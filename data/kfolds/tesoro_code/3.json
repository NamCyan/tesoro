{"id":32858,"original_code":"@Override\n  protected Collection<String> getDirectoryEntries(Path path) throws IOException {\n    \/\/ TODO(felly): Support directory traversal.\n    return ImmutableList.of();\n  }","code":"@Override\n  protected Collection<String> getDirectoryEntries(Path path) throws IOException {\n   \n    return ImmutableList.of();\n  }","cleancode":"@override protected collection<string> getdirectoryentries(path path) throws ioexception { return immutablelist.of(); }","comment":"\/\/ todo(felly): support directory traversal.","repo":"bloomberg\/bazel","code_context_2":"@Override\nprotected Collection<String> getDirectoryEntries(Path path) throws IOException {\n\/\/ TODO(felly): Support directory traversal.\nreturn ImmutableList.of();\n}","code_context_10":"@Override\nprotected Collection<String> getDirectoryEntries(Path path) throws IOException {\n\/\/ TODO(felly): Support directory traversal.\nreturn ImmutableList.of();\n}","code_context_20":"@Override\nprotected Collection<String> getDirectoryEntries(Path path) throws IOException {\n\/\/ TODO(felly): Support directory traversal.\nreturn ImmutableList.of();\n}","label":[1,0,0,0]}
{"id":8382,"original_code":"public String parseId() throws SyntaxError {\n    String value = parseArg();\n    if (argWasQuoted()) {\n      throw new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n    } else if (value == null) {\n      throw new SyntaxError(\"Expected identifier instead of 'null' for function \"  + sp);\n    }\n    return value;\n  }","code":"public String parseId() throws SyntaxError {\n    String value = parseArg();\n    if (argWasQuoted()) {\n      throw new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n    } else if (value == null) {\n      throw new SyntaxError(\"Expected identifier instead of 'null' for function \"  + sp);\n    }\n    return value;\n  }","cleancode":"public string parseid() throws syntaxerror { string value = parsearg(); if (argwasquoted()) { throw new syntaxerror(\"expected identifier instead of quoted string:\" + value); } else if (value == null) { throw new syntaxerror(\"expected identifier instead of 'null' for function \" + sp); } return value; }","comment":"\/* * todo: doc *\/","repo":"anon24816\/lucene-solr","code_context_2":"public String parseId() throws SyntaxError {\nString value = parseArg();\nif (argWasQuoted()) {\nthrow new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n} else if (value == null) {\nthrow new SyntaxError(\"Expected identifier instead of 'null' for function \" + sp);\n}\nreturn value;\n}","code_context_10":"public String parseId() throws SyntaxError {\nString value = parseArg();\nif (argWasQuoted()) {\nthrow new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n} else if (value == null) {\nthrow new SyntaxError(\"Expected identifier instead of 'null' for function \" + sp);\n}\nreturn value;\n}","code_context_20":"public String parseId() throws SyntaxError {\nString value = parseArg();\nif (argWasQuoted()) {\nthrow new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n} else if (value == null) {\nthrow new SyntaxError(\"Expected identifier instead of 'null' for function \" + sp);\n}\nreturn value;\n}","label":[0,0,0,0]}
{"id":8383,"original_code":"public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n      \/\/ nestedQuery would be null when de-referenced query value is not specified\n      \/\/ Ex: query($qq) in request with no qq param specified\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n      QParser sub;\n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          \/\/ value specified directly in local params... so the end of the\n          \/\/ query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          \/\/ value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          \/\/ int subEnd = sub.findEnd(')');\n          \/\/ TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n      sp.pos += end-start;  \/\/ advance past nested query\n      nestedQuery = sub.getQuery();\n      \/\/ handling null check on nestedQuery separately, so that proper error can be returned\n      \/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n    return nestedQuery;\n  }","code":"public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n     \n     \n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n      QParser sub;\n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n         \n         \n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n         \n          sub = subQuery(qs, null);\n         \n         \n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n      sp.pos += end-start; \n      nestedQuery = sub.getQuery();\n     \n     \n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n    return nestedQuery;\n  }","cleancode":"public query parsenestedquery() throws syntaxerror { query nestedquery; if (sp.opt(\"$\")) { string param = sp.getid(); string qstr = getparam(param); qstr = qstr==null ? \"\" : qstr; nestedquery = subquery(qstr, null).getquery(); if (nestedquery == null) { throw new syntaxerror(\"missing param \" + param + \" while parsing function '\" + sp.val + \"'\"); } } else { int start = sp.pos; string v = sp.val; string qs = v; modifiablesolrparams nestedlocalparams = new modifiablesolrparams(); int end = queryparsing.parselocalparams(qs, start, nestedlocalparams, getparams()); qparser sub; if (end>start) { if (nestedlocalparams.get(queryparsing.v) != null) { sub = subquery(qs.substring(start, end), null); } else { sub = subquery(qs, null); throw new syntaxerror(\"nested local params must have value in v parameter. got '\" + qs + \"'\"); } } else { throw new syntaxerror(\"nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\"); } sp.pos += end-start; nestedquery = sub.getquery(); if (nestedquery == null) { throw new syntaxerror(\"nested function query returned null for '\" + sp.val + \"'\"); } } consumeargumentdelimiter(); return nestedquery; }","comment":"\/* * todo: doc *\/\n\/\/ nestedquery would be null when de-referenced query value is not specified \/\/ ex: query($qq) in request with no qq param specified\n\/\/ value specified directly in local params... so the end of the \/\/ query should be the end of the local params.\n\/\/ value here is *after* the local params... ask the parser.\n\/\/ int subend = sub.findend(')'); \/\/ todo.. implement functions to find the end of a nested query\n\/\/ advance past nested query\n\/\/ handling null check on nestedquery separately, so that proper error can be returned \/\/ one case this would be possible when v is specified but v's value is empty or has only spaces","repo":"anon24816\/lucene-solr","code_context_2":"public Query parseNestedQuery() throws SyntaxError {\nQuery nestedQuery;\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");","code_context_10":"public Query parseNestedQuery() throws SyntaxError {\nQuery nestedQuery;\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\npublic Query parseNestedQuery() throws SyntaxError {\nQuery nestedQuery;\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\n\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}","code_context_20":"public Query parseNestedQuery() throws SyntaxError {\nQuery nestedQuery;\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\npublic Query parseNestedQuery() throws SyntaxError {\nQuery nestedQuery;\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\nif (sp.opt(\"$\")) {\nString param = sp.getId();\nString qstr = getParam(param);\nqstr = qstr==null ? \"\" : qstr;\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\n\nnestedQuery = subQuery(qstr, null).getQuery();\n\/\/ nestedQuery would be null when de-referenced query value is not specified\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\n\/\/ Ex: query($qq) in request with no qq param specified\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n}\n}\nelse {\nint start = sp.pos;\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\nString v = sp.val;\nString qs = v;\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}\n\nModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\nint end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\nQParser sub;\nif (end>start) {\nif (nestedLocalParams.get(QueryParsing.V) != null) {\n\/\/ value specified directly in local params... so the end of the\n\/\/ query should be the end of the local params.\nsub = subQuery(qs.substring(start, end), null);\n} else {\n\/\/ value here is *after* the local params... ask the parser.\nsub = subQuery(qs, null);\n\/\/ int subEnd = sub.findEnd(')');\n\/\/ TODO.. implement functions to find the end of a nested query\nthrow new SyntaxError(\"Nested local params must have value in v parameter. got '\" + qs + \"'\");\n}\n} else {\nthrow new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n}\nsp.pos += end-start; \/\/ advance past nested query\nnestedQuery = sub.getQuery();\n\/\/ handling null check on nestedQuery separately, so that proper error can be returned\n\/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\nif (nestedQuery == null) {\nthrow new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n}\n}\nconsumeArgumentDelimiter();\nreturn nestedQuery;\n}","label":[0,1,0,0]}
{"id":16595,"original_code":"public void testPrint() throws Exception {\n        Map map = new HashMap();\n        map.put(\"bob\", \"drools\");\n        map.put(\"james\", \"geronimo\");\n        List list = new ArrayList();\n        list.add(map);\n        \/** @todo fix this! *\/\n        \/\/assertConsoleOutput(list, \"[['bob':'drools', 'james':'geronimo']]\");\n    }","code":"public void testPrint() throws Exception {\n        Map map = new HashMap();\n        map.put(\"bob\", \"drools\");\n        map.put(\"james\", \"geronimo\");\n        List list = new ArrayList();\n        list.add(map);\n       \n       \n    }","cleancode":"public void testprint() throws exception { map map = new hashmap(); map.put(\"bob\", \"drools\"); map.put(\"james\", \"geronimo\"); list list = new arraylist(); list.add(map); }","comment":"\/** @todo fix this! *\/ \/\/assertconsoleoutput(list, \"[['bob':'drools', 'james':'geronimo']]\");","repo":"chanwit\/groovy","code_context_2":"List list = new ArrayList();\nlist.add(map);\n\/** @todo fix this! *\/\n\/\/assertConsoleOutput(list, \"[['bob':'drools', 'james':'geronimo']]\");\n}","code_context_10":"public void testPrint() throws Exception {\nMap map = new HashMap();\nmap.put(\"bob\", \"drools\");\nmap.put(\"james\", \"geronimo\");\nList list = new ArrayList();\nlist.add(map);\n\/** @todo fix this! *\/\n\/\/assertConsoleOutput(list, \"[['bob':'drools', 'james':'geronimo']]\");\n}","code_context_20":"public void testPrint() throws Exception {\nMap map = new HashMap();\nmap.put(\"bob\", \"drools\");\nmap.put(\"james\", \"geronimo\");\nList list = new ArrayList();\nlist.add(map);\n\/** @todo fix this! *\/\n\/\/assertConsoleOutput(list, \"[['bob':'drools', 'james':'geronimo']]\");\n}","label":[0,0,1,0]}
{"id":8514,"original_code":"public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            for (String name : ALWAYS_READABLE_PATHS) {\n                if (rest.startsWith(name)) {\n                    return this;\n                }\n            }\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\n                    return this;\n                }\n            }\n            \/\/ TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n                && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\n                return this;\n            }\n            throw e;\n        }\n        return this;\n    }","code":"public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            for (String name : ALWAYS_READABLE_PATHS) {\n                if (rest.startsWith(name)) {\n                    return this;\n                }\n            }\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\n                    return this;\n                }\n            }\n           \n            if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n                && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\n                return this;\n            }\n            throw e;\n        }\n        return this;\n    }","cleancode":"public object gettarget() { try { checkpermission(read); } catch (accessdeniedexception e) { string rest = stapler.getcurrentrequest().getrestofpath(); for (string name : always_readable_paths) { if (rest.startswith(name)) { return this; } } for (string name : getunprotectedrootactions()) { if (rest.startswith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) { return this; } } if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\") && \"true\".equals(stapler.getcurrentrequest().getparameter(\"encrypt\"))) { return this; } throw e; } return this; }","comment":"\/\/ todo slavecomputer.doslaveagentjnlp; there should be an annotation to request unprotected access","repo":"codemonkey77\/jenkins","code_context_2":"}\n}\n\/\/ TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\nif (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n&& \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {","code_context_10":"for (String name : ALWAYS_READABLE_PATHS) {\nif (rest.startsWith(name)) {\nreturn this;\n}\n}\nfor (String name : getUnprotectedRootActions()) {\nif (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\nreturn this;\n}\n}\n\/\/ TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\nif (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n&& \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\nreturn this;\n}\nthrow e;\n}\nreturn this;\n}","code_context_20":"public Object getTarget() {\ntry {\ncheckPermission(READ);\n} catch (AccessDeniedException e) {\nString rest = Stapler.getCurrentRequest().getRestOfPath();\nfor (String name : ALWAYS_READABLE_PATHS) {\nif (rest.startsWith(name)) {\nreturn this;\n}\n}\nfor (String name : getUnprotectedRootActions()) {\nif (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\nreturn this;\n}\n}\n\/\/ TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\nif (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n&& \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\nreturn this;\n}\nthrow e;\n}\nreturn this;\n}","label":[1,0,0,0]}
{"id":24924,"original_code":"public ObjectiveFunctionInterface getObjectiveFunction(){\n\t\treturn this.oObjectiveFunction;\n\t}","code":"public ObjectiveFunctionInterface getObjectiveFunction(){\n\t\treturn this.oObjectiveFunction;\n\t}","cleancode":"public objectivefunctioninterface getobjectivefunction(){ return this.oobjectivefunction; }","comment":"\/** * todo implement any common functionality here so that your * heuristics can reuse them! * e.g. you may want to implement the swapping of two delivery locations here! *\/","repo":"cmyxt502\/aim-project-2020","code_context_2":"public ObjectiveFunctionInterface getObjectiveFunction(){\nreturn this.oObjectiveFunction;\n}","code_context_10":"public ObjectiveFunctionInterface getObjectiveFunction(){\nreturn this.oObjectiveFunction;\n}","code_context_20":"public ObjectiveFunctionInterface getObjectiveFunction(){\nreturn this.oObjectiveFunction;\n}","label":[0,1,0,0]}
{"id":16806,"original_code":"@Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n            Bundle args = getArguments();\n            TierCategory category = (TierCategory) args.getSerializable(\"category\");\n            String tier = args.getString(\"tier\");\n            \/\/ Inflate the layout for this fragment\n            View view = inflater.inflate(R.layout.fragment_tier_list, container, false);\n            LinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\n            try {\/\/TODO: see if we can be more error-tolerance\n                myTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return view;\n        }","code":"@Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n            Bundle args = getArguments();\n            TierCategory category = (TierCategory) args.getSerializable(\"category\");\n            String tier = args.getString(\"tier\");\n           \n            View view = inflater.inflate(R.layout.fragment_tier_list, container, false);\n            LinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\n            try \n                myTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return view;\n        }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { bundle args = getarguments(); tiercategory category = (tiercategory) args.getserializable(\"category\"); string tier = args.getstring(\"tier\"); view view = inflater.inflate(r.layout.fragment_tier_list, container, false); linearlayout layout = (linearlayout) view.findviewbyid(r.id.tier_layout); try mytask = new populatetiertableasynctask(getactivity(), layout, category).execute(tier); } catch (exception e) { e.printstacktrace(); } return view; }","comment":"\/\/ inflate the layout for this fragment\n\/\/todo: see if we can be more error-tolerance","repo":"chinhodado\/BBDB","code_context_2":"TierCategory category = (TierCategory) args.getSerializable(\"category\");\nString tier = args.getString(\"tier\");\n\/\/ Inflate the layout for this fragment\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\n\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\ntry {\/\/TODO: see if we can be more error-tolerance\nmyTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n} catch (Exception e) {","code_context_10":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\nBundle args = getArguments();\nTierCategory category = (TierCategory) args.getSerializable(\"category\");\nString tier = args.getString(\"tier\");\n\/\/ Inflate the layout for this fragment\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\ntry {\/\/TODO: see if we can be more error-tolerance\nmyTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn view;\n}\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\nBundle args = getArguments();\nTierCategory category = (TierCategory) args.getSerializable(\"category\");\nString tier = args.getString(\"tier\");\n\/\/ Inflate the layout for this fragment\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\ntry {\/\/TODO: see if we can be more error-tolerance\nmyTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn view;\n}","code_context_20":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\nBundle args = getArguments();\nTierCategory category = (TierCategory) args.getSerializable(\"category\");\nString tier = args.getString(\"tier\");\n\/\/ Inflate the layout for this fragment\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\ntry {\/\/TODO: see if we can be more error-tolerance\nmyTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn view;\n}\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\nBundle args = getArguments();\nTierCategory category = (TierCategory) args.getSerializable(\"category\");\nString tier = args.getString(\"tier\");\n\/\/ Inflate the layout for this fragment\nView view = inflater.inflate(R.layout.fragment_tier_list, container, false);\nLinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\ntry {\/\/TODO: see if we can be more error-tolerance\nmyTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn view;\n}","label":[1,0,0,0]}
{"id":16807,"original_code":"@Override\n        protected void onPostExecute(Void param) {\n            if (pageDOM == null) {\n                return; \/\/ instead of try-catch\n            }\n            Elements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n            \/\/ calculate the width of the images to be displayed later on\n            Display display = activity.getWindowManager().getDefaultDisplay();\n            Point size = new Point();\n            display.getSize(size);\n            int screenWidth = size.x;\n            int scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\n            int tableIndex = tierMap.get(category).get(tier);\n            Element tierTable = tierTables.get(tableIndex);\n            TableLayout table = new TableLayout(activity);\n            Elements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\n            int countRow = 0;\n            for (Element row : rows) {\n                countRow++;\n                if (countRow == 1) {\n                    \/\/ row 1 is the column headers. This may be different in the DOM in browser\n                    continue;\n                }\n                else {\n                    Elements cells = row.getElementsByTag(\"td\");\n                    TableRow tr = new TableRow(activity);\n                    ImageView imgView = new ImageView(activity); tr.addView(imgView);\n                    \/\/ get the thubnail image src\n                    Element link = row.getElementsByTag(\"a\").first();\n                    String imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\n                    if (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\n                    imgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\n                    imgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n                    \/\/ get the scaled image link and display it\n                    String newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\n                    ImageLoader.getInstance().displayImage(newScaledLink, imgView);\n                    String famName = cells.get(2).text();\n                    TextView tv = new TextView(activity);\n                    tv.setText(famName);\n                    tr.addView(tv);\n                    tr.setGravity(0x10); \/\/center vertical\n                    table.addView(tr);\n                    tr.setTag(famName);\n                    tr.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            Intent intent = new Intent(activity, FamDetailActivity.class);\n                            intent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\n                            activity.startActivity(intent);\n                        }\n                    });\n                }\n            }\n            layout.addView(table);\n            \/\/TODO: center the spinner horizontally\n            \/\/remove the spinner\n            ProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\n            layout.removeView(progressBar);\n        }","code":"@Override\n        protected void onPostExecute(Void param) {\n            if (pageDOM == null) {\n                return;\n            }\n            Elements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n           \n            Display display = activity.getWindowManager().getDefaultDisplay();\n            Point size = new Point();\n            display.getSize(size);\n            int screenWidth = size.x;\n            int scaleWidth = screenWidth \/ 10;\n            int tableIndex = tierMap.get(category).get(tier);\n            Element tierTable = tierTables.get(tableIndex);\n            TableLayout table = new TableLayout(activity);\n            Elements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\");\n            int countRow = 0;\n            for (Element row : rows) {\n                countRow++;\n                if (countRow == 1) {\n                   \n                    continue;\n                }\n                else {\n                    Elements cells = row.getElementsByTag(\"td\");\n                    TableRow tr = new TableRow(activity);\n                    ImageView imgView = new ImageView(activity); tr.addView(imgView);\n                   \n                    Element link = row.getElementsByTag(\"a\").first();\n                    String imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\n                    if (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\n                    imgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5)));\n                    imgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n                   \n                    String newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\n                    ImageLoader.getInstance().displayImage(newScaledLink, imgView);\n                    String famName = cells.get(2).text();\n                    TextView tv = new TextView(activity);\n                    tv.setText(famName);\n                    tr.addView(tv);\n                    tr.setGravity(0x10);\n                    table.addView(tr);\n                    tr.setTag(famName);\n                    tr.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            Intent intent = new Intent(activity, FamDetailActivity.class);\n                            intent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\n                            activity.startActivity(intent);\n                        }\n                    });\n                }\n            }\n            layout.addView(table);\n           \n           \n            ProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\n            layout.removeView(progressBar);\n        }","cleancode":"@override protected void onpostexecute(void param) { if (pagedom == null) { return; } elements tiertables = pagedom.getelementsbyclass(\"wikitable\"); display display = activity.getwindowmanager().getdefaultdisplay(); point size = new point(); display.getsize(size); int screenwidth = size.x; int scalewidth = screenwidth \/ 10; int tableindex = tiermap.get(category).get(tier); element tiertable = tiertables.get(tableindex); tablelayout table = new tablelayout(activity); elements rows = tiertable.getelementsbytag(\"tbody\").first().getelementsbytag(\"tr\"); int countrow = 0; for (element row : rows) { countrow++; if (countrow == 1) { continue; } else { elements cells = row.getelementsbytag(\"td\"); tablerow tr = new tablerow(activity); imageview imgview = new imageview(activity); tr.addview(imgview); element link = row.getelementsbytag(\"a\").first(); string imgsrc = link.getelementsbytag(\"img\").first().attr(\"data-src\"); if (imgsrc == null || imgsrc.equals(\"\")) imgsrc = link.getelementsbytag(\"img\").first().attr(\"src\"); imgview.setlayoutparams(new tablerow.layoutparams(scalewidth, (int) (scalewidth*1.5))); imgview.setscaletype(imageview.scaletype.fit_center); string newscaledlink = util.getscaledwikiaimagelink(imgsrc, scalewidth); imageloader.getinstance().displayimage(newscaledlink, imgview); string famname = cells.get(2).text(); textview tv = new textview(activity); tv.settext(famname); tr.addview(tv); tr.setgravity(0x10); table.addview(tr); tr.settag(famname); tr.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(activity, famdetailactivity.class); intent.putextra(mainactivity.fam_name, (string) v.gettag()); activity.startactivity(intent); } }); } } layout.addview(table); progressbar progressbar = (progressbar) activity.findviewbyid(r.id.progressbar_tiertable); layout.removeview(progressbar); }","comment":"\/\/ instead of try-catch\n\/\/ calculate the width of the images to be displayed later on\n\/\/ set it to be 1\/10 of the screen width\n\/\/ get all rows in each table\n\/\/ row 1 is the column headers. this may be different in the dom in browser\n\/\/ get the thubnail image src\n\/\/ the height's not exact\n\/\/ get the scaled image link and display it\n\/\/center vertical\n\/\/todo: center the spinner horizontally \/\/remove the spinner","repo":"chinhodado\/BBDB","code_context_2":"protected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\n\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\n\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\n\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\n\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\n\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\n\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\n\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\n\n}\nlayout.addView(table);\n\/\/TODO: center the spinner horizontally\n\/\/remove the spinner\nProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\nlayout.removeView(progressBar);","code_context_10":"@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\n\n@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\n\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\n\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\n\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\n\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\n\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n}\n}\nlayout.addView(table);\n\/\/TODO: center the spinner horizontally\n\/\/remove the spinner\nProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\nlayout.removeView(progressBar);\n}","code_context_20":"@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\n\n@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\n@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\n\n@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\n\n@Override\nprotected void onPostExecute(Void param) {\nif (pageDOM == null) {\nreturn; \/\/ instead of try-catch\n}\nElements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n\/\/ calculate the width of the images to be displayed later on\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\n\nDisplay display = activity.getWindowManager().getDefaultDisplay();\nPoint size = new Point();\ndisplay.getSize(size);\nint screenWidth = size.x;\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\n\nint scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\nint tableIndex = tierMap.get(category).get(tier);\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n}\n\nElement tierTable = tierTables.get(tableIndex);\nTableLayout table = new TableLayout(activity);\nElements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\nint countRow = 0;\nfor (Element row : rows) {\ncountRow++;\nif (countRow == 1) {\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n}\n}\nlayout.addView(table);\n\n\/\/ row 1 is the column headers. This may be different in the DOM in browser\ncontinue;\n}\nelse {\nElements cells = row.getElementsByTag(\"td\");\nTableRow tr = new TableRow(activity);\nImageView imgView = new ImageView(activity); tr.addView(imgView);\n\/\/ get the thubnail image src\nElement link = row.getElementsByTag(\"a\").first();\nString imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\nif (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\nimgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\nimgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n\/\/ get the scaled image link and display it\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n}\n}\nlayout.addView(table);\n\/\/TODO: center the spinner horizontally\n\/\/remove the spinner\nProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\nlayout.removeView(progressBar);\n}\n\nString newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\nImageLoader.getInstance().displayImage(newScaledLink, imgView);\nString famName = cells.get(2).text();\nTextView tv = new TextView(activity);\ntv.setText(famName);\ntr.addView(tv);\ntr.setGravity(0x10); \/\/center vertical\ntable.addView(tr);\ntr.setTag(famName);\ntr.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(activity, FamDetailActivity.class);\nintent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\nactivity.startActivity(intent);\n}\n});\n}\n}\nlayout.addView(table);\n\/\/TODO: center the spinner horizontally\n\/\/remove the spinner\nProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\nlayout.removeView(progressBar);\n}","label":[0,1,0,0]}
{"id":33203,"original_code":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\n        Method method = descriptor.getWriteMethod();\n        if (method != null) {\n            \/\/ TODO should we handle the property.name() attribute?\n            \/\/ maybe add this to XBean code generator...\n            Property property = method.getAnnotation(Property.class);\n            if (property != null) {\n                if (property.required()) {\n                    \/\/ TODO use property.name()?\n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n            Reference reference = method.getAnnotation(Reference.class);\n            if (reference != null) {\n                if (reference.required()) {\n                    \/\/ TODO use reference.name()?\n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n        }\n    }","code":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\n        Method method = descriptor.getWriteMethod();\n        if (method != null) {\n           \n           \n            Property property = method.getAnnotation(Property.class);\n            if (property != null) {\n                if (property.required()) {\n                   \n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n            Reference reference = method.getAnnotation(Reference.class);\n            if (reference != null) {\n                if (reference.required()) {\n                   \n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n        }\n    }","cleancode":"protected void processproperty(string beanname, beandefinition definition, propertydescriptor descriptor) throws beansexception { method method = descriptor.getwritemethod(); if (method != null) { property property = method.getannotation(property.class); if (property != null) { if (property.required()) { string propertyname = descriptor.getname(); mutablepropertyvalues propertyvalues = definition.getpropertyvalues(); if (!propertyvalues.contains(propertyname)) { throw new beaninitializationexception(\"mandatory property: \" + propertyname + \" not specified on bean: \" + beanname); } } } reference reference = method.getannotation(reference.class); if (reference != null) { if (reference.required()) { string propertyname = descriptor.getname(); mutablepropertyvalues propertyvalues = definition.getpropertyvalues(); if (!propertyvalues.contains(propertyname)) { throw new beaninitializationexception(\"mandatory reference: \" + propertyname + \" not specified on bean: \" + beanname); } } } } }","comment":"\/\/ todo should we handle the property.name() attribute? \/\/ maybe add this to xbean code generator...\n\/\/ todo use property.name()?\n\/\/ todo use reference.name()?","repo":"codehaus\/xbean","code_context_2":"Method method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\n\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\n\nif (reference != null) {\nif (reference.required()) {\n\/\/ TODO use reference.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();","code_context_10":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\nMethod method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n\nprotected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\nMethod method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\nReference reference = method.getAnnotation(Reference.class);\nif (reference != null) {\nif (reference.required()) {\n\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\nReference reference = method.getAnnotation(Reference.class);\nif (reference != null) {\nif (reference.required()) {\n\/\/ TODO use reference.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\n}\n}","code_context_20":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\nMethod method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\nReference reference = method.getAnnotation(Reference.class);\nif (reference != null) {\nif (reference.required()) {\n\/\/ TODO use reference.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n\nprotected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\nMethod method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\nReference reference = method.getAnnotation(Reference.class);\nif (reference != null) {\nif (reference.required()) {\n\/\/ TODO use reference.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\n}\n}\n\nprotected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\nMethod method = descriptor.getWriteMethod();\nif (method != null) {\n\/\/ TODO should we handle the property.name() attribute?\n\/\/ maybe add this to XBean code generator...\nProperty property = method.getAnnotation(Property.class);\nif (property != null) {\nif (property.required()) {\n\/\/ TODO use property.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\nReference reference = method.getAnnotation(Reference.class);\nif (reference != null) {\nif (reference.required()) {\n\/\/ TODO use reference.name()?\nString propertyName = descriptor.getName();\nMutablePropertyValues propertyValues = definition.getPropertyValues();\nif (!propertyValues.contains(propertyName)) {\nthrow new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n}\n}\n}\n}\n}","label":[1,0,0,0]}
{"id":16856,"original_code":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\n        if (pathElems.isEmpty()) return null;\n        List<String> bestTrail = null;\n        for(List<String> trail : possibleTrails) {\n            if (pathElems.size() > trail.size()) continue; \/\/ sure to fail\n            ListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\n            ListIterator<String> tit = trail.listIterator(trail.size());\n            boolean matched = true;\n            while(matched && pit.hasPrevious()) {\n                AltUrlPartResults urlInfos = pit.previous();\n                String categoryId = tit.previous();\n                \/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\n                if (!urlInfos.containsKey(categoryId)) {\n                    matched = false;\n                }\n            }\n            if (matched) {\n                if (trail.size() == pathElems.size()) { \/\/ ideal case\n                    bestTrail = trail;\n                    break;\n                } else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\n                    bestTrail = trail;\n                }\n            }\n        }\n        return bestTrail;\n    }","code":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\n        if (pathElems.isEmpty()) return null;\n        List<String> bestTrail = null;\n        for(List<String> trail : possibleTrails) {\n            if (pathElems.size() > trail.size()) continue;\n            ListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\n            ListIterator<String> tit = trail.listIterator(trail.size());\n            boolean matched = true;\n            while(matched && pit.hasPrevious()) {\n                AltUrlPartResults urlInfos = pit.previous();\n                String categoryId = tit.previous();\n               \n                if (!urlInfos.containsKey(categoryId)) {\n                    matched = false;\n                }\n            }\n            if (matched) {\n                if (trail.size() == pathElems.size()) {\n                    bestTrail = trail;\n                    break;\n                } else if (bestTrail == null || trail.size() < bestTrail.size()) {\n                    bestTrail = trail;\n                }\n            }\n        }\n        return bestTrail;\n    }","cleancode":"protected list<string> findbesttrailforurlpathelems(delegator delegator, list<list<string>> possibletrails, list<alturlpartresults> pathelems) throws genericentityexception { if (pathelems.isempty()) return null; list<string> besttrail = null; for(list<string> trail : possibletrails) { if (pathelems.size() > trail.size()) continue; listiterator<alturlpartresults> pit = pathelems.listiterator(pathelems.size()); listiterator<string> tit = trail.listiterator(trail.size()); boolean matched = true; while(matched && pit.hasprevious()) { alturlpartresults urlinfos = pit.previous(); string categoryid = tit.previous(); if (!urlinfos.containskey(categoryid)) { matched = false; } } if (matched) { if (trail.size() == pathelems.size()) { besttrail = trail; break; } else if (besttrail == null || trail.size() < besttrail.size()) { besttrail = trail; } } } return besttrail; }","comment":"\/** * uses the passed path elements (resolved) to try to select the best of the possible trails. * returns null only if nothing matches at all. * best-effort. * <p> * todo: review: the possibility of each path elem matching multiple category ids makes this extremely * complicated; so we ignore the specific implications and just match as much as possible. * <p> * for a trail to be selected, it must \"end with\" the pathelems; after that, the best trail is one that * has smallest length. *\/\n\/\/ sure to fail\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\n\/\/ ideal case\n\/\/ smaller = better","repo":"codesbyzhangpeng\/scipio-erp","code_context_2":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\n\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}","code_context_10":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nprotected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}","code_context_20":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nprotected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\n\nprotected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nprotected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}\n\nprotected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\nif (pathElems.isEmpty()) return null;\nList<String> bestTrail = null;\nfor(List<String> trail : possibleTrails) {\nif (pathElems.size() > trail.size()) continue; \/\/ sure to fail\nListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\nListIterator<String> tit = trail.listIterator(trail.size());\nboolean matched = true;\nwhile(matched && pit.hasPrevious()) {\nAltUrlPartResults urlInfos = pit.previous();\nString categoryId = tit.previous();\n\/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\nif (!urlInfos.containsKey(categoryId)) {\nmatched = false;\n}\n}\nif (matched) {\nif (trail.size() == pathElems.size()) { \/\/ ideal case\nbestTrail = trail;\nbreak;\n} else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\nbestTrail = trail;\n}\n}\n}\nreturn bestTrail;\n}","label":[1,0,0,0]}
{"id":16860,"original_code":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\n        return ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n    }","code":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\n        return ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n    }","cleancode":"protected list<list<string>> getproductrolluptrails(delegator delegator, string productid, set<string> topcategoryids) { return productworker.getproductrolluptrails(delegator, productid, topcategoryids, true); }","comment":"\/** * return all paths from the given topcategoryids to the product. * <p> * todo?: perhaps can cache with utilcache in future, or read from a cached category tree. *\/","repo":"codesbyzhangpeng\/scipio-erp","code_context_2":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\nreturn ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n}","code_context_10":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\nreturn ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n}","code_context_20":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\nreturn ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n}","label":[0,1,0,0]}
{"id":16861,"original_code":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\n        return CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n    }","code":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\n        return CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n    }","cleancode":"protected list<list<string>> getcategoryrolluptrails(delegator delegator, string productcategoryid, set<string> topcategoryids) { return categoryworker.getcategoryrolluptrails(delegator, productcategoryid, topcategoryids, true); }","comment":"\/** * return all paths from the given topcategoryids to the category. * <p> * todo?: perhaps can cache with utilcache in future, or read from a cached category tree. *\/","repo":"codesbyzhangpeng\/scipio-erp","code_context_2":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\nreturn CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n}","code_context_10":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\nreturn CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n}","code_context_20":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\nreturn CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n}","label":[0,1,0,0]}
{"id":33286,"original_code":"@Override\n    public void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n        \/\/ Validate client version\n        if (!message.getClientVersion().equals(requiredClientVersion)) {\n            ErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\n            connection.sendMessage(error);\n            logger.info(\"Sending Client Error\");\n            return;\n        }\n        SoeAccount account = accountService.validateSession(message.getToken());\n        if (account == null) {\n            ErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\n            connection.sendMessage(error);\n            logger.info(\"Invalid Session: \" + message.getToken());\n            return;\n        }\n        connection.setAccountId(account.getId());\n        connection.setAccountUsername(account.getUsername());\n        connection.addRole(ConnectionRole.AUTHENTICATED);\n        \/\/ TODO: Actually implement permissions\n        ClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\n        connection.sendMessage(cpm);\n    }","code":"@Override\n    public void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n       \n        if (!message.getClientVersion().equals(requiredClientVersion)) {\n            ErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\n            connection.sendMessage(error);\n            logger.info(\"Sending Client Error\");\n            return;\n        }\n        SoeAccount account = accountService.validateSession(message.getToken());\n        if (account == null) {\n            ErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\n            connection.sendMessage(error);\n            logger.info(\"Invalid Session: \" + message.getToken());\n            return;\n        }\n        connection.setAccountId(account.getId());\n        connection.setAccountUsername(account.getUsername());\n        connection.addRole(ConnectionRole.AUTHENTICATED);\n       \n        ClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\n        connection.sendMessage(cpm);\n    }","cleancode":"@override public void handleincoming(soeudpconnection connection, clientidmsg message) throws exception { if (!message.getclientversion().equals(requiredclientversion)) { errormessage error = new errormessage(\"login error\", \"the client you are attempting to connect with does not match that required by the server.\", false); connection.sendmessage(error); logger.info(\"sending client error\"); return; } soeaccount account = accountservice.validatesession(message.gettoken()); if (account == null) { errormessage error = new errormessage(\"error\", \"invalid session\", false); connection.sendmessage(error); logger.info(\"invalid session: \" + message.gettoken()); return; } connection.setaccountid(account.getid()); connection.setaccountusername(account.getusername()); connection.addrole(connectionrole.authenticated); clientpermissionsmessage cpm = new clientpermissionsmessage(true, true, true, true); connection.sendmessage(cpm); }","comment":"\/\/ validate client version\n\/\/ todo: actually implement permissions","repo":"bacta\/cu","code_context_2":"@Override\npublic void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n\/\/ Validate client version\nif (!message.getClientVersion().equals(requiredClientVersion)) {\nErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\n\nconnection.setAccountUsername(account.getUsername());\nconnection.addRole(ConnectionRole.AUTHENTICATED);\n\/\/ TODO: Actually implement permissions\nClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\nconnection.sendMessage(cpm);","code_context_10":"@Override\npublic void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n\/\/ Validate client version\nif (!message.getClientVersion().equals(requiredClientVersion)) {\nErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\nconnection.sendMessage(error);\nlogger.info(\"Sending Client Error\");\nreturn;\n}\nSoeAccount account = accountService.validateSession(message.getToken());\nif (account == null) {\nErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\nconnection.sendMessage(error);\n\nSoeAccount account = accountService.validateSession(message.getToken());\nif (account == null) {\nErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\nconnection.sendMessage(error);\nlogger.info(\"Invalid Session: \" + message.getToken());\nreturn;\n}\nconnection.setAccountId(account.getId());\nconnection.setAccountUsername(account.getUsername());\nconnection.addRole(ConnectionRole.AUTHENTICATED);\n\/\/ TODO: Actually implement permissions\nClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\nconnection.sendMessage(cpm);\n}","code_context_20":"@Override\npublic void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n\/\/ Validate client version\nif (!message.getClientVersion().equals(requiredClientVersion)) {\nErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\nconnection.sendMessage(error);\nlogger.info(\"Sending Client Error\");\nreturn;\n}\nSoeAccount account = accountService.validateSession(message.getToken());\nif (account == null) {\nErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\nconnection.sendMessage(error);\nlogger.info(\"Invalid Session: \" + message.getToken());\nreturn;\n}\nconnection.setAccountId(account.getId());\nconnection.setAccountUsername(account.getUsername());\nconnection.addRole(ConnectionRole.AUTHENTICATED);\n\/\/ TODO: Actually implement permissions\nClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\nconnection.sendMessage(cpm);\n}\n\n@Override\npublic void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n\/\/ Validate client version\nif (!message.getClientVersion().equals(requiredClientVersion)) {\nErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\nconnection.sendMessage(error);\nlogger.info(\"Sending Client Error\");\nreturn;\n}\nSoeAccount account = accountService.validateSession(message.getToken());\nif (account == null) {\nErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\nconnection.sendMessage(error);\nlogger.info(\"Invalid Session: \" + message.getToken());\nreturn;\n}\nconnection.setAccountId(account.getId());\nconnection.setAccountUsername(account.getUsername());\nconnection.addRole(ConnectionRole.AUTHENTICATED);\n\/\/ TODO: Actually implement permissions\nClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\nconnection.sendMessage(cpm);\n}","label":[0,1,0,0]}
{"id":25102,"original_code":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\n      final Stream<OWLAnnotation> annos) {\n    \/\/ Need a method in the OWL API to get Annotation by URI...\n    final Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\n    final AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\n    annos.forEach(anno -> {\n      final OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\n      if (prop != null && anno.getValue().asLiteral().isPresent()) {\n        final String literal = anno.getValue().asLiteral().get().getLiteral();\n        final OWLAxiom ax = factory\n            .getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\n        axioms.add(ax);\n      } else {\n        if (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\n          final OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n              .map(this::getSkosScheme).orElse(skosConceptScheme);\n          axioms.add(factory.\n              getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\n          inSchemeAdded.set(true);\n        } else if (includeUnmappedProperties) {\n          \/\/ for all other annotation axioms, just add them as they are\n          axioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n        }\n      }\n    });\n    \/\/ ensure inScheme is set. we need it, so set to default if missing\n    if (!inSchemeAdded.get()) {\n      axioms.add(factory.\n          getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n    }\n    \/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n    \/\/ want to use SKOS note to keep the original OBO identifier.\n    final String frag = concept.getIRI().getFragment();\n    final String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\n    axioms.add(factory.getOWLDataPropertyAssertionAxiom(\n        factory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n  }","code":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\n      final Stream<OWLAnnotation> annos) {\n   \n    final Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\n    final AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\n    annos.forEach(anno -> {\n      final OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\n      if (prop != null && anno.getValue().asLiteral().isPresent()) {\n        final String literal = anno.getValue().asLiteral().get().getLiteral();\n        final OWLAxiom ax = factory\n            .getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\n        axioms.add(ax);\n      } else {\n        if (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\n          final OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n              .map(this::getSkosScheme).orElse(skosConceptScheme);\n          axioms.add(factory.\n              getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\n          inSchemeAdded.set(true);\n        } else if (includeUnmappedProperties) {\n         \n          axioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n        }\n      }\n    });\n   \n    if (!inSchemeAdded.get()) {\n      axioms.add(factory.\n          getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n    }\n   \n   \n    final String frag = concept.getIRI().getFragment();\n    final String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\n    axioms.add(factory.getOWLDataPropertyAssertionAxiom(\n        factory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n  }","cleancode":"private void addskosdataproperties(final owlnamedindividual concept, final stream<owlannotation> annos) { final map<iri, owldataproperty> annomap = mapper.getannotationmap(); final atomicboolean inschemeadded = new atomicboolean(false); annos.foreach(anno -> { final owldataproperty prop = annomap.get(anno.getproperty().getiri()); if (prop != null && anno.getvalue().asliteral().ispresent()) { final string literal = anno.getvalue().asliteral().get().getliteral(); final owlaxiom ax = factory .getowldatapropertyassertionaxiom(prop, concept, factory.getowlliteral(literal, \"en\")); axioms.add(ax); } else { if (obo2owlvocabulary.iri_oio_hasobonamespace.sameiri(anno.getproperty())) { final owlindividual scheme = anno.getvalue().asliteral().map(owlliteral::getliteral) .map(this::getskosscheme).orelse(skosconceptscheme); axioms.add(factory. getowlobjectpropertyassertionaxiom(inschemeproperty, concept, scheme)); inschemeadded.set(true); } else if (includeunmappedproperties) { axioms.add(factory.getowlannotationassertionaxiom(concept.getiri(), anno)); } } }); if (!inschemeadded.get()) { axioms.add(factory. getowlobjectpropertyassertionaxiom(inschemeproperty, concept, skosconceptscheme)); } final string frag = concept.getiri().getfragment(); final string oboid = underscore.matcher(frag).replacefirst(\":\"); axioms.add(factory.getowldatapropertyassertionaxiom( factory.getowldataproperty(skosvocabulary.note), concept, oboid)); }","comment":"\/\/ need a method in the owl api to get annotation by uri...\n\/\/ for all other annotation axioms, just add them as they are\n\/\/ ensure inscheme is set. we need it, so set to default if missing\n\/\/ this is an after thought, whole script needs re-writing if i were to do this properly anyway \/\/ want to use skos note to keep the original obo identifier.","repo":"autayeu\/obo2skos","code_context_2":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\nfinal Stream<OWLAnnotation> annos) {\n\/\/ Need a method in the OWL API to get Annotation by URI...\nfinal Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\nfinal AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\n\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\n\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");","code_context_10":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\nfinal Stream<OWLAnnotation> annos) {\n\/\/ Need a method in the OWL API to get Annotation by URI...\nfinal Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\nfinal AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\nannos.forEach(anno -> {\nfinal OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\nif (prop != null && anno.getValue().asLiteral().isPresent()) {\nfinal String literal = anno.getValue().asLiteral().get().getLiteral();\nfinal OWLAxiom ax = factory\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\n\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\nif (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\nfinal OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\naxioms.add(factory.getOWLDataPropertyAssertionAxiom(\nfactory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\naxioms.add(factory.getOWLDataPropertyAssertionAxiom(\nfactory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n}","code_context_20":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\nfinal Stream<OWLAnnotation> annos) {\n\/\/ Need a method in the OWL API to get Annotation by URI...\nfinal Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\nfinal AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\nannos.forEach(anno -> {\nfinal OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\nif (prop != null && anno.getValue().asLiteral().isPresent()) {\nfinal String literal = anno.getValue().asLiteral().get().getLiteral();\nfinal OWLAxiom ax = factory\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\nif (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\nfinal OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n\nprivate void addSKOSDataProperties(final OWLNamedIndividual concept,\nfinal Stream<OWLAnnotation> annos) {\n\/\/ Need a method in the OWL API to get Annotation by URI...\nfinal Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\nfinal AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\nannos.forEach(anno -> {\nfinal OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\nif (prop != null && anno.getValue().asLiteral().isPresent()) {\nfinal String literal = anno.getValue().asLiteral().get().getLiteral();\nfinal OWLAxiom ax = factory\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\nif (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\nfinal OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\naxioms.add(factory.getOWLDataPropertyAssertionAxiom(\nfactory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n}\n\nannos.forEach(anno -> {\nfinal OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\nif (prop != null && anno.getValue().asLiteral().isPresent()) {\nfinal String literal = anno.getValue().asLiteral().get().getLiteral();\nfinal OWLAxiom ax = factory\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\nif (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\nfinal OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\naxioms.add(factory.getOWLDataPropertyAssertionAxiom(\nfactory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n}\n\n.getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\naxioms.add(ax);\n} else {\nif (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\nfinal OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n.map(this::getSkosScheme).orElse(skosConceptScheme);\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\ninSchemeAdded.set(true);\n} else if (includeUnmappedProperties) {\n\/\/ for all other annotation axioms, just add them as they are\naxioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n}\n}\n});\n\/\/ ensure inScheme is set. we need it, so set to default if missing\nif (!inSchemeAdded.get()) {\naxioms.add(factory.\ngetOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n}\n\/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n\/\/ want to use SKOS note to keep the original OBO identifier.\nfinal String frag = concept.getIRI().getFragment();\nfinal String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\naxioms.add(factory.getOWLDataPropertyAssertionAxiom(\nfactory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n}","label":[1,1,0,0]}
{"id":16966,"original_code":"@SuppressWarnings(\"deprecation\")\n\tprivate static void broadcastStateChange(String title, boolean preparing, boolean titleOrSongHaveChanged) {\n\t\tif (notificationBroadcastPending) {\n\t\t\tlocalHandler.removeMessages(MSG_BROADCAST_STATE_CHANGE);\n\t\t\tnotificationBroadcastPending = false;\n\t\t}\n\t\tfinal long now = SystemClock.uptimeMillis();\n\t\tfinal long delta = now - notificationLastUpdateTime;\n\t\tif (delta < 100 || notificationLastUpdateTime == 0) {\n\t\t\tnotificationBroadcastPending = true;\n\t\t\tlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\n\t\t\treturn;\n\t\t}\n\t\tnotificationLastUpdateTime = now;\n\t\trefreshNotification();\n\t\tWidgetMain.updateWidgets();\n\t\t\/\/\n\t\t\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\t\t\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\t\t\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\t\t\/\/\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\t\t\/\/\n\t\t\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\t\t\/\/\n\t\tif (localSong == null) {\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\n\t\t\tstickyBroadcast.removeExtra(\"id\");\n\t\t\tstickyBroadcast.removeExtra(\"songid\");\n\t\t\tstickyBroadcast.removeExtra(\"track\");\n\t\t\tstickyBroadcast.removeExtra(\"artist\");\n\t\t\tstickyBroadcast.removeExtra(\"album\");\n\t\t\tstickyBroadcast.removeExtra(\"duration\");\n\t\t\t\/\/stickyBroadcast.removeExtra(\"position\");\n\t\t\tstickyBroadcast.removeExtra(\"playing\");\n\t\t} else {\n\t\t\t\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\t\t\t\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\n\t\t\tstickyBroadcast.putExtra(\"id\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"songid\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"track\", title);\n\t\t\tstickyBroadcast.putExtra(\"artist\", localSong.artist);\n\t\t\tstickyBroadcast.putExtra(\"album\", localSong.album);\n\t\t\tstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\t\t\t\/\/stickyBroadcast.putExtra(\"position\", (long)0);\n\t\t\tstickyBroadcast.putExtra(\"playing\", localPlaying);\n\t\t}\n\t\t\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\t\t\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\n\t\ttry {\n\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n\t\t\t\tthePlayer.sendBroadcast(stickyBroadcast);\n\t\t\telse\n\t\t\t\tthePlayer.sendStickyBroadcast(stickyBroadcast);\n\t\t} catch (RuntimeException ex) {\n\t\t\t\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n\t\t}\n\t\tif (remoteControlClient != null)\n\t\t\tbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\n\t\tif (mediaSession != null)\n\t\t\tbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n\t}","code":"@SuppressWarnings(\"deprecation\")\n\tprivate static void broadcastStateChange(String title, boolean preparing, boolean titleOrSongHaveChanged) {\n\t\tif (notificationBroadcastPending) {\n\t\t\tlocalHandler.removeMessages(MSG_BROADCAST_STATE_CHANGE);\n\t\t\tnotificationBroadcastPending = false;\n\t\t}\n\t\tfinal long now = SystemClock.uptimeMillis();\n\t\tfinal long delta = now - notificationLastUpdateTime;\n\t\tif (delta < 100 || notificationLastUpdateTime == 0) {\n\t\t\tnotificationBroadcastPending = true;\n\t\t\tlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\n\t\t\treturn;\n\t\t}\n\t\tnotificationLastUpdateTime = now;\n\t\trefreshNotification();\n\t\tWidgetMain.updateWidgets();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tif (localSong == null) {\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\n\t\t\tstickyBroadcast.removeExtra(\"id\");\n\t\t\tstickyBroadcast.removeExtra(\"songid\");\n\t\t\tstickyBroadcast.removeExtra(\"track\");\n\t\t\tstickyBroadcast.removeExtra(\"artist\");\n\t\t\tstickyBroadcast.removeExtra(\"album\");\n\t\t\tstickyBroadcast.removeExtra(\"duration\");\n\t\t\n\t\t\tstickyBroadcast.removeExtra(\"playing\");\n\t\t} else {\n\t\t\n\t\t\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\n\t\t\tstickyBroadcast.putExtra(\"id\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"songid\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"track\", title);\n\t\t\tstickyBroadcast.putExtra(\"artist\", localSong.artist);\n\t\t\tstickyBroadcast.putExtra(\"album\", localSong.album);\n\t\t\tstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\t\t\n\t\t\tstickyBroadcast.putExtra(\"playing\", localPlaying);\n\t\t}\n\t\n\t\n\t\ttry {\n\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n\t\t\t\tthePlayer.sendBroadcast(stickyBroadcast);\n\t\t\telse\n\t\t\t\tthePlayer.sendStickyBroadcast(stickyBroadcast);\n\t\t} catch (RuntimeException ex) {\n\t\t\n\t\t}\n\t\tif (remoteControlClient != null)\n\t\t\tbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\n\t\tif (mediaSession != null)\n\t\t\tbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n\t}","cleancode":"@suppresswarnings(\"deprecation\") private static void broadcaststatechange(string title, boolean preparing, boolean titleorsonghavechanged) { if (notificationbroadcastpending) { localhandler.removemessages(msg_broadcast_state_change); notificationbroadcastpending = false; } final long now = systemclock.uptimemillis(); final long delta = now - notificationlastupdatetime; if (delta < 100 || notificationlastupdatetime == 0) { notificationbroadcastpending = true; localhandler.sendmessageattime(message.obtain(localhandler, msg_broadcast_state_change, (preparing ? 0x01 : 0) | (titleorsonghavechanged ? 0x02 : 0), 0, title), (notificationlastupdatetime == 0 ? ((notificationlastupdatetime = now) + 2000) : (notificationlastupdatetime + 110 - delta))); return; } notificationlastupdatetime = now; refreshnotification(); widgetmain.updatewidgets(); if (localsong == null) { stickybroadcast.setaction(\"com.android.music.playbackcomplete\"); stickybroadcast.removeextra(\"id\"); stickybroadcast.removeextra(\"songid\"); stickybroadcast.removeextra(\"track\"); stickybroadcast.removeextra(\"artist\"); stickybroadcast.removeextra(\"album\"); stickybroadcast.removeextra(\"duration\"); stickybroadcast.removeextra(\"playing\"); } else { stickybroadcast.setaction(\"com.android.music.playstatechanged\"); stickybroadcast.putextra(\"id\", localsong.id); stickybroadcast.putextra(\"songid\", localsong.id); stickybroadcast.putextra(\"track\", title); stickybroadcast.putextra(\"artist\", localsong.artist); stickybroadcast.putextra(\"album\", localsong.album); stickybroadcast.putextra(\"duration\", (long)localsong.lengthms); stickybroadcast.putextra(\"playing\", localplaying); } try { if (build.version.sdk_int >= build.version_codes.lollipop) theplayer.sendbroadcast(stickybroadcast); else theplayer.sendstickybroadcast(stickybroadcast); } catch (runtimeexception ex) { } if (remotecontrolclient != null) broadcaststatechangetoremotecontrol(title, preparing, titleorsonghavechanged); if (mediasession != null) broadcaststatechangetomediasession(title, preparing, titleorsonghavechanged); }","comment":"\/\/ \/\/perhaps, one day we should implement remotecontrolclient for better bluetooth support...? \/\/http:\/\/developer.android.com\/reference\/android\/media\/remotecontrolclient.html \/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/music\/+\/master\/src\/com\/android\/music\/mediaplaybackservice.java \/\/ \/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp \/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song \/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info \/\/ \/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/avrcp.java \/\/\n\/\/stickybroadcast.removeextra(\"position\");\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged.... \/\/stickybroadcast.setaction(playbackhaschanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\n\/\/stickybroadcast.putextra(\"position\", (long)0);\n\/\/ maybe check if api >= 21, and if so, use sendbroadcast instead.....??? \/\/ https:\/\/developer.android.com\/reference\/android\/content\/context#sendstickybroadcast(android.content.intent)\n\/\/just ignore because most apps actually use remotecontrolclient on newer androids","repo":"carlosrafaelgn\/FPlayAndroid","code_context_2":"refreshNotification();\nWidgetMain.updateWidgets();\n\/\/\n\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\/\/\n\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\/\/\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\n\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\n\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)","code_context_10":"final long now = SystemClock.uptimeMillis();\nfinal long delta = now - notificationLastUpdateTime;\nif (delta < 100 || notificationLastUpdateTime == 0) {\nnotificationBroadcastPending = true;\nlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\nreturn;\n}\nnotificationLastUpdateTime = now;\nrefreshNotification();\nWidgetMain.updateWidgets();\n\/\/\n\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\/\/\n\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\/\/\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\n\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)\nbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\n\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)\nbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\nif (mediaSession != null)\nbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n}","code_context_20":"@SuppressWarnings(\"deprecation\")\nprivate static void broadcastStateChange(String title, boolean preparing, boolean titleOrSongHaveChanged) {\nif (notificationBroadcastPending) {\nlocalHandler.removeMessages(MSG_BROADCAST_STATE_CHANGE);\nnotificationBroadcastPending = false;\n}\nfinal long now = SystemClock.uptimeMillis();\nfinal long delta = now - notificationLastUpdateTime;\nif (delta < 100 || notificationLastUpdateTime == 0) {\nnotificationBroadcastPending = true;\nlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\nreturn;\n}\nnotificationLastUpdateTime = now;\nrefreshNotification();\nWidgetMain.updateWidgets();\n\/\/\n\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\/\/\n\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\/\/\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\nWidgetMain.updateWidgets();\n\/\/\n\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\/\/\n\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\/\/\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\n\n\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\/\/\n\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\/\/\n\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\/\/\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\n\nif (localSong == null) {\nstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\nstickyBroadcast.removeExtra(\"id\");\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)\nbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\nif (mediaSession != null)\nbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n}\n\nstickyBroadcast.removeExtra(\"songid\");\nstickyBroadcast.removeExtra(\"track\");\nstickyBroadcast.removeExtra(\"artist\");\nstickyBroadcast.removeExtra(\"album\");\nstickyBroadcast.removeExtra(\"duration\");\n\/\/stickyBroadcast.removeExtra(\"position\");\nstickyBroadcast.removeExtra(\"playing\");\n} else {\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)\nbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\nif (mediaSession != null)\nbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n}\n\n\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\nstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\nstickyBroadcast.putExtra(\"id\", localSong.id);\nstickyBroadcast.putExtra(\"songid\", localSong.id);\nstickyBroadcast.putExtra(\"track\", title);\nstickyBroadcast.putExtra(\"artist\", localSong.artist);\nstickyBroadcast.putExtra(\"album\", localSong.album);\nstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\/\/stickyBroadcast.putExtra(\"position\", (long)0);\nstickyBroadcast.putExtra(\"playing\", localPlaying);\n}\n\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\ntry {\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\nthePlayer.sendBroadcast(stickyBroadcast);\nelse\nthePlayer.sendStickyBroadcast(stickyBroadcast);\n} catch (RuntimeException ex) {\n\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n}\nif (remoteControlClient != null)\nbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\nif (mediaSession != null)\nbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n}","label":[0,1,1,0]}
{"id":25223,"original_code":"public Node<N> join(Node<N> x, Node<N> y) {\n        \/\/ TODO this.majorants should return an iterator\n        SortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\n        xMajorants.add(x);\n        SortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\n        yMajorants.add(y);\n        xMajorants.retainAll(yMajorants);\n        DAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\n        TreeSet<Node> join = new TreeSet<Node>(graph.min());\n        if (join.size() == 1) {\n            return join.first();\n        }\n        return null;\n    }","code":"public Node<N> join(Node<N> x, Node<N> y) {\n       \n        SortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\n        xMajorants.add(x);\n        SortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\n        yMajorants.add(y);\n        xMajorants.retainAll(yMajorants);\n        DAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\n        TreeSet<Node> join = new TreeSet<Node>(graph.min());\n        if (join.size() == 1) {\n            return join.first();\n        }\n        return null;\n    }","cleancode":"public node<n> join(node<n> x, node<n> y) { sortedset<node<n>> xmajorants = new treeset<node<n>>(this.majorants(x)); xmajorants.add(x); sortedset<node<n>> ymajorants = new treeset<node<n>>(this.majorants(y)); ymajorants.add(y); xmajorants.retainall(ymajorants); dagraph<n, e> graph = this.getsubgraphbynodes(xmajorants); treeset<node> join = new treeset<node>(graph.min()); if (join.size() == 1) { return join.first(); } return null; }","comment":"\/** * returns the join of the two specified nodes if it exists. * * @param x the first node * @param y the second node * * @return the node which is at the join of the nodes or null if it does not * exist * * @todo this.majorants should return an iterator *\/\n\/\/ todo this.majorants should return an iterator","repo":"chdemko\/java-lattices","code_context_2":"public Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);\nSortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\nyMajorants.add(y);\nxMajorants.retainAll(yMajorants);\nDAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\nTreeSet<Node> join = new TreeSet<Node>(graph.min());\nif (join.size() == 1) {\nreturn join.first();\n}\nreturn null;\n}\n\npublic Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);","code_context_10":"public Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);\nSortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\nyMajorants.add(y);\nxMajorants.retainAll(yMajorants);\nDAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\nTreeSet<Node> join = new TreeSet<Node>(graph.min());\nif (join.size() == 1) {\nreturn join.first();\n}\nreturn null;\n}\n\npublic Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);\nSortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\nyMajorants.add(y);\nxMajorants.retainAll(yMajorants);\nDAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\nTreeSet<Node> join = new TreeSet<Node>(graph.min());\nif (join.size() == 1) {\nreturn join.first();\n}","code_context_20":"public Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);\nSortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\nyMajorants.add(y);\nxMajorants.retainAll(yMajorants);\nDAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\nTreeSet<Node> join = new TreeSet<Node>(graph.min());\nif (join.size() == 1) {\nreturn join.first();\n}\nreturn null;\n}\n\npublic Node<N> join(Node<N> x, Node<N> y) {\n\/\/ TODO this.majorants should return an iterator\nSortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\nxMajorants.add(x);\nSortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\nyMajorants.add(y);\nxMajorants.retainAll(yMajorants);\nDAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\nTreeSet<Node> join = new TreeSet<Node>(graph.min());\nif (join.size() == 1) {\nreturn join.first();\n}\nreturn null;\n}","label":[1,0,0,0]}
{"id":8840,"original_code":"public static void resetData(BitbucketTestedProduct stash) {\n        YaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n                .loginAsSysAdmin(YaccRepoSettingsPage.class);\n        settingsPage.clickEditYacc()\n                .clearSettings();\n        settingsPage.clickSubmit();\n        settingsPage.clickDisable();\n        YaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\n        globalSettingsPage.clearSettings();\n        globalSettingsPage.clickSubmit();\n        stash.getTester().getDriver().manage().deleteAllCookies();\n    }","code":"public static void resetData(BitbucketTestedProduct stash) {\n        YaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n                .loginAsSysAdmin(YaccRepoSettingsPage.class);\n        settingsPage.clickEditYacc()\n                .clearSettings();\n        settingsPage.clickSubmit();\n        settingsPage.clickDisable();\n        YaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\n        globalSettingsPage.clearSettings();\n        globalSettingsPage.clickSubmit();\n        stash.getTester().getDriver().manage().deleteAllCookies();\n    }","cleancode":"public static void resetdata(bitbuckettestedproduct stash) { yaccreposettingspage settingspage = stash.visit(bitbucketloginpage.class) .loginassysadmin(yaccreposettingspage.class); settingspage.clickedityacc() .clearsettings(); settingspage.clicksubmit(); settingspage.clickdisable(); yaccglobalsettingspage globalsettingspage = stash.visit(yaccglobalsettingspage.class); globalsettingspage.clearsettings(); globalsettingspage.clicksubmit(); stash.gettester().getdriver().manage().deleteallcookies(); }","comment":"\/** * reset yacc settings data so that tests can start at a clean slate. * this is sort of hackish... maybe the atlassian integration test * api has a way to reset all the data? *\/","repo":"christiangalsterer\/yet-another-commit-checker","code_context_2":"public static void resetData(BitbucketTestedProduct stash) {\nYaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n.loginAsSysAdmin(YaccRepoSettingsPage.class);\nsettingsPage.clickEditYacc()\n.clearSettings();\nsettingsPage.clickSubmit();\nsettingsPage.clickDisable();\nYaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\nglobalSettingsPage.clearSettings();\nglobalSettingsPage.clickSubmit();\nstash.getTester().getDriver().manage().deleteAllCookies();\n}","code_context_10":"public static void resetData(BitbucketTestedProduct stash) {\nYaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n.loginAsSysAdmin(YaccRepoSettingsPage.class);\nsettingsPage.clickEditYacc()\n.clearSettings();\nsettingsPage.clickSubmit();\nsettingsPage.clickDisable();\nYaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\nglobalSettingsPage.clearSettings();\nglobalSettingsPage.clickSubmit();\nstash.getTester().getDriver().manage().deleteAllCookies();\n}","code_context_20":"public static void resetData(BitbucketTestedProduct stash) {\nYaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n.loginAsSysAdmin(YaccRepoSettingsPage.class);\nsettingsPage.clickEditYacc()\n.clearSettings();\nsettingsPage.clickSubmit();\nsettingsPage.clickDisable();\nYaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\nglobalSettingsPage.clearSettings();\nglobalSettingsPage.clickSubmit();\nstash.getTester().getDriver().manage().deleteAllCookies();\n}","label":[1,0,0,0]}
{"id":17204,"original_code":"public void getDagInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    Map<String, Object> dagInfo = new HashMap<String, Object>();\n    dagInfo.put(\"id\", dag.getID().toString());\n    dagInfo.put(\"progress\", Float.toString(dag.getCompletedTaskProgress()));\n    dagInfo.put(\"status\", dag.getState().toString());\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = dag.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          dagInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n      \/\/ Ignore\n      \/\/ TODO: add an error message instead for counter key\n    }\n    renderJSON(ImmutableMap.of(\n        \"dag\", dagInfo\n    ));\n  }","code":"public void getDagInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    Map<String, Object> dagInfo = new HashMap<String, Object>();\n    dagInfo.put(\"id\", dag.getID().toString());\n    dagInfo.put(\"progress\", Float.toString(dag.getCompletedTaskProgress()));\n    dagInfo.put(\"status\", dag.getState().toString());\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = dag.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          dagInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n     \n     \n    }\n    renderJSON(ImmutableMap.of(\n        \"dag\", dagInfo\n    ));\n  }","cleancode":"public void getdaginfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); map<string, object> daginfo = new hashmap<string, object>(); daginfo.put(\"id\", dag.getid().tostring()); daginfo.put(\"progress\", float.tostring(dag.getcompletedtaskprogress())); daginfo.put(\"status\", dag.getstate().tostring()); try { if (counternames != null && !counternames.isempty()) { tezcounters counters = dag.getcachedcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { daginfo.put(\"counters\", countermap); } } } catch (limitexceededexception e) { } renderjson(immutablemap.of( \"dag\", daginfo )); }","comment":"\/\/ ignore \/\/ todo: add an error message instead for counter key","repo":"chenjunbiao001\/tez","code_context_2":"}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nrenderJSON(ImmutableMap.of(","code_context_10":"dagInfo.put(\"status\", dag.getState().toString());\ntry {\nif (counterNames != null && !counterNames.isEmpty()) {\nTezCounters counters = dag.getCachedCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ndagInfo.put(\"counters\", counterMap);\n}\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nrenderJSON(ImmutableMap.of(\n\"dag\", dagInfo\n));\n}","code_context_20":"return;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nMap<String, Object> dagInfo = new HashMap<String, Object>();\ndagInfo.put(\"id\", dag.getID().toString());\ndagInfo.put(\"progress\", Float.toString(dag.getCompletedTaskProgress()));\ndagInfo.put(\"status\", dag.getState().toString());\ntry {\nif (counterNames != null && !counterNames.isEmpty()) {\nTezCounters counters = dag.getCachedCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ndagInfo.put(\"counters\", counterMap);\n}\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nrenderJSON(ImmutableMap.of(\n\"dag\", dagInfo\n));\n}","label":[0,1,0,0]}
{"id":17205,"original_code":"private Map<String, Object> getVertexInfoMap(Vertex vertex,\n                                               Map<String, Set<String>> counterNames) {\n    Map<String, Object> vertexInfo = new HashMap<String, Object>();\n    vertexInfo.put(\"id\", vertex.getVertexId().toString());\n    vertexInfo.put(\"status\", vertex.getState().toString());\n    vertexInfo.put(\"progress\", Float.toString(vertex.getCompletedTaskProgress()));\n    vertexInfo.put(\"initTime\", Long.toString(vertex.getInitTime()));\n    vertexInfo.put(\"startTime\", Long.toString(vertex.getStartTime()));\n    vertexInfo.put(\"finishTime\", Long.toString(vertex.getFinishTime()));\n    vertexInfo.put(\"firstTaskStartTime\", Long.toString(vertex.getFirstTaskStartTime()));\n    vertexInfo.put(\"lastTaskFinishTime\", Long.toString(vertex.getLastTaskFinishTime()));\n    ProgressBuilder vertexProgress = vertex.getVertexProgress();\n    vertexInfo.put(\"totalTasks\", Integer.toString(vertexProgress.getTotalTaskCount()));\n    vertexInfo.put(\"runningTasks\", Integer.toString(vertexProgress.getRunningTaskCount()));\n    vertexInfo.put(\"succeededTasks\", Integer.toString(vertexProgress.getSucceededTaskCount()));\n    vertexInfo.put(\"failedTaskAttempts\",\n        Integer.toString(vertexProgress.getFailedTaskAttemptCount()));\n    vertexInfo.put(\"killedTaskAttempts\",\n        Integer.toString(vertexProgress.getKilledTaskAttemptCount()));\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = vertex.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          vertexInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n      \/\/ Ignore\n      \/\/ TODO: add an error message instead for counter key\n    }\n    return vertexInfo;\n  }","code":"private Map<String, Object> getVertexInfoMap(Vertex vertex,\n                                               Map<String, Set<String>> counterNames) {\n    Map<String, Object> vertexInfo = new HashMap<String, Object>();\n    vertexInfo.put(\"id\", vertex.getVertexId().toString());\n    vertexInfo.put(\"status\", vertex.getState().toString());\n    vertexInfo.put(\"progress\", Float.toString(vertex.getCompletedTaskProgress()));\n    vertexInfo.put(\"initTime\", Long.toString(vertex.getInitTime()));\n    vertexInfo.put(\"startTime\", Long.toString(vertex.getStartTime()));\n    vertexInfo.put(\"finishTime\", Long.toString(vertex.getFinishTime()));\n    vertexInfo.put(\"firstTaskStartTime\", Long.toString(vertex.getFirstTaskStartTime()));\n    vertexInfo.put(\"lastTaskFinishTime\", Long.toString(vertex.getLastTaskFinishTime()));\n    ProgressBuilder vertexProgress = vertex.getVertexProgress();\n    vertexInfo.put(\"totalTasks\", Integer.toString(vertexProgress.getTotalTaskCount()));\n    vertexInfo.put(\"runningTasks\", Integer.toString(vertexProgress.getRunningTaskCount()));\n    vertexInfo.put(\"succeededTasks\", Integer.toString(vertexProgress.getSucceededTaskCount()));\n    vertexInfo.put(\"failedTaskAttempts\",\n        Integer.toString(vertexProgress.getFailedTaskAttemptCount()));\n    vertexInfo.put(\"killedTaskAttempts\",\n        Integer.toString(vertexProgress.getKilledTaskAttemptCount()));\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = vertex.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          vertexInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n     \n     \n    }\n    return vertexInfo;\n  }","cleancode":"private map<string, object> getvertexinfomap(vertex vertex, map<string, set<string>> counternames) { map<string, object> vertexinfo = new hashmap<string, object>(); vertexinfo.put(\"id\", vertex.getvertexid().tostring()); vertexinfo.put(\"status\", vertex.getstate().tostring()); vertexinfo.put(\"progress\", float.tostring(vertex.getcompletedtaskprogress())); vertexinfo.put(\"inittime\", long.tostring(vertex.getinittime())); vertexinfo.put(\"starttime\", long.tostring(vertex.getstarttime())); vertexinfo.put(\"finishtime\", long.tostring(vertex.getfinishtime())); vertexinfo.put(\"firsttaskstarttime\", long.tostring(vertex.getfirsttaskstarttime())); vertexinfo.put(\"lasttaskfinishtime\", long.tostring(vertex.getlasttaskfinishtime())); progressbuilder vertexprogress = vertex.getvertexprogress(); vertexinfo.put(\"totaltasks\", integer.tostring(vertexprogress.gettotaltaskcount())); vertexinfo.put(\"runningtasks\", integer.tostring(vertexprogress.getrunningtaskcount())); vertexinfo.put(\"succeededtasks\", integer.tostring(vertexprogress.getsucceededtaskcount())); vertexinfo.put(\"failedtaskattempts\", integer.tostring(vertexprogress.getfailedtaskattemptcount())); vertexinfo.put(\"killedtaskattempts\", integer.tostring(vertexprogress.getkilledtaskattemptcount())); try { if (counternames != null && !counternames.isempty()) { tezcounters counters = vertex.getcachedcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { vertexinfo.put(\"counters\", countermap); } } } catch (limitexceededexception e) { } return vertexinfo; }","comment":"\/\/ ignore \/\/ todo: add an error message instead for counter key","repo":"chenjunbiao001\/tez","code_context_2":"}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nreturn vertexInfo;","code_context_10":"Integer.toString(vertexProgress.getKilledTaskAttemptCount()));\ntry {\nif (counterNames != null && !counterNames.isEmpty()) {\nTezCounters counters = vertex.getCachedCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nvertexInfo.put(\"counters\", counterMap);\n}\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nreturn vertexInfo;\n}","code_context_20":"vertexInfo.put(\"finishTime\", Long.toString(vertex.getFinishTime()));\nvertexInfo.put(\"firstTaskStartTime\", Long.toString(vertex.getFirstTaskStartTime()));\nvertexInfo.put(\"lastTaskFinishTime\", Long.toString(vertex.getLastTaskFinishTime()));\nProgressBuilder vertexProgress = vertex.getVertexProgress();\nvertexInfo.put(\"totalTasks\", Integer.toString(vertexProgress.getTotalTaskCount()));\nvertexInfo.put(\"runningTasks\", Integer.toString(vertexProgress.getRunningTaskCount()));\nvertexInfo.put(\"succeededTasks\", Integer.toString(vertexProgress.getSucceededTaskCount()));\nvertexInfo.put(\"failedTaskAttempts\",\nInteger.toString(vertexProgress.getFailedTaskAttemptCount()));\nvertexInfo.put(\"killedTaskAttempts\",\nInteger.toString(vertexProgress.getKilledTaskAttemptCount()));\ntry {\nif (counterNames != null && !counterNames.isEmpty()) {\nTezCounters counters = vertex.getCachedCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nvertexInfo.put(\"counters\", counterMap);\n}\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nreturn vertexInfo;\n}","label":[0,1,0,0]}
{"id":17206,"original_code":"public void getTasksInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n      \/\/Ignore\n    }\n    List<Task> tasks = getRequestedTasks(dag, limit);\n    if(tasks == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\n    for(Task t : tasks) {\n      Map<String, Object> taskInfo = new HashMap<String, Object>();\n      taskInfo.put(\"id\", t.getTaskId().toString());\n      taskInfo.put(\"progress\", Float.toString(t.getProgress()));\n      taskInfo.put(\"status\", t.getState().toString());\n      try {\n        TezCounters counters = t.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          taskInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n        \/\/ Ignore\n        \/\/ TODO: add an error message instead for counter key\n      }\n      tasksInfo.add(taskInfo);\n    }\n    renderJSON(ImmutableMap.of(\n      \"tasks\", tasksInfo\n    ));\n  }","code":"public void getTasksInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n     \n    }\n    List<Task> tasks = getRequestedTasks(dag, limit);\n    if(tasks == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\n    for(Task t : tasks) {\n      Map<String, Object> taskInfo = new HashMap<String, Object>();\n      taskInfo.put(\"id\", t.getTaskId().toString());\n      taskInfo.put(\"progress\", Float.toString(t.getProgress()));\n      taskInfo.put(\"status\", t.getState().toString());\n      try {\n        TezCounters counters = t.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          taskInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n       \n       \n      }\n      tasksInfo.add(taskInfo);\n    }\n    renderJSON(ImmutableMap.of(\n      \"tasks\", tasksInfo\n    ));\n  }","cleancode":"public void gettasksinfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } int limit = max_queried; try { limit = getqueryparamint(webuiservice.limit); } catch (numberformatexception e) { } list<task> tasks = getrequestedtasks(dag, limit); if(tasks == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); arraylist<map<string, object>> tasksinfo = new arraylist<map<string, object>>(); for(task t : tasks) { map<string, object> taskinfo = new hashmap<string, object>(); taskinfo.put(\"id\", t.gettaskid().tostring()); taskinfo.put(\"progress\", float.tostring(t.getprogress())); taskinfo.put(\"status\", t.getstate().tostring()); try { tezcounters counters = t.getcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { taskinfo.put(\"counters\", countermap); } } catch (limitexceededexception e) { } tasksinfo.add(taskinfo); } renderjson(immutablemap.of( \"tasks\", tasksinfo )); }","comment":"\/** * renders the response json for tasksinfo api * the json will have an array of task objects under the key tasks. *\/\n\/\/ignore\n\/\/ ignore \/\/ todo: add an error message instead for counter key","repo":"chenjunbiao001\/tez","code_context_2":"public void getTasksInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);\n}\nrenderJSON(ImmutableMap.of(\n\"tasks\", tasksInfo\n));\n}\n\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\n\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);","code_context_10":"public void getTasksInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);\n}\nrenderJSON(ImmutableMap.of(\n\"tasks\", tasksInfo\n));\n}\n\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\n\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);\n}\nrenderJSON(ImmutableMap.of(\n\"tasks\", tasksInfo\n));\n}","code_context_20":"public void getTasksInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);\n}\nrenderJSON(ImmutableMap.of(\n\"tasks\", tasksInfo\n));\n}\n\npublic void getTasksInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\n\/\/Ignore\n}\nList<Task> tasks = getRequestedTasks(dag, limit);\nif(tasks == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\nfor(Task t : tasks) {\nMap<String, Object> taskInfo = new HashMap<String, Object>();\ntaskInfo.put(\"id\", t.getTaskId().toString());\ntaskInfo.put(\"progress\", Float.toString(t.getProgress()));\ntaskInfo.put(\"status\", t.getState().toString());\ntry {\nTezCounters counters = t.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\ntaskInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\ntasksInfo.add(taskInfo);\n}\nrenderJSON(ImmutableMap.of(\n\"tasks\", tasksInfo\n));\n}","label":[0,1,0,0]}
{"id":17207,"original_code":"public void getAttemptsInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n      \/\/Ignore\n    }\n    List<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\n    if(attempts == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\n    for(TaskAttempt a : attempts) {\n      Map<String, Object> attemptInfo = new HashMap<String, Object>();\n      attemptInfo.put(\"id\", a.getID().toString());\n      attemptInfo.put(\"progress\", Float.toString(a.getProgress()));\n      attemptInfo.put(\"status\", a.getState().toString());\n      try {\n        TezCounters counters = a.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          attemptInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n        \/\/ Ignore\n        \/\/ TODO: add an error message instead for counter key\n      }\n      attemptsInfo.add(attemptInfo);\n    }\n    renderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n  }","code":"public void getAttemptsInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n     \n    }\n    List<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\n    if(attempts == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\n    for(TaskAttempt a : attempts) {\n      Map<String, Object> attemptInfo = new HashMap<String, Object>();\n      attemptInfo.put(\"id\", a.getID().toString());\n      attemptInfo.put(\"progress\", Float.toString(a.getProgress()));\n      attemptInfo.put(\"status\", a.getState().toString());\n      try {\n        TezCounters counters = a.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          attemptInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n       \n       \n      }\n      attemptsInfo.add(attemptInfo);\n    }\n    renderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n  }","cleancode":"public void getattemptsinfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } int limit = max_queried; try { limit = getqueryparamint(webuiservice.limit); } catch (numberformatexception e) { } list<taskattempt> attempts = getrequestedattempts(dag, limit); if(attempts == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); arraylist<map<string, object>> attemptsinfo = new arraylist<map<string, object>>(); for(taskattempt a : attempts) { map<string, object> attemptinfo = new hashmap<string, object>(); attemptinfo.put(\"id\", a.getid().tostring()); attemptinfo.put(\"progress\", float.tostring(a.getprogress())); attemptinfo.put(\"status\", a.getstate().tostring()); try { tezcounters counters = a.getcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { attemptinfo.put(\"counters\", countermap); } } catch (limitexceededexception e) { } attemptsinfo.add(attemptinfo); } renderjson(immutablemap.of(\"attempts\", attemptsinfo)); }","comment":"\/** * renders the response json for attemptsinfo api * the json will have an array of attempt objects under the key attempts. *\/\n\/\/ignore\n\/\/ ignore \/\/ todo: add an error message instead for counter key","repo":"chenjunbiao001\/tez","code_context_2":"public void getAttemptsInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);\n}\nrenderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n}\n\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\n\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);","code_context_10":"public void getAttemptsInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);\n}\nrenderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n}\n\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\n\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);\n}\nrenderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n}","code_context_20":"public void getAttemptsInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);\n}\nrenderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n}\n\npublic void getAttemptsInfo() {\nif (!setupResponse()) {\nreturn;\n}\nDAG dag = checkAndGetDAGFromRequest();\nif (dag == null) {\nreturn;\n}\nint limit = MAX_QUERIED;\ntry {\nlimit = getQueryParamInt(WebUIService.LIMIT);\n} catch (NumberFormatException e) {\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\n\/\/Ignore\n}\nList<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\nif(attempts == null) {\nreturn;\n}\nMap<String, Set<String>> counterNames = getCounterListFromRequest();\nArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\nfor(TaskAttempt a : attempts) {\nMap<String, Object> attemptInfo = new HashMap<String, Object>();\nattemptInfo.put(\"id\", a.getID().toString());\nattemptInfo.put(\"progress\", Float.toString(a.getProgress()));\nattemptInfo.put(\"status\", a.getState().toString());\ntry {\nTezCounters counters = a.getCounters();\nMap<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\nif (counterMap != null && !counterMap.isEmpty()) {\nattemptInfo.put(\"counters\", counterMap);\n}\n} catch (LimitExceededException e) {\n\/\/ Ignore\n\/\/ TODO: add an error message instead for counter key\n}\nattemptsInfo.add(attemptInfo);\n}\nrenderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n}","label":[0,1,0,0]}
{"id":824,"original_code":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\n\t\t\tthrows DIDResolveException {\n\t\tlog.debug(\"Resolving untrusted DID {}...\", did.toString());\n\t\tif (resolveHandle != null) {\n\t\t\tDIDDocument doc = resolveHandle.resolve(did);\n\t\t\tif (doc != null)\n\t\t\t\treturn doc;\n\t\t}\n\t\tDIDBiography bio = resolveDidBiography(did, false, force);\n\t\tDIDTransaction tx = null;\n\t\tswitch (bio.getStatus()) {\n\t\tcase VALID:\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tbreak;\n\t\tcase DEACTIVATED:\n\t\t\tif (bio.size() != 2)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\n\t\t\tDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\n\t\t\tif (doc == null)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\n\t\t\ttx = bio.getTransaction(1);\n\t\t\tbreak;\n\t\tcase NOT_FOUND:\n\t\t\treturn null;\n\t\t}\n\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\n\t\t\tthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\t\t\/\/ NOTICE: Make a copy from DIDBackend cache.\n\t\t\/\/ \t\t   Avoid share same DIDDocument instance between DIDBackend\n\t\t\/\/         cache and DIDStore cache.\n\t\tDIDDocument doc = tx.getRequest().getDocument().clone();\n\t\tDIDMetadata metadata = doc.getMetadata();\n\t\tmetadata.setTransactionId(tx.getTransactionId());\n\t\tmetadata.setSignature(doc.getProof().getSignature());\n\t\tmetadata.setPublishTime(tx.getTimestamp());\n\t\tif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\n\t\t\tmetadata.setDeactivated(true);\n\t\treturn doc;\n\t}","code":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\n\t\t\tthrows DIDResolveException {\n\t\tlog.debug(\"Resolving untrusted DID {}...\", did.toString());\n\t\tif (resolveHandle != null) {\n\t\t\tDIDDocument doc = resolveHandle.resolve(did);\n\t\t\tif (doc != null)\n\t\t\t\treturn doc;\n\t\t}\n\t\tDIDBiography bio = resolveDidBiography(did, false, force);\n\t\tDIDTransaction tx = null;\n\t\tswitch (bio.getStatus()) {\n\t\tcase VALID:\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tbreak;\n\t\tcase DEACTIVATED:\n\t\t\tif (bio.size() != 2)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\n\t\t\tDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\n\t\t\tif (doc == null)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\n\t\t\ttx = bio.getTransaction(1);\n\t\t\tbreak;\n\t\tcase NOT_FOUND:\n\t\t\treturn null;\n\t\t}\n\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\n\t\t\tthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\t\n\t\n\t\n\t\tDIDDocument doc = tx.getRequest().getDocument().clone();\n\t\tDIDMetadata metadata = doc.getMetadata();\n\t\tmetadata.setTransactionId(tx.getTransactionId());\n\t\tmetadata.setSignature(doc.getProof().getSignature());\n\t\tmetadata.setPublishTime(tx.getTimestamp());\n\t\tif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\n\t\t\tmetadata.setDeactivated(true);\n\t\treturn doc;\n\t}","cleancode":"public diddocument resolveuntrusteddid(did did, boolean force) throws didresolveexception { log.debug(\"resolving untrusted did {}...\", did.tostring()); if (resolvehandle != null) { diddocument doc = resolvehandle.resolve(did); if (doc != null) return doc; } didbiography bio = resolvedidbiography(did, false, force); didtransaction tx = null; switch (bio.getstatus()) { case valid: tx = bio.gettransaction(0); break; case deactivated: if (bio.size() != 2) throw new didresolveexception(\"invalid did biography, wrong transaction count.\"); tx = bio.gettransaction(0); if (tx.getrequest().getoperation() != idchainrequest.operation.deactivate) throw new didresolveexception(\"invalid did biography, wrong status.\"); diddocument doc = bio.gettransaction(1).getrequest().getdocument(); if (doc == null) throw new didresolveexception(\"invalid did biography, invalid trancations.\"); tx = bio.gettransaction(1); break; case not_found: return null; } if (tx.getrequest().getoperation() != idchainrequest.operation.create && tx.getrequest().getoperation() != idchainrequest.operation.update && tx.getrequest().getoperation() != idchainrequest.operation.transfer) throw new didresolveexception(\"invalid id transaction, unknown operation.\"); diddocument doc = tx.getrequest().getdocument().clone(); didmetadata metadata = doc.getmetadata(); metadata.settransactionid(tx.gettransactionid()); metadata.setsignature(doc.getproof().getsignature()); metadata.setpublishtime(tx.gettimestamp()); if (bio.getstatus() == didbiography.status.deactivated) metadata.setdeactivated(true); return doc; }","comment":"\/** * resolve the specific did in untrusted mode, internal use only. * * @param did the did object to be resolve * @param force ignore the local cache and resolve from the id chain if true; * try to use cache first if false. * @return the diddocument object * @throws didresolveexception if an error occurred when resolving did *\/ \/\/ todo: to be remove in the future\n\/\/ notice: make a copy from didbackend cache. \/\/ avoid share same diddocument instance between didbackend \/\/ cache and didstore cache.","repo":"chenyukaola\/Elastos.DID.Java.SDK","code_context_2":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\nthrows DIDResolveException {\nlog.debug(\"Resolving untrusted DID {}...\", did.toString());\nif (resolveHandle != null) {\nDIDDocument doc = resolveHandle.resolve(did);\nif (doc != null)\nreturn doc;\n}\nDIDBiography bio = resolveDidBiography(did, false, force);\nDIDTransaction tx = null;\nswitch (bio.getStatus()) {\ncase VALID:\ntx = bio.getTransaction(0);\nbreak;\ncase DEACTIVATED:\nif (bio.size() != 2)\nthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\ntx = bio.getTransaction(0);\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\nthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\nDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\nif (doc == null)\nthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\ntx = bio.getTransaction(1);\nbreak;\ncase NOT_FOUND:\nreturn null;\n}\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();\nmetadata.setTransactionId(tx.getTransactionId());\nmetadata.setSignature(doc.getProof().getSignature());\nmetadata.setPublishTime(tx.getTimestamp());\nif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\nmetadata.setDeactivated(true);\nreturn doc;\n}\n\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();","code_context_10":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\nthrows DIDResolveException {\nlog.debug(\"Resolving untrusted DID {}...\", did.toString());\nif (resolveHandle != null) {\nDIDDocument doc = resolveHandle.resolve(did);\nif (doc != null)\nreturn doc;\n}\nDIDBiography bio = resolveDidBiography(did, false, force);\nDIDTransaction tx = null;\nswitch (bio.getStatus()) {\ncase VALID:\ntx = bio.getTransaction(0);\nbreak;\ncase DEACTIVATED:\nif (bio.size() != 2)\nthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\ntx = bio.getTransaction(0);\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\nthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\nDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\nif (doc == null)\nthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\ntx = bio.getTransaction(1);\nbreak;\ncase NOT_FOUND:\nreturn null;\n}\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();\nmetadata.setTransactionId(tx.getTransactionId());\nmetadata.setSignature(doc.getProof().getSignature());\nmetadata.setPublishTime(tx.getTimestamp());\nif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\nmetadata.setDeactivated(true);\nreturn doc;\n}\n\nthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\ntx = bio.getTransaction(1);\nbreak;\ncase NOT_FOUND:\nreturn null;\n}\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();\nmetadata.setTransactionId(tx.getTransactionId());\nmetadata.setSignature(doc.getProof().getSignature());\nmetadata.setPublishTime(tx.getTimestamp());\nif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\nmetadata.setDeactivated(true);\nreturn doc;\n}","code_context_20":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\nthrows DIDResolveException {\nlog.debug(\"Resolving untrusted DID {}...\", did.toString());\nif (resolveHandle != null) {\nDIDDocument doc = resolveHandle.resolve(did);\nif (doc != null)\nreturn doc;\n}\nDIDBiography bio = resolveDidBiography(did, false, force);\nDIDTransaction tx = null;\nswitch (bio.getStatus()) {\ncase VALID:\ntx = bio.getTransaction(0);\nbreak;\ncase DEACTIVATED:\nif (bio.size() != 2)\nthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\ntx = bio.getTransaction(0);\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\nthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\nDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\nif (doc == null)\nthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\ntx = bio.getTransaction(1);\nbreak;\ncase NOT_FOUND:\nreturn null;\n}\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();\nmetadata.setTransactionId(tx.getTransactionId());\nmetadata.setSignature(doc.getProof().getSignature());\nmetadata.setPublishTime(tx.getTimestamp());\nif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\nmetadata.setDeactivated(true);\nreturn doc;\n}\n\ntx = bio.getTransaction(0);\nbreak;\ncase DEACTIVATED:\nif (bio.size() != 2)\nthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\ntx = bio.getTransaction(0);\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\nthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\nDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\nif (doc == null)\nthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\ntx = bio.getTransaction(1);\nbreak;\ncase NOT_FOUND:\nreturn null;\n}\nif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\ntx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\nthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\/\/ NOTICE: Make a copy from DIDBackend cache.\n\/\/ Avoid share same DIDDocument instance between DIDBackend\n\/\/ cache and DIDStore cache.\nDIDDocument doc = tx.getRequest().getDocument().clone();\nDIDMetadata metadata = doc.getMetadata();\nmetadata.setTransactionId(tx.getTransactionId());\nmetadata.setSignature(doc.getProof().getSignature());\nmetadata.setPublishTime(tx.getTimestamp());\nif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\nmetadata.setDeactivated(true);\nreturn doc;\n}","label":[1,0,0,0]}
{"id":1011,"original_code":"@Override\n    protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\n      ImmutableList.Builder<String> builder = ImmutableList.builder();\n      builder.addAll(commandPrefix);\n      builder.add(\"compile\");\n      builder.add(\"--legacy\"); \/\/ TODO(dreiss): Maybe make this an option?\n      builder.add(\"-o\");\n      builder.add(outputPath.toString());\n      builder.add(\"--dir\");\n      builder.add(resDirPath.toString());\n      return builder.build();\n    }","code":"@Override\n    protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\n      ImmutableList.Builder<String> builder = ImmutableList.builder();\n      builder.addAll(commandPrefix);\n      builder.add(\"compile\");\n      builder.add(\"--legacy\");\n      builder.add(\"-o\");\n      builder.add(outputPath.toString());\n      builder.add(\"--dir\");\n      builder.add(resDirPath.toString());\n      return builder.build();\n    }","cleancode":"@override protected immutablelist<string> getshellcommandinternal(executioncontext context) { immutablelist.builder<string> builder = immutablelist.builder(); builder.addall(commandprefix); builder.add(\"compile\"); builder.add(\"--legacy\"); builder.add(\"-o\"); builder.add(outputpath.tostring()); builder.add(\"--dir\"); builder.add(resdirpath.tostring()); return builder.build(); }","comment":"\/\/ todo(dreiss): maybe make this an option?","repo":"chancila\/buck","code_context_2":"builder.addAll(commandPrefix);\nbuilder.add(\"compile\");\nbuilder.add(\"--legacy\"); \/\/ TODO(dreiss): Maybe make this an option?\nbuilder.add(\"-o\");\nbuilder.add(outputPath.toString());","code_context_10":"@Override\nprotected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\nImmutableList.Builder<String> builder = ImmutableList.builder();\nbuilder.addAll(commandPrefix);\nbuilder.add(\"compile\");\nbuilder.add(\"--legacy\"); \/\/ TODO(dreiss): Maybe make this an option?\nbuilder.add(\"-o\");\nbuilder.add(outputPath.toString());\nbuilder.add(\"--dir\");\nbuilder.add(resDirPath.toString());\nreturn builder.build();\n}","code_context_20":"@Override\nprotected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\nImmutableList.Builder<String> builder = ImmutableList.builder();\nbuilder.addAll(commandPrefix);\nbuilder.add(\"compile\");\nbuilder.add(\"--legacy\"); \/\/ TODO(dreiss): Maybe make this an option?\nbuilder.add(\"-o\");\nbuilder.add(outputPath.toString());\nbuilder.add(\"--dir\");\nbuilder.add(resDirPath.toString());\nreturn builder.build();\n}","label":[1,0,0,0]}
{"id":25614,"original_code":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\n    checkState(\n        stageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\n    checkState(\n        stateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\n    OutputReceiverFactory receiverFactory =\n        new OutputReceiverFactory() {\n          @Override\n          public FnDataReceiver<OutputT> create(String pCollectionId) {\n            return (receivedElement) -> {\n              \/\/ handover to queue, do not block the grpc thread\n              outputQueue.put(KV.of(pCollectionId, receivedElement));\n            };\n          }\n        };\n    try (RemoteBundle bundle =\n        stageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\n      logger.debug(String.format(\"Sending value: %s\", element));\n      \/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\n      Iterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n      \/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n    }\n    \/\/ RemoteBundle close blocks until all results are received\n    KV<String, OutputT> result;\n    while ((result = outputQueue.poll()) != null) {\n      outputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n    }\n  }","code":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\n    checkState(\n        stageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\n    checkState(\n        stateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\n    OutputReceiverFactory receiverFactory =\n        new OutputReceiverFactory() {\n          @Override\n          public FnDataReceiver<OutputT> create(String pCollectionId) {\n            return (receivedElement) -> {\n             \n              outputQueue.put(KV.of(pCollectionId, receivedElement));\n            };\n          }\n        };\n    try (RemoteBundle bundle =\n        stageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\n      logger.debug(String.format(\"Sending value: %s\", element));\n     \n      Iterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n     \n    }\n   \n    KV<String, OutputT> result;\n    while ((result = outputQueue.poll()) != null) {\n      outputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n    }\n  }","cleancode":"private void processelementwithsdkharness(windowedvalue<inputt> element) throws exception { checkstate( stagebundlefactory != null, \"%s not yet prepared\", stagebundlefactory.class.getname()); checkstate( staterequesthandler != null, \"%s not yet prepared\", staterequesthandler.class.getname()); outputreceiverfactory receiverfactory = new outputreceiverfactory() { @override public fndatareceiver<outputt> create(string pcollectionid) { return (receivedelement) -> { outputqueue.put(kv.of(pcollectionid, receivedelement)); }; } }; try (remotebundle bundle = stagebundlefactory.getbundle(receiverfactory, staterequesthandler, progresshandler)) { logger.debug(string.format(\"sending value: %s\", element)); iterables.getonlyelement(bundle.getinputreceivers().values()).accept(element); } kv<string, outputt> result; while ((result = outputqueue.poll()) != null) { outputmanager.output(outputmap.get(result.getkey()), (windowedvalue) result.getvalue()); } }","comment":"\/\/ todo: currently assumes that every element is a separate bundle, \/\/ but this can be changed by pushing some of this logic into the \"dofnrunner\"\n\/\/ handover to queue, do not block the grpc thread\n\/\/ todo(beam-4681): add support to flink to support portable timers.\n\/\/ todo: it would be nice to emit results as they arrive, can thread wait non-blocking?\n\/\/ remotebundle close blocks until all results are received","repo":"chinasaur\/beam","code_context_2":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\n\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {","code_context_10":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\nprivate void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}","code_context_20":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\nprivate void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\nprivate void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\nprivate void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\ncheckState(\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}\n\nstageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\ncheckState(\nstateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\nOutputReceiverFactory receiverFactory =\nnew OutputReceiverFactory() {\n@Override\npublic FnDataReceiver<OutputT> create(String pCollectionId) {\nreturn (receivedElement) -> {\n\/\/ handover to queue, do not block the grpc thread\noutputQueue.put(KV.of(pCollectionId, receivedElement));\n};\n}\n};\ntry (RemoteBundle bundle =\nstageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\nlogger.debug(String.format(\"Sending value: %s\", element));\n\/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\nIterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n\/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n}\n\/\/ RemoteBundle close blocks until all results are received\nKV<String, OutputT> result;\nwhile ((result = outputQueue.poll()) != null) {\noutputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n}\n}","label":[1,1,0,0]}
{"id":9325,"original_code":"public static AuthorizationHandler getAuthZHandler() {\n        return (AuthenticationData authN) -> {\n            try {\n                \/\/framework checks for null authN so this shouldn't happen\n                if (authN == null) {\n                    throw new RuntimeException(\"Null AuthN data passed in!\");\n                }\n                \/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n                \/\/to open\/inspect\n                if (authN instanceof ClientNameAuthenicationData) {\n                    final ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n                    \/\/WARNING!!! this logic is for demonstration purposes\n                    final String identityLabel = data.getIdentityLabel();\n                    return identityLabel.startsWith(\"accepted.\") ?\n                            Authorization.ACCEPT : Authorization.REJECT;\n                }\n                \/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\n                System.err.println(\"AuthN data type is not expected object type!\");\n                return Authorization.REJECT;\n            } catch (Exception e) {\n                return Authorization.REJECT;\n            }\n        };\n    }","code":"public static AuthorizationHandler getAuthZHandler() {\n        return (AuthenticationData authN) -> {\n            try {\n               \n                if (authN == null) {\n                    throw new RuntimeException(\"Null AuthN data passed in!\");\n                }\n               \n               \n                if (authN instanceof ClientNameAuthenicationData) {\n                    final ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n                   \n                    final String identityLabel = data.getIdentityLabel();\n                    return identityLabel.startsWith(\"accepted.\") ?\n                            Authorization.ACCEPT : Authorization.REJECT;\n                }\n               \n                System.err.println(\"AuthN data type is not expected object type!\");\n                return Authorization.REJECT;\n            } catch (Exception e) {\n                return Authorization.REJECT;\n            }\n        };\n    }","cleancode":"public static authorizationhandler getauthzhandler() { return (authenticationdata authn) -> { try { if (authn == null) { throw new runtimeexception(\"null authn data passed in!\"); } if (authn instanceof clientnameauthenicationdata) { final clientnameauthenicationdata data = (clientnameauthenicationdata) authn; final string identitylabel = data.getidentitylabel(); return identitylabel.startswith(\"accepted.\") ? authorization.accept : authorization.reject; } system.err.println(\"authn data type is not expected object type!\"); return authorization.reject; } catch (exception e) { return authorization.reject; } }; }","comment":"\/\/framework checks for null authn so this shouldn't happen\n\/\/check if the authn data type matches is a good idea, and necessary if there are other fields \/\/to open\/inspect\n\/\/warning!!! this logic is for demonstration purposes\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand","repo":"bgklika\/aws-iot-device-sdk-java-v2","code_context_2":"return (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\n\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;","code_context_10":"public static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\n\npublic static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n};\n}","code_context_20":"public static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n};\n}\n\npublic static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n};\n}\n\npublic static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n};\n}\n\npublic static AuthorizationHandler getAuthZHandler() {\nreturn (AuthenticationData authN) -> {\ntry {\n\/\/framework checks for null authN so this shouldn't happen\nif (authN == null) {\nthrow new RuntimeException(\"Null AuthN data passed in!\");\n}\n\/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n\/\/to open\/inspect\nif (authN instanceof ClientNameAuthenicationData) {\nfinal ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n\/\/WARNING!!! this logic is for demonstration purposes\nfinal String identityLabel = data.getIdentityLabel();\nreturn identityLabel.startsWith(\"accepted.\") ?\nAuthorization.ACCEPT : Authorization.REJECT;\n}\n\/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\nSystem.err.println(\"AuthN data type is not expected object type!\");\nreturn Authorization.REJECT;\n} catch (Exception e) {\nreturn Authorization.REJECT;\n}\n};\n}","label":[1,0,0,0]}
{"id":17543,"original_code":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n        \/\/ Don't register read-only classes\n        if (isClassReadOnly(object.getClass(), descriptor)) {\n            return null;\n        }\n        \/\/ Check if the working copy is again being registered in which case we return the same working copy\n        Object registeredObject = getCloneMapping().get(object);\n        if (registeredObject != null) {\n            return object;\n        }\n        \/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being \n        \/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects \n        \/\/ PERF: Avoid initialization of new objects if none.\n        if (hasNewObjects()) {\n            registeredObject = getNewObjectsOriginalToClone().get(object);\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        if (this.isNestedUnitOfWork) {\n            \/\/ bug # 3228185\n            \/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n            \/\/if it has already been registered locally\n            if (hasNewObjectsInParentOriginalToClone()) {\n                registeredObject = getNewObjectsInParentOriginalToClone().get(object);\n            }\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        return null;\n    }","code":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n       \n        if (isClassReadOnly(object.getClass(), descriptor)) {\n            return null;\n        }\n       \n        Object registeredObject = getCloneMapping().get(object);\n        if (registeredObject != null) {\n            return object;\n        }\n       \n       \n       \n        if (hasNewObjects()) {\n            registeredObject = getNewObjectsOriginalToClone().get(object);\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        if (this.isNestedUnitOfWork) {\n           \n           \n           \n            if (hasNewObjectsInParentOriginalToClone()) {\n                registeredObject = getNewObjectsInParentOriginalToClone().get(object);\n            }\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        return null;\n    }","cleancode":"public object checkifalreadyregistered(object object, classdescriptor descriptor) { if (isclassreadonly(object.getclass(), descriptor)) { return null; } object registeredobject = getclonemapping().get(object); if (registeredobject != null) { return object; } if (hasnewobjects()) { registeredobject = getnewobjectsoriginaltoclone().get(object); if (registeredobject != null) { return registeredobject; } } if (this.isnestedunitofwork) { if (hasnewobjectsinparentoriginaltoclone()) { registeredobject = getnewobjectsinparentoriginaltoclone().get(object); } if (registeredobject != null) { return registeredobject; } } return null; }","comment":"\/** * internal: * return the value of the object if it already is registered, otherwise null. *\/\n\/\/ don't register read-only classes\n\/\/ check if the working copy is again being registered in which case we return the same working copy\n\/\/ check if object exists in my new objects if it is in the new objects cache then it means domain object is being \/\/ re-registered and we should return the same working clone. this check holds only for the new registered objects \/\/ perf: avoid initialization of new objects if none.\n\/\/ bug # 3228185 \/\/may be a new object from a parent unit of work, let's check our new object in parent list to see \/\/if it has already been registered locally","repo":"chenjiafan\/eclipselink","code_context_2":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\n\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\n\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);","code_context_10":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\n\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}","code_context_20":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}\n\npublic Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n\/\/ Don't register read-only classes\nif (isClassReadOnly(object.getClass(), descriptor)) {\nreturn null;\n}\n\/\/ Check if the working copy is again being registered in which case we return the same working copy\nObject registeredObject = getCloneMapping().get(object);\nif (registeredObject != null) {\nreturn object;\n}\n\/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being\n\/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects\n\/\/ PERF: Avoid initialization of new objects if none.\nif (hasNewObjects()) {\nregisteredObject = getNewObjectsOriginalToClone().get(object);\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nif (this.isNestedUnitOfWork) {\n\/\/ bug # 3228185\n\/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n\/\/if it has already been registered locally\nif (hasNewObjectsInParentOriginalToClone()) {\nregisteredObject = getNewObjectsInParentOriginalToClone().get(object);\n}\nif (registeredObject != null) {\nreturn registeredObject;\n}\n}\nreturn null;\n}","label":[0,0,1,0]}
{"id":17549,"original_code":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\n        if (toBeDeleted == null) {\n            return;\n        }\n        ClassDescriptor descriptor = getDescriptor(toBeDeleted);\n        if ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\n            throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n        }\n        logDebugMessage(toBeDeleted, \"deleting_object\");\n        \/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\n        if (getDeletedObjects().containsKey(toBeDeleted)){\n          return;\n        }\n        visitedObjects.put(toBeDeleted,toBeDeleted);\n        Object registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\n        if (registeredObject == null) {\n            Object primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\n            DoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\n            existQuery = (DoesExistQuery)existQuery.clone();\n            existQuery.setObject(toBeDeleted);\n            existQuery.setPrimaryKey(primaryKey);\n            existQuery.setDescriptor(descriptor);\n            existQuery.setIsExecutionClone(true);\n            existQuery.setCheckCacheFirst(true);\n            if (((Boolean)executeQuery(existQuery)).booleanValue()){\n                throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n            }\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n        } else {\n            \/\/fire events only if this is a managed object\n            if (descriptor.getEventManager().hasAnyEventListeners()) {\n                org.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\n                event.setEventCode(DescriptorEventManager.PreRemoveEvent);\n                event.setSession(this);\n                descriptor.getEventManager().executeEvent(event);\n            }\n            if (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\n                unregisterObject(registeredObject, DescriptorIterator.NoCascading);\n            } else {\n                getDeletedObjects().put(toBeDeleted, toBeDeleted);\n            }\n        }\n        descriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n    }","code":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\n        if (toBeDeleted == null) {\n            return;\n        }\n        ClassDescriptor descriptor = getDescriptor(toBeDeleted);\n        if ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\n            throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n        }\n        logDebugMessage(toBeDeleted, \"deleting_object\");\n       \n        if (getDeletedObjects().containsKey(toBeDeleted)){\n          return;\n        }\n        visitedObjects.put(toBeDeleted,toBeDeleted);\n        Object registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\n        if (registeredObject == null) {\n            Object primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\n            DoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\n            existQuery = (DoesExistQuery)existQuery.clone();\n            existQuery.setObject(toBeDeleted);\n            existQuery.setPrimaryKey(primaryKey);\n            existQuery.setDescriptor(descriptor);\n            existQuery.setIsExecutionClone(true);\n            existQuery.setCheckCacheFirst(true);\n            if (((Boolean)executeQuery(existQuery)).booleanValue()){\n                throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n            \n        } else {\n           \n            if (descriptor.getEventManager().hasAnyEventListeners()) {\n                org.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\n                event.setEventCode(DescriptorEventManager.PreRemoveEvent);\n                event.setSession(this);\n                descriptor.getEventManager().executeEvent(event);\n            }\n            if (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\n                unregisterObject(registeredObject, DescriptorIterator.NoCascading);\n            } else {\n                getDeletedObjects().put(toBeDeleted, toBeDeleted);\n            }\n        }\n        descriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n    }","cleancode":"public void performremove(object tobedeleted, map visitedobjects) { if (tobedeleted == null) { return; } classdescriptor descriptor = getdescriptor(tobedeleted); if ((descriptor == null) || descriptor.isdescriptortypeaggregate()) { throw new illegalargumentexception(exceptionlocalization.buildmessage(\"not_an_entity\", new object[] { tobedeleted })); } logdebugmessage(tobedeleted, \"deleting_object\"); if (getdeletedobjects().containskey(tobedeleted)){ return; } visitedobjects.put(tobedeleted,tobedeleted); object registeredobject = checkifalreadyregistered(tobedeleted, descriptor); if (registeredobject == null) { object primarykey = descriptor.getobjectbuilder().extractprimarykeyfromobject(tobedeleted, this); doesexistquery existquery = descriptor.getquerymanager().getdoesexistquery(); existquery = (doesexistquery)existquery.clone(); existquery.setobject(tobedeleted); existquery.setprimarykey(primarykey); existquery.setdescriptor(descriptor); existquery.setisexecutionclone(true); existquery.setcheckcachefirst(true); if (((boolean)executequery(existquery)).booleanvalue()){ throw new illegalargumentexception(exceptionlocalization.buildmessage(\"cannot_remove_detatched_entity\", new object[]{tobedeleted})); } else { if (descriptor.geteventmanager().hasanyeventlisteners()) { org.eclipse.persistence.descriptors.descriptorevent event = new org.eclipse.persistence.descriptors.descriptorevent(tobedeleted); event.seteventcode(descriptoreventmanager.preremoveevent); event.setsession(this); descriptor.geteventmanager().executeevent(event); } if (hasnewobjects() && getnewobjectsclonetooriginal().containskey(registeredobject)){ unregisterobject(registeredobject, descriptoriterator.nocascading); } else { getdeletedobjects().put(tobedeleted, tobedeleted); } } descriptor.getobjectbuilder().cascadeperformremove(tobedeleted, this, visitedobjects); }","comment":"\/** * internal: * this method will perform a delete operation on the provided objects pre-determining * the objects that will be deleted by a commit of the unitofwork including privately * owned objects. it does not execute a query for the deletion of these objects as the * normal deleteobject operation does. mainly implemented to provide ejb 3.0 deleteobject * support. *\/\n\/\/bug 4568370+4599010; fix entitymanager.remove() to handle new objects\n\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n\/\/fire events only if this is a managed object","repo":"chenjiafan\/eclipselink","code_context_2":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\nif (toBeDeleted == null) {\nreturn;\n}\nClassDescriptor descriptor = getDescriptor(toBeDeleted);\nif ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);\n}\n}\ndescriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n}\n\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\n\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);","code_context_10":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\nif (toBeDeleted == null) {\nreturn;\n}\nClassDescriptor descriptor = getDescriptor(toBeDeleted);\nif ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);\n}\n}\ndescriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n}\n\npublic void performRemove(Object toBeDeleted, Map visitedObjects) {\nif (toBeDeleted == null) {\nreturn;\n}\nClassDescriptor descriptor = getDescriptor(toBeDeleted);\nif ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\n\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);","code_context_20":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\nif (toBeDeleted == null) {\nreturn;\n}\nClassDescriptor descriptor = getDescriptor(toBeDeleted);\nif ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);\n}\n}\ndescriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n}\n\npublic void performRemove(Object toBeDeleted, Map visitedObjects) {\nif (toBeDeleted == null) {\nreturn;\n}\nClassDescriptor descriptor = getDescriptor(toBeDeleted);\nif ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\n\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n}\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);\n}\n}\ndescriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n}\n\nlogDebugMessage(toBeDeleted, \"deleting_object\");\n\/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\nif (getDeletedObjects().containsKey(toBeDeleted)){\nreturn;\n}\nvisitedObjects.put(toBeDeleted,toBeDeleted);\nObject registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\nif (registeredObject == null) {\nObject primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\nDoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\nexistQuery = (DoesExistQuery)existQuery.clone();\nexistQuery.setObject(toBeDeleted);\nexistQuery.setPrimaryKey(primaryKey);\nexistQuery.setDescriptor(descriptor);\nexistQuery.setIsExecutionClone(true);\nexistQuery.setCheckCacheFirst(true);\nif (((Boolean)executeQuery(existQuery)).booleanValue()){\nthrow new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n}\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n} else {\n\/\/fire events only if this is a managed object\nif (descriptor.getEventManager().hasAnyEventListeners()) {\norg.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\nevent.setEventCode(DescriptorEventManager.PreRemoveEvent);\nevent.setSession(this);\ndescriptor.getEventManager().executeEvent(event);\n}\nif (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\nunregisterObject(registeredObject, DescriptorIterator.NoCascading);\n} else {\ngetDeletedObjects().put(toBeDeleted, toBeDeleted);\n}\n}\ndescriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n}","label":[0,0,1,0]}
{"id":17557,"original_code":"protected Map cloneMap(Map map){\n        \/\/ bug 270413.  This method is needed to avoid the class cast exception when the reference mode is weak.\n    \tif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\n        return (IdentityHashMap)((IdentityHashMap)map).clone();\n    }","code":"protected Map cloneMap(Map map){\n       \n    \tif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\n        return (IdentityHashMap)((IdentityHashMap)map).clone();\n    }","cleancode":"protected map clonemap(map map){ if (this.referencemode != null && this.referencemode != referencemode.hard) return (identityweakhashmap)((identityweakhashmap)map).clone(); return (identityhashmap)((identityhashmap)map).clone(); }","comment":"\/** * this method is used internally to clone a map that holds the persistencecontexts. a weak map is returned if referencemode is weak. * *\/\n\/\/ bug 270413. this method is needed to avoid the class cast exception when the reference mode is weak.","repo":"chenjiafan\/eclipselink","code_context_2":"protected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();\n}\n\nprotected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();","code_context_10":"protected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();\n}\n\nprotected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();\n}","code_context_20":"protected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();\n}\n\nprotected Map cloneMap(Map map){\n\/\/ bug 270413. This method is needed to avoid the class cast exception when the reference mode is weak.\nif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\nreturn (IdentityHashMap)((IdentityHashMap)map).clone();\n}","label":[0,0,1,0]}
{"id":1232,"original_code":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\t\t\/\/ Note that instances are not referenced by any other model entity, so\n\t\t\/\/ they can be safely deleted here\n\t\t\/\/ without leaving any references in place.\n\t\t\/\/ If there are textual references to the instance (i.e. in a property\n\t\t\/\/ that refers to it by name) then\n\t\t\/\/ these references must be manually cleaned up separately by the code\n\t\t\/\/ that calls this method.\n\t\t\/\/ First remove the instances individually from the list of all\n\t\t\/\/ instances\n\t\tArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\n\t\tfor (CeInstance thisInst : allInsts) {\n\t\t\tdeleteInstanceNoRefs(thisInst);\n\t\t}\n\t\t\/\/ Then remove all of the instances for the specified concept from the\n\t\t\/\/ other list\n\t\tthis.instancesByConcept.remove(pConcept);\n\t\t\/\/ Then remove the unused sentences and sources that may be left as a\n\t\t\/\/ result\n\t\tpAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n\t}","code":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\n\t\tfor (CeInstance thisInst : allInsts) {\n\t\t\tdeleteInstanceNoRefs(thisInst);\n\t\t}\n\t\n\t\n\t\tthis.instancesByConcept.remove(pConcept);\n\t\n\t\n\t\tpAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n\t}","cleancode":"protected void deleteallinstancesforconcept(actioncontext pac, ceconcept pconcept) { arraylist<ceinstance> allinsts = getallinstancesforconcept(pconcept); for (ceinstance thisinst : allinsts) { deleteinstancenorefs(thisinst); } this.instancesbyconcept.remove(pconcept); pac.getmodelbuilder().removeunusedsentencesandsources(pac); }","comment":"\/\/ todo: add deletesource\n\/\/ note that instances are not referenced by any other model entity, so \/\/ they can be safely deleted here \/\/ without leaving any references in place. \/\/ if there are textual references to the instance (i.e. in a property \/\/ that refers to it by name) then \/\/ these references must be manually cleaned up separately by the code \/\/ that calls this method. \/\/ first remove the instances individually from the list of all \/\/ instances\n\/\/ then remove all of the instances for the specified concept from the \/\/ other list\n\/\/ then remove the unused sentences and sources that may be left as a \/\/ result","repo":"ce-store\/ce-store","code_context_2":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\nprotected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\n\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}","code_context_10":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\nprotected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}","code_context_20":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\nprotected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\nprotected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}\n\nprotected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\/\/ Note that instances are not referenced by any other model entity, so\n\/\/ they can be safely deleted here\n\/\/ without leaving any references in place.\n\/\/ If there are textual references to the instance (i.e. in a property\n\/\/ that refers to it by name) then\n\/\/ these references must be manually cleaned up separately by the code\n\/\/ that calls this method.\n\/\/ First remove the instances individually from the list of all\n\/\/ instances\nArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\nfor (CeInstance thisInst : allInsts) {\ndeleteInstanceNoRefs(thisInst);\n}\n\/\/ Then remove all of the instances for the specified concept from the\n\/\/ other list\nthis.instancesByConcept.remove(pConcept);\n\/\/ Then remove the unused sentences and sources that may be left as a\n\/\/ result\npAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n}","label":[0,1,0,0]}
{"id":25901,"original_code":"@Test\n    public void testGetVotesForInstance() {\n        System.out.println(\"getVotesForInstance\");\n        FeS2 classifier = new FeS2();\n        Instance x = trainingSet.instance(0);\n        classifier.subspaceStrategyOption.setChosenIndex(0);\n        classifier.distanceStrategyOption.setChosenIndex(2);\n        classifier.initialClusterWeightOption.setValue(0.1);\n        classifier.learningRateAlphaOption.setValue(0.95);\n        classifier.minimumClusterSizeOption.setValue(3);\n        classifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n       \/\/ classifier.pruneThresholdOption.setValue(0.00001);\n        classifier.updateStrategyOption.setChosenIndex(1);\n        classifier.trainOnInstance(trainingSet.instance(0));\n        double[] result = classifier.getVotesForInstance(x);\n        int h = (int) result[weka.core.Utils.maxIndex(result)];\n        int y = 1;\n        assertEquals(y,h);\n        \/\/ TODO - add fuller set\n    }","code":"@Test\n    public void testGetVotesForInstance() {\n        System.out.println(\"getVotesForInstance\");\n        FeS2 classifier = new FeS2();\n        Instance x = trainingSet.instance(0);\n        classifier.subspaceStrategyOption.setChosenIndex(0);\n        classifier.distanceStrategyOption.setChosenIndex(2);\n        classifier.initialClusterWeightOption.setValue(0.1);\n        classifier.learningRateAlphaOption.setValue(0.95);\n        classifier.minimumClusterSizeOption.setValue(3);\n        classifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n      \n        classifier.updateStrategyOption.setChosenIndex(1);\n        classifier.trainOnInstance(trainingSet.instance(0));\n        double[] result = classifier.getVotesForInstance(x);\n        int h = (int) result[weka.core.Utils.maxIndex(result)];\n        int y = 1;\n        assertEquals(y,h);\n       \n    }","cleancode":"@test public void testgetvotesforinstance() { system.out.println(\"getvotesforinstance\"); fes2 classifier = new fes2(); instance x = trainingset.instance(0); classifier.subspacestrategyoption.setchosenindex(0); classifier.distancestrategyoption.setchosenindex(2); classifier.initialclusterweightoption.setvalue(0.1); classifier.learningratealphaoption.setvalue(0.95); classifier.minimumclustersizeoption.setvalue(3); classifier.outlierdefinitionstrategyoption.setchosenindex(0); classifier.updatestrategyoption.setchosenindex(1); classifier.trainoninstance(trainingset.instance(0)); double[] result = classifier.getvotesforinstance(x); int h = (int) result[weka.core.utils.maxindex(result)]; int y = 1; assertequals(y,h); }","comment":"\/** * test of getvotesforinstance method, of class fes2. *\/\n\/\/ classifier.prunethresholdoption.setvalue(0.00001);\n\/\/ todo - add fuller set","repo":"bigfastdata\/SluiceBox","code_context_2":"@Test\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}\n\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\n\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}","code_context_10":"@Test\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}\n\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}\n\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}","code_context_20":"@Test\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}\n\n@Test\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}\n\n@Test\npublic void testGetVotesForInstance() {\nSystem.out.println(\"getVotesForInstance\");\nFeS2 classifier = new FeS2();\nInstance x = trainingSet.instance(0);\nclassifier.subspaceStrategyOption.setChosenIndex(0);\nclassifier.distanceStrategyOption.setChosenIndex(2);\nclassifier.initialClusterWeightOption.setValue(0.1);\nclassifier.learningRateAlphaOption.setValue(0.95);\nclassifier.minimumClusterSizeOption.setValue(3);\nclassifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n\/\/ classifier.pruneThresholdOption.setValue(0.00001);\nclassifier.updateStrategyOption.setChosenIndex(1);\nclassifier.trainOnInstance(trainingSet.instance(0));\ndouble[] result = classifier.getVotesForInstance(x);\nint h = (int) result[weka.core.Utils.maxIndex(result)];\nint y = 1;\nassertEquals(y,h);\n\/\/ TODO - add fuller set\n}","label":[0,1,0,0]}
{"id":34109,"original_code":"public ReportHeaderGroup getReportHeaderGroup(int col)\n    {\n        \/* no report header groups? *\/\n        if (ListTools.isEmpty(this.rptHdrGrps)) {\n            return null;\n        }\n        \/* search for column *\/\n        for (ReportHeaderGroup rhg : this.rptHdrGrps) {\n            int C = rhg.getColIndex();\n            if (col == C) {\n                return rhg;\n            }\n            \/\/ TODO: optimize\n        }\n        \/* not found *\/\n        return null;\n    }","code":"public ReportHeaderGroup getReportHeaderGroup(int col)\n    {\n       \n        if (ListTools.isEmpty(this.rptHdrGrps)) {\n            return null;\n        }\n       \n        for (ReportHeaderGroup rhg : this.rptHdrGrps) {\n            int C = rhg.getColIndex();\n            if (col == C) {\n                return rhg;\n            }\n           \n        }\n       \n        return null;\n    }","cleancode":"public reportheadergroup getreportheadergroup(int col) { if (listtools.isempty(this.rpthdrgrps)) { return null; } for (reportheadergroup rhg : this.rpthdrgrps) { int c = rhg.getcolindex(); if (col == c) { return rhg; } } return null; }","comment":"\/** *** sets the report header group at the specified column **\/\n\/* no report header groups? *\/\n\/* search for column *\/\n\/\/ todo: optimize\n\/* not found *\/","repo":"aungphyopyaekyaw\/gpstrack","code_context_2":"public ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\n\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\n\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}","code_context_10":"public ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}","code_context_20":"public ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}\n\npublic ReportHeaderGroup getReportHeaderGroup(int col)\n{\n\/* no report header groups? *\/\nif (ListTools.isEmpty(this.rptHdrGrps)) {\nreturn null;\n}\n\/* search for column *\/\nfor (ReportHeaderGroup rhg : this.rptHdrGrps) {\nint C = rhg.getColIndex();\nif (col == C) {\nreturn rhg;\n}\n\/\/ TODO: optimize\n}\n\/* not found *\/\nreturn null;\n}","label":[1,0,0,0]}
{"id":9544,"original_code":"@Override\n  public int getPreferredHeight() {\n    \/\/ The superclass uses getOffsetHeight, which won't work for us.\n    return ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n  }","code":"@Override\n  public int getPreferredHeight() {\n   \n    return ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n  }","cleancode":"@override public int getpreferredheight() { return componentconstants.videoplayer_preferred_height; }","comment":"\/\/ the superclass uses getoffsetheight, which won't work for us.","repo":"be1be1\/appinventor-polyu","code_context_2":"@Override\npublic int getPreferredHeight() {\n\/\/ The superclass uses getOffsetHeight, which won't work for us.\nreturn ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n}","code_context_10":"@Override\npublic int getPreferredHeight() {\n\/\/ The superclass uses getOffsetHeight, which won't work for us.\nreturn ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n}","code_context_20":"@Override\npublic int getPreferredHeight() {\n\/\/ The superclass uses getOffsetHeight, which won't work for us.\nreturn ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n}","label":[0,0,1,0]}
{"id":25966,"original_code":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\n\t\tif (obj.getString(\"kind\").equals(\"constant\")) {\n\t\t\tString name = obj.getString(\"name\");\n\t\t\tString desc = obj.optString(\"description\", \"\");\n\t\t\tObject defaultValue = obj.opt(\"defaultvalue\");\n\t\t\tString[] types;\n\t\t\tif (obj.has(\"type\")) {\n\t\t\t\tJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\n\t\t\t\ttypes = getStringArray(jsonTypes);\n\t\t\t} else {\n\t\t\t\t\/\/ FIXME: this is the case of blendModes and scaleModes\n\t\t\t\ttypes = new String[] { \"Object\" };\n\t\t\t}\n\t\t\tPhaserConstant cons = new PhaserConstant();\n\t\t\t{\n\t\t\t\t\/\/ static flag\n\t\t\t\tString scope = obj.optString(\"scope\", \"\");\n\t\t\t\tif (scope.equals(\"static\")) {\n\t\t\t\t\tcons.setStatic(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcons.setName(name);\n\t\t\tcons.setHelp(desc);\n\t\t\tcons.setTypes(types);\n\t\t\tcons.setDefaultValue(defaultValue);\n\t\t\tString memberof = obj.optString(\"memberof\", null);\n\t\t\tif (memberof == null) {\n\t\t\t\t\/\/ global constant\n\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t\/\/ FIXME: only add those Phaser.js constants\n\t\t\t\tif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n\t\t\t\t\t_globalConstants.add(cons);\n\t\t\t\t} else {\n\t\t\t\t\tout.println(obj.toString(2));\n\t\t\t\t\tthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n\t\t\t\t\t\t\t+ cons.getFile().getFileName() + \"#\" + cons.getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPhaserType type = typeMap.get(memberof);\n\t\t\t\tif (!type.getMemberMap().containsKey(name)) {\n\t\t\t\t\ttype.getMemberMap().put(name, cons);\n\t\t\t\t\tcons.setDeclType(type);\n\t\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","code":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\n\t\tif (obj.getString(\"kind\").equals(\"constant\")) {\n\t\t\tString name = obj.getString(\"name\");\n\t\t\tString desc = obj.optString(\"description\", \"\");\n\t\t\tObject defaultValue = obj.opt(\"defaultvalue\");\n\t\t\tString[] types;\n\t\t\tif (obj.has(\"type\")) {\n\t\t\t\tJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\n\t\t\t\ttypes = getStringArray(jsonTypes);\n\t\t\t} else {\n\t\t\t\n\t\t\t\ttypes = new String[] { \"Object\" };\n\t\t\t}\n\t\t\tPhaserConstant cons = new PhaserConstant();\n\t\t\t{\n\t\t\t\n\t\t\t\tString scope = obj.optString(\"scope\", \"\");\n\t\t\t\tif (scope.equals(\"static\")) {\n\t\t\t\t\tcons.setStatic(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcons.setName(name);\n\t\t\tcons.setHelp(desc);\n\t\t\tcons.setTypes(types);\n\t\t\tcons.setDefaultValue(defaultValue);\n\t\t\tString memberof = obj.optString(\"memberof\", null);\n\t\t\tif (memberof == null) {\n\t\t\t\n\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\n\t\t\t\tif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n\t\t\t\t\t_globalConstants.add(cons);\n\t\t\t\t} else {\n\t\t\t\t\tout.println(obj.toString(2));\n\t\t\t\t\tthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n\t\t\t\t\t\t\t+ cons.getFile().getFileName() + \"#\" + cons.getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPhaserType type = typeMap.get(memberof);\n\t\t\t\tif (!type.getMemberMap().containsKey(name)) {\n\t\t\t\t\ttype.getMemberMap().put(name, cons);\n\t\t\t\t\tcons.setDeclType(type);\n\t\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","cleancode":"private void buildconstant(jsonobject obj, map<string, phasertype> typemap) { if (obj.getstring(\"kind\").equals(\"constant\")) { string name = obj.getstring(\"name\"); string desc = obj.optstring(\"description\", \"\"); object defaultvalue = obj.opt(\"defaultvalue\"); string[] types; if (obj.has(\"type\")) { jsonarray jsontypes = obj.getjsonobject(\"type\").getjsonarray(\"names\"); types = getstringarray(jsontypes); } else { types = new string[] { \"object\" }; } phaserconstant cons = new phaserconstant(); { string scope = obj.optstring(\"scope\", \"\"); if (scope.equals(\"static\")) { cons.setstatic(true); } } cons.setname(name); cons.sethelp(desc); cons.settypes(types); cons.setdefaultvalue(defaultvalue); string memberof = obj.optstring(\"memberof\", null); if (memberof == null) { buildmeta(cons, obj); if (cons.getfile().getfilename().tostring().equals(\"phaser.js\")) { _globalconstants.add(cons); } else { out.println(obj.tostring(2)); throw new illegalargumentexception(\"all global constants should come from phaser.js and not from \" + cons.getfile().getfilename() + \"#\" + cons.getname()); } } else { phasertype type = typemap.get(memberof); if (!type.getmembermap().containskey(name)) { type.getmembermap().put(name, cons); cons.setdecltype(type); buildmeta(cons, obj); } } } }","comment":"\/\/ fixme: this is the case of blendmodes and scalemodes\n\/\/ static flag\n\/\/ global constant\n\/\/ fixme: only add those phaser.js constants","repo":"boniatillo-com\/rayo","code_context_2":"types = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\n\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\n\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\n\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);","code_context_10":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\nif (obj.getString(\"kind\").equals(\"constant\")) {\nString name = obj.getString(\"name\");\nString desc = obj.optString(\"description\", \"\");\nObject defaultValue = obj.opt(\"defaultvalue\");\nString[] types;\nif (obj.has(\"type\")) {\nJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\ntypes = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\n\nString[] types;\nif (obj.has(\"type\")) {\nJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\ntypes = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\n\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);\n} else {\nout.println(obj.toString(2));\nthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n+ cons.getFile().getFileName() + \"#\" + cons.getName());\n}\n} else {\n\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);\n} else {\nout.println(obj.toString(2));\nthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n+ cons.getFile().getFileName() + \"#\" + cons.getName());\n}\n} else {\nPhaserType type = typeMap.get(memberof);\nif (!type.getMemberMap().containsKey(name)) {","code_context_20":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\nif (obj.getString(\"kind\").equals(\"constant\")) {\nString name = obj.getString(\"name\");\nString desc = obj.optString(\"description\", \"\");\nObject defaultValue = obj.opt(\"defaultvalue\");\nString[] types;\nif (obj.has(\"type\")) {\nJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\ntypes = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n\nprivate void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\nif (obj.getString(\"kind\").equals(\"constant\")) {\nString name = obj.getString(\"name\");\nString desc = obj.optString(\"description\", \"\");\nObject defaultValue = obj.opt(\"defaultvalue\");\nString[] types;\nif (obj.has(\"type\")) {\nJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\ntypes = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);\n} else {\nout.println(obj.toString(2));\nthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n+ cons.getFile().getFileName() + \"#\" + cons.getName());\n\nJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\ntypes = getStringArray(jsonTypes);\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);\n} else {\nout.println(obj.toString(2));\nthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n+ cons.getFile().getFileName() + \"#\" + cons.getName());\n}\n} else {\nPhaserType type = typeMap.get(memberof);\nif (!type.getMemberMap().containsKey(name)) {\ntype.getMemberMap().put(name, cons);\ncons.setDeclType(type);\nbuildMeta(cons, obj);\n}\n}\n}\n}\n\n} else {\n\/\/ FIXME: this is the case of blendModes and scaleModes\ntypes = new String[] { \"Object\" };\n}\nPhaserConstant cons = new PhaserConstant();\n{\n\/\/ static flag\nString scope = obj.optString(\"scope\", \"\");\nif (scope.equals(\"static\")) {\ncons.setStatic(true);\n}\n}\ncons.setName(name);\ncons.setHelp(desc);\ncons.setTypes(types);\ncons.setDefaultValue(defaultValue);\nString memberof = obj.optString(\"memberof\", null);\nif (memberof == null) {\n\/\/ global constant\nbuildMeta(cons, obj);\n\/\/ FIXME: only add those Phaser.js constants\nif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n_globalConstants.add(cons);\n} else {\nout.println(obj.toString(2));\nthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n+ cons.getFile().getFileName() + \"#\" + cons.getName());\n}\n} else {\nPhaserType type = typeMap.get(memberof);\nif (!type.getMemberMap().containsKey(name)) {\ntype.getMemberMap().put(name, cons);\ncons.setDeclType(type);\nbuildMeta(cons, obj);\n}\n}\n}\n}","label":[1,0,1,0]}
{"id":1477,"original_code":"@Override\n    public String getName() {\n        return \"Manage services\";\n    }","code":"@Override\n    public String getName() {\n        return \"Manage services\";\n    }","cleancode":"@override public string getname() { return \"manage services\"; }","comment":"\/\/ todo replace with keys for i18n","repo":"civts\/AAC","code_context_2":"@Override\npublic String getName() {\nreturn \"Manage services\";\n}","code_context_10":"@Override\npublic String getName() {\nreturn \"Manage services\";\n}","code_context_20":"@Override\npublic String getName() {\nreturn \"Manage services\";\n}","label":[1,0,0,0]}
{"id":9669,"original_code":"@Override\n  public void testSave() {\n    \/\/ TODO Embedded Elasticsearch integration tests do not support has child operations\n  }","code":"@Override\n  public void testSave() {\n   \n  }","cleancode":"@override public void testsave() { }","comment":"\/\/ todo embedded elasticsearch integration tests do not support has child operations","repo":"commitd\/jonah-server","code_context_2":"@Override\npublic void testSave() {\n\/\/ TODO Embedded Elasticsearch integration tests do not support has child operations\n}","code_context_10":"@Override\npublic void testSave() {\n\/\/ TODO Embedded Elasticsearch integration tests do not support has child operations\n}","code_context_20":"@Override\npublic void testSave() {\n\/\/ TODO Embedded Elasticsearch integration tests do not support has child operations\n}","label":[0,1,0,0]}
{"id":1489,"original_code":"public void downloadTiles(){\n\t\tsetVisible(false);\n\t\tfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\n\t\tint numberTiles = 0;\n\t\tfinal int startZoom = (Integer) startSpinner.getValue();\n\t\tfinal int endZoom = (Integer) endSpinner.getValue();\n\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\tnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n\t\t}\n\t\tfinal int number = numberTiles;\n\t\tfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\n\t\tprogressDialog.setRunnable(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number); \/\/$NON-NLS-1$\n\t\t\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\t\t\tfor(int x = x1; x <= x2; x++){\n\t\t\t\t\t\tfor(int y=y1; y<= y2; y++){\n\t\t\t\t\t\t\tString file = getFileForImage(x, y, zoom, map.getTileFormat());\n\t\t\t\t\t\t\tif(new File(tilesLocation, file).exists()){\n\t\t\t\t\t\t\t\tprogressDialog.progress(1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDownloadRequest req = new DownloadRequest(map.getUrlToLoad(x, y, zoom), \n\t\t\t\t\t\t\t\t\t\tnew File(tilesLocation, file), x, y, zoom);\n\t\t\t\t\t\t\t\tinstance.requestToDownload(req);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(instance.isSomethingBeingDownloaded()){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tArrayList<IMapDownloaderCallback> previousCallbacks = \n\t\t\tnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\n\t\tinstance.getDownloaderCallbacks().clear();\n\t\tinstance.addDownloaderCallback(new IMapDownloaderCallback(){\n\t\t\t@Override\n\t\t\tpublic void tileDownloaded(DownloadRequest request) {\n\t\t\t\t\/\/ TODO request could be null if bundle loading?\n\t\t\t\tprogressDialog.progress(1);\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tprogressDialog.run();\n\t\t\tinstance.refuseAllPreviousRequests();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tExceptionHandler.handle((Exception) e.getCause());\n\t\t} catch (InterruptedException e) {\n\t\t\tExceptionHandler.handle(e);\n\t\t} finally {\n\t\t\tinstance.getDownloaderCallbacks().clear();\n\t\t\tinstance.getDownloaderCallbacks().addAll(previousCallbacks);\n\t\t}\n\t}","code":"public void downloadTiles(){\n\t\tsetVisible(false);\n\t\tfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\"));\n\t\tint numberTiles = 0;\n\t\tfinal int startZoom = (Integer) startSpinner.getValue();\n\t\tfinal int endZoom = (Integer) endSpinner.getValue();\n\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\tnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n\t\t}\n\t\tfinal int number = numberTiles;\n\t\tfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\n\t\tprogressDialog.setRunnable(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number);\n\t\t\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\t\t\tfor(int x = x1; x <= x2; x++){\n\t\t\t\t\t\tfor(int y=y1; y<= y2; y++){\n\t\t\t\t\t\t\tString file = getFileForImage(x, y, zoom, map.getTileFormat());\n\t\t\t\t\t\t\tif(new File(tilesLocation, file).exists()){\n\t\t\t\t\t\t\t\tprogressDialog.progress(1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDownloadRequest req = new DownloadRequest(map.getUrlToLoad(x, y, zoom), \n\t\t\t\t\t\t\t\t\t\tnew File(tilesLocation, file), x, y, zoom);\n\t\t\t\t\t\t\t\tinstance.requestToDownload(req);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(instance.isSomethingBeingDownloaded()){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tArrayList<IMapDownloaderCallback> previousCallbacks = \n\t\t\tnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\n\t\tinstance.getDownloaderCallbacks().clear();\n\t\tinstance.addDownloaderCallback(new IMapDownloaderCallback(){\n\t\t\t@Override\n\t\t\tpublic void tileDownloaded(DownloadRequest request) {\n\t\t\t\n\t\t\t\tprogressDialog.progress(1);\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tprogressDialog.run();\n\t\t\tinstance.refuseAllPreviousRequests();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tExceptionHandler.handle((Exception) e.getCause());\n\t\t} catch (InterruptedException e) {\n\t\t\tExceptionHandler.handle(e);\n\t\t} finally {\n\t\t\tinstance.getDownloaderCallbacks().clear();\n\t\t\tinstance.getDownloaderCallbacks().addAll(previousCallbacks);\n\t\t}\n\t}","cleancode":"public void downloadtiles(){ setvisible(false); final progressdialog progressdialog = new progressdialog(this, messages.getstring(\"tilebundledownloaddialog.downloading.tiles\")); int numbertiles = 0; final int startzoom = (integer) startspinner.getvalue(); final int endzoom = (integer) endspinner.getvalue(); for (int zoom = startzoom; zoom <= endzoom; zoom++) { int x1 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon1()); int x2 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon2()); int y1 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat1()); int y2 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat2()); numbertiles += (x2 - x1 + 1) * (y2 - y1 + 1); } final int number = numbertiles; final maptiledownloader instance = maptiledownloader.getinstance(mapcreatorversion.app_map_creator_version); progressdialog.setrunnable(new runnable(){ @override public void run() { progressdialog.starttask(messages.getstring(\"tilebundledownloaddialog.loading\"), number); for (int zoom = startzoom; zoom <= endzoom; zoom++) { int x1 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon1()); int x2 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon2()); int y1 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat1()); int y2 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat2()); for(int x = x1; x <= x2; x++){ for(int y=y1; y<= y2; y++){ string file = getfileforimage(x, y, zoom, map.gettileformat()); if(new file(tileslocation, file).exists()){ progressdialog.progress(1); } else { downloadrequest req = new downloadrequest(map.geturltoload(x, y, zoom), new file(tileslocation, file), x, y, zoom); instance.requesttodownload(req); } } } while(instance.issomethingbeingdownloaded()){ try { thread.sleep(100); } catch (interruptedexception e) { throw new illegalargumentexception(e); } } } } }); arraylist<imapdownloadercallback> previouscallbacks = new arraylist<imapdownloadercallback>(instance.getdownloadercallbacks()); instance.getdownloadercallbacks().clear(); instance.adddownloadercallback(new imapdownloadercallback(){ @override public void tiledownloaded(downloadrequest request) { progressdialog.progress(1); } }); try { progressdialog.run(); instance.refuseallpreviousrequests(); } catch (invocationtargetexception e) { exceptionhandler.handle((exception) e.getcause()); } catch (interruptedexception e) { exceptionhandler.handle(e); } finally { instance.getdownloadercallbacks().clear(); instance.getdownloadercallbacks().addall(previouscallbacks); } }","comment":"\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/ todo request could be null if bundle loading?","repo":"brownsys\/android-app-modes-osmand","code_context_2":"public void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\n\npublic void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\n\n@Override\npublic void tileDownloaded(DownloadRequest request) {\n\/\/ TODO request could be null if bundle loading?\nprogressDialog.progress(1);\n}","code_context_10":"public void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\nfinal int endZoom = (Integer) endSpinner.getValue();\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\nint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\nnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n}\n\npublic void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\nfinal int endZoom = (Integer) endSpinner.getValue();\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\nint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\nnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n}\n\n}\n}\n}\n});\nArrayList<IMapDownloaderCallback> previousCallbacks =\nnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\ninstance.getDownloaderCallbacks().clear();\ninstance.addDownloaderCallback(new IMapDownloaderCallback(){\n@Override\npublic void tileDownloaded(DownloadRequest request) {\n\/\/ TODO request could be null if bundle loading?\nprogressDialog.progress(1);\n}\n});\ntry {\nprogressDialog.run();\ninstance.refuseAllPreviousRequests();\n} catch (InvocationTargetException e) {\nExceptionHandler.handle((Exception) e.getCause());\n} catch (InterruptedException e) {\nExceptionHandler.handle(e);","code_context_20":"public void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\nfinal int endZoom = (Integer) endSpinner.getValue();\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\nint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\nnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n}\nfinal int number = numberTiles;\nfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\nprogressDialog.setRunnable(new Runnable(){\n@Override\npublic void run() {\nprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number); \/\/$NON-NLS-1$\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\npublic void downloadTiles(){\nsetVisible(false);\nfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\nint numberTiles = 0;\nfinal int startZoom = (Integer) startSpinner.getValue();\nfinal int endZoom = (Integer) endSpinner.getValue();\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\nint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\nnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n}\nfinal int number = numberTiles;\nfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\nprogressDialog.setRunnable(new Runnable(){\n@Override\npublic void run() {\nprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number); \/\/$NON-NLS-1$\nfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\nint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\nint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\nint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\ninstance.requestToDownload(req);\n}\n}\n}\nwhile(instance.isSomethingBeingDownloaded()){\ntry {\nThread.sleep(100);\n} catch (InterruptedException e) {\nthrow new IllegalArgumentException(e);\n}\n}\n}\n}\n});\nArrayList<IMapDownloaderCallback> previousCallbacks =\nnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\ninstance.getDownloaderCallbacks().clear();\ninstance.addDownloaderCallback(new IMapDownloaderCallback(){\n@Override\npublic void tileDownloaded(DownloadRequest request) {\n\/\/ TODO request could be null if bundle loading?\nprogressDialog.progress(1);\n}\n});\ntry {\nprogressDialog.run();\ninstance.refuseAllPreviousRequests();\n} catch (InvocationTargetException e) {\nExceptionHandler.handle((Exception) e.getCause());\n} catch (InterruptedException e) {\nExceptionHandler.handle(e);\n} finally {\ninstance.getDownloaderCallbacks().clear();\ninstance.getDownloaderCallbacks().addAll(previousCallbacks);\n}\n}","label":[0,1,0,0]}
{"id":26161,"original_code":"@Override\n\tpublic boolean saveSettings() {\n\t\t\/\/ We might even consider updating the user-supplied file, if any...\n\t\treturn false;\n\t}","code":"@Override\n\tpublic boolean saveSettings() {\n\t\n\t\treturn false;\n\t}","cleancode":"@override public boolean savesettings() { return false; }","comment":"\/\/ we might even consider updating the user-supplied file, if any...","repo":"chbi\/gerrit-gitblit-plugin","code_context_2":"@Override\npublic boolean saveSettings() {\n\/\/ We might even consider updating the user-supplied file, if any...\nreturn false;\n}","code_context_10":"@Override\npublic boolean saveSettings() {\n\/\/ We might even consider updating the user-supplied file, if any...\nreturn false;\n}","code_context_20":"@Override\npublic boolean saveSettings() {\n\/\/ We might even consider updating the user-supplied file, if any...\nreturn false;\n}","label":[1,0,0,0]}
{"id":34429,"original_code":"public void setValue(Object newValue) {\n        Object checkedValue = checkValue(newValue);\n        setDirty(isDifferent(baseValue, checkedValue));\n        if (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\n            firePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n        }\n    }","code":"public void setValue(Object newValue) {\n        Object checkedValue = checkValue(newValue);\n        setDirty(isDifferent(baseValue, checkedValue));\n        if (isDifferent(value, checkedValue)){\n            firePropertyChange(VALUE, value, value = checkedValue);\n        }\n    }","cleancode":"public void setvalue(object newvalue) { object checkedvalue = checkvalue(newvalue); setdirty(isdifferent(basevalue, checkedvalue)); if (isdifferent(value, checkedvalue)){ firepropertychange(value, value, value = checkedvalue); } }","comment":"\/\/ todo dk: think about specific method versions for each allowed type\n\/\/ firepropertychange doesn't do this check sufficiently\n\/\/ set inline to avoid recursion","repo":"canoo\/open-dolphin","code_context_2":"public void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}\n\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}","code_context_10":"public void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}\n\npublic void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}\n\npublic void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}","code_context_20":"public void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}\n\npublic void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}\n\npublic void setValue(Object newValue) {\nObject checkedValue = checkValue(newValue);\nsetDirty(isDifferent(baseValue, checkedValue));\nif (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\nfirePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n}\n}","label":[1,0,0,0]}
{"id":26262,"original_code":"@Override\n    public TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n      \/\/ TODO Should be split into different tests for mean, variance, covariance, covariancematrix\n      return new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\n        private final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\n        private final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\n        private final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\n        private final List<Integer> dataMean = Arrays.asList(496, 384);\n        private DRes<BigInteger> outputMean1;\n        private DRes<BigInteger> outputMean2;\n        private DRes<BigInteger> outputVariance;\n        private DRes<BigInteger> outputCovariance;\n        private List<List<DRes<BigInteger>>> outputCovarianceMatix;\n        @Override\n        public void test() throws Exception {\n          Application<Void, ProtocolBuilderNumeric> app = builder -> {\n            Numeric NumericBuilder = builder.numeric();\n            List<DRes<SInt>> input1 = data1.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input2 = data2.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input3 = data3.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> means = dataMean.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            DRes<SInt> mean1 = builder.seq(new Mean(input1));\n            DRes<SInt> mean2 = builder.seq(new Mean(input2));\n            DRes<SInt> variance = builder.seq(new Variance(input1, mean1));\n            DRes<SInt> covariance = builder.seq(new Covariance(input1, input2, mean1, mean2));\n            DRes<List<List<DRes<SInt>>>> covarianceMatrix =\n                builder.seq(new CovarianceMatrix(Arrays.asList(input1, input2, input3), means));\n            return builder.par((par) -> {\n              Numeric open = par.numeric();\n              outputMean1 = open.open(mean1);\n              outputMean2 = open.open(mean2);\n              outputVariance = open.open(variance);\n              outputCovariance = open.open(covariance);\n              List<List<DRes<SInt>>> covarianceMatrixOut = covarianceMatrix.out();\n              List<List<DRes<BigInteger>>> openCovarianceMatrix =\n                  new ArrayList<>(covarianceMatrixOut.size());\n              for (List<DRes<SInt>> computations : covarianceMatrixOut) {\n                List<DRes<BigInteger>> computationList = new ArrayList<>(computations.size());\n                openCovarianceMatrix.add(computationList);\n                for (DRes<SInt> computation : computations) {\n                  computationList.add(open.open(computation));\n                }\n              }\n              outputCovarianceMatix = openCovarianceMatrix;\n              return null;\n            });\n          };\n          runApplication(app);\n          BigInteger mean1 = outputMean1.out();\n          BigInteger mean2 = outputMean2.out();\n          BigInteger variance = outputVariance.out();\n          BigInteger covariance = outputCovariance.out();\n          double sum = 0.0;\n          for (int entry : data1) {\n            sum += entry;\n          }\n          double mean1Exact = sum \/ data1.size();\n          sum = 0.0;\n          for (int entry : data2) {\n            sum += entry;\n          }\n          double mean2Exact = sum \/ data2.size();\n          double ssd = 0.0;\n          for (int entry : data1) {\n            ssd += (entry - mean1Exact) * (entry - mean1Exact);\n          }\n          double varianceExact = ssd \/ (data1.size() - 1);\n          double covarianceExact = 0.0;\n          for (int i = 0; i < data1.size(); i++) {\n            covarianceExact += (data1.get(i) - mean1Exact) * (data2.get(i) - mean2Exact);\n          }\n          covarianceExact \/= (data1.size() - 1);\n          double tolerance = 1.0;\n          Assert.assertTrue(isInInterval(mean1, mean1Exact, tolerance));\n          Assert.assertTrue(isInInterval(mean2, mean2Exact, tolerance));\n          Assert.assertTrue(isInInterval(variance, varianceExact, tolerance));\n          System.out.println(covariance + \" \" + covarianceExact + \" - \" + tolerance);\n          Assert.assertTrue(isInInterval(covariance, covarianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(0).get(0).out(), varianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(1).get(0).out(), covarianceExact, tolerance));\n        }\n      };\n    }","code":"@Override\n    public TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n     \n      return new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\n        private final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\n        private final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\n        private final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\n        private final List<Integer> dataMean = Arrays.asList(496, 384);\n        private DRes<BigInteger> outputMean1;\n        private DRes<BigInteger> outputMean2;\n        private DRes<BigInteger> outputVariance;\n        private DRes<BigInteger> outputCovariance;\n        private List<List<DRes<BigInteger>>> outputCovarianceMatix;\n        @Override\n        public void test() throws Exception {\n          Application<Void, ProtocolBuilderNumeric> app = builder -> {\n            Numeric NumericBuilder = builder.numeric();\n            List<DRes<SInt>> input1 = data1.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input2 = data2.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input3 = data3.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> means = dataMean.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            DRes<SInt> mean1 = builder.seq(new Mean(input1));\n            DRes<SInt> mean2 = builder.seq(new Mean(input2));\n            DRes<SInt> variance = builder.seq(new Variance(input1, mean1));\n            DRes<SInt> covariance = builder.seq(new Covariance(input1, input2, mean1, mean2));\n            DRes<List<List<DRes<SInt>>>> covarianceMatrix =\n                builder.seq(new CovarianceMatrix(Arrays.asList(input1, input2, input3), means));\n            return builder.par((par) -> {\n              Numeric open = par.numeric();\n              outputMean1 = open.open(mean1);\n              outputMean2 = open.open(mean2);\n              outputVariance = open.open(variance);\n              outputCovariance = open.open(covariance);\n              List<List<DRes<SInt>>> covarianceMatrixOut = covarianceMatrix.out();\n              List<List<DRes<BigInteger>>> openCovarianceMatrix =\n                  new ArrayList<>(covarianceMatrixOut.size());\n              for (List<DRes<SInt>> computations : covarianceMatrixOut) {\n                List<DRes<BigInteger>> computationList = new ArrayList<>(computations.size());\n                openCovarianceMatrix.add(computationList);\n                for (DRes<SInt> computation : computations) {\n                  computationList.add(open.open(computation));\n                }\n              }\n              outputCovarianceMatix = openCovarianceMatrix;\n              return null;\n            });\n          };\n          runApplication(app);\n          BigInteger mean1 = outputMean1.out();\n          BigInteger mean2 = outputMean2.out();\n          BigInteger variance = outputVariance.out();\n          BigInteger covariance = outputCovariance.out();\n          double sum = 0.0;\n          for (int entry : data1) {\n            sum += entry;\n          }\n          double mean1Exact = sum \/ data1.size();\n          sum = 0.0;\n          for (int entry : data2) {\n            sum += entry;\n          }\n          double mean2Exact = sum \/ data2.size();\n          double ssd = 0.0;\n          for (int entry : data1) {\n            ssd += (entry - mean1Exact) * (entry - mean1Exact);\n          }\n          double varianceExact = ssd \/ (data1.size() - 1);\n          double covarianceExact = 0.0;\n          for (int i = 0; i < data1.size(); i++) {\n            covarianceExact += (data1.get(i) - mean1Exact) * (data2.get(i) - mean2Exact);\n          }\n          covarianceExact \/= (data1.size() - 1);\n          double tolerance = 1.0;\n          Assert.assertTrue(isInInterval(mean1, mean1Exact, tolerance));\n          Assert.assertTrue(isInInterval(mean2, mean2Exact, tolerance));\n          Assert.assertTrue(isInInterval(variance, varianceExact, tolerance));\n          System.out.println(covariance + \" \" + covarianceExact + \" - \" + tolerance);\n          Assert.assertTrue(isInInterval(covariance, covarianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(0).get(0).out(), varianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(1).get(0).out(), covarianceExact, tolerance));\n        }\n      };\n    }","cleancode":"@override public testthread<resourcepoolt, protocolbuildernumeric> next() { return new testthread<resourcepoolt, protocolbuildernumeric>() { private final list<integer> data1 = arrays.aslist(543, 520, 532, 497, 450, 432); private final list<integer> data2 = arrays.aslist(432, 620, 232, 337, 250, 433); private final list<integer> data3 = arrays.aslist(80, 90, 123, 432, 145, 606); private final list<integer> datamean = arrays.aslist(496, 384); private dres<biginteger> outputmean1; private dres<biginteger> outputmean2; private dres<biginteger> outputvariance; private dres<biginteger> outputcovariance; private list<list<dres<biginteger>>> outputcovariancematix; @override public void test() throws exception { application<void, protocolbuildernumeric> app = builder -> { numeric numericbuilder = builder.numeric(); list<dres<sint>> input1 = data1.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> input2 = data2.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> input3 = data3.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> means = datamean.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); dres<sint> mean1 = builder.seq(new mean(input1)); dres<sint> mean2 = builder.seq(new mean(input2)); dres<sint> variance = builder.seq(new variance(input1, mean1)); dres<sint> covariance = builder.seq(new covariance(input1, input2, mean1, mean2)); dres<list<list<dres<sint>>>> covariancematrix = builder.seq(new covariancematrix(arrays.aslist(input1, input2, input3), means)); return builder.par((par) -> { numeric open = par.numeric(); outputmean1 = open.open(mean1); outputmean2 = open.open(mean2); outputvariance = open.open(variance); outputcovariance = open.open(covariance); list<list<dres<sint>>> covariancematrixout = covariancematrix.out(); list<list<dres<biginteger>>> opencovariancematrix = new arraylist<>(covariancematrixout.size()); for (list<dres<sint>> computations : covariancematrixout) { list<dres<biginteger>> computationlist = new arraylist<>(computations.size()); opencovariancematrix.add(computationlist); for (dres<sint> computation : computations) { computationlist.add(open.open(computation)); } } outputcovariancematix = opencovariancematrix; return null; }); }; runapplication(app); biginteger mean1 = outputmean1.out(); biginteger mean2 = outputmean2.out(); biginteger variance = outputvariance.out(); biginteger covariance = outputcovariance.out(); double sum = 0.0; for (int entry : data1) { sum += entry; } double mean1exact = sum \/ data1.size(); sum = 0.0; for (int entry : data2) { sum += entry; } double mean2exact = sum \/ data2.size(); double ssd = 0.0; for (int entry : data1) { ssd += (entry - mean1exact) * (entry - mean1exact); } double varianceexact = ssd \/ (data1.size() - 1); double covarianceexact = 0.0; for (int i = 0; i < data1.size(); i++) { covarianceexact += (data1.get(i) - mean1exact) * (data2.get(i) - mean2exact); } covarianceexact \/= (data1.size() - 1); double tolerance = 1.0; assert.asserttrue(isininterval(mean1, mean1exact, tolerance)); assert.asserttrue(isininterval(mean2, mean2exact, tolerance)); assert.asserttrue(isininterval(variance, varianceexact, tolerance)); system.out.println(covariance + \" \" + covarianceexact + \" - \" + tolerance); assert.asserttrue(isininterval(covariance, covarianceexact, tolerance)); assert.asserttrue( isininterval(outputcovariancematix.get(0).get(0).out(), varianceexact, tolerance)); assert.asserttrue( isininterval(outputcovariancematix.get(1).get(0).out(), covarianceexact, tolerance)); } }; }","comment":"\/\/ todo should be split into different tests for mean, variance, covariance, covariancematrix","repo":"basitkhurram\/fresco","code_context_2":"@Override\npublic TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n\/\/ TODO Should be split into different tests for mean, variance, covariance, covariancematrix\nreturn new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\nprivate final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);","code_context_10":"@Override\npublic TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n\/\/ TODO Should be split into different tests for mean, variance, covariance, covariancematrix\nreturn new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\nprivate final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\nprivate final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\nprivate final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\nprivate final List<Integer> dataMean = Arrays.asList(496, 384);\nprivate DRes<BigInteger> outputMean1;\nprivate DRes<BigInteger> outputMean2;\nprivate DRes<BigInteger> outputVariance;\nprivate DRes<BigInteger> outputCovariance;\nprivate List<List<DRes<BigInteger>>> outputCovarianceMatix;","code_context_20":"@Override\npublic TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n\/\/ TODO Should be split into different tests for mean, variance, covariance, covariancematrix\nreturn new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\nprivate final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\nprivate final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\nprivate final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\nprivate final List<Integer> dataMean = Arrays.asList(496, 384);\nprivate DRes<BigInteger> outputMean1;\nprivate DRes<BigInteger> outputMean2;\nprivate DRes<BigInteger> outputVariance;\nprivate DRes<BigInteger> outputCovariance;\nprivate List<List<DRes<BigInteger>>> outputCovarianceMatix;\n@Override\npublic void test() throws Exception {\nApplication<Void, ProtocolBuilderNumeric> app = builder -> {\nNumeric NumericBuilder = builder.numeric();\nList<DRes<SInt>> input1 = data1.stream().map(BigInteger::valueOf)\n.map(NumericBuilder::known).collect(Collectors.toList());\nList<DRes<SInt>> input2 = data2.stream().map(BigInteger::valueOf)\n.map(NumericBuilder::known).collect(Collectors.toList());\nList<DRes<SInt>> input3 = data3.stream().map(BigInteger::valueOf)\n.map(NumericBuilder::known).collect(Collectors.toList());","label":[0,0,0,1]}
{"id":1728,"original_code":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\t\t\/\/ prepare for a new iteration, clean the state\n\t\tclearData();\n\t\t\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\n\t\tString clauseOutput = \"\"; \n\t\tif (verifyOrFind)\n\t\t\tclauseOutput += generateSmtContractClauseVerify(cc);\n\t\telse \n\t\t\tclauseOutput += generateSmtContractClauseFind(cc);    \n\t\t\/\/ process input and output to collect info about components and\n\t\t\/\/ properties\n\t\ttraverseInputOutput(ac);\n\t\t\/\/ create definitions and facts\n\t\t\/\/ also populate string2int dictionary as a side effect\n\t\tString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\t\t\/\/ apply dictionary transform to clause output\n\t\t\/\/ FIXME collisions with other names possible\n\t\tfor (String str: stringToIntDict.keySet()) { \n\t\t\tclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n\t\t}\n\t\t\/\/ defs and facts come come first\n\t\treturn defFactOutput + clauseOutput;\n\t}","code":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\t\n\t\tclearData();\n\t\n\t\tString clauseOutput = \"\"; \n\t\tif (verifyOrFind)\n\t\t\tclauseOutput += generateSmtContractClauseVerify(cc);\n\t\telse \n\t\t\tclauseOutput += generateSmtContractClauseFind(cc);    \n\t\n\t\n\t\ttraverseInputOutput(ac);\n\t\n\t\n\t\tString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\t\n\t\n\t\tfor (String str: stringToIntDict.keySet()) { \n\t\t\tclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n\t\t}\n\t\n\t\treturn defFactOutput + clauseOutput;\n\t}","cleancode":"public string generatesmtforclause(analysiscontract ac, contractclause cc, boolean verifyorfind) { cleardata(); string clauseoutput = \"\"; if (verifyorfind) clauseoutput += generatesmtcontractclauseverify(cc); else clauseoutput += generatesmtcontractclausefind(cc); traverseinputoutput(ac); string deffactoutput = psg.generatedefinitionsandfacts(comptoprop, ac, stringtointdict); for (string str: stringtointdict.keyset()) { clauseoutput = clauseoutput.replace('$' + str + '$', string.valueof(stringtointdict.get(str))); } return deffactoutput + clauseoutput; }","comment":"\/** * generate an smt2 model for a given analysiscontract. the main interface * of this class. * * @param ac * the analysiscontract to generate for * @param forassumptions * indicates whether the analysiscontract is an assumption * (slight differences in processing) * @return *\/\n\/\/ prepare for a new iteration, clean the state\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\n\/\/ process input and output to collect info about components and \/\/ properties\n\/\/ create definitions and facts \/\/ also populate string2int dictionary as a side effect\n\/\/ apply dictionary transform to clause output \/\/ fixme collisions with other names possible\n\/\/ defs and facts come come first","repo":"bisc\/active","code_context_2":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\n\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\n\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}","code_context_10":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\n\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}","code_context_20":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}\n\npublic String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\/\/ prepare for a new iteration, clean the state\nclearData();\n\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\nString clauseOutput = \"\";\nif (verifyOrFind)\nclauseOutput += generateSmtContractClauseVerify(cc);\nelse\nclauseOutput += generateSmtContractClauseFind(cc);\n\/\/ process input and output to collect info about components and\n\/\/ properties\ntraverseInputOutput(ac);\n\/\/ create definitions and facts\n\/\/ also populate string2int dictionary as a side effect\nString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\/\/ apply dictionary transform to clause output\n\/\/ FIXME collisions with other names possible\nfor (String str: stringToIntDict.keySet()) {\nclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n}\n\/\/ defs and facts come come first\nreturn defFactOutput + clauseOutput;\n}","label":[0,0,1,0]}
{"id":34500,"original_code":"@NonNull\n    public static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\n        if (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ avoid updating to frequently\n        final long timeNow = System.currentTimeMillis();\n        if ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\n            return ensureTrack(lastRoutingPoints, start, destination);\n        }\n        \/\/ Disable routing for huge distances\n        final int maxThresholdKm = Settings.getBrouterThreshold();\n        final float targetDistance = start.distanceTo(destination);\n        if (targetDistance > maxThresholdKm) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ disable routing when near the target\n        if (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ Use cached route if current position has not changed more than 5m and we had a route\n        \/\/ TODO: Maybe adjust this to current zoomlevel\n        if (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\n            return lastRoutingPoints;\n        }\n        \/\/ now really calculate a new route\n        lastDestination = destination;\n        lastRoutingPoints = calculateRouting(start, destination);\n        lastDirectionUpdatePoint = start;\n        timeLastUpdate = timeNow;\n        return ensureTrack(lastRoutingPoints, start, destination);\n    }","code":"@NonNull\n    public static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\n        if (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\n            return defaultTrack(start, destination);\n        }\n       \n        final long timeNow = System.currentTimeMillis();\n        if ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\n            return ensureTrack(lastRoutingPoints, start, destination);\n        }\n       \n        final int maxThresholdKm = Settings.getBrouterThreshold();\n        final float targetDistance = start.distanceTo(destination);\n        if (targetDistance > maxThresholdKm) {\n            return defaultTrack(start, destination);\n        }\n       \n        if (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\n            return defaultTrack(start, destination);\n        }\n       \n       \n        if (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\n            return lastRoutingPoints;\n        }\n       \n        lastDestination = destination;\n        lastRoutingPoints = calculateRouting(start, destination);\n        lastDirectionUpdatePoint = start;\n        timeLastUpdate = timeNow;\n        return ensureTrack(lastRoutingPoints, start, destination);\n    }","cleancode":"@nonnull public static geopoint[] gettrack(final geopoint start, final geopoint destination) { if (brouter == null || settings.getroutingmode() == routingmode.straight) { return defaulttrack(start, destination); } final long timenow = system.currenttimemillis(); if ((timenow - timelastupdate) < 1000 * update_min_delay_seconds) { return ensuretrack(lastroutingpoints, start, destination); } final int maxthresholdkm = settings.getbrouterthreshold(); final float targetdistance = start.distanceto(destination); if (targetdistance > maxthresholdkm) { return defaulttrack(start, destination); } if (targetdistance < min_routing_distance_kilometers) { return defaulttrack(start, destination); } if (lastdirectionupdatepoint != null && destination == lastdestination && start.distanceto(lastdirectionupdatepoint) < update_min_distance_kilometers && lastroutingpoints != null) { return lastroutingpoints; } lastdestination = destination; lastroutingpoints = calculaterouting(start, destination); lastdirectionupdatepoint = start; timelastupdate = timenow; return ensuretrack(lastroutingpoints, start, destination); }","comment":"\/** * return a valid track (with at least two points, including the start and destination). * in some cases (e.g., destination is too close or too far, path could not be found), * a straight line will be returned. * * @param start the starting point * @param destination the destination point * @return a track with at least two points including the start and destination points *\/\n\/\/ avoid updating to frequently\n\/\/ disable routing for huge distances\n\/\/ disable routing when near the target\n\/\/ use cached route if current position has not changed more than 5m and we had a route \/\/ todo: maybe adjust this to current zoomlevel\n\/\/ now really calculate a new route","repo":"cayacdev\/cgeo","code_context_2":"@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\n\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\n\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);","code_context_10":"@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\n\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}","code_context_20":"@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\n@NonNull\npublic static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\nif (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\nreturn defaultTrack(start, destination);\n}\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\n\/\/ avoid updating to frequently\nfinal long timeNow = System.currentTimeMillis();\nif ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}\n\/\/ Disable routing for huge distances\nfinal int maxThresholdKm = Settings.getBrouterThreshold();\nfinal float targetDistance = start.distanceTo(destination);\nif (targetDistance > maxThresholdKm) {\nreturn defaultTrack(start, destination);\n}\n\/\/ disable routing when near the target\nif (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\nreturn defaultTrack(start, destination);\n}\n\/\/ Use cached route if current position has not changed more than 5m and we had a route\n\/\/ TODO: Maybe adjust this to current zoomlevel\nif (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\nreturn lastRoutingPoints;\n}\n\/\/ now really calculate a new route\nlastDestination = destination;\nlastRoutingPoints = calculateRouting(start, destination);\nlastDirectionUpdatePoint = start;\ntimeLastUpdate = timeNow;\nreturn ensureTrack(lastRoutingPoints, start, destination);\n}","label":[0,1,0,0]}
{"id":26309,"original_code":"public static void load(Preferences options) {\n        fontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n        fontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n        markdownExtensions.init(options, \"markdownExtensions\");\n        \/\/ TODO rewrite after add extension dialogs\n        setMarkdownExtensions(MarkdownExtensions.ids());\n        showLineNo.init(options, \"showLineNo\", true);\n        showWhitespace.init(options, \"showWhitespace\", false);\n    }","code":"public static void load(Preferences options) {\n        fontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n        fontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n        markdownExtensions.init(options, \"markdownExtensions\");\n       \n        setMarkdownExtensions(MarkdownExtensions.ids());\n        showLineNo.init(options, \"showLineNo\", true);\n        showWhitespace.init(options, \"showWhitespace\", false);\n    }","cleancode":"public static void load(preferences options) { fontfamily.init(options, \"fontfamily\", null, value -> safefontfamily(value)); fontsize.init(options, \"fontsize\", def_font_size); markdownextensions.init(options, \"markdownextensions\"); setmarkdownextensions(markdownextensions.ids()); showlineno.init(options, \"showlineno\", true); showwhitespace.init(options, \"showwhitespace\", false); }","comment":"\/\/ todo rewrite after add extension dialogs","repo":"baobab-it\/notebookFX","code_context_2":"fontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\nmarkdownExtensions.init(options, \"markdownExtensions\");\n\/\/ TODO rewrite after add extension dialogs\nsetMarkdownExtensions(MarkdownExtensions.ids());\nshowLineNo.init(options, \"showLineNo\", true);","code_context_10":"public static void load(Preferences options) {\nfontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\nfontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\nmarkdownExtensions.init(options, \"markdownExtensions\");\n\/\/ TODO rewrite after add extension dialogs\nsetMarkdownExtensions(MarkdownExtensions.ids());\nshowLineNo.init(options, \"showLineNo\", true);\nshowWhitespace.init(options, \"showWhitespace\", false);\n}","code_context_20":"public static void load(Preferences options) {\nfontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\nfontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\nmarkdownExtensions.init(options, \"markdownExtensions\");\n\/\/ TODO rewrite after add extension dialogs\nsetMarkdownExtensions(MarkdownExtensions.ids());\nshowLineNo.init(options, \"showLineNo\", true);\nshowWhitespace.init(options, \"showWhitespace\", false);\n}","label":[0,1,0,0]}
{"id":26319,"original_code":"@Override\n    public void close()\n    {\n        \/\/ TODO: Connect\n    }","code":"@Override\n    public void close()\n    {\n       \n    }","cleancode":"@override public void close() { }","comment":"\/\/ todo: connect","repo":"ankitaagar\/felix-dev","code_context_2":"public void close()\n{\n\/\/ TODO: Connect\n}","code_context_10":"@Override\npublic void close()\n{\n\/\/ TODO: Connect\n}","code_context_20":"@Override\npublic void close()\n{\n\/\/ TODO: Connect\n}","label":[0,1,0,0]}
{"id":26320,"original_code":"@Override\n    public String getEntryAsNativeLibrary(String entryName)\n    {\n        \/\/ TODO: Connect\n        return null;\n    }","code":"@Override\n    public String getEntryAsNativeLibrary(String entryName)\n    {\n       \n        return null;\n    }","cleancode":"@override public string getentryasnativelibrary(string entryname) { return null; }","comment":"\/\/ todo: connect","repo":"ankitaagar\/felix-dev","code_context_2":"public String getEntryAsNativeLibrary(String entryName)\n{\n\/\/ TODO: Connect\nreturn null;\n}","code_context_10":"@Override\npublic String getEntryAsNativeLibrary(String entryName)\n{\n\/\/ TODO: Connect\nreturn null;\n}","code_context_20":"@Override\npublic String getEntryAsNativeLibrary(String entryName)\n{\n\/\/ TODO: Connect\nreturn null;\n}","label":[0,1,0,0]}
{"id":26321,"original_code":"@Override\n    public URL getEntryAsURL(String name)\n    {\n        \/\/ TODO: Connect\n        return null;\n    }","code":"@Override\n    public URL getEntryAsURL(String name)\n    {\n       \n        return null;\n    }","cleancode":"@override public url getentryasurl(string name) { return null; }","comment":"\/\/ todo: connect","repo":"ankitaagar\/felix-dev","code_context_2":"public URL getEntryAsURL(String name)\n{\n\/\/ TODO: Connect\nreturn null;\n}","code_context_10":"@Override\npublic URL getEntryAsURL(String name)\n{\n\/\/ TODO: Connect\nreturn null;\n}","code_context_20":"@Override\npublic URL getEntryAsURL(String name)\n{\n\/\/ TODO: Connect\nreturn null;\n}","label":[0,1,0,0]}
{"id":1778,"original_code":"public void testLayerHandle() throws Exception {\n        NbModuleProject project = TestBase.generateStandaloneModule(getWorkDir(), \"module\");\n        LayerHandle handle = LayerHandle.forProject(project);\n        FileObject expectedLayerXML = project.getProjectDirectory().getFileObject(\"src\/org\/example\/module\/resources\/layer.xml\");\n        assertNotNull(expectedLayerXML);\n        FileObject layerXML = handle.getLayerFile();\n        assertNotNull(\"layer.xml already exists\", layerXML);\n        assertEquals(\"right layer file\", expectedLayerXML, layerXML);\n        FileSystem fs = handle.layer(true);\n        assertEquals(\"initially empty\", 0, fs.getRoot().getChildren().length);\n        long initialSize = layerXML.getSize();\n        fs.getRoot().createData(\"foo\");\n        assertEquals(\"not saved yet\", initialSize, layerXML.getSize());\n        fs = handle.layer(true);\n        assertNotNull(\"still have in-memory mods\", fs.findResource(\"foo\"));\n        fs.getRoot().createData(\"bar\");\n        handle.save();\n        assertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\n        String xml =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n                \"<filesystem>\\n\" +\n                \"    <file name=\\\"bar\\\"\/>\\n\" +\n                \"    <file name=\\\"foo\\\"\/>\\n\" +\n                \"<\/filesystem>\\n\";\n        assertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n        \/\/ XXX test that nbres: file contents work\n    }","code":"public void testLayerHandle() throws Exception {\n        NbModuleProject project = TestBase.generateStandaloneModule(getWorkDir(), \"module\");\n        LayerHandle handle = LayerHandle.forProject(project);\n        FileObject expectedLayerXML = project.getProjectDirectory().getFileObject(\"src\/org\/example\/module\/resources\/layer.xml\");\n        assertNotNull(expectedLayerXML);\n        FileObject layerXML = handle.getLayerFile();\n        assertNotNull(\"layer.xml already exists\", layerXML);\n        assertEquals(\"right layer file\", expectedLayerXML, layerXML);\n        FileSystem fs = handle.layer(true);\n        assertEquals(\"initially empty\", 0, fs.getRoot().getChildren().length);\n        long initialSize = layerXML.getSize();\n        fs.getRoot().createData(\"foo\");\n        assertEquals(\"not saved yet\", initialSize, layerXML.getSize());\n        fs = handle.layer(true);\n        assertNotNull(\"still have in-memory mods\", fs.findResource(\"foo\"));\n        fs.getRoot().createData(\"bar\");\n        handle.save();\n        assertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\n        String xml =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n                \"<filesystem>\\n\" +\n                \"    <file name=\\\"bar\\\"\/>\\n\" +\n                \"    <file name=\\\"foo\\\"\/>\\n\" +\n                \"<\/filesystem>\\n\";\n        assertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n       \n    }","cleancode":"public void testlayerhandle() throws exception { nbmoduleproject project = testbase.generatestandalonemodule(getworkdir(), \"module\"); layerhandle handle = layerhandle.forproject(project); fileobject expectedlayerxml = project.getprojectdirectory().getfileobject(\"src\/org\/example\/module\/resources\/layer.xml\"); assertnotnull(expectedlayerxml); fileobject layerxml = handle.getlayerfile(); assertnotnull(\"layer.xml already exists\", layerxml); assertequals(\"right layer file\", expectedlayerxml, layerxml); filesystem fs = handle.layer(true); assertequals(\"initially empty\", 0, fs.getroot().getchildren().length); long initialsize = layerxml.getsize(); fs.getroot().createdata(\"foo\"); assertequals(\"not saved yet\", initialsize, layerxml.getsize()); fs = handle.layer(true); assertnotnull(\"still have in-memory mods\", fs.findresource(\"foo\")); fs.getroot().createdata(\"bar\"); handle.save(); asserttrue(\"now it is saved\", layerxml.getsize() > initialsize); string xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" + \"<!doctype filesystem public \\\"-\/\/netbeans\/\/dtd filesystem 1.2\/\/en\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" + \"<filesystem>\\n\" + \" <file name=\\\"bar\\\"\/>\\n\" + \" <file name=\\\"foo\\\"\/>\\n\" + \"<\/filesystem>\\n\"; assertequals(\"right contents too\", xml, testbase.slurp(layerxml)); }","comment":"\/\/ xxx test that nbres: file contents work","repo":"arusinha\/incubator-netbeans","code_context_2":"\"<\/filesystem>\\n\";\nassertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n\/\/ XXX test that nbres: file contents work\n}","code_context_10":"handle.save();\nassertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\nString xml =\n\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n\"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n\"<filesystem>\\n\" +\n\" <file name=\\\"bar\\\"\/>\\n\" +\n\" <file name=\\\"foo\\\"\/>\\n\" +\n\"<\/filesystem>\\n\";\nassertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n\/\/ XXX test that nbres: file contents work\n}","code_context_20":"assertNotNull(\"layer.xml already exists\", layerXML);\nassertEquals(\"right layer file\", expectedLayerXML, layerXML);\nFileSystem fs = handle.layer(true);\nassertEquals(\"initially empty\", 0, fs.getRoot().getChildren().length);\nlong initialSize = layerXML.getSize();\nfs.getRoot().createData(\"foo\");\nassertEquals(\"not saved yet\", initialSize, layerXML.getSize());\nfs = handle.layer(true);\nassertNotNull(\"still have in-memory mods\", fs.findResource(\"foo\"));\nfs.getRoot().createData(\"bar\");\nhandle.save();\nassertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\nString xml =\n\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n\"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n\"<filesystem>\\n\" +\n\" <file name=\\\"bar\\\"\/>\\n\" +\n\" <file name=\\\"foo\\\"\/>\\n\" +\n\"<\/filesystem>\\n\";\nassertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n\/\/ XXX test that nbres: file contents work\n}","label":[0,0,0,1]}
{"id":26391,"original_code":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n        \/\/null is easy\n        if (param == null) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\n                    return method.loadNull();\n                }\n            };\n        }\n        \/\/check the loaded object support (i.e. config) to see if this is a config item\n        DeferredParameter loadedObject = findLoaded(param);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n        \/\/Handle empty collections as returned by the Collections object\n        loadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n        \/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n        \/\/but some are quite complex when dealing with objects and collections\n        if (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n            \/\/check for substitution types, if present we invoke recursively on the substitution\n            SubstitutionHolder holder = substitutions.get(param.getClass());\n            if (holder == null) {\n                holder = substitutions.get(expectedType);\n            }\n            try {\n                ObjectSubstitution substitution = holder.sub.newInstance();\n                Object res = substitution.serialize(param);\n                DeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\n                SubstitutionHolder finalHolder = holder;\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        serialized.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\n                        ResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\n                        return method.invokeInterfaceMethod(\n                                ofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\n                                creator.loadDeferred(serialized));\n                    }\n                };\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to substitute \" + param, e);\n            }\n        } else if (param instanceof Optional) {\n            Optional val = (Optional) param;\n            if (val.isPresent()) {\n                DeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        res.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\n                                context.loadDeferred(res));\n                    }\n                };\n            } else {\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n                    }\n                };\n            }\n        } else if (param instanceof String) {\n            if (((String) param).length() > 65535) {\n                throw new RuntimeException(\"String too large to record: \" + param);\n            }\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((String) param);\n                }\n            };\n        } else if (param instanceof Integer) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((Integer) param));\n                }\n            };\n        } else if (param instanceof Boolean) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((Boolean) param));\n                }\n            };\n        } else if (param instanceof URL) {\n            String url = ((URL) param).toExternalForm();\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    AssignableResultHandle value = method.createVariable(URL.class);\n                    try (TryBlock et = method.tryBlock()) {\n                        et.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\n                        try (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\n                            malformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n                        }\n                    }\n                    return value;\n                }\n            };\n        } else if (param instanceof Enum) {\n            Enum e = (Enum) param;\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    ResultHandle nm = method.load(e.name());\n                    return method.invokeStaticMethod(\n                            ofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\n                            nm);\n                }\n            };\n        } else if (param instanceof ReturnedProxy) {\n            \/\/if this is a proxy we just grab the value from the StartupContext\n            ReturnedProxy rp = (ReturnedProxy) param;\n            if (!rp.__static$$init() && staticInit) {\n                throw new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n            }\n            String proxyId = rp.__returned$proxy$key();\n            \/\/because this is the result of a method invocation that may not have happened at param deserialization time\n            \/\/we just load it from the startup context\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\n                            method.getMethodParam(0), method.load(proxyId));\n                }\n            };\n        } else if (param instanceof Duration) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\n                            method.load(param.toString()));\n                }\n            };\n        } else if (param instanceof Class<?>) {\n            if (!((Class) param).isPrimitive()) {\n                \/\/ Only try to load the class by name if it is not a primitive class\n                String name = classProxies.get(param);\n                if (name == null) {\n                    name = ((Class) param).getName();\n                }\n                String finalName = name;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        ResultHandle currentThread = method\n                                .invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\n                        ResultHandle tccl = method.invokeVirtualMethod(\n                                ofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\n                                currentThread);\n                        return method.invokeStaticMethod(\n                                ofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\n                                method.load(finalName), method.load(true), tccl);\n                    }\n                };\n            } else {\n                \/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.loadClass((Class) param);\n                    }\n                };\n            }\n        } else if (expectedType == boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((boolean) param);\n                }\n            };\n        } else if (expectedType == Boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((boolean) param));\n                }\n            };\n        } else if (expectedType == int.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((int) param);\n                }\n            };\n        } else if (expectedType == Integer.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((int) param));\n                }\n            };\n        } else if (expectedType == short.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((short) param);\n                }\n            };\n        } else if (expectedType == Short.class || param instanceof Short) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\n                            method.load((short) param));\n                }\n            };\n        } else if (expectedType == byte.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((byte) param);\n                }\n            };\n        } else if (expectedType == Byte.class || param instanceof Byte) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\n                            method.load((byte) param));\n                }\n            };\n        } else if (expectedType == char.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((char) param);\n                }\n            };\n        } else if (expectedType == Character.class || param instanceof Character) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\n                            method.load((char) param));\n                }\n            };\n        } else if (expectedType == long.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((long) param);\n                }\n            };\n        } else if (expectedType == Long.class || param instanceof Long) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\n                            method.load((long) param));\n                }\n            };\n        } else if (expectedType == float.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((float) param);\n                }\n            };\n        } else if (expectedType == Float.class || param instanceof Float) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\n                            method.load((float) param));\n                }\n            };\n        } else if (expectedType == double.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((double) param);\n                }\n            };\n        } else if (expectedType == Double.class || param instanceof Double) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\n                            method.load((double) param));\n                }\n            };\n        } else if (expectedType.isArray()) {\n            int length = Array.getLength(param);\n            DeferredParameter[] components = new DeferredParameter[length];\n            for (int i = 0; i < length; ++i) {\n                DeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\n                        expectedType.getComponentType(), relaxedValidation);\n                components[i] = component;\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                void doPrepare(MethodContext context) {\n                    for (int i = 0; i < length; ++i) {\n                        components[i].prepare(context);\n                    }\n                    super.doPrepare(context);\n                }\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    \/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n                    \/\/fix this later\n                    ResultHandle out = method.newArray(expectedType.getComponentType(), length);\n                    for (int i = 0; i < length; ++i) {\n                        method.writeArrayValue(out, i, context.loadDeferred(components[i]));\n                    }\n                    return out;\n                }\n            };\n        } else if (param instanceof AnnotationProxy) {\n            \/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\n            AnnotationProxy annotationProxy = (AnnotationProxy) param;\n            List<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n                    .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\n            Map<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n                    .collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\n            DeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\n            for (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\n                MethodInfo valueMethod = iterator.next();\n                Object explicitValue = annotationProxy.getValues().get(valueMethod.name());\n                if (explicitValue != null) {\n                    constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\n                            explicitValue.getClass(), relaxedValidation);\n                } else {\n                    AnnotationValue value = annotationValues.get(valueMethod.name());\n                    if (value == null) {\n                        \/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n                        \/\/ returnValueResults, entry.getValue().getClass()));\n                        Object defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\n                        if (defaultValue != null) {\n                            constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\n                                    defaultValue.getClass(), relaxedValidation);\n                            continue;\n                        }\n                        if (value == null) {\n                            value = valueMethod.defaultValue();\n                        }\n                    }\n                    if (value == null) {\n                        throw new NullPointerException(\"Value not set for \" + param);\n                    }\n                    DeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\n                    constructorParamsHandles[iterator.previousIndex()] = retValue;\n                }\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    MethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\n                            constructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\n                    ResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\n                    for (int i = 0; i < constructorParamsHandles.length; i++) {\n                        DeferredParameter deferredParameter = constructorParamsHandles[i];\n                        if (deferredParameter instanceof DeferredArrayStoreParameter) {\n                            DeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\n                            arrayParam.doPrepare(context);\n                        }\n                        args[i] = context.loadDeferred(deferredParameter);\n                    }\n                    return method.newInstance(constructor, args);\n                }\n            };\n        } else {\n            return loadComplexObject(param, existing, expectedType, relaxedValidation);\n        }\n    }","code":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n       \n        if (param == null) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\n                    return method.loadNull();\n                }\n            };\n        }\n       \n        DeferredParameter loadedObject = findLoaded(param);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n       \n        loadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n       \n       \n        if (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n           \n            SubstitutionHolder holder = substitutions.get(param.getClass());\n            if (holder == null) {\n                holder = substitutions.get(expectedType);\n            }\n            try {\n                ObjectSubstitution substitution = holder.sub.newInstance();\n                Object res = substitution.serialize(param);\n                DeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\n                SubstitutionHolder finalHolder = holder;\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        serialized.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\n                        ResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\n                        return method.invokeInterfaceMethod(\n                                ofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\n                                creator.loadDeferred(serialized));\n                    }\n                };\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to substitute \" + param, e);\n            }\n        } else if (param instanceof Optional) {\n            Optional val = (Optional) param;\n            if (val.isPresent()) {\n                DeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        res.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\n                                context.loadDeferred(res));\n                    }\n                };\n            } else {\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n                    }\n                };\n            }\n        } else if (param instanceof String) {\n            if (((String) param).length() > 65535) {\n                throw new RuntimeException(\"String too large to record: \" + param);\n            }\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((String) param);\n                }\n            };\n        } else if (param instanceof Integer) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((Integer) param));\n                }\n            };\n        } else if (param instanceof Boolean) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((Boolean) param));\n                }\n            };\n        } else if (param instanceof URL) {\n            String url = ((URL) param).toExternalForm();\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    AssignableResultHandle value = method.createVariable(URL.class);\n                    try (TryBlock et = method.tryBlock()) {\n                        et.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\n                        try (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\n                            malformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n                        }\n                    }\n                    return value;\n                }\n            };\n        } else if (param instanceof Enum) {\n            Enum e = (Enum) param;\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    ResultHandle nm = method.load(e.name());\n                    return method.invokeStaticMethod(\n                            ofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\n                            nm);\n                }\n            };\n        } else if (param instanceof ReturnedProxy) {\n           \n            ReturnedProxy rp = (ReturnedProxy) param;\n            if (!rp.__static$$init() && staticInit) {\n                throw new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n            }\n            String proxyId = rp.__returned$proxy$key();\n           \n           \n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\n                            method.getMethodParam(0), method.load(proxyId));\n                }\n            };\n        } else if (param instanceof Duration) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\n                            method.load(param.toString()));\n                }\n            };\n        } else if (param instanceof Class<?>) {\n            if (!((Class) param).isPrimitive()) {\n               \n                String name = classProxies.get(param);\n                if (name == null) {\n                    name = ((Class) param).getName();\n                }\n                String finalName = name;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        ResultHandle currentThread = method\n                                .invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\n                        ResultHandle tccl = method.invokeVirtualMethod(\n                                ofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\n                                currentThread);\n                        return method.invokeStaticMethod(\n                                ofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\n                                method.load(finalName), method.load(true), tccl);\n                    }\n                };\n            } else {\n               \n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.loadClass((Class) param);\n                    }\n                };\n            }\n        } else if (expectedType == boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((boolean) param);\n                }\n            };\n        } else if (expectedType == Boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((boolean) param));\n                }\n            };\n        } else if (expectedType == int.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((int) param);\n                }\n            };\n        } else if (expectedType == Integer.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((int) param));\n                }\n            };\n        } else if (expectedType == short.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((short) param);\n                }\n            };\n        } else if (expectedType == Short.class || param instanceof Short) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\n                            method.load((short) param));\n                }\n            };\n        } else if (expectedType == byte.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((byte) param);\n                }\n            };\n        } else if (expectedType == Byte.class || param instanceof Byte) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\n                            method.load((byte) param));\n                }\n            };\n        } else if (expectedType == char.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((char) param);\n                }\n            };\n        } else if (expectedType == Character.class || param instanceof Character) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\n                            method.load((char) param));\n                }\n            };\n        } else if (expectedType == long.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((long) param);\n                }\n            };\n        } else if (expectedType == Long.class || param instanceof Long) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\n                            method.load((long) param));\n                }\n            };\n        } else if (expectedType == float.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((float) param);\n                }\n            };\n        } else if (expectedType == Float.class || param instanceof Float) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\n                            method.load((float) param));\n                }\n            };\n        } else if (expectedType == double.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((double) param);\n                }\n            };\n        } else if (expectedType == Double.class || param instanceof Double) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\n                            method.load((double) param));\n                }\n            };\n        } else if (expectedType.isArray()) {\n            int length = Array.getLength(param);\n            DeferredParameter[] components = new DeferredParameter[length];\n            for (int i = 0; i < length; ++i) {\n                DeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\n                        expectedType.getComponentType(), relaxedValidation);\n                components[i] = component;\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                void doPrepare(MethodContext context) {\n                    for (int i = 0; i < length; ++i) {\n                        components[i].prepare(context);\n                    }\n                    super.doPrepare(context);\n                }\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                   \n                   \n                    ResultHandle out = method.newArray(expectedType.getComponentType(), length);\n                    for (int i = 0; i < length; ++i) {\n                        method.writeArrayValue(out, i, context.loadDeferred(components[i]));\n                    }\n                    return out;\n                }\n            };\n        } else if (param instanceof AnnotationProxy) {\n           \n            AnnotationProxy annotationProxy = (AnnotationProxy) param;\n            List<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n                    .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\n            Map<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n                    .collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\n            DeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\n            for (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\n                MethodInfo valueMethod = iterator.next();\n                Object explicitValue = annotationProxy.getValues().get(valueMethod.name());\n                if (explicitValue != null) {\n                    constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\n                            explicitValue.getClass(), relaxedValidation);\n                } else {\n                    AnnotationValue value = annotationValues.get(valueMethod.name());\n                    if (value == null) {\n                       \n                       \n                        Object defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\n                        if (defaultValue != null) {\n                            constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\n                                    defaultValue.getClass(), relaxedValidation);\n                            continue;\n                        }\n                        if (value == null) {\n                            value = valueMethod.defaultValue();\n                        }\n                    }\n                    if (value == null) {\n                        throw new NullPointerException(\"Value not set for \" + param);\n                    }\n                    DeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\n                    constructorParamsHandles[iterator.previousIndex()] = retValue;\n                }\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    MethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\n                            constructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\n                    ResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\n                    for (int i = 0; i < constructorParamsHandles.length; i++) {\n                        DeferredParameter deferredParameter = constructorParamsHandles[i];\n                        if (deferredParameter instanceof DeferredArrayStoreParameter) {\n                            DeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\n                            arrayParam.doPrepare(context);\n                        }\n                        args[i] = context.loadDeferred(deferredParameter);\n                    }\n                    return method.newInstance(constructor, args);\n                }\n            };\n        } else {\n            return loadComplexObject(param, existing, expectedType, relaxedValidation);\n        }\n    }","cleancode":"private deferredparameter loadobjectinstanceimpl(object param, map<object, deferredparameter> existing, class<?> expectedtype, boolean relaxedvalidation) { if (param == null) { return new deferredparameter() { @override resulthandle doload(methodcontext creator, methodcreator method, resulthandle array) { return method.loadnull(); } }; } deferredparameter loadedobject = findloaded(param); if (loadedobject != null) { return loadedobject; } loadedobject = handlecollectionsobjects(param, existing, relaxedvalidation); if (loadedobject != null) { return loadedobject; } if (substitutions.containskey(param.getclass()) || substitutions.containskey(expectedtype)) { substitutionholder holder = substitutions.get(param.getclass()); if (holder == null) { holder = substitutions.get(expectedtype); } try { objectsubstitution substitution = holder.sub.newinstance(); object res = substitution.serialize(param); deferredparameter serialized = loadobjectinstance(res, existing, holder.to, relaxedvalidation); substitutionholder finalholder = holder; return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { serialized.prepare(context); super.doprepare(context); } @override resulthandle createvalue(methodcontext creator, methodcreator method, resulthandle array) { resulthandle subinstance = method.newinstance(methoddescriptor.ofconstructor(finalholder.sub)); return method.invokeinterfacemethod( ofmethod(objectsubstitution.class, \"deserialize\", object.class, object.class), subinstance, creator.loaddeferred(serialized)); } }; } catch (exception e) { throw new runtimeexception(\"failed to substitute \" + param, e); } } else if (param instanceof optional) { optional val = (optional) param; if (val.ispresent()) { deferredparameter res = loadobjectinstance(val.get(), existing, object.class, relaxedvalidation); return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { res.prepare(context); super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(optional.class, \"of\", optional.class, object.class), context.loaddeferred(res)); } }; } else { return new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(optional.class, \"empty\", optional.class)); } }; } } else if (param instanceof string) { if (((string) param).length() > 65535) { throw new runtimeexception(\"string too large to record: \" + param); } return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((string) param); } }; } else if (param instanceof integer) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(integer.class, \"valueof\", integer.class, int.class), method.load((integer) param)); } }; } else if (param instanceof boolean) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(boolean.class, \"valueof\", boolean.class, boolean.class), method.load((boolean) param)); } }; } else if (param instanceof url) { string url = ((url) param).toexternalform(); return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { assignableresulthandle value = method.createvariable(url.class); try (tryblock et = method.tryblock()) { et.assign(value, et.newinstance(methoddescriptor.ofconstructor(url.class, string.class), et.load(url))); try (catchblockcreator malformed = et.addcatch(malformedurlexception.class)) { malformed.throwexception(runtimeexception.class, \"malformed url\", malformed.getcaughtexception()); } } return value; } }; } else if (param instanceof enum) { enum e = (enum) param; return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { resulthandle nm = method.load(e.name()); return method.invokestaticmethod( ofmethod(e.getdeclaringclass(), \"valueof\", e.getdeclaringclass(), string.class), nm); } }; } else if (param instanceof returnedproxy) { returnedproxy rp = (returnedproxy) param; if (!rp.__static$$init() && staticinit) { throw new runtimeexception(\"invalid proxy passed to recorder. \" + rp + \" was created in a runtime recorder method, while this recorder is for a static init method. the object will not have been created at the time this method is run.\"); } string proxyid = rp.__returned$proxy$key(); return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokevirtualmethod(ofmethod(startupcontext.class, \"getvalue\", object.class, string.class), method.getmethodparam(0), method.load(proxyid)); } }; } else if (param instanceof duration) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(duration.class, \"parse\", duration.class, charsequence.class), method.load(param.tostring())); } }; } else if (param instanceof class<?>) { if (!((class) param).isprimitive()) { string name = classproxies.get(param); if (name == null) { name = ((class) param).getname(); } string finalname = name; return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { resulthandle currentthread = method .invokestaticmethod(ofmethod(thread.class, \"currentthread\", thread.class)); resulthandle tccl = method.invokevirtualmethod( ofmethod(thread.class, \"getcontextclassloader\", classloader.class), currentthread); return method.invokestaticmethod( ofmethod(class.class, \"forname\", class.class, string.class, boolean.class, classloader.class), method.load(finalname), method.load(true), tccl); } }; } else { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.loadclass((class) param); } }; } } else if (expectedtype == boolean.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((boolean) param); } }; } else if (expectedtype == boolean.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(boolean.class, \"valueof\", boolean.class, boolean.class), method.load((boolean) param)); } }; } else if (expectedtype == int.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((int) param); } }; } else if (expectedtype == integer.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(integer.class, \"valueof\", integer.class, int.class), method.load((int) param)); } }; } else if (expectedtype == short.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((short) param); } }; } else if (expectedtype == short.class || param instanceof short) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(short.class, \"valueof\", short.class, short.class), method.load((short) param)); } }; } else if (expectedtype == byte.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((byte) param); } }; } else if (expectedtype == byte.class || param instanceof byte) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(byte.class, \"valueof\", byte.class, byte.class), method.load((byte) param)); } }; } else if (expectedtype == char.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((char) param); } }; } else if (expectedtype == character.class || param instanceof character) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(character.class, \"valueof\", character.class, char.class), method.load((char) param)); } }; } else if (expectedtype == long.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((long) param); } }; } else if (expectedtype == long.class || param instanceof long) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(long.class, \"valueof\", long.class, long.class), method.load((long) param)); } }; } else if (expectedtype == float.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((float) param); } }; } else if (expectedtype == float.class || param instanceof float) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(float.class, \"valueof\", float.class, float.class), method.load((float) param)); } }; } else if (expectedtype == double.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((double) param); } }; } else if (expectedtype == double.class || param instanceof double) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(double.class, \"valueof\", double.class, double.class), method.load((double) param)); } }; } else if (expectedtype.isarray()) { int length = array.getlength(param); deferredparameter[] components = new deferredparameter[length]; for (int i = 0; i < length; ++i) { deferredparameter component = loadobjectinstance(array.get(param, i), existing, expectedtype.getcomponenttype(), relaxedvalidation); components[i] = component; } return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { for (int i = 0; i < length; ++i) { components[i].prepare(context); } super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { resulthandle out = method.newarray(expectedtype.getcomponenttype(), length); for (int i = 0; i < length; ++i) { method.writearrayvalue(out, i, context.loaddeferred(components[i])); } return out; } }; } else if (param instanceof annotationproxy) { annotationproxy annotationproxy = (annotationproxy) param; list<methodinfo> constructorparams = annotationproxy.getannotationclass().methods().stream() .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(collectors.tolist()); map<string, annotationvalue> annotationvalues = annotationproxy.getannotationinstance().values().stream() .collect(collectors.tomap(annotationvalue::name, function.identity())); deferredparameter[] constructorparamshandles = new deferredparameter[constructorparams.size()]; for (listiterator<methodinfo> iterator = constructorparams.listiterator(); iterator.hasnext();) { methodinfo valuemethod = iterator.next(); object explicitvalue = annotationproxy.getvalues().get(valuemethod.name()); if (explicitvalue != null) { constructorparamshandles[iterator.previousindex()] = loadobjectinstance(explicitvalue, existing, explicitvalue.getclass(), relaxedvalidation); } else { annotationvalue value = annotationvalues.get(valuemethod.name()); if (value == null) { object defaultvalue = annotationproxy.getdefaultvalues().get(valuemethod.name()); if (defaultvalue != null) { constructorparamshandles[iterator.previousindex()] = loadobjectinstance(defaultvalue, existing, defaultvalue.getclass(), relaxedvalidation); continue; } if (value == null) { value = valuemethod.defaultvalue(); } } if (value == null) { throw new nullpointerexception(\"value not set for \" + param); } deferredparameter retvalue = loadvalue(value, annotationproxy.getannotationclass(), valuemethod); constructorparamshandles[iterator.previousindex()] = retvalue; } } return new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { methoddescriptor constructor = methoddescriptor.ofconstructor(annotationproxy.getannotationliteraltype(), constructorparams.stream().map(m -> m.returntype().name().tostring()).toarray()); resulthandle[] args = new resulthandle[constructorparamshandles.length]; for (int i = 0; i < constructorparamshandles.length; i++) { deferredparameter deferredparameter = constructorparamshandles[i]; if (deferredparameter instanceof deferredarraystoreparameter) { deferredarraystoreparameter arrayparam = (deferredarraystoreparameter) deferredparameter; arrayparam.doprepare(context); } args[i] = context.loaddeferred(deferredparameter); } return method.newinstance(constructor, args); } }; } else { return loadcomplexobject(param, existing, expectedtype, relaxedvalidation); } }","comment":"\/** * returns a representation of a serialized parameter. *\/\n\/\/null is easy\n\/\/check the loaded object support (i.e. config) to see if this is a config item\n\/\/handle empty collections as returned by the collections object\n\/\/create the appropriate deferredparameter, a lot of these a fairly simple constant values, \/\/but some are quite complex when dealing with objects and collections\n\/\/check for substitution types, if present we invoke recursively on the substitution\n\/\/if this is a proxy we just grab the value from the startupcontext\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time \/\/we just load it from the startup context\n\/\/ only try to load the class by name if it is not a primitive class\n\/\/ else load the primitive type by reference; double.class => class var9 = double.type;\n\/\/todo large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array \/\/fix this later\n\/\/ new com.foo.myannotation_proxy_annotationliteral(\"foo\")\n\/\/ method.invokeinterfacemethod(map_put, valueshandle, method.load(entry.getkey()), loadobjectinstance(method, entry.getvalue(), \/\/ returnvalueresults, entry.getvalue().getclass()));","repo":"cdhermann\/quarkus","code_context_2":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nserialized.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\nResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\nreturn method.invokeInterfaceMethod(\nofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\ncreator.loadDeferred(serialized));\n}\n};\n} catch (Exception e) {\nthrow new RuntimeException(\"Failed to substitute \" + param, e);\n}\n} else if (param instanceof Optional) {\nOptional val = (Optional) param;\nif (val.isPresent()) {\nDeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nres.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\ncontext.loadDeferred(res));\n}\n};\n} else {\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n}\n};\n}\n} else if (param instanceof String) {\nif (((String) param).length() > 65535) {\nthrow new RuntimeException(\"String too large to record: \" + param);\n}\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((String) param);\n}\n};\n} else if (param instanceof Integer) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((Integer) param));\n}\n};\n} else if (param instanceof Boolean) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((Boolean) param));\n}\n};\n} else if (param instanceof URL) {\nString url = ((URL) param).toExternalForm();\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nAssignableResultHandle value = method.createVariable(URL.class);\ntry (TryBlock et = method.tryBlock()) {\net.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\ntry (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\nmalformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n}\n}\nreturn value;\n}\n};\n} else if (param instanceof Enum) {\nEnum e = (Enum) param;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.loadClass((Class) param);\n}\n};\n}\n} else if (expectedType == boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((boolean) param);\n}\n};\n} else if (expectedType == Boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((boolean) param));\n}\n};\n} else if (expectedType == int.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((int) param);\n}\n};\n} else if (expectedType == Integer.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((int) param));\n}\n};\n} else if (expectedType == short.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((short) param);\n}\n};\n} else if (expectedType == Short.class || param instanceof Short) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\nmethod.load((short) param));\n}\n};\n} else if (expectedType == byte.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((byte) param);\n}\n};\n} else if (expectedType == Byte.class || param instanceof Byte) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\nmethod.load((byte) param));\n}\n};\n} else if (expectedType == char.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((char) param);\n}\n};\n} else if (expectedType == Character.class || param instanceof Character) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\nmethod.load((char) param));\n}\n};\n} else if (expectedType == long.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((long) param);\n}\n};\n} else if (expectedType == Long.class || param instanceof Long) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\nmethod.load((long) param));\n}\n};\n} else if (expectedType == float.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((float) param);\n}\n};\n} else if (expectedType == Float.class || param instanceof Float) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\nmethod.load((float) param));\n}\n};\n} else if (expectedType == double.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((double) param);\n}\n};\n} else if (expectedType == Double.class || param instanceof Double) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\nmethod.load((double) param));\n}\n};\n} else if (expectedType.isArray()) {\nint length = Array.getLength(param);\nDeferredParameter[] components = new DeferredParameter[length];\nfor (int i = 0; i < length; ++i) {\nDeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\nexpectedType.getComponentType(), relaxedValidation);\ncomponents[i] = component;\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\ndefaultValue.getClass(), relaxedValidation);\ncontinue;\n}\nif (value == null) {\nvalue = valueMethod.defaultValue();\n}\n}\nif (value == null) {\nthrow new NullPointerException(\"Value not set for \" + param);\n}\nDeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\nconstructorParamsHandles[iterator.previousIndex()] = retValue;\n}\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nMethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\nconstructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\nResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\nfor (int i = 0; i < constructorParamsHandles.length; i++) {\nDeferredParameter deferredParameter = constructorParamsHandles[i];\nif (deferredParameter instanceof DeferredArrayStoreParameter) {\nDeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\narrayParam.doPrepare(context);\n}\nargs[i] = context.loadDeferred(deferredParameter);\n}\nreturn method.newInstance(constructor, args);\n}\n};\n} else {\nreturn loadComplexObject(param, existing, expectedType, relaxedValidation);\n}\n}\n\nprivate DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\n\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\n\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\n\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\n\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\n\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\n\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\n\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\n\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\n\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {","code_context_10":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nserialized.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\nResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\nreturn method.invokeInterfaceMethod(\nofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\ncreator.loadDeferred(serialized));\n}\n};\n} catch (Exception e) {\nthrow new RuntimeException(\"Failed to substitute \" + param, e);\n}\n} else if (param instanceof Optional) {\nOptional val = (Optional) param;\nif (val.isPresent()) {\nDeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nres.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\ncontext.loadDeferred(res));\n}\n};\n} else {\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n}\n};\n}\n} else if (param instanceof String) {\nif (((String) param).length() > 65535) {\nthrow new RuntimeException(\"String too large to record: \" + param);\n}\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((String) param);\n}\n};\n} else if (param instanceof Integer) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((Integer) param));\n}\n};\n} else if (param instanceof Boolean) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((Boolean) param));\n}\n};\n} else if (param instanceof URL) {\nString url = ((URL) param).toExternalForm();\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nAssignableResultHandle value = method.createVariable(URL.class);\ntry (TryBlock et = method.tryBlock()) {\net.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\ntry (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\nmalformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n}\n}\nreturn value;\n}\n};\n} else if (param instanceof Enum) {\nEnum e = (Enum) param;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.loadClass((Class) param);\n}\n};\n}\n} else if (expectedType == boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((boolean) param);\n}\n};\n} else if (expectedType == Boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((boolean) param));\n}\n};\n} else if (expectedType == int.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((int) param);\n}\n};\n} else if (expectedType == Integer.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((int) param));\n}\n};\n} else if (expectedType == short.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((short) param);\n}\n};\n} else if (expectedType == Short.class || param instanceof Short) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\nmethod.load((short) param));\n}\n};\n} else if (expectedType == byte.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((byte) param);\n}\n};\n} else if (expectedType == Byte.class || param instanceof Byte) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\nmethod.load((byte) param));\n}\n};\n} else if (expectedType == char.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((char) param);\n}\n};\n} else if (expectedType == Character.class || param instanceof Character) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\nmethod.load((char) param));\n}\n};\n} else if (expectedType == long.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((long) param);\n}\n};\n} else if (expectedType == Long.class || param instanceof Long) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\nmethod.load((long) param));\n}\n};\n} else if (expectedType == float.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((float) param);\n}\n};\n} else if (expectedType == Float.class || param instanceof Float) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\nmethod.load((float) param));\n}\n};\n} else if (expectedType == double.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((double) param);\n}\n};\n} else if (expectedType == Double.class || param instanceof Double) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\nmethod.load((double) param));\n}\n};\n} else if (expectedType.isArray()) {\nint length = Array.getLength(param);\nDeferredParameter[] components = new DeferredParameter[length];\nfor (int i = 0; i < length; ++i) {\nDeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\nexpectedType.getComponentType(), relaxedValidation);\ncomponents[i] = component;\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\ndefaultValue.getClass(), relaxedValidation);\ncontinue;\n}\nif (value == null) {\nvalue = valueMethod.defaultValue();\n}\n}\nif (value == null) {\nthrow new NullPointerException(\"Value not set for \" + param);\n}\nDeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\nconstructorParamsHandles[iterator.previousIndex()] = retValue;\n}\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nMethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\nconstructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\nResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\nfor (int i = 0; i < constructorParamsHandles.length; i++) {\nDeferredParameter deferredParameter = constructorParamsHandles[i];\nif (deferredParameter instanceof DeferredArrayStoreParameter) {\nDeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\narrayParam.doPrepare(context);\n}\nargs[i] = context.loadDeferred(deferredParameter);\n}\nreturn method.newInstance(constructor, args);\n}\n};\n} else {\nreturn loadComplexObject(param, existing, expectedType, relaxedValidation);\n}\n}\n\nprivate DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\n\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\n\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\n\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\n\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\n\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\n\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.loadClass((Class) param);\n}\n};\n}\n} else if (expectedType == boolean.class) {\nreturn new DeferredParameter() {\n@Override\n\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\n\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\n\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\ndefaultValue.getClass(), relaxedValidation);\ncontinue;\n}\nif (value == null) {\nvalue = valueMethod.defaultValue();\n}\n}","code_context_20":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nserialized.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\nResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\nreturn method.invokeInterfaceMethod(\nofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\ncreator.loadDeferred(serialized));\n}\n};\n} catch (Exception e) {\nthrow new RuntimeException(\"Failed to substitute \" + param, e);\n}\n} else if (param instanceof Optional) {\nOptional val = (Optional) param;\nif (val.isPresent()) {\nDeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nres.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\ncontext.loadDeferred(res));\n}\n};\n} else {\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n}\n};\n}\n} else if (param instanceof String) {\nif (((String) param).length() > 65535) {\nthrow new RuntimeException(\"String too large to record: \" + param);\n}\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((String) param);\n}\n};\n} else if (param instanceof Integer) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((Integer) param));\n}\n};\n} else if (param instanceof Boolean) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((Boolean) param));\n}\n};\n} else if (param instanceof URL) {\nString url = ((URL) param).toExternalForm();\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nAssignableResultHandle value = method.createVariable(URL.class);\ntry (TryBlock et = method.tryBlock()) {\net.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\ntry (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\nmalformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n}\n}\nreturn value;\n}\n};\n} else if (param instanceof Enum) {\nEnum e = (Enum) param;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.loadClass((Class) param);\n}\n};\n}\n} else if (expectedType == boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((boolean) param);\n}\n};\n} else if (expectedType == Boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((boolean) param));\n}\n};\n} else if (expectedType == int.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((int) param);\n}\n};\n} else if (expectedType == Integer.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\nmethod.load((int) param));\n}\n};\n} else if (expectedType == short.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((short) param);\n}\n};\n} else if (expectedType == Short.class || param instanceof Short) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\nmethod.load((short) param));\n}\n};\n} else if (expectedType == byte.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((byte) param);\n}\n};\n} else if (expectedType == Byte.class || param instanceof Byte) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\nmethod.load((byte) param));\n}\n};\n} else if (expectedType == char.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((char) param);\n}\n};\n} else if (expectedType == Character.class || param instanceof Character) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\nmethod.load((char) param));\n}\n};\n} else if (expectedType == long.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((long) param);\n}\n};\n} else if (expectedType == Long.class || param instanceof Long) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\nmethod.load((long) param));\n}\n};\n} else if (expectedType == float.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((float) param);\n}\n};\n} else if (expectedType == Float.class || param instanceof Float) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\nmethod.load((float) param));\n}\n};\n} else if (expectedType == double.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((double) param);\n}\n};\n} else if (expectedType == Double.class || param instanceof Double) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\nmethod.load((double) param));\n}\n};\n} else if (expectedType.isArray()) {\nint length = Array.getLength(param);\nDeferredParameter[] components = new DeferredParameter[length];\nfor (int i = 0; i < length; ++i) {\nDeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\nexpectedType.getComponentType(), relaxedValidation);\ncomponents[i] = component;\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\ndefaultValue.getClass(), relaxedValidation);\ncontinue;\n}\nif (value == null) {\nvalue = valueMethod.defaultValue();\n}\n}\nif (value == null) {\nthrow new NullPointerException(\"Value not set for \" + param);\n}\nDeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\nconstructorParamsHandles[iterator.previousIndex()] = retValue;\n}\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nMethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\nconstructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\nResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\nfor (int i = 0; i < constructorParamsHandles.length; i++) {\nDeferredParameter deferredParameter = constructorParamsHandles[i];\nif (deferredParameter instanceof DeferredArrayStoreParameter) {\nDeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\narrayParam.doPrepare(context);\n}\nargs[i] = context.loadDeferred(deferredParameter);\n}\nreturn method.newInstance(constructor, args);\n}\n};\n} else {\nreturn loadComplexObject(param, existing, expectedType, relaxedValidation);\n}\n}\n\nprivate DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\n\nprivate DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\n\nprivate DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/null is easy\nif (param == null) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nserialized.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\nResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\n\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\nreturn method.loadNull();\n}\n};\n}\n\/\/check the loaded object support (i.e. config) to see if this is a config item\nDeferredParameter loadedObject = findLoaded(param);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/Handle empty collections as returned by the Collections object\nloadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\nif (loadedObject != null) {\nreturn loadedObject;\n}\n\/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n\/\/but some are quite complex when dealing with objects and collections\nif (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n\/\/check for substitution types, if present we invoke recursively on the substitution\nSubstitutionHolder holder = substitutions.get(param.getClass());\nif (holder == null) {\nholder = substitutions.get(expectedType);\n}\ntry {\nObjectSubstitution substitution = holder.sub.newInstance();\nObject res = substitution.serialize(param);\nDeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\nSubstitutionHolder finalHolder = holder;\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nserialized.prepare(context);\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\nResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\nreturn method.invokeInterfaceMethod(\nofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\n\net.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\ntry (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\nmalformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n}\n}\nreturn value;\n}\n};\n} else if (param instanceof Enum) {\nEnum e = (Enum) param;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\n\n};\n} else if (param instanceof Enum) {\nEnum e = (Enum) param;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle nm = method.load(e.name());\nreturn method.invokeStaticMethod(\nofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\nnm);\n}\n};\n} else if (param instanceof ReturnedProxy) {\n\/\/if this is a proxy we just grab the value from the StartupContext\nReturnedProxy rp = (ReturnedProxy) param;\nif (!rp.__static$$init() && staticInit) {\nthrow new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n+ \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n}\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\n\nString proxyId = rp.__returned$proxy$key();\n\/\/because this is the result of a method invocation that may not have happened at param deserialization time\n\/\/we just load it from the startup context\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\nmethod.getMethodParam(0), method.load(proxyId));\n}\n};\n} else if (param instanceof Duration) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\nmethod.load(param.toString()));\n}\n};\n} else if (param instanceof Class<?>) {\nif (!((Class) param).isPrimitive()) {\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\n\n\/\/ Only try to load the class by name if it is not a primitive class\nString name = classProxies.get(param);\nif (name == null) {\nname = ((Class) param).getName();\n}\nString finalName = name;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle currentThread = method\n.invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\nResultHandle tccl = method.invokeVirtualMethod(\nofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\ncurrentThread);\nreturn method.invokeStaticMethod(\nofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\nmethod.load(finalName), method.load(true), tccl);\n}\n};\n} else {\n\/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.loadClass((Class) param);\n}\n};\n}\n} else if (expectedType == boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.load((boolean) param);\n}\n};\n} else if (expectedType == Boolean.class) {\nreturn new DeferredParameter() {\n@Override\nResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\nreturn method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\nmethod.load((boolean) param));\n\n}\n};\n} else if (expectedType.isArray()) {\nint length = Array.getLength(param);\nDeferredParameter[] components = new DeferredParameter[length];\nfor (int i = 0; i < length; ++i) {\nDeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\nexpectedType.getComponentType(), relaxedValidation);\ncomponents[i] = component;\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\n\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\nfor (int i = 0; i < length; ++i) {\ncomponents[i].prepare(context);\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n\/\/fix this later\nResultHandle out = method.newArray(expectedType.getComponentType(), length);\nfor (int i = 0; i < length; ++i) {\nmethod.writeArrayValue(out, i, context.loadDeferred(components[i]));\n}\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\n\nreturn out;\n}\n};\n} else if (param instanceof AnnotationProxy) {\n\/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\nAnnotationProxy annotationProxy = (AnnotationProxy) param;\nList<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n.filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\nMap<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n.collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\nDeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\nfor (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\nMethodInfo valueMethod = iterator.next();\nObject explicitValue = annotationProxy.getValues().get(valueMethod.name());\nif (explicitValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\nexplicitValue.getClass(), relaxedValidation);\n} else {\nAnnotationValue value = annotationValues.get(valueMethod.name());\nif (value == null) {\n\/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n\/\/ returnValueResults, entry.getValue().getClass()));\nObject defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\nif (defaultValue != null) {\nconstructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\ndefaultValue.getClass(), relaxedValidation);\ncontinue;\n}\nif (value == null) {\nvalue = valueMethod.defaultValue();\n}\n}\nif (value == null) {\nthrow new NullPointerException(\"Value not set for \" + param);\n}\nDeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\nconstructorParamsHandles[iterator.previousIndex()] = retValue;\n}\n}\nreturn new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {","label":[0,0,1,0]}
{"id":26392,"original_code":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n        \/\/a list of steps that are performed on the object after it has been created\n        \/\/we need to create all these first, to ensure the required objects have already\n        \/\/been deserialized\n        List<SerialzationStep> setupSteps = new ArrayList<>();\n        List<SerialzationStep> ctorSetupSteps = new ArrayList<>();\n        boolean relaxedOk = false;\n        if (param instanceof Collection) {\n            \/\/if this is a collection we want to serialize every element\n            for (Object i : (Collection) param) {\n                DeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        \/\/each step can happen in a new method, so it is safe to do this\n                        method.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        \/\/handle the value serialization\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        if (param instanceof Map) {\n            \/\/map works the same as collection\n            for (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\n                DeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n                DeferredParameter val = i.getValue() != null\n                        ? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n                        : loadObjectInstance(null, existing, Object.class, relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        method.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\n                                context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        key.prepare(context);\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        \/\/check how the object is constructed\n        NonDefaultConstructorHolder nonDefaultConstructorHolder = null;\n        DeferredParameter[] nonDefaultConstructorHandles = null;\n        \/\/used to resolve the parameter position for @RecordableConstructor\n        Map<String, Integer> constructorParamNameMap = new HashMap<>();\n        if (nonDefaultConstructors.containsKey(param.getClass())) {\n            nonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\n            List<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\n            if (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\n                throw new RuntimeException(\"Unable to serialize \" + param\n                        + \" as the wrong number of parameters were generated for \"\n                        + nonDefaultConstructorHolder.constructor);\n            }\n            int count = 0;\n            nonDefaultConstructorHandles = new DeferredParameter[params.size()];\n            for (int i = 0; i < params.size(); i++) {\n                Object obj = params.get(i);\n                nonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\n                        nonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n            }\n        } else {\n            for (Constructor<?> ctor : param.getClass().getConstructors()) {\n                if (ctor.isAnnotationPresent(RecordableConstructor.class)) {\n                    nonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\n                    nonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\n                    for (int i = 0; i < ctor.getParameterCount(); ++i) {\n                        String name = ctor.getParameters()[i].getName();\n                        constructorParamNameMap.put(name, i);\n                    }\n                    break;\n                }\n            }\n        }\n        Set<String> handledProperties = new HashSet<>();\n        Property[] desc = PropertyUtils.getPropertyDescriptors(param);\n        for (Property i : desc) {\n            \/\/ check if the getter is ignored\n            if ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\n                continue;\n            }\n            \/\/ check if the matching field is ignored\n            try {\n                if (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\n                    continue;\n                }\n            } catch (NoSuchFieldException ignored) {\n            }\n            Integer ctorParamIndex = constructorParamNameMap.remove(i.name);\n            if (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\n                try {\n                    \/\/read only prop, we may still be able to do stuff with it if it is a collection\n                    if (Collection.class.isAssignableFrom(i.getPropertyType())) {\n                        \/\/special case, a collection with only a read method\n                        \/\/we assume we can just add to the connection\n                        handledProperties.add(i.getName());\n                        Collection propertyValue = (Collection) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            List<DeferredParameter> params = new ArrayList<>();\n                            for (Object c : propertyValue) {\n                                DeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\n                                params.add(toAdd);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    \/\/get the collection\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (DeferredParameter i : params) {\n                                        \/\/add the parameter\n                                        \/\/TODO: this is not guareded against large collections, probably not an issue in practice\n                                        method.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (DeferredParameter i : params) {\n                                        i.prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n                        \/\/special case, a map with only a read method\n                        \/\/we assume we can just add to the map\n                        \/\/similar to how collection works above\n                        handledProperties.add(i.getName());\n                        Map<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            Map<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\n                            for (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\n                                DeferredParameter key = loadObjectInstance(entry.getKey(), existing,\n                                        Object.class, relaxedValidation);\n                                DeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\n                                        relaxedValidation);\n                                def.put(key, val);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        method.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\n                                                context.loadDeferred(e.getValue()));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        e.getKey().prepare(context);\n                                        e.getValue().prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n                            && nonDefaultConstructorHolder == null) {\n                        \/\/check if there is actually a field with the name\n                        try {\n                            i.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\n                            throw new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n                                    + \"' as the property is read only\");\n                        } catch (NoSuchFieldException e) {\n                            \/\/if there is no underlying field then we ignore the property\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n                \/\/normal javabean property\n                try {\n                    handledProperties.add(i.getName());\n                    Object propertyValue = i.read(param);\n                    if (propertyValue == null && ctorParamIndex == null) {\n                        \/\/we just assume properties are null by default\n                        \/\/TODO: is this a valid assumption? Should we check this by creating an instance?\n                        continue;\n                    }\n                    Class propertyType = i.getPropertyType();\n                    if (ctorParamIndex == null\n                            && i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\n                        if (relaxedValidation) {\n                            \/\/this is a weird situation where the reader and writer are different types\n                            \/\/we iterate and try and find a valid setter method for the type we have\n                            \/\/OpenAPI does some weird stuff like this\n                            for (Method m : param.getClass().getMethods()) {\n                                if (m.getName().equals(i.getWriteMethod().getName())) {\n                                    if (m.getParameterTypes().length > 0\n                                            && m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\n                                        propertyType = m.getParameterTypes()[0];\n                                        break;\n                                    }\n                                }\n                            }\n                        } else {\n                            throw new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n                                    + \" as setter and getters were different types\");\n                        }\n                    }\n                    DeferredParameter val = loadObjectInstance(propertyValue, existing,\n                            i.getPropertyType(), relaxedValidation);\n                    if (ctorParamIndex != null) {\n                        nonDefaultConstructorHandles[ctorParamIndex] = val;\n                        ctorSetupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    } else {\n                        Class finalPropertyType = propertyType;\n                        setupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                                method.invokeVirtualMethod(\n                                        ofMethod(param.getClass(), i.getWriteMethod().getName(),\n                                                i.getWriteMethod().getReturnType(),\n                                                finalPropertyType),\n                                        context.loadDeferred(out),\n                                        context.loadDeferred(val));\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        \/\/now handle accessible fields\n        for (Field field : param.getClass().getFields()) {\n            \/\/ check if the field is ignored\n            if (field.getAnnotation(IgnoreProperty.class) != null) {\n                continue;\n            }\n            if (!handledProperties.contains(field.getName())) {\n                Integer ctorParamIndex = constructorParamNameMap.remove(field.getName());\n                if ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n                        !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        DeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\n                                relaxedValidation);\n                        if (ctorParamIndex != null) {\n                            nonDefaultConstructorHandles[ctorParamIndex] = val;\n                            ctorSetupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        } else {\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    method.writeInstanceField(\n                                            FieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\n                                            context.loadDeferred(out),\n                                            context.loadDeferred(val));\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        }\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        }\n        if (!constructorParamNameMap.isEmpty()) {\n            throw new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n                    + \" could not read field values \" + constructorParamNameMap.keySet());\n        }\n        NonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\n        DeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n        \/\/create a deferred value to represet the object itself. This allows the creation to be split\n        \/\/over multiple methods, which is important if this is a large object\n        DeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                ResultHandle out;\n                \/\/do the creation\n                if (finalNonDefaultConstructorHolder != null) {\n                    out = method.newInstance(\n                            ofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\n                                    finalNonDefaultConstructorHolder.constructor.getParameterTypes()),\n                            Arrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n                                    .toArray(ResultHandle[]::new));\n                } else {\n                    try {\n                        param.getClass().getDeclaredConstructor();\n                        out = method.newInstance(ofConstructor(param.getClass()));\n                    } catch (NoSuchMethodException e) {\n                        \/\/fallback for collection types, such as unmodifiableMap\n                        if (SortedMap.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeMap.class));\n                        } else if (Map.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashMap.class));\n                        } else if (List.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(ArrayList.class));\n                        } else if (SortedSet.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeSet.class));\n                        } else if (Set.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashSet.class));\n                        } else {\n                            throw new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n                                    + \" to bytecode as it has no default constructor\");\n                        }\n                    }\n                }\n                return out;\n            }\n        };\n        \/\/now return the actual deferred parameter that represents the result of construction\n        return new DeferredArrayStoreParameter() {\n            @Override\n            void doPrepare(MethodContext context) {\n                \/\/this is where the object construction happens\n                \/\/first create the actial object\n                for (SerialzationStep i : ctorSetupSteps) {\n                    i.prepare(context);\n                }\n                objectValue.prepare(context);\n                for (SerialzationStep i : setupSteps) {\n                    \/\/then prepare the steps (i.e. creating the values to be placed into this object)\n                    i.prepare(context);\n                }\n                for (SerialzationStep i : setupSteps) {\n                    \/\/now actually run the steps (i.e. actually stick the values into the object)\n                    context.writeInstruction(new InstructionGroup() {\n                        @Override\n                        public void write(MethodContext context, MethodCreator method, ResultHandle array) {\n                            i.handle(context, method, objectValue);\n                        }\n                    });\n                }\n                super.doPrepare(context);\n            }\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                \/\/just return the already created object\n                return context.loadDeferred(objectValue);\n            }\n        };\n    }","code":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n       \n       \n       \n        List<SerialzationStep> setupSteps = new ArrayList<>();\n        List<SerialzationStep> ctorSetupSteps = new ArrayList<>();\n        boolean relaxedOk = false;\n        if (param instanceof Collection) {\n           \n            for (Object i : (Collection) param) {\n                DeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                       \n                        method.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                       \n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        if (param instanceof Map) {\n           \n            for (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\n                DeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n                DeferredParameter val = i.getValue() != null\n                        ? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n                        : loadObjectInstance(null, existing, Object.class, relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        method.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\n                                context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        key.prepare(context);\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n       \n        NonDefaultConstructorHolder nonDefaultConstructorHolder = null;\n        DeferredParameter[] nonDefaultConstructorHandles = null;\n       \n        Map<String, Integer> constructorParamNameMap = new HashMap<>();\n        if (nonDefaultConstructors.containsKey(param.getClass())) {\n            nonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\n            List<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\n            if (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\n                throw new RuntimeException(\"Unable to serialize \" + param\n                        + \" as the wrong number of parameters were generated for \"\n                        + nonDefaultConstructorHolder.constructor);\n            }\n            int count = 0;\n            nonDefaultConstructorHandles = new DeferredParameter[params.size()];\n            for (int i = 0; i < params.size(); i++) {\n                Object obj = params.get(i);\n                nonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\n                        nonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n            }\n        } else {\n            for (Constructor<?> ctor : param.getClass().getConstructors()) {\n                if (ctor.isAnnotationPresent(RecordableConstructor.class)) {\n                    nonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\n                    nonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\n                    for (int i = 0; i < ctor.getParameterCount(); ++i) {\n                        String name = ctor.getParameters()[i].getName();\n                        constructorParamNameMap.put(name, i);\n                    }\n                    break;\n                }\n            }\n        }\n        Set<String> handledProperties = new HashSet<>();\n        Property[] desc = PropertyUtils.getPropertyDescriptors(param);\n        for (Property i : desc) {\n           \n            if ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\n                continue;\n            }\n           \n            try {\n                if (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\n                    continue;\n                }\n            } catch (NoSuchFieldException ignored) {\n            }\n            Integer ctorParamIndex = constructorParamNameMap.remove(i.name);\n            if (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\n                try {\n                   \n                    if (Collection.class.isAssignableFrom(i.getPropertyType())) {\n                       \n                       \n                        handledProperties.add(i.getName());\n                        Collection propertyValue = (Collection) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            List<DeferredParameter> params = new ArrayList<>();\n                            for (Object c : propertyValue) {\n                                DeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\n                                params.add(toAdd);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                   \n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (DeferredParameter i : params) {\n                                       \n                                       \n                                        method.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (DeferredParameter i : params) {\n                                        i.prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n                       \n                       \n                       \n                        handledProperties.add(i.getName());\n                        Map<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            Map<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\n                            for (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\n                                DeferredParameter key = loadObjectInstance(entry.getKey(), existing,\n                                        Object.class, relaxedValidation);\n                                DeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\n                                        relaxedValidation);\n                                def.put(key, val);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        method.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\n                                                context.loadDeferred(e.getValue()));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        e.getKey().prepare(context);\n                                        e.getValue().prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n                            && nonDefaultConstructorHolder == null) {\n                       \n                        try {\n                            i.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\n                            throw new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n                                    + \"' as the property is read only\");\n                        } catch (NoSuchFieldException e) {\n                           \n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n               \n                try {\n                    handledProperties.add(i.getName());\n                    Object propertyValue = i.read(param);\n                    if (propertyValue == null && ctorParamIndex == null) {\n                       \n                       \n                        continue;\n                    }\n                    Class propertyType = i.getPropertyType();\n                    if (ctorParamIndex == null\n                            && i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\n                        if (relaxedValidation) {\n                           \n                           \n                           \n                            for (Method m : param.getClass().getMethods()) {\n                                if (m.getName().equals(i.getWriteMethod().getName())) {\n                                    if (m.getParameterTypes().length > 0\n                                            && m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\n                                        propertyType = m.getParameterTypes()[0];\n                                        break;\n                                    }\n                                }\n                            }\n                        } else {\n                            throw new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n                                    + \" as setter and getters were different types\");\n                        }\n                    }\n                    DeferredParameter val = loadObjectInstance(propertyValue, existing,\n                            i.getPropertyType(), relaxedValidation);\n                    if (ctorParamIndex != null) {\n                        nonDefaultConstructorHandles[ctorParamIndex] = val;\n                        ctorSetupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    } else {\n                        Class finalPropertyType = propertyType;\n                        setupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                                method.invokeVirtualMethod(\n                                        ofMethod(param.getClass(), i.getWriteMethod().getName(),\n                                                i.getWriteMethod().getReturnType(),\n                                                finalPropertyType),\n                                        context.loadDeferred(out),\n                                        context.loadDeferred(val));\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n       \n        for (Field field : param.getClass().getFields()) {\n           \n            if (field.getAnnotation(IgnoreProperty.class) != null) {\n                continue;\n            }\n            if (!handledProperties.contains(field.getName())) {\n                Integer ctorParamIndex = constructorParamNameMap.remove(field.getName());\n                if ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n                        !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        DeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\n                                relaxedValidation);\n                        if (ctorParamIndex != null) {\n                            nonDefaultConstructorHandles[ctorParamIndex] = val;\n                            ctorSetupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        } else {\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    method.writeInstanceField(\n                                            FieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\n                                            context.loadDeferred(out),\n                                            context.loadDeferred(val));\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        }\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        }\n        if (!constructorParamNameMap.isEmpty()) {\n            throw new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n                    + \" could not read field values \" + constructorParamNameMap.keySet());\n        }\n        NonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\n        DeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n       \n       \n        DeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                ResultHandle out;\n               \n                if (finalNonDefaultConstructorHolder != null) {\n                    out = method.newInstance(\n                            ofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\n                                    finalNonDefaultConstructorHolder.constructor.getParameterTypes()),\n                            Arrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n                                    .toArray(ResultHandle[]::new));\n                } else {\n                    try {\n                        param.getClass().getDeclaredConstructor();\n                        out = method.newInstance(ofConstructor(param.getClass()));\n                    } catch (NoSuchMethodException e) {\n                       \n                        if (SortedMap.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeMap.class));\n                        } else if (Map.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashMap.class));\n                        } else if (List.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(ArrayList.class));\n                        } else if (SortedSet.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeSet.class));\n                        } else if (Set.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashSet.class));\n                        } else {\n                            throw new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n                                    + \" to bytecode as it has no default constructor\");\n                        }\n                    }\n                }\n                return out;\n            }\n        };\n       \n        return new DeferredArrayStoreParameter() {\n            @Override\n            void doPrepare(MethodContext context) {\n               \n               \n                for (SerialzationStep i : ctorSetupSteps) {\n                    i.prepare(context);\n                }\n                objectValue.prepare(context);\n                for (SerialzationStep i : setupSteps) {\n                   \n                    i.prepare(context);\n                }\n                for (SerialzationStep i : setupSteps) {\n                   \n                    context.writeInstruction(new InstructionGroup() {\n                        @Override\n                        public void write(MethodContext context, MethodCreator method, ResultHandle array) {\n                            i.handle(context, method, objectValue);\n                        }\n                    });\n                }\n                super.doPrepare(context);\n            }\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n               \n                return context.loadDeferred(objectValue);\n            }\n        };\n    }","cleancode":"private deferredparameter loadcomplexobject(object param, map<object, deferredparameter> existing, class<?> expectedtype, boolean relaxedvalidation) { list<serialzationstep> setupsteps = new arraylist<>(); list<serialzationstep> ctorsetupsteps = new arraylist<>(); boolean relaxedok = false; if (param instanceof collection) { for (object i : (collection) param) { deferredparameter val = loadobjectinstance(i, existing, i.getclass(), relaxedvalidation); setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokeinterfacemethod(collection_add, context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } relaxedok = true; } if (param instanceof map) { for (map.entry<?, ?> i : ((map<?, ?>) param).entryset()) { deferredparameter key = loadobjectinstance(i.getkey(), existing, i.getkey().getclass(), relaxedvalidation); deferredparameter val = i.getvalue() != null ? loadobjectinstance(i.getvalue(), existing, i.getvalue().getclass(), relaxedvalidation) : loadobjectinstance(null, existing, object.class, relaxedvalidation); setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokeinterfacemethod(map_put, context.loaddeferred(out), context.loaddeferred(key), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { key.prepare(context); val.prepare(context); } }); } relaxedok = true; } nondefaultconstructorholder nondefaultconstructorholder = null; deferredparameter[] nondefaultconstructorhandles = null; map<string, integer> constructorparamnamemap = new hashmap<>(); if (nondefaultconstructors.containskey(param.getclass())) { nondefaultconstructorholder = nondefaultconstructors.get(param.getclass()); list<object> params = nondefaultconstructorholder.paramgenerator.apply(param); if (params.size() != nondefaultconstructorholder.constructor.getparametercount()) { throw new runtimeexception(\"unable to serialize \" + param + \" as the wrong number of parameters were generated for \" + nondefaultconstructorholder.constructor); } int count = 0; nondefaultconstructorhandles = new deferredparameter[params.size()]; for (int i = 0; i < params.size(); i++) { object obj = params.get(i); nondefaultconstructorhandles[i] = loadobjectinstance(obj, existing, nondefaultconstructorholder.constructor.getparametertypes()[count++], relaxedvalidation); } } else { for (constructor<?> ctor : param.getclass().getconstructors()) { if (ctor.isannotationpresent(recordableconstructor.class)) { nondefaultconstructorholder = new nondefaultconstructorholder(ctor, null); nondefaultconstructorhandles = new deferredparameter[ctor.getparametercount()]; for (int i = 0; i < ctor.getparametercount(); ++i) { string name = ctor.getparameters()[i].getname(); constructorparamnamemap.put(name, i); } break; } } } set<string> handledproperties = new hashset<>(); property[] desc = propertyutils.getpropertydescriptors(param); for (property i : desc) { if ((i.getreadmethod() != null) && (i.getreadmethod().getannotation(ignoreproperty.class) != null)) { continue; } try { if (param.getclass().getdeclaredfield(i.getname()).getannotation(ignoreproperty.class) != null) { continue; } } catch (nosuchfieldexception ignored) { } integer ctorparamindex = constructorparamnamemap.remove(i.name); if (i.getreadmethod() != null && i.getwritemethod() == null && ctorparamindex == null) { try { if (collection.class.isassignablefrom(i.getpropertytype())) { handledproperties.add(i.getname()); collection propertyvalue = (collection) i.read(param); if (propertyvalue != null && !propertyvalue.isempty()) { list<deferredparameter> params = new arraylist<>(); for (object c : propertyvalue) { deferredparameter toadd = loadobjectinstance(c, existing, object.class, relaxedvalidation); params.add(toadd); } setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { resulthandle prop = method.invokevirtualmethod( methoddescriptor.ofmethod(i.getreadmethod()), context.loaddeferred(out)); for (deferredparameter i : params) { method.invokeinterfacemethod(collection_add, prop, context.loaddeferred(i)); } } @override public void prepare(methodcontext context) { for (deferredparameter i : params) { i.prepare(context); } } }); } } else if (map.class.isassignablefrom(i.getpropertytype())) { handledproperties.add(i.getname()); map<object, object> propertyvalue = (map<object, object>) i.read(param); if (propertyvalue != null && !propertyvalue.isempty()) { map<deferredparameter, deferredparameter> def = new linkedhashmap<>(); for (map.entry<object, object> entry : propertyvalue.entryset()) { deferredparameter key = loadobjectinstance(entry.getkey(), existing, object.class, relaxedvalidation); deferredparameter val = loadobjectinstance(entry.getvalue(), existing, object.class, relaxedvalidation); def.put(key, val); } setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { resulthandle prop = method.invokevirtualmethod( methoddescriptor.ofmethod(i.getreadmethod()), context.loaddeferred(out)); for (map.entry<deferredparameter, deferredparameter> e : def.entryset()) { method.invokeinterfacemethod(map_put, prop, context.loaddeferred(e.getkey()), context.loaddeferred(e.getvalue())); } } @override public void prepare(methodcontext context) { for (map.entry<deferredparameter, deferredparameter> e : def.entryset()) { e.getkey().prepare(context); e.getvalue().prepare(context); } } }); } } else if (!relaxedvalidation && !i.getname().equals(\"class\") && !relaxedok && nondefaultconstructorholder == null) { try { i.getreadmethod().getdeclaringclass().getdeclaredfield(i.getname()); throw new runtimeexception(\"cannot serialise field '\" + i.getname() + \"' on object '\" + param + \"' as the property is read only\"); } catch (nosuchfieldexception e) { } } } catch (exception e) { throw new runtimeexception(e); } } else if (i.getreadmethod() != null && (i.getwritemethod() != null || ctorparamindex != null)) { try { handledproperties.add(i.getname()); object propertyvalue = i.read(param); if (propertyvalue == null && ctorparamindex == null) { continue; } class propertytype = i.getpropertytype(); if (ctorparamindex == null && i.getreadmethod().getreturntype() != i.getwritemethod().getparametertypes()[0]) { if (relaxedvalidation) { for (method m : param.getclass().getmethods()) { if (m.getname().equals(i.getwritemethod().getname())) { if (m.getparametertypes().length > 0 && m.getparametertypes()[0].isassignablefrom(param.getclass())) { propertytype = m.getparametertypes()[0]; break; } } } } else { throw new runtimeexception(\"cannot serialise field \" + i.getname() + \" on object \" + param + \" as setter and getters were different types\"); } } deferredparameter val = loadobjectinstance(propertyvalue, existing, i.getpropertytype(), relaxedvalidation); if (ctorparamindex != null) { nondefaultconstructorhandles[ctorparamindex] = val; ctorsetupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { } @override public void prepare(methodcontext context) { val.prepare(context); } }); } else { class finalpropertytype = propertytype; setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokevirtualmethod( ofmethod(param.getclass(), i.getwritemethod().getname(), i.getwritemethod().getreturntype(), finalpropertytype), context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } } catch (exception e) { throw new runtimeexception(e); } } } for (field field : param.getclass().getfields()) { if (field.getannotation(ignoreproperty.class) != null) { continue; } if (!handledproperties.contains(field.getname())) { integer ctorparamindex = constructorparamnamemap.remove(field.getname()); if ((ctorparamindex != null || !modifier.isfinal(field.getmodifiers())) && !modifier.isstatic(field.getmodifiers())) { try { deferredparameter val = loadobjectinstance(field.get(param), existing, field.gettype(), relaxedvalidation); if (ctorparamindex != null) { nondefaultconstructorhandles[ctorparamindex] = val; ctorsetupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { } @override public void prepare(methodcontext context) { val.prepare(context); } }); } else { setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.writeinstancefield( fielddescriptor.of(param.getclass(), field.getname(), field.gettype()), context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } } catch (exception e) { throw new runtimeexception(e); } } } } if (!constructorparamnamemap.isempty()) { throw new runtimeexception(\"could not find parameters for constructor \" + nondefaultconstructorholder.constructor + \" could not read field values \" + constructorparamnamemap.keyset()); } nondefaultconstructorholder finalnondefaultconstructorholder = nondefaultconstructorholder; deferredparameter[] finalctorhandles = nondefaultconstructorhandles; deferredarraystoreparameter objectvalue = new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { resulthandle out; if (finalnondefaultconstructorholder != null) { out = method.newinstance( ofconstructor(finalnondefaultconstructorholder.constructor.getdeclaringclass(), finalnondefaultconstructorholder.constructor.getparametertypes()), arrays.stream(finalctorhandles).map(m -> context.loaddeferred(m)) .toarray(resulthandle[]::new)); } else { try { param.getclass().getdeclaredconstructor(); out = method.newinstance(ofconstructor(param.getclass())); } catch (nosuchmethodexception e) { if (sortedmap.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(treemap.class)); } else if (map.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(linkedhashmap.class)); } else if (list.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(arraylist.class)); } else if (sortedset.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(treeset.class)); } else if (set.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(linkedhashset.class)); } else { throw new runtimeexception(\"unable to serialize objects of type \" + param.getclass() + \" to bytecode as it has no default constructor\"); } } } return out; } }; return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { for (serialzationstep i : ctorsetupsteps) { i.prepare(context); } objectvalue.prepare(context); for (serialzationstep i : setupsteps) { i.prepare(context); } for (serialzationstep i : setupsteps) { context.writeinstruction(new instructiongroup() { @override public void write(methodcontext context, methodcreator method, resulthandle array) { i.handle(context, method, objectvalue); } }); } super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return context.loaddeferred(objectvalue); } }; }","comment":"\/** * created a {@link deferredparameter} to load a complex object, such as a javabean or collection. this is basically * just an extension of {@link #loadobjectinstanceimpl(object, map, class, boolean)} but it removes some of the more complex * code from that method. * * @param param the object to load * @param existing the existing object map * @param expectedtype the expected type of the object * @param relaxedvalidation * @return *\/\n\/\/a list of steps that are performed on the object after it has been created \/\/we need to create all these first, to ensure the required objects have already \/\/been deserialized\n\/\/if this is a collection we want to serialize every element\n\/\/each step can happen in a new method, so it is safe to do this\n\/\/handle the value serialization\n\/\/map works the same as collection\n\/\/check how the object is constructed\n\/\/used to resolve the parameter position for @recordableconstructor\n\/\/ check if the getter is ignored\n\/\/ check if the matching field is ignored\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\n\/\/special case, a collection with only a read method \/\/we assume we can just add to the connection\n\/\/get the collection\n\/\/add the parameter \/\/todo: this is not guareded against large collections, probably not an issue in practice\n\/\/special case, a map with only a read method \/\/we assume we can just add to the map \/\/similar to how collection works above\n\/\/check if there is actually a field with the name\n\/\/if there is no underlying field then we ignore the property\n\/\/normal javabean property\n\/\/we just assume properties are null by default \/\/todo: is this a valid assumption? should we check this by creating an instance?\n\/\/this is a weird situation where the reader and writer are different types \/\/we iterate and try and find a valid setter method for the type we have \/\/openapi does some weird stuff like this\n\/\/now handle accessible fields\n\/\/ check if the field is ignored\n\/\/create a deferred value to represet the object itself. this allows the creation to be split \/\/over multiple methods, which is important if this is a large object\n\/\/do the creation\n\/\/fallback for collection types, such as unmodifiablemap\n\/\/now return the actual deferred parameter that represents the result of construction\n\/\/this is where the object construction happens \/\/first create the actial object\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\n\/\/now actually run the steps (i.e. actually stick the values into the object)\n\/\/just return the already created object","repo":"cdhermann\/quarkus","code_context_2":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\nnonDefaultConstructorHandles = new DeferredParameter[params.size()];\nfor (int i = 0; i < params.size(); i++) {\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\nnonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\nfor (int i = 0; i < ctor.getParameterCount(); ++i) {\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\nDeferredParameter key = loadObjectInstance(entry.getKey(), existing,\nObject.class, relaxedValidation);\nDeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\nrelaxedValidation);\ndef.put(key, val);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\nmethod.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\ncontext.loadDeferred(e.getValue()));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\nthrow new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n+ \" as setter and getters were different types\");\n}\n}\nDeferredParameter val = loadObjectInstance(propertyValue, existing,\ni.getPropertyType(), relaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nClass finalPropertyType = propertyType;\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeVirtualMethod(\nofMethod(param.getClass(), i.getWriteMethod().getName(),\ni.getWriteMethod().getReturnType(),\nfinalPropertyType),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nmethod.writeInstanceField(\nFieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\n\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\n\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\n\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\n\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\n\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\n\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\n\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\n\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\n\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\n\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\n\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\n\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\n\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\n\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\n\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\n\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\n\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}","code_context_10":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\nnonDefaultConstructorHandles = new DeferredParameter[params.size()];\nfor (int i = 0; i < params.size(); i++) {\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\nnonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\nfor (int i = 0; i < ctor.getParameterCount(); ++i) {\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\nDeferredParameter key = loadObjectInstance(entry.getKey(), existing,\nObject.class, relaxedValidation);\nDeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\nrelaxedValidation);\ndef.put(key, val);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\nmethod.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\ncontext.loadDeferred(e.getValue()));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\nthrow new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n+ \" as setter and getters were different types\");\n}\n}\nDeferredParameter val = loadObjectInstance(propertyValue, existing,\ni.getPropertyType(), relaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nClass finalPropertyType = propertyType;\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeVirtualMethod(\nofMethod(param.getClass(), i.getWriteMethod().getName(),\ni.getWriteMethod().getReturnType(),\nfinalPropertyType),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nmethod.writeInstanceField(\nFieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\n\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\n\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\n\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\n\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\n\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\nDeferredParameter key = loadObjectInstance(entry.getKey(), existing,\nObject.class, relaxedValidation);\nDeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\nrelaxedValidation);\ndef.put(key, val);\n\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\n\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\n\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\n\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\n\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\n\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\n\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\n\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}","code_context_20":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\nnonDefaultConstructorHandles = new DeferredParameter[params.size()];\nfor (int i = 0; i < params.size(); i++) {\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\nnonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\nfor (int i = 0; i < ctor.getParameterCount(); ++i) {\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\nDeferredParameter key = loadObjectInstance(entry.getKey(), existing,\nObject.class, relaxedValidation);\nDeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\nrelaxedValidation);\ndef.put(key, val);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\nmethod.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\ncontext.loadDeferred(e.getValue()));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\nthrow new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n+ \" as setter and getters were different types\");\n}\n}\nDeferredParameter val = loadObjectInstance(propertyValue, existing,\ni.getPropertyType(), relaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nClass finalPropertyType = propertyType;\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeVirtualMethod(\nofMethod(param.getClass(), i.getWriteMethod().getName(),\ni.getWriteMethod().getReturnType(),\nfinalPropertyType),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n} else {\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nmethod.writeInstanceField(\nFieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\n\nprivate DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\nClass<?> expectedType, boolean relaxedValidation) {\n\/\/a list of steps that are performed on the object after it has been created\n\/\/we need to create all these first, to ensure the required objects have already\n\/\/been deserialized\nList<SerialzationStep> setupSteps = new ArrayList<>();\nList<SerialzationStep> ctorSetupSteps = new ArrayList<>();\nboolean relaxedOk = false;\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\n\nif (param instanceof Collection) {\n\/\/if this is a collection we want to serialize every element\nfor (Object i : (Collection) param) {\nDeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n\/\/each step can happen in a new method, so it is safe to do this\nmethod.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\n\/\/handle the value serialization\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\nif (param instanceof Map) {\n\/\/map works the same as collection\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\nfor (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\nDeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\nDeferredParameter val = i.getValue() != null\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\nnonDefaultConstructorHandles = new DeferredParameter[params.size()];\nfor (int i = 0; i < params.size(); i++) {\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\n\n? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n: loadObjectInstance(null, existing, Object.class, relaxedValidation);\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nkey.prepare(context);\nval.prepare(context);\n}\n});\n}\nrelaxedOk = true;\n}\n\/\/check how the object is constructed\nNonDefaultConstructorHolder nonDefaultConstructorHolder = null;\nDeferredParameter[] nonDefaultConstructorHandles = null;\n\/\/used to resolve the parameter position for @RecordableConstructor\nMap<String, Integer> constructorParamNameMap = new HashMap<>();\nif (nonDefaultConstructors.containsKey(param.getClass())) {\nnonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\nList<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\nif (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\nthrow new RuntimeException(\"Unable to serialize \" + param\n+ \" as the wrong number of parameters were generated for \"\n+ nonDefaultConstructorHolder.constructor);\n}\nint count = 0;\nnonDefaultConstructorHandles = new DeferredParameter[params.size()];\nfor (int i = 0; i < params.size(); i++) {\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\n\nObject obj = params.get(i);\nnonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\nnonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n}\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\nnonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\nfor (int i = 0; i < ctor.getParameterCount(); ++i) {\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\n\n} else {\nfor (Constructor<?> ctor : param.getClass().getConstructors()) {\nif (ctor.isAnnotationPresent(RecordableConstructor.class)) {\nnonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\nnonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\nfor (int i = 0; i < ctor.getParameterCount(); ++i) {\nString name = ctor.getParameters()[i].getName();\nconstructorParamNameMap.put(name, i);\n}\nbreak;\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n\n}\n}\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\n}\nSet<String> handledProperties = new HashSet<>();\nProperty[] desc = PropertyUtils.getPropertyDescriptors(param);\nfor (Property i : desc) {\n\/\/ check if the getter is ignored\nif ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\ncontinue;\n}\n\/\/ check if the matching field is ignored\ntry {\nif (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\n} catch (NoSuchFieldException ignored) {\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n\n}\nInteger ctorParamIndex = constructorParamNameMap.remove(i.name);\nif (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\ntry {\n\/\/read only prop, we may still be able to do stuff with it if it is a collection\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\nif (Collection.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a collection with only a read method\n\/\/we assume we can just add to the connection\nhandledProperties.add(i.getName());\nCollection propertyValue = (Collection) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nList<DeferredParameter> params = new ArrayList<>();\nfor (Object c : propertyValue) {\nDeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\nparams.add(toAdd);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\n\nDeferredArrayStoreParameter out) {\n\/\/get the collection\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (DeferredParameter i : params) {\n\/\/add the parameter\n\/\/TODO: this is not guareded against large collections, probably not an issue in practice\nmethod.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (DeferredParameter i : params) {\ni.prepare(context);\n}\n}\n});\n}\n} else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n\/\/special case, a map with only a read method\n\/\/we assume we can just add to the map\n\/\/similar to how collection works above\nhandledProperties.add(i.getName());\nMap<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\nif (propertyValue != null && !propertyValue.isEmpty()) {\nMap<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\nfor (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\nDeferredParameter key = loadObjectInstance(entry.getKey(), existing,\nObject.class, relaxedValidation);\nDeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\nrelaxedValidation);\ndef.put(key, val);\n}\nsetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\nmethod.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\n\nDeferredArrayStoreParameter out) {\nResultHandle prop = method.invokeVirtualMethod(\nMethodDescriptor.ofMethod(i.getReadMethod()),\ncontext.loadDeferred(out));\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\nmethod.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\ncontext.loadDeferred(e.getValue()));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n\ncontext.loadDeferred(e.getValue()));\n}\n}\n@Override\npublic void prepare(MethodContext context) {\nfor (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\ne.getKey().prepare(context);\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\ne.getValue().prepare(context);\n}\n}\n});\n}\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\n\n} else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n&& nonDefaultConstructorHolder == null) {\n\/\/check if there is actually a field with the name\ntry {\ni.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\nthrow new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n+ \"' as the property is read only\");\n} catch (NoSuchFieldException e) {\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\nthrow new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n\n\/\/if there is no underlying field then we ignore the property\n}\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n} else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n\/\/normal javabean property\ntry {\nhandledProperties.add(i.getName());\nObject propertyValue = i.read(param);\nif (propertyValue == null && ctorParamIndex == null) {\n\/\/we just assume properties are null by default\n\/\/TODO: is this a valid assumption? Should we check this by creating an instance?\ncontinue;\n}\nClass propertyType = i.getPropertyType();\nif (ctorParamIndex == null\n&& i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\nif (relaxedValidation) {\n\/\/this is a weird situation where the reader and writer are different types\n\/\/we iterate and try and find a valid setter method for the type we have\n\/\/OpenAPI does some weird stuff like this\nfor (Method m : param.getClass().getMethods()) {\nif (m.getName().equals(i.getWriteMethod().getName())) {\nif (m.getParameterTypes().length > 0\n&& m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\npropertyType = m.getParameterTypes()[0];\nbreak;\n}\n}\n}\n} else {\nthrow new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n+ \" as setter and getters were different types\");\n}\n}\nDeferredParameter val = loadObjectInstance(propertyValue, existing,\ni.getPropertyType(), relaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\n\n@Override\npublic void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\nmethod.invokeVirtualMethod(\nofMethod(param.getClass(), i.getWriteMethod().getName(),\ni.getWriteMethod().getReturnType(),\nfinalPropertyType),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n}\n@Override\n\nmethod.invokeVirtualMethod(\nofMethod(param.getClass(), i.getWriteMethod().getName(),\ni.getWriteMethod().getReturnType(),\nfinalPropertyType),\ncontext.loadDeferred(out),\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n\/\/now handle accessible fields\nfor (Field field : param.getClass().getFields()) {\n\/\/ check if the field is ignored\nif (field.getAnnotation(IgnoreProperty.class) != null) {\ncontinue;\n}\nif (!handledProperties.contains(field.getName())) {\nInteger ctorParamIndex = constructorParamNameMap.remove(field.getName());\nif ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n!Modifier.isStatic(field.getModifiers())) {\ntry {\nDeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\nrelaxedValidation);\nif (ctorParamIndex != null) {\nnonDefaultConstructorHandles[ctorParamIndex] = val;\nctorSetupSteps.add(new SerialzationStep() {\n@Override\npublic void handle(MethodContext context, MethodCreator method,\nDeferredArrayStoreParameter out) {\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n\ncontext.loadDeferred(val));\n}\n@Override\npublic void prepare(MethodContext context) {\nval.prepare(context);\n}\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\n\n});\n}\n} catch (Exception e) {\nthrow new RuntimeException(e);\n}\n}\n}\n}\nif (!constructorParamNameMap.isEmpty()) {\nthrow new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n+ \" could not read field values \" + constructorParamNameMap.keySet());\n}\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n\nNonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\nDeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n\/\/create a deferred value to represet the object itself. This allows the creation to be split\n\/\/over multiple methods, which is important if this is a large object\nDeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\nResultHandle out;\n\/\/do the creation\nif (finalNonDefaultConstructorHolder != null) {\nout = method.newInstance(\nofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\nfinalNonDefaultConstructorHolder.constructor.getParameterTypes()),\nArrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n.toArray(ResultHandle[]::new));\n} else {\ntry {\nparam.getClass().getDeclaredConstructor();\nout = method.newInstance(ofConstructor(param.getClass()));\n} catch (NoSuchMethodException e) {\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\n\n\/\/fallback for collection types, such as unmodifiableMap\nif (SortedMap.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeMap.class));\n} else if (Map.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n\nout = method.newInstance(ofConstructor(LinkedHashMap.class));\n} else if (List.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(ArrayList.class));\n} else if (SortedSet.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(TreeSet.class));\n} else if (Set.class.isAssignableFrom(expectedType)) {\nout = method.newInstance(ofConstructor(LinkedHashSet.class));\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\n\n} else {\nthrow new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n+ \" to bytecode as it has no default constructor\");\n}\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}\n\n}\n}\nreturn out;\n}\n};\n\/\/now return the actual deferred parameter that represents the result of construction\nreturn new DeferredArrayStoreParameter() {\n@Override\nvoid doPrepare(MethodContext context) {\n\/\/this is where the object construction happens\n\/\/first create the actial object\nfor (SerialzationStep i : ctorSetupSteps) {\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}\n\ni.prepare(context);\n}\nobjectValue.prepare(context);\nfor (SerialzationStep i : setupSteps) {\n\/\/then prepare the steps (i.e. creating the values to be placed into this object)\ni.prepare(context);\n}\nfor (SerialzationStep i : setupSteps) {\n\/\/now actually run the steps (i.e. actually stick the values into the object)\ncontext.writeInstruction(new InstructionGroup() {\n@Override\npublic void write(MethodContext context, MethodCreator method, ResultHandle array) {\ni.handle(context, method, objectValue);\n}\n});\n}\nsuper.doPrepare(context);\n}\n@Override\nResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n\/\/just return the already created object\nreturn context.loadDeferred(objectValue);\n}\n};\n}","label":[1,1,0,0]}
{"id":34583,"original_code":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n        \/\/ prompt may be null\n        \/\/ mask may be null\n        \/\/ buffer may be null\n        \/*\n         * This is the accumulator for VI-mode repeat count. That is, while in\n         * move mode, if you type 30x it will delete 30 characters. This is\n         * where the \"30\" is accumulated until the command is struck.\n         *\/\n        int repeatCount = 0;\n        \/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n        this.mask = mask != null ? mask : this.echoCharacter;\n        if (prompt != null) {\n            setPrompt(prompt);\n        }\n        else {\n            prompt = getPrompt();\n        }\n        try {\n            if (buffer != null) {\n                buf.write(buffer);\n            }\n            if (!terminal.isSupported()) {\n                beforeReadLine(prompt, mask);\n            }\n            if (buffer != null && buffer.length() > 0\n                    || prompt != null && prompt.length() > 0) {\n                drawLine();\n                out.flush();\n            }\n            \/\/ if the terminal is unsupported, just use plain-java reading\n            if (!terminal.isSupported()) {\n                return readLineSimple();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableInterruptCharacter();\n            }\n            if (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableLitteralNextCharacter();\n            }\n            String originalPrompt = this.prompt;\n            state = State.NORMAL;\n            boolean success = true;\n            pushBackChar.clear();\n            while (true) {\n                Object o = readBinding(getKeys());\n                if (o == null) {\n                    return null;\n                }\n                int c = 0;\n                if (opBuffer.length() > 0) {\n                    c = opBuffer.codePointBefore(opBuffer.length());\n                }\n                Log.trace(\"Binding: \", o);\n                \/\/ Handle macros\n                if (o instanceof String) {\n                    String macro = (String) o;\n                    for (int i = 0; i < macro.length(); i++) {\n                        pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                    }\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                \/\/ Handle custom callbacks\n                if (o instanceof ActionListener) {\n                    ((ActionListener) o).actionPerformed(null);\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                CursorBuffer oldBuf = new CursorBuffer();\n                oldBuf.buffer.append(buf.buffer);\n                oldBuf.cursor = buf.cursor;\n                \/\/ Search mode.\n                \/\/\n                \/\/ Note that we have to do this first, because if there is a command\n                \/\/ not linked to a search command, we leave the search mode and fall\n                \/\/ through to the normal state.\n                if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                    int cursorDest = -1;\n                    \/\/ TODO: check the isearch-terminators variable terminating the search\n                    switch ( ((Operation) o )) {\n                        case ABORT:\n                            state = State.NORMAL;\n                            buf.clear();\n                            buf.write(originalBuffer.buffer);\n                            buf.cursor = originalBuffer.cursor;\n                            break;\n                        case REVERSE_SEARCH_HISTORY:\n                            state = State.SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > 0) {\n                                searchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case FORWARD_SEARCH_HISTORY:\n                            state = State.FORWARD_SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > -1 && searchIndex < history.size() - 1) {\n                                searchIndex = searchForwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case BACKWARD_DELETE_CHAR:\n                            if (searchTerm.length() > 0) {\n                                searchTerm.deleteCharAt(searchTerm.length() - 1);\n                                if (state == State.SEARCH) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                } else {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                }\n                            }\n                            break;\n                        case SELF_INSERT:\n                            searchTerm.appendCodePoint(c);\n                            if (state == State.SEARCH) {\n                                searchIndex = searchBackwards(searchTerm.toString());\n                            } else {\n                                searchIndex = searchForwards(searchTerm.toString());\n                            }\n                            break;\n                        default:\n                            \/\/ Set buffer and cursor position to the found string.\n                            if (searchIndex != -1) {\n                                history.moveTo(searchIndex);\n                                \/\/ set cursor position to the found string\n                                cursorDest = history.current().toString().indexOf(searchTerm.toString());\n                            }\n                            if (o != Operation.ACCEPT_LINE) {\n                                o = null;\n                            }\n                            state = State.NORMAL;\n                            break;\n                    }\n                    \/\/ if we're still in search mode, print the search status\n                    if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                        if (searchTerm.length() == 0) {\n                            if (state == State.SEARCH) {\n                                printSearchStatus(\"\", \"\");\n                            } else {\n                                printForwardSearchStatus(\"\", \"\");\n                            }\n                            searchIndex = -1;\n                        } else {\n                            if (searchIndex == -1) {\n                                beep();\n                                printSearchStatus(searchTerm.toString(), \"\");\n                            } else if (state == State.SEARCH) {\n                                printSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            } else {\n                                printForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            }\n                        }\n                    }\n                    \/\/ otherwise, restore the line\n                    else {\n                        restoreLine(originalPrompt, cursorDest);\n                    }\n                }\n                if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                    \/*\n                     * If this is still false at the end of the switch, then\n                     * we reset our repeatCount to 0.\n                     *\/\n                    boolean isArgDigit = false;\n                    \/*\n                     * Every command that can be repeated a specified number\n                     * of times, needs to know how many times to repeat, so\n                     * we figure that out here.\n                     *\/\n                    int count = (repeatCount == 0) ? 1 : repeatCount;\n                    \/*\n                     * Default success to true. You only need to explicitly\n                     * set it if something goes wrong.\n                     *\/\n                    success = true;\n                    if (o instanceof Operation) {\n                        Operation op = (Operation)o;\n                        \/*\n                         * Current location of the cursor (prior to the operation).\n                         * These are used by vi *-to operation (e.g. delete-to)\n                         * so we know where we came from.\n                         *\/\n                        int     cursorStart = buf.cursor;\n                        State   origState   = state;\n                        \/*\n                         * If we are on a \"vi\" movement based operation, then we\n                         * need to restrict the sets of inputs pretty heavily.\n                         *\/\n                        if (state == State.VI_CHANGE_TO\n                            || state == State.VI_YANK_TO\n                            || state == State.VI_DELETE_TO) {\n                            op = viDeleteChangeYankToRemap(op);\n                        }\n                        switch ( op ) {\n                            case COMPLETE: \/\/ tab\n                                \/\/ There is an annoyance with tab completion in that\n                                \/\/ sometimes the user is actually pasting input in that\n                                \/\/ has physical tabs in it.  This attempts to look at how\n                                \/\/ quickly a character follows the tab, if the character\n                                \/\/ follows *immediately*, we assume it is a tab literal.\n                                boolean isTabLiteral = false;\n                                if (copyPasteDetection\n                                    && c == 9\n                                    && (!pushBackChar.isEmpty()\n                                        || (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\n                                    isTabLiteral = true;\n                                }\n                                if (! isTabLiteral) {\n                                    success = complete();\n                                }\n                                else {\n                                    putString(opBuffer);\n                                }\n                                break;\n                            case POSSIBLE_COMPLETIONS:\n                                printCompletionCandidates();\n                                break;\n                            case BEGINNING_OF_LINE:\n                                success = setCursorPosition(0);\n                                break;\n                            case YANK:\n                                success = yank();\n                                break;\n                            case YANK_POP:\n                                success = yankPop();\n                                break;\n                            case KILL_LINE: \/\/ CTRL-K\n                                success = killLine();\n                                break;\n                            case KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                break;\n                            case CLEAR_SCREEN: \/\/ CTRL-L\n                                success = clearScreen();\n                                redrawLine();\n                                break;\n                            case OVERWRITE_MODE:\n                                buf.setOverTyping(!buf.isOverTyping());\n                                break;\n                            case SELF_INSERT:\n                                putString(opBuffer);\n                                break;\n                            case ACCEPT_LINE:\n                                return accept();\n                            case ABORT:\n                                if (searchTerm == null) {\n                                    abort();\n                                }\n                                break;\n                            case INTERRUPT:\n                                if (handleUserInterrupt) {\n                                    println();\n                                    flush();\n                                    String partialLine = buf.buffer.toString();\n                                    buf.clear();\n                                    history.moveToEnd();\n                                    throw new UserInterruptException(partialLine);\n                                }\n                                break;\n                            \/*\n                             * VI_MOVE_ACCEPT_LINE is the result of an ENTER\n                             * while in move mode. This is the same as a normal\n                             * ACCEPT_LINE, except that we need to enter\n                             * insert mode as well.\n                             *\/\n                            case VI_MOVE_ACCEPT_LINE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                return accept();\n                            case BACKWARD_WORD:\n                                success = previousWord();\n                                break;\n                            case FORWARD_WORD:\n                                success = nextWord();\n                                break;\n                            case PREVIOUS_HISTORY:\n                                success = moveHistory(false);\n                                break;\n                            \/*\n                             * According to bash\/readline move through history\n                             * in \"vi\" mode will move the cursor to the\n                             * start of the line. If there is no previous\n                             * history, then the cursor doesn't move.\n                             *\/\n                            case VI_PREVIOUS_HISTORY:\n                                success = moveHistory(false, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case NEXT_HISTORY:\n                                success = moveHistory(true);\n                                break;\n                            \/*\n                             * According to bash\/readline move through history\n                             * in \"vi\" mode will move the cursor to the\n                             * start of the line. If there is no next history,\n                             * then the cursor doesn't move.\n                             *\/\n                            case VI_NEXT_HISTORY:\n                                success = moveHistory(true, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case BACKWARD_DELETE_CHAR: \/\/ backspace\n                                success = backspace();\n                                break;\n                            case EXIT_OR_DELETE_CHAR:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                success = deleteCurrentCharacter();\n                                break;\n                            case DELETE_CHAR: \/\/ delete\n                                success = deleteCurrentCharacter();\n                                break;\n                            case BACKWARD_CHAR:\n                                success = moveCursor(-(count)) != 0;\n                                break;\n                            case FORWARD_CHAR:\n                                success = moveCursor(count) != 0;\n                                break;\n                            case UNIX_LINE_DISCARD:\n                                success = resetLine();\n                                break;\n                            case UNIX_WORD_RUBOUT:\n                                success = unixWordRubout(count);\n                                break;\n                            case BACKWARD_KILL_WORD:\n                                success = deletePreviousWord();\n                                break;\n                            case KILL_WORD:\n                                success = deleteNextWord();\n                                break;\n                            case BEGINNING_OF_HISTORY:\n                                success = history.moveToFirst();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case END_OF_HISTORY:\n                                success = history.moveToLast();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case HISTORY_SEARCH_BACKWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                searchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\n                                if (searchIndex == -1) {\n                                    beep();\n                                } else {\n                                    \/\/ Maintain cursor position while searching.\n                                    success = history.moveTo(searchIndex);\n                                    if (success) {\n                                        setBufferKeepPos(history.current());\n                                    }\n                                }\n                                break;\n                            case HISTORY_SEARCH_FORWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                int index = history.index() + 1;\n                                if (index == history.size()) {\n                                    history.moveToEnd();\n                                    setBufferKeepPos(searchTerm.toString());\n                                } else if (index < history.size()) {\n                                    searchIndex = searchForwards(searchTerm.toString(), index, true);\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    } else {\n                                        \/\/ Maintain cursor position while searching.\n                                        success = history.moveTo(searchIndex);\n                                        if (success) {\n                                            setBufferKeepPos(history.current());\n                                        }\n                                    }\n                                }\n                                break;\n                            case REVERSE_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case FORWARD_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.FORWARD_SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printForwardSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printForwardSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case CAPITALIZE_WORD:\n                                success = capitalizeWord();\n                                break;\n                            case UPCASE_WORD:\n                                success = upCaseWord();\n                                break;\n                            case DOWNCASE_WORD:\n                                success = downCaseWord();\n                                break;\n                            case END_OF_LINE:\n                                success = moveToEnd();\n                                break;\n                            case TAB_INSERT:\n                                putString( \"\\t\" );\n                                break;\n                            case RE_READ_INIT_FILE:\n                                consoleKeys.loadKeys(appName, inputrcUrl);\n                                break;\n                            case START_KBD_MACRO:\n                                recording = true;\n                                break;\n                            case END_KBD_MACRO:\n                                recording = false;\n                                macro = macro.substring(0, macro.length() - opBuffer.length());\n                                break;\n                            case CALL_LAST_KBD_MACRO:\n                                for (int i = 0; i < macro.length(); i++) {\n                                    pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                                }\n                                opBuffer.setLength(0);\n                                break;\n                            case VI_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_MOVEMENT_MODE:\n                                \/*\n                                 * If we are re-entering move mode from an\n                                 * aborted yank-to, delete-to, change-to then\n                                 * don't move the cursor back. The cursor is\n                                 * only move on an expclit entry to movement\n                                 * mode.\n                                 *\/\n                                if (state == State.NORMAL) {\n                                    moveCursor(-1);\n                                }\n                                consoleKeys.setKeyMap(KeyMap.VI_MOVE);\n                                break;\n                            case VI_INSERTION_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_MODE:\n                                moveCursor(1);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_EOL:\n                                success = moveToEnd();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            \/*\n                             * Handler for CTRL-D. Attempts to follow readline\n                             * behavior. If the line is empty, then it is an EOF\n                             * otherwise it is as if the user hit enter.\n                             *\/\n                            case VI_EOF_MAYBE:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                return accept();\n                            case TRANSPOSE_CHARS:\n                                success = transposeChars(count);\n                                break;\n                            case INSERT_COMMENT:\n                                return insertComment (false);\n                            case INSERT_CLOSE_CURLY:\n                                insertClose(\"}\");\n                                break;\n                            case INSERT_CLOSE_PAREN:\n                                insertClose(\")\");\n                                break;\n                            case INSERT_CLOSE_SQUARE:\n                                insertClose(\"]\");\n                                break;\n                            case VI_INSERT_COMMENT:\n                                return insertComment (true);\n                            case VI_MATCH:\n                                success = viMatch ();\n                                break;\n                            case VI_SEARCH:\n                                int lastChar = viSearch(opBuffer.charAt(0));\n                                if (lastChar != -1) {\n                                    pushBackChar.push((char)lastChar);\n                                }\n                                break;\n                            case VI_ARG_DIGIT:\n                                repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                isArgDigit = true;\n                                break;\n                            case VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\n                                if (repeatCount > 0) {\n                                    repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                    isArgDigit = true;\n                                }\n                                else {\n                                    success = setCursorPosition(0);\n                                }\n                                break;\n                            case VI_FIRST_PRINT:\n                                success = setCursorPosition(0) && viNextWord(1);\n                                break;\n                            case VI_PREV_WORD:\n                                success = viPreviousWord(count);\n                                break;\n                            case VI_NEXT_WORD:\n                                success = viNextWord(count);\n                                break;\n                            case VI_END_WORD:\n                                success = viEndWord(count);\n                                break;\n                            case VI_INSERT_BEG:\n                                success = setCursorPosition(0);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_RUBOUT:\n                                success = viRubout(count);\n                                break;\n                            case VI_DELETE:\n                                success = viDelete(count);\n                                break;\n                            case VI_DELETE_TO:\n                                \/*\n                                 * This is a weird special case. In vi\n                                 * \"dd\" deletes the current line. So if we\n                                 * get a delete-to, followed by a delete-to,\n                                 * we delete the line.\n                                 *\/\n                                if (state == State.VI_DELETE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_DELETE_TO;\n                                }\n                                break;\n                            case VI_YANK_TO:\n                                \/\/ Similar to delete-to, a \"yy\" yanks the whole line.\n                                if (state == State.VI_YANK_TO) {\n                                    yankBuffer = buf.buffer.toString();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_YANK_TO;\n                                }\n                                break;\n                            case VI_CHANGE_TO:\n                                if (state == State.VI_CHANGE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                    consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                }\n                                else {\n                                    state = State.VI_CHANGE_TO;\n                                }\n                                break;\n                            case VI_KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_PUT:\n                                success = viPut(count);\n                                break;\n                            case VI_CHAR_SEARCH: {\n                                 \/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\n                                int searchChar = (c != ';' && c != ',')\n                                    ? (pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop ())\n                                    : 0;\n                                    success = viCharSearch(count, c, searchChar);\n                                }\n                                break;\n                            case VI_CHANGE_CASE:\n                                success = viChangeCase(count);\n                                break;\n                            case VI_CHANGE_CHAR:\n                                success = viChangeChar(count,\n                                    pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop());\n                                break;\n                            case VI_DELETE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), false);\n                                break;\n                            case VI_CHANGE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case EMACS_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.EMACS);\n                                break;\n                            case QUIT:\n                                getCursorBuffer().clear();\n                                return accept();\n                            case QUOTED_INSERT:\n                                quotedInsert = true;\n                                break;\n                            case PASTE_FROM_CLIPBOARD:\n                                paste();\n                                break;\n                            default:\n                                break;\n                        }\n                        \/*\n                         * If we were in a yank-to, delete-to, move-to\n                         * when this operation started, then fall back to\n                         *\/\n                        if (origState != State.NORMAL) {\n                            if (origState == State.VI_DELETE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, false);\n                            }\n                            else if (origState == State.VI_CHANGE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                            }\n                            else if (origState == State.VI_YANK_TO) {\n                                success = viYankTo(cursorStart, buf.cursor);\n                            }\n                            state = State.NORMAL;\n                        }\n                        \/*\n                         * Another subtly. The check for the NORMAL state is\n                         * to ensure that we do not clear out the repeat\n                         * count when in delete-to, yank-to, or move-to modes.\n                         *\/\n                        if (state == State.NORMAL && !isArgDigit) {\n                            \/*\n                             * If the operation performed wasn't a vi argument\n                             * digit, then clear out the current repeatCount;\n                             *\/\n                            repeatCount = 0;\n                        }\n                        if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                            originalBuffer = null;\n                            previousSearchTerm = \"\";\n                            searchTerm = null;\n                            searchIndex = -1;\n                        }\n                    }\n                }\n                if (!success) {\n                    beep();\n                }\n                opBuffer.setLength(0);\n                flush();\n            }\n        }\n        finally {\n            if (!terminal.isSupported()) {\n                afterReadLine();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).enableInterruptCharacter();\n            }\n        }\n    }","code":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n       \n       \n       \n       \n        int repeatCount = 0;\n       \n        this.mask = mask != null ? mask : this.echoCharacter;\n        if (prompt != null) {\n            setPrompt(prompt);\n        }\n        else {\n            prompt = getPrompt();\n        }\n        try {\n            if (buffer != null) {\n                buf.write(buffer);\n            }\n            if (!terminal.isSupported()) {\n                beforeReadLine(prompt, mask);\n            }\n            if (buffer != null && buffer.length() > 0\n                    || prompt != null && prompt.length() > 0) {\n                drawLine();\n                out.flush();\n            }\n           \n            if (!terminal.isSupported()) {\n                return readLineSimple();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableInterruptCharacter();\n            }\n            if (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableLitteralNextCharacter();\n            }\n            String originalPrompt = this.prompt;\n            state = State.NORMAL;\n            boolean success = true;\n            pushBackChar.clear();\n            while (true) {\n                Object o = readBinding(getKeys());\n                if (o == null) {\n                    return null;\n                }\n                int c = 0;\n                if (opBuffer.length() > 0) {\n                    c = opBuffer.codePointBefore(opBuffer.length());\n                }\n                Log.trace(\"Binding: \", o);\n               \n                if (o instanceof String) {\n                    String macro = (String) o;\n                    for (int i = 0; i < macro.length(); i++) {\n                        pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                    }\n                    opBuffer.setLength(0);\n                    continue;\n                }\n               \n                if (o instanceof ActionListener) {\n                    ((ActionListener) o).actionPerformed(null);\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                CursorBuffer oldBuf = new CursorBuffer();\n                oldBuf.buffer.append(buf.buffer);\n                oldBuf.cursor = buf.cursor;\n               \n               \n               \n               \n               \n                if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                    int cursorDest = -1;\n                   \n                    switch ( ((Operation) o )) {\n                        case ABORT:\n                            state = State.NORMAL;\n                            buf.clear();\n                            buf.write(originalBuffer.buffer);\n                            buf.cursor = originalBuffer.cursor;\n                            break;\n                        case REVERSE_SEARCH_HISTORY:\n                            state = State.SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > 0) {\n                                searchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case FORWARD_SEARCH_HISTORY:\n                            state = State.FORWARD_SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > -1 && searchIndex < history.size() - 1) {\n                                searchIndex = searchForwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case BACKWARD_DELETE_CHAR:\n                            if (searchTerm.length() > 0) {\n                                searchTerm.deleteCharAt(searchTerm.length() - 1);\n                                if (state == State.SEARCH) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                } else {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                }\n                            }\n                            break;\n                        case SELF_INSERT:\n                            searchTerm.appendCodePoint(c);\n                            if (state == State.SEARCH) {\n                                searchIndex = searchBackwards(searchTerm.toString());\n                            } else {\n                                searchIndex = searchForwards(searchTerm.toString());\n                            }\n                            break;\n                        default:\n                           \n                            if (searchIndex != -1) {\n                                history.moveTo(searchIndex);\n                               \n                                cursorDest = history.current().toString().indexOf(searchTerm.toString());\n                            }\n                            if (o != Operation.ACCEPT_LINE) {\n                                o = null;\n                            }\n                            state = State.NORMAL;\n                            break;\n                    }\n                   \n                    if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                        if (searchTerm.length() == 0) {\n                            if (state == State.SEARCH) {\n                                printSearchStatus(\"\", \"\");\n                            } else {\n                                printForwardSearchStatus(\"\", \"\");\n                            }\n                            searchIndex = -1;\n                        } else {\n                            if (searchIndex == -1) {\n                                beep();\n                                printSearchStatus(searchTerm.toString(), \"\");\n                            } else if (state == State.SEARCH) {\n                                printSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            } else {\n                                printForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            }\n                        }\n                    }\n                   \n                    else {\n                        restoreLine(originalPrompt, cursorDest);\n                    }\n                }\n                if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                   \n                    boolean isArgDigit = false;\n                   \n                    int count = (repeatCount == 0) ? 1 : repeatCount;\n                   \n                    success = true;\n                    if (o instanceof Operation) {\n                        Operation op = (Operation)o;\n                       \n                        int     cursorStart = buf.cursor;\n                        State   origState   = state;\n                       \n                        if (state == State.VI_CHANGE_TO\n                            || state == State.VI_YANK_TO\n                            || state == State.VI_DELETE_TO) {\n                            op = viDeleteChangeYankToRemap(op);\n                        }\n                        switch ( op ) {\n                            case COMPLETE:\n                               \n                               \n                               \n                               \n                               \n                                boolean isTabLiteral = false;\n                                if (copyPasteDetection\n                                    && c == 9\n                                    && (!pushBackChar.isEmpty()\n                                        || (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\n                                    isTabLiteral = true;\n                                }\n                                if (! isTabLiteral) {\n                                    success = complete();\n                                }\n                                else {\n                                    putString(opBuffer);\n                                }\n                                break;\n                            case POSSIBLE_COMPLETIONS:\n                                printCompletionCandidates();\n                                break;\n                            case BEGINNING_OF_LINE:\n                                success = setCursorPosition(0);\n                                break;\n                            case YANK:\n                                success = yank();\n                                break;\n                            case YANK_POP:\n                                success = yankPop();\n                                break;\n                            case KILL_LINE:\n                                success = killLine();\n                                break;\n                            case KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                break;\n                            case CLEAR_SCREEN:\n                                success = clearScreen();\n                                redrawLine();\n                                break;\n                            case OVERWRITE_MODE:\n                                buf.setOverTyping(!buf.isOverTyping());\n                                break;\n                            case SELF_INSERT:\n                                putString(opBuffer);\n                                break;\n                            case ACCEPT_LINE:\n                                return accept();\n                            case ABORT:\n                                if (searchTerm == null) {\n                                    abort();\n                                }\n                                break;\n                            case INTERRUPT:\n                                if (handleUserInterrupt) {\n                                    println();\n                                    flush();\n                                    String partialLine = buf.buffer.toString();\n                                    buf.clear();\n                                    history.moveToEnd();\n                                    throw new UserInterruptException(partialLine);\n                                }\n                                break;\n                           \n                            case VI_MOVE_ACCEPT_LINE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                return accept();\n                            case BACKWARD_WORD:\n                                success = previousWord();\n                                break;\n                            case FORWARD_WORD:\n                                success = nextWord();\n                                break;\n                            case PREVIOUS_HISTORY:\n                                success = moveHistory(false);\n                                break;\n                           \n                            case VI_PREVIOUS_HISTORY:\n                                success = moveHistory(false, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case NEXT_HISTORY:\n                                success = moveHistory(true);\n                                break;\n                           \n                            case VI_NEXT_HISTORY:\n                                success = moveHistory(true, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case BACKWARD_DELETE_CHAR:\n                                success = backspace();\n                                break;\n                            case EXIT_OR_DELETE_CHAR:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                success = deleteCurrentCharacter();\n                                break;\n                            case DELETE_CHAR:\n                                success = deleteCurrentCharacter();\n                                break;\n                            case BACKWARD_CHAR:\n                                success = moveCursor(-(count)) != 0;\n                                break;\n                            case FORWARD_CHAR:\n                                success = moveCursor(count) != 0;\n                                break;\n                            case UNIX_LINE_DISCARD:\n                                success = resetLine();\n                                break;\n                            case UNIX_WORD_RUBOUT:\n                                success = unixWordRubout(count);\n                                break;\n                            case BACKWARD_KILL_WORD:\n                                success = deletePreviousWord();\n                                break;\n                            case KILL_WORD:\n                                success = deleteNextWord();\n                                break;\n                            case BEGINNING_OF_HISTORY:\n                                success = history.moveToFirst();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case END_OF_HISTORY:\n                                success = history.moveToLast();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case HISTORY_SEARCH_BACKWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                searchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\n                                if (searchIndex == -1) {\n                                    beep();\n                                } else {\n                                   \n                                    success = history.moveTo(searchIndex);\n                                    if (success) {\n                                        setBufferKeepPos(history.current());\n                                    }\n                                }\n                                break;\n                            case HISTORY_SEARCH_FORWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                int index = history.index() + 1;\n                                if (index == history.size()) {\n                                    history.moveToEnd();\n                                    setBufferKeepPos(searchTerm.toString());\n                                } else if (index < history.size()) {\n                                    searchIndex = searchForwards(searchTerm.toString(), index, true);\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    } else {\n                                       \n                                        success = history.moveTo(searchIndex);\n                                        if (success) {\n                                            setBufferKeepPos(history.current());\n                                        }\n                                    }\n                                }\n                                break;\n                            case REVERSE_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case FORWARD_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.FORWARD_SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printForwardSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printForwardSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case CAPITALIZE_WORD:\n                                success = capitalizeWord();\n                                break;\n                            case UPCASE_WORD:\n                                success = upCaseWord();\n                                break;\n                            case DOWNCASE_WORD:\n                                success = downCaseWord();\n                                break;\n                            case END_OF_LINE:\n                                success = moveToEnd();\n                                break;\n                            case TAB_INSERT:\n                                putString( \"\\t\" );\n                                break;\n                            case RE_READ_INIT_FILE:\n                                consoleKeys.loadKeys(appName, inputrcUrl);\n                                break;\n                            case START_KBD_MACRO:\n                                recording = true;\n                                break;\n                            case END_KBD_MACRO:\n                                recording = false;\n                                macro = macro.substring(0, macro.length() - opBuffer.length());\n                                break;\n                            case CALL_LAST_KBD_MACRO:\n                                for (int i = 0; i < macro.length(); i++) {\n                                    pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                                }\n                                opBuffer.setLength(0);\n                                break;\n                            case VI_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_MOVEMENT_MODE:\n                               \n                                if (state == State.NORMAL) {\n                                    moveCursor(-1);\n                                }\n                                consoleKeys.setKeyMap(KeyMap.VI_MOVE);\n                                break;\n                            case VI_INSERTION_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_MODE:\n                                moveCursor(1);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_EOL:\n                                success = moveToEnd();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                           \n                            case VI_EOF_MAYBE:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                return accept();\n                            case TRANSPOSE_CHARS:\n                                success = transposeChars(count);\n                                break;\n                            case INSERT_COMMENT:\n                                return insertComment (false);\n                            case INSERT_CLOSE_CURLY:\n                                insertClose(\"}\");\n                                break;\n                            case INSERT_CLOSE_PAREN:\n                                insertClose(\")\");\n                                break;\n                            case INSERT_CLOSE_SQUARE:\n                                insertClose(\"]\");\n                                break;\n                            case VI_INSERT_COMMENT:\n                                return insertComment (true);\n                            case VI_MATCH:\n                                success = viMatch ();\n                                break;\n                            case VI_SEARCH:\n                                int lastChar = viSearch(opBuffer.charAt(0));\n                                if (lastChar != -1) {\n                                    pushBackChar.push((char)lastChar);\n                                }\n                                break;\n                            case VI_ARG_DIGIT:\n                                repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                isArgDigit = true;\n                                break;\n                            case VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\n                                if (repeatCount > 0) {\n                                    repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                    isArgDigit = true;\n                                }\n                                else {\n                                    success = setCursorPosition(0);\n                                }\n                                break;\n                            case VI_FIRST_PRINT:\n                                success = setCursorPosition(0) && viNextWord(1);\n                                break;\n                            case VI_PREV_WORD:\n                                success = viPreviousWord(count);\n                                break;\n                            case VI_NEXT_WORD:\n                                success = viNextWord(count);\n                                break;\n                            case VI_END_WORD:\n                                success = viEndWord(count);\n                                break;\n                            case VI_INSERT_BEG:\n                                success = setCursorPosition(0);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_RUBOUT:\n                                success = viRubout(count);\n                                break;\n                            case VI_DELETE:\n                                success = viDelete(count);\n                                break;\n                            case VI_DELETE_TO:\n                               \n                                if (state == State.VI_DELETE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_DELETE_TO;\n                                }\n                                break;\n                            case VI_YANK_TO:\n                               \n                                if (state == State.VI_YANK_TO) {\n                                    yankBuffer = buf.buffer.toString();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_YANK_TO;\n                                }\n                                break;\n                            case VI_CHANGE_TO:\n                                if (state == State.VI_CHANGE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                    consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                }\n                                else {\n                                    state = State.VI_CHANGE_TO;\n                                }\n                                break;\n                            case VI_KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_PUT:\n                                success = viPut(count);\n                                break;\n                            case VI_CHAR_SEARCH: {\n                                \n                                int searchChar = (c != ';' && c != ',')\n                                    ? (pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop ())\n                                    : 0;\n                                    success = viCharSearch(count, c, searchChar);\n                                }\n                                break;\n                            case VI_CHANGE_CASE:\n                                success = viChangeCase(count);\n                                break;\n                            case VI_CHANGE_CHAR:\n                                success = viChangeChar(count,\n                                    pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop());\n                                break;\n                            case VI_DELETE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), false);\n                                break;\n                            case VI_CHANGE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case EMACS_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.EMACS);\n                                break;\n                            case QUIT:\n                                getCursorBuffer().clear();\n                                return accept();\n                            case QUOTED_INSERT:\n                                quotedInsert = true;\n                                break;\n                            case PASTE_FROM_CLIPBOARD:\n                                paste();\n                                break;\n                            default:\n                                break;\n                        }\n                       \n                        if (origState != State.NORMAL) {\n                            if (origState == State.VI_DELETE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, false);\n                            }\n                            else if (origState == State.VI_CHANGE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                            }\n                            else if (origState == State.VI_YANK_TO) {\n                                success = viYankTo(cursorStart, buf.cursor);\n                            }\n                            state = State.NORMAL;\n                        }\n                       \n                        if (state == State.NORMAL && !isArgDigit) {\n                           \n                            repeatCount = 0;\n                        }\n                        if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                            originalBuffer = null;\n                            previousSearchTerm = \"\";\n                            searchTerm = null;\n                            searchIndex = -1;\n                        }\n                    }\n                }\n                if (!success) {\n                    beep();\n                }\n                opBuffer.setLength(0);\n                flush();\n            }\n        }\n        finally {\n            if (!terminal.isSupported()) {\n                afterReadLine();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).enableInterruptCharacter();\n            }\n        }\n    }","cleancode":"public string readline(string prompt, final character mask, string buffer) throws ioexception { int repeatcount = 0; this.mask = mask != null ? mask : this.echocharacter; if (prompt != null) { setprompt(prompt); } else { prompt = getprompt(); } try { if (buffer != null) { buf.write(buffer); } if (!terminal.issupported()) { beforereadline(prompt, mask); } if (buffer != null && buffer.length() > 0 || prompt != null && prompt.length() > 0) { drawline(); out.flush(); } if (!terminal.issupported()) { return readlinesimple(); } if (handleuserinterrupt && (terminal instanceof unixterminal)) { ((unixterminal) terminal).disableinterruptcharacter(); } if (handlelitteralnext && (terminal instanceof unixterminal)) { ((unixterminal) terminal).disablelitteralnextcharacter(); } string originalprompt = this.prompt; state = state.normal; boolean success = true; pushbackchar.clear(); while (true) { object o = readbinding(getkeys()); if (o == null) { return null; } int c = 0; if (opbuffer.length() > 0) { c = opbuffer.codepointbefore(opbuffer.length()); } log.trace(\"binding: \", o); if (o instanceof string) { string macro = (string) o; for (int i = 0; i < macro.length(); i++) { pushbackchar.push(macro.charat(macro.length() - 1 - i)); } opbuffer.setlength(0); continue; } if (o instanceof actionlistener) { ((actionlistener) o).actionperformed(null); opbuffer.setlength(0); continue; } cursorbuffer oldbuf = new cursorbuffer(); oldbuf.buffer.append(buf.buffer); oldbuf.cursor = buf.cursor; if (state == state.search || state == state.forward_search) { int cursordest = -1; switch ( ((operation) o )) { case abort: state = state.normal; buf.clear(); buf.write(originalbuffer.buffer); buf.cursor = originalbuffer.cursor; break; case reverse_search_history: state = state.search; if (searchterm.length() == 0) { searchterm.append(previoussearchterm); } if (searchindex > 0) { searchindex = searchbackwards(searchterm.tostring(), searchindex); } break; case forward_search_history: state = state.forward_search; if (searchterm.length() == 0) { searchterm.append(previoussearchterm); } if (searchindex > -1 && searchindex < history.size() - 1) { searchindex = searchforwards(searchterm.tostring(), searchindex); } break; case backward_delete_char: if (searchterm.length() > 0) { searchterm.deletecharat(searchterm.length() - 1); if (state == state.search) { searchindex = searchbackwards(searchterm.tostring()); } else { searchindex = searchforwards(searchterm.tostring()); } } break; case self_insert: searchterm.appendcodepoint(c); if (state == state.search) { searchindex = searchbackwards(searchterm.tostring()); } else { searchindex = searchforwards(searchterm.tostring()); } break; default: if (searchindex != -1) { history.moveto(searchindex); cursordest = history.current().tostring().indexof(searchterm.tostring()); } if (o != operation.accept_line) { o = null; } state = state.normal; break; } if (state == state.search || state == state.forward_search) { if (searchterm.length() == 0) { if (state == state.search) { printsearchstatus(\"\", \"\"); } else { printforwardsearchstatus(\"\", \"\"); } searchindex = -1; } else { if (searchindex == -1) { beep(); printsearchstatus(searchterm.tostring(), \"\"); } else if (state == state.search) { printsearchstatus(searchterm.tostring(), history.get(searchindex).tostring()); } else { printforwardsearchstatus(searchterm.tostring(), history.get(searchindex).tostring()); } } } else { restoreline(originalprompt, cursordest); } } if (state != state.search && state != state.forward_search) { boolean isargdigit = false; int count = (repeatcount == 0) ? 1 : repeatcount; success = true; if (o instanceof operation) { operation op = (operation)o; int cursorstart = buf.cursor; state origstate = state; if (state == state.vi_change_to || state == state.vi_yank_to || state == state.vi_delete_to) { op = videletechangeyanktoremap(op); } switch ( op ) { case complete: boolean istabliteral = false; if (copypastedetection && c == 9 && (!pushbackchar.isempty() || (in.isnonblockingenabled() && in.peek(escapetimeout) != -2))) { istabliteral = true; } if (! istabliteral) { success = complete(); } else { putstring(opbuffer); } break; case possible_completions: printcompletioncandidates(); break; case beginning_of_line: success = setcursorposition(0); break; case yank: success = yank(); break; case yank_pop: success = yankpop(); break; case kill_line: success = killline(); break; case kill_whole_line: success = setcursorposition(0) && killline(); break; case clear_screen: success = clearscreen(); redrawline(); break; case overwrite_mode: buf.setovertyping(!buf.isovertyping()); break; case self_insert: putstring(opbuffer); break; case accept_line: return accept(); case abort: if (searchterm == null) { abort(); } break; case interrupt: if (handleuserinterrupt) { println(); flush(); string partialline = buf.buffer.tostring(); buf.clear(); history.movetoend(); throw new userinterruptexception(partialline); } break; case vi_move_accept_line: consolekeys.setkeymap(keymap.vi_insert); return accept(); case backward_word: success = previousword(); break; case forward_word: success = nextword(); break; case previous_history: success = movehistory(false); break; case vi_previous_history: success = movehistory(false, count) && setcursorposition(0); break; case next_history: success = movehistory(true); break; case vi_next_history: success = movehistory(true, count) && setcursorposition(0); break; case backward_delete_char: success = backspace(); break; case exit_or_delete_char: if (buf.buffer.length() == 0) { return null; } success = deletecurrentcharacter(); break; case delete_char: success = deletecurrentcharacter(); break; case backward_char: success = movecursor(-(count)) != 0; break; case forward_char: success = movecursor(count) != 0; break; case unix_line_discard: success = resetline(); break; case unix_word_rubout: success = unixwordrubout(count); break; case backward_kill_word: success = deletepreviousword(); break; case kill_word: success = deletenextword(); break; case beginning_of_history: success = history.movetofirst(); if (success) { setbuffer(history.current()); } break; case end_of_history: success = history.movetolast(); if (success) { setbuffer(history.current()); } break; case history_search_backward: searchterm = new stringbuffer(buf.uptocursor()); searchindex = searchbackwards(searchterm.tostring(), history.index(), true); if (searchindex == -1) { beep(); } else { success = history.moveto(searchindex); if (success) { setbufferkeeppos(history.current()); } } break; case history_search_forward: searchterm = new stringbuffer(buf.uptocursor()); int index = history.index() + 1; if (index == history.size()) { history.movetoend(); setbufferkeeppos(searchterm.tostring()); } else if (index < history.size()) { searchindex = searchforwards(searchterm.tostring(), index, true); if (searchindex == -1) { beep(); } else { success = history.moveto(searchindex); if (success) { setbufferkeeppos(history.current()); } } } break; case reverse_search_history: originalbuffer = new cursorbuffer(); originalbuffer.write(buf.buffer); originalbuffer.cursor = buf.cursor; if (searchterm != null) { previoussearchterm = searchterm.tostring(); } searchterm = new stringbuffer(buf.buffer); state = state.search; if (searchterm.length() > 0) { searchindex = searchbackwards(searchterm.tostring()); if (searchindex == -1) { beep(); } printsearchstatus(searchterm.tostring(), searchindex > -1 ? history.get(searchindex).tostring() : \"\"); } else { searchindex = -1; printsearchstatus(\"\", \"\"); } break; case forward_search_history: originalbuffer = new cursorbuffer(); originalbuffer.write(buf.buffer); originalbuffer.cursor = buf.cursor; if (searchterm != null) { previoussearchterm = searchterm.tostring(); } searchterm = new stringbuffer(buf.buffer); state = state.forward_search; if (searchterm.length() > 0) { searchindex = searchforwards(searchterm.tostring()); if (searchindex == -1) { beep(); } printforwardsearchstatus(searchterm.tostring(), searchindex > -1 ? history.get(searchindex).tostring() : \"\"); } else { searchindex = -1; printforwardsearchstatus(\"\", \"\"); } break; case capitalize_word: success = capitalizeword(); break; case upcase_word: success = upcaseword(); break; case downcase_word: success = downcaseword(); break; case end_of_line: success = movetoend(); break; case tab_insert: putstring( \"\\t\" ); break; case re_read_init_file: consolekeys.loadkeys(appname, inputrcurl); break; case start_kbd_macro: recording = true; break; case end_kbd_macro: recording = false; macro = macro.substring(0, macro.length() - opbuffer.length()); break; case call_last_kbd_macro: for (int i = 0; i < macro.length(); i++) { pushbackchar.push(macro.charat(macro.length() - 1 - i)); } opbuffer.setlength(0); break; case vi_editing_mode: consolekeys.setkeymap(keymap.vi_insert); break; case vi_movement_mode: if (state == state.normal) { movecursor(-1); } consolekeys.setkeymap(keymap.vi_move); break; case vi_insertion_mode: consolekeys.setkeymap(keymap.vi_insert); break; case vi_append_mode: movecursor(1); consolekeys.setkeymap(keymap.vi_insert); break; case vi_append_eol: success = movetoend(); consolekeys.setkeymap(keymap.vi_insert); break; case vi_eof_maybe: if (buf.buffer.length() == 0) { return null; } return accept(); case transpose_chars: success = transposechars(count); break; case insert_comment: return insertcomment (false); case insert_close_curly: insertclose(\"}\"); break; case insert_close_paren: insertclose(\")\"); break; case insert_close_square: insertclose(\"]\"); break; case vi_insert_comment: return insertcomment (true); case vi_match: success = vimatch (); break; case vi_search: int lastchar = visearch(opbuffer.charat(0)); if (lastchar != -1) { pushbackchar.push((char)lastchar); } break; case vi_arg_digit: repeatcount = (repeatcount * 10) + opbuffer.charat(0) - '0'; isargdigit = true; break; case vi_beginning_of_line_or_arg_digit: if (repeatcount > 0) { repeatcount = (repeatcount * 10) + opbuffer.charat(0) - '0'; isargdigit = true; } else { success = setcursorposition(0); } break; case vi_first_print: success = setcursorposition(0) && vinextword(1); break; case vi_prev_word: success = vipreviousword(count); break; case vi_next_word: success = vinextword(count); break; case vi_end_word: success = viendword(count); break; case vi_insert_beg: success = setcursorposition(0); consolekeys.setkeymap(keymap.vi_insert); break; case vi_rubout: success = virubout(count); break; case vi_delete: success = videlete(count); break; case vi_delete_to: if (state == state.vi_delete_to) { success = setcursorposition(0) && killline(); state = origstate = state.normal; } else { state = state.vi_delete_to; } break; case vi_yank_to: if (state == state.vi_yank_to) { yankbuffer = buf.buffer.tostring(); state = origstate = state.normal; } else { state = state.vi_yank_to; } break; case vi_change_to: if (state == state.vi_change_to) { success = setcursorposition(0) && killline(); state = origstate = state.normal; consolekeys.setkeymap(keymap.vi_insert); } else { state = state.vi_change_to; } break; case vi_kill_whole_line: success = setcursorposition(0) && killline(); consolekeys.setkeymap(keymap.vi_insert); break; case vi_put: success = viput(count); break; case vi_char_search: { int searchchar = (c != ';' && c != ',') ? (pushbackchar.isempty() ? readcharacter() : pushbackchar.pop ()) : 0; success = vicharsearch(count, c, searchchar); } break; case vi_change_case: success = vichangecase(count); break; case vi_change_char: success = vichangechar(count, pushbackchar.isempty() ? readcharacter() : pushbackchar.pop()); break; case vi_delete_to_eol: success = videleteto(buf.cursor, buf.buffer.length(), false); break; case vi_change_to_eol: success = videleteto(buf.cursor, buf.buffer.length(), true); consolekeys.setkeymap(keymap.vi_insert); break; case emacs_editing_mode: consolekeys.setkeymap(keymap.emacs); break; case quit: getcursorbuffer().clear(); return accept(); case quoted_insert: quotedinsert = true; break; case paste_from_clipboard: paste(); break; default: break; } if (origstate != state.normal) { if (origstate == state.vi_delete_to) { success = videleteto(cursorstart, buf.cursor, false); } else if (origstate == state.vi_change_to) { success = videleteto(cursorstart, buf.cursor, true); consolekeys.setkeymap(keymap.vi_insert); } else if (origstate == state.vi_yank_to) { success = viyankto(cursorstart, buf.cursor); } state = state.normal; } if (state == state.normal && !isargdigit) { repeatcount = 0; } if (state != state.search && state != state.forward_search) { originalbuffer = null; previoussearchterm = \"\"; searchterm = null; searchindex = -1; } } } if (!success) { beep(); } opbuffer.setlength(0); flush(); } } finally { if (!terminal.issupported()) { afterreadline(); } if (handleuserinterrupt && (terminal instanceof unixterminal)) { ((unixterminal) terminal).enableinterruptcharacter(); } } }","comment":"\/** * read a line from the <i>in<\/i> {@link inputstream}, and return the line * (without any trailing newlines). * * @param prompt the prompt to issue to the console, may be null. * @return a line that is read from the terminal, or null if there was null input (e.g., <i>ctrl-d<\/i> * was pressed). *\/\n\/\/ prompt may be null \/\/ mask may be null \/\/ buffer may be null \/* * this is the accumulator for vi-mode repeat count. that is, while in * move mode, if you type 30x it will delete 30 characters. this is * where the \"30\" is accumulated until the command is struck. *\/\n\/\/ fixme: this blows, each call to readline will reset the console's state which doesn't seem very nice.\n\/\/ if the terminal is unsupported, just use plain-java reading\n\/\/ handle macros\n\/\/ handle custom callbacks\n\/\/ search mode. \/\/ \/\/ note that we have to do this first, because if there is a command \/\/ not linked to a search command, we leave the search mode and fall \/\/ through to the normal state.\n\/\/ todo: check the isearch-terminators variable terminating the search\n\/\/ set buffer and cursor position to the found string.\n\/\/ set cursor position to the found string\n\/\/ if we're still in search mode, print the search status\n\/\/ otherwise, restore the line\n\/* * if this is still false at the end of the switch, then * we reset our repeatcount to 0. *\/\n\/* * every command that can be repeated a specified number * of times, needs to know how many times to repeat, so * we figure that out here. *\/\n\/* * default success to true. you only need to explicitly * set it if something goes wrong. *\/\n\/* * current location of the cursor (prior to the operation). * these are used by vi *-to operation (e.g. delete-to) * so we know where we came from. *\/\n\/* * if we are on a \"vi\" movement based operation, then we * need to restrict the sets of inputs pretty heavily. *\/\n\/\/ tab\n\/\/ there is an annoyance with tab completion in that \/\/ sometimes the user is actually pasting input in that \/\/ has physical tabs in it. this attempts to look at how \/\/ quickly a character follows the tab, if the character \/\/ follows *immediately*, we assume it is a tab literal.\n\/\/ ctrl-k\n\/\/ ctrl-l\n\/* * vi_move_accept_line is the result of an enter * while in move mode. this is the same as a normal * accept_line, except that we need to enter * insert mode as well. *\/\n\/* * according to bash\/readline move through history * in \"vi\" mode will move the cursor to the * start of the line. if there is no previous * history, then the cursor doesn't move. *\/\n\/* * according to bash\/readline move through history * in \"vi\" mode will move the cursor to the * start of the line. if there is no next history, * then the cursor doesn't move. *\/\n\/\/ backspace\n\/\/ delete\n\/\/ maintain cursor position while searching.\n\/\/ maintain cursor position while searching.\n\/* * if we are re-entering move mode from an * aborted yank-to, delete-to, change-to then * don't move the cursor back. the cursor is * only move on an expclit entry to movement * mode. *\/\n\/* * handler for ctrl-d. attempts to follow readline * behavior. if the line is empty, then it is an eof * otherwise it is as if the user hit enter. *\/\n\/* * this is a weird special case. in vi * \"dd\" deletes the current line. so if we * get a delete-to, followed by a delete-to, * we delete the line. *\/\n\/\/ similar to delete-to, a \"yy\" yanks the whole line.\n\/\/ ';' and ',' don't need another character. they indicate repeat next or repeat prev.\n\/* * if we were in a yank-to, delete-to, move-to * when this operation started, then fall back to *\/\n\/* * another subtly. the check for the normal state is * to ensure that we do not clear out the repeat * count when in delete-to, yank-to, or move-to modes. *\/\n\/* * if the operation performed wasn't a vi argument * digit, then clear out the current repeatcount; *\/","repo":"boris-gelman\/jline2","code_context_2":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\nstate = State.NORMAL;\nboolean success = true;\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > 0) {\nsearchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > -1 && searchIndex < history.size() - 1) {\nsearchIndex = searchForwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase BACKWARD_DELETE_CHAR:\nif (searchTerm.length() > 0) {\nsearchTerm.deleteCharAt(searchTerm.length() - 1);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\n}\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n}\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n\/*\n* If this is still false at the end of the switch, then\n* we reset our repeatCount to 0.\n*\/\nboolean isArgDigit = false;\n\/*\n* Every command that can be repeated a specified number\n* of times, needs to know how many times to repeat, so\n* we figure that out here.\n*\/\nint count = (repeatCount == 0) ? 1 : repeatCount;\n\/*\n* Default success to true. You only need to explicitly\n* set it if something goes wrong.\n*\/\nsuccess = true;\nif (o instanceof Operation) {\nOperation op = (Operation)o;\n\/*\n* Current location of the cursor (prior to the operation).\n* These are used by vi *-to operation (e.g. delete-to)\n* so we know where we came from.\n*\/\nint cursorStart = buf.cursor;\nState origState = state;\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\nreturn accept();\ncase ABORT:\nif (searchTerm == null) {\nabort();\n}\nbreak;\ncase INTERRUPT:\nif (handleUserInterrupt) {\nprintln();\nflush();\nString partialLine = buf.buffer.toString();\nbuf.clear();\nhistory.moveToEnd();\nthrow new UserInterruptException(partialLine);\n}\nbreak;\n\/*\n* VI_MOVE_ACCEPT_LINE is the result of an ENTER\n* while in move mode. This is the same as a normal\n* ACCEPT_LINE, except that we need to enter\n* insert mode as well.\n*\/\ncase VI_MOVE_ACCEPT_LINE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nreturn accept();\ncase BACKWARD_WORD:\nsuccess = previousWord();\nbreak;\ncase FORWARD_WORD:\nsuccess = nextWord();\nbreak;\ncase PREVIOUS_HISTORY:\nsuccess = moveHistory(false);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no previous\n* history, then the cursor doesn't move.\n*\/\ncase VI_PREVIOUS_HISTORY:\nsuccess = moveHistory(false, count)\n&& setCursorPosition(0);\nbreak;\ncase NEXT_HISTORY:\nsuccess = moveHistory(true);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\nbreak;\ncase UNIX_WORD_RUBOUT:\nsuccess = unixWordRubout(count);\nbreak;\ncase BACKWARD_KILL_WORD:\nsuccess = deletePreviousWord();\nbreak;\ncase KILL_WORD:\nsuccess = deleteNextWord();\nbreak;\ncase BEGINNING_OF_HISTORY:\nsuccess = history.moveToFirst();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase END_OF_HISTORY:\nsuccess = history.moveToLast();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\nhistory.moveToEnd();\nsetBufferKeepPos(searchTerm.toString());\n} else if (index < history.size()) {\nsearchIndex = searchForwards(searchTerm.toString(), index, true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\n}\nbreak;\ncase REVERSE_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchBackwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintSearchStatus(\"\", \"\");\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchForwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintForwardSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintForwardSearchStatus(\"\", \"\");\n}\nbreak;\ncase CAPITALIZE_WORD:\nsuccess = capitalizeWord();\nbreak;\ncase UPCASE_WORD:\nsuccess = upCaseWord();\nbreak;\ncase DOWNCASE_WORD:\nsuccess = downCaseWord();\nbreak;\ncase END_OF_LINE:\nsuccess = moveToEnd();\nbreak;\ncase TAB_INSERT:\nputString( \"\\t\" );\nbreak;\ncase RE_READ_INIT_FILE:\nconsoleKeys.loadKeys(appName, inputrcUrl);\nbreak;\ncase START_KBD_MACRO:\nrecording = true;\nbreak;\ncase END_KBD_MACRO:\nrecording = false;\nmacro = macro.substring(0, macro.length() - opBuffer.length());\nbreak;\ncase CALL_LAST_KBD_MACRO:\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\nbreak;\ncase VI_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_MOVEMENT_MODE:\n\/*\n* If we are re-entering move mode from an\n* aborted yank-to, delete-to, change-to then\n* don't move the cursor back. The cursor is\n* only move on an expclit entry to movement\n* mode.\n*\/\nif (state == State.NORMAL) {\nmoveCursor(-1);\n}\nconsoleKeys.setKeyMap(KeyMap.VI_MOVE);\nbreak;\ncase VI_INSERTION_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_MODE:\nmoveCursor(1);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_EOL:\nsuccess = moveToEnd();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\n\/*\n* Handler for CTRL-D. Attempts to follow readline\n* behavior. If the line is empty, then it is an EOF\n* otherwise it is as if the user hit enter.\n*\/\ncase VI_EOF_MAYBE:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nreturn accept();\ncase TRANSPOSE_CHARS:\nsuccess = transposeChars(count);\nbreak;\ncase INSERT_COMMENT:\nreturn insertComment (false);\ncase INSERT_CLOSE_CURLY:\ninsertClose(\"}\");\nbreak;\ncase INSERT_CLOSE_PAREN:\ninsertClose(\")\");\nbreak;\ncase INSERT_CLOSE_SQUARE:\ninsertClose(\"]\");\nbreak;\ncase VI_INSERT_COMMENT:\nreturn insertComment (true);\ncase VI_MATCH:\nsuccess = viMatch ();\nbreak;\ncase VI_SEARCH:\nint lastChar = viSearch(opBuffer.charAt(0));\nif (lastChar != -1) {\npushBackChar.push((char)lastChar);\n}\nbreak;\ncase VI_ARG_DIGIT:\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\nbreak;\ncase VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\nif (repeatCount > 0) {\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\n}\nelse {\nsuccess = setCursorPosition(0);\n}\nbreak;\ncase VI_FIRST_PRINT:\nsuccess = setCursorPosition(0) && viNextWord(1);\nbreak;\ncase VI_PREV_WORD:\nsuccess = viPreviousWord(count);\nbreak;\ncase VI_NEXT_WORD:\nsuccess = viNextWord(count);\nbreak;\ncase VI_END_WORD:\nsuccess = viEndWord(count);\nbreak;\ncase VI_INSERT_BEG:\nsuccess = setCursorPosition(0);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_RUBOUT:\nsuccess = viRubout(count);\nbreak;\ncase VI_DELETE:\nsuccess = viDelete(count);\nbreak;\ncase VI_DELETE_TO:\n\/*\n* This is a weird special case. In vi\n* \"dd\" deletes the current line. So if we\n* get a delete-to, followed by a delete-to,\n* we delete the line.\n*\/\nif (state == State.VI_DELETE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_DELETE_TO;\n}\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_YANK_TO;\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse {\nstate = State.VI_CHANGE_TO;\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_PUT:\nsuccess = viPut(count);\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop ())\n: 0;\nsuccess = viCharSearch(count, c, searchChar);\n}\nbreak;\ncase VI_CHANGE_CASE:\nsuccess = viChangeCase(count);\nbreak;\ncase VI_CHANGE_CHAR:\nsuccess = viChangeChar(count,\npushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop());\nbreak;\ncase VI_DELETE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), false);\nbreak;\ncase VI_CHANGE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase EMACS_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.EMACS);\nbreak;\ncase QUIT:\ngetCursorBuffer().clear();\nreturn accept();\ncase QUOTED_INSERT:\nquotedInsert = true;\nbreak;\ncase PASTE_FROM_CLIPBOARD:\npaste();\nbreak;\ndefault:\nbreak;\n}\n\/*\n* If we were in a yank-to, delete-to, move-to\n* when this operation started, then fall back to\n*\/\nif (origState != State.NORMAL) {\nif (origState == State.VI_DELETE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, false);\n}\nelse if (origState == State.VI_CHANGE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse if (origState == State.VI_YANK_TO) {\nsuccess = viYankTo(cursorStart, buf.cursor);\n}\nstate = State.NORMAL;\n}\n\/*\n* Another subtly. The check for the NORMAL state is\n* to ensure that we do not clear out the repeat\n* count when in delete-to, yank-to, or move-to modes.\n*\/\nif (state == State.NORMAL && !isArgDigit) {\n\/*\n* If the operation performed wasn't a vi argument\n* digit, then clear out the current repeatCount;\n*\/\nrepeatCount = 0;\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\noriginalBuffer = null;\npreviousSearchTerm = \"\";\nsearchTerm = null;\nsearchIndex = -1;\n}\n}\n}\nif (!success) {\nbeep();\n}\nopBuffer.setLength(0);\nflush();\n}\n}\nfinally {\nif (!terminal.isSupported()) {\nafterReadLine();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).enableInterruptCharacter();\n}\n}\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\n\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\n\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\n\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\n\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\n\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\n\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\n\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\n\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\n\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\n\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\n\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\n\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\n\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;","code_context_10":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\nstate = State.NORMAL;\nboolean success = true;\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > 0) {\nsearchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > -1 && searchIndex < history.size() - 1) {\nsearchIndex = searchForwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase BACKWARD_DELETE_CHAR:\nif (searchTerm.length() > 0) {\nsearchTerm.deleteCharAt(searchTerm.length() - 1);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\n}\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n}\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n\/*\n* If this is still false at the end of the switch, then\n* we reset our repeatCount to 0.\n*\/\nboolean isArgDigit = false;\n\/*\n* Every command that can be repeated a specified number\n* of times, needs to know how many times to repeat, so\n* we figure that out here.\n*\/\nint count = (repeatCount == 0) ? 1 : repeatCount;\n\/*\n* Default success to true. You only need to explicitly\n* set it if something goes wrong.\n*\/\nsuccess = true;\nif (o instanceof Operation) {\nOperation op = (Operation)o;\n\/*\n* Current location of the cursor (prior to the operation).\n* These are used by vi *-to operation (e.g. delete-to)\n* so we know where we came from.\n*\/\nint cursorStart = buf.cursor;\nState origState = state;\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\nreturn accept();\ncase ABORT:\nif (searchTerm == null) {\nabort();\n}\nbreak;\ncase INTERRUPT:\nif (handleUserInterrupt) {\nprintln();\nflush();\nString partialLine = buf.buffer.toString();\nbuf.clear();\nhistory.moveToEnd();\nthrow new UserInterruptException(partialLine);\n}\nbreak;\n\/*\n* VI_MOVE_ACCEPT_LINE is the result of an ENTER\n* while in move mode. This is the same as a normal\n* ACCEPT_LINE, except that we need to enter\n* insert mode as well.\n*\/\ncase VI_MOVE_ACCEPT_LINE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nreturn accept();\ncase BACKWARD_WORD:\nsuccess = previousWord();\nbreak;\ncase FORWARD_WORD:\nsuccess = nextWord();\nbreak;\ncase PREVIOUS_HISTORY:\nsuccess = moveHistory(false);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no previous\n* history, then the cursor doesn't move.\n*\/\ncase VI_PREVIOUS_HISTORY:\nsuccess = moveHistory(false, count)\n&& setCursorPosition(0);\nbreak;\ncase NEXT_HISTORY:\nsuccess = moveHistory(true);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\nbreak;\ncase UNIX_WORD_RUBOUT:\nsuccess = unixWordRubout(count);\nbreak;\ncase BACKWARD_KILL_WORD:\nsuccess = deletePreviousWord();\nbreak;\ncase KILL_WORD:\nsuccess = deleteNextWord();\nbreak;\ncase BEGINNING_OF_HISTORY:\nsuccess = history.moveToFirst();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase END_OF_HISTORY:\nsuccess = history.moveToLast();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\nhistory.moveToEnd();\nsetBufferKeepPos(searchTerm.toString());\n} else if (index < history.size()) {\nsearchIndex = searchForwards(searchTerm.toString(), index, true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\n}\nbreak;\ncase REVERSE_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchBackwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintSearchStatus(\"\", \"\");\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchForwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintForwardSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintForwardSearchStatus(\"\", \"\");\n}\nbreak;\ncase CAPITALIZE_WORD:\nsuccess = capitalizeWord();\nbreak;\ncase UPCASE_WORD:\nsuccess = upCaseWord();\nbreak;\ncase DOWNCASE_WORD:\nsuccess = downCaseWord();\nbreak;\ncase END_OF_LINE:\nsuccess = moveToEnd();\nbreak;\ncase TAB_INSERT:\nputString( \"\\t\" );\nbreak;\ncase RE_READ_INIT_FILE:\nconsoleKeys.loadKeys(appName, inputrcUrl);\nbreak;\ncase START_KBD_MACRO:\nrecording = true;\nbreak;\ncase END_KBD_MACRO:\nrecording = false;\nmacro = macro.substring(0, macro.length() - opBuffer.length());\nbreak;\ncase CALL_LAST_KBD_MACRO:\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\nbreak;\ncase VI_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_MOVEMENT_MODE:\n\/*\n* If we are re-entering move mode from an\n* aborted yank-to, delete-to, change-to then\n* don't move the cursor back. The cursor is\n* only move on an expclit entry to movement\n* mode.\n*\/\nif (state == State.NORMAL) {\nmoveCursor(-1);\n}\nconsoleKeys.setKeyMap(KeyMap.VI_MOVE);\nbreak;\ncase VI_INSERTION_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_MODE:\nmoveCursor(1);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_EOL:\nsuccess = moveToEnd();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\n\/*\n* Handler for CTRL-D. Attempts to follow readline\n* behavior. If the line is empty, then it is an EOF\n* otherwise it is as if the user hit enter.\n*\/\ncase VI_EOF_MAYBE:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nreturn accept();\ncase TRANSPOSE_CHARS:\nsuccess = transposeChars(count);\nbreak;\ncase INSERT_COMMENT:\nreturn insertComment (false);\ncase INSERT_CLOSE_CURLY:\ninsertClose(\"}\");\nbreak;\ncase INSERT_CLOSE_PAREN:\ninsertClose(\")\");\nbreak;\ncase INSERT_CLOSE_SQUARE:\ninsertClose(\"]\");\nbreak;\ncase VI_INSERT_COMMENT:\nreturn insertComment (true);\ncase VI_MATCH:\nsuccess = viMatch ();\nbreak;\ncase VI_SEARCH:\nint lastChar = viSearch(opBuffer.charAt(0));\nif (lastChar != -1) {\npushBackChar.push((char)lastChar);\n}\nbreak;\ncase VI_ARG_DIGIT:\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\nbreak;\ncase VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\nif (repeatCount > 0) {\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\n}\nelse {\nsuccess = setCursorPosition(0);\n}\nbreak;\ncase VI_FIRST_PRINT:\nsuccess = setCursorPosition(0) && viNextWord(1);\nbreak;\ncase VI_PREV_WORD:\nsuccess = viPreviousWord(count);\nbreak;\ncase VI_NEXT_WORD:\nsuccess = viNextWord(count);\nbreak;\ncase VI_END_WORD:\nsuccess = viEndWord(count);\nbreak;\ncase VI_INSERT_BEG:\nsuccess = setCursorPosition(0);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_RUBOUT:\nsuccess = viRubout(count);\nbreak;\ncase VI_DELETE:\nsuccess = viDelete(count);\nbreak;\ncase VI_DELETE_TO:\n\/*\n* This is a weird special case. In vi\n* \"dd\" deletes the current line. So if we\n* get a delete-to, followed by a delete-to,\n* we delete the line.\n*\/\nif (state == State.VI_DELETE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_DELETE_TO;\n}\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_YANK_TO;\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse {\nstate = State.VI_CHANGE_TO;\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_PUT:\nsuccess = viPut(count);\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop ())\n: 0;\nsuccess = viCharSearch(count, c, searchChar);\n}\nbreak;\ncase VI_CHANGE_CASE:\nsuccess = viChangeCase(count);\nbreak;\ncase VI_CHANGE_CHAR:\nsuccess = viChangeChar(count,\npushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop());\nbreak;\ncase VI_DELETE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), false);\nbreak;\ncase VI_CHANGE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase EMACS_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.EMACS);\nbreak;\ncase QUIT:\ngetCursorBuffer().clear();\nreturn accept();\ncase QUOTED_INSERT:\nquotedInsert = true;\nbreak;\ncase PASTE_FROM_CLIPBOARD:\npaste();\nbreak;\ndefault:\nbreak;\n}\n\/*\n* If we were in a yank-to, delete-to, move-to\n* when this operation started, then fall back to\n*\/\nif (origState != State.NORMAL) {\nif (origState == State.VI_DELETE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, false);\n}\nelse if (origState == State.VI_CHANGE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse if (origState == State.VI_YANK_TO) {\nsuccess = viYankTo(cursorStart, buf.cursor);\n}\nstate = State.NORMAL;\n}\n\/*\n* Another subtly. The check for the NORMAL state is\n* to ensure that we do not clear out the repeat\n* count when in delete-to, yank-to, or move-to modes.\n*\/\nif (state == State.NORMAL && !isArgDigit) {\n\/*\n* If the operation performed wasn't a vi argument\n* digit, then clear out the current repeatCount;\n*\/\nrepeatCount = 0;\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\noriginalBuffer = null;\npreviousSearchTerm = \"\";\nsearchTerm = null;\nsearchIndex = -1;\n}\n}\n}\nif (!success) {\nbeep();\n}\nopBuffer.setLength(0);\nflush();\n}\n}\nfinally {\nif (!terminal.isSupported()) {\nafterReadLine();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).enableInterruptCharacter();\n}\n}\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\n\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\n\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\n\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\n\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n}\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n\/*\n* If this is still false at the end of the switch, then\n* we reset our repeatCount to 0.\n*\/\nboolean isArgDigit = false;\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\n\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\n\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\n\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\n\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\n\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\n\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\n\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\n\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\n\n*\/\nif (state == State.VI_DELETE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_DELETE_TO;\n}\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_YANK_TO;\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\n\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_PUT:\nsuccess = viPut(count);\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop ())\n: 0;\nsuccess = viCharSearch(count, c, searchChar);\n}\nbreak;\ncase VI_CHANGE_CASE:\nsuccess = viChangeCase(count);\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}","code_context_20":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\nstate = State.NORMAL;\nboolean success = true;\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > 0) {\nsearchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > -1 && searchIndex < history.size() - 1) {\nsearchIndex = searchForwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase BACKWARD_DELETE_CHAR:\nif (searchTerm.length() > 0) {\nsearchTerm.deleteCharAt(searchTerm.length() - 1);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\n}\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n}\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n\/*\n* If this is still false at the end of the switch, then\n* we reset our repeatCount to 0.\n*\/\nboolean isArgDigit = false;\n\/*\n* Every command that can be repeated a specified number\n* of times, needs to know how many times to repeat, so\n* we figure that out here.\n*\/\nint count = (repeatCount == 0) ? 1 : repeatCount;\n\/*\n* Default success to true. You only need to explicitly\n* set it if something goes wrong.\n*\/\nsuccess = true;\nif (o instanceof Operation) {\nOperation op = (Operation)o;\n\/*\n* Current location of the cursor (prior to the operation).\n* These are used by vi *-to operation (e.g. delete-to)\n* so we know where we came from.\n*\/\nint cursorStart = buf.cursor;\nState origState = state;\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\nreturn accept();\ncase ABORT:\nif (searchTerm == null) {\nabort();\n}\nbreak;\ncase INTERRUPT:\nif (handleUserInterrupt) {\nprintln();\nflush();\nString partialLine = buf.buffer.toString();\nbuf.clear();\nhistory.moveToEnd();\nthrow new UserInterruptException(partialLine);\n}\nbreak;\n\/*\n* VI_MOVE_ACCEPT_LINE is the result of an ENTER\n* while in move mode. This is the same as a normal\n* ACCEPT_LINE, except that we need to enter\n* insert mode as well.\n*\/\ncase VI_MOVE_ACCEPT_LINE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nreturn accept();\ncase BACKWARD_WORD:\nsuccess = previousWord();\nbreak;\ncase FORWARD_WORD:\nsuccess = nextWord();\nbreak;\ncase PREVIOUS_HISTORY:\nsuccess = moveHistory(false);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no previous\n* history, then the cursor doesn't move.\n*\/\ncase VI_PREVIOUS_HISTORY:\nsuccess = moveHistory(false, count)\n&& setCursorPosition(0);\nbreak;\ncase NEXT_HISTORY:\nsuccess = moveHistory(true);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\nbreak;\ncase UNIX_WORD_RUBOUT:\nsuccess = unixWordRubout(count);\nbreak;\ncase BACKWARD_KILL_WORD:\nsuccess = deletePreviousWord();\nbreak;\ncase KILL_WORD:\nsuccess = deleteNextWord();\nbreak;\ncase BEGINNING_OF_HISTORY:\nsuccess = history.moveToFirst();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase END_OF_HISTORY:\nsuccess = history.moveToLast();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\nhistory.moveToEnd();\nsetBufferKeepPos(searchTerm.toString());\n} else if (index < history.size()) {\nsearchIndex = searchForwards(searchTerm.toString(), index, true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\n}\nbreak;\ncase REVERSE_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchBackwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintSearchStatus(\"\", \"\");\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\noriginalBuffer = new CursorBuffer();\noriginalBuffer.write(buf.buffer);\noriginalBuffer.cursor = buf.cursor;\nif (searchTerm != null) {\npreviousSearchTerm = searchTerm.toString();\n}\nsearchTerm = new StringBuffer(buf.buffer);\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() > 0) {\nsearchIndex = searchForwards(searchTerm.toString());\nif (searchIndex == -1) {\nbeep();\n}\nprintForwardSearchStatus(searchTerm.toString(),\nsearchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n} else {\nsearchIndex = -1;\nprintForwardSearchStatus(\"\", \"\");\n}\nbreak;\ncase CAPITALIZE_WORD:\nsuccess = capitalizeWord();\nbreak;\ncase UPCASE_WORD:\nsuccess = upCaseWord();\nbreak;\ncase DOWNCASE_WORD:\nsuccess = downCaseWord();\nbreak;\ncase END_OF_LINE:\nsuccess = moveToEnd();\nbreak;\ncase TAB_INSERT:\nputString( \"\\t\" );\nbreak;\ncase RE_READ_INIT_FILE:\nconsoleKeys.loadKeys(appName, inputrcUrl);\nbreak;\ncase START_KBD_MACRO:\nrecording = true;\nbreak;\ncase END_KBD_MACRO:\nrecording = false;\nmacro = macro.substring(0, macro.length() - opBuffer.length());\nbreak;\ncase CALL_LAST_KBD_MACRO:\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\nbreak;\ncase VI_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_MOVEMENT_MODE:\n\/*\n* If we are re-entering move mode from an\n* aborted yank-to, delete-to, change-to then\n* don't move the cursor back. The cursor is\n* only move on an expclit entry to movement\n* mode.\n*\/\nif (state == State.NORMAL) {\nmoveCursor(-1);\n}\nconsoleKeys.setKeyMap(KeyMap.VI_MOVE);\nbreak;\ncase VI_INSERTION_MODE:\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_MODE:\nmoveCursor(1);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_APPEND_EOL:\nsuccess = moveToEnd();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\n\/*\n* Handler for CTRL-D. Attempts to follow readline\n* behavior. If the line is empty, then it is an EOF\n* otherwise it is as if the user hit enter.\n*\/\ncase VI_EOF_MAYBE:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nreturn accept();\ncase TRANSPOSE_CHARS:\nsuccess = transposeChars(count);\nbreak;\ncase INSERT_COMMENT:\nreturn insertComment (false);\ncase INSERT_CLOSE_CURLY:\ninsertClose(\"}\");\nbreak;\ncase INSERT_CLOSE_PAREN:\ninsertClose(\")\");\nbreak;\ncase INSERT_CLOSE_SQUARE:\ninsertClose(\"]\");\nbreak;\ncase VI_INSERT_COMMENT:\nreturn insertComment (true);\ncase VI_MATCH:\nsuccess = viMatch ();\nbreak;\ncase VI_SEARCH:\nint lastChar = viSearch(opBuffer.charAt(0));\nif (lastChar != -1) {\npushBackChar.push((char)lastChar);\n}\nbreak;\ncase VI_ARG_DIGIT:\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\nbreak;\ncase VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\nif (repeatCount > 0) {\nrepeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\nisArgDigit = true;\n}\nelse {\nsuccess = setCursorPosition(0);\n}\nbreak;\ncase VI_FIRST_PRINT:\nsuccess = setCursorPosition(0) && viNextWord(1);\nbreak;\ncase VI_PREV_WORD:\nsuccess = viPreviousWord(count);\nbreak;\ncase VI_NEXT_WORD:\nsuccess = viNextWord(count);\nbreak;\ncase VI_END_WORD:\nsuccess = viEndWord(count);\nbreak;\ncase VI_INSERT_BEG:\nsuccess = setCursorPosition(0);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_RUBOUT:\nsuccess = viRubout(count);\nbreak;\ncase VI_DELETE:\nsuccess = viDelete(count);\nbreak;\ncase VI_DELETE_TO:\n\/*\n* This is a weird special case. In vi\n* \"dd\" deletes the current line. So if we\n* get a delete-to, followed by a delete-to,\n* we delete the line.\n*\/\nif (state == State.VI_DELETE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_DELETE_TO;\n}\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_YANK_TO;\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse {\nstate = State.VI_CHANGE_TO;\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_PUT:\nsuccess = viPut(count);\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop ())\n: 0;\nsuccess = viCharSearch(count, c, searchChar);\n}\nbreak;\ncase VI_CHANGE_CASE:\nsuccess = viChangeCase(count);\nbreak;\ncase VI_CHANGE_CHAR:\nsuccess = viChangeChar(count,\npushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop());\nbreak;\ncase VI_DELETE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), false);\nbreak;\ncase VI_CHANGE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase EMACS_EDITING_MODE:\nconsoleKeys.setKeyMap(KeyMap.EMACS);\nbreak;\ncase QUIT:\ngetCursorBuffer().clear();\nreturn accept();\ncase QUOTED_INSERT:\nquotedInsert = true;\nbreak;\ncase PASTE_FROM_CLIPBOARD:\npaste();\nbreak;\ndefault:\nbreak;\n}\n\/*\n* If we were in a yank-to, delete-to, move-to\n* when this operation started, then fall back to\n*\/\nif (origState != State.NORMAL) {\nif (origState == State.VI_DELETE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, false);\n}\nelse if (origState == State.VI_CHANGE_TO) {\nsuccess = viDeleteTo(cursorStart, buf.cursor, true);\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse if (origState == State.VI_YANK_TO) {\nsuccess = viYankTo(cursorStart, buf.cursor);\n}\nstate = State.NORMAL;\n}\n\/*\n* Another subtly. The check for the NORMAL state is\n* to ensure that we do not clear out the repeat\n* count when in delete-to, yank-to, or move-to modes.\n*\/\nif (state == State.NORMAL && !isArgDigit) {\n\/*\n* If the operation performed wasn't a vi argument\n* digit, then clear out the current repeatCount;\n*\/\nrepeatCount = 0;\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\noriginalBuffer = null;\npreviousSearchTerm = \"\";\nsearchTerm = null;\nsearchIndex = -1;\n}\n}\n}\nif (!success) {\nbeep();\n}\nopBuffer.setLength(0);\nflush();\n}\n}\nfinally {\nif (!terminal.isSupported()) {\nafterReadLine();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).enableInterruptCharacter();\n}\n}\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\n\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\nif (!terminal.isSupported()) {\nreturn readLineSimple();\n}\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\nstate = State.NORMAL;\nboolean success = true;\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\n\nif (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableInterruptCharacter();\n}\nif (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n((UnixTerminal) terminal).disableLitteralNextCharacter();\n}\nString originalPrompt = this.prompt;\nstate = State.NORMAL;\nboolean success = true;\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\npushBackChar.clear();\nwhile (true) {\nObject o = readBinding(getKeys());\nif (o == null) {\nreturn null;\n}\nint c = 0;\nif (opBuffer.length() > 0) {\nc = opBuffer.codePointBefore(opBuffer.length());\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\n\n}\nLog.trace(\"Binding: \", o);\n\/\/ Handle macros\nif (o instanceof String) {\nString macro = (String) o;\nfor (int i = 0; i < macro.length(); i++) {\npushBackChar.push(macro.charAt(macro.length() - 1 - i));\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > 0) {\nsearchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\n\n}\nopBuffer.setLength(0);\ncontinue;\n}\n\/\/ Handle custom callbacks\nif (o instanceof ActionListener) {\n((ActionListener) o).actionPerformed(null);\nopBuffer.setLength(0);\ncontinue;\n}\nCursorBuffer oldBuf = new CursorBuffer();\noldBuf.buffer.append(buf.buffer);\noldBuf.cursor = buf.cursor;\n\/\/ Search mode.\n\/\/\n\/\/ Note that we have to do this first, because if there is a command\n\/\/ not linked to a search command, we leave the search mode and fall\n\/\/ through to the normal state.\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nint cursorDest = -1;\n\/\/ TODO: check the isearch-terminators variable terminating the search\nswitch ( ((Operation) o )) {\ncase ABORT:\nstate = State.NORMAL;\nbuf.clear();\nbuf.write(originalBuffer.buffer);\nbuf.cursor = originalBuffer.cursor;\nbreak;\ncase REVERSE_SEARCH_HISTORY:\nstate = State.SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n}\nif (searchIndex > 0) {\nsearchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n}\nbreak;\ncase FORWARD_SEARCH_HISTORY:\nstate = State.FORWARD_SEARCH;\nif (searchTerm.length() == 0) {\nsearchTerm.append(previousSearchTerm);\n\nbreak;\ncase BACKWARD_DELETE_CHAR:\nif (searchTerm.length() > 0) {\nsearchTerm.deleteCharAt(searchTerm.length() - 1);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\n}\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n\nsearchTerm.deleteCharAt(searchTerm.length() - 1);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\n}\nbreak;\ncase SELF_INSERT:\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\n\nsearchTerm.appendCodePoint(c);\nif (state == State.SEARCH) {\nsearchIndex = searchBackwards(searchTerm.toString());\n} else {\nsearchIndex = searchForwards(searchTerm.toString());\n}\nbreak;\ndefault:\n\/\/ Set buffer and cursor position to the found string.\nif (searchIndex != -1) {\nhistory.moveTo(searchIndex);\n\/\/ set cursor position to the found string\ncursorDest = history.current().toString().indexOf(searchTerm.toString());\n}\nif (o != Operation.ACCEPT_LINE) {\no = null;\n}\nstate = State.NORMAL;\nbreak;\n}\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\n\n\/\/ if we're still in search mode, print the search status\nif (state == State.SEARCH || state == State.FORWARD_SEARCH) {\nif (searchTerm.length() == 0) {\nif (state == State.SEARCH) {\nprintSearchStatus(\"\", \"\");\n} else {\nprintForwardSearchStatus(\"\", \"\");\n}\nsearchIndex = -1;\n} else {\nif (searchIndex == -1) {\nbeep();\nprintSearchStatus(searchTerm.toString(), \"\");\n} else if (state == State.SEARCH) {\nprintSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n} else {\nprintForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n}\n}\n}\n\/\/ otherwise, restore the line\nelse {\nrestoreLine(originalPrompt, cursorDest);\n}\n}\nif (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n\/*\n* If this is still false at the end of the switch, then\n* we reset our repeatCount to 0.\n*\/\nboolean isArgDigit = false;\n\/*\n* Every command that can be repeated a specified number\n* of times, needs to know how many times to repeat, so\n* we figure that out here.\n*\/\nint count = (repeatCount == 0) ? 1 : repeatCount;\n\/*\n* Default success to true. You only need to explicitly\n* set it if something goes wrong.\n*\/\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\n\nsuccess = true;\nif (o instanceof Operation) {\nOperation op = (Operation)o;\n\/*\n* Current location of the cursor (prior to the operation).\n* These are used by vi *-to operation (e.g. delete-to)\n* so we know where we came from.\n*\/\nint cursorStart = buf.cursor;\nState origState = state;\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\n\nif (o instanceof Operation) {\nOperation op = (Operation)o;\n\/*\n* Current location of the cursor (prior to the operation).\n* These are used by vi *-to operation (e.g. delete-to)\n* so we know where we came from.\n*\/\nint cursorStart = buf.cursor;\nState origState = state;\n\/*\n* If we are on a \"vi\" movement based operation, then we\n* need to restrict the sets of inputs pretty heavily.\n*\/\nif (state == State.VI_CHANGE_TO\n|| state == State.VI_YANK_TO\n|| state == State.VI_DELETE_TO) {\nop = viDeleteChangeYankToRemap(op);\n}\nswitch ( op ) {\ncase COMPLETE: \/\/ tab\n\/\/ There is an annoyance with tab completion in that\n\/\/ sometimes the user is actually pasting input in that\n\/\/ has physical tabs in it. This attempts to look at how\n\/\/ quickly a character follows the tab, if the character\n\/\/ follows *immediately*, we assume it is a tab literal.\nboolean isTabLiteral = false;\nif (copyPasteDetection\n&& c == 9\n&& (!pushBackChar.isEmpty()\n|| (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\nisTabLiteral = true;\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\n\n}\nif (! isTabLiteral) {\nsuccess = complete();\n}\nelse {\nputString(opBuffer);\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\nreturn accept();\ncase ABORT:\nif (searchTerm == null) {\nabort();\n\n}\nbreak;\ncase POSSIBLE_COMPLETIONS:\nprintCompletionCandidates();\nbreak;\ncase BEGINNING_OF_LINE:\nsuccess = setCursorPosition(0);\nbreak;\ncase YANK:\nsuccess = yank();\nbreak;\ncase YANK_POP:\nsuccess = yankPop();\nbreak;\ncase KILL_LINE: \/\/ CTRL-K\nsuccess = killLine();\nbreak;\ncase KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nbreak;\ncase CLEAR_SCREEN: \/\/ CTRL-L\nsuccess = clearScreen();\nredrawLine();\nbreak;\ncase OVERWRITE_MODE:\nbuf.setOverTyping(!buf.isOverTyping());\nbreak;\ncase SELF_INSERT:\nputString(opBuffer);\nbreak;\ncase ACCEPT_LINE:\nreturn accept();\ncase ABORT:\nif (searchTerm == null) {\nabort();\n}\nbreak;\ncase INTERRUPT:\nif (handleUserInterrupt) {\nprintln();\nflush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\n* start of the line. If there is no previous\n* history, then the cursor doesn't move.\n*\/\ncase VI_PREVIOUS_HISTORY:\nsuccess = moveHistory(false, count)\n&& setCursorPosition(0);\nbreak;\ncase NEXT_HISTORY:\nsuccess = moveHistory(true);\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\nbreak;\n\nbreak;\n\/*\n* According to bash\/readline move through history\n* in \"vi\" mode will move the cursor to the\n* start of the line. If there is no next history,\n* then the cursor doesn't move.\n*\/\ncase VI_NEXT_HISTORY:\nsuccess = moveHistory(true, count)\n&& setCursorPosition(0);\nbreak;\ncase BACKWARD_DELETE_CHAR: \/\/ backspace\nsuccess = backspace();\nbreak;\ncase EXIT_OR_DELETE_CHAR:\nif (buf.buffer.length() == 0) {\nreturn null;\n}\nsuccess = deleteCurrentCharacter();\nbreak;\ncase DELETE_CHAR: \/\/ delete\nsuccess = deleteCurrentCharacter();\nbreak;\ncase BACKWARD_CHAR:\nsuccess = moveCursor(-(count)) != 0;\nbreak;\ncase FORWARD_CHAR:\nsuccess = moveCursor(count) != 0;\nbreak;\ncase UNIX_LINE_DISCARD:\nsuccess = resetLine();\nbreak;\ncase UNIX_WORD_RUBOUT:\nsuccess = unixWordRubout(count);\nbreak;\ncase BACKWARD_KILL_WORD:\nsuccess = deletePreviousWord();\nbreak;\ncase KILL_WORD:\nsuccess = deleteNextWord();\nbreak;\n\nsuccess = deleteNextWord();\nbreak;\ncase BEGINNING_OF_HISTORY:\nsuccess = history.moveToFirst();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase END_OF_HISTORY:\nsuccess = history.moveToLast();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\nhistory.moveToEnd();\nsetBufferKeepPos(searchTerm.toString());\n} else if (index < history.size()) {\nsearchIndex = searchForwards(searchTerm.toString(), index, true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\n\nsuccess = deleteNextWord();\nbreak;\ncase BEGINNING_OF_HISTORY:\nsuccess = history.moveToFirst();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase END_OF_HISTORY:\nsuccess = history.moveToLast();\nif (success) {\nsetBuffer(history.current());\n}\nbreak;\ncase HISTORY_SEARCH_BACKWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nsearchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\nsetBufferKeepPos(history.current());\n}\n}\nbreak;\ncase HISTORY_SEARCH_FORWARD:\nsearchTerm = new StringBuffer(buf.upToCursor());\nint index = history.index() + 1;\nif (index == history.size()) {\nhistory.moveToEnd();\nsetBufferKeepPos(searchTerm.toString());\n} else if (index < history.size()) {\nsearchIndex = searchForwards(searchTerm.toString(), index, true);\nif (searchIndex == -1) {\nbeep();\n} else {\n\/\/ Maintain cursor position while searching.\nsuccess = history.moveTo(searchIndex);\nif (success) {\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\/\/ if the terminal is unsupported, just use plain-java reading\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n}\n\nbreak;\ncase VI_DELETE:\nsuccess = viDelete(count);\nbreak;\ncase VI_DELETE_TO:\n\/*\n* This is a weird special case. In vi\n* \"dd\" deletes the current line. So if we\n* get a delete-to, followed by a delete-to,\n* we delete the line.\n*\/\nif (state == State.VI_DELETE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_DELETE_TO;\n}\nbreak;\ncase VI_YANK_TO:\n\/\/ Similar to delete-to, a \"yy\" yanks the whole line.\nif (state == State.VI_YANK_TO) {\nyankBuffer = buf.buffer.toString();\nstate = origState = State.NORMAL;\n}\nelse {\nstate = State.VI_YANK_TO;\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse {\nstate = State.VI_CHANGE_TO;\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\n\n}\nbreak;\ncase VI_CHANGE_TO:\nif (state == State.VI_CHANGE_TO) {\nsuccess = setCursorPosition(0) && killLine();\nstate = origState = State.NORMAL;\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\n}\nelse {\nstate = State.VI_CHANGE_TO;\n}\nbreak;\ncase VI_KILL_WHOLE_LINE:\nsuccess = setCursorPosition(0) && killLine();\nconsoleKeys.setKeyMap(KeyMap.VI_INSERT);\nbreak;\ncase VI_PUT:\nsuccess = viPut(count);\nbreak;\ncase VI_CHAR_SEARCH: {\n\/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\nint searchChar = (c != ';' && c != ',')\n? (pushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop ())\n: 0;\nsuccess = viCharSearch(count, c, searchChar);\n}\nbreak;\ncase VI_CHANGE_CASE:\nsuccess = viChangeCase(count);\nbreak;\ncase VI_CHANGE_CHAR:\nsuccess = viChangeChar(count,\npushBackChar.isEmpty()\n? readCharacter()\n: pushBackChar.pop());\nbreak;\ncase VI_DELETE_TO_EOL:\nsuccess = viDeleteTo(buf.cursor, buf.buffer.length(), false);\nbreak;\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();\nout.flush();\n\npublic String readLine(String prompt, final Character mask, String buffer) throws IOException {\n\/\/ prompt may be null\n\/\/ mask may be null\n\/\/ buffer may be null\n\/*\n* This is the accumulator for VI-mode repeat count. That is, while in\n* move mode, if you type 30x it will delete 30 characters. This is\n* where the \"30\" is accumulated until the command is struck.\n*\/\nint repeatCount = 0;\n\/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\nthis.mask = mask != null ? mask : this.echoCharacter;\nif (prompt != null) {\nsetPrompt(prompt);\n}\nelse {\nprompt = getPrompt();\n}\ntry {\nif (buffer != null) {\nbuf.write(buffer);\n}\nif (!terminal.isSupported()) {\nbeforeReadLine(prompt, mask);\n}\nif (buffer != null && buffer.length() > 0\n|| prompt != null && prompt.length() > 0) {\ndrawLine();","label":[0,1,1,0]}
{"id":10081,"original_code":"public int undo()\n\t{\n\t\tif (turn == 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t\/\/ Restore game history (pop current moves frame and reset selected move):\n\t\tmoves_frame = moves[moves_frame + 1];\n\t\tfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\n\t\tmoves[moves_frame + 2] = 0;\n\t\t\/\/ Restore cached current game situation (figure constellation, king positions,\n\t\t\/\/\tcastlings, active player and turn number):\n\t\tfinal var x = Move.x(move);\n\t\tfinal var y = Move.y(move);\n\t\tfinal var X = Move.X(move);\n\t\tfinal var Y = Move.Y(move);\n\t\tfinal var figure_moved = Move.figure_moved(move);\n\t\tfinal var figure_destination = Move.figure_destination(move);\n\t\tboard[x][y] = figure_moved;\n\t\tboard[X][Y] = figure_destination;\n\t\tif (figure_moved.is_king())\n\t\t{\n\t\t\tif (player)\n\t\t\t{\n\t\t\t\tking_x_b = x;\n\t\t\t\tking_y_b = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tking_x_w = x;\n\t\t\t\tking_y_w = y;\n\t\t\t}\n\t\t\tif (X == x - 2)\n\t\t\t{ \/\/ Castling left:\n\t\t\t\tboard[0][Y] = board[3][Y];\n\t\t\t\tboard[3][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (X == x + 2)\n\t\t\t{ \/\/ Castling right:\n\t\t\t\tboard[7][Y] = board[5][Y];\n\t\t\t\tboard[5][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n\t\t{ \/\/ Undo en passant capture:\n\t\t\tboard[X][y] = Figure.pawn(!figure_moved.owner);\n\t\t}\n\t\tcastlings_allowed ^= Move.castling_changes(move);\n\t\tplayer = !player;\n\t\tturn--;\n\t\treturn move;\n\t}","code":"public int undo()\n\t{\n\t\tif (turn == 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tmoves_frame = moves[moves_frame + 1];\n\t\tfinal var move = moves[moves_frame + 2]\n\t\tmoves[moves_frame + 2] = 0;\n\t\n\t\n\t\tfinal var x = Move.x(move);\n\t\tfinal var y = Move.y(move);\n\t\tfinal var X = Move.X(move);\n\t\tfinal var Y = Move.Y(move);\n\t\tfinal var figure_moved = Move.figure_moved(move);\n\t\tfinal var figure_destination = Move.figure_destination(move);\n\t\tboard[x][y] = figure_moved;\n\t\tboard[X][Y] = figure_destination;\n\t\tif (figure_moved.is_king())\n\t\t{\n\t\t\tif (player)\n\t\t\t{\n\t\t\t\tking_x_b = x;\n\t\t\t\tking_y_b = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tking_x_w = x;\n\t\t\t\tking_y_w = y;\n\t\t\t}\n\t\t\tif (X == x - 2)\n\t\t\t{\n\t\t\t\tboard[0][Y] = board[3][Y];\n\t\t\t\tboard[3][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (X == x + 2)\n\t\t\t{\n\t\t\t\tboard[7][Y] = board[5][Y];\n\t\t\t\tboard[5][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n\t\t{\n\t\t\tboard[X][y] = Figure.pawn(!figure_moved.owner);\n\t\t}\n\t\tcastlings_allowed ^= Move.castling_changes(move);\n\t\tplayer = !player;\n\t\tturn--;\n\t\treturn move;\n\t}","cleancode":"public int undo() { if (turn == 1) { return 0; } moves_frame = moves[moves_frame + 1]; final var move = moves[moves_frame + 2] moves[moves_frame + 2] = 0; final var x = move.x(move); final var y = move.y(move); final var x = move.x(move); final var y = move.y(move); final var figure_moved = move.figure_moved(move); final var figure_destination = move.figure_destination(move); board[x][y] = figure_moved; board[x][y] = figure_destination; if (figure_moved.is_king()) { if (player) { king_x_b = x; king_y_b = y; } else { king_x_w = x; king_y_w = y; } if (x == x - 2) { board[0][y] = board[3][y]; board[3][y] = null; if (figure_moved.owner) { castling_done_w = false; } else { castling_done_b = false; } } else if (x == x + 2) { board[7][y] = board[5][y]; board[5][y] = null; if (figure_moved.owner) { castling_done_w = false; } else { castling_done_b = false; } } } else if (figure_moved.is_pawn() && x != x && figure_destination == null) { board[x][y] = figure.pawn(!figure_moved.owner); } castlings_allowed ^= move.castling_changes(move); player = !player; turn--; return move; }","comment":"\/\/ restore game history (pop current moves frame and reset selected move):\n\/\/ todo: fix when moves_selected contains index not move\n\/\/ restore cached current game situation (figure constellation, king positions, \/\/ castlings, active player and turn number):\n\/\/ castling left:\n\/\/ castling right:\n\/\/ undo en passant capture:","repo":"christoff-buerger\/pmChess","code_context_2":"return 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\n\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\n\n}\nif (X == x - 2)\n{ \/\/ Castling left:\nboard[0][Y] = board[3][Y];\nboard[3][Y] = null;\n\n}\nelse if (X == x + 2)\n{ \/\/ Castling right:\nboard[7][Y] = board[5][Y];\nboard[5][Y] = null;\n\n}\nelse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n{ \/\/ Undo en passant capture:\nboard[X][y] = Figure.pawn(!figure_moved.owner);\n}","code_context_10":"public int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\n\npublic int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\n\npublic int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\nboard[X][Y] = figure_destination;\nif (figure_moved.is_king())\n{\n\n{\nking_x_b = x;\nking_y_b = y;\n}\nelse\n{\nking_x_w = x;\nking_y_w = y;\n}\nif (X == x - 2)\n{ \/\/ Castling left:\nboard[0][Y] = board[3][Y];\nboard[3][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\nelse if (X == x + 2)\n{ \/\/ Castling right:\nboard[7][Y] = board[5][Y];\nboard[5][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\n}\nelse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n{ \/\/ Undo en passant capture:\nboard[X][y] = Figure.pawn(!figure_moved.owner);\n}\ncastlings_allowed ^= Move.castling_changes(move);\nplayer = !player;\nturn--;\nreturn move;\n}","code_context_20":"public int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\nboard[X][Y] = figure_destination;\nif (figure_moved.is_king())\n{\nif (player)\n{\nking_x_b = x;\nking_y_b = y;\n}\n\npublic int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\nboard[X][Y] = figure_destination;\nif (figure_moved.is_king())\n{\nif (player)\n{\nking_x_b = x;\nking_y_b = y;\n}\nelse\n{\n\npublic int undo()\n{\nif (turn == 1)\n{\nreturn 0;\n}\n\/\/ Restore game history (pop current moves frame and reset selected move):\nmoves_frame = moves[moves_frame + 1];\nfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\nmoves[moves_frame + 2] = 0;\n\/\/ Restore cached current game situation (figure constellation, king positions,\n\/\/ castlings, active player and turn number):\nfinal var x = Move.x(move);\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\nboard[X][Y] = figure_destination;\nif (figure_moved.is_king())\n{\nif (player)\n{\nking_x_b = x;\nking_y_b = y;\n}\nelse\n{\nking_x_w = x;\nking_y_w = y;\n}\n\nfinal var y = Move.y(move);\nfinal var X = Move.X(move);\nfinal var Y = Move.Y(move);\nfinal var figure_moved = Move.figure_moved(move);\nfinal var figure_destination = Move.figure_destination(move);\nboard[x][y] = figure_moved;\nboard[X][Y] = figure_destination;\nif (figure_moved.is_king())\n{\nif (player)\n{\nking_x_b = x;\nking_y_b = y;\n}\nelse\n{\nking_x_w = x;\nking_y_w = y;\n}\nif (X == x - 2)\n{ \/\/ Castling left:\nboard[0][Y] = board[3][Y];\nboard[3][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\nelse if (X == x + 2)\n{ \/\/ Castling right:\nboard[7][Y] = board[5][Y];\nboard[5][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n\n}\nelse\n{\nking_x_w = x;\nking_y_w = y;\n}\nif (X == x - 2)\n{ \/\/ Castling left:\nboard[0][Y] = board[3][Y];\nboard[3][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\nelse if (X == x + 2)\n{ \/\/ Castling right:\nboard[7][Y] = board[5][Y];\nboard[5][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\n}\nelse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n{ \/\/ Undo en passant capture:\nboard[X][y] = Figure.pawn(!figure_moved.owner);\n}\ncastlings_allowed ^= Move.castling_changes(move);\nplayer = !player;\nturn--;\nreturn move;\n\nelse\n{\ncastling_done_b = false;\n}\n}\nelse if (X == x + 2)\n{ \/\/ Castling right:\nboard[7][Y] = board[5][Y];\nboard[5][Y] = null;\nif (figure_moved.owner)\n{\ncastling_done_w = false;\n}\nelse\n{\ncastling_done_b = false;\n}\n}\n}\nelse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n{ \/\/ Undo en passant capture:\nboard[X][y] = Figure.pawn(!figure_moved.owner);\n}\ncastlings_allowed ^= Move.castling_changes(move);\nplayer = !player;\nturn--;\nreturn move;\n}","label":[1,0,0,0]}
{"id":34697,"original_code":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\n\tthrows InterruptedException {\n\tdriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\n\tAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\n\tint lastindex = -1;\n\tboolean emplidfound = false;\n\tboolean dataprocessed = false;\n\tfor (int i = 1; i <= 25; i++) {\n\t\tSystem.out.println(\"\\nIteration no.: \" + i);\n\t\tWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\n\t\tString keydata = key.getText();\n\t\tSystem.out.println(keydata);\n\t\tboolean result = keydata.contains(\"Key: \" + emplid);\n\t\tString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\n\t\tThread.sleep(5000);\n\t\tif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\n\t\t\templidfound = true;\n\t\t\tString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tSystem.out.println(status);\n\t\t\tboolean statusresult = status.equals(\"PROCESSED\");\n\t\t\tString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\n\t\t\tSystem.out.println(dataID);\n\t\t\t\/\/Validation if Data is processed\n\t\tif (statusresult == true) {\/\/ Validate if processed\n\t\t\tSystem.out.println(\"Data PROCESSED\");\n\t\t\tdataprocessed = true;\n\t\t\tlastindex = i;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tSystem.out.println(\"Data Not Yet Processed\");\n\t\t\tint count = 20;\n\t\t\tString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\n\t\t\tboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\n\t\t\tSystem.out.println(correctdataid);\/\/TODO to remove\n\t\t\twhile (count != 0 && statusresult == false) {\/\/ Loop for\n\t\t\t\/\/ processed\n\t\t\t\tif(correctdataid==true){\n\t\t\tSystem.out.println(\"Status check: \" + status);\n\t\t\tSystem.out.println(count);\n\t\t\tdriver.navigate().refresh();\n\t\t\tThread.sleep(15000);\n\t\t\tstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tstatusresult = status.equals(\"PROCESSED\");\n\t\t\tcount--;\n\t\t\t}else\n\t\t\t{\n\t\t\t\t\/\/TODO GO BACK TO CHECK EMPLID\n\t\t\t}\n\t\t\t}\t\t\n\t\tif(statusresult==true)\n\t\t{\n\t\t\tlastindex = i;\n\t\t\tdataprocessed = true;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t\t} else {\n\t\tSystem.out.println(\"Checking next data\");\n\t\t}\n\t}\n\t\tif(!emplidfound)\n\t\t{\n\t\t\tSystem.out.println(\"No data in Sync Monitor\");\n\t\t\tAssert.assertTrue(emplidfound);\n\t\t}\n\t\tif(dataprocessed)\n\t\t{\n\t\t\tThread.sleep(3000);\n\t\t\tWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\t\t\t\/\/ Get data content\n\t\t\tString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\t\t\t\/\/ Validate that content was correct\n\t\t\tboolean contenttypefound = dataBlock.contains(contenttype);\n\t\t\tboolean contentfound = dataBlock.contains(content);\n\t\t\tAssert.assertEquals(true, contenttypefound);\n\t\t\tAssert.assertEquals(true, contentfound);\n\t\t}else{\n\t\t\tSystem.out.println(\"Data was not processed in sync monitor\");\n\t\t\tAssert.assertTrue(dataprocessed);\n\t\t}\n\t\t}","code":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\n\tthrows InterruptedException {\n\tdriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\n\tAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\n\tint lastindex = -1;\n\tboolean emplidfound = false;\n\tboolean dataprocessed = false;\n\tfor (int i = 1; i <= 25; i++) {\n\t\tSystem.out.println(\"\\nIteration no.: \" + i);\n\t\tWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\n\t\tString keydata = key.getText();\n\t\tSystem.out.println(keydata);\n\t\tboolean result = keydata.contains(\"Key: \" + emplid);\n\t\tString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\n\t\tThread.sleep(5000);\n\t\tif (result == true && actualDirection.equals(direction)) {\n\t\t\templidfound = true;\n\t\t\tString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tSystem.out.println(status);\n\t\t\tboolean statusresult = status.equals(\"PROCESSED\");\n\t\t\tString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText()\n\t\t\tSystem.out.println(dataID);\n\t\t\n\t\tif (statusresult == true) \n\t\t\tSystem.out.println(\"Data PROCESSED\");\n\t\t\tdataprocessed = true;\n\t\t\tlastindex = i;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tSystem.out.println(\"Data Not Yet Processed\");\n\t\t\tint count = 20;\n\t\t\tString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText()\n\t\t\tboolean correctdataid = dataID.equals(dataIDafterrefresh)\n\t\t\tSystem.out.println(correctdataid)\n\t\t\twhile (count != 0 && statusresult == false) \n\t\t\n\t\t\t\tif(correctdataid==true){\n\t\t\tSystem.out.println(\"Status check: \" + status);\n\t\t\tSystem.out.println(count);\n\t\t\tdriver.navigate().refresh();\n\t\t\tThread.sleep(15000);\n\t\t\tstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tstatusresult = status.equals(\"PROCESSED\");\n\t\t\tcount--;\n\t\t\t}else\n\t\t\t{\n\t\t\t\n\t\t\t}\n\t\t\t}\t\t\n\t\tif(statusresult==true)\n\t\t{\n\t\t\tlastindex = i;\n\t\t\tdataprocessed = true;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t\t} else {\n\t\tSystem.out.println(\"Checking next data\");\n\t\t}\n\t}\n\t\tif(!emplidfound)\n\t\t{\n\t\t\tSystem.out.println(\"No data in Sync Monitor\");\n\t\t\tAssert.assertTrue(emplidfound);\n\t\t}\n\t\tif(dataprocessed)\n\t\t{\n\t\t\tThread.sleep(3000);\n\t\t\tWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\t\t\n\t\t\tString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\t\t\n\t\t\tboolean contenttypefound = dataBlock.contains(contenttype);\n\t\t\tboolean contentfound = dataBlock.contains(content);\n\t\t\tAssert.assertEquals(true, contenttypefound);\n\t\t\tAssert.assertEquals(true, contentfound);\n\t\t}else{\n\t\t\tSystem.out.println(\"Data was not processed in sync monitor\");\n\t\t\tAssert.assertTrue(dataprocessed);\n\t\t}\n\t\t}","cleancode":"public static void syncmonitordatavalidation(webdriver driver, string emplid, string contenttype, string content, testparameters testparameters, string direction) throws interruptedexception { driver.get(testparameters.murlmyinsead+testparameters.msyncmonitor); assert.assertequals(driver.gettitle(), \"myinsead - sync monitor\"); int lastindex = -1; boolean emplidfound = false; boolean dataprocessed = false; for (int i = 1; i <= 25; i++) { system.out.println(\"\\niteration no.: \" + i); webelement key = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\")); string keydata = key.gettext(); system.out.println(keydata); boolean result = keydata.contains(\"key: \" + emplid); string actualdirection = driver.findelement(by.xpath(\"\/\/*[@id='tblresult']\/tbody\/tr[\"+i+\"]\/td[3]\")).gettext().trim(); thread.sleep(5000); if (result == true && actualdirection.equals(direction)) { emplidfound = true; string status = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).gettext(); system.out.println(status); boolean statusresult = status.equals(\"processed\"); string dataid = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).gettext() system.out.println(dataid); if (statusresult == true) system.out.println(\"data processed\"); dataprocessed = true; lastindex = i; break; } else { system.out.println(\"data not yet processed\"); int count = 20; string dataidafterrefresh = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).gettext() boolean correctdataid = dataid.equals(dataidafterrefresh) system.out.println(correctdataid) while (count != 0 && statusresult == false) if(correctdataid==true){ system.out.println(\"status check: \" + status); system.out.println(count); driver.navigate().refresh(); thread.sleep(15000); status = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).gettext(); statusresult = status.equals(\"processed\"); count--; }else { } } if(statusresult==true) { lastindex = i; dataprocessed = true; break; } } break; } else { system.out.println(\"checking next data\"); } } if(!emplidfound) { system.out.println(\"no data in sync monitor\"); assert.asserttrue(emplidfound); } if(dataprocessed) { thread.sleep(3000); webelement button = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\")); string datablock = button.getattribute(\"data-content\").replaceall(\"\\\\s+\", \"\"); boolean contenttypefound = datablock.contains(contenttype); boolean contentfound = datablock.contains(content); assert.assertequals(true, contenttypefound); assert.assertequals(true, contentfound); }else{ system.out.println(\"data was not processed in sync monitor\"); assert.asserttrue(dataprocessed); } }","comment":"\/\/------------------------------------------------------------------------------------------------------------- \/\/ validate sync monitor content\n\/\/ validate if emplid is in the key\n\/\/todo get the data id\n\/\/validation if data is processed\n\/\/ validate if processed\n\/\/todo to remove\n\/\/todo to remove\n\/\/todo to remove\n\/\/ loop for\n\/\/ processed\n\/\/todo go back to check emplid\n\/\/ get data content\n\/\/ validate that content was correct","repo":"aurelienartus\/testproject","code_context_2":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\nthrows InterruptedException {\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}\n\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\n\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\n\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\n\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\n\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\n\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\n\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\n\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\n\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\n\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\n\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);","code_context_10":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\nthrows InterruptedException {\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}\n\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\n\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\n\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\n\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\n\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}","code_context_20":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\nthrows InterruptedException {\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}\n\npublic static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\nthrows InterruptedException {\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\n\npublic static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\nthrows InterruptedException {\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\n\ndriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\n\nAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\nint lastindex = -1;\nboolean emplidfound = false;\nboolean dataprocessed = false;\nfor (int i = 1; i <= 25; i++) {\nSystem.out.println(\"\\nIteration no.: \" + i);\nWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\nString keydata = key.getText();\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\n\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\n\nSystem.out.println(keydata);\nboolean result = keydata.contains(\"Key: \" + emplid);\nString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\n\nThread.sleep(5000);\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n\nif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\nemplidfound = true;\nString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nSystem.out.println(status);\nboolean statusresult = status.equals(\"PROCESSED\");\nString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\nSystem.out.println(dataID);\n\/\/Validation if Data is processed\nif (statusresult == true) {\/\/ Validate if processed\nSystem.out.println(\"Data PROCESSED\");\ndataprocessed = true;\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\n\nlastindex = i;\nbreak;\n} else {\nSystem.out.println(\"Data Not Yet Processed\");\nint count = 20;\nString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\nboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\nSystem.out.println(correctdataid);\/\/TODO to remove\nwhile (count != 0 && statusresult == false) {\/\/ Loop for\n\/\/ processed\nif(correctdataid==true){\nSystem.out.println(\"Status check: \" + status);\nSystem.out.println(count);\ndriver.navigate().refresh();\nThread.sleep(15000);\nstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\nstatusresult = status.equals(\"PROCESSED\");\ncount--;\n}else\n{\n\/\/TODO GO BACK TO CHECK EMPLID\n}\n}\nif(statusresult==true)\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n\n{\nlastindex = i;\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}\n\ndataprocessed = true;\nbreak;\n}\n}\nbreak;\n} else {\nSystem.out.println(\"Checking next data\");\n}\n}\nif(!emplidfound)\n{\nSystem.out.println(\"No data in Sync Monitor\");\nAssert.assertTrue(emplidfound);\n}\nif(dataprocessed)\n{\nThread.sleep(3000);\nWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\/\/ Get data content\nString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\/\/ Validate that content was correct\nboolean contenttypefound = dataBlock.contains(contenttype);\nboolean contentfound = dataBlock.contains(content);\nAssert.assertEquals(true, contenttypefound);\nAssert.assertEquals(true, contentfound);\n}else{\nSystem.out.println(\"Data was not processed in sync monitor\");\nAssert.assertTrue(dataprocessed);\n}\n}","label":[1,0,0,0]}
{"id":1954,"original_code":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        Security security = (Security)request.getAttribute(\"security\");\n        GenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\n        ServletContext servletContext = session.getServletContext();\n        String webSiteId = WebSiteWorker.getWebSiteId(request);\n        Delegator delegator = (Delegator)request.getAttribute(\"delegator\");\n        LocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\n        Map<String, Object> paramMap = UtilHttp.getParameterMap(request);\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\n        String targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\n        String roles = null;\n        String authorId = null;\n        GenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\n        if (authorContent != null) {\n            authorId = authorContent.getString(\"contentId\");\n        } else {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\n            return \"error\";\n        }\n        \/\/ Determine if user is owner of target content\n        String userLoginId = userLogin.getString(\"userLoginId\");\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\n        List<String> roleTypeList = null;\n        if (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\n            roles = \"OWNER\";\n            roleTypeList = StringUtil.split(roles, \"|\");\n        }\n        List<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\n        List<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n        String permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\n        String permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\n        if (UtilValidate.isEmpty(targContentId)) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\n            return \"error\";\n        }\n        \/\/ Get all the subSites that the user is permitted to link to\n        List<Object []> origPublishedLinkList = null;\n        try {\n            \/\/ TODO: this needs to be given author userLogin\n            EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\n            origPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n        } catch (GenericEntityException e) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n            return \"error\";\n        } catch (GeneralException e2) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n            return \"error\";\n        }\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n        \/\/ make a map of the values that are passed in using the top subSite as the key.\n        \/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\n        Map<String, String> siteIdLookup = new HashMap<String, String>();\n        for (String param : paramMap.keySet()) {\n            int pos = param.indexOf(\"select_\");\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\n            if (pos >= 0) {\n                String siteId = param.substring(7);\n                String subSiteVal = (String)paramMap.get(param);\n                siteIdLookup.put(siteId, subSiteVal);\n            }\n        }\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n        \/\/ Loop thru all the possible subsites\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \/\/ int counter = 0;\n        String responseMessage = null;\n        String errorMessage = null;\n        \/\/ String permissionMessage = null;\n        boolean statusIdUpdated = false;\n        Map<String, Object> results = null;\n        for (Object [] arr : origPublishedLinkList) {\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\n            String contentId = (String)arr[0]; \/\/ main (2nd level) site id\n            String origSubContentId = null;\n            List<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n            \/\/ Timestamp topFromDate = (Timestamp)arr[3];\n            Timestamp origFromDate = null;\n            for (Object [] pubArr : origSubList) {\n            \/\/ see if a link already exists by looking for non-null fromDate\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\n                Timestamp fromDate = (Timestamp)pubArr[2];\n                origSubContentId = null;\n                if (fromDate != null) {\n                    origSubContentId = (String)pubArr[0];\n                    origFromDate = fromDate;\n                    break;\n                }\n            }\n            String currentSubContentId = siteIdLookup.get(contentId);\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\n            try {\n                if (UtilValidate.isNotEmpty(currentSubContentId)) {\n                    if (!currentSubContentId.equals(origSubContentId)) {\n                        \/\/ disable existing link\n                        if (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\n                            List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                                    .where(\"contentId\", targContentId, \n                                            \"contentIdTo\", origSubContentId, \n                                            \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                            \"thruDate\", null)\n                                    .queryList();\n                            for (GenericValue cAssoc : oldActiveValues) {\n                                cAssoc.set(\"thruDate\", nowTimestamp);\n                                cAssoc.store();\n                                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n                            }\n                        }\n                        \/\/ create new link\n                        Map<String, Object> serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", currentSubContentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        responseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\n                        if (UtilValidate.isNotEmpty(responseMessage)) {\n                            errorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\n                            Debug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\n                            Debug.logError(errorMessage, module);\n                            request.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\n                            return \"error\";\n                        }\n                        serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", contentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\n                        if (!statusIdUpdated) {\n                            try {\n                                GenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\n                                targContent.set(\"statusId\", \"CTNT_PUBLISHED\");\n                                targContent.store();\n                                statusIdUpdated = true;\n                            } catch (GenericEntityException e) {\n                                Debug.logError(e.getMessage(), module);\n                                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                                return \"error\";\n                            }\n                        }\n                    }\n                } else if (UtilValidate.isNotEmpty(origSubContentId)) {\n                    \/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\n                    List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                            .where(\"contentId\", targContentId, \n                                    \"contentIdTo\", origSubContentId, \n                                    \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                    \"thruDate\", null)\n                            .queryList();\n                    for (GenericValue cAssoc : oldActiveValues) {\n                        cAssoc.set(\"thruDate\", nowTimestamp);\n                        cAssoc.store();\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logError(e.getMessage(), module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                return \"error\";\n            } catch (GenericServiceException e2) {\n                Debug.logError(e2, module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n                return \"error\";\n            }\n        }\n        return \"success\";\n    }","code":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        Security security = (Security)request.getAttribute(\"security\");\n        GenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\n        ServletContext servletContext = session.getServletContext();\n        String webSiteId = WebSiteWorker.getWebSiteId(request);\n        Delegator delegator = (Delegator)request.getAttribute(\"delegator\");\n        LocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\n        Map<String, Object> paramMap = UtilHttp.getParameterMap(request);\n       \n        String targContentId = (String)paramMap.get(\"contentId\");\n        String roles = null;\n        String authorId = null;\n        GenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\n        if (authorContent != null) {\n            authorId = authorContent.getString(\"contentId\");\n        } else {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\n            return \"error\";\n        }\n       \n        String userLoginId = userLogin.getString(\"userLoginId\");\n       \n        List<String> roleTypeList = null;\n        if (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\n            roles = \"OWNER\";\n            roleTypeList = StringUtil.split(roles, \"|\");\n        }\n        List<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\n        List<String> contentPurposeList = null;\n       \n        String permittedAction = (String)paramMap.get(\"permittedAction\");\n        String permittedOperations = (String)paramMap.get(\"permittedOperations\");\n        if (UtilValidate.isEmpty(targContentId)) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\n            return \"error\";\n        }\n       \n        List<Object []> origPublishedLinkList = null;\n        try {\n           \n            EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\n            origPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n        } catch (GenericEntityException e) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n            return \"error\";\n        } catch (GeneralException e2) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n            return \"error\";\n        }\n               \n       \n       \n        Map<String, String> siteIdLookup = new HashMap<String, String>();\n        for (String param : paramMap.keySet()) {\n            int pos = param.indexOf(\"select_\");\n               \n            if (pos >= 0) {\n                String siteId = param.substring(7);\n                String subSiteVal = (String)paramMap.get(param);\n                siteIdLookup.put(siteId, subSiteVal);\n            }\n        }\n       \n       \n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n       \n        String responseMessage = null;\n        String errorMessage = null;\n       \n        boolean statusIdUpdated = false;\n        Map<String, Object> results = null;\n        for (Object [] arr : origPublishedLinkList) {\n           \n            String contentId = (String)arr[0];\n            String origSubContentId = null;\n            List<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n           \n            Timestamp origFromDate = null;\n            for (Object [] pubArr : origSubList) {\n           \n               \n                Timestamp fromDate = (Timestamp)pubArr[2];\n                origSubContentId = null;\n                if (fromDate != null) {\n                    origSubContentId = (String)pubArr[0];\n                    origFromDate = fromDate;\n                    break;\n                }\n            }\n            String currentSubContentId = siteIdLookup.get(contentId);\n           \n           \n            try {\n                if (UtilValidate.isNotEmpty(currentSubContentId)) {\n                    if (!currentSubContentId.equals(origSubContentId)) {\n                       \n                        if (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\n                            List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                                    .where(\"contentId\", targContentId, \n                                            \"contentIdTo\", origSubContentId, \n                                            \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                            \"thruDate\", null)\n                                    .queryList();\n                            for (GenericValue cAssoc : oldActiveValues) {\n                                cAssoc.set(\"thruDate\", nowTimestamp);\n                                cAssoc.store();\n                               \n                            }\n                        }\n                       \n                        Map<String, Object> serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", currentSubContentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        responseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\n                        if (UtilValidate.isNotEmpty(responseMessage)) {\n                            errorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\n                            Debug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\n                            Debug.logError(errorMessage, module);\n                            request.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\n                            return \"error\";\n                        }\n                        serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", contentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                       \n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                       \n                        if (!statusIdUpdated) {\n                            try {\n                                GenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\n                                targContent.set(\"statusId\", \"CTNT_PUBLISHED\");\n                                targContent.store();\n                                statusIdUpdated = true;\n                            } catch (GenericEntityException e) {\n                                Debug.logError(e.getMessage(), module);\n                                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                                return \"error\";\n                            }\n                        }\n                    }\n                } else if (UtilValidate.isNotEmpty(origSubContentId)) {\n                   \n                    List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                            .where(\"contentId\", targContentId, \n                                    \"contentIdTo\", origSubContentId, \n                                    \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                    \"thruDate\", null)\n                            .queryList();\n                    for (GenericValue cAssoc : oldActiveValues) {\n                        cAssoc.set(\"thruDate\", nowTimestamp);\n                        cAssoc.store();\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logError(e.getMessage(), module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                return \"error\";\n            } catch (GenericServiceException e2) {\n                Debug.logError(e2, module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n                return \"error\";\n            }\n        }\n        return \"success\";\n    }","cleancode":"public static string updatepublishlinks(httpservletrequest request, httpservletresponse response) { httpsession session = request.getsession(); security security = (security)request.getattribute(\"security\"); genericvalue userlogin = (genericvalue)session.getattribute(\"userlogin\"); servletcontext servletcontext = session.getservletcontext(); string websiteid = websiteworker.getwebsiteid(request); delegator delegator = (delegator)request.getattribute(\"delegator\"); localdispatcher dispatcher = (localdispatcher)request.getattribute(\"dispatcher\"); map<string, object> parammap = utilhttp.getparametermap(request); string targcontentid = (string)parammap.get(\"contentid\"); string roles = null; string authorid = null; genericvalue authorcontent = contentmanagementworker.getauthorcontent(delegator, targcontentid); if (authorcontent != null) { authorid = authorcontent.getstring(\"contentid\"); } else { request.setattribute(\"_error_message_\", \"authorcontent is empty.\"); return \"error\"; } string userloginid = userlogin.getstring(\"userloginid\"); list<string> roletypelist = null; if (authorid != null && userloginid != null && authorid.equals(userloginid)) { roles = \"owner\"; roletypelist = stringutil.split(roles, \"|\"); } list<string> targetoperationlist = utilmisc.<string>tolist(\"content_publish\"); list<string> contentpurposelist = null; string permittedaction = (string)parammap.get(\"permittedaction\"); string permittedoperations = (string)parammap.get(\"permittedoperations\"); if (utilvalidate.isempty(targcontentid)) { request.setattribute(\"_error_message_\", \"targcontentid is empty.\"); return \"error\"; } list<object []> origpublishedlinklist = null; try { entityquery.use(delegator).from(\"userlogin\").where(\"userloginid\", authorid).cache().queryone(); origpublishedlinklist = contentmanagementworker.getpublishedlinks(delegator, targcontentid, websiteid, userlogin, security, permittedaction, permittedoperations, roles); } catch (genericentityexception e) { request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } catch (generalexception e2) { request.setattribute(\"_error_message_\", e2.getmessage()); return \"error\"; } map<string, string> siteidlookup = new hashmap<string, string>(); for (string param : parammap.keyset()) { int pos = param.indexof(\"select_\"); if (pos >= 0) { string siteid = param.substring(7); string subsiteval = (string)parammap.get(param); siteidlookup.put(siteid, subsiteval); } } timestamp nowtimestamp = utildatetime.nowtimestamp(); string responsemessage = null; string errormessage = null; boolean statusidupdated = false; map<string, object> results = null; for (object [] arr : origpublishedlinklist) { string contentid = (string)arr[0]; string origsubcontentid = null; list<object []> origsublist = utilgenerics.checklist(arr[1]); timestamp origfromdate = null; for (object [] pubarr : origsublist) { timestamp fromdate = (timestamp)pubarr[2]; origsubcontentid = null; if (fromdate != null) { origsubcontentid = (string)pubarr[0]; origfromdate = fromdate; break; } } string currentsubcontentid = siteidlookup.get(contentid); try { if (utilvalidate.isnotempty(currentsubcontentid)) { if (!currentsubcontentid.equals(origsubcontentid)) { if (utilvalidate.isnotempty(origsubcontentid) && origfromdate != null) { list<genericvalue> oldactivevalues = entityquery.use(delegator).from(\"contentassoc\") .where(\"contentid\", targcontentid, \"contentidto\", origsubcontentid, \"contentassoctypeid\", \"publish_link\", \"thrudate\", null) .querylist(); for (genericvalue cassoc : oldactivevalues) { cassoc.set(\"thrudate\", nowtimestamp); cassoc.store(); } } map<string, object> servicein = new hashmap<string, object>(); servicein.put(\"userlogin\", userlogin); servicein.put(\"contentid\", targcontentid); servicein.put(\"contentassoctypeid\", \"publish_link\"); servicein.put(\"fromdate\", nowtimestamp); servicein.put(\"contentidto\", currentsubcontentid); servicein.put(\"roletypelist\", roletypelist); servicein.put(\"targetoperationlist\", targetoperationlist); servicein.put(\"contentpurposelist\", contentpurposelist); results = dispatcher.runsync(\"createcontentassoc\", servicein); responsemessage = (string)results.get(modelservice.response_message); if (utilvalidate.isnotempty(responsemessage)) { errormessage = (string)results.get(modelservice.error_message); debug.logerror(\"in updatepublishlinks, servicein:\" + servicein , module); debug.logerror(errormessage, module); request.setattribute(\"_error_message_\", errormessage); return \"error\"; } servicein = new hashmap<string, object>(); servicein.put(\"userlogin\", userlogin); servicein.put(\"contentid\", targcontentid); servicein.put(\"contentassoctypeid\", \"publish_link\"); servicein.put(\"fromdate\", nowtimestamp); servicein.put(\"contentidto\", contentid); servicein.put(\"roletypelist\", roletypelist); servicein.put(\"targetoperationlist\", targetoperationlist); servicein.put(\"contentpurposelist\", contentpurposelist); results = dispatcher.runsync(\"createcontentassoc\", servicein); if (!statusidupdated) { try { genericvalue targcontent = entityquery.use(delegator).from(\"content\").where(\"contentid\", targcontentid).queryone(); targcontent.set(\"statusid\", \"ctnt_published\"); targcontent.store(); statusidupdated = true; } catch (genericentityexception e) { debug.logerror(e.getmessage(), module); request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } } } } else if (utilvalidate.isnotempty(origsubcontentid)) { list<genericvalue> oldactivevalues = entityquery.use(delegator).from(\"contentassoc\") .where(\"contentid\", targcontentid, \"contentidto\", origsubcontentid, \"contentassoctypeid\", \"publish_link\", \"thrudate\", null) .querylist(); for (genericvalue cassoc : oldactivevalues) { cassoc.set(\"thrudate\", nowtimestamp); cassoc.store(); } } } catch (genericentityexception e) { debug.logerror(e.getmessage(), module); request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } catch (genericserviceexception e2) { debug.logerror(e2, module); request.setattribute(\"_error_message_\", e2.getmessage()); return \"error\"; } } return \"success\"; }","comment":"\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, parammap:\" + parammap , module);\n\/\/ the content to be linked to one or more sites\n\/\/ determine if user is owner of target content\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, userloginid:\" + userloginid + \" authorid:\" + authorid , module);\n\/\/utilmisc.tolist(\"article\");\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, roles:\" + roles +\" roletypelist:\" + roletypelist , module);\n\/\/ the content to be linked to one or more sites\n\/\/ the content to be linked to one or more sites\n\/\/ get all the subsites that the user is permitted to link to\n\/\/ todo: this needs to be given author userlogin\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, origpublishedlinklist:\" + origpublishedlinklist , module); \/\/ make a map of the values that are passed in using the top subsite as the key. \/\/ content can only be linked to one subsite under a top site (ends with \"_master\")\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, param:\" + param + \" pos:\" + pos , module);\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, siteidlookup:\" + siteidlookup , module); \/\/ loop thru all the possible subsites\n\/\/ int counter = 0;\n\/\/ string permissionmessage = null;\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, arr:\" + arrays.aslist(arr) , module);\n\/\/ main (2nd level) site id\n\/\/ timestamp topfromdate = (timestamp)arr[3];\n\/\/ see if a link already exists by looking for non-null fromdate \/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, pubarr:\" + arrays.aslist(pubarr) , module);\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, currentsubcontentid:\" + currentsubcontentid , module); \/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, origsubcontentid:\" + origsubcontentid , module);\n\/\/ disable existing link\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, deactivating:\" + cassoc , module);\n\/\/ create new link\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, servicein(3b):\" + servicein , module);\n\/\/if (debug.infoon()) debug.loginfo(\"in updatepublishlinks, results(3b):\" + results , module);\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled","repo":"atb\/ofbiz","code_context_2":"LocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\n\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\n\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\n\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\n\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\n\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\n\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\n\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\n\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\n\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\n\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\n\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\n\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\n\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\n\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\n\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\n\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\n\n}\n} else if (UtilValidate.isNotEmpty(origSubContentId)) {\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,","code_context_10":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\n\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\n\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\n\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\n\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\n\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\n\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", currentSubContentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\n\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", currentSubContentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\n}\nserviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", contentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\nGenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\ntargContent.set(\"statusId\", \"CTNT_PUBLISHED\");\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\n\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", contentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\nGenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\ntargContent.set(\"statusId\", \"CTNT_PUBLISHED\");\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n}\n}\n}\n} else if (UtilValidate.isNotEmpty(origSubContentId)) {\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n}","code_context_20":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\n\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n\npublic static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\nHttpSession session = request.getSession();\nSecurity security = (Security)request.getAttribute(\"security\");\nGenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\nServletContext servletContext = session.getServletContext();\nString webSiteId = WebSiteWorker.getWebSiteId(request);\nDelegator delegator = (Delegator)request.getAttribute(\"delegator\");\nLocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\nMap<String, Object> paramMap = UtilHttp.getParameterMap(request);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\nString targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\nString roles = null;\nString authorId = null;\nGenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\nif (authorContent != null) {\nauthorId = authorContent.getString(\"contentId\");\n} else {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\nreturn \"error\";\n}\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\n\n\/\/ Determine if user is owner of target content\nString userLoginId = userLogin.getString(\"userLoginId\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\nList<String> roleTypeList = null;\nif (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\nroles = \"OWNER\";\nroleTypeList = StringUtil.split(roles, \"|\");\n}\nList<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\nList<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\nString permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\nString permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\nif (UtilValidate.isEmpty(targContentId)) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\nreturn \"error\";\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\n}\n\/\/ Get all the subSites that the user is permitted to link to\nList<Object []> origPublishedLinkList = null;\ntry {\n\/\/ TODO: this needs to be given author userLogin\nEntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\norigPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\n} catch (GenericEntityException e) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\n\n} catch (GeneralException e2) {\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\n\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n\/\/ make a map of the values that are passed in using the top subSite as the key.\n\/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\n\nMap<String, String> siteIdLookup = new HashMap<String, String>();\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\n\nfor (String param : paramMap.keySet()) {\nint pos = param.indexOf(\"select_\");\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\n\nif (pos >= 0) {\nString siteId = param.substring(7);\nString subSiteVal = (String)paramMap.get(param);\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\n\nsiteIdLookup.put(siteId, subSiteVal);\n}\n}\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n\/\/ Loop thru all the possible subsites\nTimestamp nowTimestamp = UtilDateTime.nowTimestamp();\n\/\/ int counter = 0;\nString responseMessage = null;\nString errorMessage = null;\n\/\/ String permissionMessage = null;\nboolean statusIdUpdated = false;\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\nMap<String, Object> results = null;\nfor (Object [] arr : origPublishedLinkList) {\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\nString contentId = (String)arr[0]; \/\/ main (2nd level) site id\nString origSubContentId = null;\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\n\nList<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n\/\/ Timestamp topFromDate = (Timestamp)arr[3];\nTimestamp origFromDate = null;\nfor (Object [] pubArr : origSubList) {\n\/\/ see if a link already exists by looking for non-null fromDate\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\nTimestamp fromDate = (Timestamp)pubArr[2];\norigSubContentId = null;\nif (fromDate != null) {\norigSubContentId = (String)pubArr[0];\norigFromDate = fromDate;\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", currentSubContentId);\n\nbreak;\n}\n}\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", currentSubContentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\nresponseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\nif (UtilValidate.isNotEmpty(responseMessage)) {\nerrorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\nDebug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\nDebug.logError(errorMessage, module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\nreturn \"error\";\n\nString currentSubContentId = siteIdLookup.get(contentId);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\ntry {\nif (UtilValidate.isNotEmpty(currentSubContentId)) {\nif (!currentSubContentId.equals(origSubContentId)) {\n\/\/ disable existing link\nif (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n}\n}\n\/\/ create new link\nMap<String, Object> serviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", currentSubContentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\nresponseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\nif (UtilValidate.isNotEmpty(responseMessage)) {\nerrorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\nDebug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\nDebug.logError(errorMessage, module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\nreturn \"error\";\n}\nserviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\n\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\nresponseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\nif (UtilValidate.isNotEmpty(responseMessage)) {\nerrorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\nDebug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\nDebug.logError(errorMessage, module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\nreturn \"error\";\n}\nserviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", contentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\nGenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\ntargContent.set(\"statusId\", \"CTNT_PUBLISHED\");\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n}\n}\n}\n} else if (UtilValidate.isNotEmpty(origSubContentId)) {\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\nresponseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\nif (UtilValidate.isNotEmpty(responseMessage)) {\nerrorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\nDebug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\nDebug.logError(errorMessage, module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\nreturn \"error\";\n}\nserviceIn = new HashMap<String, Object>();\nserviceIn.put(\"userLogin\", userLogin);\nserviceIn.put(\"contentId\", targContentId);\nserviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\nserviceIn.put(\"fromDate\", nowTimestamp);\nserviceIn.put(\"contentIdTo\", contentId);\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\nGenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\ntargContent.set(\"statusId\", \"CTNT_PUBLISHED\");\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n}\n}\n}\n} else if (UtilValidate.isNotEmpty(origSubContentId)) {\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n\nserviceIn.put(\"roleTypeList\", roleTypeList);\nserviceIn.put(\"targetOperationList\", targetOperationList);\nserviceIn.put(\"contentPurposeList\", contentPurposeList);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\nresults = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n\/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\nif (!statusIdUpdated) {\ntry {\nGenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\ntargContent.set(\"statusId\", \"CTNT_PUBLISHED\");\ntargContent.store();\nstatusIdUpdated = true;\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n}\n}\n}\n} else if (UtilValidate.isNotEmpty(origSubContentId)) {\n\/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\nList<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n.where(\"contentId\", targContentId,\n\"contentIdTo\", origSubContentId,\n\"contentAssocTypeId\", \"PUBLISH_LINK\",\n\"thruDate\", null)\n.queryList();\nfor (GenericValue cAssoc : oldActiveValues) {\ncAssoc.set(\"thruDate\", nowTimestamp);\ncAssoc.store();\n}\n}\n} catch (GenericEntityException e) {\nDebug.logError(e.getMessage(), module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\nreturn \"error\";\n} catch (GenericServiceException e2) {\nDebug.logError(e2, module);\nrequest.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\nreturn \"error\";\n}","label":[1,0,0,0]}
{"id":1998,"original_code":"public boolean storedRSVs(String operator) {\n        return true;\n    }","code":"public boolean storedRSVs(String operator) {\n        return true;\n    }","cleancode":"public boolean storedrsvs(string operator) { return true; }","comment":"\/** * tests whether the rsvs are already stored in the <code>weight<\/code> * table, or if they are computed from outside. * <p> * <p> * the default implemenation returns <code>true<\/code>. * <p> * todo: really useful? * * @param operator search operator * @return true, if the rsvs are already stored *\/","repo":"automenta\/java-unidu-pire","code_context_2":"public boolean storedRSVs(String operator) {\nreturn true;\n}","code_context_10":"public boolean storedRSVs(String operator) {\nreturn true;\n}","code_context_20":"public boolean storedRSVs(String operator) {\nreturn true;\n}","label":[1,0,0,0]}
{"id":34787,"original_code":"@NotNull\n    @Override\n    public UserReference toReference(@NotNull RedditClient reddit) {\n        return reddit.user(getName());\n    }","code":"@NotNull\n    @Override\n    public UserReference toReference(@NotNull RedditClient reddit) {\n        return reddit.user(getName());\n    }","cleancode":"@notnull @override public userreference toreference(@notnull redditclient reddit) { return reddit.user(getname()); }","comment":"\/\/ todo: a lot more properties for logged-in users (see \/api\/v1\/me)","repo":"andsala\/JRAW","code_context_2":"@NotNull\n@Override\npublic UserReference toReference(@NotNull RedditClient reddit) {\nreturn reddit.user(getName());\n}","code_context_10":"@NotNull\n@Override\npublic UserReference toReference(@NotNull RedditClient reddit) {\nreturn reddit.user(getName());\n}","code_context_20":"@NotNull\n@Override\npublic UserReference toReference(@NotNull RedditClient reddit) {\nreturn reddit.user(getName());\n}","label":[1,0,0,0]}
{"id":34902,"original_code":"public static int[] parseJavaVersion(final String jdkVer) {\n    final int p0, p1;\n    try {\n      String[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\n      parts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\n      p0 = Integer.parseInt(parts[0]); \/\/the first number group\n      p1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n    } catch (final NumberFormatException | ArrayIndexOutOfBoundsException  e) {\n      throw new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n    }\n    \/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\n    return new int[] {p0, p1};\n  }","code":"public static int[] parseJavaVersion(final String jdkVer) {\n    final int p0, p1;\n    try {\n      String[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\")\n      parts = parts[0].split(\"\\\\.\");\n      p0 = Integer.parseInt(parts[0]);\n      p1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0;\n    } catch (final NumberFormatException | ArrayIndexOutOfBoundsException  e) {\n      throw new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n    }\n   \n    return new int[] {p0, p1};\n  }","cleancode":"public static int[] parsejavaversion(final string jdkver) { final int p0, p1; try { string[] parts = jdkver.trim().split(\"[^0-9\\\\.]\") parts = parts[0].split(\"\\\\.\"); p0 = integer.parseint(parts[0]); p1 = (parts.length > 1) ? integer.parseint(parts[1]) : 0; } catch (final numberformatexception | arrayindexoutofboundsexception e) { throw new illegalargumentexception(\"improper java -version string: \" + jdkver + \"\\n\" + e); } return new int[] {p0, p1}; }","comment":"\/** * returns first two number groups of the java version string. * @param jdkver the java version string from system.getproperty(\"java.version\"). * @return first two number groups of the java version string. *\/\n\/\/grab only number groups and \".\"\n\/\/split out the number groups\n\/\/the first number group\n\/\/2nd number group, or 0\n\/\/checkjavaversion(jdkver, p0, p1); \/\/todo optional to omit this.","repo":"apache\/incubator-datasketches-memory","code_context_2":"public static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\n\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\n\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}","code_context_10":"public static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}","code_context_20":"public static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}\n\npublic static int[] parseJavaVersion(final String jdkVer) {\nfinal int p0, p1;\ntry {\nString[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\nparts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\np0 = Integer.parseInt(parts[0]); \/\/the first number group\np1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n} catch (final NumberFormatException | ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n}\n\/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\nreturn new int[] {p0, p1};\n}","label":[1,0,0,0]}
{"id":34920,"original_code":"@Deprecated\n    public static float getScreenPixelRatio() {\n        \/\/TODO replace with API from Java 9 once that is released\n        if (Platform.isMac()) {\n            Toolkit toolkit = Toolkit.getDefaultToolkit();\n            Object contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\n            if (contentScaleFactor instanceof Number) {\n                return ((Number) contentScaleFactor).floatValue();\n            } else {\n                return 1.0f;\n            }\n        } else {\n            return 1.0f;\n        }\n    }","code":"@Deprecated\n    public static float getScreenPixelRatio() {\n       \n        if (Platform.isMac()) {\n            Toolkit toolkit = Toolkit.getDefaultToolkit();\n            Object contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\n            if (contentScaleFactor instanceof Number) {\n                return ((Number) contentScaleFactor).floatValue();\n            } else {\n                return 1.0f;\n            }\n        } else {\n            return 1.0f;\n        }\n    }","cleancode":"@deprecated public static float getscreenpixelratio() { if (platform.ismac()) { toolkit toolkit = toolkit.getdefaulttoolkit(); object contentscalefactor = toolkit.getdesktopproperty(\"apple.awt.contentscalefactor\"); if (contentscalefactor instanceof number) { return ((number) contentscalefactor).floatvalue(); } else { return 1.0f; } } else { return 1.0f; } }","comment":"\/** * returns the \"device pixel ratio\" for the current display. a return value * higher than 1.0 indicates a \"retina\" or \"hidpi\" screen. * @deprecated this method relies on apple-specific awt properties, which * remain from the old apple jdk but will be removed from the * jdk in java 9. *\/\n\/\/todo replace with api from java 9 once that is released","repo":"colorizenl\/colorize-java-commons","code_context_2":"@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();\nObject contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\nif (contentScaleFactor instanceof Number) {\nreturn ((Number) contentScaleFactor).floatValue();\n} else {\nreturn 1.0f;\n}\n} else {\nreturn 1.0f;\n}\n}\n\n@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();","code_context_10":"@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();\nObject contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\nif (contentScaleFactor instanceof Number) {\nreturn ((Number) contentScaleFactor).floatValue();\n} else {\nreturn 1.0f;\n}\n} else {\nreturn 1.0f;\n}\n}\n\n@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();\nObject contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\nif (contentScaleFactor instanceof Number) {\nreturn ((Number) contentScaleFactor).floatValue();\n} else {\nreturn 1.0f;\n}\n} else {\nreturn 1.0f;","code_context_20":"@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();\nObject contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\nif (contentScaleFactor instanceof Number) {\nreturn ((Number) contentScaleFactor).floatValue();\n} else {\nreturn 1.0f;\n}\n} else {\nreturn 1.0f;\n}\n}\n\n@Deprecated\npublic static float getScreenPixelRatio() {\n\/\/TODO replace with API from Java 9 once that is released\nif (Platform.isMac()) {\nToolkit toolkit = Toolkit.getDefaultToolkit();\nObject contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\nif (contentScaleFactor instanceof Number) {\nreturn ((Number) contentScaleFactor).floatValue();\n} else {\nreturn 1.0f;\n}\n} else {\nreturn 1.0f;\n}\n}","label":[1,0,0,0]}
{"id":10429,"original_code":"@Override\n    public Object onExecute(ExecutionEvent event) throws ExecutionException {\n        project = PluginUtil.getSelectedProject();\n        try {\n            if (project == null) {\n                throw new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n            }\n            basePath = project.getLocation().toString();\n            if (MavenUtils.isMavenProject(project)) {\n                destinationPath = MavenUtils.getTargetPath(project);\n            } else {\n                destinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n                        .normalize().toString();\n            }\n            \/\/ Stop running container\n            String runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\n            if (runningContainerId != null) {\n                boolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\n                        Constant.MESSAGE_CONFIRM_STOP_CONTAINER);\n                if (stop) {\n                    DockerRuntime.getInstance().cleanRuningContainer(basePath);\n                } else {\n                    return null;\n                }\n            }\n            \/\/ Build artifact\n            ConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\n            if (MavenUtils.isMavenProject(project)) {\n                MavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\n                IContainer container;\n                container = MavenUtils.getPomFile(project).getParent();\n                action.launch(container, () -> {\n                    \/\/ TODO: callback after mvn package done. IMPORTANT\n                    buildAndRun(event);\n                    return null;\n                });\n            } else {\n                WarUtil.export(project, destinationPath);\n                buildAndRun(event);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            ConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\n            sendTelemetryOnException(event, e);\n        }\n        return null;\n    }","code":"@Override\n    public Object onExecute(ExecutionEvent event) throws ExecutionException {\n        project = PluginUtil.getSelectedProject();\n        try {\n            if (project == null) {\n                throw new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n            }\n            basePath = project.getLocation().toString();\n            if (MavenUtils.isMavenProject(project)) {\n                destinationPath = MavenUtils.getTargetPath(project);\n            } else {\n                destinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n                        .normalize().toString();\n            }\n           \n            String runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\n            if (runningContainerId != null) {\n                boolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\n                        Constant.MESSAGE_CONFIRM_STOP_CONTAINER);\n                if (stop) {\n                    DockerRuntime.getInstance().cleanRuningContainer(basePath);\n                } else {\n                    return null;\n                }\n            }\n           \n            ConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\n            if (MavenUtils.isMavenProject(project)) {\n                MavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\n                IContainer container;\n                container = MavenUtils.getPomFile(project).getParent();\n                action.launch(container, () -> {\n                   \n                    buildAndRun(event);\n                    return null;\n                });\n            } else {\n                WarUtil.export(project, destinationPath);\n                buildAndRun(event);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            ConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\n            sendTelemetryOnException(event, e);\n        }\n        return null;\n    }","cleancode":"@override public object onexecute(executionevent event) throws executionexception { project = pluginutil.getselectedproject(); try { if (project == null) { throw new exception(constant.error_no_selected_project); } basepath = project.getlocation().tostring(); if (mavenutils.ismavenproject(project)) { destinationpath = mavenutils.gettargetpath(project); } else { destinationpath = paths.get(basepath, constant.dockerfile_folder, project.getname() + \".war\") .normalize().tostring(); } string runningcontainerid = dockerruntime.getinstance().getrunningcontainerid(basepath); if (runningcontainerid != null) { boolean stop = messagedialog.openconfirm(pluginutil.getparentshell(), \"confirmation\", constant.message_confirm_stop_container); if (stop) { dockerruntime.getinstance().cleanruningcontainer(basepath); } else { return null; } } consolelogger.info(string.format(constant.message_exporting_project, destinationpath)); if (mavenutils.ismavenproject(project)) { mavenexecuteaction action = new mavenexecuteaction(maven_goals); icontainer container; container = mavenutils.getpomfile(project).getparent(); action.launch(container, () -> { buildandrun(event); return null; }); } else { warutil.export(project, destinationpath); buildandrun(event); } } catch (exception e) { e.printstacktrace(); consolelogger.error(string.format(constant.error_running_docker, e.getmessage())); sendtelemetryonexception(event, e); } return null; }","comment":"\/\/ stop running container\n\/\/ build artifact\n\/\/ todo: callback after mvn package done. important","repo":"andxu\/azure-tools-for-java","code_context_2":".normalize().toString();\n}\n\/\/ Stop running container\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\n\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\n\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;","code_context_10":"if (project == null) {\nthrow new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n}\nbasePath = project.getLocation().toString();\nif (MavenUtils.isMavenProject(project)) {\ndestinationPath = MavenUtils.getTargetPath(project);\n} else {\ndestinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n.normalize().toString();\n}\n\/\/ Stop running container\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\nboolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\nConstant.MESSAGE_CONFIRM_STOP_CONTAINER);\nif (stop) {\nDockerRuntime.getInstance().cleanRuningContainer(basePath);\n} else {\nreturn null;\n}\n}\n\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\nboolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\nConstant.MESSAGE_CONFIRM_STOP_CONTAINER);\nif (stop) {\nDockerRuntime.getInstance().cleanRuningContainer(basePath);\n} else {\nreturn null;\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\nMavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\nIContainer container;\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;\n});\n\nreturn null;\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\nMavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\nIContainer container;\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;\n});\n} else {\nWarUtil.export(project, destinationPath);\nbuildAndRun(event);\n}\n} catch (Exception e) {\ne.printStackTrace();\nConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));","code_context_20":"@Override\npublic Object onExecute(ExecutionEvent event) throws ExecutionException {\nproject = PluginUtil.getSelectedProject();\ntry {\nif (project == null) {\nthrow new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n}\nbasePath = project.getLocation().toString();\nif (MavenUtils.isMavenProject(project)) {\ndestinationPath = MavenUtils.getTargetPath(project);\n} else {\ndestinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n.normalize().toString();\n}\n\/\/ Stop running container\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\nboolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\nConstant.MESSAGE_CONFIRM_STOP_CONTAINER);\nif (stop) {\nDockerRuntime.getInstance().cleanRuningContainer(basePath);\n} else {\nreturn null;\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\nMavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\nIContainer container;\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;\n\nthrow new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n}\nbasePath = project.getLocation().toString();\nif (MavenUtils.isMavenProject(project)) {\ndestinationPath = MavenUtils.getTargetPath(project);\n} else {\ndestinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n.normalize().toString();\n}\n\/\/ Stop running container\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\nboolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\nConstant.MESSAGE_CONFIRM_STOP_CONTAINER);\nif (stop) {\nDockerRuntime.getInstance().cleanRuningContainer(basePath);\n} else {\nreturn null;\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\nMavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\nIContainer container;\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;\n});\n} else {\nWarUtil.export(project, destinationPath);\nbuildAndRun(event);\n}\n} catch (Exception e) {\ne.printStackTrace();\nConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\nsendTelemetryOnException(event, e);\n}\nreturn null;\n\n.normalize().toString();\n}\n\/\/ Stop running container\nString runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\nif (runningContainerId != null) {\nboolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\nConstant.MESSAGE_CONFIRM_STOP_CONTAINER);\nif (stop) {\nDockerRuntime.getInstance().cleanRuningContainer(basePath);\n} else {\nreturn null;\n}\n}\n\/\/ Build artifact\nConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\nif (MavenUtils.isMavenProject(project)) {\nMavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\nIContainer container;\ncontainer = MavenUtils.getPomFile(project).getParent();\naction.launch(container, () -> {\n\/\/ TODO: callback after mvn package done. IMPORTANT\nbuildAndRun(event);\nreturn null;\n});\n} else {\nWarUtil.export(project, destinationPath);\nbuildAndRun(event);\n}\n} catch (Exception e) {\ne.printStackTrace();\nConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\nsendTelemetryOnException(event, e);\n}\nreturn null;\n}","label":[0,1,0,0]}
{"id":2322,"original_code":"public ValueInstantiator createOptimized()\n    {\n        \/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n         *  property-based creators.\n         *\/\n        if (_originalInstantiator.canCreateFromObjectWith()\n                || _originalInstantiator.canCreateUsingDelegate()) {\n            return null;\n        }\n        \/\/ for now, only consider need to handle default creator\n        AnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\n        if (defaultCreator != null) {\n            AnnotatedElement elem = defaultCreator.getAnnotated();\n            if (elem instanceof Constructor<?>) {\n                \/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\n                Constructor<?> ctor = (Constructor<?>) elem;\n                if (!Modifier.isPrivate(ctor.getModifiers())) {\n                    return createSubclass(ctor, null).with(_originalInstantiator);\n                }\n            } else if (elem instanceof Method) {\n                Method m = (Method) elem;\n                int mods = m.getModifiers();\n                \/\/ and as above, can't access private ones\n                if (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\n                    return createSubclass(null, m).with(_originalInstantiator);\n                }\n            }\n        }\n        return null;\n    }","code":"public ValueInstantiator createOptimized()\n    {\n       \n        if (_originalInstantiator.canCreateFromObjectWith()\n                || _originalInstantiator.canCreateUsingDelegate()) {\n            return null;\n        }\n       \n        AnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\n        if (defaultCreator != null) {\n            AnnotatedElement elem = defaultCreator.getAnnotated();\n            if (elem instanceof Constructor<?>) {\n               \n                Constructor<?> ctor = (Constructor<?>) elem;\n                if (!Modifier.isPrivate(ctor.getModifiers())) {\n                    return createSubclass(ctor, null).with(_originalInstantiator);\n                }\n            } else if (elem instanceof Method) {\n                Method m = (Method) elem;\n                int mods = m.getModifiers();\n               \n                if (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\n                    return createSubclass(null, m).with(_originalInstantiator);\n                }\n            }\n        }\n        return null;\n    }","cleancode":"public valueinstantiator createoptimized() { if (_originalinstantiator.cancreatefromobjectwith() || _originalinstantiator.cancreateusingdelegate()) { return null; } annotatedwithparams defaultcreator = _originalinstantiator.getdefaultcreator(); if (defaultcreator != null) { annotatedelement elem = defaultcreator.getannotated(); if (elem instanceof constructor<?>) { constructor<?> ctor = (constructor<?>) elem; if (!modifier.isprivate(ctor.getmodifiers())) { return createsubclass(ctor, null).with(_originalinstantiator); } } else if (elem instanceof method) { method m = (method) elem; int mods = m.getmodifiers(); if (modifier.isstatic(mods) && !modifier.isprivate(mods)) { return createsubclass(null, m).with(_originalinstantiator); } } } return null; }","comment":"\/* [issue#11]: need to avoid optimizing if we use delegate- or * property-based creators. *\/\n\/\/ for now, only consider need to handle default creator\n\/\/ first things first: as per [issue#34], can not access private ctors or methods\n\/\/ and as above, can't access private ones","repo":"bsanchezb\/jackson-modules-base","code_context_2":"public ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\n\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\n\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\n\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);","code_context_10":"public ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\n\npublic ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\n\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n}\n}\n}\nreturn null;\n}","code_context_20":"public ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n\npublic ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n}\n}\n}\nreturn null;\n}\n\npublic ValueInstantiator createOptimized()\n{\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n}\n}\n}\nreturn null;\n}\n\n\/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n* property-based creators.\n*\/\nif (_originalInstantiator.canCreateFromObjectWith()\n|| _originalInstantiator.canCreateUsingDelegate()) {\nreturn null;\n}\n\/\/ for now, only consider need to handle default creator\nAnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\nif (defaultCreator != null) {\nAnnotatedElement elem = defaultCreator.getAnnotated();\nif (elem instanceof Constructor<?>) {\n\/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\nConstructor<?> ctor = (Constructor<?>) elem;\nif (!Modifier.isPrivate(ctor.getModifiers())) {\nreturn createSubclass(ctor, null).with(_originalInstantiator);\n}\n} else if (elem instanceof Method) {\nMethod m = (Method) elem;\nint mods = m.getModifiers();\n\/\/ and as above, can't access private ones\nif (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\nreturn createSubclass(null, m).with(_originalInstantiator);\n}\n}\n}\nreturn null;\n}","label":[1,0,0,0]}
{"id":10679,"original_code":"@Override\n  public void flush(long timeoutMillis) {\n    \/\/ TODO: Flush transport\n  }","code":"@Override\n  public void flush(long timeoutMillis) {\n   \n  }","cleancode":"@override public void flush(long timeoutmillis) { }","comment":"\/\/ todo: flush transport","repo":"bsergean\/sentry-android","code_context_2":"@Override\npublic void flush(long timeoutMillis) {\n\/\/ TODO: Flush transport\n}","code_context_10":"@Override\npublic void flush(long timeoutMillis) {\n\/\/ TODO: Flush transport\n}","code_context_20":"@Override\npublic void flush(long timeoutMillis) {\n\/\/ TODO: Flush transport\n}","label":[0,1,0,0]}
{"id":18946,"original_code":"protected boolean startsWithReferenceAnchor(TextLine line) {\n    if (line == null) {\n      return false;\n    }\n    String text = line.getText();\n    if (text == null) {\n      return false;\n    }\n    return REFERENCE_ANCHOR.matcher(text).find();\n  }","code":"protected boolean startsWithReferenceAnchor(TextLine line) {\n    if (line == null) {\n      return false;\n    }\n    String text = line.getText();\n    if (text == null) {\n      return false;\n    }\n    return REFERENCE_ANCHOR.matcher(text).find();\n  }","cleancode":"protected boolean startswithreferenceanchor(textline line) { if (line == null) { return false; } string text = line.gettext(); if (text == null) { return false; } return reference_anchor.matcher(text).find(); }","comment":"\/** * checks is the given text line starts with a reference anchor like \"[1]\", \"[2]\", etc. * * @param line the text line to check. * @return true, if the given text line starts with a reference anchor, false otherwise. *\/ \/\/ todo: move to any util.","repo":"ckorzen\/pdfact","code_context_2":"protected boolean startsWithReferenceAnchor(TextLine line) {\nif (line == null) {\nreturn false;\n}\nString text = line.getText();\nif (text == null) {\nreturn false;\n}\nreturn REFERENCE_ANCHOR.matcher(text).find();\n}","code_context_10":"protected boolean startsWithReferenceAnchor(TextLine line) {\nif (line == null) {\nreturn false;\n}\nString text = line.getText();\nif (text == null) {\nreturn false;\n}\nreturn REFERENCE_ANCHOR.matcher(text).find();\n}","code_context_20":"protected boolean startsWithReferenceAnchor(TextLine line) {\nif (line == null) {\nreturn false;\n}\nString text = line.getText();\nif (text == null) {\nreturn false;\n}\nreturn REFERENCE_ANCHOR.matcher(text).find();\n}","label":[0,1,0,0]}
{"id":10779,"original_code":"public Future<?>  greetMeSometimeAsync(String requestType, \n                                           AsyncHandler<GreetMeSometimeResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code":"public Future<?>  greetMeSometimeAsync(String requestType, \n                                           AsyncHandler<GreetMeSometimeResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmesometimeasync(string requesttype, asynchandler<greetmesometimeresponse> asynchandler) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"AsyncHandler<GreetMeSometimeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Future<?> greetMeSometimeAsync(String requestType,\nAsyncHandler<GreetMeSometimeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Future<?> greetMeSometimeAsync(String requestType,\nAsyncHandler<GreetMeSometimeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10780,"original_code":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) { \n        return null; \n        \/*not called *\/\n    }","code":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmesometimeresponse> greetmesometimeasync(string requesttype) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10781,"original_code":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {  \n        return null; \n        \/*not called *\/\n    }","code":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {  \n        return null; \n       \n    }","cleancode":"public response<testdoclitfaultresponse> testdoclitfaultasync(string faulttype) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10782,"original_code":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {  \n        return null; \n        \/*not called *\/\n    }","code":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {  \n        return null; \n       \n    }","cleancode":"public future<?> testdoclitfaultasync(string faulttype, asynchandler ah) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10783,"original_code":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\n        return null;\n        \/* not called *\/\n    }","code":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\n        return null;\n       \n    }","cleancode":"public future<?> testdoclitbareasync(string bare, asynchandler ah) { return null; }","comment":"\/* not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\nreturn null;\n\/* not called *\/\n}","code_context_10":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\nreturn null;\n\/* not called *\/\n}","code_context_20":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\nreturn null;\n\/* not called *\/\n}","label":[0,0,0,0]}
{"id":10784,"original_code":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\n        return null;\n        \/* not called *\/\n    }","code":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\n        return null;\n       \n    }","cleancode":"public response<baredocumentresponse> testdoclitbareasync(string bare) { return null; }","comment":"\/* not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\nreturn null;\n\/* not called *\/\n}","code_context_10":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\nreturn null;\n\/* not called *\/\n}","code_context_20":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\nreturn null;\n\/* not called *\/\n}","label":[0,0,0,0]}
{"id":10785,"original_code":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmeasync(string requesttype, asynchandler<greetmeresponse> asynchandler) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10786,"original_code":"public Response<GreetMeResponse> greetMeAsync(String requestType) { \n        return null; \n        \/*not called *\/\n    }","code":"public Response<GreetMeResponse> greetMeAsync(String requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmeresponse> greetmeasync(string requesttype) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<GreetMeResponse> greetMeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Response<GreetMeResponse> greetMeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Response<GreetMeResponse> greetMeAsync(String requestType) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10787,"original_code":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmelaterasync(long requesttype, asynchandler<greetmelaterresponse> asynchandler) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10788,"original_code":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) { \n        return null; \n        \/*not called *\/\n    }","code":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmelaterresponse> greetmelaterasync(long requesttype) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10789,"original_code":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> sayhiasync(asynchandler<sayhiresponse> asynchandler) { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10790,"original_code":"public Response<SayHiResponse> sayHiAsync() { \n        return null; \n        \/*not called *\/\n    }","code":"public Response<SayHiResponse> sayHiAsync() { \n        return null; \n       \n    }","cleancode":"public response<sayhiresponse> sayhiasync() { return null; }","comment":"\/*not called *\/","repo":"apache\/servicemix4-features","code_context_2":"public Response<SayHiResponse> sayHiAsync() {\nreturn null;\n\/*not called *\/\n}","code_context_10":"public Response<SayHiResponse> sayHiAsync() {\nreturn null;\n\/*not called *\/\n}","code_context_20":"public Response<SayHiResponse> sayHiAsync() {\nreturn null;\n\/*not called *\/\n}","label":[0,0,0,0]}
{"id":10852,"original_code":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n    {\n        if (command instanceof SinglePartitionReadCommand)\n        {\n            \/\/ Note: as yet there's no route to get here - a 2i query *always* uses a\n            \/\/ PartitionRangeReadCommand. This is here in preparation for coming changes\n            \/\/ in SelectStatement.\n            SinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\n            ByteBuffer pk = sprc.partitionKey().getKey();\n            ClusteringIndexFilter filter = sprc.clusteringIndexFilter();\n            if (filter instanceof ClusteringIndexNamesFilter)\n            {\n                NavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\n                NavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\n                for (Clustering c : requested)\n                    clusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\n                return new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n            }\n            else\n            {\n                Slices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\n                Slices.Builder builder = new Slices.Builder(index.getIndexComparator());\n                for (Slice slice : requested)\n                    builder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\n                return new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n            }\n        }\n        else\n        {\n            DataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\n            AbstractBounds<PartitionPosition> range = dataRange.keyRange();\n            Slice slice = Slice.ALL;\n            \/*\n             * XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n             * the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n             * key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n             *\/\n            if (range.left instanceof DecoratedKey)\n            {\n                \/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n                \/\/ but if it is, we can optimise slightly by restricting the slice\n                if (range.right instanceof DecoratedKey)\n                {\n                    DecoratedKey startKey = (DecoratedKey) range.left;\n                    DecoratedKey endKey = (DecoratedKey) range.right;\n                    Slice.Bound start = Slice.Bound.BOTTOM;\n                    Slice.Bound end = Slice.Bound.TOP;\n                    \/*\n                     * For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n                     * slice queries where we can slightly restrict the beginning and end.\n                     *\/\n                    if (!dataRange.isNamesQuery())\n                    {\n                        ClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\n                        ClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n                        \/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n                        \/\/ (or through post-query reordering) and shouldn't get there.\n                        assert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\n                        Slices startSlices = startSliceFilter.requestedSlices();\n                        Slices endSlices = endSliceFilter.requestedSlices();\n                        if (startSlices.size() > 0)\n                            start = startSlices.get(0).start();\n                        if (endSlices.size() > 0)\n                            end = endSlices.get(endSlices.size() - 1).end();\n                    }\n                    slice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\n                                       index.makeIndexBound(endKey.getKey(), end));\n                }\n                else\n                {\n                   \/\/ otherwise, just start the index slice from the key we do have\n                   slice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\n                                      Slice.Bound.TOP);\n                }\n            }\n            return new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n        }\n    }","code":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n    {\n        if (command instanceof SinglePartitionReadCommand)\n        {\n           \n           \n           \n            SinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\n            ByteBuffer pk = sprc.partitionKey().getKey();\n            ClusteringIndexFilter filter = sprc.clusteringIndexFilter();\n            if (filter instanceof ClusteringIndexNamesFilter)\n            {\n                NavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\n                NavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\n                for (Clustering c : requested)\n                    clusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\n                return new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n            }\n            else\n            {\n                Slices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\n                Slices.Builder builder = new Slices.Builder(index.getIndexComparator());\n                for (Slice slice : requested)\n                    builder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\n                return new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n            }\n        }\n        else\n        {\n            DataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\n            AbstractBounds<PartitionPosition> range = dataRange.keyRange();\n            Slice slice = Slice.ALL;\n           \n            if (range.left instanceof DecoratedKey)\n            {\n               \n               \n                if (range.right instanceof DecoratedKey)\n                {\n                    DecoratedKey startKey = (DecoratedKey) range.left;\n                    DecoratedKey endKey = (DecoratedKey) range.right;\n                    Slice.Bound start = Slice.Bound.BOTTOM;\n                    Slice.Bound end = Slice.Bound.TOP;\n                   \n                    if (!dataRange.isNamesQuery())\n                    {\n                        ClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\n                        ClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n                       \n                       \n                        assert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\n                        Slices startSlices = startSliceFilter.requestedSlices();\n                        Slices endSlices = endSliceFilter.requestedSlices();\n                        if (startSlices.size() > 0)\n                            start = startSlices.get(0).start();\n                        if (endSlices.size() > 0)\n                            end = endSlices.get(endSlices.size() - 1).end();\n                    }\n                    slice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\n                                       index.makeIndexBound(endKey.getKey(), end));\n                }\n                else\n                {\n                  \n                   slice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\n                                      Slice.Bound.TOP);\n                }\n            }\n            return new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n        }\n    }","cleancode":"private clusteringindexfilter makeindexfilter(abstractsimplepercolumnsecondaryindex index, readcommand command) { if (command instanceof singlepartitionreadcommand) { singlepartitionreadcommand sprc = (singlepartitionreadcommand)command; bytebuffer pk = sprc.partitionkey().getkey(); clusteringindexfilter filter = sprc.clusteringindexfilter(); if (filter instanceof clusteringindexnamesfilter) { navigableset<clustering> requested = ((clusteringindexnamesfilter)filter).requestedrows(); navigableset<clustering> clusterings = new treeset<>(index.getindexcomparator()); for (clustering c : requested) clusterings.add(index.makeindexclustering(pk, c, (cell)null).takealias()); return new clusteringindexnamesfilter(clusterings, filter.isreversed()); } else { slices requested = ((clusteringindexslicefilter)filter).requestedslices(); slices.builder builder = new slices.builder(index.getindexcomparator()); for (slice slice : requested) builder.add(index.makeindexbound(pk, slice.start()), index.makeindexbound(pk, slice.end())); return new clusteringindexslicefilter(builder.build(), filter.isreversed()); } } else { datarange datarange = ((partitionrangereadcommand)command).datarange(); abstractbounds<partitionposition> range = datarange.keyrange(); slice slice = slice.all; if (range.left instanceof decoratedkey) { if (range.right instanceof decoratedkey) { decoratedkey startkey = (decoratedkey) range.left; decoratedkey endkey = (decoratedkey) range.right; slice.bound start = slice.bound.bottom; slice.bound end = slice.bound.top; if (!datarange.isnamesquery()) { clusteringindexslicefilter startslicefilter = ((clusteringindexslicefilter) datarange.clusteringindexfilter(startkey)); clusteringindexslicefilter endslicefilter = ((clusteringindexslicefilter) datarange.clusteringindexfilter(endkey)); assert !startslicefilter.isreversed() && !endslicefilter.isreversed(); slices startslices = startslicefilter.requestedslices(); slices endslices = endslicefilter.requestedslices(); if (startslices.size() > 0) start = startslices.get(0).start(); if (endslices.size() > 0) end = endslices.get(endslices.size() - 1).end(); } slice = slice.make(index.makeindexbound(startkey.getkey(), start), index.makeindexbound(endkey.getkey(), end)); } else { slice = slice.make(index.makeindexbound(((decoratedkey)range.left).getkey(), slice.bound.bottom), slice.bound.top); } } return new clusteringindexslicefilter(slices.with(index.getindexcomparator(), slice), false); } }","comment":"\/\/ note: as yet there's no route to get here - a 2i query *always* uses a \/\/ partitionrangereadcommand. this is here in preparation for coming changes \/\/ in selectstatement.\n\/* * xxx: if the range requested is a token range, we'll have to start at the beginning (and stop at the end) of * the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible * key having a given token. a potential fix would be to actually store the token along the key in the indexed row. *\/\n\/\/ the right hand side of the range may not be a decoratedkey (for instance if we're paging), \/\/ but if it is, we can optimise slightly by restricting the slice\n\/* * for index queries over a range, we can't do a whole lot better than querying everything for the key range, though for * slice queries where we can slightly restrict the beginning and end. *\/\n\/\/ we can't effectively support reversed queries when we have a range, so we don't support it \/\/ (or through post-query reordering) and shouldn't get there.\n\/\/ otherwise, just start the index slice from the key we do have","repo":"chaordic\/cassandra","code_context_2":"if (command instanceof SinglePartitionReadCommand)\n{\n\/\/ Note: as yet there's no route to get here - a 2i query *always* uses a\n\/\/ PartitionRangeReadCommand. This is here in preparation for coming changes\n\/\/ in SelectStatement.\nSinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\nByteBuffer pk = sprc.partitionKey().getKey();\n\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\n\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\nassert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\nSlices startSlices = startSliceFilter.requestedSlices();\n\nelse\n{\n\/\/ otherwise, just start the index slice from the key we do have\nslice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\nSlice.Bound.TOP);","code_context_10":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n{\nif (command instanceof SinglePartitionReadCommand)\n{\n\/\/ Note: as yet there's no route to get here - a 2i query *always* uses a\n\/\/ PartitionRangeReadCommand. This is here in preparation for coming changes\n\/\/ in SelectStatement.\nSinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\nByteBuffer pk = sprc.partitionKey().getKey();\nClusteringIndexFilter filter = sprc.clusteringIndexFilter();\nif (filter instanceof ClusteringIndexNamesFilter)\n{\nNavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\nNavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\nfor (Clustering c : requested)\nclusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\nreturn new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\nelse\n{\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\n\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\nelse\n{\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\n\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\nassert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\nSlices startSlices = startSliceFilter.requestedSlices();\nSlices endSlices = endSliceFilter.requestedSlices();\nif (startSlices.size() > 0)\nstart = startSlices.get(0).start();\nif (endSlices.size() > 0)\nend = endSlices.get(endSlices.size() - 1).end();\n}\nslice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\nindex.makeIndexBound(endKey.getKey(), end));\n\nif (startSlices.size() > 0)\nstart = startSlices.get(0).start();\nif (endSlices.size() > 0)\nend = endSlices.get(endSlices.size() - 1).end();\n}\nslice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\nindex.makeIndexBound(endKey.getKey(), end));\n}\nelse\n{\n\/\/ otherwise, just start the index slice from the key we do have\nslice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\nSlice.Bound.TOP);\n}\n}\nreturn new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n}\n}","code_context_20":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n{\nif (command instanceof SinglePartitionReadCommand)\n{\n\/\/ Note: as yet there's no route to get here - a 2i query *always* uses a\n\/\/ PartitionRangeReadCommand. This is here in preparation for coming changes\n\/\/ in SelectStatement.\nSinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\nByteBuffer pk = sprc.partitionKey().getKey();\nClusteringIndexFilter filter = sprc.clusteringIndexFilter();\nif (filter instanceof ClusteringIndexNamesFilter)\n{\nNavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\nNavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\nfor (Clustering c : requested)\nclusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\nreturn new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n}\nelse\n{\nSlices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\nSlices.Builder builder = new Slices.Builder(index.getIndexComparator());\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\n\nNavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\nNavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\nfor (Clustering c : requested)\nclusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\nreturn new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n}\nelse\n{\nSlices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\nSlices.Builder builder = new Slices.Builder(index.getIndexComparator());\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\nelse\n{\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\n\n{\nSlices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\nSlices.Builder builder = new Slices.Builder(index.getIndexComparator());\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\nelse\n{\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\nassert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\nSlices startSlices = startSliceFilter.requestedSlices();\nSlices endSlices = endSliceFilter.requestedSlices();\nif (startSlices.size() > 0)\n\nNavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\nNavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\nfor (Clustering c : requested)\nclusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\nreturn new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n}\nelse\n{\nSlices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\nSlices.Builder builder = new Slices.Builder(index.getIndexComparator());\nfor (Slice slice : requested)\nbuilder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\nreturn new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n}\n}\nelse\n{\nDataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\nAbstractBounds<PartitionPosition> range = dataRange.keyRange();\nSlice slice = Slice.ALL;\n\/*\n* XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n* the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\n* key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n*\/\nif (range.left instanceof DecoratedKey)\n{\n\/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n\/\/ but if it is, we can optimise slightly by restricting the slice\nif (range.right instanceof DecoratedKey)\n{\nDecoratedKey startKey = (DecoratedKey) range.left;\nDecoratedKey endKey = (DecoratedKey) range.right;\nSlice.Bound start = Slice.Bound.BOTTOM;\nSlice.Bound end = Slice.Bound.TOP;\n\/*\n* For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n* slice queries where we can slightly restrict the beginning and end.\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\nassert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\nSlices startSlices = startSliceFilter.requestedSlices();\nSlices endSlices = endSliceFilter.requestedSlices();\nif (startSlices.size() > 0)\nstart = startSlices.get(0).start();\nif (endSlices.size() > 0)\nend = endSlices.get(endSlices.size() - 1).end();\n}\nslice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\nindex.makeIndexBound(endKey.getKey(), end));\n}\nelse\n{\n\/\/ otherwise, just start the index slice from the key we do have\nslice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\nSlice.Bound.TOP);\n}\n}\nreturn new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n}\n\n*\/\nif (!dataRange.isNamesQuery())\n{\nClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\nClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n\/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n\/\/ (or through post-query reordering) and shouldn't get there.\nassert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\nSlices startSlices = startSliceFilter.requestedSlices();\nSlices endSlices = endSliceFilter.requestedSlices();\nif (startSlices.size() > 0)\nstart = startSlices.get(0).start();\nif (endSlices.size() > 0)\nend = endSlices.get(endSlices.size() - 1).end();\n}\nslice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\nindex.makeIndexBound(endKey.getKey(), end));\n}\nelse\n{\n\/\/ otherwise, just start the index slice from the key we do have\nslice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\nSlice.Bound.TOP);\n}\n}\nreturn new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n}\n}","label":[1,0,0,0]}
{"id":10876,"original_code":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\n            final int tClassifierId) {\n        \/\/ --- precondition\n        if (catalog == null && schema == null) {\n            return false;\n        }\n        RelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n            @Override\n            protected T doSwitch(int classifierID, EObject theEObject) {\n                if (theEObject.eClass().getClassifierID() != tClassifierId) {\n                    return null;\n                } else {\n                    return super.doSwitch(classifierID, theEObject);\n                }\n            }\n            @Override\n            public T caseColumnSet(ColumnSet object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTable(Table object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdTable(TdTable object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdView(TdView object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseView(View object) {\n                return castObject(object);\n            }\n            @SuppressWarnings(\"unchecked\")\n            private T castObject(Object object) {\n                return (T) object;\n            }\n        };\n        EList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\n        if (elements.isEmpty()) {\n            \/\/ no element found\n            return false;\n        }\n        for (EObject elt : elements) {\n            T columnSet = relationalSwitch.doSwitch(elt);\n            if (columnSet != null) {\n                output.add(columnSet);\n            }\n        }\n        return true;\n    }","code":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\n            final int tClassifierId) {\n       \n        if (catalog == null && schema == null) {\n            return false;\n        }\n        RelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n            @Override\n            protected T doSwitch(int classifierID, EObject theEObject) {\n                if (theEObject.eClass().getClassifierID() != tClassifierId) {\n                    return null;\n                } else {\n                    return super.doSwitch(classifierID, theEObject);\n                }\n            }\n            @Override\n            public T caseColumnSet(ColumnSet object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTable(Table object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdTable(TdTable object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdView(TdView object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseView(View object) {\n                return castObject(object);\n            }\n            @SuppressWarnings(\"unchecked\")\n            private T castObject(Object object) {\n                return (T) object;\n            }\n        };\n        EList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\n        if (elements.isEmpty()) {\n           \n            return false;\n        }\n        for (EObject elt : elements) {\n            T columnSet = relationalSwitch.doSwitch(elt);\n            if (columnSet != null) {\n                output.add(columnSet);\n            }\n        }\n        return true;\n    }","cleancode":"public static <t extends columnset> boolean fillcolumnsets(catalog catalog, schema schema, collection<t> output, final int tclassifierid) { if (catalog == null && schema == null) { return false; } relationalswitch<t> relationalswitch = new relationalswitch<t>() { @override protected t doswitch(int classifierid, eobject theeobject) { if (theeobject.eclass().getclassifierid() != tclassifierid) { return null; } else { return super.doswitch(classifierid, theeobject); } } @override public t casecolumnset(columnset object) { return castobject(object); } @override public t casetable(table object) { return castobject(object); } @override public t casetdtable(tdtable object) { return castobject(object); } @override public t casetdview(tdview object) { return castobject(object); } @override public t caseview(view object) { return castobject(object); } @suppresswarnings(\"unchecked\") private t castobject(object object) { return (t) object; } }; elist<modelelement> elements = (schema != null) ? schema.getownedelement() : catalog.getownedelement(); if (elements.isempty()) { return false; } for (eobject elt : elements) { t columnset = relationalswitch.doswitch(elt); if (columnset != null) { output.add(columnset); } } return true; }","comment":"\/** * method \"fillcolumnsets\". todo scorreia this method has not been tested yet!! * * @param <t> the type of elements to find (either table, view, columnset) * @param catalog the catalog if the tables are stored directly in catalog (or null) * @param schema the schema if the tables are stored directly in schema (or null) * @param output the list of searched elements (tables, tdtables....) * @param tclassifierid the the classifierid of the searched elements (e.g. {@link relationalpackage#td_view}) * @return true if elements have been found and potentially added to the output list. *\/\n\/\/ --- precondition\n\/\/ no element found","repo":"coheigea\/tcommon-studio-se","code_context_2":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n}\nRelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n@Override\nprotected T doSwitch(int classifierID, EObject theEObject) {\nif (theEObject.eClass().getClassifierID() != tClassifierId) {\nreturn null;\n} else {\nreturn super.doSwitch(classifierID, theEObject);\n}\n}\n@Override\npublic T caseColumnSet(ColumnSet object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTable(Table object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdTable(TdTable object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdView(TdView object) {\nreturn castObject(object);\n}\n@Override\npublic T caseView(View object) {\nreturn castObject(object);\n}\n@SuppressWarnings(\"unchecked\")\nprivate T castObject(Object object) {\nreturn (T) object;\n}\n};\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}\nfor (EObject elt : elements) {\nT columnSet = relationalSwitch.doSwitch(elt);\nif (columnSet != null) {\noutput.add(columnSet);\n}\n}\nreturn true;\n}\n\npublic static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}","code_context_10":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n}\nRelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n@Override\nprotected T doSwitch(int classifierID, EObject theEObject) {\nif (theEObject.eClass().getClassifierID() != tClassifierId) {\nreturn null;\n} else {\nreturn super.doSwitch(classifierID, theEObject);\n}\n}\n@Override\npublic T caseColumnSet(ColumnSet object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTable(Table object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdTable(TdTable object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdView(TdView object) {\nreturn castObject(object);\n}\n@Override\npublic T caseView(View object) {\nreturn castObject(object);\n}\n@SuppressWarnings(\"unchecked\")\nprivate T castObject(Object object) {\nreturn (T) object;\n}\n};\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}\nfor (EObject elt : elements) {\nT columnSet = relationalSwitch.doSwitch(elt);\nif (columnSet != null) {\noutput.add(columnSet);\n}\n}\nreturn true;\n}\n\npublic static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n}\nRelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n@Override\nprotected T doSwitch(int classifierID, EObject theEObject) {\nif (theEObject.eClass().getClassifierID() != tClassifierId) {\nreturn null;\n} else {\nreturn super.doSwitch(classifierID, theEObject);\n\npublic T caseView(View object) {\nreturn castObject(object);\n}\n@SuppressWarnings(\"unchecked\")\nprivate T castObject(Object object) {\nreturn (T) object;\n}\n};\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}\nfor (EObject elt : elements) {\nT columnSet = relationalSwitch.doSwitch(elt);\nif (columnSet != null) {\noutput.add(columnSet);\n}\n}\nreturn true;\n}","code_context_20":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n}\nRelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n@Override\nprotected T doSwitch(int classifierID, EObject theEObject) {\nif (theEObject.eClass().getClassifierID() != tClassifierId) {\nreturn null;\n} else {\nreturn super.doSwitch(classifierID, theEObject);\n}\n}\n@Override\npublic T caseColumnSet(ColumnSet object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTable(Table object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdTable(TdTable object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdView(TdView object) {\nreturn castObject(object);\n}\n@Override\npublic T caseView(View object) {\nreturn castObject(object);\n}\n@SuppressWarnings(\"unchecked\")\nprivate T castObject(Object object) {\nreturn (T) object;\n}\n};\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}\nfor (EObject elt : elements) {\nT columnSet = relationalSwitch.doSwitch(elt);\nif (columnSet != null) {\noutput.add(columnSet);\n}\n}\nreturn true;\n}\n\npublic static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\nfinal int tClassifierId) {\n\/\/ --- precondition\nif (catalog == null && schema == null) {\nreturn false;\n}\nRelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n@Override\nprotected T doSwitch(int classifierID, EObject theEObject) {\nif (theEObject.eClass().getClassifierID() != tClassifierId) {\nreturn null;\n} else {\nreturn super.doSwitch(classifierID, theEObject);\n}\n}\n@Override\npublic T caseColumnSet(ColumnSet object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTable(Table object) {\nreturn castObject(object);\n}\n\n}\n@Override\npublic T caseTdTable(TdTable object) {\nreturn castObject(object);\n}\n@Override\npublic T caseTdView(TdView object) {\nreturn castObject(object);\n}\n@Override\npublic T caseView(View object) {\nreturn castObject(object);\n}\n@SuppressWarnings(\"unchecked\")\nprivate T castObject(Object object) {\nreturn (T) object;\n}\n};\nEList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\nif (elements.isEmpty()) {\n\/\/ no element found\nreturn false;\n}\nfor (EObject elt : elements) {\nT columnSet = relationalSwitch.doSwitch(elt);\nif (columnSet != null) {\noutput.add(columnSet);\n}\n}\nreturn true;\n}","label":[0,0,0,1]}
{"id":2699,"original_code":"public void controllerStatusChanged(boolean isPlaying) {\n        \/\/ Rocket doesn't implement this yet!\n        \/\/ Would be useful to control Rocket from demo's side\n    }","code":"public void controllerStatusChanged(boolean isPlaying) {\n       \n       \n    }","cleancode":"public void controllerstatuschanged(boolean isplaying) { }","comment":"\/\/ rocket doesn't implement this yet! \/\/ would be useful to control rocket from demo's side","repo":"bjakke\/moonlander","code_context_2":"public void controllerStatusChanged(boolean isPlaying) {\n\/\/ Rocket doesn't implement this yet!\n\/\/ Would be useful to control Rocket from demo's side\n}","code_context_10":"public void controllerStatusChanged(boolean isPlaying) {\n\/\/ Rocket doesn't implement this yet!\n\/\/ Would be useful to control Rocket from demo's side\n}","code_context_20":"public void controllerStatusChanged(boolean isPlaying) {\n\/\/ Rocket doesn't implement this yet!\n\/\/ Would be useful to control Rocket from demo's side\n}","label":[0,1,0,0]}
{"id":2728,"original_code":"@Override\n    public boolean addPendingAuthorisationtoBlock() {\n        logger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\n        block = new Block();\n        try{\n            ArrayList<BlockChainAuthorisedObj>  pendingAuthorisationArrayList;\n            synchronized (pendingAuthorisationContainer){\n                pendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\n                logger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\n                pendingAuthorisationContainer.reset();\n                logger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n            }\n            \/\/ We need to order Merkle tree 1st before acually\n            \/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n        }catch (Exception ex){\n            logger.error(ex.getStackTrace());\n        }\n        return false;\n    }","code":"@Override\n    public boolean addPendingAuthorisationtoBlock() {\n        logger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\n        block = new Block();\n        try{\n            ArrayList<BlockChainAuthorisedObj>  pendingAuthorisationArrayList;\n            synchronized (pendingAuthorisationContainer){\n                pendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\n                logger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\n                pendingAuthorisationContainer.reset();\n                logger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n            }\n           \n           \n        }catch (Exception ex){\n            logger.error(ex.getStackTrace());\n        }\n        return false;\n    }","cleancode":"@override public boolean addpendingauthorisationtoblock() { logger.info(\"defaultblockchainpublisher:: addpendingauthorisationtoblock method called with client id:\"); block = new block(); try{ arraylist<blockchainauthorisedobj> pendingauthorisationarraylist; synchronized (pendingauthorisationcontainer){ pendingauthorisationarraylist = pendingauthorisationcontainer.getpendingaccesstokens(); logger.info(\"pendingauthorisationarraylist size: \"+ pendingauthorisationarraylist.size()); pendingauthorisationcontainer.reset(); logger.info(\"pendingauthorisationarraylist size post reset: \"+ pendingauthorisationarraylist.size()); } }catch (exception ex){ logger.error(ex.getstacktrace()); } return false; }","comment":"\/** * this is a block creation process and when created * this will be published to all peers * and block will be added to blockchain. * * @return *\/\n\/\/ we need to order merkle tree 1st before acually \/\/ actual merkel tree implementation in java. we probably will go with a less dramatic version for poc.","repo":"anubandhan\/spring-security-oauth-BlockChain","code_context_2":"@Override\npublic boolean addPendingAuthorisationtoBlock() {\nlogger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\nblock = new Block();\ntry{\nArrayList<BlockChainAuthorisedObj> pendingAuthorisationArrayList;\nsynchronized (pendingAuthorisationContainer){\npendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\nlogger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\npendingAuthorisationContainer.reset();\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());\n}\nreturn false;\n}\n\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());","code_context_10":"@Override\npublic boolean addPendingAuthorisationtoBlock() {\nlogger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\nblock = new Block();\ntry{\nArrayList<BlockChainAuthorisedObj> pendingAuthorisationArrayList;\nsynchronized (pendingAuthorisationContainer){\npendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\nlogger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\npendingAuthorisationContainer.reset();\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());\n}\nreturn false;\n}\n\nlogger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\nblock = new Block();\ntry{\nArrayList<BlockChainAuthorisedObj> pendingAuthorisationArrayList;\nsynchronized (pendingAuthorisationContainer){\npendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\nlogger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\npendingAuthorisationContainer.reset();\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());\n}\nreturn false;\n}","code_context_20":"@Override\npublic boolean addPendingAuthorisationtoBlock() {\nlogger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\nblock = new Block();\ntry{\nArrayList<BlockChainAuthorisedObj> pendingAuthorisationArrayList;\nsynchronized (pendingAuthorisationContainer){\npendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\nlogger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\npendingAuthorisationContainer.reset();\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());\n}\nreturn false;\n}\n\n@Override\npublic boolean addPendingAuthorisationtoBlock() {\nlogger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\nblock = new Block();\ntry{\nArrayList<BlockChainAuthorisedObj> pendingAuthorisationArrayList;\nsynchronized (pendingAuthorisationContainer){\npendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\nlogger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\npendingAuthorisationContainer.reset();\nlogger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n}\n\/\/ We need to order Merkle tree 1st before acually\n\/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n}catch (Exception ex){\nlogger.error(ex.getStackTrace());\n}\nreturn false;\n}","label":[1,0,0,0]}
{"id":19202,"original_code":"private void getToken(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n                \/\/todo send to background\n                SSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","code":"private void getToken(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n               \n                SSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","cleancode":"private void gettoken(jsonarray args) { if (args == null || args.length() == 0) { return; } try { if (args.length() >= 5) { jsonarray jsonarray = args.getjsonarray(2); arraylist<string> clientscopes = new arraylist<string>(); if (jsonarray != null) { for (int i = 0; i < jsonarray.length(); i++) { clientscopes.add(jsonarray.get(i).tostring()); } } this.clientid = args.getstring(0); this.clientsecret = args.getstring(1); this.clientscopes = clientscopes; this.clientredirecturi = args.getstring(3); this.production = args.getboolean(4); ssohelper.gettoken(this, this.cordova.getactivity(), clientid, clientsecret, clientscopes, clientredirecturi, production); } } catch (jsonexception e) { e.printstacktrace(); callbackcontext.error(e.getmessage()); } }","comment":"\/\/todo send to background","repo":"benbenxiaoluchi\/com.accenture.cordova.plugin.sso","code_context_2":"this.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n}","code_context_10":"if (jsonArray != null) {\nfor (int i = 0; i < jsonArray.length(); i++) {\nclientScopes.add(jsonArray.get(i).toString());\n}\n}\nthis.clientId = args.getString(0);\nthis.clientSecret = args.getString(1);\nthis.clientScopes = clientScopes;\nthis.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n}\n} catch (JSONException e) {\ne.printStackTrace();\ncallbackContext.error(e.getMessage());\n}\n}","code_context_20":"private void getToken(JSONArray args) {\nif (args == null || args.length() == 0) {\nreturn;\n}\ntry {\nif (args.length() >= 5) {\nJSONArray jsonArray = args.getJSONArray(2);\nArrayList<String> clientScopes = new ArrayList<String>();\nif (jsonArray != null) {\nfor (int i = 0; i < jsonArray.length(); i++) {\nclientScopes.add(jsonArray.get(i).toString());\n}\n}\nthis.clientId = args.getString(0);\nthis.clientSecret = args.getString(1);\nthis.clientScopes = clientScopes;\nthis.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n}\n} catch (JSONException e) {\ne.printStackTrace();\ncallbackContext.error(e.getMessage());\n}\n}","label":[0,1,0,0]}
{"id":19203,"original_code":"private void logout(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n                \/\/todo send to background\n                SSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\n                this.callbackContext.success();\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","code":"private void logout(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n               \n                SSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\n                this.callbackContext.success();\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","cleancode":"private void logout(jsonarray args) { if (args == null || args.length() == 0) { return; } try { if (args.length() >= 5) { jsonarray jsonarray = args.getjsonarray(2); arraylist<string> clientscopes = new arraylist<string>(); if (jsonarray != null) { for (int i = 0; i < jsonarray.length(); i++) { clientscopes.add(jsonarray.get(i).tostring()); } } this.clientid = args.getstring(0); this.clientsecret = args.getstring(1); this.clientscopes = clientscopes; this.clientredirecturi = args.getstring(3); this.production = args.getboolean(4); ssohelper.logout(this.cordova.getactivity(), clientid, clientsecret, production); this.callbackcontext.success(); } } catch (jsonexception e) { e.printstacktrace(); callbackcontext.error(e.getmessage()); } }","comment":"\/\/todo send to background","repo":"benbenxiaoluchi\/com.accenture.cordova.plugin.sso","code_context_2":"this.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\nthis.callbackContext.success();","code_context_10":"if (jsonArray != null) {\nfor (int i = 0; i < jsonArray.length(); i++) {\nclientScopes.add(jsonArray.get(i).toString());\n}\n}\nthis.clientId = args.getString(0);\nthis.clientSecret = args.getString(1);\nthis.clientScopes = clientScopes;\nthis.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\nthis.callbackContext.success();\n}\n} catch (JSONException e) {\ne.printStackTrace();\ncallbackContext.error(e.getMessage());\n}\n}","code_context_20":"private void logout(JSONArray args) {\nif (args == null || args.length() == 0) {\nreturn;\n}\ntry {\nif (args.length() >= 5) {\nJSONArray jsonArray = args.getJSONArray(2);\nArrayList<String> clientScopes = new ArrayList<String>();\nif (jsonArray != null) {\nfor (int i = 0; i < jsonArray.length(); i++) {\nclientScopes.add(jsonArray.get(i).toString());\n}\n}\nthis.clientId = args.getString(0);\nthis.clientSecret = args.getString(1);\nthis.clientScopes = clientScopes;\nthis.clientRedirectUri = args.getString(3);\nthis.production = args.getBoolean(4);\n\/\/todo send to background\nSSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\nthis.callbackContext.success();\n}\n} catch (JSONException e) {\ne.printStackTrace();\ncallbackContext.error(e.getMessage());\n}\n}","label":[0,1,0,0]}
{"id":11077,"original_code":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\n    name = name.toLowerCase();\n    if (name.equals(\"secp224r1\")) {\n      return 224;\n    } else if (name.equals(\"secp256r1\")) {\n      return 256;\n    } else if (name.equals(\"secp384r1\")) {\n      return 384;\n    } else if (name.equals(\"secp521r1\")) {\n      return 521;\n    } else if (name.equals(\"secp256k1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp224r1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp224t1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp256r1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp256t1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp320r1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp320t1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp384r1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp384t1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp512r1\")) {\n      return 512;\n    } else if (name.equals(\"brainpoolp512t1\")) {\n      return 512;\n    } else {\n      throw new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n    }\n  }","code":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\n    name = name.toLowerCase();\n    if (name.equals(\"secp224r1\")) {\n      return 224;\n    } else if (name.equals(\"secp256r1\")) {\n      return 256;\n    } else if (name.equals(\"secp384r1\")) {\n      return 384;\n    } else if (name.equals(\"secp521r1\")) {\n      return 521;\n    } else if (name.equals(\"secp256k1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp224r1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp224t1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp256r1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp256t1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp320r1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp320t1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp384r1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp384t1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp512r1\")) {\n      return 512;\n    } else if (name.equals(\"brainpoolp512t1\")) {\n      return 512;\n    } else {\n      throw new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n    }\n  }","cleancode":"public static int getcurvesize(string name) throws nosuchalgorithmexception { name = name.tolowercase(); if (name.equals(\"secp224r1\")) { return 224; } else if (name.equals(\"secp256r1\")) { return 256; } else if (name.equals(\"secp384r1\")) { return 384; } else if (name.equals(\"secp521r1\")) { return 521; } else if (name.equals(\"secp256k1\")) { return 256; } else if (name.equals(\"brainpoolp224r1\")) { return 224; } else if (name.equals(\"brainpoolp224t1\")) { return 224; } else if (name.equals(\"brainpoolp256r1\")) { return 256; } else if (name.equals(\"brainpoolp256t1\")) { return 256; } else if (name.equals(\"brainpoolp320r1\")) { return 320; } else if (name.equals(\"brainpoolp320t1\")) { return 320; } else if (name.equals(\"brainpoolp384r1\")) { return 384; } else if (name.equals(\"brainpoolp384t1\")) { return 384; } else if (name.equals(\"brainpoolp512r1\")) { return 512; } else if (name.equals(\"brainpoolp512t1\")) { return 512; } else { throw new nosuchalgorithmexception(\"curve not implemented:\" + name); } }","comment":"\/** * returns the bit size of a given curve. todo(bleichen): add all curves that * are tested. *\/","repo":"avineshwar\/wycheproof","code_context_2":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\nname = name.toLowerCase();\nif (name.equals(\"secp224r1\")) {\nreturn 224;\n} else if (name.equals(\"secp256r1\")) {\nreturn 256;\n} else if (name.equals(\"secp384r1\")) {\nreturn 384;\n} else if (name.equals(\"secp521r1\")) {\nreturn 521;\n} else if (name.equals(\"secp256k1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp224r1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp224t1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp256r1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp256t1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp320r1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp320t1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp384r1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp384t1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp512r1\")) {\nreturn 512;\n} else if (name.equals(\"brainpoolp512t1\")) {\nreturn 512;\n} else {\nthrow new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n}\n}","code_context_10":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\nname = name.toLowerCase();\nif (name.equals(\"secp224r1\")) {\nreturn 224;\n} else if (name.equals(\"secp256r1\")) {\nreturn 256;\n} else if (name.equals(\"secp384r1\")) {\nreturn 384;\n} else if (name.equals(\"secp521r1\")) {\nreturn 521;\n} else if (name.equals(\"secp256k1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp224r1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp224t1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp256r1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp256t1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp320r1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp320t1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp384r1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp384t1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp512r1\")) {\nreturn 512;\n} else if (name.equals(\"brainpoolp512t1\")) {\nreturn 512;\n} else {\nthrow new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n}\n}","code_context_20":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\nname = name.toLowerCase();\nif (name.equals(\"secp224r1\")) {\nreturn 224;\n} else if (name.equals(\"secp256r1\")) {\nreturn 256;\n} else if (name.equals(\"secp384r1\")) {\nreturn 384;\n} else if (name.equals(\"secp521r1\")) {\nreturn 521;\n} else if (name.equals(\"secp256k1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp224r1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp224t1\")) {\nreturn 224;\n} else if (name.equals(\"brainpoolp256r1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp256t1\")) {\nreturn 256;\n} else if (name.equals(\"brainpoolp320r1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp320t1\")) {\nreturn 320;\n} else if (name.equals(\"brainpoolp384r1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp384t1\")) {\nreturn 384;\n} else if (name.equals(\"brainpoolp512r1\")) {\nreturn 512;\n} else if (name.equals(\"brainpoolp512t1\")) {\nreturn 512;\n} else {\nthrow new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n}\n}","label":[0,1,0,0]}
{"id":2922,"original_code":"protected Boolean Authenticated()\n    {\n        String OauthToken = request().getHeader(\"token\");\n        if (OauthToken == null || OauthToken.isEmpty()) {\n            return false;\n        }\n        Oauth token = Oauth\n                .find\n                .where()\n                .eq(\"token\", OauthToken)\n                .eq(\"active\", OathTokenActive)\n                .findUnique();\n        if (token != null) {\n            return  true;\n        }\n        return false;\n    }","code":"protected Boolean Authenticated()\n    {\n        String OauthToken = request().getHeader(\"token\");\n        if (OauthToken == null || OauthToken.isEmpty()) {\n            return false;\n        }\n        Oauth token = Oauth\n                .find\n                .where()\n                .eq(\"token\", OauthToken)\n                .eq(\"active\", OathTokenActive)\n                .findUnique();\n        if (token != null) {\n            return  true;\n        }\n        return false;\n    }","cleancode":"protected boolean authenticated() { string oauthtoken = request().getheader(\"token\"); if (oauthtoken == null || oauthtoken.isempty()) { return false; } oauth token = oauth .find .where() .eq(\"token\", oauthtoken) .eq(\"active\", oathtokenactive) .findunique(); if (token != null) { return true; } return false; }","comment":"\/** * checks if the token provided is saved. * collects the heading token, compares it against the db records. * warning : this is not a production method. * todo : compare vs user, pass token securely to avoid sql injection * * @author channing froom * @return *\/","repo":"channing-froom\/playframework-2.5.2","code_context_2":"protected Boolean Authenticated()\n{\nString OauthToken = request().getHeader(\"token\");\nif (OauthToken == null || OauthToken.isEmpty()) {\nreturn false;\n}\nOauth token = Oauth\n.find\n.where()\n.eq(\"token\", OauthToken)\n.eq(\"active\", OathTokenActive)\n.findUnique();\nif (token != null) {\nreturn true;\n}\nreturn false;\n}","code_context_10":"protected Boolean Authenticated()\n{\nString OauthToken = request().getHeader(\"token\");\nif (OauthToken == null || OauthToken.isEmpty()) {\nreturn false;\n}\nOauth token = Oauth\n.find\n.where()\n.eq(\"token\", OauthToken)\n.eq(\"active\", OathTokenActive)\n.findUnique();\nif (token != null) {\nreturn true;\n}\nreturn false;\n}","code_context_20":"protected Boolean Authenticated()\n{\nString OauthToken = request().getHeader(\"token\");\nif (OauthToken == null || OauthToken.isEmpty()) {\nreturn false;\n}\nOauth token = Oauth\n.find\n.where()\n.eq(\"token\", OauthToken)\n.eq(\"active\", OathTokenActive)\n.findUnique();\nif (token != null) {\nreturn true;\n}\nreturn false;\n}","label":[0,1,0,0]}
{"id":19359,"original_code":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        getLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\n        checkEnvProperties();\n        Connection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\n        conn.setLog(getLog());\n        String projectDirectory = project.getBasedir().getAbsolutePath();\n        try {\n            \/\/TODO add copy prop file to \/target\/config\/ with filtering.\n            \/\/ Update - just copy the one file... for now lets copy them all\n            copyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\n            conn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\n            conn.updateConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(e.getMessage());\n        }\n    }","code":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        getLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\n        checkEnvProperties();\n        Connection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\n        conn.setLog(getLog());\n        String projectDirectory = project.getBasedir().getAbsolutePath();\n        try {\n           \n           \n            copyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\n            conn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\n            conn.updateConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(e.getMessage());\n        }\n    }","cleancode":"@override public void execute() throws mojoexecutionexception, mojofailureexception { getlog().info(\"updating connection:\" + connection + \" for integration \" + integrationname + \"_\" + integrationversion + \" from \" + baseurl); checkenvproperties(); connection conn = new connection(connection, baseurl, icsuser, icspassword); conn.setlog(getlog()); string projectdirectory = project.getbasedir().getabsolutepath(); try { copyconfigfiles(projectdirectory + connectionconfigdir, projectdirectory + \"\/target\/connections\"); conn.setconfigdirectory(projectdirectory + \"\/target\/connections\"); conn.updateconnection(); } catch (exception e) { e.printstacktrace(); throw new mojoexecutionexception(e.getmessage()); } }","comment":"\/\/todo add copy prop file to \/target\/config\/ with filtering. \/\/ update - just copy the one file... for now lets copy them all","repo":"avioconsulting\/ics-maven-plugin","code_context_2":"String projectDirectory = project.getBasedir().getAbsolutePath();\ntry {\n\/\/TODO add copy prop file to \/target\/config\/ with filtering.\n\/\/ Update - just copy the one file... for now lets copy them all\ncopyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\nconn.setConfigDirectory(projectDirectory + \"\/target\/connections\");","code_context_10":"@Override\npublic void execute() throws MojoExecutionException, MojoFailureException {\ngetLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\ncheckEnvProperties();\nConnection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\nconn.setLog(getLog());\nString projectDirectory = project.getBasedir().getAbsolutePath();\ntry {\n\/\/TODO add copy prop file to \/target\/config\/ with filtering.\n\/\/ Update - just copy the one file... for now lets copy them all\ncopyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\nconn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\nconn.updateConnection();\n} catch (Exception e) {\ne.printStackTrace();\nthrow new MojoExecutionException(e.getMessage());\n}\n}","code_context_20":"@Override\npublic void execute() throws MojoExecutionException, MojoFailureException {\ngetLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\ncheckEnvProperties();\nConnection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\nconn.setLog(getLog());\nString projectDirectory = project.getBasedir().getAbsolutePath();\ntry {\n\/\/TODO add copy prop file to \/target\/config\/ with filtering.\n\/\/ Update - just copy the one file... for now lets copy them all\ncopyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\nconn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\nconn.updateConnection();\n} catch (Exception e) {\ne.printStackTrace();\nthrow new MojoExecutionException(e.getMessage());\n}\n}","label":[1,0,0,0]}
{"id":19372,"original_code":"static String resolve(String message, Object[] args) {\n        String formatted = String.format(message, args);\n        \/\/ TODO - fix!  this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n        \/\/ TODO - to be resolved\n        for (String key : TERM_CODES.keySet()) {\n            TermCode termCode = TERM_CODES.get(key);\n            Matcher matcher = termCode.pattern.matcher(formatted);\n            if (matcher.find()) {\n                if ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n                        || (\"dbug\".equals(key) && !dbugLevel.get())) {\n                    \/\/ this is a log statement for a disabled log-level, skip.\n                    return null;\n                }\n                if (decorated.get()) {\n                    String output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\n                    formatted = matcher.replaceAll(output);\n                }\n            }\n        }\n        return formatted;\n    }","code":"static String resolve(String message, Object[] args) {\n        String formatted = String.format(message, args);\n       \n       \n        for (String key : TERM_CODES.keySet()) {\n            TermCode termCode = TERM_CODES.get(key);\n            Matcher matcher = termCode.pattern.matcher(formatted);\n            if (matcher.find()) {\n                if ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n                        || (\"dbug\".equals(key) && !dbugLevel.get())) {\n                   \n                    return null;\n                }\n                if (decorated.get()) {\n                    String output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\n                    formatted = matcher.replaceAll(output);\n                }\n            }\n        }\n        return formatted;\n    }","cleancode":"static string resolve(string message, object[] args) { string formatted = string.format(message, args); for (string key : term_codes.keyset()) { termcode termcode = term_codes.get(key); matcher matcher = termcode.pattern.matcher(formatted); if (matcher.find()) { if ((\"warn\".equals(key) && !warnlevel.get()) || (\"info\".equals(key) && !infolevel.get()) || (\"dbug\".equals(key) && !dbuglevel.get())) { return null; } if (decorated.get()) { string output = iscoloredoutput() ? termcode.output : termcode.noncoloredoutput; formatted = matcher.replaceall(output); } } } return formatted; }","comment":"\/\/ todo - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^ \/\/ todo - to be resolved\n\/\/ this is a log statement for a disabled log-level, skip.","repo":"blangel\/ply","code_context_2":"static String resolve(String message, Object[] args) {\nString formatted = String.format(message, args);\n\/\/ TODO - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n\/\/ TODO - to be resolved\nfor (String key : TERM_CODES.keySet()) {\nTermCode termCode = TERM_CODES.get(key);\n\nif ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n|| (\"dbug\".equals(key) && !dbugLevel.get())) {\n\/\/ this is a log statement for a disabled log-level, skip.\nreturn null;\n}","code_context_10":"static String resolve(String message, Object[] args) {\nString formatted = String.format(message, args);\n\/\/ TODO - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n\/\/ TODO - to be resolved\nfor (String key : TERM_CODES.keySet()) {\nTermCode termCode = TERM_CODES.get(key);\nMatcher matcher = termCode.pattern.matcher(formatted);\nif (matcher.find()) {\nif ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n|| (\"dbug\".equals(key) && !dbugLevel.get())) {\n\/\/ this is a log statement for a disabled log-level, skip.\nreturn null;\n}\nif (decorated.get()) {\n\nstatic String resolve(String message, Object[] args) {\nString formatted = String.format(message, args);\n\/\/ TODO - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n\/\/ TODO - to be resolved\nfor (String key : TERM_CODES.keySet()) {\nTermCode termCode = TERM_CODES.get(key);\nMatcher matcher = termCode.pattern.matcher(formatted);\nif (matcher.find()) {\nif ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n|| (\"dbug\".equals(key) && !dbugLevel.get())) {\n\/\/ this is a log statement for a disabled log-level, skip.\nreturn null;\n}\nif (decorated.get()) {\nString output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\nformatted = matcher.replaceAll(output);\n}\n}\n}\nreturn formatted;\n}","code_context_20":"static String resolve(String message, Object[] args) {\nString formatted = String.format(message, args);\n\/\/ TODO - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n\/\/ TODO - to be resolved\nfor (String key : TERM_CODES.keySet()) {\nTermCode termCode = TERM_CODES.get(key);\nMatcher matcher = termCode.pattern.matcher(formatted);\nif (matcher.find()) {\nif ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n|| (\"dbug\".equals(key) && !dbugLevel.get())) {\n\/\/ this is a log statement for a disabled log-level, skip.\nreturn null;\n}\nif (decorated.get()) {\nString output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\nformatted = matcher.replaceAll(output);\n}\n}\n}\nreturn formatted;\n}\n\nstatic String resolve(String message, Object[] args) {\nString formatted = String.format(message, args);\n\/\/ TODO - fix! this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n\/\/ TODO - to be resolved\nfor (String key : TERM_CODES.keySet()) {\nTermCode termCode = TERM_CODES.get(key);\nMatcher matcher = termCode.pattern.matcher(formatted);\nif (matcher.find()) {\nif ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n|| (\"dbug\".equals(key) && !dbugLevel.get())) {\n\/\/ this is a log statement for a disabled log-level, skip.\nreturn null;\n}\nif (decorated.get()) {\nString output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\nformatted = matcher.replaceAll(output);\n}\n}\n}\nreturn formatted;\n}","label":[0,0,1,0]}
{"id":3003,"original_code":"public void removeSegment(IndexSegment segment) {\n    \/\/ TODO(saurabh): Explain reload scenario here\n    Iterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\n    while (primaryKeyIterator.hasNext()) {\n      PrimaryKey pk = primaryKeyIterator.next();\n      _primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n          (primaryKey, currentSegment) -> {\n            if (currentSegment == segment) {\n              return null;\n            } else {\n              return currentSegment;\n            }\n          });\n    }\n    _serverMetrics.setValueOfPartitionGauge(_tableNameWithType, _partitionId, ServerGauge.DEDUP_PRIMARY_KEYS_COUNT,\n        _primaryKeyToSegmentMap.size());\n  }","code":"public void removeSegment(IndexSegment segment) {\n   \n    Iterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\n    while (primaryKeyIterator.hasNext()) {\n      PrimaryKey pk = primaryKeyIterator.next();\n      _primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n          (primaryKey, currentSegment) -> {\n            if (currentSegment == segment) {\n              return null;\n            } else {\n              return currentSegment;\n            }\n          });\n    }\n    _serverMetrics.setValueOfPartitionGauge(_tableNameWithType, _partitionId, ServerGauge.DEDUP_PRIMARY_KEYS_COUNT,\n        _primaryKeyToSegmentMap.size());\n  }","cleancode":"public void removesegment(indexsegment segment) { iterator<primarykey> primarykeyiterator = getprimarykeyiterator(segment, _primarykeycolumns); while (primarykeyiterator.hasnext()) { primarykey pk = primarykeyiterator.next(); _primarykeytosegmentmap.compute(hashutils.hashprimarykey(pk, _hashfunction), (primarykey, currentsegment) -> { if (currentsegment == segment) { return null; } else { return currentsegment; } }); } _servermetrics.setvalueofpartitiongauge(_tablenamewithtype, _partitionid, servergauge.dedup_primary_keys_count, _primarykeytosegmentmap.size()); }","comment":"\/\/ todo(saurabh): explain reload scenario here","repo":"asf-transfer\/pinot","code_context_2":"public void removeSegment(IndexSegment segment) {\n\/\/ TODO(saurabh): Explain reload scenario here\nIterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\nwhile (primaryKeyIterator.hasNext()) {","code_context_10":"public void removeSegment(IndexSegment segment) {\n\/\/ TODO(saurabh): Explain reload scenario here\nIterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\nwhile (primaryKeyIterator.hasNext()) {\nPrimaryKey pk = primaryKeyIterator.next();\n_primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n(primaryKey, currentSegment) -> {\nif (currentSegment == segment) {\nreturn null;\n} else {\nreturn currentSegment;\n}","code_context_20":"public void removeSegment(IndexSegment segment) {\n\/\/ TODO(saurabh): Explain reload scenario here\nIterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\nwhile (primaryKeyIterator.hasNext()) {\nPrimaryKey pk = primaryKeyIterator.next();\n_primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n(primaryKey, currentSegment) -> {\nif (currentSegment == segment) {\nreturn null;\n} else {\nreturn currentSegment;\n}\n});\n}\n_serverMetrics.setValueOfPartitionGauge(_tableNameWithType, _partitionId, ServerGauge.DEDUP_PRIMARY_KEYS_COUNT,\n_primaryKeyToSegmentMap.size());\n}","label":[0,0,0,0]}
{"id":11202,"original_code":"protected InputStream getContentStream()\n\t\t\t\t\tthrows MessagingException {\n\ttry {\n\tsynchronized(this) {\n\t    if (contentStream == null) {\n\t\tInputStream rawcontent = folder.getProtocol().retr(msgnum,\n\t\t\t\t\tmsgSize > 0 ? msgSize + hdrSize : 0);\n\t\tif (rawcontent == null) {\n\t\t    expunged = true;\n\t\t    throw new MessageRemovedException();    \/\/  XXX - what else?\n\t\t}\n\t\tif (headers == null ||\n\t\t\t((POP3Store)(folder.getStore())).forgetTopHeaders) {\n\t\t    headers = new InternetHeaders(rawcontent);\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t} else {\n\t\t    \/*\n\t\t     * Already have the headers, have to skip the headers\n\t\t     * in the content array and return the body.\n\t\t     *\n\t\t     * XXX - It seems that some mail servers return slightly\n\t\t     * different headers in the RETR results than were returned\n\t\t     * in the TOP results, so we can't depend on remembering\n\t\t     * the size of the headers from the TOP command and just\n\t\t     * skipping that many bytes.  Instead, we have to process\n\t\t     * the content, skipping over the header until we come to\n\t\t     * the empty line that separates the header from the body.\n\t\t     *\/\n\t\t    int offset = 0;\n\t\t    for (;;) {\n\t\t\tint len = 0;\t\/\/ number of bytes in this line\n\t\t\tint c1;\n\t\t\twhile ((c1 = rawcontent.read()) >= 0) {\n\t\t\t    if (c1 == '\\n')\t\/\/ end of line\n\t\t\t\tbreak;\n\t\t\t    else if (c1 == '\\r') {\n\t\t\t\t\/\/ got CR, is the next char LF?\n\t\t\t\tif (rawcontent.available() > 0) {\n\t\t\t\t    rawcontent.mark(1);\n\t\t\t\t    if (rawcontent.read() != '\\n')\n\t\t\t\t\trawcontent.reset();\n\t\t\t\t}\n\t\t\t\tbreak;\t\/\/ in any case, end of line\n\t\t\t    }\n\t\t\t    \/\/ not CR, NL, or CRLF, count the byte\n\t\t\t    len++;\n\t\t\t}\n\t\t\t\/\/ here when end of line or out of data\n\t\t\t\/\/ if out of data, we're done\n\t\t\tif (rawcontent.available() == 0)\n\t\t\t    break;\n\t\t\t\/\/ if it was an empty line, we're done\n\t\t\tif (len == 0)\n\t\t\t    break;\n\t\t    }\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t}\n\t\tcontentStream =\n\t\t    ((SharedInputStream)rawcontent).newStream(hdrSize, -1);\n\t\trawcontent = null;\t\/\/ help GC\n\t    }\n\t}\n\t} catch (EOFException eex) {\n\t    folder.close(false);\n\t    throw new FolderClosedException(folder, eex.toString());\n\t} catch (IOException ex) {\n\t    throw new MessagingException(\"error fetching POP3 content\", ex);\n\t}\n\treturn super.getContentStream();\n    }","code":"protected InputStream getContentStream()\n\t\t\t\t\tthrows MessagingException {\n\ttry {\n\tsynchronized(this) {\n\t    if (contentStream == null) {\n\t\tInputStream rawcontent = folder.getProtocol().retr(msgnum,\n\t\t\t\t\tmsgSize > 0 ? msgSize + hdrSize : 0);\n\t\tif (rawcontent == null) {\n\t\t    expunged = true;\n\t\t    throw new MessageRemovedException();   \n\t\t}\n\t\tif (headers == null ||\n\t\t\t((POP3Store)(folder.getStore())).forgetTopHeaders) {\n\t\t    headers = new InternetHeaders(rawcontent);\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t} else {\n\t\t   \n\t\t    int offset = 0;\n\t\t    for (;;) {\n\t\t\tint len = 0;\n\t\t\tint c1;\n\t\t\twhile ((c1 = rawcontent.read()) >= 0) {\n\t\t\t    if (c1 == '\\n')\n\t\t\t\tbreak;\n\t\t\t    else if (c1 == '\\r') {\n\t\t\t\n\t\t\t\tif (rawcontent.available() > 0) {\n\t\t\t\t    rawcontent.mark(1);\n\t\t\t\t    if (rawcontent.read() != '\\n')\n\t\t\t\t\trawcontent.reset();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t   \n\t\t\t    len++;\n\t\t\t}\n\t\t\n\t\t\n\t\t\tif (rawcontent.available() == 0)\n\t\t\t    break;\n\t\t\n\t\t\tif (len == 0)\n\t\t\t    break;\n\t\t    }\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t}\n\t\tcontentStream =\n\t\t    ((SharedInputStream)rawcontent).newStream(hdrSize, -1);\n\t\trawcontent = null;\n\t    }\n\t}\n\t} catch (EOFException eex) {\n\t    folder.close(false);\n\t    throw new FolderClosedException(folder, eex.toString());\n\t} catch (IOException ex) {\n\t    throw new MessagingException(\"error fetching POP3 content\", ex);\n\t}\n\treturn super.getContentStream();\n    }","cleancode":"protected inputstream getcontentstream() throws messagingexception { try { synchronized(this) { if (contentstream == null) { inputstream rawcontent = folder.getprotocol().retr(msgnum, msgsize > 0 ? msgsize + hdrsize : 0); if (rawcontent == null) { expunged = true; throw new messageremovedexception(); } if (headers == null || ((pop3store)(folder.getstore())).forgettopheaders) { headers = new internetheaders(rawcontent); hdrsize = (int)((sharedinputstream)rawcontent).getposition(); } else { int offset = 0; for (;;) { int len = 0; int c1; while ((c1 = rawcontent.read()) >= 0) { if (c1 == '\\n') break; else if (c1 == '\\r') { if (rawcontent.available() > 0) { rawcontent.mark(1); if (rawcontent.read() != '\\n') rawcontent.reset(); } break; } len++; } if (rawcontent.available() == 0) break; if (len == 0) break; } hdrsize = (int)((sharedinputstream)rawcontent).getposition(); } contentstream = ((sharedinputstream)rawcontent).newstream(hdrsize, -1); rawcontent = null; } } } catch (eofexception eex) { folder.close(false); throw new folderclosedexception(folder, eex.tostring()); } catch (ioexception ex) { throw new messagingexception(\"error fetching pop3 content\", ex); } return super.getcontentstream(); }","comment":"\/** * produce the raw bytes of the content. the data is fetched using * the pop3 retr command. * * @see #contentstream *\/\n\/\/ xxx - what else?\n\/* * already have the headers, have to skip the headers * in the content array and return the body. * * xxx - it seems that some mail servers return slightly * different headers in the retr results than were returned * in the top results, so we can't depend on remembering * the size of the headers from the top command and just * skipping that many bytes. instead, we have to process * the content, skipping over the header until we come to * the empty line that separates the header from the body. *\/\n\/\/ number of bytes in this line\n\/\/ end of line\n\/\/ got cr, is the next char lf?\n\/\/ in any case, end of line\n\/\/ not cr, nl, or crlf, count the byte\n\/\/ here when end of line or out of data \/\/ if out of data, we're done\n\/\/ if it was an empty line, we're done\n\/\/ help gc","repo":"cesarmo759\/android_kernel_samsung_msm8916","code_context_2":"protected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}\n\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\n\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\n\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\n\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\n\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}","code_context_10":"protected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}\n\nprotected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\n\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\n\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\n\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}","code_context_20":"protected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}\n\nprotected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\n\nprotected InputStream getContentStream()\nthrows MessagingException {\ntry {\nsynchronized(this) {\nif (contentStream == null) {\nInputStream rawcontent = folder.getProtocol().retr(msgnum,\nmsgSize > 0 ? msgSize + hdrSize : 0);\nif (rawcontent == null) {\nexpunged = true;\nthrow new MessageRemovedException(); \/\/ XXX - what else?\n}\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\nif (headers == null ||\n((POP3Store)(folder.getStore())).forgetTopHeaders) {\nheaders = new InternetHeaders(rawcontent);\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n} else {\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n\n\/*\n* Already have the headers, have to skip the headers\n* in the content array and return the body.\n*\n* XXX - It seems that some mail servers return slightly\n* different headers in the RETR results than were returned\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n\n* in the TOP results, so we can't depend on remembering\n* the size of the headers from the TOP command and just\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n\n* skipping that many bytes. Instead, we have to process\n* the content, skipping over the header until we come to\n* the empty line that separates the header from the body.\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\n\n*\/\nint offset = 0;\nfor (;;) {\nint len = 0; \/\/ number of bytes in this line\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\n\nint c1;\nwhile ((c1 = rawcontent.read()) >= 0) {\nif (c1 == '\\n') \/\/ end of line\nbreak;\nelse if (c1 == '\\r') {\n\/\/ got CR, is the next char LF?\nif (rawcontent.available() > 0) {\nrawcontent.mark(1);\nif (rawcontent.read() != '\\n')\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}\n\nrawcontent.reset();\n}\nbreak; \/\/ in any case, end of line\n}\n\/\/ not CR, NL, or CRLF, count the byte\nlen++;\n}\n\/\/ here when end of line or out of data\n\/\/ if out of data, we're done\nif (rawcontent.available() == 0)\nbreak;\n\/\/ if it was an empty line, we're done\nif (len == 0)\nbreak;\n}\nhdrSize =\n(int)((SharedInputStream)rawcontent).getPosition();\n}\ncontentStream =\n((SharedInputStream)rawcontent).newStream(hdrSize, -1);\nrawcontent = null; \/\/ help GC\n}\n}\n} catch (EOFException eex) {\nfolder.close(false);\nthrow new FolderClosedException(folder, eex.toString());\n} catch (IOException ex) {\nthrow new MessagingException(\"error fetching POP3 content\", ex);\n}\nreturn super.getContentStream();\n}","label":[1,0,0,0]}
{"id":11203,"original_code":"public void setHeader(String name, String value)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code":"public void setHeader(String name, String value)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void setheader(string name, string value) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","comment":"\/** * set the value for this header_name. throws illegalwriteexception * because pop3 messages are read-only. * * @param name header name * @param value header value * @see javax.mail.internet.mimeutility * @exception illegalwriteexception because the underlying * implementation does not support modification * @exception illegalstateexception if this message is * obtained from a read_only folder. *\/\n\/\/ xxx - should check for read-only folder?","repo":"cesarmo759\/android_kernel_samsung_msm8916","code_context_2":"public void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_10":"public void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_20":"public void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void setHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","label":[0,1,0,0]}
{"id":11204,"original_code":"public void addHeader(String name, String value)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code":"public void addHeader(String name, String value)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void addheader(string name, string value) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","comment":"\/** * add this value to the existing values for this header_name. * throws illegalwriteexception because pop3 messages are read-only. * * @param name header name * @param value header value * @see javax.mail.internet.mimeutility * @exception illegalwriteexception because the underlying * implementation does not support modification * @exception illegalstateexception if this message is * obtained from a read_only folder. *\/\n\/\/ xxx - should check for read-only folder?","repo":"cesarmo759\/android_kernel_samsung_msm8916","code_context_2":"public void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_10":"public void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_20":"public void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeader(String name, String value)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","label":[0,1,0,0]}
{"id":11205,"original_code":"public void removeHeader(String name)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code":"public void removeHeader(String name)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void removeheader(string name) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","comment":"\/** * remove all headers with this name. * throws illegalwriteexception because pop3 messages are read-only. * * @exception illegalwriteexception because the underlying * implementation does not support modification * @exception illegalstateexception if this message is * obtained from a read_only folder. *\/\n\/\/ xxx - should check for read-only folder?","repo":"cesarmo759\/android_kernel_samsung_msm8916","code_context_2":"public void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_10":"public void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_20":"public void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void removeHeader(String name)\nthrows MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","label":[0,1,0,0]}
{"id":11206,"original_code":"public void addHeaderLine(String line) throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code":"public void addHeaderLine(String line) throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void addheaderline(string line) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","comment":"\/** * add a raw rfc822 header-line. * throws illegalwriteexception because pop3 messages are read-only. * * @exception illegalwriteexception because the underlying * implementation does not support modification * @exception illegalstateexception if this message is * obtained from a read_only folder. *\/\n\/\/ xxx - should check for read-only folder?","repo":"cesarmo759\/android_kernel_samsung_msm8916","code_context_2":"public void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_10":"public void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","code_context_20":"public void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}\n\npublic void addHeaderLine(String line) throws MessagingException {\n\/\/ XXX - should check for read-only folder?\nthrow new IllegalWriteException(\"POP3 messages are read-only\");\n}","label":[0,1,0,0]}
{"id":11257,"original_code":"private void findEvents(Context context, String name, MultiName multiName, int pos, Watcher watcher, ReferenceValue ref)\n    {\n        String srcTypeName = null;\n        if (watcher.isPartOfAnonObjectGraph())\n        {\n            srcTypeName = standardDefs.CLASS_OBJECTPROXY;\n        }\n        else if (! srcTypeStack.empty())\n        {\n            srcTypeName = srcTypeStack.peek();\n        }\n        Watcher parentWatcher = watcher.getParent();\n        if ((parentWatcher != null) && parentWatcher.isOperation())\n        {\n            watcher.addChangeEvent(\"resultForBinding\");\n        }\n        else if (srcTypeName != null)\n        {\n            AbcClass watchedClass = typeTable.getClass(srcTypeName);\n            if (watchedClass != null)\n            {\n                if ( watchedClass.isSubclassOf(standardDefs.CLASS_OBJECTPROXY) )\n                {\n                    watcher.setPartOfAnonObjectGraph(true);\n                }\n                List metaData = watchedClass.getMetaData(BINDABLE, true);\n                boolean foundEvents = addBindables(watcher, metaData);\n                boolean foundSource = false;\n                Variable variable = getVariable(context, watchedClass, ref, multiName);\n                if (variable != null)\n                {\n                    metaData = variable.getMetaData(BINDABLE);\n                    foundEvents = addBindables(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(CHANGE_EVENT);\n                    foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                    foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                    \/\/ Object has a public static const variable names \"length\", which is\n                    \/\/ some legacy compatibility crap left over from EMCA script 262, so\n                    \/\/ we ignore it.\n                    if (variable.isConst() &&\n                        !(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        \/\/ We didn't really find any events, but we want\n                        \/\/ to follow the same code path below as if we did.\n                        foundEvents = true;\n                        \/\/    TODO will this ever be something besides a PropertyWatcher?\n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher) watcher).suppress();\n                        }\n                    }\n                    \/\/ See comment above.\n                    if (!(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        checkForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n                    }\n                    foundSource = true;\n                }\n                if (!foundEvents)\n                {\n                    Method getter = getGetter(context, watchedClass, ref, multiName);\n                    if (getter != null)\n                    {\n                        metaData = getter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\n                        checkForStaticProperty(getter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    Method setter = getSetter(context, watchedClass, ref, multiName);\n                    if (setter != null)\n                    {\n                        metaData = setter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        checkForStaticProperty(setter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    else\n                    {\n                        if (getter != null)\n                        {\n                            \/\/    getters without setters are de facto const, use same bypass as above for const vars\n                            foundEvents = true;\n                        }\n                    }\n                }\n                if (!foundSource)\n                {\n                    Method function = getMethod(context, watchedClass, ref, multiName);\n                    if (function != null)\n                    {\n                        metaData = function.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        foundSource = true;\n                        if (!foundEvents && callExpressionStack.isEmpty())\n                        {\n                            foundEvents = true;\n                            \/\/    TODO will this ever be something besides a PropertyWatcher?\n                            if (watcher instanceof PropertyWatcher)\n                            {\n                                ((PropertyWatcher)watcher).suppress();\n                            }\n                        }\n                    }\n                }\n                if ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n                {\n                    watcher.setOperation(true);\n                }\n                else if (!foundEvents &&\n                         !(watcher instanceof FunctionReturnWatcher) &&\n                         !(watcher instanceof XMLWatcher) &&\n                         !watcher.isOperation())\n                {\n                    \/***\n                     * NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n                     * ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n                     * of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n                     * actual type of the actual value being assigned to the property.\n                     * OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n                     *\/\n                    if (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n                    {\n                        \/\/    TODO do we still want this to be configurable?\n                        if (showBindingWarnings)\n                        {\n                            context.localizedWarning2(pos, new UnableToDetectChanges(name));\n                        }\n                        \/\/    TODO will this ever be something besides a PropertyWatcher?\n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher)watcher).suppress();\n                        }\n                    }\n                }\n            }\n        }\n    }","code":"private void findEvents(Context context, String name, MultiName multiName, int pos, Watcher watcher, ReferenceValue ref)\n    {\n        String srcTypeName = null;\n        if (watcher.isPartOfAnonObjectGraph())\n        {\n            srcTypeName = standardDefs.CLASS_OBJECTPROXY;\n        }\n        else if (! srcTypeStack.empty())\n        {\n            srcTypeName = srcTypeStack.peek();\n        }\n        Watcher parentWatcher = watcher.getParent();\n        if ((parentWatcher != null) && parentWatcher.isOperation())\n        {\n            watcher.addChangeEvent(\"resultForBinding\");\n        }\n        else if (srcTypeName != null)\n        {\n            AbcClass watchedClass = typeTable.getClass(srcTypeName);\n            if (watchedClass != null)\n            {\n                if ( watchedClass.isSubclassOf(standardDefs.CLASS_OBJECTPROXY) )\n                {\n                    watcher.setPartOfAnonObjectGraph(true);\n                }\n                List metaData = watchedClass.getMetaData(BINDABLE, true);\n                boolean foundEvents = addBindables(watcher, metaData);\n                boolean foundSource = false;\n                Variable variable = getVariable(context, watchedClass, ref, multiName);\n                if (variable != null)\n                {\n                    metaData = variable.getMetaData(BINDABLE);\n                    foundEvents = addBindables(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(CHANGE_EVENT);\n                    foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                    foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                   \n                   \n                   \n                    if (variable.isConst() &&\n                        !(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                       \n                       \n                        foundEvents = true;\n                       \n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher) watcher).suppress();\n                        }\n                    }\n                   \n                    if (!(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        checkForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n                    }\n                    foundSource = true;\n                }\n                if (!foundEvents)\n                {\n                    Method getter = getGetter(context, watchedClass, ref, multiName);\n                    if (getter != null)\n                    {\n                        metaData = getter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\n                        checkForStaticProperty(getter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    Method setter = getSetter(context, watchedClass, ref, multiName);\n                    if (setter != null)\n                    {\n                        metaData = setter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        checkForStaticProperty(setter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    else\n                    {\n                        if (getter != null)\n                        {\n                           \n                            foundEvents = true;\n                        }\n                    }\n                }\n                if (!foundSource)\n                {\n                    Method function = getMethod(context, watchedClass, ref, multiName);\n                    if (function != null)\n                    {\n                        metaData = function.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        foundSource = true;\n                        if (!foundEvents && callExpressionStack.isEmpty())\n                        {\n                            foundEvents = true;\n                           \n                            if (watcher instanceof PropertyWatcher)\n                            {\n                                ((PropertyWatcher)watcher).suppress();\n                            }\n                        }\n                    }\n                }\n                if ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n                {\n                    watcher.setOperation(true);\n                }\n                else if (!foundEvents &&\n                         !(watcher instanceof FunctionReturnWatcher) &&\n                         !(watcher instanceof XMLWatcher) &&\n                         !watcher.isOperation())\n                {\n                   \n                    if (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n                    {\n                       \n                        if (showBindingWarnings)\n                        {\n                            context.localizedWarning2(pos, new UnableToDetectChanges(name));\n                        }\n                       \n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher)watcher).suppress();\n                        }\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void findevents(context context, string name, multiname multiname, int pos, watcher watcher, referencevalue ref) { string srctypename = null; if (watcher.ispartofanonobjectgraph()) { srctypename = standarddefs.class_objectproxy; } else if (! srctypestack.empty()) { srctypename = srctypestack.peek(); } watcher parentwatcher = watcher.getparent(); if ((parentwatcher != null) && parentwatcher.isoperation()) { watcher.addchangeevent(\"resultforbinding\"); } else if (srctypename != null) { abcclass watchedclass = typetable.getclass(srctypename); if (watchedclass != null) { if ( watchedclass.issubclassof(standarddefs.class_objectproxy) ) { watcher.setpartofanonobjectgraph(true); } list metadata = watchedclass.getmetadata(bindable, true); boolean foundevents = addbindables(watcher, metadata); boolean foundsource = false; variable variable = getvariable(context, watchedclass, ref, multiname); if (variable != null) { metadata = variable.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = variable.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = variable.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; if (variable.isconst() && !(multiname.getlocalpart().equals(\"length\") && variable.getdeclaringclassname().equals(symboltable.object))) { foundevents = true; if (watcher instanceof propertywatcher) { ((propertywatcher) watcher).suppress(); } } if (!(multiname.getlocalpart().equals(\"length\") && variable.getdeclaringclassname().equals(symboltable.object))) { checkforstaticproperty(variable.isstatic(), watcher, srctypename); } foundsource = true; } if (!foundevents) { method getter = getgetter(context, watchedclass, ref, multiname); if (getter != null) { metadata = getter.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = getter.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = getter.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents( watcher, metadata) || foundevents; checkforstaticproperty(getter.isstatic(), watcher, srctypename); foundsource = true; } method setter = getsetter(context, watchedclass, ref, multiname); if (setter != null) { metadata = setter.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = setter.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = setter.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; checkforstaticproperty(setter.isstatic(), watcher, srctypename); foundsource = true; } else { if (getter != null) { foundevents = true; } } } if (!foundsource) { method function = getmethod(context, watchedclass, ref, multiname); if (function != null) { metadata = function.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = function.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = function.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; foundsource = true; if (!foundevents && callexpressionstack.isempty()) { foundevents = true; if (watcher instanceof propertywatcher) { ((propertywatcher)watcher).suppress(); } } } } if ((!foundsource) && watchedclass.issubclassof(standarddefs.class_abstractservice)) { watcher.setoperation(true); } else if (!foundevents && !(watcher instanceof functionreturnwatcher) && !(watcher instanceof xmlwatcher) && !watcher.isoperation()) { if (!(watchedclass.getname().equals(symboltable.object) || watchedclass.getname().equals(symboltable.notype))) { if (showbindingwarnings) { context.localizedwarning2(pos, new unabletodetectchanges(name)); } if (watcher instanceof propertywatcher) { ((propertywatcher)watcher).suppress(); } } } } } }","comment":"\/\/ object has a public static const variable names \"length\", which is \/\/ some legacy compatibility crap left over from emca script 262, so \/\/ we ignore it.\n\/\/ we didn't really find any events, but we want \/\/ to follow the same code path below as if we did.\n\/\/ todo will this ever be something besides a propertywatcher?\n\/\/ see comment above.\n\/\/ getters without setters are de facto const, use same bypass as above for const vars\n\/\/ todo will this ever be something besides a propertywatcher?\n\/*** * note: when we've failed to find change events for properties of untyped or object-typed parents, we go * ahead and generate code to create a runtime propertywatcher with no change events specified. the lack * of change events tells the runtime pw to introspect rtti to discover change events associated with the * actual type of the actual value being assigned to the property. * otoh for strongly-typed properties, we still require change events to be reachable at compile time. *\/\n\/\/ todo do we still want this to be configurable?\n\/\/ todo will this ever be something besides a propertywatcher?","repo":"blackjyn\/flex-sdk","code_context_2":"metaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\n\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\n\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n\nif (getter != null)\n{\n\/\/ getters without setters are de facto const, use same bypass as above for const vars\nfoundEvents = true;\n}\n\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n\n!watcher.isOperation())\n{\n\/***\n* NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n* ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n* of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n* actual type of the actual value being assigned to the property.\n* OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n*\/\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\/\/ TODO do we still want this to be configurable?\nif (showBindingWarnings)\n{\n\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{","code_context_10":"boolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\n\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\ncheckForStaticProperty(setter.isStatic(), watcher, srcTypeName);\nfoundSource = true;\n}\nelse\n{\nif (getter != null)\n{\n\/\/ getters without setters are de facto const, use same bypass as above for const vars\nfoundEvents = true;\n}\n}\n}\nif (!foundSource)\n{\nMethod function = getMethod(context, watchedClass, ref, multiName);\nif (function != null)\n{\nmetaData = function.getMetaData(BINDABLE);\n\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n\n}\nif ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n{\nwatcher.setOperation(true);\n}\nelse if (!foundEvents &&\n!(watcher instanceof FunctionReturnWatcher) &&\n!(watcher instanceof XMLWatcher) &&\n!watcher.isOperation())\n{\n\/***\n* NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n* ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n* of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n* actual type of the actual value being assigned to the property.\n* OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n*\/\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\/\/ TODO do we still want this to be configurable?\nif (showBindingWarnings)\n{\ncontext.localizedWarning2(pos, new UnableToDetectChanges(name));\n}\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n\n{\n\/***\n* NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n* ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n* of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n* actual type of the actual value being assigned to the property.\n* OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n*\/\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\/\/ TODO do we still want this to be configurable?\nif (showBindingWarnings)\n{\ncontext.localizedWarning2(pos, new UnableToDetectChanges(name));\n}\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher)watcher).suppress();\n}\n}\n\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);","code_context_20":"{\nAbcClass watchedClass = typeTable.getClass(srcTypeName);\nif (watchedClass != null)\n{\nif ( watchedClass.isSubclassOf(standardDefs.CLASS_OBJECTPROXY) )\n{\nwatcher.setPartOfAnonObjectGraph(true);\n}\nList metaData = watchedClass.getMetaData(BINDABLE, true);\nboolean foundEvents = addBindables(watcher, metaData);\nboolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n\n}\nList metaData = watchedClass.getMetaData(BINDABLE, true);\nboolean foundEvents = addBindables(watcher, metaData);\nboolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\nif (getter != null)\n{\n\nboolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\nif (getter != null)\n{\nmetaData = getter.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\n\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\nif (getter != null)\n{\nmetaData = getter.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = getter.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = getter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\ncheckForStaticProperty(getter.isStatic(), watcher, srcTypeName);\nfoundSource = true;\n\nfoundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\ncheckForStaticProperty(getter.isStatic(), watcher, srcTypeName);\nfoundSource = true;\n}\nMethod setter = getSetter(context, watchedClass, ref, multiName);\nif (setter != null)\n{\nmetaData = setter.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = setter.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\ncheckForStaticProperty(setter.isStatic(), watcher, srcTypeName);\nfoundSource = true;\n}\nelse\n{\nif (getter != null)\n{\n\/\/ getters without setters are de facto const, use same bypass as above for const vars\nfoundEvents = true;\n}\n}\n}\nif (!foundSource)\n{\nMethod function = getMethod(context, watchedClass, ref, multiName);\nif (function != null)\n{\nmetaData = function.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = function.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = function.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\nfoundSource = true;\nif (!foundEvents && callExpressionStack.isEmpty())\n{\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\n\nboolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\nif (getter != null)\n{\nmetaData = getter.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\n\nif (!foundEvents && callExpressionStack.isEmpty())\n{\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher)watcher).suppress();\n}\n}\n}\n}\nif ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n{\nwatcher.setOperation(true);\n}\nelse if (!foundEvents &&\n!(watcher instanceof FunctionReturnWatcher) &&\n!(watcher instanceof XMLWatcher) &&\n!watcher.isOperation())\n{\n\/***\n* NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n* ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n* of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n* actual type of the actual value being assigned to the property.\n* OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n*\/\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\/\/ TODO do we still want this to be configurable?\nif (showBindingWarnings)\n{\ncontext.localizedWarning2(pos, new UnableToDetectChanges(name));\n}\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher)watcher).suppress();\n}\n}\n}\n}\n}\n}\n\n}\n}\nif ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n{\nwatcher.setOperation(true);\n}\nelse if (!foundEvents &&\n!(watcher instanceof FunctionReturnWatcher) &&\n!(watcher instanceof XMLWatcher) &&\n!watcher.isOperation())\n{\n\/***\n* NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n* ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n* of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n* actual type of the actual value being assigned to the property.\n* OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n*\/\nif (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n{\n\/\/ TODO do we still want this to be configurable?\nif (showBindingWarnings)\n{\ncontext.localizedWarning2(pos, new UnableToDetectChanges(name));\n}\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher)watcher).suppress();\n}\n}\n}\n}\n}\n}\n\nboolean foundSource = false;\nVariable variable = getVariable(context, watchedClass, ref, multiName);\nif (variable != null)\n{\nmetaData = variable.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(CHANGE_EVENT);\nfoundEvents = addChangeEvents(watcher, metaData) || foundEvents;\nmetaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\nfoundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n\/\/ Object has a public static const variable names \"length\", which is\n\/\/ some legacy compatibility crap left over from EMCA script 262, so\n\/\/ we ignore it.\nif (variable.isConst() &&\n!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\n\/\/ We didn't really find any events, but we want\n\/\/ to follow the same code path below as if we did.\nfoundEvents = true;\n\/\/ TODO will this ever be something besides a PropertyWatcher?\nif (watcher instanceof PropertyWatcher)\n{\n((PropertyWatcher) watcher).suppress();\n}\n}\n\/\/ See comment above.\nif (!(multiName.getLocalPart().equals(\"length\") &&\nvariable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n{\ncheckForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n}\nfoundSource = true;\n}\nif (!foundEvents)\n{\nMethod getter = getGetter(context, watchedClass, ref, multiName);\nif (getter != null)\n{\nmetaData = getter.getMetaData(BINDABLE);\nfoundEvents = addBindables(watcher, metaData) || foundEvents;","label":[1,0,0,0]}
{"id":11345,"original_code":"@Override\n    public void show() {\n        super.show();\n        this.x = r.nextFloat();\n        this.y = r.nextFloat();\n        float angle = r.nextFloat() * 2 * 3.14159f;\n        this.vx = (float)java.lang.Math.cos(angle);\n        this.vy = (float)java.lang.Math.sin(angle);\n        \/\/todo instead of going back to main menu, pause the game with pause screen?\n        Gdx.input.setCatchBackKey(true);\n        getStage().addListener(new InputListener() {\n            @Override\n            public boolean keyUp(InputEvent event, int keycode) {\n                if (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\n                    app.setScreen(app.getMainScreen());\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n    }","code":"@Override\n    public void show() {\n        super.show();\n        this.x = r.nextFloat();\n        this.y = r.nextFloat();\n        float angle = r.nextFloat() * 2 * 3.14159f;\n        this.vx = (float)java.lang.Math.cos(angle);\n        this.vy = (float)java.lang.Math.sin(angle);\n       \n        Gdx.input.setCatchBackKey(true);\n        getStage().addListener(new InputListener() {\n            @Override\n            public boolean keyUp(InputEvent event, int keycode) {\n                if (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\n                    app.setScreen(app.getMainScreen());\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n    }","cleancode":"@override public void show() { super.show(); this.x = r.nextfloat(); this.y = r.nextfloat(); float angle = r.nextfloat() * 2 * 3.14159f; this.vx = (float)java.lang.math.cos(angle); this.vy = (float)java.lang.math.sin(angle); gdx.input.setcatchbackkey(true); getstage().addlistener(new inputlistener() { @override public boolean keyup(inputevent event, int keycode) { if (keycode == input.keys.back || keycode == input.keys.escape) { app.setscreen(app.getmainscreen()); return true; } else { return false; } } }); }","comment":"\/\/todo instead of going back to main menu, pause the game with pause screen?","repo":"cmsd2\/toyapp","code_context_2":"this.vx = (float)java.lang.Math.cos(angle);\nthis.vy = (float)java.lang.Math.sin(angle);\n\/\/todo instead of going back to main menu, pause the game with pause screen?\nGdx.input.setCatchBackKey(true);\ngetStage().addListener(new InputListener() {","code_context_10":"@Override\npublic void show() {\nsuper.show();\nthis.x = r.nextFloat();\nthis.y = r.nextFloat();\nfloat angle = r.nextFloat() * 2 * 3.14159f;\nthis.vx = (float)java.lang.Math.cos(angle);\nthis.vy = (float)java.lang.Math.sin(angle);\n\/\/todo instead of going back to main menu, pause the game with pause screen?\nGdx.input.setCatchBackKey(true);\ngetStage().addListener(new InputListener() {\n@Override\npublic boolean keyUp(InputEvent event, int keycode) {\nif (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\napp.setScreen(app.getMainScreen());\nreturn true;\n} else {\nreturn false;\n}","code_context_20":"@Override\npublic void show() {\nsuper.show();\nthis.x = r.nextFloat();\nthis.y = r.nextFloat();\nfloat angle = r.nextFloat() * 2 * 3.14159f;\nthis.vx = (float)java.lang.Math.cos(angle);\nthis.vy = (float)java.lang.Math.sin(angle);\n\/\/todo instead of going back to main menu, pause the game with pause screen?\nGdx.input.setCatchBackKey(true);\ngetStage().addListener(new InputListener() {\n@Override\npublic boolean keyUp(InputEvent event, int keycode) {\nif (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\napp.setScreen(app.getMainScreen());\nreturn true;\n} else {\nreturn false;\n}\n}\n});\n}","label":[1,0,0,0]}
{"id":19729,"original_code":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\t\n\t}","cleancode":"public void getstatusoperation(org.oasis_open.docs.ws_tx.wsba._2006._06.getstatus param5) { }","comment":"\/** * auto generated method signature * * @param param5 * *\/\n\/\/ todo fill this with the necessary business logic","repo":"apache\/kandula","code_context_2":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}","code_context_10":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}","code_context_20":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\/\/ Todo fill this with the necessary business logic\n}","label":[0,1,0,0]}
{"id":19730,"original_code":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n\t{\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n\t{\n\t\n\t}","cleancode":"public void notcompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.notcompleted param6) { }","comment":"\/** * auto generated method signature * * @param param6 * *\/\n\/\/ todo fill this with the necessary business logic","repo":"apache\/kandula","code_context_2":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}","code_context_10":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}","code_context_20":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n{\n\/\/ Todo fill this with the necessary business logic\n}","label":[0,1,0,0]}
{"id":19731,"original_code":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n\t{\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n\t{\n\t\n\t}","cleancode":"public void statusoperation(org.oasis_open.docs.ws_tx.wsba._2006._06.status param7) { }","comment":"\/** * auto generated method signature * * @param param7 * *\/\n\/\/ todo fill this with the necessary business logic","repo":"apache\/kandula","code_context_2":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}","code_context_10":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}","code_context_20":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}\n\npublic void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n{\n\/\/ Todo fill this with the necessary business logic\n}","label":[0,1,0,0]}
{"id":11728,"original_code":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\n        GenomicLocation normalizedGenomicLocation = new GenomicLocation();\n        \/\/ if original input is set in the incoming genomic location object then use the same value\n        \/\/ for the normalized genomic location object returned, otherwise set it to the\n        \/\/ string representation of the incoming genomic location object\n        if (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n        } else {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n        }\n        \/\/ normalize chromosome name\n        String chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\n        normalizedGenomicLocation.setChromosome(chr);\n        \/\/ convert vcf style start,end,ref,alt to MAF style\n        Integer start = genomicLocation.getStart();\n        Integer end = genomicLocation.getEnd();\n        String ref = genomicLocation.getReferenceAllele().trim();\n        String var = genomicLocation.getVariantAllele().trim();\n        String prefix = \"\";\n        if (!ref.equals(var)) {\n            prefix = longestCommonPrefix(ref, var);\n        }\n        \/\/ Remove common prefix and adjust variant position accordingly\n        if (prefix.length() > 0) {\n            ref = ref.substring(prefix.length());\n            var = var.substring(prefix.length());\n            int nStart = start + prefix.length();\n            if (ref.length() == 0) {\n                nStart -= 1;\n            }\n            start = nStart;\n        }\n        normalizedGenomicLocation.setStart(start);\n        normalizedGenomicLocation.setEnd(end);\n        normalizedGenomicLocation.setReferenceAllele(ref);\n        normalizedGenomicLocation.setVariantAllele(var);\n        return normalizedGenomicLocation;\n    }","code":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\n        GenomicLocation normalizedGenomicLocation = new GenomicLocation();\n       \n       \n       \n        if (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n        } else {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n        }\n       \n        String chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\n        normalizedGenomicLocation.setChromosome(chr);\n       \n        Integer start = genomicLocation.getStart();\n        Integer end = genomicLocation.getEnd();\n        String ref = genomicLocation.getReferenceAllele().trim();\n        String var = genomicLocation.getVariantAllele().trim();\n        String prefix = \"\";\n        if (!ref.equals(var)) {\n            prefix = longestCommonPrefix(ref, var);\n        }\n       \n        if (prefix.length() > 0) {\n            ref = ref.substring(prefix.length());\n            var = var.substring(prefix.length());\n            int nStart = start + prefix.length();\n            if (ref.length() == 0) {\n                nStart -= 1;\n            }\n            start = nStart;\n        }\n        normalizedGenomicLocation.setStart(start);\n        normalizedGenomicLocation.setEnd(end);\n        normalizedGenomicLocation.setReferenceAllele(ref);\n        normalizedGenomicLocation.setVariantAllele(var);\n        return normalizedGenomicLocation;\n    }","cleancode":"public genomiclocation normalizegenomiclocation(genomiclocation genomiclocation) { genomiclocation normalizedgenomiclocation = new genomiclocation(); if (genomiclocation.getoriginalinput() != null && !genomiclocation.getoriginalinput().isempty()) { normalizedgenomiclocation.setoriginalinput(genomiclocation.getoriginalinput()); } else { normalizedgenomiclocation.setoriginalinput(genomiclocation.tostring()); } string chr = chromosomenormalizer(genomiclocation.getchromosome().trim()); normalizedgenomiclocation.setchromosome(chr); integer start = genomiclocation.getstart(); integer end = genomiclocation.getend(); string ref = genomiclocation.getreferenceallele().trim(); string var = genomiclocation.getvariantallele().trim(); string prefix = \"\"; if (!ref.equals(var)) { prefix = longestcommonprefix(ref, var); } if (prefix.length() > 0) { ref = ref.substring(prefix.length()); var = var.substring(prefix.length()); int nstart = start + prefix.length(); if (ref.length() == 0) { nstart -= 1; } start = nstart; } normalizedgenomiclocation.setstart(start); normalizedgenomiclocation.setend(end); normalizedgenomiclocation.setreferenceallele(ref); normalizedgenomiclocation.setvariantallele(var); return normalizedgenomiclocation; }","comment":"\/* * normalize genomic location: * * 1. convert vcf style start,end,ref,alt to maf by looking for common * prefix. (todo: not sure if this is always a good idea) * 2. normalize chromsome names. *\/\n\/\/ if original input is set in the incoming genomic location object then use the same value \/\/ for the normalized genomic location object returned, otherwise set it to the \/\/ string representation of the incoming genomic location object\n\/\/ normalize chromosome name\n\/\/ convert vcf style start,end,ref,alt to maf style\n\/\/ remove common prefix and adjust variant position accordingly","repo":"as1000\/genome-nexus","code_context_2":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);\nnormalizedGenomicLocation.setEnd(end);\nnormalizedGenomicLocation.setReferenceAllele(ref);\nnormalizedGenomicLocation.setVariantAllele(var);\nreturn normalizedGenomicLocation;\n}\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\n\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());","code_context_10":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);\nnormalizedGenomicLocation.setEnd(end);\nnormalizedGenomicLocation.setReferenceAllele(ref);\nnormalizedGenomicLocation.setVariantAllele(var);\nreturn normalizedGenomicLocation;\n}\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\n\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);","code_context_20":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);\nnormalizedGenomicLocation.setEnd(end);\nnormalizedGenomicLocation.setReferenceAllele(ref);\nnormalizedGenomicLocation.setVariantAllele(var);\nreturn normalizedGenomicLocation;\n}\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n\npublic GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\nGenomicLocation normalizedGenomicLocation = new GenomicLocation();\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);\nnormalizedGenomicLocation.setEnd(end);\n\n\/\/ if original input is set in the incoming genomic location object then use the same value\n\/\/ for the normalized genomic location object returned, otherwise set it to the\n\/\/ string representation of the incoming genomic location object\nif (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n} else {\nnormalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n}\n\/\/ normalize chromosome name\nString chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\nnormalizedGenomicLocation.setChromosome(chr);\n\/\/ convert vcf style start,end,ref,alt to MAF style\nInteger start = genomicLocation.getStart();\nInteger end = genomicLocation.getEnd();\nString ref = genomicLocation.getReferenceAllele().trim();\nString var = genomicLocation.getVariantAllele().trim();\nString prefix = \"\";\nif (!ref.equals(var)) {\nprefix = longestCommonPrefix(ref, var);\n}\n\/\/ Remove common prefix and adjust variant position accordingly\nif (prefix.length() > 0) {\nref = ref.substring(prefix.length());\nvar = var.substring(prefix.length());\nint nStart = start + prefix.length();\nif (ref.length() == 0) {\nnStart -= 1;\n}\nstart = nStart;\n}\nnormalizedGenomicLocation.setStart(start);\nnormalizedGenomicLocation.setEnd(end);\nnormalizedGenomicLocation.setReferenceAllele(ref);\nnormalizedGenomicLocation.setVariantAllele(var);\nreturn normalizedGenomicLocation;\n}","label":[1,0,0,0]}
{"id":20003,"original_code":"public Builder withOriginalCourseId(final String originalCourseId) {\n            getObject().setOriginalCourseId(originalCourseId);\n            return thisBuilder();\n        }","code":"public Builder withOriginalCourseId(final String originalCourseId) {\n            getObject().setOriginalCourseId(originalCourseId);\n            return thisBuilder();\n        }","cleancode":"public builder withoriginalcourseid(final string originalcourseid) { getobject().setoriginalcourseid(originalcourseid); return thisbuilder(); }","comment":"\/** * todo: \"previous course\" and \"original course\" appear to be separate * concepts; comment needs revision to explain a bit more. * * sets the previous course code if present. * * @param originalcourseid the original course id. * @return thisbuilder *\/","repo":"bcgov\/EDUC-GRAD-REPORT-API","code_context_2":"public Builder withOriginalCourseId(final String originalCourseId) {\ngetObject().setOriginalCourseId(originalCourseId);\nreturn thisBuilder();\n}","code_context_10":"public Builder withOriginalCourseId(final String originalCourseId) {\ngetObject().setOriginalCourseId(originalCourseId);\nreturn thisBuilder();\n}","code_context_20":"public Builder withOriginalCourseId(final String originalCourseId) {\ngetObject().setOriginalCourseId(originalCourseId);\nreturn thisBuilder();\n}","label":[1,0,0,0]}
{"id":3835,"original_code":"protected Serializable[] getParamValues(Serializable[] rawParamValues) throws SQLException\n    {\n        int nonPositionedParametersCount = 0;\n        for (Serializable rawParamValue : rawParamValues)\n        {\n            if (rawParamValue != null && rawParamValue instanceof NonPositionedParameter) ++nonPositionedParametersCount;\n        }\n        Serializable[] paramValues = new Serializable[parameterNames.size() + nonPositionedParametersCount];\n        Entity entity = (Entity)Optional.ofNullable(getParent()).filter(x -> x instanceof Entity).orElse(null);\n        if (entity == null)\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                paramValues[i] = rawParamValues[paramMapping[i]];\n            }\n        }\n        else\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                String paramName = parameterNames.get(i);\n                paramValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n            }\n        }\n        \/\/ non positioned parameters should always be given last (CB TODO - document)\n        for (int i = 0; i < nonPositionedParametersCount; ++i)\n        {\n            paramValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n        }\n        return paramValues;\n    }","code":"protected Serializable[] getParamValues(Serializable[] rawParamValues) throws SQLException\n    {\n        int nonPositionedParametersCount = 0;\n        for (Serializable rawParamValue : rawParamValues)\n        {\n            if (rawParamValue != null && rawParamValue instanceof NonPositionedParameter) ++nonPositionedParametersCount;\n        }\n        Serializable[] paramValues = new Serializable[parameterNames.size() + nonPositionedParametersCount];\n        Entity entity = (Entity)Optional.ofNullable(getParent()).filter(x -> x instanceof Entity).orElse(null);\n        if (entity == null)\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                paramValues[i] = rawParamValues[paramMapping[i]];\n            }\n        }\n        else\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                String paramName = parameterNames.get(i);\n                paramValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n            }\n        }\n       \n        for (int i = 0; i < nonPositionedParametersCount; ++i)\n        {\n            paramValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n        }\n        return paramValues;\n    }","cleancode":"protected serializable[] getparamvalues(serializable[] rawparamvalues) throws sqlexception { int nonpositionedparameterscount = 0; for (serializable rawparamvalue : rawparamvalues) { if (rawparamvalue != null && rawparamvalue instanceof nonpositionedparameter) ++nonpositionedparameterscount; } serializable[] paramvalues = new serializable[parameternames.size() + nonpositionedparameterscount]; entity entity = (entity)optional.ofnullable(getparent()).filter(x -> x instanceof entity).orelse(null); if (entity == null) { for (int i = 0; i < paramvalues.length - nonpositionedparameterscount; ++i) { paramvalues[i] = rawparamvalues[parammapping[i]]; } } else { for (int i = 0; i < paramvalues.length - nonpositionedparameterscount; ++i) { string paramname = parameternames.get(i); paramvalues[i] = entity.filtervalue(paramname, rawparamvalues[parammapping[i]]); } } for (int i = 0; i < nonpositionedparameterscount; ++i) { paramvalues[paramvalues.length - nonpositionedparameterscount + i] = rawparamvalues[rawparamvalues.length - nonpositionedparameterscount + i]; } return paramvalues; }","comment":"\/\/ non positioned parameters should always be given last (cb todo - document)","repo":"arkanovicz\/velocity-model","code_context_2":"}\n}\n\/\/ non positioned parameters should always be given last (CB TODO - document)\nfor (int i = 0; i < nonPositionedParametersCount; ++i)\n{","code_context_10":"}\n}\nelse\n{\nfor (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n{\nString paramName = parameterNames.get(i);\nparamValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n}\n}\n\/\/ non positioned parameters should always be given last (CB TODO - document)\nfor (int i = 0; i < nonPositionedParametersCount; ++i)\n{\nparamValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n}\nreturn paramValues;\n}","code_context_20":"{\nif (rawParamValue != null && rawParamValue instanceof NonPositionedParameter) ++nonPositionedParametersCount;\n}\nSerializable[] paramValues = new Serializable[parameterNames.size() + nonPositionedParametersCount];\nEntity entity = (Entity)Optional.ofNullable(getParent()).filter(x -> x instanceof Entity).orElse(null);\nif (entity == null)\n{\nfor (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n{\nparamValues[i] = rawParamValues[paramMapping[i]];\n}\n}\nelse\n{\nfor (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n{\nString paramName = parameterNames.get(i);\nparamValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n}\n}\n\/\/ non positioned parameters should always be given last (CB TODO - document)\nfor (int i = 0; i < nonPositionedParametersCount; ++i)\n{\nparamValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n}\nreturn paramValues;\n}","label":[0,0,0,0]}
{"id":12164,"original_code":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n        \/\/ NOTE:\n        \/\/ seekTo() call will be ignored if the player is attached as a next\n        \/\/ player.\n        try {\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            \/\/ prepare\n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            \/\/ seek\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n            \/\/ NOTE: valid position is returned\n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ start\n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ wait for the next player started\n            Thread.sleep(player.getDuration());\n            \/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n            \/\/ NOTE: valid current position position is returned\n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n            \/\/ wait for the next player completion\n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n                \/\/ WTF! Android's native audio decoder gives very poor seek\n                \/\/ accuracy!\n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n                \/\/ wait for the next player completion\n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","code":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n       \n       \n       \n        try {\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n           \n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n           \n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n           \n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            Thread.sleep(player.getDuration());\n           \n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n           \n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n           \n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n               \n               \n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n               \n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","cleancode":"public void testseektobeforeattachedasnextmediaplayer() throws throwable { ibasicmediaplayer player = createwrappedplayerinstance(); ibasicmediaplayer nextplayer = null; object args = gettestparams(); try { seekcompletelistenerobject seekcomp = new seekcompletelistenerobject(); transitstatetoprepared(player, args); nextplayer = createnextplayer(player, nextplayertype.prepared); nextplayer.setonseekcompletelistener(seekcomp); int seekposition = nextplayer.getduration() \/ 2; nextplayer.seekto(seekposition); if (!seekcomp.await(default_event_wait_duration)) { fail(); } assertequals(seekposition, nextplayer.getcurrentposition()); setunwrappedtnextplayer(player, nextplayer); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); player.start(); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(short_event_wait_duration); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(player.getduration()); assertequals(player.getduration(), player.getcurrentposition()); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); assertlargerthanorequal(seekposition, nextplayer.getcurrentposition()); thread.sleep(nextplayer.getduration() - seekposition + short_event_wait_duration); if (true) { log.w(\"xxx\", \"testseektobeforeattachedasnextmediaplayer() - workaround\"); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); thread.sleep(seekposition); } assertequals(nextplayer.getduration(), nextplayer.getcurrentposition()); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); } finally { releasequietly(nextplayer); releasequietly(player); } }","comment":"\/\/ note: this test case may fails with standardmediaplayer (affects: ics to jb, lollipop with nuplayer)\n\/\/ note: \/\/ seekto() call will be ignored if the player is attached as a next \/\/ player.\n\/\/ prepare\n\/\/ seek\n\/\/ note: valid position is returned\n\/\/ start\n\/\/ wait for the next player started\n\/\/ note: standardmediaplayer fails on this assertion if using nuplayer\n\/\/ note: valid current position position is returned\n\/\/ wait for the next player completion\n\/\/ wtf! android's native audio decoder gives very poor seek \/\/ accuracy!\n\/\/ wait for the next player completion","repo":"cirnoftw\/android-openslmediaplayer","code_context_2":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\n\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\n\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\n\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\n\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);","code_context_10":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\n\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\n\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\n\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\n\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\n\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\n\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\n\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion","code_context_20":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\n\npublic void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nnextPlayer.setOnSeekCompleteListener(seekComp);\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n\n\/\/ seek\nint seekPosition = nextPlayer.getDuration() \/ 2;\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\n\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\n\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}","label":[1,0,1,0]}
{"id":12165,"original_code":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n        \/\/ NOTE:\n        \/\/ seekTo() call will be ignored if the player is attached as a next\n        \/\/ player.\n        try {\n            \/\/ prepare\n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ start\n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n            \/\/ NOTE: valid position is returned\n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ wait for the next player started\n            Thread.sleep(player.getDuration());\n            \/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n            \/\/ NOTE: valid current position position is returned\n            \/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n            \/\/ wait for the next player completion\n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n                \/\/ WTF! Android's native audio decoder gives very poor seek\n                \/\/ accuracy!\n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n                \/\/ wait for the next player completion\n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","code":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n       \n       \n       \n        try {\n           \n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n           \n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            Thread.sleep(player.getDuration());\n           \n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n           \n           \n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n           \n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n               \n               \n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n               \n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","cleancode":"public void testseektoafterattachedasnextmediaplayer() throws throwable { ibasicmediaplayer player = createwrappedplayerinstance(); ibasicmediaplayer nextplayer = null; object args = gettestparams(); try { transitstatetoprepared(player, args); nextplayer = createnextplayer(player, nextplayertype.prepared); setunwrappedtnextplayer(player, nextplayer); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); player.start(); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); int seekposition = nextplayer.getduration() \/ 2; seekcompletelistenerobject seekcomp = new seekcompletelistenerobject(); nextplayer.setonseekcompletelistener(seekcomp); nextplayer.seekto(seekposition); if (!seekcomp.await(default_event_wait_duration)) { fail(); } assertequals(seekposition, nextplayer.getcurrentposition()); thread.sleep(short_event_wait_duration); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(player.getduration()); assertequals(player.getduration(), player.getcurrentposition()); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); assertlargerthanorequal(seekposition, nextplayer.getcurrentposition()); thread.sleep(nextplayer.getduration() - seekposition + short_event_wait_duration); if (true) { log.w(\"xxx\", \"testseektoafterattachedasnextmediaplayer() - workaround\"); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); thread.sleep(seekposition); } assertequals(nextplayer.getduration(), nextplayer.getcurrentposition()); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); } finally { releasequietly(nextplayer); releasequietly(player); } }","comment":"\/\/ note: this test case may fails with standardmediaplayer (affects: ics to jb, lollipop with nuplayer)\n\/\/ note: \/\/ seekto() call will be ignored if the player is attached as a next \/\/ player.\n\/\/ prepare\n\/\/ start\n\/\/ note: valid position is returned\n\/\/ wait for the next player started\n\/\/ note: standardmediaplayer fails on this assertion if using nuplayer\n\/\/ note: valid current position position is returned \/\/ xxx galaxy s4 (sc-04e, android 4.4.2) fails on this assertion\n\/\/ wait for the next player completion\n\/\/ wtf! android's native audio decoder gives very poor seek \/\/ accuracy!\n\/\/ wait for the next player completion","repo":"cirnoftw\/android-openslmediaplayer","code_context_2":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\n\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\n\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\n\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\n\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\n\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);","code_context_10":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\npublic void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\n\npublic void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\n\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\n\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\n\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\n\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\n\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\n\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion","code_context_20":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\npublic void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\n\npublic void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\n\npublic void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\nIBasicMediaPlayer player = createWrappedPlayerInstance();\nIBasicMediaPlayer nextPlayer = null;\nObject args = getTestParams();\n\/\/ NOTE:\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\n\n\/\/ seekTo() call will be ignored if the player is attached as a next\n\/\/ player.\ntry {\n\/\/ prepare\ntransitStateToPrepared(player, args);\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\nnextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\nsetUnwrappedtNextPlayer(player, nextPlayer);\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\n\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ start\nplayer.start();\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\n\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\nint seekPosition = nextPlayer.getDuration() \/ 2;\nSeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\n\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}\n}\n\nnextPlayer.setOnSeekCompleteListener(seekComp);\nnextPlayer.seekTo(seekPosition);\nif (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\nfail();\n}\n\/\/ NOTE: valid position is returned\nassertEquals(seekPosition, nextPlayer.getCurrentPosition());\nThread.sleep(SHORT_EVENT_WAIT_DURATION);\nassertTrue(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n\/\/ wait for the next player started\nThread.sleep(player.getDuration());\n\/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\nassertEquals(player.getDuration(), player.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ NOTE: valid current position position is returned\n\/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\nassertLargerThanOrEqual(seekPosition,\nnextPlayer.getCurrentPosition());\n\/\/ wait for the next player completion\nThread.sleep(nextPlayer.getDuration() - seekPosition\n+ SHORT_EVENT_WAIT_DURATION);\nif (true) {\nLog.w(\"XXX\",\n\"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n\/\/ WTF! Android's native audio decoder gives very poor seek\n\/\/ accuracy!\nassertFalse(player.isPlaying());\nassertTrue(nextPlayer.isPlaying());\n\/\/ wait for the next player completion\nThread.sleep(seekPosition);\n}\nassertEquals(nextPlayer.getDuration(),\nnextPlayer.getCurrentPosition());\nassertFalse(player.isPlaying());\nassertFalse(nextPlayer.isPlaying());\n} finally {\nreleaseQuietly(nextPlayer);\nreleaseQuietly(player);\n}","label":[1,0,1,0]}
{"id":20677,"original_code":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\n        return CompletableFuture.supplyAsync(() -> {\n            \/\/ TODO: explore a more relaxed locking strategy.\n            writeLock.lock();\n            try {\n                return supplier.get();\n            } catch (Throwable ex) {\n                log.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\n                throw ex;\n            } finally {\n                writeLock.unlock();\n            }\n        }, contextExecutor);\n    }","code":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\n        return CompletableFuture.supplyAsync(() -> {\n           \n            writeLock.lock();\n            try {\n                return supplier.get();\n            } catch (Throwable ex) {\n                log.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\n                throw ex;\n            } finally {\n                writeLock.unlock();\n            }\n        }, contextExecutor);\n    }","cleancode":"private <u> completablefuture<u> supplyincontext(supplier<u> supplier, string opdescription) { return completablefuture.supplyasync(() -> { writelock.lock(); try { return supplier.get(); } catch (throwable ex) { log.error(\"exception in p4runtime client of {}, executing {}\", deviceid, opdescription, ex); throw ex; } finally { writelock.unlock(); } }, contextexecutor); }","comment":"\/** * executes the given task (supplier) in the grpc context executor of this client, such that if the context is * cancelled (e.g. client shutdown) the rpc is automatically cancelled. * <p> * important: tasks submitted in parallel by different threads are forced executed sequentially. * <p> *\/\n\/\/ todo: explore a more relaxed locking strategy.","repo":"antiguru\/onos","code_context_2":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {\nreturn supplier.get();\n} catch (Throwable ex) {\nlog.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\nthrow ex;\n} finally {\nwriteLock.unlock();\n}\n}, contextExecutor);\n}\n\nprivate <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {","code_context_10":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {\nreturn supplier.get();\n} catch (Throwable ex) {\nlog.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\nthrow ex;\n} finally {\nwriteLock.unlock();\n}\n}, contextExecutor);\n}\n\nprivate <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {\nreturn supplier.get();\n} catch (Throwable ex) {\nlog.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\nthrow ex;\n} finally {\nwriteLock.unlock();\n}\n}, contextExecutor);","code_context_20":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {\nreturn supplier.get();\n} catch (Throwable ex) {\nlog.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\nthrow ex;\n} finally {\nwriteLock.unlock();\n}\n}, contextExecutor);\n}\n\nprivate <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\nreturn CompletableFuture.supplyAsync(() -> {\n\/\/ TODO: explore a more relaxed locking strategy.\nwriteLock.lock();\ntry {\nreturn supplier.get();\n} catch (Throwable ex) {\nlog.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\nthrow ex;\n} finally {\nwriteLock.unlock();\n}\n}, contextExecutor);\n}","label":[1,0,0,0]}
{"id":20862,"original_code":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\n    LongRange idsToRead = getIdsToRead();\n    \/\/ No more entries to read\n    if (idsToRead.getMaximumLong() == 0) {\n      return;\n    }\n    \/\/ TODO: Remove left outer join and command type filter once the\n    \/\/ exchange partition bug is fixed in HIVE-12215\n    String queryFormatString = \"SELECT a.id, a.create_time, \"\n        + \"command_type, command, name, category, \"\n        + \"type, serialized_object \"\n        + \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n        + \"WHERE a.id >= ? AND a.id <= ? \"\n        + \"AND (command_type IS NULL OR command_type \"\n        + \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n        + \"ORDER BY id \"\n        \/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n        \/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n        \/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n        \/\/ first transaction commits. Locking can also be done with serializable isolation level.\n        + \"LOCK IN SHARE MODE\";\n    String query = String.format(queryFormatString,\n        auditLogTableName, outputObjectsTableName,\n        idsToRead.getMinimumLong(), idsToRead.getMaximumLong());\n    Connection connection = dbConnectionFactory.getConnection();\n    PreparedStatement ps = connection.prepareStatement(query);\n    int index = 1;\n    ps.setLong(index++, idsToRead.getMinimumLong());\n    ps.setLong(index++, idsToRead.getMaximumLong());\n    ResultSet rs = ps.executeQuery();\n    long id = -1;\n    Timestamp createTime = null;\n    HiveOperation commandType = null;\n    String command = null;\n    String objectName;\n    String objectCategory;\n    String objectType;\n    String objectSerialized;\n    long previouslyReadId = -1;\n    Timestamp previouslyReadTs = null;\n    HiveOperation previousCommandType = null;\n    String previousCommand = null;\n    \/\/ For a given audit log ID, the join would have produced multiple rows\n    \/\/ for each ID. Each row contains a single output. Group all the rows\n    \/\/ and the outputs into a AuditLogEntry.\n    \/\/ For a given audit log ID, these accumulate the outputs from the\n    \/\/ different rows.\n    List<String> outputDirectories = new LinkedList<>();\n    List<Table> outputTables = new LinkedList<>();\n    List<NamedPartition> outputPartitions = new LinkedList<>();\n    List<Table> referenceTables = new LinkedList<>();\n    Table inputTable = null;\n    NamedPartition renameFromPartition = null;\n    while (rs.next()) {\n      id = rs.getLong(\"id\");\n      createTime = rs.getTimestamp(\"create_time\");\n      \/\/ Invalid operations are returned as null\n      String commandTypeString = rs.getString(\"command_type\");\n      commandType = convertToHiveOperation(commandTypeString);\n      if (commandType == null) {\n        LOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n      }\n      command = rs.getString(\"command\");\n      objectName = rs.getString(\"name\");\n      objectCategory = rs.getString(\"category\");\n      objectType = rs.getString(\"type\");\n      objectSerialized = rs.getString(\"serialized_object\");\n      if (previouslyReadId != -1 && id != previouslyReadId) {\n        lastReadId = previouslyReadId;\n        \/\/ This means that all the outputs for a given audit log entry\n        \/\/ has been read.\n        AuditLogEntry entry = new AuditLogEntry(\n            previouslyReadId,\n            previouslyReadTs,\n            previousCommandType,\n            previousCommand,\n            outputDirectories,\n            referenceTables,\n            outputTables,\n            outputPartitions,\n            inputTable,\n            renameFromPartition);\n        auditLogEntries.add(entry);\n        \/\/ Reset these accumulated values\n        outputDirectories = new LinkedList<>();\n        referenceTables = new LinkedList<>();\n        outputTables = new LinkedList<>();\n        outputPartitions = new LinkedList<>();\n        renameFromPartition = null;\n        inputTable = null;\n      }\n      previouslyReadId = id;\n      previouslyReadTs = createTime;\n      previousCommandType = commandType;\n      previousCommand = command;\n      if (\"DIRECTORY\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"TABLE\".equals(objectType)) {\n        Table table = new Table();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, table);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(table);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputTables.add(table);\n        } else if (\"REFERENCE_TABLE\".equals(objectCategory)) {\n          referenceTables.add(table);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          inputTable = table;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"PARTITION\".equals(objectType)) {\n        Partition partition = new Partition();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, partition);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(partition);\n        String partitionName = getPartitionNameFromOutputCol(objectName);\n        NamedPartition namedPartition = new NamedPartition(partitionName, partition);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputPartitions.add(namedPartition);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          renameFromPartition = namedPartition;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"DFS_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"LOCAL_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"DATABASE\".equals(objectType)) {\n        \/\/ Currently, nothing is done with DB's\n      } else if (objectType == null) {\n        \/\/ This will happen for queries that don't have any output\n        \/\/ objects. This can be removed a long with the OUTER aspect\n        \/\/ of the join above once the bug with exchange partitions is\n        \/\/ fixed.\n        LOG.debug(\"No output objects\");\n      } else {\n        throw new RuntimeException(\"Unhandled output type: \" + objectType);\n      }\n    }\n    \/\/ This is the case where we read to the end of the table.\n    if (id != -1) {\n      AuditLogEntry entry = new AuditLogEntry(\n          id,\n          createTime,\n          commandType,\n          command,\n          outputDirectories,\n          referenceTables,\n          outputTables,\n          outputPartitions,\n          inputTable,\n          renameFromPartition);\n      auditLogEntries.add(entry);\n    }\n    \/\/ Note: if we constantly get empty results (i.e. no valid entries\n    \/\/ because all the commands got filtered out), then the lastReadId won't\n    \/\/ be updated for a while.\n    lastReadId = idsToRead.getMaximumLong();\n    return;\n  }","code":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\n    LongRange idsToRead = getIdsToRead();\n   \n    if (idsToRead.getMaximumLong() == 0) {\n      return;\n    }\n   \n   \n    String queryFormatString = \"SELECT a.id, a.create_time, \"\n        + \"command_type, command, name, category, \"\n        + \"type, serialized_object \"\n        + \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n        + \"WHERE a.id >= ? AND a.id <= ? \"\n        + \"AND (command_type IS NULL OR command_type \"\n        + \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n        + \"ORDER BY id \"\n       \n       \n       \n       \n        + \"LOCK IN SHARE MODE\";\n    String query = String.format(queryFormatString,\n        auditLogTableName, outputObjectsTableName,\n        idsToRead.getMinimumLong(), idsToRead.getMaximumLong());\n    Connection connection = dbConnectionFactory.getConnection();\n    PreparedStatement ps = connection.prepareStatement(query);\n    int index = 1;\n    ps.setLong(index++, idsToRead.getMinimumLong());\n    ps.setLong(index++, idsToRead.getMaximumLong());\n    ResultSet rs = ps.executeQuery();\n    long id = -1;\n    Timestamp createTime = null;\n    HiveOperation commandType = null;\n    String command = null;\n    String objectName;\n    String objectCategory;\n    String objectType;\n    String objectSerialized;\n    long previouslyReadId = -1;\n    Timestamp previouslyReadTs = null;\n    HiveOperation previousCommandType = null;\n    String previousCommand = null;\n   \n   \n   \n   \n   \n    List<String> outputDirectories = new LinkedList<>();\n    List<Table> outputTables = new LinkedList<>();\n    List<NamedPartition> outputPartitions = new LinkedList<>();\n    List<Table> referenceTables = new LinkedList<>();\n    Table inputTable = null;\n    NamedPartition renameFromPartition = null;\n    while (rs.next()) {\n      id = rs.getLong(\"id\");\n      createTime = rs.getTimestamp(\"create_time\");\n     \n      String commandTypeString = rs.getString(\"command_type\");\n      commandType = convertToHiveOperation(commandTypeString);\n      if (commandType == null) {\n        LOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n      }\n      command = rs.getString(\"command\");\n      objectName = rs.getString(\"name\");\n      objectCategory = rs.getString(\"category\");\n      objectType = rs.getString(\"type\");\n      objectSerialized = rs.getString(\"serialized_object\");\n      if (previouslyReadId != -1 && id != previouslyReadId) {\n        lastReadId = previouslyReadId;\n       \n       \n        AuditLogEntry entry = new AuditLogEntry(\n            previouslyReadId,\n            previouslyReadTs,\n            previousCommandType,\n            previousCommand,\n            outputDirectories,\n            referenceTables,\n            outputTables,\n            outputPartitions,\n            inputTable,\n            renameFromPartition);\n        auditLogEntries.add(entry);\n       \n        outputDirectories = new LinkedList<>();\n        referenceTables = new LinkedList<>();\n        outputTables = new LinkedList<>();\n        outputPartitions = new LinkedList<>();\n        renameFromPartition = null;\n        inputTable = null;\n      }\n      previouslyReadId = id;\n      previouslyReadTs = createTime;\n      previousCommandType = commandType;\n      previousCommand = command;\n      if (\"DIRECTORY\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"TABLE\".equals(objectType)) {\n        Table table = new Table();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, table);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(table);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputTables.add(table);\n        } else if (\"REFERENCE_TABLE\".equals(objectCategory)) {\n          referenceTables.add(table);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          inputTable = table;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"PARTITION\".equals(objectType)) {\n        Partition partition = new Partition();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, partition);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(partition);\n        String partitionName = getPartitionNameFromOutputCol(objectName);\n        NamedPartition namedPartition = new NamedPartition(partitionName, partition);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputPartitions.add(namedPartition);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          renameFromPartition = namedPartition;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"DFS_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"LOCAL_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"DATABASE\".equals(objectType)) {\n       \n      } else if (objectType == null) {\n       \n       \n       \n       \n        LOG.debug(\"No output objects\");\n      } else {\n        throw new RuntimeException(\"Unhandled output type: \" + objectType);\n      }\n    }\n   \n    if (id != -1) {\n      AuditLogEntry entry = new AuditLogEntry(\n          id,\n          createTime,\n          commandType,\n          command,\n          outputDirectories,\n          referenceTables,\n          outputTables,\n          outputPartitions,\n          inputTable,\n          renameFromPartition);\n      auditLogEntries.add(entry);\n    }\n   \n   \n   \n    lastReadId = idsToRead.getMaximumLong();\n    return;\n  }","cleancode":"private void fetchmoreentries() throws sqlexception, auditlogentryexception { longrange idstoread = getidstoread(); if (idstoread.getmaximumlong() == 0) { return; } string queryformatstring = \"select a.id, a.create_time, \" + \"command_type, command, name, category, \" + \"type, serialized_object \" + \"from %s a left outer join %s b on a.id = b.audit_log_id \" + \"where a.id >= ? and a.id <= ? \" + \"and (command_type is null or command_type \" + \"not in('showtables', 'showpartitions', 'switchdatabase')) \" + \"order by id \" + \"lock in share mode\"; string query = string.format(queryformatstring, auditlogtablename, outputobjectstablename, idstoread.getminimumlong(), idstoread.getmaximumlong()); connection connection = dbconnectionfactory.getconnection(); preparedstatement ps = connection.preparestatement(query); int index = 1; ps.setlong(index++, idstoread.getminimumlong()); ps.setlong(index++, idstoread.getmaximumlong()); resultset rs = ps.executequery(); long id = -1; timestamp createtime = null; hiveoperation commandtype = null; string command = null; string objectname; string objectcategory; string objecttype; string objectserialized; long previouslyreadid = -1; timestamp previouslyreadts = null; hiveoperation previouscommandtype = null; string previouscommand = null; list<string> outputdirectories = new linkedlist<>(); list<table> outputtables = new linkedlist<>(); list<namedpartition> outputpartitions = new linkedlist<>(); list<table> referencetables = new linkedlist<>(); table inputtable = null; namedpartition renamefrompartition = null; while (rs.next()) { id = rs.getlong(\"id\"); createtime = rs.gettimestamp(\"create_time\"); string commandtypestring = rs.getstring(\"command_type\"); commandtype = converttohiveoperation(commandtypestring); if (commandtype == null) { log.debug(string.format(\"invalid operation %s in audit log id: %s\", commandtypestring, id)); } command = rs.getstring(\"command\"); objectname = rs.getstring(\"name\"); objectcategory = rs.getstring(\"category\"); objecttype = rs.getstring(\"type\"); objectserialized = rs.getstring(\"serialized_object\"); if (previouslyreadid != -1 && id != previouslyreadid) { lastreadid = previouslyreadid; auditlogentry entry = new auditlogentry( previouslyreadid, previouslyreadts, previouscommandtype, previouscommand, outputdirectories, referencetables, outputtables, outputpartitions, inputtable, renamefrompartition); auditlogentries.add(entry); outputdirectories = new linkedlist<>(); referencetables = new linkedlist<>(); outputtables = new linkedlist<>(); outputpartitions = new linkedlist<>(); renamefrompartition = null; inputtable = null; } previouslyreadid = id; previouslyreadts = createtime; previouscommandtype = commandtype; previouscommand = command; if (\"directory\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"table\".equals(objecttype)) { table table = new table(); try { replicationutils.deserializeobject(objectserialized, table); } catch (metadataexception e) { throw new auditlogentryexception(e); } replicationutils.normalizenames(table); if (\"output\".equals(objectcategory)) { outputtables.add(table); } else if (\"reference_table\".equals(objectcategory)) { referencetables.add(table); } else if (\"rename_from\".equals(objectcategory) || \"input\".equals(objectcategory)) { inputtable = table; } else { throw new runtimeexception(\"unhandled category: \" + objectcategory); } } else if (\"partition\".equals(objecttype)) { partition partition = new partition(); try { replicationutils.deserializeobject(objectserialized, partition); } catch (metadataexception e) { throw new auditlogentryexception(e); } replicationutils.normalizenames(partition); string partitionname = getpartitionnamefromoutputcol(objectname); namedpartition namedpartition = new namedpartition(partitionname, partition); if (\"output\".equals(objectcategory)) { outputpartitions.add(namedpartition); } else if (\"rename_from\".equals(objectcategory) || \"input\".equals(objectcategory)) { renamefrompartition = namedpartition; } else { throw new runtimeexception(\"unhandled category: \" + objectcategory); } } else if (\"dfs_dir\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"local_dir\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"database\".equals(objecttype)) { } else if (objecttype == null) { log.debug(\"no output objects\"); } else { throw new runtimeexception(\"unhandled output type: \" + objecttype); } } if (id != -1) { auditlogentry entry = new auditlogentry( id, createtime, commandtype, command, outputdirectories, referencetables, outputtables, outputpartitions, inputtable, renamefrompartition); auditlogentries.add(entry); } lastreadid = idstoread.getmaximumlong(); return; }","comment":"\/\/ no more entries to read\n\/\/ todo: remove left outer join and command type filter once the \/\/ exchange partition bug is fixed in hive-12215\n\/\/ get read locks on the specified rows to prevent skipping of rows that haven't committed \/\/ yet, but have an id between idstoread. for example, one transaction starts and \/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the \/\/ first transaction commits. locking can also be done with serializable isolation level.\n\/\/ for a given audit log id, the join would have produced multiple rows \/\/ for each id. each row contains a single output. group all the rows \/\/ and the outputs into a auditlogentry. \/\/ for a given audit log id, these accumulate the outputs from the \/\/ different rows.\n\/\/ invalid operations are returned as null\n\/\/ this means that all the outputs for a given audit log entry \/\/ has been read.\n\/\/ reset these accumulated values\n\/\/ currently, nothing is done with db's\n\/\/ this will happen for queries that don't have any output \/\/ objects. this can be removed a long with the outer aspect \/\/ of the join above once the bug with exchange partitions is \/\/ fixed.\n\/\/ this is the case where we read to the end of the table.\n\/\/ note: if we constantly get empty results (i.e. no valid entries \/\/ because all the commands got filtered out), then the lastreadid won't \/\/ be updated for a while.","repo":"aoen\/reair","code_context_2":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n\/\/ first transaction commits. Locking can also be done with serializable isolation level.\n+ \"LOCK IN SHARE MODE\";\nString query = String.format(queryFormatString,\n\nHiveOperation previousCommandType = null;\nString previousCommand = null;\n\/\/ For a given audit log ID, the join would have produced multiple rows\n\/\/ for each ID. Each row contains a single output. Group all the rows\n\/\/ and the outputs into a AuditLogEntry.\n\/\/ For a given audit log ID, these accumulate the outputs from the\n\/\/ different rows.\nList<String> outputDirectories = new LinkedList<>();\nList<Table> outputTables = new LinkedList<>();\n\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\nString commandTypeString = rs.getString(\"command_type\");\ncommandType = convertToHiveOperation(commandTypeString);\n\nif (previouslyReadId != -1 && id != previouslyReadId) {\nlastReadId = previouslyReadId;\n\/\/ This means that all the outputs for a given audit log entry\n\/\/ has been read.\nAuditLogEntry entry = new AuditLogEntry(\npreviouslyReadId,\n\nrenameFromPartition);\nauditLogEntries.add(entry);\n\/\/ Reset these accumulated values\noutputDirectories = new LinkedList<>();\nreferenceTables = new LinkedList<>();\n\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\n\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\n\nauditLogEntries.add(entry);\n}\n\/\/ Note: if we constantly get empty results (i.e. no valid entries\n\/\/ because all the commands got filtered out), then the lastReadId won't\n\/\/ be updated for a while.\nlastReadId = idsToRead.getMaximumLong();\nreturn;","code_context_10":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n\nprivate void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n+ \"AND (command_type IS NULL OR command_type \"\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n+ \"AND (command_type IS NULL OR command_type \"\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n\/\/ first transaction commits. Locking can also be done with serializable isolation level.\n+ \"LOCK IN SHARE MODE\";\nString query = String.format(queryFormatString,\nauditLogTableName, outputObjectsTableName,\nidsToRead.getMinimumLong(), idsToRead.getMaximumLong());\nConnection connection = dbConnectionFactory.getConnection();\nPreparedStatement ps = connection.prepareStatement(query);\nint index = 1;\nps.setLong(index++, idsToRead.getMinimumLong());\nps.setLong(index++, idsToRead.getMaximumLong());\nResultSet rs = ps.executeQuery();\n\nHiveOperation commandType = null;\nString command = null;\nString objectName;\nString objectCategory;\nString objectType;\nString objectSerialized;\nlong previouslyReadId = -1;\nTimestamp previouslyReadTs = null;\nHiveOperation previousCommandType = null;\nString previousCommand = null;\n\/\/ For a given audit log ID, the join would have produced multiple rows\n\/\/ for each ID. Each row contains a single output. Group all the rows\n\/\/ and the outputs into a AuditLogEntry.\n\/\/ For a given audit log ID, these accumulate the outputs from the\n\/\/ different rows.\nList<String> outputDirectories = new LinkedList<>();\nList<Table> outputTables = new LinkedList<>();\nList<NamedPartition> outputPartitions = new LinkedList<>();\nList<Table> referenceTables = new LinkedList<>();\nTable inputTable = null;\nNamedPartition renameFromPartition = null;\nwhile (rs.next()) {\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\n\n\/\/ different rows.\nList<String> outputDirectories = new LinkedList<>();\nList<Table> outputTables = new LinkedList<>();\nList<NamedPartition> outputPartitions = new LinkedList<>();\nList<Table> referenceTables = new LinkedList<>();\nTable inputTable = null;\nNamedPartition renameFromPartition = null;\nwhile (rs.next()) {\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\nString commandTypeString = rs.getString(\"command_type\");\ncommandType = convertToHiveOperation(commandTypeString);\nif (commandType == null) {\nLOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n}\ncommand = rs.getString(\"command\");\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\n\nif (commandType == null) {\nLOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n}\ncommand = rs.getString(\"command\");\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\nif (previouslyReadId != -1 && id != previouslyReadId) {\nlastReadId = previouslyReadId;\n\/\/ This means that all the outputs for a given audit log entry\n\/\/ has been read.\nAuditLogEntry entry = new AuditLogEntry(\npreviouslyReadId,\npreviouslyReadTs,\npreviousCommandType,\npreviousCommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\n\npreviouslyReadTs,\npreviousCommandType,\npreviousCommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n\/\/ Reset these accumulated values\noutputDirectories = new LinkedList<>();\nreferenceTables = new LinkedList<>();\noutputTables = new LinkedList<>();\noutputPartitions = new LinkedList<>();\nrenameFromPartition = null;\ninputTable = null;\n}\npreviouslyReadId = id;\npreviouslyReadTs = createTime;\npreviousCommandType = commandType;\n\n} else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\nrenameFromPartition = namedPartition;\n} else {\nthrow new RuntimeException(\"Unhandled category: \" + objectCategory);\n}\n} else if (\"DFS_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"LOCAL_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\n} else {\nthrow new RuntimeException(\"Unhandled category: \" + objectCategory);\n}\n} else if (\"DFS_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"LOCAL_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\n\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\n\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n}\n\/\/ Note: if we constantly get empty results (i.e. no valid entries\n\/\/ because all the commands got filtered out), then the lastReadId won't\n\/\/ be updated for a while.\nlastReadId = idsToRead.getMaximumLong();\nreturn;\n}","code_context_20":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n+ \"AND (command_type IS NULL OR command_type \"\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n\/\/ first transaction commits. Locking can also be done with serializable isolation level.\n+ \"LOCK IN SHARE MODE\";\nString query = String.format(queryFormatString,\nauditLogTableName, outputObjectsTableName,\n\nprivate void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n+ \"AND (command_type IS NULL OR command_type \"\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n\/\/ first transaction commits. Locking can also be done with serializable isolation level.\n+ \"LOCK IN SHARE MODE\";\nString query = String.format(queryFormatString,\nauditLogTableName, outputObjectsTableName,\nidsToRead.getMinimumLong(), idsToRead.getMaximumLong());\nConnection connection = dbConnectionFactory.getConnection();\nPreparedStatement ps = connection.prepareStatement(query);\nint index = 1;\nps.setLong(index++, idsToRead.getMinimumLong());\n\nprivate void fetchMoreEntries() throws SQLException, AuditLogEntryException {\nLongRange idsToRead = getIdsToRead();\n\/\/ No more entries to read\nif (idsToRead.getMaximumLong() == 0) {\nreturn;\n}\n\/\/ TODO: Remove left outer join and command type filter once the\n\/\/ exchange partition bug is fixed in HIVE-12215\nString queryFormatString = \"SELECT a.id, a.create_time, \"\n+ \"command_type, command, name, category, \"\n+ \"type, serialized_object \"\n+ \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n+ \"WHERE a.id >= ? AND a.id <= ? \"\n+ \"AND (command_type IS NULL OR command_type \"\n+ \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n+ \"ORDER BY id \"\n\/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n\/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n\/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n\/\/ first transaction commits. Locking can also be done with serializable isolation level.\n+ \"LOCK IN SHARE MODE\";\nString query = String.format(queryFormatString,\nauditLogTableName, outputObjectsTableName,\nidsToRead.getMinimumLong(), idsToRead.getMaximumLong());\nConnection connection = dbConnectionFactory.getConnection();\nPreparedStatement ps = connection.prepareStatement(query);\nint index = 1;\nps.setLong(index++, idsToRead.getMinimumLong());\nps.setLong(index++, idsToRead.getMaximumLong());\nResultSet rs = ps.executeQuery();\nlong id = -1;\nTimestamp createTime = null;\nHiveOperation commandType = null;\nString command = null;\nString objectName;\nString objectCategory;\nString objectType;\nString objectSerialized;\nlong previouslyReadId = -1;\nTimestamp previouslyReadTs = null;\n\nauditLogTableName, outputObjectsTableName,\nidsToRead.getMinimumLong(), idsToRead.getMaximumLong());\nConnection connection = dbConnectionFactory.getConnection();\nPreparedStatement ps = connection.prepareStatement(query);\nint index = 1;\nps.setLong(index++, idsToRead.getMinimumLong());\nps.setLong(index++, idsToRead.getMaximumLong());\nResultSet rs = ps.executeQuery();\nlong id = -1;\nTimestamp createTime = null;\nHiveOperation commandType = null;\nString command = null;\nString objectName;\nString objectCategory;\nString objectType;\nString objectSerialized;\nlong previouslyReadId = -1;\nTimestamp previouslyReadTs = null;\nHiveOperation previousCommandType = null;\nString previousCommand = null;\n\/\/ For a given audit log ID, the join would have produced multiple rows\n\/\/ for each ID. Each row contains a single output. Group all the rows\n\/\/ and the outputs into a AuditLogEntry.\n\/\/ For a given audit log ID, these accumulate the outputs from the\n\/\/ different rows.\nList<String> outputDirectories = new LinkedList<>();\nList<Table> outputTables = new LinkedList<>();\nList<NamedPartition> outputPartitions = new LinkedList<>();\nList<Table> referenceTables = new LinkedList<>();\nTable inputTable = null;\nNamedPartition renameFromPartition = null;\nwhile (rs.next()) {\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\nString commandTypeString = rs.getString(\"command_type\");\ncommandType = convertToHiveOperation(commandTypeString);\nif (commandType == null) {\nLOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n}\ncommand = rs.getString(\"command\");\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\n\nString objectType;\nString objectSerialized;\nlong previouslyReadId = -1;\nTimestamp previouslyReadTs = null;\nHiveOperation previousCommandType = null;\nString previousCommand = null;\n\/\/ For a given audit log ID, the join would have produced multiple rows\n\/\/ for each ID. Each row contains a single output. Group all the rows\n\/\/ and the outputs into a AuditLogEntry.\n\/\/ For a given audit log ID, these accumulate the outputs from the\n\/\/ different rows.\nList<String> outputDirectories = new LinkedList<>();\nList<Table> outputTables = new LinkedList<>();\nList<NamedPartition> outputPartitions = new LinkedList<>();\nList<Table> referenceTables = new LinkedList<>();\nTable inputTable = null;\nNamedPartition renameFromPartition = null;\nwhile (rs.next()) {\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\nString commandTypeString = rs.getString(\"command_type\");\ncommandType = convertToHiveOperation(commandTypeString);\nif (commandType == null) {\nLOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n}\ncommand = rs.getString(\"command\");\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\nif (previouslyReadId != -1 && id != previouslyReadId) {\nlastReadId = previouslyReadId;\n\/\/ This means that all the outputs for a given audit log entry\n\/\/ has been read.\nAuditLogEntry entry = new AuditLogEntry(\npreviouslyReadId,\npreviouslyReadTs,\npreviousCommandType,\npreviousCommand,\noutputDirectories,\n\nList<NamedPartition> outputPartitions = new LinkedList<>();\nList<Table> referenceTables = new LinkedList<>();\nTable inputTable = null;\nNamedPartition renameFromPartition = null;\nwhile (rs.next()) {\nid = rs.getLong(\"id\");\ncreateTime = rs.getTimestamp(\"create_time\");\n\/\/ Invalid operations are returned as null\nString commandTypeString = rs.getString(\"command_type\");\ncommandType = convertToHiveOperation(commandTypeString);\nif (commandType == null) {\nLOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n}\ncommand = rs.getString(\"command\");\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\nif (previouslyReadId != -1 && id != previouslyReadId) {\nlastReadId = previouslyReadId;\n\/\/ This means that all the outputs for a given audit log entry\n\/\/ has been read.\nAuditLogEntry entry = new AuditLogEntry(\npreviouslyReadId,\npreviouslyReadTs,\npreviousCommandType,\npreviousCommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n\/\/ Reset these accumulated values\noutputDirectories = new LinkedList<>();\nreferenceTables = new LinkedList<>();\noutputTables = new LinkedList<>();\noutputPartitions = new LinkedList<>();\nrenameFromPartition = null;\ninputTable = null;\n}\n\nobjectName = rs.getString(\"name\");\nobjectCategory = rs.getString(\"category\");\nobjectType = rs.getString(\"type\");\nobjectSerialized = rs.getString(\"serialized_object\");\nif (previouslyReadId != -1 && id != previouslyReadId) {\nlastReadId = previouslyReadId;\n\/\/ This means that all the outputs for a given audit log entry\n\/\/ has been read.\nAuditLogEntry entry = new AuditLogEntry(\npreviouslyReadId,\npreviouslyReadTs,\npreviousCommandType,\npreviousCommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n\/\/ Reset these accumulated values\noutputDirectories = new LinkedList<>();\nreferenceTables = new LinkedList<>();\noutputTables = new LinkedList<>();\noutputPartitions = new LinkedList<>();\nrenameFromPartition = null;\ninputTable = null;\n}\npreviouslyReadId = id;\npreviouslyReadTs = createTime;\npreviousCommandType = commandType;\npreviousCommand = command;\nif (\"DIRECTORY\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"TABLE\".equals(objectType)) {\nTable table = new Table();\ntry {\nReplicationUtils.deserializeObject(objectSerialized, table);\n} catch (MetadataException e) {\nthrow new AuditLogEntryException(e);\n}\n\ntry {\nReplicationUtils.deserializeObject(objectSerialized, partition);\n} catch (MetadataException e) {\nthrow new AuditLogEntryException(e);\n}\nReplicationUtils.normalizeNames(partition);\nString partitionName = getPartitionNameFromOutputCol(objectName);\nNamedPartition namedPartition = new NamedPartition(partitionName, partition);\nif (\"OUTPUT\".equals(objectCategory)) {\noutputPartitions.add(namedPartition);\n} else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\nrenameFromPartition = namedPartition;\n} else {\nthrow new RuntimeException(\"Unhandled category: \" + objectCategory);\n}\n} else if (\"DFS_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"LOCAL_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\n\n} catch (MetadataException e) {\nthrow new AuditLogEntryException(e);\n}\nReplicationUtils.normalizeNames(partition);\nString partitionName = getPartitionNameFromOutputCol(objectName);\nNamedPartition namedPartition = new NamedPartition(partitionName, partition);\nif (\"OUTPUT\".equals(objectCategory)) {\noutputPartitions.add(namedPartition);\n} else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\nrenameFromPartition = namedPartition;\n} else {\nthrow new RuntimeException(\"Unhandled category: \" + objectCategory);\n}\n} else if (\"DFS_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"LOCAL_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n}\n\nrenameFromPartition = namedPartition;\n} else {\nthrow new RuntimeException(\"Unhandled category: \" + objectCategory);\n}\n} else if (\"DFS_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"LOCAL_DIR\".equals(objectType)) {\noutputDirectories.add(objectName);\n} else if (\"DATABASE\".equals(objectType)) {\n\/\/ Currently, nothing is done with DB's\n} else if (objectType == null) {\n\/\/ This will happen for queries that don't have any output\n\/\/ objects. This can be removed a long with the OUTER aspect\n\/\/ of the join above once the bug with exchange partitions is\n\/\/ fixed.\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n}\n\/\/ Note: if we constantly get empty results (i.e. no valid entries\n\/\/ because all the commands got filtered out), then the lastReadId won't\n\/\/ be updated for a while.\nlastReadId = idsToRead.getMaximumLong();\nreturn;\n}\n\nLOG.debug(\"No output objects\");\n} else {\nthrow new RuntimeException(\"Unhandled output type: \" + objectType);\n}\n}\n\/\/ This is the case where we read to the end of the table.\nif (id != -1) {\nAuditLogEntry entry = new AuditLogEntry(\nid,\ncreateTime,\ncommandType,\ncommand,\noutputDirectories,\nreferenceTables,\noutputTables,\noutputPartitions,\ninputTable,\nrenameFromPartition);\nauditLogEntries.add(entry);\n}\n\/\/ Note: if we constantly get empty results (i.e. no valid entries\n\/\/ because all the commands got filtered out), then the lastReadId won't\n\/\/ be updated for a while.\nlastReadId = idsToRead.getMaximumLong();\nreturn;\n}","label":[1,1,1,0]}
{"id":12727,"original_code":"@Override\n    public void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\n        for (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\n            int j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\n            double cR, cI, zR, zI, p;\n            \/\/ use ThreadLocalRandom for improved performance\n            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\n            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n            \/\/ check if the sequence generated by (cR, cI) escapes\n            for (j = 0; j < iterationLimit; j++) {\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {\n                    break;\n                }\n            }\n            if (j == iterationLimit) { \/\/ does the sequence escape?\n                continue;\n            }\n            zR = cR;\n            zI = cI;\n            for (j = 0; j < iterationLimit; j++) {\n                \/\/ Is the point within the rendering region?\n                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\n                    bufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\n                    bufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\n                    negative.buffer.setElem(bufferY * negative.size.width + bufferX,\n                            negative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n                }\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n            }\n        }\n    }","code":"@Override\n    public void run(Engine.Negative negative) {\n        for (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\n            int j, bufferX, bufferY;\n            double cR, cI, zR, zI, p;\n           \n            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\n            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n           \n            for (j = 0; j < iterationLimit; j++) {\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {\n                    break;\n                }\n            }\n            if (j == iterationLimit) {\n                continue;\n            }\n            zR = cR;\n            zI = cI;\n            for (j = 0; j < iterationLimit; j++) {\n               \n                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\n                    bufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\n                    bufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\n                    negative.buffer.setElem(bufferY * negative.size.width + bufferX,\n                            negative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n                }\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n            }\n        }\n    }","cleancode":"@override public void run(engine.negative negative) { for (int i = 1; i <= task_sample_size; i++) { int j, bufferx, buffery; double cr, ci, zr, zi, p; cr = zr = minx + threadlocalrandom.current().nextdouble(rangex); ci = zi = miny + threadlocalrandom.current().nextdouble(rangey); for (j = 0; j < iterationlimit; j++) { for (int k = 1; k < degree; k++) { p = zr; zr = zr * zr - zi * zi; zi = 2 * p * zi; } zr += cr; zi += ci; if (zr * zr + zi * zi > escapedistance * escapedistance) { break; } } if (j == iterationlimit) { continue; } zr = cr; zi = ci; for (j = 0; j < iterationlimit; j++) { if (zr >= minx && zr - minx <= rangex && zi >= miny && zi - miny <= rangey) { bufferx = (int) (((zr - minx) \/ rangex) * negative.size.width); buffery = (int) (((zi - miny) \/ rangey) * negative.size.height); negative.buffer.setelem(buffery * negative.size.width + bufferx, negative.buffer.getelem(buffery * negative.size.width + bufferx) + 1); } for (int k = 1; k < degree; k++) { p = zr; zr = zr * zr - zi * zi; zi = 2 * p * zi; } zr += cr; zi += ci; } } }","comment":"\/\/ todo: use \"advanced probabilistic techniques\".\n\/\/ location of (zr, zi) in histogram\n\/\/ use threadlocalrandom for improved performance\n\/\/ check if the sequence generated by (cr, ci) escapes\n\/\/ does the sequence escape?\n\/\/ is the point within the rendering region?","repo":"ari-b\/neb","code_context_2":"@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\n\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\n\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\n\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\n\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\nbufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);","code_context_10":"@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\nbufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\nbufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\nnegative.buffer.setElem(bufferY * negative.size.width + bufferX,\n\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\nbufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\nbufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\nnegative.buffer.setElem(bufferY * negative.size.width + bufferX,\nnegative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n}\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;","code_context_20":"@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\n\n@Override\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\n\npublic void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\nfor (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\nint j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\ndouble cR, cI, zR, zI, p;\n\/\/ use ThreadLocalRandom for improved performance\ncR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\nbufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\nbufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\nnegative.buffer.setElem(bufferY * negative.size.width + bufferX,\nnegative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n}\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\n}\n\ncI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n\/\/ check if the sequence generated by (cR, cI) escapes\nfor (j = 0; j < iterationLimit; j++) {\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\nif (zR * zR + zI * zI > escapeDistance * escapeDistance) {\nbreak;\n}\n}\nif (j == iterationLimit) { \/\/ does the sequence escape?\ncontinue;\n}\nzR = cR;\nzI = cI;\nfor (j = 0; j < iterationLimit; j++) {\n\/\/ Is the point within the rendering region?\nif (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\nbufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\nbufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\nnegative.buffer.setElem(bufferY * negative.size.width + bufferX,\nnegative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n}\nfor (int k = 1; k < degree; k++) {\np = zR;\nzR = zR * zR - zI * zI;\nzI = 2 * p * zI;\n}\nzR += cR;\nzI += cI;\n}\n}\n}","label":[1,0,0,0]}
{"id":20951,"original_code":"public void xtestNameClash() {\n        WritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\n        try {\n            doTestVersion(wv);\n            doTestVersion(wv);\n            fail(\"created two groups with same name\");\n        } catch (ModelException ex) {\n            wv.abort();\n            Throwable cause = ex;\n            while (null != cause.getCause()) {\n                cause = cause.getCause();\n            }\n            cause.printStackTrace();\n            fail(cause.getClass().getName() + \": \" + cause.getMessage());\n        } finally {\n            if (!wv.isCompleted()) {\n                wv.abort();\n            } \/\/ not testing persistence here\n        }\n    }","code":"public void xtestNameClash() {\n        WritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\n        try {\n            doTestVersion(wv);\n            doTestVersion(wv);\n            fail(\"created two groups with same name\");\n        } catch (ModelException ex) {\n            wv.abort();\n            Throwable cause = ex;\n            while (null != cause.getCause()) {\n                cause = cause.getCause();\n            }\n            cause.printStackTrace();\n            fail(cause.getClass().getName() + \": \" + cause.getMessage());\n        } finally {\n            if (!wv.isCompleted()) {\n                wv.abort();\n            }\n        }\n    }","cleancode":"public void xtestnameclash() { writableversion wv = model.getwritableversion(abstractmodel.superuser); try { dotestversion(wv); dotestversion(wv); fail(\"created two groups with same name\"); } catch (modelexception ex) { wv.abort(); throwable cause = ex; while (null != cause.getcause()) { cause = cause.getcause(); } cause.printstacktrace(); fail(cause.getclass().getname() + \": \" + cause.getmessage()); } finally { if (!wv.iscompleted()) { wv.abort(); } } }","comment":"\/** * later fix this test case - it leaves the db connection bad *\/\n\/\/ not testing persistence here","repo":"chrishmorris\/PiMS","code_context_2":"public void xtestNameClash() {\nWritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\ntry {\ndoTestVersion(wv);\ndoTestVersion(wv);\nfail(\"created two groups with same name\");\n} catch (ModelException ex) {\nwv.abort();\nThrowable cause = ex;\nwhile (null != cause.getCause()) {\ncause = cause.getCause();\n}\ncause.printStackTrace();\nfail(cause.getClass().getName() + \": \" + cause.getMessage());\n} finally {\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}\n\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}","code_context_10":"public void xtestNameClash() {\nWritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\ntry {\ndoTestVersion(wv);\ndoTestVersion(wv);\nfail(\"created two groups with same name\");\n} catch (ModelException ex) {\nwv.abort();\nThrowable cause = ex;\nwhile (null != cause.getCause()) {\ncause = cause.getCause();\n}\ncause.printStackTrace();\nfail(cause.getClass().getName() + \": \" + cause.getMessage());\n} finally {\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}\n\nwv.abort();\nThrowable cause = ex;\nwhile (null != cause.getCause()) {\ncause = cause.getCause();\n}\ncause.printStackTrace();\nfail(cause.getClass().getName() + \": \" + cause.getMessage());\n} finally {\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}","code_context_20":"public void xtestNameClash() {\nWritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\ntry {\ndoTestVersion(wv);\ndoTestVersion(wv);\nfail(\"created two groups with same name\");\n} catch (ModelException ex) {\nwv.abort();\nThrowable cause = ex;\nwhile (null != cause.getCause()) {\ncause = cause.getCause();\n}\ncause.printStackTrace();\nfail(cause.getClass().getName() + \": \" + cause.getMessage());\n} finally {\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}\n\npublic void xtestNameClash() {\nWritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\ntry {\ndoTestVersion(wv);\ndoTestVersion(wv);\nfail(\"created two groups with same name\");\n} catch (ModelException ex) {\nwv.abort();\nThrowable cause = ex;\nwhile (null != cause.getCause()) {\ncause = cause.getCause();\n}\ncause.printStackTrace();\nfail(cause.getClass().getName() + \": \" + cause.getMessage());\n} finally {\nif (!wv.isCompleted()) {\nwv.abort();\n} \/\/ not testing persistence here\n}\n}","label":[0,0,1,0]}
{"id":13109,"original_code":"public void hasLength(int length) {\n        \/\/ TODO Support string length?\n        checkArgument(length >= 0, \"length (%s) must be >= 0\", length);\n        if (actual() == null || !actual().isContainerNode()) {\n            fail(\"is a container\");\n        } else if (actual().size() != length) {\n            fail(\"has length\", length);\n        }\n    }","code":"public void hasLength(int length) {\n       \n        checkArgument(length >= 0, \"length (%s) must be >= 0\", length);\n        if (actual() == null || !actual().isContainerNode()) {\n            fail(\"is a container\");\n        } else if (actual().size() != length) {\n            fail(\"has length\", length);\n        }\n    }","cleancode":"public void haslength(int length) { checkargument(length >= 0, \"length (%s) must be >= 0\", length); if (actual() == null || !actual().iscontainernode()) { fail(\"is a container\"); } else if (actual().size() != length) { fail(\"has length\", length); } }","comment":"\/** * fails if the subject is not a container with the specified number of values or name\/value pairs. *\/\n\/\/ todo support string length?","repo":"blackducksoftware\/magpie-libraries","code_context_2":"public void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {\nfail(\"is a container\");\n} else if (actual().size() != length) {\nfail(\"has length\", length);\n}\n}\n\npublic void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {","code_context_10":"public void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {\nfail(\"is a container\");\n} else if (actual().size() != length) {\nfail(\"has length\", length);\n}\n}\n\npublic void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {\nfail(\"is a container\");\n} else if (actual().size() != length) {\nfail(\"has length\", length);\n}\n}","code_context_20":"public void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {\nfail(\"is a container\");\n} else if (actual().size() != length) {\nfail(\"has length\", length);\n}\n}\n\npublic void hasLength(int length) {\n\/\/ TODO Support string length?\ncheckArgument(length >= 0, \"length (%s) must be >= 0\", length);\nif (actual() == null || !actual().isContainerNode()) {\nfail(\"is a container\");\n} else if (actual().size() != length) {\nfail(\"has length\", length);\n}\n}","label":[1,0,1,0]}
{"id":13111,"original_code":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\n            objectMapper.configure(feature, state);\n            return this;\n        }","code":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\n            objectMapper.configure(feature, state);\n            return this;\n        }","cleancode":"public jsonsubjectfactory configure(deserializationfeature feature, boolean state) { objectmapper.configure(feature, state); return this; }","comment":"\/\/ todo register other modules via method calls?","repo":"blackducksoftware\/magpie-libraries","code_context_2":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\nobjectMapper.configure(feature, state);\nreturn this;\n}","code_context_10":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\nobjectMapper.configure(feature, state);\nreturn this;\n}","code_context_20":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\nobjectMapper.configure(feature, state);\nreturn this;\n}","label":[1,0,0,0]}
{"id":21976,"original_code":"@Override\n    public void onBindViewHolder(final ViewHolder holder, final int position) {\n        final Item item = mItemList.get(position);\n        setListener(mListener);\n        String dateStr = item.getPubDate();\n        DateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.getDefault());\n        try {\n            Date date = formatter.parse(dateStr);\n            String pubDateStr = DateUtils.formatAbbrev(mContext, date);\n            String[] dateMonth = pubDateStr.split(\" \");\n            holder.mTvMonth.setText(dateMonth[0]);\n            holder.mTvDate.setText(dateMonth[1]);\n        } catch (ParseException e) {\n            e.printStackTrace();\n            GoogleAnalyticsUtil.trackException(mContext, e);\n        }\n        if (null != item.getItunesDuration()) {\n            \/\/Check if the duration is already formatted\n            if (item.getItunesDuration().contains(\":\")) {\n                holder.mTvPodcastDuration.setText(item.getItunesDuration());\n            } else {\n                long min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\n                long sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\n                holder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n            }\n        }\n        holder.mTvPodcastTitle.setText(item.getTitle());\n        holder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                \/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\n                String imageUrl = \"\";\n                Cursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\n                if (cursor != null) {\n                    while (cursor.moveToNext()) {\n                        imageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n                    }\n                }\n                Track track = new Track();\n                track.setTitle(item.getTitle());\n                track.setStreamUrl(item.getEnclosure().getUrl());\n                track.setArtist(item.getItunesAuthor());\n                track.setArtworkUrl(imageUrl);\n                track.setDurationInMilli(Converter.getMilliSeconds(item.getItunesDuration()));\n                if (mListener != null) {\n                    mListener.onTrackClicked(track);\n                }\n            }\n        });\n        holder.mEpisodeRl.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                displayBottomSheet(item);\n            }\n        });\n    }","code":"@Override\n    public void onBindViewHolder(final ViewHolder holder, final int position) {\n        final Item item = mItemList.get(position);\n        setListener(mListener);\n        String dateStr = item.getPubDate();\n        DateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.getDefault());\n        try {\n            Date date = formatter.parse(dateStr);\n            String pubDateStr = DateUtils.formatAbbrev(mContext, date);\n            String[] dateMonth = pubDateStr.split(\" \");\n            holder.mTvMonth.setText(dateMonth[0]);\n            holder.mTvDate.setText(dateMonth[1]);\n        } catch (ParseException e) {\n            e.printStackTrace();\n            GoogleAnalyticsUtil.trackException(mContext, e);\n        }\n        if (null != item.getItunesDuration()) {\n           \n            if (item.getItunesDuration().contains(\":\")) {\n                holder.mTvPodcastDuration.setText(item.getItunesDuration());\n            } else {\n                long min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\n                long sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\n                holder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n            }\n        }\n        holder.mTvPodcastTitle.setText(item.getTitle());\n        holder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               \n                String imageUrl = \"\";\n                Cursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\n                if (cursor != null) {\n                    while (cursor.moveToNext()) {\n                        imageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n                    }\n                }\n                Track track = new Track();\n                track.setTitle(item.getTitle());\n                track.setStreamUrl(item.getEnclosure().getUrl());\n                track.setArtist(item.getItunesAuthor());\n                track.setArtworkUrl(imageUrl);\n                track.setDurationInMilli(Converter.getMilliSeconds(item.getItunesDuration()));\n                if (mListener != null) {\n                    mListener.onTrackClicked(track);\n                }\n            }\n        });\n        holder.mEpisodeRl.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                displayBottomSheet(item);\n            }\n        });\n    }","cleancode":"@override public void onbindviewholder(final viewholder holder, final int position) { final item item = mitemlist.get(position); setlistener(mlistener); string datestr = item.getpubdate(); dateformat formatter = new simpledateformat(\"eee, dd mmm yyyy hh:mm:ss\", locale.getdefault()); try { date date = formatter.parse(datestr); string pubdatestr = dateutils.formatabbrev(mcontext, date); string[] datemonth = pubdatestr.split(\" \"); holder.mtvmonth.settext(datemonth[0]); holder.mtvdate.settext(datemonth[1]); } catch (parseexception e) { e.printstacktrace(); googleanalyticsutil.trackexception(mcontext, e); } if (null != item.getitunesduration()) { if (item.getitunesduration().contains(\":\")) { holder.mtvpodcastduration.settext(item.getitunesduration()); } else { long min = integer.parseint(item.getitunesduration()) \/ 60000; long sec = integer.parseint(item.getitunesduration()) % 60000 \/ 1000; holder.mtvpodcastduration.settext(string.format(mcontext.getresources().getstring(r.string.duration), min, sec)); } } holder.mtvpodcasttitle.settext(item.gettitle()); holder.mplayimagebutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { string imageurl = \"\"; cursor cursor = mcontext.getcontentresolver().query(muri, null, null, null, null); if (cursor != null) { while (cursor.movetonext()) { imageurl = cursor.getstring(applicationconstants.column_subscribed_podcast_feed_image_url); } } track track = new track(); track.settitle(item.gettitle()); track.setstreamurl(item.getenclosure().geturl()); track.setartist(item.getitunesauthor()); track.setartworkurl(imageurl); track.setdurationinmilli(converter.getmilliseconds(item.getitunesduration())); if (mlistener != null) { mlistener.ontrackclicked(track); } } }); holder.mepisoderl.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { displaybottomsheet(item); } }); }","comment":"\/\/check if the duration is already formatted\n\/\/todo:: change icon based on action. if playing, equalizer icon, pause pause-icon etc","repo":"c0de-wizard\/pod-adddict","code_context_2":"}\nif (null != item.getItunesDuration()) {\n\/\/Check if the duration is already formatted\nif (item.getItunesDuration().contains(\":\")) {\nholder.mTvPodcastDuration.setText(item.getItunesDuration());\n\n@Override\npublic void onClick(View v) {\n\/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\nString imageUrl = \"\";\nCursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);","code_context_10":"Date date = formatter.parse(dateStr);\nString pubDateStr = DateUtils.formatAbbrev(mContext, date);\nString[] dateMonth = pubDateStr.split(\" \");\nholder.mTvMonth.setText(dateMonth[0]);\nholder.mTvDate.setText(dateMonth[1]);\n} catch (ParseException e) {\ne.printStackTrace();\nGoogleAnalyticsUtil.trackException(mContext, e);\n}\nif (null != item.getItunesDuration()) {\n\/\/Check if the duration is already formatted\nif (item.getItunesDuration().contains(\":\")) {\nholder.mTvPodcastDuration.setText(item.getItunesDuration());\n} else {\nlong min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\nlong sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\nholder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n}\n}\nholder.mTvPodcastTitle.setText(item.getTitle());\nholder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n\n} else {\nlong min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\nlong sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\nholder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n}\n}\nholder.mTvPodcastTitle.setText(item.getTitle());\nholder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\nString imageUrl = \"\";\nCursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\nif (cursor != null) {\nwhile (cursor.moveToNext()) {\nimageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n}\n}\nTrack track = new Track();\ntrack.setTitle(item.getTitle());\ntrack.setStreamUrl(item.getEnclosure().getUrl());","code_context_20":"@Override\npublic void onBindViewHolder(final ViewHolder holder, final int position) {\nfinal Item item = mItemList.get(position);\nsetListener(mListener);\nString dateStr = item.getPubDate();\nDateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.getDefault());\ntry {\nDate date = formatter.parse(dateStr);\nString pubDateStr = DateUtils.formatAbbrev(mContext, date);\nString[] dateMonth = pubDateStr.split(\" \");\nholder.mTvMonth.setText(dateMonth[0]);\nholder.mTvDate.setText(dateMonth[1]);\n} catch (ParseException e) {\ne.printStackTrace();\nGoogleAnalyticsUtil.trackException(mContext, e);\n}\nif (null != item.getItunesDuration()) {\n\/\/Check if the duration is already formatted\nif (item.getItunesDuration().contains(\":\")) {\nholder.mTvPodcastDuration.setText(item.getItunesDuration());\n} else {\nlong min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\nlong sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\nholder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n}\n}\nholder.mTvPodcastTitle.setText(item.getTitle());\nholder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\nString imageUrl = \"\";\nCursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\nif (cursor != null) {\nwhile (cursor.moveToNext()) {\nimageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n}\n}\n\nholder.mTvMonth.setText(dateMonth[0]);\nholder.mTvDate.setText(dateMonth[1]);\n} catch (ParseException e) {\ne.printStackTrace();\nGoogleAnalyticsUtil.trackException(mContext, e);\n}\nif (null != item.getItunesDuration()) {\n\/\/Check if the duration is already formatted\nif (item.getItunesDuration().contains(\":\")) {\nholder.mTvPodcastDuration.setText(item.getItunesDuration());\n} else {\nlong min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\nlong sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\nholder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n}\n}\nholder.mTvPodcastTitle.setText(item.getTitle());\nholder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\nString imageUrl = \"\";\nCursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\nif (cursor != null) {\nwhile (cursor.moveToNext()) {\nimageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n}\n}\nTrack track = new Track();\ntrack.setTitle(item.getTitle());\ntrack.setStreamUrl(item.getEnclosure().getUrl());\ntrack.setArtist(item.getItunesAuthor());\ntrack.setArtworkUrl(imageUrl);\ntrack.setDurationInMilli(Converter.getMilliSeconds(item.getItunesDuration()));\nif (mListener != null) {\nmListener.onTrackClicked(track);\n}\n}\n});\nholder.mEpisodeRl.setOnClickListener(new View.OnClickListener() {\n@Override","label":[0,1,0,0]}
{"id":21985,"original_code":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n    {\n        final boolean IGNORE_STYLESHEETS = true;\n        final boolean IGNORE_FAVICON = true;\n        final boolean DOCBASE_ONLY = false;\n        ValueFactory factory = SimpleValueFactory.getInstance();\n        String documentBaseUriStr = documentBaseUri.toString();\n        Iterator<Statement> iter = model.iterator();\n        \/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n        \/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\n        Model filteredModel = new LinkedHashModel();\n        while (iter.hasNext()) {\n            Statement stmt = iter.next();\n            \/\/!!! Note !!!\n            \/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n            \/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n            \/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n            \/\/Because it's quite a hard fix to implement, we work around it here.\n            \/\/remove all the XHTML stylesheets predicates from the model\n            boolean removed = false;\n            if (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\n                removed = true;\n            }\n            \/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\n            if (!removed && IGNORE_FAVICON &&\n                stmt.getObject().toString().contains(\"favicon\") &&\n                (stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\n                 stmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\n                 stmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n                )) {\n                removed = true;\n            }\n            \/\/remove all non-documentBaseUri subjects from the model\n            if (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\n                removed = true;\n            }\n            \/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\n            if (!removed && stmt.getSubject() instanceof BNode) {\n                removed = true;\n            }\n            \/\/we'll use this loop to whitespace-trim the values while we're at it\n            \/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n            \/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n            \/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n            \/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n            \/\/ But it can be easily supported (the part where the exception is thrown)\n            if (!removed) {\n                \/\/these will hold possible modified pieces of the statement\n                Resource newSubject = null;\n                IRI newPredicate = null;\n                Value newObject = null;\n                \/\/trim all \"lang\" params from the subject\n                \/\/This is an important change:\n                \/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n                \/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n                \/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n                \/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n                \/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n                \/\/ That's why we try hard here to avoid these during import.\n                if (stmt.getSubject() instanceof IRI) {\n                    URI subject = URI.create(stmt.getSubject().stringValue());\n                    MultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\n                    if (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\n                        URI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\n                        newSubject = factory.createIRI(noLangUri.toString());\n                    }\n                }\n                \/\/if the object is a literal, check if it needs to be trimmed\n                \/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\n                if (stmt.getObject() instanceof Literal) {\n                    Literal literal = (Literal) stmt.getObject();\n                    String objectValue = literal.getLabel();\n                    \/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n                    \/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n                    \/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n                    \/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n                    \/\/automatically, so let's do it manually.\n                    if (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n                        \/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n                        \/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\n                        if (!StringUtils.isBlank(objectValue)) {\n                            URI objectUri = URI.create(objectValue);\n                            if (!objectUri.isAbsolute()) {\n                                objectUri = documentBaseUri.resolve(objectUri);\n                            }\n                            \/\/it makes sense to convert the data type to IRI as well\n                            newObject = factory.createIRI(objectUri.toString());\n                        }\n                    }\n                    \/\/this means it's a 'true' literal -> check if we can trim\n                    else {\n                        String objectValueTrimmed = StringUtils.strip(objectValue);\n                        if (!objectValue.equals(objectValueTrimmed)) {\n                            \/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\n                            if (literal.getDatatype().equals(RDF.LANGSTRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n                            }\n                            else if (literal.getDatatype().equals(XMLSchema.STRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else if (literal.getDatatype().equals(RDF.HTML)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else {\n                                throw new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n                            }\n                        }\n                    }\n                }\n                \/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\n                Statement validStmt = null;\n                if (newSubject != null || newObject != null || newPredicate != null) {\n                    if (newSubject == null) {\n                        newSubject = stmt.getSubject();\n                    }\n                    if (newPredicate == null) {\n                        newPredicate = stmt.getPredicate();\n                    }\n                    if (newObject == null) {\n                        newObject = stmt.getObject();\n                    }\n                    if (stmt.getContext() == null) {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject);\n                    }\n                    else {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n                    }\n                }\n                else {\n                    validStmt = stmt;\n                }\n                filteredModel.add(validStmt);\n            }\n        }\n        \/\/ if the settings say so, validate the incoming (filtered) model\n        if (Settings.instance().getEnableRdfValidation()) {\n            new RdfModelImpl(filteredModel).validate();\n        }\n        \/\/DEBUG\n        \/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\n        return filteredModel;\n    }","code":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n    {\n        final boolean IGNORE_STYLESHEETS = true;\n        final boolean IGNORE_FAVICON = true;\n        final boolean DOCBASE_ONLY = false;\n        ValueFactory factory = SimpleValueFactory.getInstance();\n        String documentBaseUriStr = documentBaseUri.toString();\n        Iterator<Statement> iter = model.iterator();\n       \n       \n        Model filteredModel = new LinkedHashModel();\n        while (iter.hasNext()) {\n            Statement stmt = iter.next();\n           \n           \n           \n           \n           \n           \n            boolean removed = false;\n            if (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\n                removed = true;\n            }\n           \n            if (!removed && IGNORE_FAVICON &&\n                stmt.getObject().toString().contains(\"favicon\") &&\n                (stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\n                 stmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\n                 stmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n                )) {\n                removed = true;\n            }\n           \n            if (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\n                removed = true;\n            }\n           \n            if (!removed && stmt.getSubject() instanceof BNode) {\n                removed = true;\n            }\n           \n           \n           \n           \n           \n           \n            if (!removed) {\n               \n                Resource newSubject = null;\n                IRI newPredicate = null;\n                Value newObject = null;\n               \n               \n               \n               \n               \n               \n               \n               \n                if (stmt.getSubject() instanceof IRI) {\n                    URI subject = URI.create(stmt.getSubject().stringValue());\n                    MultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\n                    if (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\n                        URI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\n                        newSubject = factory.createIRI(noLangUri.toString());\n                    }\n                }\n               \n               \n                if (stmt.getObject() instanceof Literal) {\n                    Literal literal = (Literal) stmt.getObject();\n                    String objectValue = literal.getLabel();\n                   \n                   \n                   \n                   \n                   \n                    if (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n                       \n                       \n                        if (!StringUtils.isBlank(objectValue)) {\n                            URI objectUri = URI.create(objectValue);\n                            if (!objectUri.isAbsolute()) {\n                                objectUri = documentBaseUri.resolve(objectUri);\n                            }\n                           \n                            newObject = factory.createIRI(objectUri.toString());\n                        }\n                    }\n                   \n                    else {\n                        String objectValueTrimmed = StringUtils.strip(objectValue);\n                        if (!objectValue.equals(objectValueTrimmed)) {\n                           \n                            if (literal.getDatatype().equals(RDF.LANGSTRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n                            }\n                            else if (literal.getDatatype().equals(XMLSchema.STRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else if (literal.getDatatype().equals(RDF.HTML)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else {\n                                throw new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n                            }\n                        }\n                    }\n                }\n               \n                Statement validStmt = null;\n                if (newSubject != null || newObject != null || newPredicate != null) {\n                    if (newSubject == null) {\n                        newSubject = stmt.getSubject();\n                    }\n                    if (newPredicate == null) {\n                        newPredicate = stmt.getPredicate();\n                    }\n                    if (newObject == null) {\n                        newObject = stmt.getObject();\n                    }\n                    if (stmt.getContext() == null) {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject);\n                    }\n                    else {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n                    }\n                }\n                else {\n                    validStmt = stmt;\n                }\n                filteredModel.add(validStmt);\n            }\n        }\n       \n        if (Settings.instance().getEnableRdfValidation()) {\n            new RdfModelImpl(filteredModel).validate();\n        }\n       \n       \n        return filteredModel;\n    }","cleancode":"protected model filtermodel(model model, uri documentbaseuri) throws ioexception { final boolean ignore_stylesheets = true; final boolean ignore_favicon = true; final boolean docbase_only = false; valuefactory factory = simplevaluefactory.getinstance(); string documentbaseuristr = documentbaseuri.tostring(); iterator<statement> iter = model.iterator(); model filteredmodel = new linkedhashmodel(); while (iter.hasnext()) { statement stmt = iter.next(); boolean removed = false; if (!removed && ignore_stylesheets && (stmt.getpredicate().tostring().equals(xhtml_ns_stylesheet) || stmt.getpredicate().tostring().equals(local_ns_stylesheet))) { removed = true; } if (!removed && ignore_favicon && stmt.getobject().tostring().contains(\"favicon\") && (stmt.getpredicate().tostring().equals(xhtml_ns_icon) || stmt.getpredicate().tostring().equals(local_ns_icon) || stmt.getpredicate().tostring().equals(xhtml_ns_apple_touch_icon) || stmt.getpredicate().tostring().equals(local_ns_apple_touch_icon) || stmt.getpredicate().tostring().equals(local_ns_manifest) )) { removed = true; } if (!removed && docbase_only && !stmt.getsubject().tostring().equals(documentbaseuristr)) { removed = true; } if (!removed && stmt.getsubject() instanceof bnode) { removed = true; } if (!removed) { resource newsubject = null; iri newpredicate = null; value newobject = null; if (stmt.getsubject() instanceof iri) { uri subject = uri.create(stmt.getsubject().stringvalue()); multivaluedmap<string, string> queryparams = stringfunctions.getqueryparameters(subject); if (queryparams != null && queryparams.containskey(i18nfactory.lang_query_param)) { uri nolanguri = uribuilder.fromuri(subject).replacequeryparam(i18nfactory.lang_query_param).build(); newsubject = factory.createiri(nolanguri.tostring()); } } if (stmt.getobject() instanceof literal) { literal literal = (literal) stmt.getobject(); string objectvalue = literal.getlabel(); if (literal.getdatatype().equals(xmlschema.anyuri)) { if (!stringutils.isblank(objectvalue)) { uri objecturi = uri.create(objectvalue); if (!objecturi.isabsolute()) { objecturi = documentbaseuri.resolve(objecturi); } newobject = factory.createiri(objecturi.tostring()); } } else { string objectvaluetrimmed = stringutils.strip(objectvalue); if (!objectvalue.equals(objectvaluetrimmed)) { if (literal.getdatatype().equals(rdf.langstring)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getlanguage().get()); } else if (literal.getdatatype().equals(xmlschema.string)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getdatatype()); } else if (literal.getdatatype().equals(rdf.html)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getdatatype()); } else { throw new ioexception(\"encountered unsupported simple literal value, this shouldn't happen; \" + literal.getdatatype() + \" - \" + objectvalue); } } } } statement validstmt = null; if (newsubject != null || newobject != null || newpredicate != null) { if (newsubject == null) { newsubject = stmt.getsubject(); } if (newpredicate == null) { newpredicate = stmt.getpredicate(); } if (newobject == null) { newobject = stmt.getobject(); } if (stmt.getcontext() == null) { validstmt = factory.createstatement(newsubject, newpredicate, newobject); } else { validstmt = factory.createstatement(newsubject, newpredicate, newobject, stmt.getcontext()); } } else { validstmt = stmt; } filteredmodel.add(validstmt); } } if (settings.instance().getenablerdfvalidation()) { new rdfmodelimpl(filteredmodel).validate(); } return filteredmodel; }","comment":"\/\/-----public methods----- \/\/-----protected methods----- \/** * note: this returns a newly created (memory based) model, so all connections with a possible underlying store are cut *\/\n\/\/note that the model has a \"predictable iteration order\", and since we get a concurrentmodexception while altering the model itself, \/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\n\/\/!!! note !!! \/\/the double (eg. both xhtml_ns_stylesheet and local_ns_stylesheet) checks below are the result of a bug: \/\/because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace, \/\/so they're actually not real xhtml predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet \/\/because it's quite a hard fix to implement, we work around it here. \/\/remove all the xhtml stylesheets predicates from the model\n\/\/removes all favicon statements. note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\n\/\/remove all non-documentbaseuri subjects from the model\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\n\/\/we'll use this loop to whitespace-trim the values while we're at it \/\/note that this is a bit hacky. the more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.sesamesink.addplainliteral() \/\/ method, but that class is supposed to be part of the core sesame library (only copied over to have rdfa support in sesame4), so i opted to implement it here \/\/also note that this implementation doens't trim the non-plain literal values (like datetime). they are passed over via the @content attribute inside rdfa, \/\/ so it should be quite clean already. also because the html input stream, coming from jsoup is minified before passed to sesame. \/\/ but it can be easily supported (the part where the exception is thrown)\n\/\/these will hold possible modified pieces of the statement\n\/\/trim all \"lang\" params from the subject \/\/this is an important change: \/\/ from time to time, the eg. ?lang=en part of an uri seeps through, even though we set every rdfa html tag with a clear @about attribute \/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesvocabulary\" \/\/ because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes), \/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using sparql). \/\/ we group by subject-uri and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc. \/\/ that's why we try hard here to avoid these during import.\n\/\/if the object is a literal, check if it needs to be trimmed \/\/big note: xsd.anyuri is also an instance of a literal!!\n\/\/we like to use and save relative uris as relative uris because it means we don't need to \/\/update them if the site domain changes. but the rdfa doc clearly states all relative uris need \/\/to be converted to absolute uris: https:\/\/www.w3.org\/tr\/rdfa-core\/#s_curieprocessing \/\/however, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyuri\"> tags), this doesn't happen \/\/automatically, so let's do it manually.\n\/\/this is important: blank uris (and this happens; eg. a tag <meta property=\"sameas\" datatype=\"xsd:anyuri\" \/> will yield a blank value for \"sameas\"!) \/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameas properties)\n\/\/it makes sense to convert the data type to iri as well\n\/\/this means it's a 'true' literal -> check if we can trim\n\/\/note: this makes sense: see simpleliteral(string label, iri datatype) constructor code\n\/\/after all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\n\/\/ if the settings say so, validate the incoming (filtered) model\n\/\/debug \/\/rdfdatamgr.write(system.out, model, rdfformat.ntriples);","repo":"bramdvrepublic\/com.beligum.blocks.core","code_context_2":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}\n\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\n\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\n\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\n\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\n\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\n\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\n\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\n\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\n\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\n\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}","code_context_10":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}\n\nprotected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\n\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\n\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\n\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\n\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\n\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\n\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}\n\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}","code_context_20":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}\n\nprotected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\n\nprotected Model filterModel(Model model, URI documentBaseUri) throws IOException\n{\nfinal boolean IGNORE_STYLESHEETS = true;\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n\nfinal boolean IGNORE_FAVICON = true;\nfinal boolean DOCBASE_ONLY = false;\nValueFactory factory = SimpleValueFactory.getInstance();\nString documentBaseUriStr = documentBaseUri.toString();\nIterator<Statement> iter = model.iterator();\n\/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n\/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\nModel filteredModel = new LinkedHashModel();\nwhile (iter.hasNext()) {\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\nStatement stmt = iter.next();\n\/\/!!! Note !!!\n\/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n\/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\n\/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n\/\/Because it's quite a hard fix to implement, we work around it here.\n\/\/remove all the XHTML stylesheets predicates from the model\nboolean removed = false;\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\nif (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\nremoved = true;\n}\n\/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\nif (!removed && IGNORE_FAVICON &&\nstmt.getObject().toString().contains(\"favicon\") &&\n(stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n\nstmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\nstmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n)) {\nremoved = true;\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\n}\n\/\/remove all non-documentBaseUri subjects from the model\nif (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\nremoved = true;\n}\n\/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\nif (!removed && stmt.getSubject() instanceof BNode) {\nremoved = true;\n}\n\/\/we'll use this loop to whitespace-trim the values while we're at it\n\/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n\/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n\/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n\/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n\/\/ But it can be easily supported (the part where the exception is thrown)\nif (!removed) {\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\n\/\/these will hold possible modified pieces of the statement\nResource newSubject = null;\nIRI newPredicate = null;\nValue newObject = null;\n\/\/trim all \"lang\" params from the subject\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\n\/\/This is an important change:\n\/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n\/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n\/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n\/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n\/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\n\n\/\/ That's why we try hard here to avoid these during import.\nif (stmt.getSubject() instanceof IRI) {\nURI subject = URI.create(stmt.getSubject().stringValue());\nMultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\nif (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\nURI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\nnewSubject = factory.createIRI(noLangUri.toString());\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\n\n}\n}\n\/\/if the object is a literal, check if it needs to be trimmed\n\/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n\nif (stmt.getObject() instanceof Literal) {\nLiteral literal = (Literal) stmt.getObject();\nString objectValue = literal.getLabel();\n\/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\n\n\/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n\/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n\/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n\/\/automatically, so let's do it manually.\nif (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n\/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n\/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\nif (!StringUtils.isBlank(objectValue)) {\nURI objectUri = URI.create(objectValue);\nif (!objectUri.isAbsolute()) {\nobjectUri = documentBaseUri.resolve(objectUri);\n}\n\/\/it makes sense to convert the data type to IRI as well\nnewObject = factory.createIRI(objectUri.toString());\n}\n}\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n\n\/\/this means it's a 'true' literal -> check if we can trim\nelse {\nString objectValueTrimmed = StringUtils.strip(objectValue);\nif (!objectValue.equals(objectValueTrimmed)) {\n\/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\nif (literal.getDatatype().equals(RDF.LANGSTRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n}\nelse if (literal.getDatatype().equals(XMLSchema.STRING)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse if (literal.getDatatype().equals(RDF.HTML)) {\nnewObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n}\nelse {\nthrow new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n}\n}\n}\n}\n\/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\nStatement validStmt = null;\nif (newSubject != null || newObject != null || newPredicate != null) {\nif (newSubject == null) {\nnewSubject = stmt.getSubject();\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n\n}\nif (newPredicate == null) {\nnewPredicate = stmt.getPredicate();\n}\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}\n\nif (newObject == null) {\nnewObject = stmt.getObject();\n}\nif (stmt.getContext() == null) {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject);\n}\nelse {\nvalidStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n}\n}\nelse {\nvalidStmt = stmt;\n}\nfilteredModel.add(validStmt);\n}\n}\n\/\/ if the settings say so, validate the incoming (filtered) model\nif (Settings.instance().getEnableRdfValidation()) {\nnew RdfModelImpl(filteredModel).validate();\n}\n\/\/DEBUG\n\/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\nreturn filteredModel;\n}","label":[1,0,0,0]}
{"id":13815,"original_code":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n        \/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n        \/\/TODO: make more robust\n        SortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\n        int count = 0;\n        Iterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\n        while (ratiosSortedSetIterator.hasNext()) {\n            DataModelInterface ratio = ratiosSortedSetIterator.next();\n            ((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n            \/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n            \/\/if ( standardValuesMap[count] == 0.0 ) {\n            ((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n            \/\/}\n            count++;\n        }\n    }","code":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n       \n       \n        SortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting()\n        int count = 0;\n        Iterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\n        while (ratiosSortedSetIterator.hasNext()) {\n            DataModelInterface ratio = ratiosSortedSetIterator.next();\n            ((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n           \n           \n            ((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n           \n            count++;\n        }\n    }","cleancode":"public void updaterawratiodatamodelswithprimarystandardvalue(double[] standardvaluesmap) { sortedset<datamodelinterface> ratiossortedset = getratiosforfractionfitting() int count = 0; iterator<datamodelinterface> ratiossortedsetiterator = ratiossortedset.iterator(); while (ratiossortedsetiterator.hasnext()) { datamodelinterface ratio = ratiossortedsetiterator.next(); ((rawratiodatamodel) ratio).setstandardvalue(standardvaluesmap[count]); ((rawratiodatamodel) ratio).setusedforfractionationcorrections(standardvaluesmap[count] != 0.0); count++; } }","comment":"\/** * * @param standardvaluesmap *\/\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values \/\/todo: make more robust\n\/\/getvalidrawratios();\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration \/\/if ( standardvaluesmap[count] == 0.0 ) {\n\/\/}","repo":"bowring\/ET_Redux","code_context_2":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\n\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\n\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\n\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}","code_context_10":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}","code_context_20":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}\n\npublic void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n\/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n\/\/TODO: make more robust\nSortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\nint count = 0;\nIterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\nwhile (ratiosSortedSetIterator.hasNext()) {\nDataModelInterface ratio = ratiosSortedSetIterator.next();\n((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n\/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n\/\/if ( standardValuesMap[count] == 0.0 ) {\n((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n\/\/}\ncount++;\n}\n}","label":[1,0,0,0]}
{"id":13882,"original_code":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\n    FiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n    \/\/ Compute the chaining distances.\n    \/\/ We do <i>not<\/i> bother to materialize the chaining order.\n    for(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\n      final KNNList neighbors = knnq.getKNNForDBID(iter, k);\n      final int r = neighbors.size();\n      DoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n      \/\/ Store the current lowest reachability.\n      final double[] mindists = new double[r];\n      for(int i = 0; it1.valid(); it1.advance(), ++i) {\n        mindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n      }\n      double acsum = 0.;\n      for(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n        \/\/ Find the minimum:\n        int minpos = -1;\n        double mindist = Double.NaN;\n        for(int i = 0; i < mindists.length; ++i) {\n          double curdist = mindists[i];\n          \/\/ Both values could be NaN, deliberately.\n          if(curdist == curdist && !(curdist > mindist)) {\n            minpos = i;\n            mindist = curdist;\n          }\n        }\n        acsum += mindist * j; \/\/ Weighted sum, decreasing weights\n        mindists[minpos] = Double.NaN;\n        it1.seek(minpos);\n        \/\/ Update distances\n        it2.seek(0);\n        for(int i = 0; it2.valid(); it2.advance(), ++i) {\n          final double curdist = mindists[i];\n          if(curdist != curdist) {\n            continue; \/\/ NaN = processed!\n          }\n          double newdist = dq.distance(it1, it2);\n          if(newdist < curdist) {\n            mindists[i] = newdist;\n          }\n        }\n      }\n      acds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\n      LOG.incrementProcessed(lrdsProgress);\n    }\n    LOG.ensureCompleted(lrdsProgress);\n  }","code":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\n    FiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n   \n   \n    for(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\n      final KNNList neighbors = knnq.getKNNForDBID(iter, k);\n      final int r = neighbors.size();\n      DoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n     \n      final double[] mindists = new double[r];\n      for(int i = 0; it1.valid(); it1.advance(), ++i) {\n        mindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n      }\n      double acsum = 0.;\n      for(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n       \n        int minpos = -1;\n        double mindist = Double.NaN;\n        for(int i = 0; i < mindists.length; ++i) {\n          double curdist = mindists[i];\n         \n          if(curdist == curdist && !(curdist > mindist)) {\n            minpos = i;\n            mindist = curdist;\n          }\n        }\n        acsum += mindist * j;\n        mindists[minpos] = Double.NaN;\n        it1.seek(minpos);\n       \n        it2.seek(0);\n        for(int i = 0; it2.valid(); it2.advance(), ++i) {\n          final double curdist = mindists[i];\n          if(curdist != curdist) {\n            continue;\n          }\n          double newdist = dq.distance(it1, it2);\n          if(newdist < curdist) {\n            mindists[i] = newdist;\n          }\n        }\n      }\n      acds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\n      LOG.incrementProcessed(lrdsProgress);\n    }\n    LOG.ensureCompleted(lrdsProgress);\n  }","cleancode":"protected void computeaveragechainingdistances(knnquery<o> knnq, distancequery<o> dq, dbids ids, writabledoubledatastore acds) { finiteprogress lrdsprogress = log.isverbose() ? new finiteprogress(\"computing average chaining distances\", ids.size(), log) : null; for(dbiditer iter = ids.iter(); iter.valid(); iter.advance()) { final knnlist neighbors = knnq.getknnfordbid(iter, k); final int r = neighbors.size(); doubledbidlistiter it1 = neighbors.iter(), it2 = neighbors.iter(); final double[] mindists = new double[r]; for(int i = 0; it1.valid(); it1.advance(), ++i) { mindists[i] = dbidutil.equal(it1, iter) ? double.nan : it1.doublevalue(); } double acsum = 0.; for(int j = ((r < k) ? r : k) - 1; j > 0; --j) { int minpos = -1; double mindist = double.nan; for(int i = 0; i < mindists.length; ++i) { double curdist = mindists[i]; if(curdist == curdist && !(curdist > mindist)) { minpos = i; mindist = curdist; } } acsum += mindist * j; mindists[minpos] = double.nan; it1.seek(minpos); it2.seek(0); for(int i = 0; it2.valid(); it2.advance(), ++i) { final double curdist = mindists[i]; if(curdist != curdist) { continue; } double newdist = dq.distance(it1, it2); if(newdist < curdist) { mindists[i] = newdist; } } } acds.putdouble(iter, acsum \/ (r * 0.5 * (r - 1.))); log.incrementprocessed(lrdsprogress); } log.ensurecompleted(lrdsprogress); }","comment":"\/** * computes the average chaining distance, the average length of a path * through the given set of points to each target. the authors of cof decided * to approximate this value using a weighted mean that assumes every object * is reached from the previous point (but actually every point could be best * reachable from the first, in which case this does not make much sense.) * * todo: can we accelerate this by using the knn of the neighbors? * * @param knnq knn query * @param dq distance query * @param ids ids to process * @param acds storage for average chaining distances *\/\n\/\/ compute the chaining distances. \/\/ we do <i>not<\/i> bother to materialize the chaining order.\n\/\/ store the current lowest reachability.\n\/\/ find the minimum:\n\/\/ both values could be nan, deliberately.\n\/\/ weighted sum, decreasing weights\n\/\/ update distances\n\/\/ nan = processed!","repo":"bertl4398\/ssdbm2020","code_context_2":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\n\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\n\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\n\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\n\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\n\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);","code_context_10":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\n\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\n\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\n\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\n\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}","code_context_20":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\n\nprotected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\nFiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n\/\/ Compute the chaining distances.\n\/\/ We do <i>not<\/i> bother to materialize the chaining order.\nfor(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\nfinal KNNList neighbors = knnq.getKNNForDBID(iter, k);\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n\nfinal int r = neighbors.size();\nDoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n\/\/ Store the current lowest reachability.\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}\n\nfinal double[] mindists = new double[r];\nfor(int i = 0; it1.valid(); it1.advance(), ++i) {\nmindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n}\ndouble acsum = 0.;\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}\n\nfor(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n\/\/ Find the minimum:\nint minpos = -1;\ndouble mindist = Double.NaN;\nfor(int i = 0; i < mindists.length; ++i) {\ndouble curdist = mindists[i];\n\/\/ Both values could be NaN, deliberately.\nif(curdist == curdist && !(curdist > mindist)) {\nminpos = i;\nmindist = curdist;\n}\n}\nacsum += mindist * j; \/\/ Weighted sum, decreasing weights\nmindists[minpos] = Double.NaN;\nit1.seek(minpos);\n\/\/ Update distances\nit2.seek(0);\nfor(int i = 0; it2.valid(); it2.advance(), ++i) {\nfinal double curdist = mindists[i];\nif(curdist != curdist) {\ncontinue; \/\/ NaN = processed!\n}\ndouble newdist = dq.distance(it1, it2);\nif(newdist < curdist) {\nmindists[i] = newdist;\n}\n}\n}\nacds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\nLOG.incrementProcessed(lrdsProgress);\n}\nLOG.ensureCompleted(lrdsProgress);\n}","label":[1,0,0,0]}
{"id":22220,"original_code":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\n        PerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\n        String author = \"\";\n        String cite = \"\";\n       \/\/ System.out.println(\"Start\");\n        ArrayList<String> perspectives = new ArrayList<String>();\n        if (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\n            ArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n           \/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\n            for (int i = 0; i < perspectiveTriples.size(); i++) {\n                Statement statement = perspectiveTriples.get(i);\n                String subject = statement.getSubject().getURI();\n                String predicate = statement.getPredicate().getURI();\n                String object = statement.getObject().toString();\n                if (predicate.endsWith(\"#hasAttribution\")) {\n                    if (trigTripleData.tripleMapGrasp.containsKey(object)) {\n                        ArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\n                        for (int j = 0; j < perspectiveValues.size(); j++) {\n                            Statement statement1 = perspectiveValues.get(j);\n                            \/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n                           \/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n                            \/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\n                            if (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\n                                if (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n                                    \/\/\/\/ this means the source has properties so it is likely to be the document with an author\n                                    ArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\n                                    for (int k = 0; k < provStatements.size(); k++) {\n                                        Statement statement2 = provStatements.get(k);\n                                        author = statement2.getObject().toString();\n                                        int idx = author.lastIndexOf(\"\/\");\n                                        if (idx > -1) {\n                                            author = author.substring(idx + 1);\n                                        }\n                                     \/\/   System.out.println(\"author source = \" + author);\n                                    }\n                                } else {\n                                    \/\/\/\/ it is not the document so a cited source\n                                    cite = statement1.getObject().toString();\n                                    int idx = cite.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        cite = cite.substring(idx + 1);\n                                    }\n\/*                                  THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n                                    \/\/\/\/ There can be source documents without meta data.\n                                    \/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n                                    \/\/\/\/ The next hack checks for upper case characters in the URI\n                                    \/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\n                                    if (cite.toLowerCase().equals(cite)) {\n                                        \/\/\/\/ no uppercase characters\n                                        cite = meta;\n                                    }\n*\/\n                                  \/\/  System.out.println(\"quote source = \" + cite);\n                                }\n                            } else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\n                                String perspective = \"\";\n                                String str = statement1.getObject().toString();\n                                \/\/   System.out.println(\"str = \" + str);\n                                int idx = str.lastIndexOf(\"#\");\n                                if (idx > -1) {\n                                    perspective = str.substring(idx + 1);\n                                } else {\n                                    idx = str.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        perspective = str.substring(idx + 1);\n                                    } else {\n                                        perspective = str;\n                                    }\n                                }\n                                ArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\n                                for (int k = 0; k < myPerspectives.size(); k++) {\n                                    String myPerspective = myPerspectives.get(k);\n                                    if (!perspectives.contains(myPerspective)) {\n                                      \/\/  System.out.println(\"myPerspective = \" + myPerspective);\n                                        perspectives.add(myPerspective);\n                                    }\n                                }\n                            } else {\n                               \/\/     System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n                            }\n                        }\n                    }\n                }\n            }\n            if (perspectives.size() > 0) {\n              \/\/  System.out.println(\"final author = \" + author);\n                perspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n            }\n        }\n        return perspectiveJsonObject;\n    }","code":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\n        PerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\n        String author = \"\";\n        String cite = \"\";\n      \n        ArrayList<String> perspectives = new ArrayList<String>();\n        if (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\n            ArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n          \n            for (int i = 0; i < perspectiveTriples.size(); i++) {\n                Statement statement = perspectiveTriples.get(i);\n                String subject = statement.getSubject().getURI();\n                String predicate = statement.getPredicate().getURI();\n                String object = statement.getObject().toString();\n                if (predicate.endsWith(\"#hasAttribution\")) {\n                    if (trigTripleData.tripleMapGrasp.containsKey(object)) {\n                        ArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\n                        for (int j = 0; j < perspectiveValues.size(); j++) {\n                            Statement statement1 = perspectiveValues.get(j);\n                           \n                          \n                           \n                            if (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\n                                if (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n                                   \n                                    ArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\n                                    for (int k = 0; k < provStatements.size(); k++) {\n                                        Statement statement2 = provStatements.get(k);\n                                        author = statement2.getObject().toString();\n                                        int idx = author.lastIndexOf(\"\/\");\n                                        if (idx > -1) {\n                                            author = author.substring(idx + 1);\n                                        }\n                                    \n                                    }\n                                } else {\n                                   \n                                    cite = statement1.getObject().toString();\n                                    int idx = cite.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        cite = cite.substring(idx + 1);\n                                    }\n                                 \n                                }\n                            } else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\n                                String perspective = \"\";\n                                String str = statement1.getObject().toString();\n                               \n                                int idx = str.lastIndexOf(\"#\");\n                                if (idx > -1) {\n                                    perspective = str.substring(idx + 1);\n                                } else {\n                                    idx = str.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        perspective = str.substring(idx + 1);\n                                    } else {\n                                        perspective = str;\n                                    }\n                                }\n                                ArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\n                                for (int k = 0; k < myPerspectives.size(); k++) {\n                                    String myPerspective = myPerspectives.get(k);\n                                    if (!perspectives.contains(myPerspective)) {\n                                     \n                                        perspectives.add(myPerspective);\n                                    }\n                                }\n                            } else {\n                              \n                            }\n                        }\n                    }\n                }\n            }\n            if (perspectives.size() > 0) {\n             \n                perspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n            }\n        }\n        return perspectiveJsonObject;\n    }","cleancode":"public static perspectivejsonobject getperspectiveobjectforevent(trigtripledata trigtripledata, string mentionuri, string meta) { perspectivejsonobject perspectivejsonobject = new perspectivejsonobject(); string author = \"\"; string cite = \"\"; arraylist<string> perspectives = new arraylist<string>(); if (trigtripledata.triplemapgrasp.containskey(mentionuri)) { arraylist<statement> perspectivetriples = trigtripledata.triplemapgrasp.get(mentionuri); for (int i = 0; i < perspectivetriples.size(); i++) { statement statement = perspectivetriples.get(i); string subject = statement.getsubject().geturi(); string predicate = statement.getpredicate().geturi(); string object = statement.getobject().tostring(); if (predicate.endswith(\"#hasattribution\")) { if (trigtripledata.triplemapgrasp.containskey(object)) { arraylist<statement> perspectivevalues = trigtripledata.triplemapgrasp.get(object); for (int j = 0; j < perspectivevalues.size(); j++) { statement statement1 = perspectivevalues.get(j); if (statement1.getpredicate().geturi().endswith(\"#wasattributedto\")) { if (trigtripledata.triplemapgrasp.containskey(statement1.getobject().tostring())) { arraylist<statement> provstatements = trigtripledata.triplemapgrasp.get(statement1.getobject().tostring()); for (int k = 0; k < provstatements.size(); k++) { statement statement2 = provstatements.get(k); author = statement2.getobject().tostring(); int idx = author.lastindexof(\"\/\"); if (idx > -1) { author = author.substring(idx + 1); } } } else { cite = statement1.getobject().tostring(); int idx = cite.lastindexof(\"\/\"); if (idx > -1) { cite = cite.substring(idx + 1); } } } else if (statement1.getpredicate().geturi().endswith(\"#value\")) { string perspective = \"\"; string str = statement1.getobject().tostring(); int idx = str.lastindexof(\"#\"); if (idx > -1) { perspective = str.substring(idx + 1); } else { idx = str.lastindexof(\"\/\"); if (idx > -1) { perspective = str.substring(idx + 1); } else { perspective = str; } } arraylist<string> myperspectives = perspectivejsonobject.normalizeperspectivevalue(perspective); for (int k = 0; k < myperspectives.size(); k++) { string myperspective = myperspectives.get(k); if (!perspectives.contains(myperspective)) { perspectives.add(myperspective); } } } else { } } } } } if (perspectives.size() > 0) { perspectivejsonobject = new perspectivejsonobject(perspectives, author, cite, \"\", \"\", \"\", mentionuri, null); } } return perspectivejsonobject; }","comment":"\/\/ system.out.println(\"start\");\n\/\/ system.out.println(\"perspectivetriples.size() = \" + perspectivetriples.size());\n\/\/system.out.println(\"statement1.tostring() = \" + statement1.tostring()); \/\/ system.out.println(\"statement1.getobject().tostring() = \" + statement1.getobject().tostring()); \/\/ttp:\/\/www.w3.org\/ns\/prov#wasattributedto,\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\n\/\/ system.out.println(\"author source = \" + author);\n\/\/\/\/ it is not the document so a cited source\n\/* this does not work: pronouns, receptionist, etc... \/\/\/\/ there can be source documents without meta data. \/\/\/\/ in that case, there are no triples for in triplemapgrasp with this subject but it is still a document \/\/\/\/ the next hack checks for upper case characters in the uri \/\/\/\/ if they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string if (cite.tolowercase().equals(cite)) { \/\/\/\/ no uppercase characters cite = meta; } *\/\n\/\/ system.out.println(\"quote source = \" + cite);\n\/\/ system.out.println(\"str = \" + str);\n\/\/ system.out.println(\"myperspective = \" + myperspective);\n\/\/ system.out.println(\"statement1.getpredicate().geturi() = \" + statement1.getpredicate().geturi());\n\/\/ system.out.println(\"final author = \" + author);","repo":"cltl\/EventCoreference","code_context_2":"String author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\n\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\n\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\n\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\n\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\n\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\n\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}","code_context_10":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\nPerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\nString author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\n\npublic static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\nPerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\nString author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\n\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\n\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\n\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\n\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}\n}\n\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}\n}\nreturn perspectiveJsonObject;\n}","code_context_20":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\nPerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\nString author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\n\npublic static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\nPerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\nString author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\n\npublic static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\nPerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\nString author = \"\";\nString cite = \"\";\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\n\/\/ System.out.println(\"Start\");\nArrayList<String> perspectives = new ArrayList<String>();\nif (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\nArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n\/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\nfor (int i = 0; i < perspectiveTriples.size(); i++) {\nStatement statement = perspectiveTriples.get(i);\nString subject = statement.getSubject().getURI();\nString predicate = statement.getPredicate().getURI();\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\nString object = statement.getObject().toString();\nif (predicate.endsWith(\"#hasAttribution\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(object)) {\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n\nArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\nfor (int j = 0; j < perspectiveValues.size(); j++) {\nStatement statement1 = perspectiveValues.get(j);\n\/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n\/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n\/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\nif (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\nif (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n\/\/\/\/ this means the source has properties so it is likely to be the document with an author\nArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\nfor (int k = 0; k < provStatements.size(); k++) {\nStatement statement2 = provStatements.get(k);\nauthor = statement2.getObject().toString();\nint idx = author.lastIndexOf(\"\/\");\nif (idx > -1) {\nauthor = author.substring(idx + 1);\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\n\n}\n\/\/ System.out.println(\"author source = \" + author);\n}\n} else {\n\/\/\/\/ it is not the document so a cited source\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\ncite = statement1.getObject().toString();\nint idx = cite.lastIndexOf(\"\/\");\nif (idx > -1) {\ncite = cite.substring(idx + 1);\n}\n\/* THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n\/\/\/\/ There can be source documents without meta data.\n\/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n\/\/\/\/ The next hack checks for upper case characters in the URI\n\/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\nif (cite.toLowerCase().equals(cite)) {\n\/\/\/\/ no uppercase characters\ncite = meta;\n}\n*\/\n\/\/ System.out.println(\"quote source = \" + cite);\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\n}\n} else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\nString perspective = \"\";\nString str = statement1.getObject().toString();\n\/\/ System.out.println(\"str = \" + str);\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}\n}\nreturn perspectiveJsonObject;\n}\n\nint idx = str.lastIndexOf(\"#\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nidx = str.lastIndexOf(\"\/\");\nif (idx > -1) {\nperspective = str.substring(idx + 1);\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}\n}\nreturn perspectiveJsonObject;\n}\n\n} else {\nperspective = str;\n}\n}\nArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\nfor (int k = 0; k < myPerspectives.size(); k++) {\nString myPerspective = myPerspectives.get(k);\nif (!perspectives.contains(myPerspective)) {\n\/\/ System.out.println(\"myPerspective = \" + myPerspective);\nperspectives.add(myPerspective);\n}\n}\n} else {\n\/\/ System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n}\n}\n}\n}\n}\nif (perspectives.size() > 0) {\n\/\/ System.out.println(\"final author = \" + author);\nperspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n}\n}\nreturn perspectiveJsonObject;\n}","label":[0,0,1,0]}
{"id":14154,"original_code":"@Test\n  void buildTask() throws Exception {\n    VelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\n    CountDownLatch latch = new CountDownLatch(1);\n    ScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n        .schedule();\n    latch.await();\n    assertEquals(TaskStatus.FINISHED, task.status());\n  }","code":"@Test\n  void buildTask() throws Exception {\n    VelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\n    CountDownLatch latch = new CountDownLatch(1);\n    ScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n        .schedule();\n    latch.await();\n    assertEquals(TaskStatus.FINISHED, task.status());\n  }","cleancode":"@test void buildtask() throws exception { velocityscheduler scheduler = new velocityscheduler(new fakepluginmanager()); countdownlatch latch = new countdownlatch(1); scheduledtask task = scheduler.buildtask(fakepluginmanager.plugin_a, latch::countdown) .schedule(); latch.await(); assertequals(taskstatus.finished, task.status()); }","comment":"\/\/ todo: the timings here will be inaccurate on slow systems.","repo":"astei\/velocity","code_context_2":"@Test\nvoid buildTask() throws Exception {\nVelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\nCountDownLatch latch = new CountDownLatch(1);\nScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n.schedule();\nlatch.await();\nassertEquals(TaskStatus.FINISHED, task.status());\n}","code_context_10":"@Test\nvoid buildTask() throws Exception {\nVelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\nCountDownLatch latch = new CountDownLatch(1);\nScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n.schedule();\nlatch.await();\nassertEquals(TaskStatus.FINISHED, task.status());\n}","code_context_20":"@Test\nvoid buildTask() throws Exception {\nVelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\nCountDownLatch latch = new CountDownLatch(1);\nScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n.schedule();\nlatch.await();\nassertEquals(TaskStatus.FINISHED, task.status());\n}","label":[0,0,1,0]}
{"id":30548,"original_code":"@Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        ParseUser currentUser = ParseUser.getCurrentUser();\n        String role = currentUser.getString(\"role\");\n        if(convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.product_list_item, null);\n            holder = new ViewHolder();\n            holder.companyNameLabel = (TextView) convertView.findViewById(R.id.companyName);\n            holder.productNameLabel = (TextView) convertView.findViewById(R.id.productNameLabel);\n            holder.priceNameLabel = (TextView) convertView.findViewById(R.id.productPriceLabel);\n            holder.addItemButton = (Button) convertView.findViewById(R.id.btnAddToCart);\n            holder.editItemButton = (Button) convertView.findViewById(R.id.btnEditButton);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        if (role.equals(\"Company Account\")) {\n            holder.editItemButton.setVisibility(View.VISIBLE);\n        }\n        else if (role.equals(\"Personal Account\")) {\n            holder.addItemButton.setVisibility(View.VISIBLE);\n        }\n        final Product product = mProducts.get(position);\n        holder.companyNameLabel.setText(product.getCompany());\n        holder.productNameLabel.setText(product.getProductName());\n        holder.priceNameLabel.setText(product.getPrice() + \"\");\n        holder.addItemButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(mContext, CheckoutActivity.class);\n                intent.putExtra(\"product\", product.getProductName());\n                mContext.startActivity(intent);\n                \/\/TODO: Add functionality for edit button\n            }\n        });\n        return convertView;\n    }","code":"@Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        ParseUser currentUser = ParseUser.getCurrentUser();\n        String role = currentUser.getString(\"role\");\n        if(convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.product_list_item, null);\n            holder = new ViewHolder();\n            holder.companyNameLabel = (TextView) convertView.findViewById(R.id.companyName);\n            holder.productNameLabel = (TextView) convertView.findViewById(R.id.productNameLabel);\n            holder.priceNameLabel = (TextView) convertView.findViewById(R.id.productPriceLabel);\n            holder.addItemButton = (Button) convertView.findViewById(R.id.btnAddToCart);\n            holder.editItemButton = (Button) convertView.findViewById(R.id.btnEditButton);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        if (role.equals(\"Company Account\")) {\n            holder.editItemButton.setVisibility(View.VISIBLE);\n        }\n        else if (role.equals(\"Personal Account\")) {\n            holder.addItemButton.setVisibility(View.VISIBLE);\n        }\n        final Product product = mProducts.get(position);\n        holder.companyNameLabel.setText(product.getCompany());\n        holder.productNameLabel.setText(product.getProductName());\n        holder.priceNameLabel.setText(product.getPrice() + \"\");\n        holder.addItemButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(mContext, CheckoutActivity.class);\n                intent.putExtra(\"product\", product.getProductName());\n                mContext.startActivity(intent);\n               \n            }\n        });\n        return convertView;\n    }","cleancode":"@override public view getview(int position, view convertview, viewgroup parent) { viewholder holder; parseuser currentuser = parseuser.getcurrentuser(); string role = currentuser.getstring(\"role\"); if(convertview == null) { convertview = layoutinflater.from(mcontext).inflate(r.layout.product_list_item, null); holder = new viewholder(); holder.companynamelabel = (textview) convertview.findviewbyid(r.id.companyname); holder.productnamelabel = (textview) convertview.findviewbyid(r.id.productnamelabel); holder.pricenamelabel = (textview) convertview.findviewbyid(r.id.productpricelabel); holder.additembutton = (button) convertview.findviewbyid(r.id.btnaddtocart); holder.edititembutton = (button) convertview.findviewbyid(r.id.btneditbutton); convertview.settag(holder); } else { holder = (viewholder) convertview.gettag(); } if (role.equals(\"company account\")) { holder.edititembutton.setvisibility(view.visible); } else if (role.equals(\"personal account\")) { holder.additembutton.setvisibility(view.visible); } final product product = mproducts.get(position); holder.companynamelabel.settext(product.getcompany()); holder.productnamelabel.settext(product.getproductname()); holder.pricenamelabel.settext(product.getprice() + \"\"); holder.additembutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(mcontext, checkoutactivity.class); intent.putextra(\"product\", product.getproductname()); mcontext.startactivity(intent); } }); return convertview; }","comment":"\/\/todo: add functionality for edit button","repo":"ashleysullins\/Postmates-android","code_context_2":"intent.putExtra(\"product\", product.getProductName());\nmContext.startActivity(intent);\n\/\/TODO: Add functionality for edit button\n}\n});","code_context_10":"final Product product = mProducts.get(position);\nholder.companyNameLabel.setText(product.getCompany());\nholder.productNameLabel.setText(product.getProductName());\nholder.priceNameLabel.setText(product.getPrice() + \"\");\nholder.addItemButton.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(mContext, CheckoutActivity.class);\nintent.putExtra(\"product\", product.getProductName());\nmContext.startActivity(intent);\n\/\/TODO: Add functionality for edit button\n}\n});\nreturn convertView;\n}","code_context_20":"convertView.setTag(holder);\n} else {\nholder = (ViewHolder) convertView.getTag();\n}\nif (role.equals(\"Company Account\")) {\nholder.editItemButton.setVisibility(View.VISIBLE);\n}\nelse if (role.equals(\"Personal Account\")) {\nholder.addItemButton.setVisibility(View.VISIBLE);\n}\nfinal Product product = mProducts.get(position);\nholder.companyNameLabel.setText(product.getCompany());\nholder.productNameLabel.setText(product.getProductName());\nholder.priceNameLabel.setText(product.getPrice() + \"\");\nholder.addItemButton.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nIntent intent = new Intent(mContext, CheckoutActivity.class);\nintent.putExtra(\"product\", product.getProductName());\nmContext.startActivity(intent);\n\/\/TODO: Add functionality for edit button\n}\n});\nreturn convertView;\n}","label":[0,1,0,0]}
{"id":22367,"original_code":"public static void main(String[] args) {\n        \/\/ TODO Implement me, pls :(\n    }","code":"public static void main(String[] args) {\n       \n    }","cleancode":"public static void main(string[] args) { }","comment":"\/\/ todo implement me, pls :(","repo":"awwitecki\/kafka-samples","code_context_2":"public static void main(String[] args) {\n\/\/ TODO Implement me, pls :(\n}","code_context_10":"public static void main(String[] args) {\n\/\/ TODO Implement me, pls :(\n}","code_context_20":"public static void main(String[] args) {\n\/\/ TODO Implement me, pls :(\n}","label":[0,1,0,0]}
{"id":30563,"original_code":"private boolean hasTimedOut(SentMessage sentMessage) {\n        \/\/ NPE fix.  For some reason under heavy load redis can return null records.\n        if (sentMessage == null) {            \n            return false;\n        }\n        long now = new Date().getTime();\n        Date createdTs = sentMessage.getCreatedTs();\n        return createdTs.getTime() + faxTimeout < now;\n    }","code":"private boolean hasTimedOut(SentMessage sentMessage) {\n       \n        if (sentMessage == null) {            \n            return false;\n        }\n        long now = new Date().getTime();\n        Date createdTs = sentMessage.getCreatedTs();\n        return createdTs.getTime() + faxTimeout < now;\n    }","cleancode":"private boolean hastimedout(sentmessage sentmessage) { if (sentmessage == null) { return false; } long now = new date().gettime(); date createdts = sentmessage.getcreatedts(); return createdts.gettime() + faxtimeout < now; }","comment":"\/** * returns true of the queued redis message has timed out (ie, created > 25 minutes ago) *\/\n\/\/ npe fix. for some reason under heavy load redis can return null records.","repo":"bcgov\/jag-efax","code_context_2":"private boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;\n}\nlong now = new Date().getTime();\nDate createdTs = sentMessage.getCreatedTs();\nreturn createdTs.getTime() + faxTimeout < now;\n}\n\nprivate boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;","code_context_10":"private boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;\n}\nlong now = new Date().getTime();\nDate createdTs = sentMessage.getCreatedTs();\nreturn createdTs.getTime() + faxTimeout < now;\n}\n\nprivate boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;\n}\nlong now = new Date().getTime();\nDate createdTs = sentMessage.getCreatedTs();\nreturn createdTs.getTime() + faxTimeout < now;\n}","code_context_20":"private boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;\n}\nlong now = new Date().getTime();\nDate createdTs = sentMessage.getCreatedTs();\nreturn createdTs.getTime() + faxTimeout < now;\n}\n\nprivate boolean hasTimedOut(SentMessage sentMessage) {\n\/\/ NPE fix. For some reason under heavy load redis can return null records.\nif (sentMessage == null) {\nreturn false;\n}\nlong now = new Date().getTime();\nDate createdTs = sentMessage.getCreatedTs();\nreturn createdTs.getTime() + faxTimeout < now;\n}","label":[0,0,1,0]}
{"id":22568,"original_code":"public long forceSkip(long bytesToSkip) throws IOException {\n      long skipped = mUpstream.skip(bytesToSkip);\n      try {\n        \/\/ Figure out where we need to jump to...\n        int skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\n        long blockOffset = bytesToSkip - skip;\n        long numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n        \/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n        \/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\n        BigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\n        byte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\n        IvParameterSpec computedIvParameterSpecForOffset;\n        if (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\n          byte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\n          System.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\n          computedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n        } else {\n          computedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n        }\n        \/\/ Setup the cipher to use the new IV at the proper offset...\n        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\n        byte[] skipBuffer = new byte[skip];\n        \/\/ And read\/update the buffer to be decrypted\n        mCipher.update(skipBuffer, 0, skip, skipBuffer);\n        Arrays.fill(skipBuffer, (byte) 0);\n      } catch (Exception e) {\n        return 0;\n      }\n      return skipped;\n    }","code":"public long forceSkip(long bytesToSkip) throws IOException {\n      long skipped = mUpstream.skip(bytesToSkip);\n      try {\n       \n        int skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\n        long blockOffset = bytesToSkip - skip;\n        long numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n       \n       \n        BigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\n        byte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\n        IvParameterSpec computedIvParameterSpecForOffset;\n        if (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\n          byte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\n          System.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\n          computedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n        } else {\n          computedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n        }\n       \n        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\n        byte[] skipBuffer = new byte[skip];\n       \n        mCipher.update(skipBuffer, 0, skip, skipBuffer);\n        Arrays.fill(skipBuffer, (byte) 0);\n      } catch (Exception e) {\n        return 0;\n      }\n      return skipped;\n    }","cleancode":"public long forceskip(long bytestoskip) throws ioexception { long skipped = mupstream.skip(bytestoskip); try { int skip = (int) (bytestoskip % aes_block_size); long blockoffset = bytestoskip - skip; long numberofblocks = blockoffset \/ aes_block_size; biginteger ivforoffsetasbiginteger = new biginteger(1, mivparameterspec.getiv()).add(biginteger.valueof(numberofblocks)); byte[] ivforoffsetbytearray = ivforoffsetasbiginteger.tobytearray(); ivparameterspec computedivparameterspecforoffset; if (ivforoffsetbytearray.length < aes_block_size) { byte[] resizedivforoffsetbytearray = new byte[aes_block_size]; system.arraycopy(ivforoffsetbytearray, 0, resizedivforoffsetbytearray, aes_block_size - ivforoffsetbytearray.length, ivforoffsetbytearray.length); computedivparameterspecforoffset = new ivparameterspec(resizedivforoffsetbytearray); } else { computedivparameterspecforoffset = new ivparameterspec(ivforoffsetbytearray, ivforoffsetbytearray.length - aes_block_size, aes_block_size); } mcipher.init(cipher.encrypt_mode, msecretkeyspec, computedivparameterspecforoffset); byte[] skipbuffer = new byte[skip]; mcipher.update(skipbuffer, 0, skip, skipbuffer); arrays.fill(skipbuffer, (byte) 0); } catch (exception e) { return 0; } return skipped; }","comment":"\/\/ figure out where we need to jump to...\n\/\/ todo: this is designed for cts mode, for other modes this routine code has to be changed \/\/ so that we don't have to read the entire stream, we have to compute what the iv should be at this point in time in cts mode\n\/\/ setup the cipher to use the new iv at the proper offset...\n\/\/ and read\/update the buffer to be decrypted","repo":"bancha2nd\/nativescript-plugins","code_context_2":"long skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\n\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\n\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);","code_context_10":"public long forceSkip(long bytesToSkip) throws IOException {\nlong skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\n\npublic long forceSkip(long bytesToSkip) throws IOException {\nlong skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);\n} catch (Exception e) {\nreturn 0;\n}\nreturn skipped;\n}\n\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);\n} catch (Exception e) {\nreturn 0;\n}\nreturn skipped;\n}","code_context_20":"public long forceSkip(long bytesToSkip) throws IOException {\nlong skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\n\npublic long forceSkip(long bytesToSkip) throws IOException {\nlong skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);\n} catch (Exception e) {\nreturn 0;\n}\nreturn skipped;\n\npublic long forceSkip(long bytesToSkip) throws IOException {\nlong skipped = mUpstream.skip(bytesToSkip);\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);\n} catch (Exception e) {\nreturn 0;\n}\nreturn skipped;\n}\n\ntry {\n\/\/ Figure out where we need to jump to...\nint skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\nlong blockOffset = bytesToSkip - skip;\nlong numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n\/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n\/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\nBigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\nbyte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\nIvParameterSpec computedIvParameterSpecForOffset;\nif (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\nbyte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\nSystem.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\ncomputedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n} else {\ncomputedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n}\n\/\/ Setup the cipher to use the new IV at the proper offset...\nmCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\nbyte[] skipBuffer = new byte[skip];\n\/\/ And read\/update the buffer to be decrypted\nmCipher.update(skipBuffer, 0, skip, skipBuffer);\nArrays.fill(skipBuffer, (byte) 0);\n} catch (Exception e) {\nreturn 0;\n}\nreturn skipped;\n}","label":[1,0,0,0]}
{"id":30915,"original_code":"@BeforeEach\n\tprotected void setup() throws Exception {\n\t\t\/\/ Remove the existing program data folder\n\t\tString suffix = \"-\" + Profile.TEST;\n\t\tProductCard metadata = ProductCard.info( Program.class );\n\t\tPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\n\t\tassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\t\t\/\/ For the parameters to be available using Java 9, the following needs to be added\n\t\t\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\t\t\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\t\t\/\/\n\t\t\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\n\t\tprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\n\t\tprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\t\/\/ NOTE Thread.yield() is helpful but not consistent\n\t\tThread.yield();\n\t\tprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\t\/\/ NOTE Thread.yield() is helpful but not consistent\n\t\tThread.yield();\n\t\t\/\/ Wait for the active workarea\n\t\t\/\/ FIXME This should use an event listener to wait for the workarea\n\t\tlong limit = System.currentTimeMillis() + TIMEOUT;\n\t\twhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\n\t\t\tThreadUtil.pause( 100 );\n\t\t}\n\t\tassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\n\t\tWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\n\t\tworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\n\t\tinitialMemoryUse = getMemoryUse();\n\t}","code":"@BeforeEach\n\tprotected void setup() throws Exception {\n\t\n\t\tString suffix = \"-\" + Profile.TEST;\n\t\tProductCard metadata = ProductCard.info( Program.class );\n\t\tPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\n\t\tassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\t\n\t\n\t\n\t\n\t\n\t\tprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\n\t\tprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\n\t\tThread.yield();\n\t\tprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\n\t\tThread.yield();\n\t\n\t\n\t\tlong limit = System.currentTimeMillis() + TIMEOUT;\n\t\twhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\n\t\t\tThreadUtil.pause( 100 );\n\t\t}\n\t\tassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\n\t\tWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\n\t\tworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\n\t\tinitialMemoryUse = getMemoryUse();\n\t}","cleancode":"@beforeeach protected void setup() throws exception { string suffix = \"-\" + profile.test; productcard metadata = productcard.info( program.class ); path programdatafolder = operatingsystem.getuserprogramdatafolder( metadata.getartifact() + suffix, metadata.getname() + suffix ); assertthat( aggressivedelete( programdatafolder ) ).withfailmessage( \"failed to delete program data folder\" ).istrue(); program = (program)fxtoolkit.setupapplication( program.class, programtestconfig.getparametervalues() ); program.register( programevent.any, programwatcher = new eventwatcher( timeout ) ); fx.waitforwithexceptions( timeout ); thread.yield(); programwatcher.waitforevent( programevent.started, timeout ); fx.waitforwithexceptions( timeout ); thread.yield(); long limit = system.currenttimemillis() + timeout; while( program.getworkspacemanager().getactiveworkspace().getactiveworkarea() == null && system.currenttimemillis() < limit ) { threadutil.pause( 100 ); } assertthat( program ).withfailmessage( \"program is null\" ).isnotnull(); assertthat( program.getworkspacemanager() ).withfailmessage( \"workspace manager is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace() ).withfailmessage( \"active workspace is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace().getactiveworkarea() ).withfailmessage( \"active workarea is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace().getactiveworkarea().getworkpane() ).withfailmessage( \"active workpane is null\" ).isnotnull(); workpane workpane = program.getworkspacemanager().getactiveworkspace().getactiveworkarea().getworkpane(); workpane.addeventhandler( workpaneevent.any, workpanewatcher = new fxeventwatcher() ); initialmemoryuse = getmemoryuse(); }","comment":"\/** * overrides setup() in applicationtest and does not call super.setup(). *\/\n\/\/ remove the existing program data folder\n\/\/ for the parameters to be available using java 9, the following needs to be added \/\/ to the test jvm command line parameters because com.sun.javafx.application.parametersimpl \/\/ is not exposed, nor is there a \"proper\" way to access it: \/\/ \/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=all-unnamed\n\/\/ note thread.yield() is helpful but not consistent\n\/\/ note thread.yield() is helpful but not consistent\n\/\/ wait for the active workarea \/\/ fixme this should use an event listener to wait for the workarea","repo":"avereon\/xenon","code_context_2":"@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\n\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\n\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {","code_context_10":"@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();","code_context_20":"@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}\n\n@BeforeEach\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}\n\nprotected void setup() throws Exception {\n\/\/ Remove the existing program data folder\nString suffix = \"-\" + Profile.TEST;\nProductCard metadata = ProductCard.info( Program.class );\nPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\nassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\/\/ For the parameters to be available using Java 9, the following needs to be added\n\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\/\/\n\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\nprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\nprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\nprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\nFx.waitForWithExceptions( TIMEOUT );\n\/\/ NOTE Thread.yield() is helpful but not consistent\nThread.yield();\n\/\/ Wait for the active workarea\n\/\/ FIXME This should use an event listener to wait for the workarea\nlong limit = System.currentTimeMillis() + TIMEOUT;\nwhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\nThreadUtil.pause( 100 );\n}\nassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\nassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\nWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\nworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\ninitialMemoryUse = getMemoryUse();\n}","label":[1,0,0,0]}
{"id":14698,"original_code":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\n        List<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\n        RepositoryCache.enter(cacheConfigurationManager);\n        try {\n            for (AssignmentType assignmentType: assignments) {\n                try {\n                    PrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\n                    if (definition == null) {\n                        \/\/ TODO: optimize\n                        definition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n                    }\n                    ItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\n                            new ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\n                    EvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\n                    evaluatedAssignments.add(assignment);\n                } catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\n                    LOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\n                            assignmentHolder, e.getMessage(), assignmentType, e);\n                }\n            }\n        } finally {\n            RepositoryCache.exit();\n        }\n        return evaluatedAssignments;\n    }","code":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\n        List<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\n        RepositoryCache.enter(cacheConfigurationManager);\n        try {\n            for (AssignmentType assignmentType: assignments) {\n                try {\n                    PrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\n                    if (definition == null) {\n                       \n                        definition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n                    }\n                    ItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\n                            new ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\n                    EvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\n                    evaluatedAssignments.add(assignment);\n                } catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\n                    LOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\n                            assignmentHolder, e.getMessage(), assignmentType, e);\n                }\n            }\n        } finally {\n            RepositoryCache.exit();\n        }\n        return evaluatedAssignments;\n    }","cleancode":"private <ah extends assignmentholdertype> collection<evaluatedassignment<ah>> evaluateassignments(ah assignmentholder, collection<assignmenttype> assignments, boolean virtual, assignmentevaluator<ah> assignmentevaluator, task task, operationresult result) { list<evaluatedassignment<ah>> evaluatedassignments = new arraylist<>(); repositorycache.enter(cacheconfigurationmanager); try { for (assignmenttype assignmenttype: assignments) { try { prismcontainerdefinition definition = assignmenttype.asprismcontainervalue().getdefinition(); if (definition == null) { definition = prismcontext.getschemaregistry().findobjectdefinitionbycompiletimeclass(assignmentholdertype.class).findcontainerdefinition(assignmentholdertype.f_assignment); } itemdeltaitem<prismcontainervalue<assignmenttype>,prismcontainerdefinition<assignmenttype>> assignmentidi = new itemdeltaitem<>(lensutil.createassignmentsinglevaluecontainer(assignmenttype), definition); evaluatedassignment<ah> assignment = assignmentevaluator.evaluate(assignmentidi, plusminuszero.zero, false, assignmentholder, assignmentholder.tostring(), virtual, task, result); evaluatedassignments.add(assignment); } catch (schemaexception | objectnotfoundexception | expressionevaluationexception | policyviolationexception | securityviolationexception | configurationexception | communicationexception e) { logger.error(\"error while processing assignment of {}: {}; assignment: {}\", assignmentholder, e.getmessage(), assignmenttype, e); } } } finally { repositorycache.exit(); } return evaluatedassignments; }","comment":"\/\/ todo: optimize","repo":"bshp\/midpoint","code_context_2":"PrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\nif (definition == null) {\n\/\/ TODO: optimize\ndefinition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n}","code_context_10":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\nList<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\nRepositoryCache.enter(cacheConfigurationManager);\ntry {\nfor (AssignmentType assignmentType: assignments) {\ntry {\nPrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\nif (definition == null) {\n\/\/ TODO: optimize\ndefinition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n}\nItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\nnew ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\nEvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\nevaluatedAssignments.add(assignment);\n} catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\nLOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\nassignmentHolder, e.getMessage(), assignmentType, e);\n}","code_context_20":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\nList<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\nRepositoryCache.enter(cacheConfigurationManager);\ntry {\nfor (AssignmentType assignmentType: assignments) {\ntry {\nPrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\nif (definition == null) {\n\/\/ TODO: optimize\ndefinition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n}\nItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\nnew ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\nEvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\nevaluatedAssignments.add(assignment);\n} catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\nLOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\nassignmentHolder, e.getMessage(), assignmentType, e);\n}\n}\n} finally {\nRepositoryCache.exit();\n}\nreturn evaluatedAssignments;\n}","label":[1,0,0,0]}
{"id":22947,"original_code":"private void decode(byte[] sensorData) {\n        kiwriousReader.setRawValues(sensorData);\n        switch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n            \/\/TODO: complete decode calls using bye array data\n            case SENSOR_COLOUR:\n                String[] colorValues = sensorDecoder.decodeColor(sensorData);\n                kiwriousReader.setR(Integer.parseInt(colorValues[0]));\n                kiwriousReader.setG(Integer.parseInt(colorValues[1]));\n                kiwriousReader.setB(Integer.parseInt(colorValues[2]));\n                break;\n            case SENSOR_CONDUCTIVITY:\n                String[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\n                kiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\n                kiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\n                break;\n            case SENSOR_HEART_RATE:\n                String heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\n                kiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\n                break;\n            case SENSOR_HUMIDITY:\n                Float[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\n                kiwriousReader.setTemperature(humidityValues[0]);\n                kiwriousReader.setHumidity(humidityValues[1]);\n                break;\n            case SENSOR_SOUND:\n\/\/                sensorDecoder.decodeSound(values);\n                break;\n            case SENSOR_TEMPERATURE:\n                String[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\n                break;\n            case SENSOR_TEMPERATURE2:\n                String[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));\n                break;\n            case SENSOR_UV:\n                String[] lightValues = sensorDecoder.decodeUV(sensorData);\n                kiwriousReader.setLux(Long.parseLong(lightValues[0]));\n                kiwriousReader.setUv(Float.parseFloat(lightValues[1]));\n                break;\n            case SENSOR_VOC:\n                String[] vocValues = sensorDecoder.decodeVOC(sensorData);\n                kiwriousReader.setVoc(Integer.parseInt(vocValues[0]));\n                kiwriousReader.setCo2(Integer.parseInt(vocValues[1]));\n                break;\n            default:\n                Log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensorData[KIWRIOUS_SENSOR_TYPE]);\n                break;\n        }\n    }","code":"private void decode(byte[] sensorData) {\n        kiwriousReader.setRawValues(sensorData);\n        switch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n           \n            case SENSOR_COLOUR:\n                String[] colorValues = sensorDecoder.decodeColor(sensorData);\n                kiwriousReader.setR(Integer.parseInt(colorValues[0]));\n                kiwriousReader.setG(Integer.parseInt(colorValues[1]));\n                kiwriousReader.setB(Integer.parseInt(colorValues[2]));\n                break;\n            case SENSOR_CONDUCTIVITY:\n                String[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\n                kiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\n                kiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\n                break;\n            case SENSOR_HEART_RATE:\n                String heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\n                kiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\n                break;\n            case SENSOR_HUMIDITY:\n                Float[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\n                kiwriousReader.setTemperature(humidityValues[0]);\n                kiwriousReader.setHumidity(humidityValues[1]);\n                break;\n            case SENSOR_SOUND:\n                break;\n            case SENSOR_TEMPERATURE:\n                String[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\n                break;\n            case SENSOR_TEMPERATURE2:\n                String[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));\n                break;\n            case SENSOR_UV:\n                String[] lightValues = sensorDecoder.decodeUV(sensorData);\n                kiwriousReader.setLux(Long.parseLong(lightValues[0]));\n                kiwriousReader.setUv(Float.parseFloat(lightValues[1]));\n                break;\n            case SENSOR_VOC:\n                String[] vocValues = sensorDecoder.decodeVOC(sensorData);\n                kiwriousReader.setVoc(Integer.parseInt(vocValues[0]));\n                kiwriousReader.setCo2(Integer.parseInt(vocValues[1]));\n                break;\n            default:\n                Log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensorData[KIWRIOUS_SENSOR_TYPE]);\n                break;\n        }\n    }","cleancode":"private void decode(byte[] sensordata) { kiwriousreader.setrawvalues(sensordata); switch (sensordata[kiwrious_sensor_type]) { case sensor_colour: string[] colorvalues = sensordecoder.decodecolor(sensordata); kiwriousreader.setr(integer.parseint(colorvalues[0])); kiwriousreader.setg(integer.parseint(colorvalues[1])); kiwriousreader.setb(integer.parseint(colorvalues[2])); break; case sensor_conductivity: string[] conductivityvalues = sensordecoder.decodeconductivity(sensordata); kiwriousreader.setresistance(long.parselong(conductivityvalues[0])); kiwriousreader.setconductivity(float.parsefloat(conductivityvalues[1])); break; case sensor_heart_rate: string heartratevalue = sensordecoder.decodeheartrate(sensordata); kiwriousreader.setheartrate(integer.parseint(heartratevalue)); break; case sensor_humidity: float[] humidityvalues = sensordecoder.decodehumidity(sensordata); kiwriousreader.settemperature(humidityvalues[0]); kiwriousreader.sethumidity(humidityvalues[1]); break; case sensor_sound: break; case sensor_temperature: string[] temperaturevalues = sensordecoder.decodetemperature(sensordata); kiwriousreader.setambienttemperature(integer.parseint(temperaturevalues[0])); kiwriousreader.setinfraredtemperature(integer.parseint(temperaturevalues[1])); break; case sensor_temperature2: string[] temperature2values = sensordecoder.decodetemperature2(sensordata); kiwriousreader.setambienttemperature(integer.parseint(temperature2values[0])); kiwriousreader.setinfraredtemperature(integer.parseint(temperature2values[1])); break; case sensor_uv: string[] lightvalues = sensordecoder.decodeuv(sensordata); kiwriousreader.setlux(long.parselong(lightvalues[0])); kiwriousreader.setuv(float.parsefloat(lightvalues[1])); break; case sensor_voc: string[] vocvalues = sensordecoder.decodevoc(sensordata); kiwriousreader.setvoc(integer.parseint(vocvalues[0])); kiwriousreader.setco2(integer.parseint(vocvalues[1])); break; default: log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensordata[kiwrious_sensor_type]); break; } }","comment":"\/\/todo: complete decode calls using bye array data\n\/\/ sensordecoder.decodesound(values);","repo":"augmented-human-lab\/kiwrious-android-library","code_context_2":"kiwriousReader.setRawValues(sensorData);\nswitch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n\/\/TODO: complete decode calls using bye array data\ncase SENSOR_COLOUR:\nString[] colorValues = sensorDecoder.decodeColor(sensorData);\n\nbreak;\ncase SENSOR_SOUND:\n\/\/ sensorDecoder.decodeSound(values);\nbreak;\ncase SENSOR_TEMPERATURE:","code_context_10":"private void decode(byte[] sensorData) {\nkiwriousReader.setRawValues(sensorData);\nswitch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n\/\/TODO: complete decode calls using bye array data\ncase SENSOR_COLOUR:\nString[] colorValues = sensorDecoder.decodeColor(sensorData);\nkiwriousReader.setR(Integer.parseInt(colorValues[0]));\nkiwriousReader.setG(Integer.parseInt(colorValues[1]));\nkiwriousReader.setB(Integer.parseInt(colorValues[2]));\nbreak;\ncase SENSOR_CONDUCTIVITY:\nString[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\nkiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\nkiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\n\ncase SENSOR_HEART_RATE:\nString heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\nkiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\nbreak;\ncase SENSOR_HUMIDITY:\nFloat[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\nkiwriousReader.setTemperature(humidityValues[0]);\nkiwriousReader.setHumidity(humidityValues[1]);\nbreak;\ncase SENSOR_SOUND:\n\/\/ sensorDecoder.decodeSound(values);\nbreak;\ncase SENSOR_TEMPERATURE:\nString[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\nkiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\nkiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\nbreak;\ncase SENSOR_TEMPERATURE2:\nString[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\nkiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\nkiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));","code_context_20":"private void decode(byte[] sensorData) {\nkiwriousReader.setRawValues(sensorData);\nswitch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n\/\/TODO: complete decode calls using bye array data\ncase SENSOR_COLOUR:\nString[] colorValues = sensorDecoder.decodeColor(sensorData);\nkiwriousReader.setR(Integer.parseInt(colorValues[0]));\nkiwriousReader.setG(Integer.parseInt(colorValues[1]));\nkiwriousReader.setB(Integer.parseInt(colorValues[2]));\nbreak;\ncase SENSOR_CONDUCTIVITY:\nString[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\nkiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\nkiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\nbreak;\ncase SENSOR_HEART_RATE:\nString heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\nkiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\nbreak;\ncase SENSOR_HUMIDITY:\nFloat[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\nkiwriousReader.setTemperature(humidityValues[0]);\nkiwriousReader.setHumidity(humidityValues[1]);\nbreak;\n\nString[] colorValues = sensorDecoder.decodeColor(sensorData);\nkiwriousReader.setR(Integer.parseInt(colorValues[0]));\nkiwriousReader.setG(Integer.parseInt(colorValues[1]));\nkiwriousReader.setB(Integer.parseInt(colorValues[2]));\nbreak;\ncase SENSOR_CONDUCTIVITY:\nString[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\nkiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\nkiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\nbreak;\ncase SENSOR_HEART_RATE:\nString heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\nkiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\nbreak;\ncase SENSOR_HUMIDITY:\nFloat[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\nkiwriousReader.setTemperature(humidityValues[0]);\nkiwriousReader.setHumidity(humidityValues[1]);\nbreak;\ncase SENSOR_SOUND:\n\/\/ sensorDecoder.decodeSound(values);\nbreak;\ncase SENSOR_TEMPERATURE:\nString[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\nkiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\nkiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\nbreak;\ncase SENSOR_TEMPERATURE2:\nString[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\nkiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\nkiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));\nbreak;\ncase SENSOR_UV:\nString[] lightValues = sensorDecoder.decodeUV(sensorData);\nkiwriousReader.setLux(Long.parseLong(lightValues[0]));\nkiwriousReader.setUv(Float.parseFloat(lightValues[1]));\nbreak;\ncase SENSOR_VOC:\nString[] vocValues = sensorDecoder.decodeVOC(sensorData);\nkiwriousReader.setVoc(Integer.parseInt(vocValues[0]));\nkiwriousReader.setCo2(Integer.parseInt(vocValues[1]));","label":[0,1,0,0]}
{"id":23039,"original_code":"@GetMapping(\"\/sign-in\")\n    Mono<JwtToken> signIn(@RequestParam(\"login\") String login,\/\/FIXME use Auth header with basic auth\n                          @RequestParam(\"password\") String password) {\n        return userRepository.findByEmailOrMobile(login, login)\n                .filter(u -> u.validatePassword(password))\n                .map(this::createToken)\n                .map(Mono::just)\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n    }","code":"@GetMapping(\"\/sign-in\")\n    Mono<JwtToken> signIn(@RequestParam(\"login\") String login\n                          @RequestParam(\"password\") String password) {\n        return userRepository.findByEmailOrMobile(login, login)\n                .filter(u -> u.validatePassword(password))\n                .map(this::createToken)\n                .map(Mono::just)\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n    }","cleancode":"@getmapping(\"\/sign-in\") mono<jwttoken> signin(@requestparam(\"login\") string login @requestparam(\"password\") string password) { return userrepository.findbyemailormobile(login, login) .filter(u -> u.validatepassword(password)) .map(this::createtoken) .map(mono::just) .orelsethrow(() -> new illegalargumentexception(\"invalid login or password\")); }","comment":"\/\/fixme use auth header with basic auth","repo":"batiaev\/provisioner","code_context_2":"@GetMapping(\"\/sign-in\")\nMono<JwtToken> signIn(@RequestParam(\"login\") String login,\/\/FIXME use Auth header with basic auth\n@RequestParam(\"password\") String password) {\nreturn userRepository.findByEmailOrMobile(login, login)","code_context_10":"@GetMapping(\"\/sign-in\")\nMono<JwtToken> signIn(@RequestParam(\"login\") String login,\/\/FIXME use Auth header with basic auth\n@RequestParam(\"password\") String password) {\nreturn userRepository.findByEmailOrMobile(login, login)\n.filter(u -> u.validatePassword(password))\n.map(this::createToken)\n.map(Mono::just)\n.orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n}","code_context_20":"@GetMapping(\"\/sign-in\")\nMono<JwtToken> signIn(@RequestParam(\"login\") String login,\/\/FIXME use Auth header with basic auth\n@RequestParam(\"password\") String password) {\nreturn userRepository.findByEmailOrMobile(login, login)\n.filter(u -> u.validatePassword(password))\n.map(this::createToken)\n.map(Mono::just)\n.orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n}","label":[0,0,1,0]}
{"id":23061,"original_code":"@Override\n\t\tvoid testBaseLib() {}","code":"@Override\n\t\tvoid testBaseLib() {}","cleancode":"@override void testbaselib() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testBaseLib() {}","code_context_10":"@Override\nvoid testBaseLib() {}","code_context_20":"@Override\nvoid testBaseLib() {}","label":[0,0,0,1]}
{"id":23062,"original_code":"@Override\n\t\tvoid testCoroutineLib() {}","code":"@Override\n\t\tvoid testCoroutineLib() {}","cleancode":"@override void testcoroutinelib() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testCoroutineLib() {}","code_context_10":"@Override\nvoid testCoroutineLib() {}","code_context_20":"@Override\nvoid testCoroutineLib() {}","label":[0,0,0,1]}
{"id":23063,"original_code":"@Override\n\t\tvoid testIoLib() {}","code":"@Override\n\t\tvoid testIoLib() {}","cleancode":"@override void testiolib() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testIoLib() {}","code_context_10":"@Override\nvoid testIoLib() {}","code_context_20":"@Override\nvoid testIoLib() {}","label":[0,0,0,1]}
{"id":23064,"original_code":"@Override\n\t\tvoid testMetatags() {}","code":"@Override\n\t\tvoid testMetatags() {}","cleancode":"@override void testmetatags() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testMetatags() {}","code_context_10":"@Override\nvoid testMetatags() {}","code_context_20":"@Override\nvoid testMetatags() {}","label":[0,0,0,1]}
{"id":23065,"original_code":"@Override\n\t\tvoid testOsLib() {}","code":"@Override\n\t\tvoid testOsLib() {}","cleancode":"@override void testoslib() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testOsLib() {}","code_context_10":"@Override\nvoid testOsLib() {}","code_context_20":"@Override\nvoid testOsLib() {}","label":[0,0,0,1]}
{"id":23066,"original_code":"@Override\n\t\tvoid testStringLib() {}","code":"@Override\n\t\tvoid testStringLib() {}","cleancode":"@override void teststringlib() {}","comment":"\/\/ fixme test failures","repo":"baodingfengyun\/luaj","code_context_2":"@Override\nvoid testStringLib() {}","code_context_10":"@Override\nvoid testStringLib() {}","code_context_20":"@Override\nvoid testStringLib() {}","label":[0,0,0,1]}
{"id":14968,"original_code":"@Override\n\tpublic String explainIncompleteness() {\n\t\tString result = null;\n\t\tif (isValueDomain()) {\n\t\t\t\/\/This concept name is value so do special processing\n\t\t\tresult = explainIfNotAllTokensProcessed(\"\");\n\t\t\tif (this.instanceName == null) {\n\t\t\t\tresult = appendReason(result, \"No instance name was identified\");\n\t\t\t} else {\n\t\t\t\t\/\/TODO: Eventually remove this test\n\t\t\t\tif (this.instanceName.equals(TOKEN_NAMED)) {\n\t\t\t\t\tresult = appendReason(result, \"Instance name of 'named' was detected\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/Do normal processing\n\t\t\tresult = super.explainIncompleteness();\n\t\t}\n\t\treturn result;\n\t}","code":"@Override\n\tpublic String explainIncompleteness() {\n\t\tString result = null;\n\t\tif (isValueDomain()) {\n\t\t\n\t\t\tresult = explainIfNotAllTokensProcessed(\"\");\n\t\t\tif (this.instanceName == null) {\n\t\t\t\tresult = appendReason(result, \"No instance name was identified\");\n\t\t\t} else {\n\t\t\t\n\t\t\t\tif (this.instanceName.equals(TOKEN_NAMED)) {\n\t\t\t\t\tresult = appendReason(result, \"Instance name of 'named' was detected\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\n\t\t\tresult = super.explainIncompleteness();\n\t\t}\n\t\treturn result;\n\t}","cleancode":"@override public string explainincompleteness() { string result = null; if (isvaluedomain()) { result = explainifnotalltokensprocessed(\"\"); if (this.instancename == null) { result = appendreason(result, \"no instance name was identified\"); } else { if (this.instancename.equals(token_named)) { result = appendreason(result, \"instance name of 'named' was detected\"); } } } else { result = super.explainincompleteness(); } return result; }","comment":"\/\/this concept name is value so do special processing\n\/\/todo: eventually remove this test\n\/\/do normal processing","repo":"ce-store\/ce-store","code_context_2":"String result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\n\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}","code_context_10":"@Override\npublic String explainIncompleteness() {\nString result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\n@Override\npublic String explainIncompleteness() {\nString result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}\nreturn result;\n}\n\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}\nreturn result;\n}","code_context_20":"@Override\npublic String explainIncompleteness() {\nString result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}\nreturn result;\n}\n\n@Override\npublic String explainIncompleteness() {\nString result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}\nreturn result;\n}\n\n@Override\npublic String explainIncompleteness() {\nString result = null;\nif (isValueDomain()) {\n\/\/This concept name is value so do special processing\nresult = explainIfNotAllTokensProcessed(\"\");\nif (this.instanceName == null) {\nresult = appendReason(result, \"No instance name was identified\");\n} else {\n\/\/TODO: Eventually remove this test\nif (this.instanceName.equals(TOKEN_NAMED)) {\nresult = appendReason(result, \"Instance name of 'named' was detected\");\n}\n}\n} else {\n\/\/Do normal processing\nresult = super.explainIncompleteness();\n}\nreturn result;\n}","label":[1,0,0,0]}
{"id":31429,"original_code":"@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\/\/ Bounds\n\t\t\t\t\t\tif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getX()+hs < colorPane.getX() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\n\t\t\t\t\t\tif ( colorPick.getY()+hs < colorPane.getY()+1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\n\t\t\t\t\t\tVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\n\t\t\t\t\t\tint index = (offset.y*(int)colorPane.getWidth())+offset.x;\n\t\t\t\t\t\tint rgb = colorPane.colors[index];\n\t\t\t\t\t\t\/\/ Swap blue\/red channel? Why do I need to do this?\n\t\t\t\t\t\tColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\t\t\t\t\t\t\/\/ Update the temp color\n\t\t\t\t\t\tcolorS.setBackgroundLegacy(c);\n\t\t\t\t\t\tr.setText(\"\"+c.getRed());\n\t\t\t\t\t\tg.setText(\"\"+c.getGreen());\n\t\t\t\t\t\tb.setText(\"\"+c.getBlue());\n\t\t\t\t\t\tcolorPick.setBackgroundLegacy(c);\n\t\t\t\t\t\ttempColor(c);\n\t\t\t\t\t}","code":"@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\t\tif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getX()+hs < colorPane.getX() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\n\t\t\t\t\t\tif ( colorPick.getY()+hs < colorPane.getY()+1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\n\t\t\t\t\t\tVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\n\t\t\t\t\t\tint index = (offset.y*(int)colorPane.getWidth())+offset.x;\n\t\t\t\t\t\tint rgb = colorPane.colors[index];\n\t\t\t\t\t\n\t\t\t\t\t\tColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\t\t\t\t\t\n\t\t\t\t\t\tcolorS.setBackgroundLegacy(c);\n\t\t\t\t\t\tr.setText(\"\"+c.getRed());\n\t\t\t\t\t\tg.setText(\"\"+c.getGreen());\n\t\t\t\t\t\tb.setText(\"\"+c.getBlue());\n\t\t\t\t\t\tcolorPick.setBackgroundLegacy(c);\n\t\t\t\t\t\ttempColor(c);\n\t\t\t\t\t}","cleancode":"@override public void run() { if ( colorpick.getx()+hs > colorpane.getx()+colorpane.getwidth()-1 ) colorpick.setabsoluteposition(colorpane.getx()+colorpane.getwidth()-hs-1, colorpick.gety()); if ( colorpick.getx()+hs < colorpane.getx() ) colorpick.setabsoluteposition(colorpane.getx()-hs, colorpick.gety()); if ( colorpick.gety()+hs > colorpane.gety()+colorpane.getheight() ) colorpick.setabsoluteposition(colorpick.getx(), colorpane.gety()+colorpane.getheight()-hs); if ( colorpick.gety()+hs < colorpane.gety()+1 ) colorpick.setabsoluteposition(colorpick.getx(), colorpane.gety()-hs+1); vector2i offset = new vector2i( (int)(colorpick.getx()+hs-colorpane.getx()), (int)colorpane.getheight()-(int)(colorpick.gety()+hs-colorpane.gety()) ); int index = (offset.y*(int)colorpane.getwidth())+offset.x; int rgb = colorpane.colors[index]; color c = new color((rgb >> 0) & 0xff, (rgb >> 8) & 0xff, (rgb >> 16) & 0xff, 255); colors.setbackgroundlegacy(c); r.settext(\"\"+c.getred()); g.settext(\"\"+c.getgreen()); b.settext(\"\"+c.getblue()); colorpick.setbackgroundlegacy(c); tempcolor(c); }","comment":"\/\/ bounds\n\/\/ swap blue\/red channel? why do i need to do this?\n\/\/ update the temp color","repo":"bumfo\/LWJGUI","code_context_2":"@Override\npublic void run() {\n\/\/ Bounds\nif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\n\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\n\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());","code_context_10":"@Override\npublic void run() {\n\/\/ Bounds\nif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\nif ( colorPick.getX()+hs < colorPane.getX() )\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\n\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\nif ( colorPick.getX()+hs < colorPane.getX() )\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());\ng.setText(\"\"+c.getGreen());\nb.setText(\"\"+c.getBlue());\ncolorPick.setBackgroundLegacy(c);\ntempColor(c);\n}\n\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());\ng.setText(\"\"+c.getGreen());\nb.setText(\"\"+c.getBlue());\ncolorPick.setBackgroundLegacy(c);\ntempColor(c);\n}","code_context_20":"@Override\npublic void run() {\n\/\/ Bounds\nif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\nif ( colorPick.getX()+hs < colorPane.getX() )\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());\ng.setText(\"\"+c.getGreen());\nb.setText(\"\"+c.getBlue());\ncolorPick.setBackgroundLegacy(c);\ntempColor(c);\n\n@Override\npublic void run() {\n\/\/ Bounds\nif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\nif ( colorPick.getX()+hs < colorPane.getX() )\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());\ng.setText(\"\"+c.getGreen());\nb.setText(\"\"+c.getBlue());\ncolorPick.setBackgroundLegacy(c);\ntempColor(c);\n}\n\n@Override\npublic void run() {\n\/\/ Bounds\nif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\ncolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\nif ( colorPick.getX()+hs < colorPane.getX() )\ncolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\nif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\nif ( colorPick.getY()+hs < colorPane.getY()+1 )\ncolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\nVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\nint index = (offset.y*(int)colorPane.getWidth())+offset.x;\nint rgb = colorPane.colors[index];\n\/\/ Swap blue\/red channel? Why do I need to do this?\nColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\/\/ Update the temp color\ncolorS.setBackgroundLegacy(c);\nr.setText(\"\"+c.getRed());\ng.setText(\"\"+c.getGreen());\nb.setText(\"\"+c.getBlue());\ncolorPick.setBackgroundLegacy(c);\ntempColor(c);\n}","label":[1,0,0,0]}
{"id":31545,"original_code":"@Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        IdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\n        return getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n    }","code":"@Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        IdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\n        return getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n    }","cleancode":"@override protected authorizationinfo dogetauthorizationinfo(principalcollection principals) { idconstruct idconstruct = (idconstruct) getavailableprincipal(principals); return getiotaccount(idconstruct.getpartition(), idconstruct.getusername()); }","comment":"\/** * retrieves the authorizationinfo for the given principals from the underlying data store. when returning * an instance from this method, you might want to consider using an instance of * {@link simpleauthorizationinfo simpleauthorizationinfo}, as it is suitable in most cases. * * @param principals the primary identifying principals of the authorizationinfo that should be retrieved. * @return the authorizationinfo associated with this principals. * @see simpleauthorizationinfo *\/","repo":"caricah\/mq.tracah","code_context_2":"@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\nIdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\nreturn getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n}","code_context_10":"@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\nIdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\nreturn getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n}","code_context_20":"@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\nIdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\nreturn getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n}","label":[0,0,0,0]}
{"id":15338,"original_code":"public static boolean yesNo(String yesNoQuestion){\n\t\tint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n        \/\/ 0=yes, 1=no, 2=cancel\n\t\treturn input==0;\n\t\t\/\/TODO remove the Cancel button. Should only be Yes and No.\n\t}","code":"public static boolean yesNo(String yesNoQuestion){\n\t\tint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n       \n\t\treturn input==0;\n\t\n\t}","cleancode":"public static boolean yesno(string yesnoquestion){ int input = joptionpane.showconfirmdialog(null, yesnoquestion); return input==0; }","comment":"\/\/ 0=yes, 1=no, 2=cancel\n\/\/todo remove the cancel button. should only be yes and no.","repo":"benrayfield\/occamsworkspace","code_context_2":"public static boolean yesNo(String yesNoQuestion){\nint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n}","code_context_10":"public static boolean yesNo(String yesNoQuestion){\nint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n}\n\npublic static boolean yesNo(String yesNoQuestion){\nint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n}","code_context_20":"public static boolean yesNo(String yesNoQuestion){\nint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n}\n\npublic static boolean yesNo(String yesNoQuestion){\nint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n\/\/ 0=yes, 1=no, 2=cancel\nreturn input==0;\n\/\/TODO remove the Cancel button. Should only be Yes and No.\n}","label":[1,0,0,0]}
{"id":15390,"original_code":"private void findActionVerbsAndArguments(TreeGraphNode node, \n\t\t\tMap<Pair<Integer, Integer>, String> edge_rels,\n\t\t\tMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\n\t\t\tMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\n\t\t\tString root_type,\n\t\t\tList<Tree> leaves,\n\t\t\tList<String> lemmas, List<Label> tags, List<HasWord> words,\n\t\t\tString recipe_name, int sentence_idx, int curr_sentence_char_offset, \n\t\t\tString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\n\t\tString node_string = node.nodeString();\n\t\tint index = node.index();\n\t\tLabel tag = tags.get(index - 1);\n\t\tint hw_character_offset = charOffset(leaves.get(index - 1));\n\t\t\/\/ Find the no-space character offset of the predicate\n\t\tint no_space_character_offset = hw_character_offset;\n\t\tString sentence_prefix = sentence_string.substring(0, hw_character_offset);\n\t\twhile (sentence_prefix.contains(\" I would \")) {\n\t\t\tno_space_character_offset -= 9;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\"I would \")) {\n\t\t\tno_space_character_offset -= 8;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\" \")) {\n\t\t\tno_space_character_offset--;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n\t\t}\n\t\tif (tag.value().startsWith(\"V\")) {\n\t\t\tSet<TreeGraphNode> deps = node_to_deps.get(node);\n\t\t\tif (deps == null) {\n\t\t\t\tSystem.out.println(node + \" \" + deps);\n\t\t\t\t\/\/ Create RecipeEvent\n\t\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\t\tpredicate_idx_to_event.put(hw_character_offset, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ check for pcomp\n\t\t\tboolean has_pcomp = false;\n\t\t\tTreeGraphNode pcomp = null;\n\t\t\tfor (TreeGraphNode dep3 : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\n\t\t\t\tif (rel_string2.equals(\"pcomp\")) {\n\t\t\t\t\thas_pcomp = true;\n\t\t\t\t\tpcomp = dep3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_pcomp) {\n\t\t\t\tSystem.out.println(\"has pcomp\");\n\t\t\t\tTreeGraphNode grandgov = dep_to_gov.get(node);\n\t\t\t\tif (grandgov != null) {\n\t\t\t\t\tint grandgov_index = grandgov.index();\n\t\t\t\t\tRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\n\t\t\t\t\tif (grandevent != null) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tgrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ Create RecipeEvent\n\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\tboolean has_subj = false;\n\t\t\tTreeGraphNode subj = null;\n\t\t\tfor (TreeGraphNode dep : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\n\t\t\t\tif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\n\t\t\t\t\thas_subj = true;\n\t\t\t\t\tsubj = dep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\n\t\t\tif (has_subj && !root_type.equals(\"SINV\")) {\n\t\t\t\tSystem.out.println(has_subj + \" \" + root_type);\n\t\t\t\tif (!subj.nodeString().equals(\"I\")) {\n\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\t\t\tif (verbs.size() == 1) {\n\t\t\t\t\t\tTreeGraphNode verb = verbs.iterator().next();\n\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\tRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\n\t\t\t\t\t\tif (dep_event != null) {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(node.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tags.get(index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tdep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdep_event.addOtherArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\/\/ TODO(chloe): do something else in this case?\n\t\t\t\t\t\tfor (TreeGraphNode verb : verbs) {\n\t\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\n\t\t\tSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\n\t\t\tTreeGraphNode pobj = null;\n\t\t\twhile (new_deps.size() != 0) {\n\t\t\t\tList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\n\t\t\t\tnew_deps.clear();\n\t\t\t\tfor (TreeGraphNode dep : deps_list) {\n\t\t\t\t\tTreeGraphNode gov = dep_to_gov.get(dep);\n\t\t\t\t\tif (gov == null) {\n\t\t\t\t\t\tgov = node;\n\t\t\t\t\t}\n\t\t\t\t\tint gov_index = index;\n\t\t\t\t\tint gov_hw_offset = hw_character_offset;\n\t\t\t\t\tString gov_string = node_string;\n\t\t\t\t\tif (gov != null) {\n\t\t\t\t\t\tgov_index = gov.index();\n\t\t\t\t\t\tgov_hw_offset = charOffset(leaves.get(gov_index - 1));\n\t\t\t\t\t\tgov_string = gov.nodeString();\n\t\t\t\t\t}\n\t\t\t\t\tint dep_index = dep.index();\n\t\t\t\t\tint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\n\t\t\t\t\tString dep_string = dep.nodeString();\n\t\t\t\t\tif (dep.nodeString().equals(\"would\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\n\t\t\t\t\tif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\t\t\t\t\t\t\/\/ skip subjects\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (rel_string.startsWith(\"pobj\")) {\n\t\t\t\t\t\t\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\t\t\t\t\t\t\/\/ prepositional phrase is found.\n\t\t\t\t\t\tpobj = dep;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ For vmod and xcomp edges, create an argument for the current verb\n\t\t\t\t\tif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\t\t\t\t\t\/\/ part of the current verb. Uses heuristics to find out.\n\t\t\t\t\tboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\n\t\t\t\t\tLabel dep_tag = tags.get(dep_index - 1);\n\t\t\t\t\tif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\tif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tString conj_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\tnode_string += \" \" + conj_string + \" \" + dep_string;\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n\t\t\t\t\t\t} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\thas_subj = false;\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\t\t\thas_subj = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (has_subj) {\n\t\t\t\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {  \/\/ prepositional phrase\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_prep) {\n\t\t\t\t\t\t\tString pobj_arg_string = null;\n\t\t\t\t\t\t\tif (pobj != null) {\n\t\t\t\t\t\t\t\targs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode dep2 : deps_list) {\n\t\t\t\t\t\t\t\t\tTreeGraphNode gov2 = dep_to_gov.get(dep2);\n\t\t\t\t\t\t\t\t\tif (gov2 == null) {\n\t\t\t\t\t\t\t\t\t\tgov2 = gov;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"pobj\")) {\n\t\t\t\t\t\t\t\t\t\targs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\/\/ Find the true preposition from the collapsed dependency relation\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tif (underscore != -1) {\n\t\t\t\t\t\t\t\tString prep_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\t\tprep_string = prep_string.replace('_', ' ');\n\t\t\t\t\t\t\t\tif (pobj_arg_string != null) {\n\t\t\t\t\t\t\t\t\tif (prep_string.contains(arg_string)) {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\/\/\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"DIRECTOBJECT \" + arg_string);\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\n\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"prep\");\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(event);\n\t\t\tpredicate_idx_to_event.put(index, event);\n\t\t} else {\n\t\t\t\/\/ This method should not be called if the node is not a verb.\n\t\t\t\/\/\n\t\t\t\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\n\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\tString arg_string = args.getFirst();\n\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\tSystem.out.println(arg_string);\n\t\t\tSystem.out.println(\"getting args error\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","code":"private void findActionVerbsAndArguments(TreeGraphNode node, \n\t\t\tMap<Pair<Integer, Integer>, String> edge_rels,\n\t\t\tMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\n\t\t\tMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\n\t\t\tString root_type,\n\t\t\tList<Tree> leaves,\n\t\t\tList<String> lemmas, List<Label> tags, List<HasWord> words,\n\t\t\tString recipe_name, int sentence_idx, int curr_sentence_char_offset, \n\t\t\tString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\n\t\tString node_string = node.nodeString();\n\t\tint index = node.index();\n\t\tLabel tag = tags.get(index - 1);\n\t\tint hw_character_offset = charOffset(leaves.get(index - 1));\n\t\n\t\tint no_space_character_offset = hw_character_offset;\n\t\tString sentence_prefix = sentence_string.substring(0, hw_character_offset);\n\t\twhile (sentence_prefix.contains(\" I would \")) {\n\t\t\tno_space_character_offset -= 9;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\"I would \")) {\n\t\t\tno_space_character_offset -= 8;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\" \")) {\n\t\t\tno_space_character_offset--;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n\t\t}\n\t\tif (tag.value().startsWith(\"V\")) {\n\t\t\tSet<TreeGraphNode> deps = node_to_deps.get(node);\n\t\t\tif (deps == null) {\n\t\t\t\tSystem.out.println(node + \" \" + deps);\n\t\t\t\n\t\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\t\tpredicate_idx_to_event.put(hw_character_offset, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tboolean has_pcomp = false;\n\t\t\tTreeGraphNode pcomp = null;\n\t\t\tfor (TreeGraphNode dep3 : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\n\t\t\t\tif (rel_string2.equals(\"pcomp\")) {\n\t\t\t\t\thas_pcomp = true;\n\t\t\t\t\tpcomp = dep3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_pcomp) {\n\t\t\t\tSystem.out.println(\"has pcomp\");\n\t\t\t\tTreeGraphNode grandgov = dep_to_gov.get(node);\n\t\t\t\tif (grandgov != null) {\n\t\t\t\t\tint grandgov_index = grandgov.index();\n\t\t\t\t\tRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\n\t\t\t\t\tif (grandevent != null) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tgrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\tboolean has_subj = false;\n\t\t\tTreeGraphNode subj = null;\n\t\t\tfor (TreeGraphNode dep : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\n\t\t\t\tif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\n\t\t\t\t\thas_subj = true;\n\t\t\t\t\tsubj = dep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (has_subj && !root_type.equals(\"SINV\")) {\n\t\t\t\tSystem.out.println(has_subj + \" \" + root_type);\n\t\t\t\tif (!subj.nodeString().equals(\"I\")) {\n\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\t\t\tif (verbs.size() == 1) {\n\t\t\t\t\t\tTreeGraphNode verb = verbs.iterator().next();\n\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\tRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\n\t\t\t\t\t\tif (dep_event != null) {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(node.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tags.get(index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tdep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdep_event.addOtherArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\tfor (TreeGraphNode verb : verbs) {\n\t\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\n\t\t\tTreeGraphNode pobj = null;\n\t\t\twhile (new_deps.size() != 0) {\n\t\t\t\tList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\n\t\t\t\tnew_deps.clear();\n\t\t\t\tfor (TreeGraphNode dep : deps_list) {\n\t\t\t\t\tTreeGraphNode gov = dep_to_gov.get(dep);\n\t\t\t\t\tif (gov == null) {\n\t\t\t\t\t\tgov = node;\n\t\t\t\t\t}\n\t\t\t\t\tint gov_index = index;\n\t\t\t\t\tint gov_hw_offset = hw_character_offset;\n\t\t\t\t\tString gov_string = node_string;\n\t\t\t\t\tif (gov != null) {\n\t\t\t\t\t\tgov_index = gov.index();\n\t\t\t\t\t\tgov_hw_offset = charOffset(leaves.get(gov_index - 1));\n\t\t\t\t\t\tgov_string = gov.nodeString();\n\t\t\t\t\t}\n\t\t\t\t\tint dep_index = dep.index();\n\t\t\t\t\tint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\n\t\t\t\t\tString dep_string = dep.nodeString();\n\t\t\t\t\tif (dep.nodeString().equals(\"would\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\n\t\t\t\t\tif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (rel_string.startsWith(\"pobj\")) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tpobj = dep;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\n\t\t\t\t\tLabel dep_tag = tags.get(dep_index - 1);\n\t\t\t\t\tif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\tif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tString conj_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\tnode_string += \" \" + conj_string + \" \" + dep_string;\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n\t\t\t\t\t\t} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\thas_subj = false;\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\t\t\thas_subj = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (has_subj) {\n\t\t\t\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { \n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_prep) {\n\t\t\t\t\t\t\tString pobj_arg_string = null;\n\t\t\t\t\t\t\tif (pobj != null) {\n\t\t\t\t\t\t\t\targs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode dep2 : deps_list) {\n\t\t\t\t\t\t\t\t\tTreeGraphNode gov2 = dep_to_gov.get(dep2);\n\t\t\t\t\t\t\t\t\tif (gov2 == null) {\n\t\t\t\t\t\t\t\t\t\tgov2 = gov;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"pobj\")) {\n\t\t\t\t\t\t\t\t\t\targs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tif (underscore != -1) {\n\t\t\t\t\t\t\t\tString prep_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\t\tprep_string = prep_string.replace('_', ' ');\n\t\t\t\t\t\t\t\tif (pobj_arg_string != null) {\n\t\t\t\t\t\t\t\t\tif (prep_string.contains(arg_string)) {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"DIRECTOBJECT \" + arg_string);\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\n\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"prep\");\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(event);\n\t\t\tpredicate_idx_to_event.put(index, event);\n\t\t} else {\n\t\t\n\t\t\n\t\t\n\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\tString arg_string = args.getFirst();\n\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\tSystem.out.println(arg_string);\n\t\t\tSystem.out.println(\"getting args error\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","cleancode":"private void findactionverbsandarguments(treegraphnode node, map<pair<integer, integer>, string> edge_rels, map<treegraphnode, set<treegraphnode>> node_to_deps, map<treegraphnode, treegraphnode> dep_to_gov, string root_type, list<tree> leaves, list<string> lemmas, list<label> tags, list<hasword> words, string recipe_name, int sentence_idx, int curr_sentence_char_offset, string sentence_string, treemap<integer, recipeevent> predicate_idx_to_event) { string node_string = node.nodestring(); int index = node.index(); label tag = tags.get(index - 1); int hw_character_offset = charoffset(leaves.get(index - 1)); int no_space_character_offset = hw_character_offset; string sentence_prefix = sentence_string.substring(0, hw_character_offset); while (sentence_prefix.contains(\" i would \")) { no_space_character_offset -= 9; sentence_prefix = sentence_prefix.replacefirst(\" i would \", \"\"); } while (sentence_prefix.contains(\"i would \")) { no_space_character_offset -= 8; sentence_prefix = sentence_prefix.replacefirst(\"i would \", \"\"); } while (sentence_prefix.contains(\" \")) { no_space_character_offset--; sentence_prefix = sentence_prefix.replacefirst(\" \", \"\"); } if (tag.value().startswith(\"v\")) { set<treegraphnode> deps = node_to_deps.get(node); if (deps == null) { system.out.println(node + \" \" + deps); recipeevent event = new recipeevent(node_string.tolowercase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset); predicate_idx_to_event.put(hw_character_offset, event); return; } boolean has_pcomp = false; treegraphnode pcomp = null; for (treegraphnode dep3 : deps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(hw_character_offset, charoffset(dep3))); if (rel_string2.equals(\"pcomp\")) { has_pcomp = true; pcomp = dep3; break; } } if (has_pcomp) { system.out.println(\"has pcomp\"); treegraphnode grandgov = dep_to_gov.get(node); if (grandgov != null) { int grandgov_index = grandgov.index(); recipeevent grandevent = predicate_idx_to_event.get(grandgov_index); if (grandevent != null) { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, true); grandevent.addprepositionalargument(hw_character_offset, args.getfirst(), pcomp.nodestring()); } } return; } recipeevent event = new recipeevent(node_string.tolowercase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset); boolean has_subj = false; treegraphnode subj = null; for (treegraphnode dep : deps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(hw_character_offset, charoffset(dep))); if (rel_string2.equals(\"nsubj\") && !root_type.equals(\"sinv\")) { has_subj = true; subj = dep; break; } } if (has_subj && !root_type.equals(\"sinv\")) { system.out.println(has_subj + \" \" + root_type); if (!subj.nodestring().equals(\"i\")) { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, false); string arg_string = args.getfirst(); set<treegraphnode> verbs = args.getsecond(); if (verbs.size() == 1) { treegraphnode verb = verbs.iterator().next(); dep_to_gov.put(verb, node); findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); recipeevent dep_event = predicate_idx_to_event.get(charoffset(leaves.get(verb.index() - 1))); if (dep_event != null) { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(node.nodestring())) { found = i; break; } } if (tags.get(index - found - 1).value().equals(\"in\")) { dep_event.addprepositionalargument(hw_character_offset, arg_string); } else { dep_event.addotherargument(hw_character_offset, arg_string); } } } else { for (treegraphnode verb : verbs) { dep_to_gov.put(verb, node); findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } return; } } set<treegraphnode> new_deps = new hashset<treegraphnode>(deps); treegraphnode pobj = null; while (new_deps.size() != 0) { list<treegraphnode> deps_list = new arraylist<treegraphnode>(new_deps); new_deps.clear(); for (treegraphnode dep : deps_list) { treegraphnode gov = dep_to_gov.get(dep); if (gov == null) { gov = node; } int gov_index = index; int gov_hw_offset = hw_character_offset; string gov_string = node_string; if (gov != null) { gov_index = gov.index(); gov_hw_offset = charoffset(leaves.get(gov_index - 1)); gov_string = gov.nodestring(); } int dep_index = dep.index(); int dep_hw_offset = charoffset(leaves.get(dep_index - 1)); string dep_string = dep.nodestring(); if (dep.nodestring().equals(\"would\")) { continue; } string rel_string = edge_rels.get(new pair<integer, integer>(gov_hw_offset, dep_hw_offset)); if (rel_string.startswith(\"nsubj\") && !root_type.equals(\"sinv\") && (gov == node || dep.nodestring().equals(\"i\"))) { continue; } if (rel_string.startswith(\"pobj\")) { pobj = dep; continue; } if (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, true); string arg_string = args.getfirst(); string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } continue; } boolean is_prep = rel_string.startswith(\"prep\") || tags.get(dep_index - 1).value().equals(\"in\"); label dep_tag = tags.get(dep_index - 1); if (dep_tag.value().startswith(\"v\") && !is_prep && !rel_string.equals(\"advcl\") ) { if (dep_index == index + 2 && rel_string.startswith(\"conj\")) { int underscore = rel_string.indexof('_'); string conj_string = rel_string.substring(underscore + 1); node_string += \" \" + conj_string + \" \" + dep_string; set<treegraphnode> depdeps = node_to_deps.get(dep); if (depdeps != null) { new_deps.addall(depdeps); for (treegraphnode depdep : depdeps) { dep_to_gov.put(depdep, dep); } } event.addverbtopredicate(dep.nodestring(), conj_string, (dep.index() > gov_index)); } else if (rel_string.startswith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) { set<treegraphnode> depdeps = node_to_deps.get(dep); has_subj = false; if (depdeps != null) { for (treegraphnode depdep : depdeps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(dep_hw_offset, charoffset(leaves.get(depdep.index() - 1)))); if (rel_string2.equals(\"nsubj\")) { has_subj = true; break; } } if (has_subj) { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, true); string arg_string = args.getfirst(); string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } } else { findactionverbsandarguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } } else { set<treegraphnode> depdeps = node_to_deps.get(dep); if (depdeps != null) { new_deps.addall(depdeps); for (treegraphnode depdep : depdeps) { dep_to_gov.put(depdep, dep); } } event.addverbtopredicate(dep.nodestring(), \"\", (dep.index() > gov_index)); } } else { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\")); string arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } if (is_prep) { string pobj_arg_string = null; if (pobj != null) { args = gettreegraphstring(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep); pobj_arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } else { for (treegraphnode dep2 : deps_list) { treegraphnode gov2 = dep_to_gov.get(dep2); if (gov2 == null) { gov2 = gov; } string rel_string2 = edge_rels.get(new pair<integer, integer>(charoffset(leaves.get(gov2.index() - 1)), charoffset(leaves.get(dep2.index() - 1)))); if (rel_string2.equals(\"pobj\")) { args = gettreegraphstring(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep); pobj_arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } break; } } } int underscore = rel_string.indexof('_'); if (underscore != -1) { string prep_string = rel_string.substring(underscore + 1); prep_string = prep_string.replace('_', ' '); if (pobj_arg_string != null) { if (prep_string.contains(arg_string)) { arg_string = prep_string + \" \" + pobj_arg_string; } else { arg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string; } } else { arg_string = prep_string + \" \" + arg_string; } } event.addprepositionalargument(dep_hw_offset, arg_string); } else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { system.out.println(\"directobject \" + arg_string); if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { if (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) { event.addprepositionalargument(dep_hw_offset, arg_string, \"for\"); } else { event.setdirectobject(arg_string); } } } } else { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { system.out.println(\"prep\"); event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } } } } } system.out.println(event); predicate_idx_to_event.put(index, event); } else { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, false); string arg_string = args.getfirst(); set<treegraphnode> verbs = args.getsecond(); system.out.println(arg_string); system.out.println(\"getting args error\"); system.exit(1); } }","comment":"\/** * finds the main action predicates in the sentence and their respective arguments. * for each, creates a recipeevent object to store the information. this information * is stored in the predicate_idx_to_event map. * * @param node verb node to be examining * @param edge_rels map of governor\/dependent pairs and the edge relation that connects * them, if any. * @param node_to_deps map that connects a governor node to its dependents. * @param leaves list of leaf nodes of the constituent parse tree * @param lemmas list of lemmas of tokens in the sentence * @param tags list of pos tags of the tokens in the sentence * @param words list of words in the sentence * @param recipe_name name of the recipe * @param sentence_idx index of the sentence within the current recipe * @param curr_sentence_char_offset starting no-space character offset of the * current sentence * @param sentence_string full text string of the current sentence * @param predicate_idx_to_event map of character offsets to the recipe events that start * at that offset. note that this is not the no-space character offset since * the tree map just cares about the relative order *\/\n\/\/ find the no-space character offset of the predicate\n\/\/ create recipeevent\n\/\/ check for pcomp\n\/\/ create recipeevent\n\/\/ if the verb has a subject other than \"i\", assume parse error and add the subject as an argument.\n\/\/ todo(chloe): do something else in this case?\n\/\/ search through the dependents of the verb and add each expanded dependent as an argument.\n\/\/ skip subjects\n\/\/ store the prepositional object, but ignore for now. we will deal with it when the \/\/ prepositional phrase is found.\n\/\/ for vmod and xcomp edges, create an argument for the current verb\n\/\/ deal with prepositional phrases and determining whether or not a dependent verb is a new verb or \/\/ part of the current verb. uses heuristics to find out.\n\/\/ prepositional phrase\n\/\/ find the true preposition from the collapsed dependency relation\n\/\/ event.setdirectobject(arg_string);\n\/\/ this method should not be called if the node is not a verb. \/\/ \/\/ not sure if this happens, so i will currently have it crash so i can investigate it.","repo":"atcbosselut\/recipe-interpretation","code_context_2":"private void findActionVerbsAndArguments(TreeGraphNode node,\nMap<Pair<Integer, Integer>, String> edge_rels,\nMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\nMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\nString root_type,\nList<Tree> leaves,\nList<String> lemmas, List<Label> tags, List<HasWord> words,\nString recipe_name, int sentence_idx, int curr_sentence_char_offset,\nString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\nString node_string = node.nodeString();\nint index = node.index();\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\nRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\nif (grandevent != null) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\ngrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n}\n}\nreturn;\n}\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\nboolean has_subj = false;\nTreeGraphNode subj = null;\nfor (TreeGraphNode dep : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\nif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\nhas_subj = true;\nsubj = dep;\nbreak;\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\nif (!subj.nodeString().equals(\"I\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nif (verbs.size() == 1) {\nTreeGraphNode verb = verbs.iterator().next();\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\nRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\nif (dep_event != null) {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(node.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\nif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n) {\nif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\nint underscore = rel_string.indexOf('_');\nString conj_string = rel_string.substring(underscore + 1);\nnode_string += \" \" + conj_string + \" \" + dep_string;\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nhas_subj = false;\nif (depdeps != null) {\nfor (TreeGraphNode depdep : depdeps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\nif (rel_string2.equals(\"nsubj\")) {\nhas_subj = true;\nbreak;\n}\n}\nif (has_subj) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n} else {\nfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\n} else {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n}\n} else { \/\/ prepositional phrase\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\nString arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nif (is_prep) {\nString pobj_arg_string = null;\nif (pobj != null) {\nargs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n} else {\nfor (TreeGraphNode dep2 : deps_list) {\nTreeGraphNode gov2 = dep_to_gov.get(dep2);\nif (gov2 == null) {\ngov2 = gov;\n}\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\nif (rel_string2.equals(\"pobj\")) {\nargs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nbreak;\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nSystem.out.println(\"DIRECTOBJECT \" + arg_string);\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n} else {\nevent.setDirectObject(arg_string);\n}\n}\n}\n} else {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nSystem.out.println(\"prep\");\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n}\n}\n}\n}\nSystem.out.println(event);\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nSystem.out.println(arg_string);\nSystem.out.println(\"getting args error\");\nSystem.exit(1);\n}\n}\n\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\n\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\n\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\n\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\n\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\n\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\n\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\n\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\n\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\n\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\n\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\n\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();","code_context_10":"private void findActionVerbsAndArguments(TreeGraphNode node,\nMap<Pair<Integer, Integer>, String> edge_rels,\nMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\nMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\nString root_type,\nList<Tree> leaves,\nList<String> lemmas, List<Label> tags, List<HasWord> words,\nString recipe_name, int sentence_idx, int curr_sentence_char_offset,\nString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\nString node_string = node.nodeString();\nint index = node.index();\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\nRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\nif (grandevent != null) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\ngrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n}\n}\nreturn;\n}\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\nboolean has_subj = false;\nTreeGraphNode subj = null;\nfor (TreeGraphNode dep : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\nif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\nhas_subj = true;\nsubj = dep;\nbreak;\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\nif (!subj.nodeString().equals(\"I\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nif (verbs.size() == 1) {\nTreeGraphNode verb = verbs.iterator().next();\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\nRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\nif (dep_event != null) {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(node.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\nif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n) {\nif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\nint underscore = rel_string.indexOf('_');\nString conj_string = rel_string.substring(underscore + 1);\nnode_string += \" \" + conj_string + \" \" + dep_string;\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nhas_subj = false;\nif (depdeps != null) {\nfor (TreeGraphNode depdep : depdeps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\nif (rel_string2.equals(\"nsubj\")) {\nhas_subj = true;\nbreak;\n}\n}\nif (has_subj) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n} else {\nfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\n} else {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n}\n} else { \/\/ prepositional phrase\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\nString arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nif (is_prep) {\nString pobj_arg_string = null;\nif (pobj != null) {\nargs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n} else {\nfor (TreeGraphNode dep2 : deps_list) {\nTreeGraphNode gov2 = dep_to_gov.get(dep2);\nif (gov2 == null) {\ngov2 = gov;\n}\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\nif (rel_string2.equals(\"pobj\")) {\nargs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nbreak;\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nSystem.out.println(\"DIRECTOBJECT \" + arg_string);\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n} else {\nevent.setDirectObject(arg_string);\n}\n}\n}\n} else {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nSystem.out.println(\"prep\");\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n}\n}\n}\n}\nSystem.out.println(event);\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nSystem.out.println(arg_string);\nSystem.out.println(\"getting args error\");\nSystem.exit(1);\n}\n}\n\nMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\nString root_type,\nList<Tree> leaves,\nList<String> lemmas, List<Label> tags, List<HasWord> words,\nString recipe_name, int sentence_idx, int curr_sentence_char_offset,\nString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\nString node_string = node.nodeString();\nint index = node.index();\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\n\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\n\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\n\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\n\nboolean has_subj = false;\nTreeGraphNode subj = null;\nfor (TreeGraphNode dep : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\nif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\nhas_subj = true;\nsubj = dep;\nbreak;\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\nif (!subj.nodeString().equals(\"I\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nif (verbs.size() == 1) {\nTreeGraphNode verb = verbs.iterator().next();\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\n\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\n\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\n\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\n\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\nif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n) {\nif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\nint underscore = rel_string.indexOf('_');\nString conj_string = rel_string.substring(underscore + 1);\nnode_string += \" \" + conj_string + \" \" + dep_string;\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\n\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\n\nargs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nbreak;\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nSystem.out.println(\"DIRECTOBJECT \" + arg_string);\n\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n}\n}\n}\n}\nSystem.out.println(event);\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nSystem.out.println(arg_string);\nSystem.out.println(\"getting args error\");\nSystem.exit(1);\n}\n}","code_context_20":"private void findActionVerbsAndArguments(TreeGraphNode node,\nMap<Pair<Integer, Integer>, String> edge_rels,\nMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\nMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\nString root_type,\nList<Tree> leaves,\nList<String> lemmas, List<Label> tags, List<HasWord> words,\nString recipe_name, int sentence_idx, int curr_sentence_char_offset,\nString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\nString node_string = node.nodeString();\nint index = node.index();\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\nRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\nif (grandevent != null) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\ngrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n}\n}\nreturn;\n}\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\nboolean has_subj = false;\nTreeGraphNode subj = null;\nfor (TreeGraphNode dep : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\nif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\nhas_subj = true;\nsubj = dep;\nbreak;\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\nif (!subj.nodeString().equals(\"I\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nif (verbs.size() == 1) {\nTreeGraphNode verb = verbs.iterator().next();\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\nRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\nif (dep_event != null) {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(node.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\nif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n) {\nif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\nint underscore = rel_string.indexOf('_');\nString conj_string = rel_string.substring(underscore + 1);\nnode_string += \" \" + conj_string + \" \" + dep_string;\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nhas_subj = false;\nif (depdeps != null) {\nfor (TreeGraphNode depdep : depdeps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\nif (rel_string2.equals(\"nsubj\")) {\nhas_subj = true;\nbreak;\n}\n}\nif (has_subj) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n} else {\nfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\n} else {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n}\n} else { \/\/ prepositional phrase\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\nString arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nif (is_prep) {\nString pobj_arg_string = null;\nif (pobj != null) {\nargs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n} else {\nfor (TreeGraphNode dep2 : deps_list) {\nTreeGraphNode gov2 = dep_to_gov.get(dep2);\nif (gov2 == null) {\ngov2 = gov;\n}\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\nif (rel_string2.equals(\"pobj\")) {\nargs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nbreak;\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nSystem.out.println(\"DIRECTOBJECT \" + arg_string);\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n} else {\nevent.setDirectObject(arg_string);\n}\n}\n}\n} else {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nSystem.out.println(\"prep\");\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n}\n}\n}\n}\nSystem.out.println(event);\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nSystem.out.println(arg_string);\nSystem.out.println(\"getting args error\");\nSystem.exit(1);\n}\n}\n\nprivate void findActionVerbsAndArguments(TreeGraphNode node,\nMap<Pair<Integer, Integer>, String> edge_rels,\nMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\nMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\nString root_type,\nList<Tree> leaves,\nList<String> lemmas, List<Label> tags, List<HasWord> words,\nString recipe_name, int sentence_idx, int curr_sentence_char_offset,\nString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\nString node_string = node.nodeString();\nint index = node.index();\nLabel tag = tags.get(index - 1);\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\n\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\nRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\nif (grandevent != null) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\ngrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n}\n\nint hw_character_offset = charOffset(leaves.get(index - 1));\n\/\/ Find the no-space character offset of the predicate\nint no_space_character_offset = hw_character_offset;\nString sentence_prefix = sentence_string.substring(0, hw_character_offset);\nwhile (sentence_prefix.contains(\" I would \")) {\nno_space_character_offset -= 9;\nsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n}\nwhile (sentence_prefix.contains(\"I would \")) {\nno_space_character_offset -= 8;\nsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n}\nwhile (sentence_prefix.contains(\" \")) {\nno_space_character_offset--;\nsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n}\nif (tag.value().startsWith(\"V\")) {\nSet<TreeGraphNode> deps = node_to_deps.get(node);\nif (deps == null) {\nSystem.out.println(node + \" \" + deps);\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\npredicate_idx_to_event.put(hw_character_offset, event);\nreturn;\n}\n\/\/ check for pcomp\nboolean has_pcomp = false;\nTreeGraphNode pcomp = null;\nfor (TreeGraphNode dep3 : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\nif (rel_string2.equals(\"pcomp\")) {\nhas_pcomp = true;\npcomp = dep3;\nbreak;\n}\n}\nif (has_pcomp) {\nSystem.out.println(\"has pcomp\");\nTreeGraphNode grandgov = dep_to_gov.get(node);\nif (grandgov != null) {\nint grandgov_index = grandgov.index();\n\nRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\nif (grandevent != null) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\ngrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n}\n}\nreturn;\n}\n\/\/ Create RecipeEvent\nRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\nboolean has_subj = false;\nTreeGraphNode subj = null;\nfor (TreeGraphNode dep : deps) {\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\nif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\nhas_subj = true;\nsubj = dep;\nbreak;\n}\n}\n\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\nif (has_subj && !root_type.equals(\"SINV\")) {\nSystem.out.println(has_subj + \" \" + root_type);\nif (!subj.nodeString().equals(\"I\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nif (verbs.size() == 1) {\nTreeGraphNode verb = verbs.iterator().next();\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\nRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\nif (dep_event != null) {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(node.nodeString())) {\nfound = i;\nbreak;\n}\n\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\nRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\nif (dep_event != null) {\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(node.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\n\nbreak;\n}\n}\nif (tags.get(index - found - 1).value().equals(\"IN\")) {\ndep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n} else {\ndep_event.addOtherArgument(hw_character_offset, arg_string);\n}\n}\n} else {\n\/\/ TODO(chloe): do something else in this case?\nfor (TreeGraphNode verb : verbs) {\ndep_to_gov.put(verb, node);\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n}\nreturn;\n}\n}\n\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\nSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\nTreeGraphNode pobj = null;\nwhile (new_deps.size() != 0) {\nList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\nnew_deps.clear();\nfor (TreeGraphNode dep : deps_list) {\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\n\nTreeGraphNode gov = dep_to_gov.get(dep);\nif (gov == null) {\ngov = node;\n}\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\n\nint gov_index = index;\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\ncontinue;\n}\n\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\/\/ part of the current verb. Uses heuristics to find out.\nboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\nLabel dep_tag = tags.get(dep_index - 1);\nif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n) {\nif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\nint underscore = rel_string.indexOf('_');\nString conj_string = rel_string.substring(underscore + 1);\nnode_string += \" \" + conj_string + \" \" + dep_string;\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nif (depdeps != null) {\nnew_deps.addAll(depdeps);\nfor (TreeGraphNode depdep : depdeps) {\ndep_to_gov.put(depdep, dep);\n}\n}\nevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\nSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\nhas_subj = false;\nif (depdeps != null) {\n\nint gov_hw_offset = hw_character_offset;\nString gov_string = node_string;\nif (gov != null) {\ngov_index = gov.index();\ngov_hw_offset = charOffset(leaves.get(gov_index - 1));\ngov_string = gov.nodeString();\n}\nint dep_index = dep.index();\nint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\nString dep_string = dep.nodeString();\nif (dep.nodeString().equals(\"would\")) {\ncontinue;\n}\nString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\nif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\/\/ skip subjects\ncontinue;\n}\nif (rel_string.startsWith(\"pobj\")) {\n\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\/\/ prepositional phrase is found.\npobj = dep;\ncontinue;\n}\n\/\/ For vmod and xcomp edges, create an argument for the current verb\nif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\nString arg_string = args.getFirst();\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\n} else {\nfor (TreeGraphNode dep2 : deps_list) {\nTreeGraphNode gov2 = dep_to_gov.get(dep2);\nif (gov2 == null) {\ngov2 = gov;\n}\nString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\nif (rel_string2.equals(\"pobj\")) {\nargs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\npobj_arg_string = args.getFirst();\nfor (TreeGraphNode verb : args.getSecond()) {\nfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\ncurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n}\nbreak;\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\n\n}\n}\n}\n\/\/ Find the true preposition from the collapsed dependency relation\nint underscore = rel_string.indexOf('_');\nif (underscore != -1) {\nString prep_string = rel_string.substring(underscore + 1);\nprep_string = prep_string.replace('_', ' ');\nif (pobj_arg_string != null) {\nif (prep_string.contains(arg_string)) {\narg_string = prep_string + \" \" + pobj_arg_string;\n} else {\narg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n}\n} else {\narg_string = prep_string + \" \" + arg_string;\n}\n}\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\/\/ event.setDirectObject(arg_string);\nString[] split = arg_string.split(\" \");\nint found = -1;\nfor (int i = 0; i < split.length; i++) {\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nSystem.out.println(\"DIRECTOBJECT \" + arg_string);\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\nevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n} else {\nevent.setDirectObject(arg_string);\n}\n}\n}\n\nif (split[i].equals(dep.nodeString())) {\nfound = i;\nbreak;\n}\n}\nif (found != -1) {\nif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\nSystem.out.println(\"prep\");\nevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n} else {\nevent.addOtherArgument(dep_hw_offset, arg_string);\n}\n}\n}\n}\n}\n}\nSystem.out.println(event);\npredicate_idx_to_event.put(index, event);\n} else {\n\/\/ This method should not be called if the node is not a verb.\n\/\/\n\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\nPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\nString arg_string = args.getFirst();\nSet<TreeGraphNode> verbs = args.getSecond();\nSystem.out.println(arg_string);\nSystem.out.println(\"getting args error\");\nSystem.exit(1);\n}\n}","label":[1,0,0,0]}
{"id":23710,"original_code":"@Provides\n    @Singleton\n    Retrofit provideCall() {\n        Cache cache = null;\n        try {\n            cache = new Cache(cacheFile, 10 * 1024 * 1024);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        \/* TODO Consider moving elsewhere. *\/\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n                        Request original = chain.request();\n                        HttpUrl originalHttpUrl = original.url();\n                        HttpUrl url = originalHttpUrl.newBuilder()\n                                .addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n                                .build();\n                        Request request = original.newBuilder()\n                                .header(\"Content-Type\", \"application\/json\")\n                                .removeHeader(\"Pragma\")\n                                .header(\"Cache-Control\", String.format(\"max-age=%d\", BuildConfig.CACHETIME))\n                                .url(url)\n                                .build();\n                        okhttp3.Response response = chain.proceed(request);\n                        response.cacheResponse();\n                        return response;\n                    }\n                })\n                .cache(cache)\n                .build();\n        return new Retrofit.Builder()\n                .baseUrl(BuildConfig.API_OPENWEATHERMAP_BASEURL)\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .build();\n    }","code":"@Provides\n    @Singleton\n    Retrofit provideCall() {\n        Cache cache = null;\n        try {\n            cache = new Cache(cacheFile, 10 * 1024 * 1024);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n       \n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n                        Request original = chain.request();\n                        HttpUrl originalHttpUrl = original.url();\n                        HttpUrl url = originalHttpUrl.newBuilder()\n                                .addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n                                .build();\n                        Request request = original.newBuilder()\n                                .header(\"Content-Type\", \"application\/json\")\n                                .removeHeader(\"Pragma\")\n                                .header(\"Cache-Control\", String.format(\"max-age=%d\", BuildConfig.CACHETIME))\n                                .url(url)\n                                .build();\n                        okhttp3.Response response = chain.proceed(request);\n                        response.cacheResponse();\n                        return response;\n                    }\n                })\n                .cache(cache)\n                .build();\n        return new Retrofit.Builder()\n                .baseUrl(BuildConfig.API_OPENWEATHERMAP_BASEURL)\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .build();\n    }","cleancode":"@provides @singleton retrofit providecall() { cache cache = null; try { cache = new cache(cachefile, 10 * 1024 * 1024); } catch (exception e) { e.printstacktrace(); } okhttpclient okhttpclient = new okhttpclient.builder() .addinterceptor(new interceptor() { @override public okhttp3.response intercept(chain chain) throws ioexception { request original = chain.request(); httpurl originalhttpurl = original.url(); httpurl url = originalhttpurl.newbuilder() .addqueryparameter(\"appid\", buildconfig.api_openweathermap_key) .build(); request request = original.newbuilder() .header(\"content-type\", \"application\/json\") .removeheader(\"pragma\") .header(\"cache-control\", string.format(\"max-age=%d\", buildconfig.cachetime)) .url(url) .build(); okhttp3.response response = chain.proceed(request); response.cacheresponse(); return response; } }) .cache(cache) .build(); return new retrofit.builder() .baseurl(buildconfig.api_openweathermap_baseurl) .client(okhttpclient) .addconverterfactory(gsonconverterfactory.create()) .addcalladapterfactory(rxjavacalladapterfactory.create()) .build(); }","comment":"\/* todo consider moving elsewhere. *\/","repo":"arenaq\/weather-app","code_context_2":"e.printStackTrace();\n}\n\/* TODO Consider moving elsewhere. *\/\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n.addInterceptor(new Interceptor() {","code_context_10":"@Provides\n@Singleton\nRetrofit provideCall() {\nCache cache = null;\ntry {\ncache = new Cache(cacheFile, 10 * 1024 * 1024);\n} catch (Exception e) {\ne.printStackTrace();\n}\n\/* TODO Consider moving elsewhere. *\/\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n.addInterceptor(new Interceptor() {\n@Override\npublic okhttp3.Response intercept(Chain chain) throws IOException {\nRequest original = chain.request();\nHttpUrl originalHttpUrl = original.url();\nHttpUrl url = originalHttpUrl.newBuilder()\n.addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n.build();\nRequest request = original.newBuilder()","code_context_20":"@Provides\n@Singleton\nRetrofit provideCall() {\nCache cache = null;\ntry {\ncache = new Cache(cacheFile, 10 * 1024 * 1024);\n} catch (Exception e) {\ne.printStackTrace();\n}\n\/* TODO Consider moving elsewhere. *\/\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n.addInterceptor(new Interceptor() {\n@Override\npublic okhttp3.Response intercept(Chain chain) throws IOException {\nRequest original = chain.request();\nHttpUrl originalHttpUrl = original.url();\nHttpUrl url = originalHttpUrl.newBuilder()\n.addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n.build();\nRequest request = original.newBuilder()\n.header(\"Content-Type\", \"application\/json\")\n.removeHeader(\"Pragma\")\n.header(\"Cache-Control\", String.format(\"max-age=%d\", BuildConfig.CACHETIME))\n.url(url)\n.build();\nokhttp3.Response response = chain.proceed(request);\nresponse.cacheResponse();\nreturn response;\n}\n})","label":[0,1,0,0]}
{"id":32099,"original_code":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\n        if (matchPattern == null) {\n            return Collections.emptyList();\n        }\n        Matcher matcher = matchPattern.matcher(clippedText);\n        List<Rectangle> highlightAreas = null;\n        int startFrom = 0;\n        while (startFrom < clippedText.length() && matcher.find(startFrom)) {\n            if (highlightAreas == null) {\n                highlightAreas = new ArrayList<Rectangle>();\n            }\n            int start = matcher.start();\n            int end = matcher.end();\n            if (start == end) {\n                \/\/ empty matcher will cause infinite loop\n                break;\n            }\n            startFrom = end;\n            int highlightx;\n            int highlightWidth;\n            if (start == 0) {\n                \/\/ start highlight from the start of the field\n                highlightx = xOffset;\n            } else {\n                \/\/ Calculate the width of the unhighlighted text to get the\n                \/\/ start of the highlighted region.\n                String strToStart = clippedText.substring(0, start);\n                highlightx = fm.stringWidth(strToStart) + xOffset;\n            }\n            \/\/ Get the width of the highlighted region\n            String highlightText = clippedText.substring(start, end);\n            highlightWidth = fm.stringWidth(highlightText);\n            highlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n        }\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\n        if (highlightAreas == null) {\n            highlightAreas = Collections.emptyList();\n        } else {\n            coalesceHighlightAreas(highlightAreas);\n        }\n        return highlightAreas;\n    }","code":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\n        if (matchPattern == null) {\n            return Collections.emptyList();\n        }\n        Matcher matcher = matchPattern.matcher(clippedText);\n        List<Rectangle> highlightAreas = null;\n        int startFrom = 0;\n        while (startFrom < clippedText.length() && matcher.find(startFrom)) {\n            if (highlightAreas == null) {\n                highlightAreas = new ArrayList<Rectangle>();\n            }\n            int start = matcher.start();\n            int end = matcher.end();\n            if (start == end) {\n               \n                break;\n            }\n            startFrom = end;\n            int highlightx;\n            int highlightWidth;\n            if (start == 0) {\n               \n                highlightx = xOffset;\n            } else {\n               \n               \n                String strToStart = clippedText.substring(0, start);\n                highlightx = fm.stringWidth(strToStart) + xOffset;\n            }\n           \n            String highlightText = clippedText.substring(start, end);\n            highlightWidth = fm.stringWidth(highlightText);\n            highlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n        \n        if (highlightAreas == null) {\n            highlightAreas = Collections.emptyList();\n        } else {\n            coalesceHighlightAreas(highlightAreas);\n        }\n        return highlightAreas;\n    }","cleancode":"protected list<rectangle> createhighlightareas2(string fulltext, string clippedtext, fontmetrics fm, int xoffset, int yoffset, int height) { if (matchpattern == null) { return collections.emptylist(); } matcher matcher = matchpattern.matcher(clippedtext); list<rectangle> highlightareas = null; int startfrom = 0; while (startfrom < clippedtext.length() && matcher.find(startfrom)) { if (highlightareas == null) { highlightareas = new arraylist<rectangle>(); } int start = matcher.start(); int end = matcher.end(); if (start == end) { break; } startfrom = end; int highlightx; int highlightwidth; if (start == 0) { highlightx = xoffset; } else { string strtostart = clippedtext.substring(0, start); highlightx = fm.stringwidth(strtostart) + xoffset; } string highlighttext = clippedtext.substring(start, end); highlightwidth = fm.stringwidth(highlighttext); highlightareas.add(new rectangle(highlightx, yoffset, highlightwidth, height)); if (highlightareas == null) { highlightareas = collections.emptylist(); } else { coalescehighlightareas(highlightareas); } return highlightareas; }","comment":"\/** * creates the rectangles that contain matched characters in the given text. * <p> * todo: improve partial clipped matches: if one of the matched characters * is clipped, the remaining characters lose their highlight; just the * ellipsis is highlighted. * <\/p> * * @param fulltext * useful for highlighting if matches exist in clipped text and * in the ellipsis * @param clippedtext * the clipped text to search (could be the same as fulltext) * @param fm * the font metrics of the rendered font * @param xoffset * the x offset at which text rendering starts * @param yoffset * the y offset at which text rendering starts (e.g. different * rowheights) * @param height * the height of painted highlights * @return a <code>list<\/code> of highlight areas to paint *\/\n\/\/ empty matcher will cause infinite loop\n\/\/ start highlight from the start of the field\n\/\/ calculate the width of the unhighlighted text to get the \/\/ start of the highlighted region.\n\/\/ get the width of the highlighted region\n\/\/ while ( startfrom < text.length() && matcher.find( startfrom ) )","repo":"aragozin\/stackviewer","code_context_2":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\nif (matchPattern == null) {\nreturn Collections.emptyList();\n}\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\n\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\n\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();","code_context_10":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\nif (matchPattern == null) {\nreturn Collections.emptyList();\n}\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\n\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}","code_context_20":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\nif (matchPattern == null) {\nreturn Collections.emptyList();\n}\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nprotected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\nif (matchPattern == null) {\nreturn Collections.emptyList();\n}\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\n\nif (matchPattern == null) {\nreturn Collections.emptyList();\n}\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nMatcher matcher = matchPattern.matcher(clippedText);\nList<Rectangle> highlightAreas = null;\nint startFrom = 0;\nwhile (startFrom < clippedText.length() && matcher.find(startFrom)) {\nif (highlightAreas == null) {\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nhighlightAreas = new ArrayList<Rectangle>();\n}\nint start = matcher.start();\nint end = matcher.end();\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}\n\nif (start == end) {\n\/\/ empty matcher will cause infinite loop\nbreak;\n}\nstartFrom = end;\nint highlightx;\nint highlightWidth;\nif (start == 0) {\n\/\/ start highlight from the start of the field\nhighlightx = xOffset;\n} else {\n\/\/ Calculate the width of the unhighlighted text to get the\n\/\/ start of the highlighted region.\nString strToStart = clippedText.substring(0, start);\nhighlightx = fm.stringWidth(strToStart) + xOffset;\n}\n\/\/ Get the width of the highlighted region\nString highlightText = clippedText.substring(start, end);\nhighlightWidth = fm.stringWidth(highlightText);\nhighlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n}\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\nif (highlightAreas == null) {\nhighlightAreas = Collections.emptyList();\n} else {\ncoalesceHighlightAreas(highlightAreas);\n}\nreturn highlightAreas;\n}","label":[1,0,0,0]}
{"id":32113,"original_code":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\n    List<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\n    for(int i = 0; i < node.getNumEntries(); i++) {\n      RdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\n      double minDist = distanceFunction.minDist(entry, q);\n      result.add(new DoubleObjPair<>(minDist, entry));\n    }\n    Collections.sort(result);\n    return result;\n  }","code":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\n    List<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\n    for(int i = 0; i < node.getNumEntries(); i++) {\n      RdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\n      double minDist = distanceFunction.minDist(entry, q);\n      result.add(new DoubleObjPair<>(minDist, entry));\n    }\n    Collections.sort(result);\n    return result;\n  }","cleancode":"protected list<doubleobjpair<rdknnentry>> getsortedentries(abstractrstartreenode<?, ?> node, spatialcomparable q, spatialprimitivedistancefunction<?> distancefunction) { list<doubleobjpair<rdknnentry>> result = new arraylist<>(); for(int i = 0; i < node.getnumentries(); i++) { rdknnentry entry = (rdknnentry) node.getentry(i); double mindist = distancefunction.mindist(entry, q); result.add(new doubleobjpair<>(mindist, entry)); } collections.sort(result); return result; }","comment":"\/** * sorts the entries of the specified node according to their minimum distance * to the specified object. * * @param node the node * @param q the query object * @param distancefunction the distance function for computing the distances * @return a list of the sorted entries *\/ \/\/ todo: move somewhere else?","repo":"bertl4398\/ssdbm2020","code_context_2":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\nList<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\nfor(int i = 0; i < node.getNumEntries(); i++) {\nRdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\ndouble minDist = distanceFunction.minDist(entry, q);\nresult.add(new DoubleObjPair<>(minDist, entry));\n}\nCollections.sort(result);\nreturn result;\n}","code_context_10":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\nList<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\nfor(int i = 0; i < node.getNumEntries(); i++) {\nRdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\ndouble minDist = distanceFunction.minDist(entry, q);\nresult.add(new DoubleObjPair<>(minDist, entry));\n}\nCollections.sort(result);\nreturn result;\n}","code_context_20":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\nList<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\nfor(int i = 0; i < node.getNumEntries(); i++) {\nRdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\ndouble minDist = distanceFunction.minDist(entry, q);\nresult.add(new DoubleObjPair<>(minDist, entry));\n}\nCollections.sort(result);\nreturn result;\n}","label":[1,0,0,0]}
{"id":23927,"original_code":"public void recordCorpusData (Corpus c, Learner l){\n\t\tif (!isRecording) return;\n\t\tthis.c=c;\n\t\tVocabulary v = c.getVocabulary();\n\t\tSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\n\t\tSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\n\t\tStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\n\t\tcorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\n\t\ts.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\n\t\ts.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\n\t\ts.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\n\t\ts.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\n\t\ts.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\t\t\/\/TODO add proper number formatters\n\t\ts.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\n\t\ts.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\n\t\ts.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\n\t\tfor (Map.Entry<String, Integer> e: entrySet){\n\t\t\tif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\n\t\t\t\ts.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n\t\t\t}\n\t\t}\n\t\ts.append(\"},\\n\");\n\t\ts.append(\"\\tidToType: {\");\n\t\tfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\n\t\t\tif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\t\n\t\t\t}\n\t\t}\n\t\ts.append(\"}\");\n\t\ts.append(\"\\n};\");\n\t\ttry {\n\t\t\tcorpusFile.createNewFile();\n\t\t\tBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\n\t\t\tout.append(s);\n\t\t\tout.close();\n\t\t} catch (IOException e1) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t}\n\t}","code":"public void recordCorpusData (Corpus c, Learner l){\n\t\tif (!isRecording) return;\n\t\tthis.c=c;\n\t\tVocabulary v = c.getVocabulary();\n\t\tSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\n\t\tSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\n\t\tStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\n\t\tcorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\n\t\ts.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\n\t\ts.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\n\t\ts.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\n\t\ts.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\n\t\ts.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\t\n\t\ts.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\n\t\ts.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\n\t\ts.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\n\t\tfor (Map.Entry<String, Integer> e: entrySet){\n\t\t\tif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n\t\t\t}\n\t\t}\n\t\ts.append(\"},\\n\");\n\t\ts.append(\"\\tidToType: {\");\n\t\tfor (Map.Entry<Integer, Word> e: wordSet){\n\t\t\tif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\t\n\t\t\t}\n\t\t}\n\t\ts.append(\"}\");\n\t\ts.append(\"\\n};\");\n\t\ttry {\n\t\t\tcorpusFile.createNewFile();\n\t\t\tBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\n\t\t\tout.append(s);\n\t\t\tout.close();\n\t\t} catch (IOException e1) {\n\t\t\n\t\t\te1.printStackTrace();\n\t\t}\n\t}","cleancode":"public void recordcorpusdata (corpus c, learner l){ if (!isrecording) return; this.c=c; vocabulary v = c.getvocabulary(); set<map.entry<string, integer>> entryset = v.getwordindicesentryset(); set<map.entry<integer, word>> wordset = v.getwordentryset(); stringbuilder s = new stringbuilder(v.getnumofwords()*30); corpusfile = new file(mainpath, \"corpus_\"+name+\".js\"); s.append(string.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name)); s.append(string.format(\"\\ttokencount: %1$s,\\n\", c.tokencount)); s.append(string.format(\"\\ttypecount: %1$s,\\n\", v.getnumofwords())); s.append(string.format(\"\\tcommontypes: %1$s,\\n\", (v.getnumofwords()-v.countwordsbelowthreshold(l.rare_word_threshold)))); s.append(string.format(\"\\tclustercount: %1$s,\\n\", l.number_of_clusters)); s.append(string.format(\"\\tidentityeps: %1$s,\\n\", l.identity_epsilon)); s.append(string.format(\"\\titerationcount: %1$s,\\n\", iterationcounter)); s.append(\"\\ttypetoid: \\n\\t{\\n\\t\"); for (map.entry<string, integer> e: entryset){ if (v.getword(e.getvalue()).frequency >= l.rare_word_threshold){ s.append(string.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getkey(), e.getvalue())); } } s.append(\"},\\n\"); s.append(\"\\tidtotype: {\"); for (map.entry<integer, word> e: wordset){ if (e.getvalue().frequency >= l.rare_word_threshold){ s.append(string.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getkey(), e.getvalue().name)); } } s.append(\"}\"); s.append(\"\\n};\"); try { corpusfile.createnewfile(); bufferedwriter out = new bufferedwriter(new filewriter(corpusfile)); out.append(s); out.close(); } catch (ioexception e1) { e1.printstacktrace(); } }","comment":"\/* * * corpus_%corpusname% = { name: \"...\", tokencount: 500, typecount: 1000, commontypes: 900, clustercount: 100, identityeps: 0.00004 iterationcount: 7, typetoid: { typename:0, typename2: 1, ... }, idtotype: { 1: \"word\", 4: \"bleh\", } }; *\/ \/** * *\/\n\/\/todo add proper number formatters\n\/\/todo see if necessary\n\/\/no rare word check here, to keep vector status\n\/\/ todo auto-generated catch block","repo":"aureatesting\/Syntactic","code_context_2":"public void recordCorpusData (Corpus c, Learner l){\nif (!isRecording) return;\nthis.c=c;\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}\n\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\n\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}","code_context_10":"public void recordCorpusData (Corpus c, Learner l){\nif (!isRecording) return;\nthis.c=c;\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}\n\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\n\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\n\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\n\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}","code_context_20":"public void recordCorpusData (Corpus c, Learner l){\nif (!isRecording) return;\nthis.c=c;\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}\n\npublic void recordCorpusData (Corpus c, Learner l){\nif (!isRecording) return;\nthis.c=c;\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\n\npublic void recordCorpusData (Corpus c, Learner l){\nif (!isRecording) return;\nthis.c=c;\nVocabulary v = c.getVocabulary();\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n\nSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\nSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\nStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\ncorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\ns.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\ns.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\ns.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\ns.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\ns.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\/\/TODO add proper number formatters\ns.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\ns.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\ns.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}\n\nfor (Map.Entry<String, Integer> e: entrySet){\nif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\ns.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n}\n}\ns.append(\"},\\n\");\ns.append(\"\\tidToType: {\");\nfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\nif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\ns.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\n}\n}\ns.append(\"}\");\ns.append(\"\\n};\");\ntry {\ncorpusFile.createNewFile();\nBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\nout.append(s);\nout.close();\n} catch (IOException e1) {\n\/\/ TODO Auto-generated catch block\ne1.printStackTrace();\n}\n}","label":[1,1,0,0]}
{"id":15912,"original_code":"@Test\n    public void testSpendInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 0;\n        \/\/ spend coins\n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n        \/\/ wait while balance be a 100\n        waitForBalance(100);\n        \/\/ wait while balance isn't update\n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        coinOutput.check(matches(withText(balanceString)));\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        \/\/ submit disabled\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ empty string is valid zero\n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n        \/\/ valid value\n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ @TODO potentially, may break test, as coin can be created\n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n        \/\/ we can send transaction even if coin does not exists, because it can be no a true\n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_get_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n        \/\/ visible \"use max\" for spend tab\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        actionUseMax.perform(click());\n        amountInput.check(matches(withText(\"100\")));\n        Response<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate2.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n    }","code":"@Test\n    public void testSpendInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 0;\n       \n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n       \n        waitForBalance(100);\n       \n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        coinOutput.check(matches(withText(balanceString)));\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n       \n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n       \n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n       \n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_get_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n       \n        String expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n       \n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        actionUseMax.perform(click());\n        amountInput.check(matches(withText(\"100\")));\n        Response<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate2.body().isOk());\n       \n        String expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n    }","cleancode":"@test public void testspendinputs() throws throwable { explorercoinsrepository repo = testwallet.app().explorercoinsrepo(); gateestimaterepository estimaterepo = testwallet.app().estimaterepo(); final int tabpos = 0; mactivitytestrule.runonuithread(() -> { mactivitytestrule.getactivity().setcurrentpage(tabpos); }); waitforbalance(100); waitforbalanceupdate(); final string balancestring = string.format(\"%s (%s)\", mintersdk.default_coin, bdhuman(new bigdecimal(100.d))); viewinteraction actionbtn = onview(allof( withid(r.id.action), withtext(\"exchange\"), inviewpager(tabpos, r.id.pager) )); viewinteraction actionusemax = onview(allof( withid(r.id.action_maximum), inviewpager(tabpos, r.id.pager) )); viewinteraction amountinput = onview(allof(withid(r.id.input_amount), inviewpager(tabpos, r.id.pager))); viewinteraction coininput = onview(allof(withid(r.id.input_incoming_coin), inviewpager(tabpos, r.id.pager))); viewinteraction coinoutput = onview(allof(withid(r.id.input_outgoing_coin), inviewpager(tabpos, r.id.pager))); viewinteraction layoutcalculation = onview(allof( withid(r.id.layout_calculation), inviewpager(tabpos, r.id.pager) )); viewinteraction calculationsum = onview(allof(withid(r.id.calculation), inviewpager(tabpos, r.id.pager))); coinoutput.check(matches(withtext(balancestring))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); actionbtn.check(matches(not(isenabled()))); amountinput.check(matches(withinputlayouthint(r.string.label_amount))); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"0\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); final string amount = \"1\"; amountinput.perform(replacetext(amount)); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); coininput.perform(replacetext(\"dosntexist\")); coininput.check(matches(withinputlayouterror(\"coin to buy not exists\"))); actionbtn.check(matches(isenabled())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coininput.perform(scrollto(), replacetext(mexchangecoin.getsymbol())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); onview(allof(withid(r.id.calculation_title), inviewpager(tabpos, r.id.pager))) .check(matches(withtext(r.string.label_you_will_get_approximately))); calculationsum.perform(scrollto()); response<gateresult<exchangesellvalue>> estimate1 = estimaterepo.getcoinexchangecurrencytosell(mintersdk.default_coin, new bigdecimal(amount), mexchangecoin.getsymbol()).execute(); asserttrue(estimate1.body().isok()); string expectestimate3 = bdhuman(estimate1.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate3, mexchangecoin.getsymbol())))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); actionusemax.perform(click()); amountinput.check(matches(withtext(\"100\"))); response<gateresult<exchangesellvalue>> estimate2 = estimaterepo.getcoinexchangecurrencytosell(mintersdk.default_coin, new bigdecimal(\"100\"), mexchangecoin.getsymbol()).execute(); asserttrue(estimate2.body().isok()); string expectestimate2 = bdhuman(estimate2.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate2, mexchangecoin.getsymbol())))); }","comment":"\/\/ spend coins\n\/\/ wait while balance be a 100\n\/\/ wait while balance isn't update\n\/\/ submit disabled\n\/\/ empty string is valid zero\n\/\/ valid value\n\/\/ @todo potentially, may break test, as coin can be created\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\n\/\/ amount without commission\n\/\/ visible \"use max\" for spend tab\n\/\/ amount without commission","repo":"bogdyak\/Android-Bip-Wallet-crypttp","code_context_2":"GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\n\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\n\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\n\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\n\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));","code_context_10":"@Test\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\n\n@Test\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\n\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\n\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\n\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n}\n\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());","code_context_20":"@Test\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n\n@Test\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\n\n@Test\npublic void testSpendInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 0;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\n\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\n\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\n\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\ncoinOutput.check(matches(withText(balanceString)));\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\n\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n}\n\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n}\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_get_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n\/\/ visible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nactionUseMax.perform(click());\namountInput.check(matches(withText(\"100\")));\nResponse<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate2.body().isOk());\n\/\/ amount without commission\nString expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n}","label":[0,0,0,1]}
{"id":15913,"original_code":"@Test\n    public void testGetInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 1;\n        \/\/ spend coins\n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n        \/\/ wait while balance be a 100\n        waitForBalance(100);\n        \/\/ wait while balance isn't update\n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        \/\/ invisible \"use max\" for spend tab\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinOutput.check(matches(withText(balanceString)));\n        \/\/ submit disabled\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ empty string is valid zero\n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n        \/\/ valid value\n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ @TODO potentially, may break test, as coin can be created\n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n        \/\/ we can send transaction even if coin does not exists, because it can be no a true\n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_pay_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n    }","code":"@Test\n    public void testGetInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 1;\n       \n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n       \n        waitForBalance(100);\n       \n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n       \n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinOutput.check(matches(withText(balanceString)));\n       \n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n       \n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n       \n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_pay_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n       \n        String expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n    }","cleancode":"@test public void testgetinputs() throws throwable { explorercoinsrepository repo = testwallet.app().explorercoinsrepo(); gateestimaterepository estimaterepo = testwallet.app().estimaterepo(); final int tabpos = 1; mactivitytestrule.runonuithread(() -> { mactivitytestrule.getactivity().setcurrentpage(tabpos); }); waitforbalance(100); waitforbalanceupdate(); final string balancestring = string.format(\"%s (%s)\", mintersdk.default_coin, bdhuman(new bigdecimal(\"100\"))); viewinteraction actionbtn = onview(allof( withid(r.id.action), withtext(\"exchange\"), inviewpager(tabpos, r.id.pager) )); viewinteraction actionusemax = onview(allof( withid(r.id.action_maximum), inviewpager(tabpos, r.id.pager) )); viewinteraction amountinput = onview(allof(withid(r.id.input_amount), inviewpager(tabpos, r.id.pager))); viewinteraction coininput = onview(allof(withid(r.id.input_incoming_coin), inviewpager(tabpos, r.id.pager))); viewinteraction coinoutput = onview(allof(withid(r.id.input_outgoing_coin), inviewpager(tabpos, r.id.pager))); viewinteraction layoutcalculation = onview(allof( withid(r.id.layout_calculation), inviewpager(tabpos, r.id.pager) )); viewinteraction calculationsum = onview(allof(withid(r.id.calculation), inviewpager(tabpos, r.id.pager))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coinoutput.check(matches(withtext(balancestring))); actionbtn.check(matches(not(isenabled()))); amountinput.check(matches(withinputlayouthint(r.string.label_amount))); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"0\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); final string amount = \"1\"; amountinput.perform(replacetext(amount)); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); coininput.perform(replacetext(\"dosntexist\")); coininput.check(matches(withinputlayouterror(\"coin to buy not exists\"))); actionbtn.check(matches(isenabled())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coininput.perform(scrollto(), replacetext(mexchangecoin.getsymbol())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); onview(allof(withid(r.id.calculation_title), inviewpager(tabpos, r.id.pager))) .check(matches(withtext(r.string.label_you_will_pay_approximately))); calculationsum.perform(scrollto()); response<gateresult<exchangebuyvalue>> estimate1 = estimaterepo.getcoinexchangecurrencytobuy(mintersdk.default_coin, new bigdecimal(amount), mexchangecoin.getsymbol()).execute(); asserttrue(estimate1.body().isok()); string expectestimate1 = bdhuman(estimate1.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate1, mintersdk.default_coin)))); }","comment":"\/\/ spend coins\n\/\/ wait while balance be a 100\n\/\/ wait while balance isn't update\n\/\/ invisible \"use max\" for spend tab\n\/\/ submit disabled\n\/\/ empty string is valid zero\n\/\/ valid value\n\/\/ @todo potentially, may break test, as coin can be created\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\n\/\/ amount without commission","repo":"bogdyak\/Android-Bip-Wallet-crypttp","code_context_2":"GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\n\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\n\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\n\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));","code_context_10":"@Test\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\n\n@Test\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\n\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\n\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\n\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n}","code_context_20":"@Test\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n\n@Test\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\n\n@Test\npublic void testGetInputs() throws Throwable {\nExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\nGateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\nfinal int tabPos = 1;\n\/\/ spend coins\nmActivityTestRule.runOnUiThread(() -> {\nmActivityTestRule.getActivity().setCurrentPage(tabPos);\n});\n\/\/ wait while balance be a 100\nwaitForBalance(100);\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\n\n\/\/ wait while balance isn't update\nwaitForBalanceUpdate();\nfinal String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\n\nViewInteraction actionBtn = onView(allOf(\nwithId(R.id.action),\nwithText(\"EXCHANGE\"),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction actionUseMax = onView(allOf(\nwithId(R.id.action_maximum),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\n\n));\nViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\nViewInteraction layoutCalculation = onView(allOf(\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n\nwithId(R.id.layout_calculation),\ninViewPager(tabPos, R.id.pager)\n));\nViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n}\n\n\/\/ invisible \"use max\" for spend tab\nactionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinOutput.check(matches(withText(balanceString)));\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n}\n\n\/\/ submit disabled\nactionBtn.check(matches(not(isEnabled())));\namountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\namountInput.perform(replaceText(\"0\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ empty string is valid zero\namountInput.perform(replaceText(\"\"));\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n}\n\namountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\nactionBtn.check(matches(not(isEnabled())));\nfinal String amount = \"1\";\n\/\/ valid value\namountInput.perform(replaceText(amount));\namountInput.check(matches(withInputLayoutError(null)));\nactionBtn.check(matches(not(isEnabled())));\n\/\/ @TODO potentially, may break test, as coin can be created\ncoinInput.perform(replaceText(\"DOSNTEXIST\"));\ncoinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n\/\/ we can send transaction even if coin does not exists, because it can be no a true\nactionBtn.check(matches(isEnabled()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\ncoinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\nlayoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\nonView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n.check(matches(withText(R.string.label_you_will_pay_approximately)));\ncalculationSum.perform(scrollTo());\nResponse<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\nassertTrue(estimate1.body().isOk());\n\/\/ amount without commission\nString expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\ncalculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n}","label":[0,0,0,1]}
{"id":24399,"original_code":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\n    List<LP2Rule> result = new ArrayList<LP2Rule>();\n    \/\/ TODO make all other tags contextual tags here. for now we take only\n    \/\/ the counterpart\n    \/\/ tag of the current learning process: (opening\/closing tags)\n    LP2RuleItem ctxItem = new LP2RuleItem();\n    MLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\n            slotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\n            aStartRule);\n    ctxItem.setContextConstraint(ctxConstraint);\n    LP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\n    ctxStartRule.setIsContextualRule(true);\n    if (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\n      ctxStartRule.addPostFillerItem(ctxItem);\n    else\n      ctxStartRule.addPreFillerItem(ctxItem);\n    result.add(ctxStartRule);\n    return result;\n  }","code":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\n    List<LP2Rule> result = new ArrayList<LP2Rule>();\n   \n   \n   \n    LP2RuleItem ctxItem = new LP2RuleItem();\n    MLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\n            slotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\n            aStartRule);\n    ctxItem.setContextConstraint(ctxConstraint);\n    LP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\n    ctxStartRule.setIsContextualRule(true);\n    if (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\n      ctxStartRule.addPostFillerItem(ctxItem);\n    else\n      ctxStartRule.addPreFillerItem(ctxItem);\n    result.add(ctxStartRule);\n    return result;\n  }","cleancode":"protected list<lp2rule> createcontextstartrulesforstartrule(final lp2rule astartrule) { list<lp2rule> result = new arraylist<lp2rule>(); lp2ruleitem ctxitem = new lp2ruleitem(); mllp2contextconstraint ctxconstraint = new mllp2contextconstraint( slotmaximumtokencountmap.get(astartrule.gettarget().getsingleslotrawtypename()), astartrule); ctxitem.setcontextconstraint(ctxconstraint); lp2rule ctxstartrule = new lp2rule(this, astartrule.gettarget()); ctxstartrule.setiscontextualrule(true); if (astartrule.gettarget().type == mltargettype.single_left_boundary) ctxstartrule.addpostfilleritem(ctxitem); else ctxstartrule.addprefilleritem(ctxitem); result.add(ctxstartrule); return result; }","comment":"\/\/ todo make all other tags contextual tags here. for now we take only \/\/ the counterpart \/\/ tag of the current learning process: (opening\/closing tags)","repo":"apache\/uima-ruta","code_context_2":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\nList<LP2Rule> result = new ArrayList<LP2Rule>();\n\/\/ TODO make all other tags contextual tags here. for now we take only\n\/\/ the counterpart\n\/\/ tag of the current learning process: (opening\/closing tags)\nLP2RuleItem ctxItem = new LP2RuleItem();\nMLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(","code_context_10":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\nList<LP2Rule> result = new ArrayList<LP2Rule>();\n\/\/ TODO make all other tags contextual tags here. for now we take only\n\/\/ the counterpart\n\/\/ tag of the current learning process: (opening\/closing tags)\nLP2RuleItem ctxItem = new LP2RuleItem();\nMLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\nslotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\naStartRule);\nctxItem.setContextConstraint(ctxConstraint);\nLP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\nctxStartRule.setIsContextualRule(true);\nif (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\nctxStartRule.addPostFillerItem(ctxItem);\nelse","code_context_20":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\nList<LP2Rule> result = new ArrayList<LP2Rule>();\n\/\/ TODO make all other tags contextual tags here. for now we take only\n\/\/ the counterpart\n\/\/ tag of the current learning process: (opening\/closing tags)\nLP2RuleItem ctxItem = new LP2RuleItem();\nMLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\nslotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\naStartRule);\nctxItem.setContextConstraint(ctxConstraint);\nLP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\nctxStartRule.setIsContextualRule(true);\nif (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\nctxStartRule.addPostFillerItem(ctxItem);\nelse\nctxStartRule.addPreFillerItem(ctxItem);\nresult.add(ctxStartRule);\nreturn result;\n}","label":[0,1,0,0]}
{"id":24503,"original_code":"@Override\n    public void runOpMode(){\n        \/\/When the robot begins, it is in initialized state\n        \/\/In this state, initialize the robot sensors and actuators\n        \/\/and wait for the event: driver pushes START\n        \/\/************************************************************\n        \/\/***   INITIALIZE THE ROBOT\n        \/\/************************************************************\n        autonParameters = AutonParameters.DEBUG_TWO_WHEEL;\n        autonParameters.setSpeed(Speed.FAST);\n        autonParameters.getSpeed().setK_i(0.3);\n        robot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\n        targetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\n        launchLine = new LaunchLine();\n        autonState = AutonState.INITIALIZE;\n        stateStopWatch = new StopWatch();\n        \/\/Initialize the wheels\n        robot.initializeStandardDriveWheels(hardwareMap);\n        \/\/Initialize the imu\n        robot.initializeImu(hardwareMap);\n        \/\/Initialize the color sensors\n        robot.initializeColorSensors(hardwareMap);\n        \/\/Initialize the digitalTouch sensors\n        robot.initializeEbotsDigitalTouches(hardwareMap);\n        \/\/Initialize the LED lights\n        robot.initializeRevBlinkinLedDriver(hardwareMap);\n        \/\/Initialize the Rev2mDistance Sensors\n        robot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n        \/\/Prepare the expansion hubs for bulk reads\n        robot.initializeExpansionHubsForBulkRead(hardwareMap);\n        telemetry.addLine(robot.getActualPose().toString());\n        telemetry.addLine(\"Initialization Complete!\");\n        telemetry.update();\n        Pose newPose = robot.getActualPose();\n        newPose.getX();\n        robot.setTargetPose(newPose);\n        waitForStart();\n        telemetry.clearAll();\n        long stateTimeLimit = 0L;\n        while(opModeIsActive()){\n            switch (autonState) {\n                case INITIALIZE:\n                    if (this.isStarted()) {       \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n                        \/\/Perform the transitional actions\n                        \/\/Initialize the encoders\n                        robot.initializeEncoderTrackers(autonParameters);\n                        \/\/Set the target pose (where the robot should drive to + heading)\n                        Pose targetPose = new Pose(targetZone.getFieldPosition(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.MOVE_TO_TARGET_ZONE;\n                        standardStateTransitionActions();\n                    } else {\n                        telemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\n                        telemetry.update();\n                    }\n                    break;\n                case MOVE_TO_TARGET_ZONE:\n                    if (robot.getEbotsMotionController().isTargetPoseReached(robot)      \/\/check if trigger event occurred\n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n                        \/\/Perform transitional actions\n                        robot.stop();\n                        \/\/Set the new state\n                        autonState = AutonState.PLACE_WOBBLE_GOAL;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000;     \/\/set a timelimit of 5 seconds for next state\n                    } else {\n                        \/\/Perform the state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case PLACE_WOBBLE_GOAL:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){  \/\/trigger event?\n                        \/\/Perform transitional actions\n                        \/\/TBD code to fold Wobble Arm\n                        \/\/Create a new target pose on the launch line in center of field\n                        double xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\n                        Pose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.MOVE_TO_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {   \/\/perform the state actions\n                        \/\/TBD code to place the wobble goal\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case MOVE_TO_LAUNCH_LINE:\n                    if(robot.getEbotsMotionController().isTargetPoseReached(robot)          \/\/trigger event?\n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){      \/\/or timed out?\n                        \/\/Perform transitional actions\n                        robot.stop();\n                        \/\/TBD spin up the ring launcher\n                        \/\/Set the new state\n                        autonState = AutonState.SHOOT_POWER_SHOTS;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000L;\n                    } else {                    \/\/perform the state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case SHOOT_POWER_SHOTS:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){     \/\/trigger event?\n                        robot.stop();\n                        \/\/Create a new target pose on the launch line in center of field\n                        Pose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.PARK_ON_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {            \/\/perform state actions\n                        \/\/TBD action to launch rings at powershots\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case PARK_ON_LAUNCH_LINE:\n                    if(!opModeIsActive()){      \/\/check for trigger event\n                        robot.stop();\n                    } else {                \/\/perform state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n            }\n        }\n        \/\/Exit opmode\n        robot.stop();\n        \/\/State debug info\n\/\/        if (debugOn) {\n\/\/            Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/            if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/                Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/            } else {\n\/\/                Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/            }\n\/\/        }\n    }","code":"@Override\n    public void runOpMode(){\n       \n       \n       \n       \n       \n       \n        autonParameters = AutonParameters.DEBUG_TWO_WHEEL;\n        autonParameters.setSpeed(Speed.FAST);\n        autonParameters.getSpeed().setK_i(0.3);\n        robot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\n        targetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\n        launchLine = new LaunchLine();\n        autonState = AutonState.INITIALIZE;\n        stateStopWatch = new StopWatch();\n       \n        robot.initializeStandardDriveWheels(hardwareMap);\n       \n        robot.initializeImu(hardwareMap);\n       \n        robot.initializeColorSensors(hardwareMap);\n       \n        robot.initializeEbotsDigitalTouches(hardwareMap);\n       \n        robot.initializeRevBlinkinLedDriver(hardwareMap);\n       \n        robot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n       \n        robot.initializeExpansionHubsForBulkRead(hardwareMap);\n        telemetry.addLine(robot.getActualPose().toString());\n        telemetry.addLine(\"Initialization Complete!\");\n        telemetry.update();\n        Pose newPose = robot.getActualPose();\n        newPose.getX();\n        robot.setTargetPose(newPose);\n        waitForStart();\n        telemetry.clearAll();\n        long stateTimeLimit = 0L;\n        while(opModeIsActive()){\n            switch (autonState) {\n                case INITIALIZE:\n                    if (this.isStarted()) {      \n                       \n                       \n                        robot.initializeEncoderTrackers(autonParameters);\n                       \n                        Pose targetPose = new Pose(targetZone.getFieldPosition(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.MOVE_TO_TARGET_ZONE;\n                        standardStateTransitionActions();\n                    } else {\n                        telemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\n                        telemetry.update();\n                    }\n                    break;\n                case MOVE_TO_TARGET_ZONE:\n                    if (robot.getEbotsMotionController().isTargetPoseReached(robot)     \n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n                       \n                        robot.stop();\n                       \n                        autonState = AutonState.PLACE_WOBBLE_GOAL;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000;    \n                    } else {\n                       \n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case PLACE_WOBBLE_GOAL:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \n                       \n                       \n                       \n                        double xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\n                        Pose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.MOVE_TO_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {  \n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case MOVE_TO_LAUNCH_LINE:\n                    if(robot.getEbotsMotionController().isTargetPoseReached(robot)         \n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){     \n                       \n                        robot.stop();\n                       \n                       \n                        autonState = AutonState.SHOOT_POWER_SHOTS;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000L;\n                    } else {                   \n                        robot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case SHOOT_POWER_SHOTS:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){    \n                        robot.stop();\n                       \n                        Pose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.PARK_ON_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {           \n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case PARK_ON_LAUNCH_LINE:\n                    if(!opModeIsActive()){     \n                        robot.stop();\n                    } else {               \n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n            }\n        }\n       \n        robot.stop();\n       \n    }","cleancode":"@override public void runopmode(){ autonparameters = autonparameters.debug_two_wheel; autonparameters.setspeed(speed.fast); autonparameters.getspeed().setk_i(0.3); robot = new robot(pose.presetpose.inner_start_line, alliance.red, autonparameters); targetzone = new targetzone(robot.getalliance(),targetzone.zone.b); launchline = new launchline(); autonstate = autonstate.initialize; statestopwatch = new stopwatch(); robot.initializestandarddrivewheels(hardwaremap); robot.initializeimu(hardwaremap); robot.initializecolorsensors(hardwaremap); robot.initializeebotsdigitaltouches(hardwaremap); robot.initializerevblinkinleddriver(hardwaremap); robot.initializeebotsrev2mdistancesensors(hardwaremap); robot.initializeexpansionhubsforbulkread(hardwaremap); telemetry.addline(robot.getactualpose().tostring()); telemetry.addline(\"initialization complete!\"); telemetry.update(); pose newpose = robot.getactualpose(); newpose.getx(); robot.settargetpose(newpose); waitforstart(); telemetry.clearall(); long statetimelimit = 0l; while(opmodeisactive()){ switch (autonstate) { case initialize: if (this.isstarted()) { robot.initializeencodertrackers(autonparameters); pose targetpose = new pose(targetzone.getfieldposition(), 0); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.move_to_target_zone; standardstatetransitionactions(); } else { telemetry.addline(\"stuck in initialized state, something is wrong\"); telemetry.update(); } break; case move_to_target_zone: if (robot.getebotsmotioncontroller().istargetposereached(robot) | statestopwatch.getelapsedtimemillis() > statetimelimit) { robot.stop(); autonstate = autonstate.place_wobble_goal; standardstatetransitionactions(); statetimelimit = 5000; } else { robot.getebotsmotioncontroller().movetotargetpose(robot, statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; case place_wobble_goal: if(statestopwatch.getelapsedtimemillis() > statetimelimit){ double xcoord = launchline.getx()-(robot.getsizecoordinate(csysdirection.x)\/2); pose targetpose = new pose(xcoord, robot.getactualpose().gety(), 0); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.move_to_launch_line; standardstatetransitionactions(); } else { telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring() + \" time limit \" + statetimelimit); } break; case move_to_launch_line: if(robot.getebotsmotioncontroller().istargetposereached(robot) | statestopwatch.getelapsedtimemillis() > statetimelimit){ robot.stop(); autonstate = autonstate.shoot_power_shots; standardstatetransitionactions(); statetimelimit = 5000l; } else { robot.getebotsmotioncontroller().movetotargetpose(robot,statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; case shoot_power_shots: if(statestopwatch.getelapsedtimemillis() > statetimelimit){ robot.stop(); pose targetpose = new pose(launchline.getx(), robot.getactualpose().gety(), 180); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.park_on_launch_line; standardstatetransitionactions(); } else { telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring() + \" time limit \" + statetimelimit); } break; case park_on_launch_line: if(!opmodeisactive()){ robot.stop(); } else { robot.getebotsmotioncontroller().movetotargetpose(robot, statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; } } robot.stop(); }","comment":"\/\/when the robot begins, it is in initialized state \/\/in this state, initialize the robot sensors and actuators \/\/and wait for the event: driver pushes start \/\/************************************************************ \/\/*** initialize the robot \/\/************************************************************\n\/\/initialize the wheels\n\/\/initialize the imu\n\/\/initialize the color sensors\n\/\/initialize the digitaltouch sensors\n\/\/initialize the led lights\n\/\/initialize the rev2mdistance sensors\n\/\/prepare the expansion hubs for bulk reads\n\/\/event to trigger next state is pushing start button\n\/\/perform the transitional actions \/\/initialize the encoders\n\/\/set the target pose (where the robot should drive to + heading)\n\/\/set the new state\n\/\/check if trigger event occurred\n\/\/perform transitional actions\n\/\/set the new state\n\/\/set a timelimit of 5 seconds for next state\n\/\/perform the state actions\n\/\/report telemetry\n\/\/trigger event?\n\/\/perform transitional actions \/\/tbd code to fold wobble arm \/\/create a new target pose on the launch line in center of field\n\/\/set the new state\n\/\/perform the state actions\n\/\/tbd code to place the wobble goal\n\/\/trigger event?\n\/\/or timed out?\n\/\/perform transitional actions\n\/\/tbd spin up the ring launcher \/\/set the new state\n\/\/perform the state actions\n\/\/report telemetry\n\/\/trigger event?\n\/\/create a new target pose on the launch line in center of field\n\/\/set the new state\n\/\/perform state actions\n\/\/tbd action to launch rings at powershots\n\/\/check for trigger event\n\/\/perform state actions\n\/\/report telemetry\n\/\/exit opmode\n\/\/state debug info \/\/ if (debugon) { \/\/ log.d(logtag, \"transitioning out of state \" + autonstate.tostring()); \/\/ if (robot.getebotsmotioncontroller().istargetposereached(robot)) { \/\/ log.d(logtag, \"pose achieved in \" + format(\"%.2f\", statestopwatch.getelapsedtimeseconds())); \/\/ } else { \/\/ log.d(logtag, \"failed to reach target, timed out!!! \" + robot.getposeerror().tostring()); \/\/ } \/\/ }","repo":"bignaczak\/eBots2020_V2","code_context_2":"@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\n\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\n\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\n\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\n\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\n\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\n\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\n\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\n\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\n\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\n\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\n\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\n\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\n\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\n\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\n\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\n\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\n\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\n\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\n\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\n\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\n\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\n\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\n\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/ Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/ } else {\n\/\/ Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/ }\n\/\/ }\n}","code_context_10":"@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\n\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\n\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\n\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\n\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\n\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\n\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\n\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\n\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\n\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\n\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\n\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\n\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\n\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/ Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/ } else {\n\/\/ Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/ }\n\/\/ }\n\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/ Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/ } else {\n\/\/ Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/ }\n\/\/ }\n}","code_context_20":"@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\n@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\n\n@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\n\n@Override\npublic void runOpMode(){\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\n\n\/\/When the robot begins, it is in initialized state\n\/\/In this state, initialize the robot sensors and actuators\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\n\/\/and wait for the event: driver pushes START\n\/\/************************************************************\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\n\n\/\/*** INITIALIZE THE ROBOT\n\/\/************************************************************\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\n\nautonParameters = AutonParameters.DEBUG_TWO_WHEEL;\nautonParameters.setSpeed(Speed.FAST);\nautonParameters.getSpeed().setK_i(0.3);\nrobot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\ntargetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\nlaunchLine = new LaunchLine();\nautonState = AutonState.INITIALIZE;\nstateStopWatch = new StopWatch();\n\/\/Initialize the wheels\nrobot.initializeStandardDriveWheels(hardwareMap);\n\/\/Initialize the imu\nrobot.initializeImu(hardwareMap);\n\/\/Initialize the color sensors\nrobot.initializeColorSensors(hardwareMap);\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\n\n\/\/Initialize the digitalTouch sensors\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\nrobot.initializeEbotsDigitalTouches(hardwareMap);\n\/\/Initialize the LED lights\nrobot.initializeRevBlinkinLedDriver(hardwareMap);\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\n\n\/\/Initialize the Rev2mDistance Sensors\nrobot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n\/\/Prepare the expansion hubs for bulk reads\nrobot.initializeExpansionHubsForBulkRead(hardwareMap);\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\n\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\n\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\n\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\n\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\n\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\n\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\n\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\nautonState = AutonState.SHOOT_POWER_SHOTS;\nstandardStateTransitionActions();\nstateTimeLimit = 5000L;\n} else { \/\/perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\n\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform the state actions\n\/\/TBD code to place the wobble goal\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase MOVE_TO_LAUNCH_LINE:\nif(robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/trigger event?\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/or timed out?\n\/\/Perform transitional actions\nrobot.stop();\n\/\/TBD spin up the ring launcher\n\/\/Set the new state\n\ntelemetry.addLine(robot.getActualPose().toString());\ntelemetry.addLine(\"Initialization Complete!\");\ntelemetry.update();\nPose newPose = robot.getActualPose();\nnewPose.getX();\nrobot.setTargetPose(newPose);\nwaitForStart();\ntelemetry.clearAll();\nlong stateTimeLimit = 0L;\nwhile(opModeIsActive()){\nswitch (autonState) {\ncase INITIALIZE:\nif (this.isStarted()) { \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n\/\/Perform the transitional actions\n\/\/Initialize the encoders\nrobot.initializeEncoderTrackers(autonParameters);\n\/\/Set the target pose (where the robot should drive to + heading)\nPose targetPose = new Pose(targetZone.getFieldPosition(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\n\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\nrobot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase SHOOT_POWER_SHOTS:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\nrobot.stop();\n\/\/Create a new target pose on the launch line in center of field\nPose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.PARK_ON_LAUNCH_LINE;\nstandardStateTransitionActions();\n} else { \/\/perform state actions\n\/\/TBD action to launch rings at powershots\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_TARGET_ZONE;\nstandardStateTransitionActions();\n} else {\ntelemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\ntelemetry.update();\n}\nbreak;\ncase MOVE_TO_TARGET_ZONE:\nif (robot.getEbotsMotionController().isTargetPoseReached(robot) \/\/check if trigger event occurred\n| stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n\/\/Perform transitional actions\nrobot.stop();\n\/\/Set the new state\nautonState = AutonState.PLACE_WOBBLE_GOAL;\nstandardStateTransitionActions();\nstateTimeLimit = 5000; \/\/set a timelimit of 5 seconds for next state\n} else {\n\/\/Perform the state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\ncase PLACE_WOBBLE_GOAL:\nif(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \/\/trigger event?\n\/\/Perform transitional actions\n\/\/TBD code to fold Wobble Arm\n\/\/Create a new target pose on the launch line in center of field\ndouble xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\nPose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\nrobot.setTargetPose(targetPose);\nstateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n\/\/Set the new state\nautonState = AutonState.MOVE_TO_LAUNCH_LINE;\nstandardStateTransitionActions();\n\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/ Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/ } else {\n\/\/ Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/ }\n\/\/ }\n}\n\n}\nbreak;\ncase PARK_ON_LAUNCH_LINE:\nif(!opModeIsActive()){ \/\/check for trigger event\nrobot.stop();\n} else { \/\/perform state actions\nrobot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n\/\/Report telemetry\ntelemetry.addData(\"Current State\", autonState.toString());\ntelemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\ntelemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\ntelemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\ntelemetry.addData(\"Error: \", robot.getPoseError().toString());\ntelemetry.update();\n}\nbreak;\n}\n}\n\/\/Exit opmode\nrobot.stop();\n\/\/State debug info\n\/\/ if (debugOn) {\n\/\/ Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/ if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/ Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/ } else {\n\/\/ Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/ }\n\/\/ }\n}","label":[0,1,0,0]}

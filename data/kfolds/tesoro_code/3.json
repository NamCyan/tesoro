{"id":32858,"original_code":"@Override\n  protected Collection<String> getDirectoryEntries(Path path) throws IOException {\n    \/\/ TODO(felly): Support directory traversal.\n    return ImmutableList.of();\n  }","code_wo_comment":"@Override\n  protected Collection<String> getDirectoryEntries(Path path) throws IOException {\n   \n    return ImmutableList.of();\n  }","cleancode":"@override protected collection<string> getdirectoryentries(path path) throws ioexception { return immutablelist.of(); }","repo":"bloomberg\/bazel","label":[1,0,0,0]}
{"id":8382,"original_code":"public String parseId() throws SyntaxError {\n    String value = parseArg();\n    if (argWasQuoted()) {\n      throw new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n    } else if (value == null) {\n      throw new SyntaxError(\"Expected identifier instead of 'null' for function \"  + sp);\n    }\n    return value;\n  }","code_wo_comment":"public String parseId() throws SyntaxError {\n    String value = parseArg();\n    if (argWasQuoted()) {\n      throw new SyntaxError(\"Expected identifier instead of quoted string:\" + value);\n    } else if (value == null) {\n      throw new SyntaxError(\"Expected identifier instead of 'null' for function \"  + sp);\n    }\n    return value;\n  }","cleancode":"public string parseid() throws syntaxerror { string value = parsearg(); if (argwasquoted()) { throw new syntaxerror(\"expected identifier instead of quoted string:\" + value); } else if (value == null) { throw new syntaxerror(\"expected identifier instead of 'null' for function \" + sp); } return value; }","repo":"anon24816\/lucene-solr","label":[0,0,0,0]}
{"id":8383,"original_code":"public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n      \/\/ nestedQuery would be null when de-referenced query value is not specified\n      \/\/ Ex: query($qq) in request with no qq param specified\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n      QParser sub;\n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n          \/\/ value specified directly in local params... so the end of the\n          \/\/ query should be the end of the local params.\n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n          \/\/ value here is *after* the local params... ask the parser.\n          sub = subQuery(qs, null);\n          \/\/ int subEnd = sub.findEnd(')');\n          \/\/ TODO.. implement functions to find the end of a nested query\n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n      sp.pos += end-start;  \/\/ advance past nested query\n      nestedQuery = sub.getQuery();\n      \/\/ handling null check on nestedQuery separately, so that proper error can be returned\n      \/\/ one case this would be possible when v is specified but v's value is empty or has only spaces\n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n    return nestedQuery;\n  }","code_wo_comment":"public Query parseNestedQuery() throws SyntaxError {\n    Query nestedQuery;\n    if (sp.opt(\"$\")) {\n      String param = sp.getId();\n      String qstr = getParam(param);\n      qstr = qstr==null ? \"\" : qstr;\n      nestedQuery = subQuery(qstr, null).getQuery();\n     \n     \n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Missing param \" + param + \" while parsing function '\" + sp.val + \"'\");\n      }\n    }\n    else {\n      int start = sp.pos;\n      String v = sp.val;\n      String qs = v;\n      ModifiableSolrParams nestedLocalParams = new ModifiableSolrParams();\n      int end = QueryParsing.parseLocalParams(qs, start, nestedLocalParams, getParams());\n      QParser sub;\n      if (end>start) {\n        if (nestedLocalParams.get(QueryParsing.V) != null) {\n         \n         \n          sub = subQuery(qs.substring(start, end), null);\n        } else {\n         \n          sub = subQuery(qs, null);\n         \n         \n          throw new SyntaxError(\"Nested local params must have value in v parameter.  got '\" + qs + \"'\");\n        }\n      } else {\n        throw new SyntaxError(\"Nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\");\n      }\n      sp.pos += end-start; \n      nestedQuery = sub.getQuery();\n     \n     \n      if (nestedQuery == null) {\n        throw new SyntaxError(\"Nested function query returned null for '\" + sp.val + \"'\");\n      }\n    }\n    consumeArgumentDelimiter();\n    return nestedQuery;\n  }","cleancode":"public query parsenestedquery() throws syntaxerror { query nestedquery; if (sp.opt(\"$\")) { string param = sp.getid(); string qstr = getparam(param); qstr = qstr==null ? \"\" : qstr; nestedquery = subquery(qstr, null).getquery(); if (nestedquery == null) { throw new syntaxerror(\"missing param \" + param + \" while parsing function '\" + sp.val + \"'\"); } } else { int start = sp.pos; string v = sp.val; string qs = v; modifiablesolrparams nestedlocalparams = new modifiablesolrparams(); int end = queryparsing.parselocalparams(qs, start, nestedlocalparams, getparams()); qparser sub; if (end>start) { if (nestedlocalparams.get(queryparsing.v) != null) { sub = subquery(qs.substring(start, end), null); } else { sub = subquery(qs, null); throw new syntaxerror(\"nested local params must have value in v parameter. got '\" + qs + \"'\"); } } else { throw new syntaxerror(\"nested function query must use $param or {!v=value} forms. got '\" + qs + \"'\"); } sp.pos += end-start; nestedquery = sub.getquery(); if (nestedquery == null) { throw new syntaxerror(\"nested function query returned null for '\" + sp.val + \"'\"); } } consumeargumentdelimiter(); return nestedquery; }","repo":"anon24816\/lucene-solr","label":[0,1,0,0]}
{"id":16595,"original_code":"public void testPrint() throws Exception {\n        Map map = new HashMap();\n        map.put(\"bob\", \"drools\");\n        map.put(\"james\", \"geronimo\");\n        List list = new ArrayList();\n        list.add(map);\n        \/** @todo fix this! *\/\n        \/\/assertConsoleOutput(list, \"[['bob':'drools', 'james':'geronimo']]\");\n    }","code_wo_comment":"public void testPrint() throws Exception {\n        Map map = new HashMap();\n        map.put(\"bob\", \"drools\");\n        map.put(\"james\", \"geronimo\");\n        List list = new ArrayList();\n        list.add(map);\n       \n       \n    }","cleancode":"public void testprint() throws exception { map map = new hashmap(); map.put(\"bob\", \"drools\"); map.put(\"james\", \"geronimo\"); list list = new arraylist(); list.add(map); }","repo":"chanwit\/groovy","label":[0,0,1,0]}
{"id":8514,"original_code":"public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            for (String name : ALWAYS_READABLE_PATHS) {\n                if (rest.startsWith(name)) {\n                    return this;\n                }\n            }\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\n                    return this;\n                }\n            }\n            \/\/ TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n                && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\n                return this;\n            }\n            throw e;\n        }\n        return this;\n    }","code_wo_comment":"public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            for (String name : ALWAYS_READABLE_PATHS) {\n                if (rest.startsWith(name)) {\n                    return this;\n                }\n            }\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) {\n                    return this;\n                }\n            }\n           \n            if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\")\n                && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))) {\n                return this;\n            }\n            throw e;\n        }\n        return this;\n    }","cleancode":"public object gettarget() { try { checkpermission(read); } catch (accessdeniedexception e) { string rest = stapler.getcurrentrequest().getrestofpath(); for (string name : always_readable_paths) { if (rest.startswith(name)) { return this; } } for (string name : getunprotectedrootactions()) { if (rest.startswith(\"\/\" + name + \"\/\") || rest.equals(\"\/\" + name)) { return this; } } if (rest.matches(\"\/computer\/[^\/]+\/slave-agent[.]jnlp\") && \"true\".equals(stapler.getcurrentrequest().getparameter(\"encrypt\"))) { return this; } throw e; } return this; }","repo":"codemonkey77\/jenkins","label":[1,0,0,0]}
{"id":24924,"original_code":"public ObjectiveFunctionInterface getObjectiveFunction(){\n\t\treturn this.oObjectiveFunction;\n\t}","code_wo_comment":"public ObjectiveFunctionInterface getObjectiveFunction(){\n\t\treturn this.oObjectiveFunction;\n\t}","cleancode":"public objectivefunctioninterface getobjectivefunction(){ return this.oobjectivefunction; }","repo":"cmyxt502\/aim-project-2020","label":[0,1,0,0]}
{"id":16806,"original_code":"@Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n            Bundle args = getArguments();\n            TierCategory category = (TierCategory) args.getSerializable(\"category\");\n            String tier = args.getString(\"tier\");\n            \/\/ Inflate the layout for this fragment\n            View view = inflater.inflate(R.layout.fragment_tier_list, container, false);\n            LinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\n            try {\/\/TODO: see if we can be more error-tolerance\n                myTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return view;\n        }","code_wo_comment":"@Override\n        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n            Bundle args = getArguments();\n            TierCategory category = (TierCategory) args.getSerializable(\"category\");\n            String tier = args.getString(\"tier\");\n           \n            View view = inflater.inflate(R.layout.fragment_tier_list, container, false);\n            LinearLayout layout = (LinearLayout) view.findViewById(R.id.tier_layout);\n            try \n                myTask = new PopulateTierTableAsyncTask(getActivity(), layout, category).execute(tier);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return view;\n        }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { bundle args = getarguments(); tiercategory category = (tiercategory) args.getserializable(\"category\"); string tier = args.getstring(\"tier\"); view view = inflater.inflate(r.layout.fragment_tier_list, container, false); linearlayout layout = (linearlayout) view.findviewbyid(r.id.tier_layout); try mytask = new populatetiertableasynctask(getactivity(), layout, category).execute(tier); } catch (exception e) { e.printstacktrace(); } return view; }","repo":"chinhodado\/BBDB","label":[1,0,0,0]}
{"id":16807,"original_code":"@Override\n        protected void onPostExecute(Void param) {\n            if (pageDOM == null) {\n                return; \/\/ instead of try-catch\n            }\n            Elements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n            \/\/ calculate the width of the images to be displayed later on\n            Display display = activity.getWindowManager().getDefaultDisplay();\n            Point size = new Point();\n            display.getSize(size);\n            int screenWidth = size.x;\n            int scaleWidth = screenWidth \/ 10; \/\/ set it to be 1\/10 of the screen width\n            int tableIndex = tierMap.get(category).get(tier);\n            Element tierTable = tierTables.get(tableIndex);\n            TableLayout table = new TableLayout(activity);\n            Elements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\"); \/\/ get all rows in each table\n            int countRow = 0;\n            for (Element row : rows) {\n                countRow++;\n                if (countRow == 1) {\n                    \/\/ row 1 is the column headers. This may be different in the DOM in browser\n                    continue;\n                }\n                else {\n                    Elements cells = row.getElementsByTag(\"td\");\n                    TableRow tr = new TableRow(activity);\n                    ImageView imgView = new ImageView(activity); tr.addView(imgView);\n                    \/\/ get the thubnail image src\n                    Element link = row.getElementsByTag(\"a\").first();\n                    String imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\n                    if (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\n                    imgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5))); \/\/ the height's not exact\n                    imgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n                    \/\/ get the scaled image link and display it\n                    String newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\n                    ImageLoader.getInstance().displayImage(newScaledLink, imgView);\n                    String famName = cells.get(2).text();\n                    TextView tv = new TextView(activity);\n                    tv.setText(famName);\n                    tr.addView(tv);\n                    tr.setGravity(0x10); \/\/center vertical\n                    table.addView(tr);\n                    tr.setTag(famName);\n                    tr.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            Intent intent = new Intent(activity, FamDetailActivity.class);\n                            intent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\n                            activity.startActivity(intent);\n                        }\n                    });\n                }\n            }\n            layout.addView(table);\n            \/\/TODO: center the spinner horizontally\n            \/\/remove the spinner\n            ProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\n            layout.removeView(progressBar);\n        }","code_wo_comment":"@Override\n        protected void onPostExecute(Void param) {\n            if (pageDOM == null) {\n                return;\n            }\n            Elements tierTables = pageDOM.getElementsByClass(\"wikitable\");\n           \n            Display display = activity.getWindowManager().getDefaultDisplay();\n            Point size = new Point();\n            display.getSize(size);\n            int screenWidth = size.x;\n            int scaleWidth = screenWidth \/ 10;\n            int tableIndex = tierMap.get(category).get(tier);\n            Element tierTable = tierTables.get(tableIndex);\n            TableLayout table = new TableLayout(activity);\n            Elements rows = tierTable.getElementsByTag(\"tbody\").first().getElementsByTag(\"tr\");\n            int countRow = 0;\n            for (Element row : rows) {\n                countRow++;\n                if (countRow == 1) {\n                   \n                    continue;\n                }\n                else {\n                    Elements cells = row.getElementsByTag(\"td\");\n                    TableRow tr = new TableRow(activity);\n                    ImageView imgView = new ImageView(activity); tr.addView(imgView);\n                   \n                    Element link = row.getElementsByTag(\"a\").first();\n                    String imgSrc = link.getElementsByTag(\"img\").first().attr(\"data-src\");\n                    if (imgSrc == null || imgSrc.equals(\"\")) imgSrc = link.getElementsByTag(\"img\").first().attr(\"src\");\n                    imgView.setLayoutParams(new TableRow.LayoutParams(scaleWidth, (int) (scaleWidth*1.5)));\n                    imgView.setScaleType(ImageView.ScaleType.FIT_CENTER);\n                   \n                    String newScaledLink = Util.getScaledWikiaImageLink(imgSrc, scaleWidth);\n                    ImageLoader.getInstance().displayImage(newScaledLink, imgView);\n                    String famName = cells.get(2).text();\n                    TextView tv = new TextView(activity);\n                    tv.setText(famName);\n                    tr.addView(tv);\n                    tr.setGravity(0x10);\n                    table.addView(tr);\n                    tr.setTag(famName);\n                    tr.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            Intent intent = new Intent(activity, FamDetailActivity.class);\n                            intent.putExtra(MainActivity.FAM_NAME, (String) v.getTag());\n                            activity.startActivity(intent);\n                        }\n                    });\n                }\n            }\n            layout.addView(table);\n           \n           \n            ProgressBar progressBar = (ProgressBar) activity.findViewById(R.id.progressBar_tierTable);\n            layout.removeView(progressBar);\n        }","cleancode":"@override protected void onpostexecute(void param) { if (pagedom == null) { return; } elements tiertables = pagedom.getelementsbyclass(\"wikitable\"); display display = activity.getwindowmanager().getdefaultdisplay(); point size = new point(); display.getsize(size); int screenwidth = size.x; int scalewidth = screenwidth \/ 10; int tableindex = tiermap.get(category).get(tier); element tiertable = tiertables.get(tableindex); tablelayout table = new tablelayout(activity); elements rows = tiertable.getelementsbytag(\"tbody\").first().getelementsbytag(\"tr\"); int countrow = 0; for (element row : rows) { countrow++; if (countrow == 1) { continue; } else { elements cells = row.getelementsbytag(\"td\"); tablerow tr = new tablerow(activity); imageview imgview = new imageview(activity); tr.addview(imgview); element link = row.getelementsbytag(\"a\").first(); string imgsrc = link.getelementsbytag(\"img\").first().attr(\"data-src\"); if (imgsrc == null || imgsrc.equals(\"\")) imgsrc = link.getelementsbytag(\"img\").first().attr(\"src\"); imgview.setlayoutparams(new tablerow.layoutparams(scalewidth, (int) (scalewidth*1.5))); imgview.setscaletype(imageview.scaletype.fit_center); string newscaledlink = util.getscaledwikiaimagelink(imgsrc, scalewidth); imageloader.getinstance().displayimage(newscaledlink, imgview); string famname = cells.get(2).text(); textview tv = new textview(activity); tv.settext(famname); tr.addview(tv); tr.setgravity(0x10); table.addview(tr); tr.settag(famname); tr.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(activity, famdetailactivity.class); intent.putextra(mainactivity.fam_name, (string) v.gettag()); activity.startactivity(intent); } }); } } layout.addview(table); progressbar progressbar = (progressbar) activity.findviewbyid(r.id.progressbar_tiertable); layout.removeview(progressbar); }","repo":"chinhodado\/BBDB","label":[0,1,0,0]}
{"id":33203,"original_code":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\n        Method method = descriptor.getWriteMethod();\n        if (method != null) {\n            \/\/ TODO should we handle the property.name() attribute?\n            \/\/ maybe add this to XBean code generator...\n            Property property = method.getAnnotation(Property.class);\n            if (property != null) {\n                if (property.required()) {\n                    \/\/ TODO use property.name()?\n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n            Reference reference = method.getAnnotation(Reference.class);\n            if (reference != null) {\n                if (reference.required()) {\n                    \/\/ TODO use reference.name()?\n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"protected void processProperty(String beanName, BeanDefinition definition, PropertyDescriptor descriptor) throws BeansException {\n        Method method = descriptor.getWriteMethod();\n        if (method != null) {\n           \n           \n            Property property = method.getAnnotation(Property.class);\n            if (property != null) {\n                if (property.required()) {\n                   \n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory property: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n            Reference reference = method.getAnnotation(Reference.class);\n            if (reference != null) {\n                if (reference.required()) {\n                   \n                    String propertyName = descriptor.getName();\n                    MutablePropertyValues propertyValues = definition.getPropertyValues();\n                    if (!propertyValues.contains(propertyName)) {\n                        throw new BeanInitializationException(\"Mandatory reference: \" + propertyName + \" not specified on bean: \" + beanName);\n                    }\n                }\n            }\n        }\n    }","cleancode":"protected void processproperty(string beanname, beandefinition definition, propertydescriptor descriptor) throws beansexception { method method = descriptor.getwritemethod(); if (method != null) { property property = method.getannotation(property.class); if (property != null) { if (property.required()) { string propertyname = descriptor.getname(); mutablepropertyvalues propertyvalues = definition.getpropertyvalues(); if (!propertyvalues.contains(propertyname)) { throw new beaninitializationexception(\"mandatory property: \" + propertyname + \" not specified on bean: \" + beanname); } } } reference reference = method.getannotation(reference.class); if (reference != null) { if (reference.required()) { string propertyname = descriptor.getname(); mutablepropertyvalues propertyvalues = definition.getpropertyvalues(); if (!propertyvalues.contains(propertyname)) { throw new beaninitializationexception(\"mandatory reference: \" + propertyname + \" not specified on bean: \" + beanname); } } } } }","repo":"codehaus\/xbean","label":[1,0,0,0]}
{"id":16856,"original_code":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\n        if (pathElems.isEmpty()) return null;\n        List<String> bestTrail = null;\n        for(List<String> trail : possibleTrails) {\n            if (pathElems.size() > trail.size()) continue; \/\/ sure to fail\n            ListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\n            ListIterator<String> tit = trail.listIterator(trail.size());\n            boolean matched = true;\n            while(matched && pit.hasPrevious()) {\n                AltUrlPartResults urlInfos = pit.previous();\n                String categoryId = tit.previous();\n                \/\/ simplistic check: ignores exact vs name-only matches, but may be good enough\n                if (!urlInfos.containsKey(categoryId)) {\n                    matched = false;\n                }\n            }\n            if (matched) {\n                if (trail.size() == pathElems.size()) { \/\/ ideal case\n                    bestTrail = trail;\n                    break;\n                } else if (bestTrail == null || trail.size() < bestTrail.size()) { \/\/ smaller = better\n                    bestTrail = trail;\n                }\n            }\n        }\n        return bestTrail;\n    }","code_wo_comment":"protected List<String> findBestTrailForUrlPathElems(Delegator delegator, List<List<String>> possibleTrails, List<AltUrlPartResults> pathElems) throws GenericEntityException {\n        if (pathElems.isEmpty()) return null;\n        List<String> bestTrail = null;\n        for(List<String> trail : possibleTrails) {\n            if (pathElems.size() > trail.size()) continue;\n            ListIterator<AltUrlPartResults> pit = pathElems.listIterator(pathElems.size());\n            ListIterator<String> tit = trail.listIterator(trail.size());\n            boolean matched = true;\n            while(matched && pit.hasPrevious()) {\n                AltUrlPartResults urlInfos = pit.previous();\n                String categoryId = tit.previous();\n               \n                if (!urlInfos.containsKey(categoryId)) {\n                    matched = false;\n                }\n            }\n            if (matched) {\n                if (trail.size() == pathElems.size()) {\n                    bestTrail = trail;\n                    break;\n                } else if (bestTrail == null || trail.size() < bestTrail.size()) {\n                    bestTrail = trail;\n                }\n            }\n        }\n        return bestTrail;\n    }","cleancode":"protected list<string> findbesttrailforurlpathelems(delegator delegator, list<list<string>> possibletrails, list<alturlpartresults> pathelems) throws genericentityexception { if (pathelems.isempty()) return null; list<string> besttrail = null; for(list<string> trail : possibletrails) { if (pathelems.size() > trail.size()) continue; listiterator<alturlpartresults> pit = pathelems.listiterator(pathelems.size()); listiterator<string> tit = trail.listiterator(trail.size()); boolean matched = true; while(matched && pit.hasprevious()) { alturlpartresults urlinfos = pit.previous(); string categoryid = tit.previous(); if (!urlinfos.containskey(categoryid)) { matched = false; } } if (matched) { if (trail.size() == pathelems.size()) { besttrail = trail; break; } else if (besttrail == null || trail.size() < besttrail.size()) { besttrail = trail; } } } return besttrail; }","repo":"codesbyzhangpeng\/scipio-erp","label":[1,0,0,0]}
{"id":16860,"original_code":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\n        return ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n    }","code_wo_comment":"protected List<List<String>> getProductRollupTrails(Delegator delegator, String productId, Set<String> topCategoryIds) {\n        return ProductWorker.getProductRollupTrails(delegator, productId, topCategoryIds, true);\n    }","cleancode":"protected list<list<string>> getproductrolluptrails(delegator delegator, string productid, set<string> topcategoryids) { return productworker.getproductrolluptrails(delegator, productid, topcategoryids, true); }","repo":"codesbyzhangpeng\/scipio-erp","label":[0,1,0,0]}
{"id":16861,"original_code":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\n        return CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n    }","code_wo_comment":"protected List<List<String>> getCategoryRollupTrails(Delegator delegator, String productCategoryId, Set<String> topCategoryIds) {\n        return CategoryWorker.getCategoryRollupTrails(delegator, productCategoryId, topCategoryIds, true);\n    }","cleancode":"protected list<list<string>> getcategoryrolluptrails(delegator delegator, string productcategoryid, set<string> topcategoryids) { return categoryworker.getcategoryrolluptrails(delegator, productcategoryid, topcategoryids, true); }","repo":"codesbyzhangpeng\/scipio-erp","label":[0,1,0,0]}
{"id":33286,"original_code":"@Override\n    public void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n        \/\/ Validate client version\n        if (!message.getClientVersion().equals(requiredClientVersion)) {\n            ErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\n            connection.sendMessage(error);\n            logger.info(\"Sending Client Error\");\n            return;\n        }\n        SoeAccount account = accountService.validateSession(message.getToken());\n        if (account == null) {\n            ErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\n            connection.sendMessage(error);\n            logger.info(\"Invalid Session: \" + message.getToken());\n            return;\n        }\n        connection.setAccountId(account.getId());\n        connection.setAccountUsername(account.getUsername());\n        connection.addRole(ConnectionRole.AUTHENTICATED);\n        \/\/ TODO: Actually implement permissions\n        ClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\n        connection.sendMessage(cpm);\n    }","code_wo_comment":"@Override\n    public void handleIncoming(SoeUdpConnection connection, ClientIdMsg message) throws Exception {\n       \n        if (!message.getClientVersion().equals(requiredClientVersion)) {\n            ErrorMessage error = new ErrorMessage(\"Login Error\", \"The client you are attempting to connect with does not match that required by the server.\", false);\n            connection.sendMessage(error);\n            logger.info(\"Sending Client Error\");\n            return;\n        }\n        SoeAccount account = accountService.validateSession(message.getToken());\n        if (account == null) {\n            ErrorMessage error = new ErrorMessage(\"Error\", \"Invalid Session\", false);\n            connection.sendMessage(error);\n            logger.info(\"Invalid Session: \" + message.getToken());\n            return;\n        }\n        connection.setAccountId(account.getId());\n        connection.setAccountUsername(account.getUsername());\n        connection.addRole(ConnectionRole.AUTHENTICATED);\n       \n        ClientPermissionsMessage cpm = new ClientPermissionsMessage(true, true, true, true);\n        connection.sendMessage(cpm);\n    }","cleancode":"@override public void handleincoming(soeudpconnection connection, clientidmsg message) throws exception { if (!message.getclientversion().equals(requiredclientversion)) { errormessage error = new errormessage(\"login error\", \"the client you are attempting to connect with does not match that required by the server.\", false); connection.sendmessage(error); logger.info(\"sending client error\"); return; } soeaccount account = accountservice.validatesession(message.gettoken()); if (account == null) { errormessage error = new errormessage(\"error\", \"invalid session\", false); connection.sendmessage(error); logger.info(\"invalid session: \" + message.gettoken()); return; } connection.setaccountid(account.getid()); connection.setaccountusername(account.getusername()); connection.addrole(connectionrole.authenticated); clientpermissionsmessage cpm = new clientpermissionsmessage(true, true, true, true); connection.sendmessage(cpm); }","repo":"bacta\/cu","label":[0,1,0,0]}
{"id":25102,"original_code":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\n      final Stream<OWLAnnotation> annos) {\n    \/\/ Need a method in the OWL API to get Annotation by URI...\n    final Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\n    final AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\n    annos.forEach(anno -> {\n      final OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\n      if (prop != null && anno.getValue().asLiteral().isPresent()) {\n        final String literal = anno.getValue().asLiteral().get().getLiteral();\n        final OWLAxiom ax = factory\n            .getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\n        axioms.add(ax);\n      } else {\n        if (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\n          final OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n              .map(this::getSkosScheme).orElse(skosConceptScheme);\n          axioms.add(factory.\n              getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\n          inSchemeAdded.set(true);\n        } else if (includeUnmappedProperties) {\n          \/\/ for all other annotation axioms, just add them as they are\n          axioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n        }\n      }\n    });\n    \/\/ ensure inScheme is set. we need it, so set to default if missing\n    if (!inSchemeAdded.get()) {\n      axioms.add(factory.\n          getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n    }\n    \/\/ This is an after thought, whole script needs re-writing if i were to do this properly anyway\n    \/\/ want to use SKOS note to keep the original OBO identifier.\n    final String frag = concept.getIRI().getFragment();\n    final String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\n    axioms.add(factory.getOWLDataPropertyAssertionAxiom(\n        factory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n  }","code_wo_comment":"private void addSKOSDataProperties(final OWLNamedIndividual concept,\n      final Stream<OWLAnnotation> annos) {\n   \n    final Map<IRI, OWLDataProperty> annoMap = mapper.getAnnotationMap();\n    final AtomicBoolean inSchemeAdded = new AtomicBoolean(false);\n    annos.forEach(anno -> {\n      final OWLDataProperty prop = annoMap.get(anno.getProperty().getIRI());\n      if (prop != null && anno.getValue().asLiteral().isPresent()) {\n        final String literal = anno.getValue().asLiteral().get().getLiteral();\n        final OWLAxiom ax = factory\n            .getOWLDataPropertyAssertionAxiom(prop, concept, factory.getOWLLiteral(literal, \"en\"));\n        axioms.add(ax);\n      } else {\n        if (Obo2OWLVocabulary.IRI_OIO_hasOboNamespace.sameIRI(anno.getProperty())) {\n          final OWLIndividual scheme = anno.getValue().asLiteral().map(OWLLiteral::getLiteral)\n              .map(this::getSkosScheme).orElse(skosConceptScheme);\n          axioms.add(factory.\n              getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, scheme));\n          inSchemeAdded.set(true);\n        } else if (includeUnmappedProperties) {\n         \n          axioms.add(factory.getOWLAnnotationAssertionAxiom(concept.getIRI(), anno));\n        }\n      }\n    });\n   \n    if (!inSchemeAdded.get()) {\n      axioms.add(factory.\n          getOWLObjectPropertyAssertionAxiom(inSchemeProperty, concept, skosConceptScheme));\n    }\n   \n   \n    final String frag = concept.getIRI().getFragment();\n    final String oboId = UNDERSCORE.matcher(frag).replaceFirst(\":\");\n    axioms.add(factory.getOWLDataPropertyAssertionAxiom(\n        factory.getOWLDataProperty(SKOSVocabulary.NOTE), concept, oboId));\n  }","cleancode":"private void addskosdataproperties(final owlnamedindividual concept, final stream<owlannotation> annos) { final map<iri, owldataproperty> annomap = mapper.getannotationmap(); final atomicboolean inschemeadded = new atomicboolean(false); annos.foreach(anno -> { final owldataproperty prop = annomap.get(anno.getproperty().getiri()); if (prop != null && anno.getvalue().asliteral().ispresent()) { final string literal = anno.getvalue().asliteral().get().getliteral(); final owlaxiom ax = factory .getowldatapropertyassertionaxiom(prop, concept, factory.getowlliteral(literal, \"en\")); axioms.add(ax); } else { if (obo2owlvocabulary.iri_oio_hasobonamespace.sameiri(anno.getproperty())) { final owlindividual scheme = anno.getvalue().asliteral().map(owlliteral::getliteral) .map(this::getskosscheme).orelse(skosconceptscheme); axioms.add(factory. getowlobjectpropertyassertionaxiom(inschemeproperty, concept, scheme)); inschemeadded.set(true); } else if (includeunmappedproperties) { axioms.add(factory.getowlannotationassertionaxiom(concept.getiri(), anno)); } } }); if (!inschemeadded.get()) { axioms.add(factory. getowlobjectpropertyassertionaxiom(inschemeproperty, concept, skosconceptscheme)); } final string frag = concept.getiri().getfragment(); final string oboid = underscore.matcher(frag).replacefirst(\":\"); axioms.add(factory.getowldatapropertyassertionaxiom( factory.getowldataproperty(skosvocabulary.note), concept, oboid)); }","repo":"autayeu\/obo2skos","label":[1,1,0,0]}
{"id":16966,"original_code":"@SuppressWarnings(\"deprecation\")\n\tprivate static void broadcastStateChange(String title, boolean preparing, boolean titleOrSongHaveChanged) {\n\t\tif (notificationBroadcastPending) {\n\t\t\tlocalHandler.removeMessages(MSG_BROADCAST_STATE_CHANGE);\n\t\t\tnotificationBroadcastPending = false;\n\t\t}\n\t\tfinal long now = SystemClock.uptimeMillis();\n\t\tfinal long delta = now - notificationLastUpdateTime;\n\t\tif (delta < 100 || notificationLastUpdateTime == 0) {\n\t\t\tnotificationBroadcastPending = true;\n\t\t\tlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\n\t\t\treturn;\n\t\t}\n\t\tnotificationLastUpdateTime = now;\n\t\trefreshNotification();\n\t\tWidgetMain.updateWidgets();\n\t\t\/\/\n\t\t\/\/perhaps, one day we should implement RemoteControlClient for better Bluetooth support...?\n\t\t\/\/http:\/\/developer.android.com\/reference\/android\/media\/RemoteControlClient.html\n\t\t\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Music\/+\/master\/src\/com\/android\/music\/MediaPlaybackService.java\n\t\t\/\/\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/15527614\/send-track-informations-via-a2dp-avrcp\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/14536597\/how-does-the-android-lockscreen-get-playing-song\n\t\t\/\/http:\/\/stackoverflow.com\/questions\/10510292\/how-to-get-current-music-track-info\n\t\t\/\/\n\t\t\/\/https:\/\/android.googlesource.com\/platform\/packages\/apps\/Bluetooth\/+\/android-4.3_r0.9.1\/src\/com\/android\/bluetooth\/a2dp\/Avrcp.java\n\t\t\/\/\n\t\tif (localSong == null) {\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\n\t\t\tstickyBroadcast.removeExtra(\"id\");\n\t\t\tstickyBroadcast.removeExtra(\"songid\");\n\t\t\tstickyBroadcast.removeExtra(\"track\");\n\t\t\tstickyBroadcast.removeExtra(\"artist\");\n\t\t\tstickyBroadcast.removeExtra(\"album\");\n\t\t\tstickyBroadcast.removeExtra(\"duration\");\n\t\t\t\/\/stickyBroadcast.removeExtra(\"position\");\n\t\t\tstickyBroadcast.removeExtra(\"playing\");\n\t\t} else {\n\t\t\t\/\/apparently, a few 4.3 devices have an issue with com.android.music.metachanged....\n\t\t\t\/\/stickyBroadcast.setAction(playbackHasChanged ? \"com.android.music.playstatechanged\" : \"com.android.music.metachanged\");\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\n\t\t\tstickyBroadcast.putExtra(\"id\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"songid\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"track\", title);\n\t\t\tstickyBroadcast.putExtra(\"artist\", localSong.artist);\n\t\t\tstickyBroadcast.putExtra(\"album\", localSong.album);\n\t\t\tstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\t\t\t\/\/stickyBroadcast.putExtra(\"position\", (long)0);\n\t\t\tstickyBroadcast.putExtra(\"playing\", localPlaying);\n\t\t}\n\t\t\/\/ maybe check if api >= 21, and if so, use sendBroadcast instead.....???\n\t\t\/\/ https:\/\/developer.android.com\/reference\/android\/content\/Context#sendStickyBroadcast(android.content.Intent)\n\t\ttry {\n\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n\t\t\t\tthePlayer.sendBroadcast(stickyBroadcast);\n\t\t\telse\n\t\t\t\tthePlayer.sendStickyBroadcast(stickyBroadcast);\n\t\t} catch (RuntimeException ex) {\n\t\t\t\/\/just ignore because most apps actually use RemoteControlClient on newer Androids\n\t\t}\n\t\tif (remoteControlClient != null)\n\t\t\tbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\n\t\tif (mediaSession != null)\n\t\t\tbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n\t}","code_wo_comment":"@SuppressWarnings(\"deprecation\")\n\tprivate static void broadcastStateChange(String title, boolean preparing, boolean titleOrSongHaveChanged) {\n\t\tif (notificationBroadcastPending) {\n\t\t\tlocalHandler.removeMessages(MSG_BROADCAST_STATE_CHANGE);\n\t\t\tnotificationBroadcastPending = false;\n\t\t}\n\t\tfinal long now = SystemClock.uptimeMillis();\n\t\tfinal long delta = now - notificationLastUpdateTime;\n\t\tif (delta < 100 || notificationLastUpdateTime == 0) {\n\t\t\tnotificationBroadcastPending = true;\n\t\t\tlocalHandler.sendMessageAtTime(Message.obtain(localHandler, MSG_BROADCAST_STATE_CHANGE, (preparing ? 0x01 : 0) | (titleOrSongHaveChanged ? 0x02 : 0), 0, title), (notificationLastUpdateTime == 0 ? ((notificationLastUpdateTime = now) + 2000) : (notificationLastUpdateTime + 110 - delta)));\n\t\t\treturn;\n\t\t}\n\t\tnotificationLastUpdateTime = now;\n\t\trefreshNotification();\n\t\tWidgetMain.updateWidgets();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tif (localSong == null) {\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playbackcomplete\");\n\t\t\tstickyBroadcast.removeExtra(\"id\");\n\t\t\tstickyBroadcast.removeExtra(\"songid\");\n\t\t\tstickyBroadcast.removeExtra(\"track\");\n\t\t\tstickyBroadcast.removeExtra(\"artist\");\n\t\t\tstickyBroadcast.removeExtra(\"album\");\n\t\t\tstickyBroadcast.removeExtra(\"duration\");\n\t\t\n\t\t\tstickyBroadcast.removeExtra(\"playing\");\n\t\t} else {\n\t\t\n\t\t\n\t\t\tstickyBroadcast.setAction(\"com.android.music.playstatechanged\");\n\t\t\tstickyBroadcast.putExtra(\"id\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"songid\", localSong.id);\n\t\t\tstickyBroadcast.putExtra(\"track\", title);\n\t\t\tstickyBroadcast.putExtra(\"artist\", localSong.artist);\n\t\t\tstickyBroadcast.putExtra(\"album\", localSong.album);\n\t\t\tstickyBroadcast.putExtra(\"duration\", (long)localSong.lengthMS);\n\t\t\n\t\t\tstickyBroadcast.putExtra(\"playing\", localPlaying);\n\t\t}\n\t\n\t\n\t\ttry {\n\t\t\tif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)\n\t\t\t\tthePlayer.sendBroadcast(stickyBroadcast);\n\t\t\telse\n\t\t\t\tthePlayer.sendStickyBroadcast(stickyBroadcast);\n\t\t} catch (RuntimeException ex) {\n\t\t\n\t\t}\n\t\tif (remoteControlClient != null)\n\t\t\tbroadcastStateChangeToRemoteControl(title, preparing, titleOrSongHaveChanged);\n\t\tif (mediaSession != null)\n\t\t\tbroadcastStateChangeToMediaSession(title, preparing, titleOrSongHaveChanged);\n\t}","cleancode":"@suppresswarnings(\"deprecation\") private static void broadcaststatechange(string title, boolean preparing, boolean titleorsonghavechanged) { if (notificationbroadcastpending) { localhandler.removemessages(msg_broadcast_state_change); notificationbroadcastpending = false; } final long now = systemclock.uptimemillis(); final long delta = now - notificationlastupdatetime; if (delta < 100 || notificationlastupdatetime == 0) { notificationbroadcastpending = true; localhandler.sendmessageattime(message.obtain(localhandler, msg_broadcast_state_change, (preparing ? 0x01 : 0) | (titleorsonghavechanged ? 0x02 : 0), 0, title), (notificationlastupdatetime == 0 ? ((notificationlastupdatetime = now) + 2000) : (notificationlastupdatetime + 110 - delta))); return; } notificationlastupdatetime = now; refreshnotification(); widgetmain.updatewidgets(); if (localsong == null) { stickybroadcast.setaction(\"com.android.music.playbackcomplete\"); stickybroadcast.removeextra(\"id\"); stickybroadcast.removeextra(\"songid\"); stickybroadcast.removeextra(\"track\"); stickybroadcast.removeextra(\"artist\"); stickybroadcast.removeextra(\"album\"); stickybroadcast.removeextra(\"duration\"); stickybroadcast.removeextra(\"playing\"); } else { stickybroadcast.setaction(\"com.android.music.playstatechanged\"); stickybroadcast.putextra(\"id\", localsong.id); stickybroadcast.putextra(\"songid\", localsong.id); stickybroadcast.putextra(\"track\", title); stickybroadcast.putextra(\"artist\", localsong.artist); stickybroadcast.putextra(\"album\", localsong.album); stickybroadcast.putextra(\"duration\", (long)localsong.lengthms); stickybroadcast.putextra(\"playing\", localplaying); } try { if (build.version.sdk_int >= build.version_codes.lollipop) theplayer.sendbroadcast(stickybroadcast); else theplayer.sendstickybroadcast(stickybroadcast); } catch (runtimeexception ex) { } if (remotecontrolclient != null) broadcaststatechangetoremotecontrol(title, preparing, titleorsonghavechanged); if (mediasession != null) broadcaststatechangetomediasession(title, preparing, titleorsonghavechanged); }","repo":"carlosrafaelgn\/FPlayAndroid","label":[0,1,1,0]}
{"id":25223,"original_code":"public Node<N> join(Node<N> x, Node<N> y) {\n        \/\/ TODO this.majorants should return an iterator\n        SortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\n        xMajorants.add(x);\n        SortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\n        yMajorants.add(y);\n        xMajorants.retainAll(yMajorants);\n        DAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\n        TreeSet<Node> join = new TreeSet<Node>(graph.min());\n        if (join.size() == 1) {\n            return join.first();\n        }\n        return null;\n    }","code_wo_comment":"public Node<N> join(Node<N> x, Node<N> y) {\n       \n        SortedSet<Node<N>> xMajorants = new TreeSet<Node<N>>(this.majorants(x));\n        xMajorants.add(x);\n        SortedSet<Node<N>> yMajorants = new TreeSet<Node<N>>(this.majorants(y));\n        yMajorants.add(y);\n        xMajorants.retainAll(yMajorants);\n        DAGraph<N, E> graph = this.getSubgraphByNodes(xMajorants);\n        TreeSet<Node> join = new TreeSet<Node>(graph.min());\n        if (join.size() == 1) {\n            return join.first();\n        }\n        return null;\n    }","cleancode":"public node<n> join(node<n> x, node<n> y) { sortedset<node<n>> xmajorants = new treeset<node<n>>(this.majorants(x)); xmajorants.add(x); sortedset<node<n>> ymajorants = new treeset<node<n>>(this.majorants(y)); ymajorants.add(y); xmajorants.retainall(ymajorants); dagraph<n, e> graph = this.getsubgraphbynodes(xmajorants); treeset<node> join = new treeset<node>(graph.min()); if (join.size() == 1) { return join.first(); } return null; }","repo":"chdemko\/java-lattices","label":[1,0,0,0]}
{"id":8840,"original_code":"public static void resetData(BitbucketTestedProduct stash) {\n        YaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n                .loginAsSysAdmin(YaccRepoSettingsPage.class);\n        settingsPage.clickEditYacc()\n                .clearSettings();\n        settingsPage.clickSubmit();\n        settingsPage.clickDisable();\n        YaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\n        globalSettingsPage.clearSettings();\n        globalSettingsPage.clickSubmit();\n        stash.getTester().getDriver().manage().deleteAllCookies();\n    }","code_wo_comment":"public static void resetData(BitbucketTestedProduct stash) {\n        YaccRepoSettingsPage settingsPage = stash.visit(BitbucketLoginPage.class)\n                .loginAsSysAdmin(YaccRepoSettingsPage.class);\n        settingsPage.clickEditYacc()\n                .clearSettings();\n        settingsPage.clickSubmit();\n        settingsPage.clickDisable();\n        YaccGlobalSettingsPage globalSettingsPage = stash.visit(YaccGlobalSettingsPage.class);\n        globalSettingsPage.clearSettings();\n        globalSettingsPage.clickSubmit();\n        stash.getTester().getDriver().manage().deleteAllCookies();\n    }","cleancode":"public static void resetdata(bitbuckettestedproduct stash) { yaccreposettingspage settingspage = stash.visit(bitbucketloginpage.class) .loginassysadmin(yaccreposettingspage.class); settingspage.clickedityacc() .clearsettings(); settingspage.clicksubmit(); settingspage.clickdisable(); yaccglobalsettingspage globalsettingspage = stash.visit(yaccglobalsettingspage.class); globalsettingspage.clearsettings(); globalsettingspage.clicksubmit(); stash.gettester().getdriver().manage().deleteallcookies(); }","repo":"christiangalsterer\/yet-another-commit-checker","label":[1,0,0,0]}
{"id":17204,"original_code":"public void getDagInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    Map<String, Object> dagInfo = new HashMap<String, Object>();\n    dagInfo.put(\"id\", dag.getID().toString());\n    dagInfo.put(\"progress\", Float.toString(dag.getCompletedTaskProgress()));\n    dagInfo.put(\"status\", dag.getState().toString());\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = dag.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          dagInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n      \/\/ Ignore\n      \/\/ TODO: add an error message instead for counter key\n    }\n    renderJSON(ImmutableMap.of(\n        \"dag\", dagInfo\n    ));\n  }","code_wo_comment":"public void getDagInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    Map<String, Object> dagInfo = new HashMap<String, Object>();\n    dagInfo.put(\"id\", dag.getID().toString());\n    dagInfo.put(\"progress\", Float.toString(dag.getCompletedTaskProgress()));\n    dagInfo.put(\"status\", dag.getState().toString());\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = dag.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          dagInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n     \n     \n    }\n    renderJSON(ImmutableMap.of(\n        \"dag\", dagInfo\n    ));\n  }","cleancode":"public void getdaginfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); map<string, object> daginfo = new hashmap<string, object>(); daginfo.put(\"id\", dag.getid().tostring()); daginfo.put(\"progress\", float.tostring(dag.getcompletedtaskprogress())); daginfo.put(\"status\", dag.getstate().tostring()); try { if (counternames != null && !counternames.isempty()) { tezcounters counters = dag.getcachedcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { daginfo.put(\"counters\", countermap); } } } catch (limitexceededexception e) { } renderjson(immutablemap.of( \"dag\", daginfo )); }","repo":"chenjunbiao001\/tez","label":[0,1,0,0]}
{"id":17205,"original_code":"private Map<String, Object> getVertexInfoMap(Vertex vertex,\n                                               Map<String, Set<String>> counterNames) {\n    Map<String, Object> vertexInfo = new HashMap<String, Object>();\n    vertexInfo.put(\"id\", vertex.getVertexId().toString());\n    vertexInfo.put(\"status\", vertex.getState().toString());\n    vertexInfo.put(\"progress\", Float.toString(vertex.getCompletedTaskProgress()));\n    vertexInfo.put(\"initTime\", Long.toString(vertex.getInitTime()));\n    vertexInfo.put(\"startTime\", Long.toString(vertex.getStartTime()));\n    vertexInfo.put(\"finishTime\", Long.toString(vertex.getFinishTime()));\n    vertexInfo.put(\"firstTaskStartTime\", Long.toString(vertex.getFirstTaskStartTime()));\n    vertexInfo.put(\"lastTaskFinishTime\", Long.toString(vertex.getLastTaskFinishTime()));\n    ProgressBuilder vertexProgress = vertex.getVertexProgress();\n    vertexInfo.put(\"totalTasks\", Integer.toString(vertexProgress.getTotalTaskCount()));\n    vertexInfo.put(\"runningTasks\", Integer.toString(vertexProgress.getRunningTaskCount()));\n    vertexInfo.put(\"succeededTasks\", Integer.toString(vertexProgress.getSucceededTaskCount()));\n    vertexInfo.put(\"failedTaskAttempts\",\n        Integer.toString(vertexProgress.getFailedTaskAttemptCount()));\n    vertexInfo.put(\"killedTaskAttempts\",\n        Integer.toString(vertexProgress.getKilledTaskAttemptCount()));\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = vertex.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          vertexInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n      \/\/ Ignore\n      \/\/ TODO: add an error message instead for counter key\n    }\n    return vertexInfo;\n  }","code_wo_comment":"private Map<String, Object> getVertexInfoMap(Vertex vertex,\n                                               Map<String, Set<String>> counterNames) {\n    Map<String, Object> vertexInfo = new HashMap<String, Object>();\n    vertexInfo.put(\"id\", vertex.getVertexId().toString());\n    vertexInfo.put(\"status\", vertex.getState().toString());\n    vertexInfo.put(\"progress\", Float.toString(vertex.getCompletedTaskProgress()));\n    vertexInfo.put(\"initTime\", Long.toString(vertex.getInitTime()));\n    vertexInfo.put(\"startTime\", Long.toString(vertex.getStartTime()));\n    vertexInfo.put(\"finishTime\", Long.toString(vertex.getFinishTime()));\n    vertexInfo.put(\"firstTaskStartTime\", Long.toString(vertex.getFirstTaskStartTime()));\n    vertexInfo.put(\"lastTaskFinishTime\", Long.toString(vertex.getLastTaskFinishTime()));\n    ProgressBuilder vertexProgress = vertex.getVertexProgress();\n    vertexInfo.put(\"totalTasks\", Integer.toString(vertexProgress.getTotalTaskCount()));\n    vertexInfo.put(\"runningTasks\", Integer.toString(vertexProgress.getRunningTaskCount()));\n    vertexInfo.put(\"succeededTasks\", Integer.toString(vertexProgress.getSucceededTaskCount()));\n    vertexInfo.put(\"failedTaskAttempts\",\n        Integer.toString(vertexProgress.getFailedTaskAttemptCount()));\n    vertexInfo.put(\"killedTaskAttempts\",\n        Integer.toString(vertexProgress.getKilledTaskAttemptCount()));\n    try {\n      if (counterNames != null && !counterNames.isEmpty()) {\n        TezCounters counters = vertex.getCachedCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          vertexInfo.put(\"counters\", counterMap);\n        }\n      }\n    } catch (LimitExceededException e) {\n     \n     \n    }\n    return vertexInfo;\n  }","cleancode":"private map<string, object> getvertexinfomap(vertex vertex, map<string, set<string>> counternames) { map<string, object> vertexinfo = new hashmap<string, object>(); vertexinfo.put(\"id\", vertex.getvertexid().tostring()); vertexinfo.put(\"status\", vertex.getstate().tostring()); vertexinfo.put(\"progress\", float.tostring(vertex.getcompletedtaskprogress())); vertexinfo.put(\"inittime\", long.tostring(vertex.getinittime())); vertexinfo.put(\"starttime\", long.tostring(vertex.getstarttime())); vertexinfo.put(\"finishtime\", long.tostring(vertex.getfinishtime())); vertexinfo.put(\"firsttaskstarttime\", long.tostring(vertex.getfirsttaskstarttime())); vertexinfo.put(\"lasttaskfinishtime\", long.tostring(vertex.getlasttaskfinishtime())); progressbuilder vertexprogress = vertex.getvertexprogress(); vertexinfo.put(\"totaltasks\", integer.tostring(vertexprogress.gettotaltaskcount())); vertexinfo.put(\"runningtasks\", integer.tostring(vertexprogress.getrunningtaskcount())); vertexinfo.put(\"succeededtasks\", integer.tostring(vertexprogress.getsucceededtaskcount())); vertexinfo.put(\"failedtaskattempts\", integer.tostring(vertexprogress.getfailedtaskattemptcount())); vertexinfo.put(\"killedtaskattempts\", integer.tostring(vertexprogress.getkilledtaskattemptcount())); try { if (counternames != null && !counternames.isempty()) { tezcounters counters = vertex.getcachedcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { vertexinfo.put(\"counters\", countermap); } } } catch (limitexceededexception e) { } return vertexinfo; }","repo":"chenjunbiao001\/tez","label":[0,1,0,0]}
{"id":17206,"original_code":"public void getTasksInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n      \/\/Ignore\n    }\n    List<Task> tasks = getRequestedTasks(dag, limit);\n    if(tasks == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\n    for(Task t : tasks) {\n      Map<String, Object> taskInfo = new HashMap<String, Object>();\n      taskInfo.put(\"id\", t.getTaskId().toString());\n      taskInfo.put(\"progress\", Float.toString(t.getProgress()));\n      taskInfo.put(\"status\", t.getState().toString());\n      try {\n        TezCounters counters = t.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          taskInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n        \/\/ Ignore\n        \/\/ TODO: add an error message instead for counter key\n      }\n      tasksInfo.add(taskInfo);\n    }\n    renderJSON(ImmutableMap.of(\n      \"tasks\", tasksInfo\n    ));\n  }","code_wo_comment":"public void getTasksInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n     \n    }\n    List<Task> tasks = getRequestedTasks(dag, limit);\n    if(tasks == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> tasksInfo = new ArrayList<Map<String, Object>>();\n    for(Task t : tasks) {\n      Map<String, Object> taskInfo = new HashMap<String, Object>();\n      taskInfo.put(\"id\", t.getTaskId().toString());\n      taskInfo.put(\"progress\", Float.toString(t.getProgress()));\n      taskInfo.put(\"status\", t.getState().toString());\n      try {\n        TezCounters counters = t.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          taskInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n       \n       \n      }\n      tasksInfo.add(taskInfo);\n    }\n    renderJSON(ImmutableMap.of(\n      \"tasks\", tasksInfo\n    ));\n  }","cleancode":"public void gettasksinfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } int limit = max_queried; try { limit = getqueryparamint(webuiservice.limit); } catch (numberformatexception e) { } list<task> tasks = getrequestedtasks(dag, limit); if(tasks == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); arraylist<map<string, object>> tasksinfo = new arraylist<map<string, object>>(); for(task t : tasks) { map<string, object> taskinfo = new hashmap<string, object>(); taskinfo.put(\"id\", t.gettaskid().tostring()); taskinfo.put(\"progress\", float.tostring(t.getprogress())); taskinfo.put(\"status\", t.getstate().tostring()); try { tezcounters counters = t.getcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { taskinfo.put(\"counters\", countermap); } } catch (limitexceededexception e) { } tasksinfo.add(taskinfo); } renderjson(immutablemap.of( \"tasks\", tasksinfo )); }","repo":"chenjunbiao001\/tez","label":[0,1,0,0]}
{"id":17207,"original_code":"public void getAttemptsInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n      \/\/Ignore\n    }\n    List<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\n    if(attempts == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\n    for(TaskAttempt a : attempts) {\n      Map<String, Object> attemptInfo = new HashMap<String, Object>();\n      attemptInfo.put(\"id\", a.getID().toString());\n      attemptInfo.put(\"progress\", Float.toString(a.getProgress()));\n      attemptInfo.put(\"status\", a.getState().toString());\n      try {\n        TezCounters counters = a.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          attemptInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n        \/\/ Ignore\n        \/\/ TODO: add an error message instead for counter key\n      }\n      attemptsInfo.add(attemptInfo);\n    }\n    renderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n  }","code_wo_comment":"public void getAttemptsInfo() {\n    if (!setupResponse()) {\n      return;\n    }\n    DAG dag = checkAndGetDAGFromRequest();\n    if (dag == null) {\n      return;\n    }\n    int limit = MAX_QUERIED;\n    try {\n      limit = getQueryParamInt(WebUIService.LIMIT);\n    } catch (NumberFormatException e) {\n     \n    }\n    List<TaskAttempt> attempts = getRequestedAttempts(dag, limit);\n    if(attempts == null) {\n      return;\n    }\n    Map<String, Set<String>> counterNames = getCounterListFromRequest();\n    ArrayList<Map<String, Object>> attemptsInfo = new ArrayList<Map<String, Object>>();\n    for(TaskAttempt a : attempts) {\n      Map<String, Object> attemptInfo = new HashMap<String, Object>();\n      attemptInfo.put(\"id\", a.getID().toString());\n      attemptInfo.put(\"progress\", Float.toString(a.getProgress()));\n      attemptInfo.put(\"status\", a.getState().toString());\n      try {\n        TezCounters counters = a.getCounters();\n        Map<String, Map<String, Long>> counterMap = constructCounterMapInfo(counters, counterNames);\n        if (counterMap != null && !counterMap.isEmpty()) {\n          attemptInfo.put(\"counters\", counterMap);\n        }\n      } catch (LimitExceededException e) {\n       \n       \n      }\n      attemptsInfo.add(attemptInfo);\n    }\n    renderJSON(ImmutableMap.of(\"attempts\", attemptsInfo));\n  }","cleancode":"public void getattemptsinfo() { if (!setupresponse()) { return; } dag dag = checkandgetdagfromrequest(); if (dag == null) { return; } int limit = max_queried; try { limit = getqueryparamint(webuiservice.limit); } catch (numberformatexception e) { } list<taskattempt> attempts = getrequestedattempts(dag, limit); if(attempts == null) { return; } map<string, set<string>> counternames = getcounterlistfromrequest(); arraylist<map<string, object>> attemptsinfo = new arraylist<map<string, object>>(); for(taskattempt a : attempts) { map<string, object> attemptinfo = new hashmap<string, object>(); attemptinfo.put(\"id\", a.getid().tostring()); attemptinfo.put(\"progress\", float.tostring(a.getprogress())); attemptinfo.put(\"status\", a.getstate().tostring()); try { tezcounters counters = a.getcounters(); map<string, map<string, long>> countermap = constructcountermapinfo(counters, counternames); if (countermap != null && !countermap.isempty()) { attemptinfo.put(\"counters\", countermap); } } catch (limitexceededexception e) { } attemptsinfo.add(attemptinfo); } renderjson(immutablemap.of(\"attempts\", attemptsinfo)); }","repo":"chenjunbiao001\/tez","label":[0,1,0,0]}
{"id":824,"original_code":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\n\t\t\tthrows DIDResolveException {\n\t\tlog.debug(\"Resolving untrusted DID {}...\", did.toString());\n\t\tif (resolveHandle != null) {\n\t\t\tDIDDocument doc = resolveHandle.resolve(did);\n\t\t\tif (doc != null)\n\t\t\t\treturn doc;\n\t\t}\n\t\tDIDBiography bio = resolveDidBiography(did, false, force);\n\t\tDIDTransaction tx = null;\n\t\tswitch (bio.getStatus()) {\n\t\tcase VALID:\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tbreak;\n\t\tcase DEACTIVATED:\n\t\t\tif (bio.size() != 2)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\n\t\t\tDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\n\t\t\tif (doc == null)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\n\t\t\ttx = bio.getTransaction(1);\n\t\t\tbreak;\n\t\tcase NOT_FOUND:\n\t\t\treturn null;\n\t\t}\n\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\n\t\t\tthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\t\t\/\/ NOTICE: Make a copy from DIDBackend cache.\n\t\t\/\/ \t\t   Avoid share same DIDDocument instance between DIDBackend\n\t\t\/\/         cache and DIDStore cache.\n\t\tDIDDocument doc = tx.getRequest().getDocument().clone();\n\t\tDIDMetadata metadata = doc.getMetadata();\n\t\tmetadata.setTransactionId(tx.getTransactionId());\n\t\tmetadata.setSignature(doc.getProof().getSignature());\n\t\tmetadata.setPublishTime(tx.getTimestamp());\n\t\tif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\n\t\t\tmetadata.setDeactivated(true);\n\t\treturn doc;\n\t}","code_wo_comment":"public DIDDocument resolveUntrustedDid(DID did, boolean force)\n\t\t\tthrows DIDResolveException {\n\t\tlog.debug(\"Resolving untrusted DID {}...\", did.toString());\n\t\tif (resolveHandle != null) {\n\t\t\tDIDDocument doc = resolveHandle.resolve(did);\n\t\t\tif (doc != null)\n\t\t\t\treturn doc;\n\t\t}\n\t\tDIDBiography bio = resolveDidBiography(did, false, force);\n\t\tDIDTransaction tx = null;\n\t\tswitch (bio.getStatus()) {\n\t\tcase VALID:\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tbreak;\n\t\tcase DEACTIVATED:\n\t\t\tif (bio.size() != 2)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong transaction count.\");\n\t\t\ttx = bio.getTransaction(0);\n\t\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.DEACTIVATE)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, wrong status.\");\n\t\t\tDIDDocument doc = bio.getTransaction(1).getRequest().getDocument();\n\t\t\tif (doc == null)\n\t\t\t\tthrow new DIDResolveException(\"Invalid DID biography, invalid trancations.\");\n\t\t\ttx = bio.getTransaction(1);\n\t\t\tbreak;\n\t\tcase NOT_FOUND:\n\t\t\treturn null;\n\t\t}\n\t\tif (tx.getRequest().getOperation() != IDChainRequest.Operation.CREATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.UPDATE &&\n\t\t\t\ttx.getRequest().getOperation() != IDChainRequest.Operation.TRANSFER)\n\t\t\tthrow new DIDResolveException(\"Invalid ID transaction, unknown operation.\");\n\t\n\t\n\t\n\t\tDIDDocument doc = tx.getRequest().getDocument().clone();\n\t\tDIDMetadata metadata = doc.getMetadata();\n\t\tmetadata.setTransactionId(tx.getTransactionId());\n\t\tmetadata.setSignature(doc.getProof().getSignature());\n\t\tmetadata.setPublishTime(tx.getTimestamp());\n\t\tif (bio.getStatus() == DIDBiography.Status.DEACTIVATED)\n\t\t\tmetadata.setDeactivated(true);\n\t\treturn doc;\n\t}","cleancode":"public diddocument resolveuntrusteddid(did did, boolean force) throws didresolveexception { log.debug(\"resolving untrusted did {}...\", did.tostring()); if (resolvehandle != null) { diddocument doc = resolvehandle.resolve(did); if (doc != null) return doc; } didbiography bio = resolvedidbiography(did, false, force); didtransaction tx = null; switch (bio.getstatus()) { case valid: tx = bio.gettransaction(0); break; case deactivated: if (bio.size() != 2) throw new didresolveexception(\"invalid did biography, wrong transaction count.\"); tx = bio.gettransaction(0); if (tx.getrequest().getoperation() != idchainrequest.operation.deactivate) throw new didresolveexception(\"invalid did biography, wrong status.\"); diddocument doc = bio.gettransaction(1).getrequest().getdocument(); if (doc == null) throw new didresolveexception(\"invalid did biography, invalid trancations.\"); tx = bio.gettransaction(1); break; case not_found: return null; } if (tx.getrequest().getoperation() != idchainrequest.operation.create && tx.getrequest().getoperation() != idchainrequest.operation.update && tx.getrequest().getoperation() != idchainrequest.operation.transfer) throw new didresolveexception(\"invalid id transaction, unknown operation.\"); diddocument doc = tx.getrequest().getdocument().clone(); didmetadata metadata = doc.getmetadata(); metadata.settransactionid(tx.gettransactionid()); metadata.setsignature(doc.getproof().getsignature()); metadata.setpublishtime(tx.gettimestamp()); if (bio.getstatus() == didbiography.status.deactivated) metadata.setdeactivated(true); return doc; }","repo":"chenyukaola\/Elastos.DID.Java.SDK","label":[1,0,0,0]}
{"id":1011,"original_code":"@Override\n    protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\n      ImmutableList.Builder<String> builder = ImmutableList.builder();\n      builder.addAll(commandPrefix);\n      builder.add(\"compile\");\n      builder.add(\"--legacy\"); \/\/ TODO(dreiss): Maybe make this an option?\n      builder.add(\"-o\");\n      builder.add(outputPath.toString());\n      builder.add(\"--dir\");\n      builder.add(resDirPath.toString());\n      return builder.build();\n    }","code_wo_comment":"@Override\n    protected ImmutableList<String> getShellCommandInternal(ExecutionContext context) {\n      ImmutableList.Builder<String> builder = ImmutableList.builder();\n      builder.addAll(commandPrefix);\n      builder.add(\"compile\");\n      builder.add(\"--legacy\");\n      builder.add(\"-o\");\n      builder.add(outputPath.toString());\n      builder.add(\"--dir\");\n      builder.add(resDirPath.toString());\n      return builder.build();\n    }","cleancode":"@override protected immutablelist<string> getshellcommandinternal(executioncontext context) { immutablelist.builder<string> builder = immutablelist.builder(); builder.addall(commandprefix); builder.add(\"compile\"); builder.add(\"--legacy\"); builder.add(\"-o\"); builder.add(outputpath.tostring()); builder.add(\"--dir\"); builder.add(resdirpath.tostring()); return builder.build(); }","repo":"chancila\/buck","label":[1,0,0,0]}
{"id":25614,"original_code":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\n    checkState(\n        stageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\n    checkState(\n        stateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\n    OutputReceiverFactory receiverFactory =\n        new OutputReceiverFactory() {\n          @Override\n          public FnDataReceiver<OutputT> create(String pCollectionId) {\n            return (receivedElement) -> {\n              \/\/ handover to queue, do not block the grpc thread\n              outputQueue.put(KV.of(pCollectionId, receivedElement));\n            };\n          }\n        };\n    try (RemoteBundle bundle =\n        stageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\n      logger.debug(String.format(\"Sending value: %s\", element));\n      \/\/ TODO(BEAM-4681): Add support to Flink to support portable timers.\n      Iterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n      \/\/ TODO: it would be nice to emit results as they arrive, can thread wait non-blocking?\n    }\n    \/\/ RemoteBundle close blocks until all results are received\n    KV<String, OutputT> result;\n    while ((result = outputQueue.poll()) != null) {\n      outputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n    }\n  }","code_wo_comment":"private void processElementWithSdkHarness(WindowedValue<InputT> element) throws Exception {\n    checkState(\n        stageBundleFactory != null, \"%s not yet prepared\", StageBundleFactory.class.getName());\n    checkState(\n        stateRequestHandler != null, \"%s not yet prepared\", StateRequestHandler.class.getName());\n    OutputReceiverFactory receiverFactory =\n        new OutputReceiverFactory() {\n          @Override\n          public FnDataReceiver<OutputT> create(String pCollectionId) {\n            return (receivedElement) -> {\n             \n              outputQueue.put(KV.of(pCollectionId, receivedElement));\n            };\n          }\n        };\n    try (RemoteBundle bundle =\n        stageBundleFactory.getBundle(receiverFactory, stateRequestHandler, progressHandler)) {\n      logger.debug(String.format(\"Sending value: %s\", element));\n     \n      Iterables.getOnlyElement(bundle.getInputReceivers().values()).accept(element);\n     \n    }\n   \n    KV<String, OutputT> result;\n    while ((result = outputQueue.poll()) != null) {\n      outputManager.output(outputMap.get(result.getKey()), (WindowedValue) result.getValue());\n    }\n  }","cleancode":"private void processelementwithsdkharness(windowedvalue<inputt> element) throws exception { checkstate( stagebundlefactory != null, \"%s not yet prepared\", stagebundlefactory.class.getname()); checkstate( staterequesthandler != null, \"%s not yet prepared\", staterequesthandler.class.getname()); outputreceiverfactory receiverfactory = new outputreceiverfactory() { @override public fndatareceiver<outputt> create(string pcollectionid) { return (receivedelement) -> { outputqueue.put(kv.of(pcollectionid, receivedelement)); }; } }; try (remotebundle bundle = stagebundlefactory.getbundle(receiverfactory, staterequesthandler, progresshandler)) { logger.debug(string.format(\"sending value: %s\", element)); iterables.getonlyelement(bundle.getinputreceivers().values()).accept(element); } kv<string, outputt> result; while ((result = outputqueue.poll()) != null) { outputmanager.output(outputmap.get(result.getkey()), (windowedvalue) result.getvalue()); } }","repo":"chinasaur\/beam","label":[1,1,0,0]}
{"id":9325,"original_code":"public static AuthorizationHandler getAuthZHandler() {\n        return (AuthenticationData authN) -> {\n            try {\n                \/\/framework checks for null authN so this shouldn't happen\n                if (authN == null) {\n                    throw new RuntimeException(\"Null AuthN data passed in!\");\n                }\n                \/\/check if the authN data type matches is a good idea, and necessary if there are other fields\n                \/\/to open\/inspect\n                if (authN instanceof ClientNameAuthenicationData) {\n                    final ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n                    \/\/WARNING!!! this logic is for demonstration purposes\n                    final String identityLabel = data.getIdentityLabel();\n                    return identityLabel.startsWith(\"accepted.\") ?\n                            Authorization.ACCEPT : Authorization.REJECT;\n                }\n                \/\/good idea to log reasons for rejection with the authentication label so testers\/users can understand\n                System.err.println(\"AuthN data type is not expected object type!\");\n                return Authorization.REJECT;\n            } catch (Exception e) {\n                return Authorization.REJECT;\n            }\n        };\n    }","code_wo_comment":"public static AuthorizationHandler getAuthZHandler() {\n        return (AuthenticationData authN) -> {\n            try {\n               \n                if (authN == null) {\n                    throw new RuntimeException(\"Null AuthN data passed in!\");\n                }\n               \n               \n                if (authN instanceof ClientNameAuthenicationData) {\n                    final ClientNameAuthenicationData data = (ClientNameAuthenicationData) authN;\n                   \n                    final String identityLabel = data.getIdentityLabel();\n                    return identityLabel.startsWith(\"accepted.\") ?\n                            Authorization.ACCEPT : Authorization.REJECT;\n                }\n               \n                System.err.println(\"AuthN data type is not expected object type!\");\n                return Authorization.REJECT;\n            } catch (Exception e) {\n                return Authorization.REJECT;\n            }\n        };\n    }","cleancode":"public static authorizationhandler getauthzhandler() { return (authenticationdata authn) -> { try { if (authn == null) { throw new runtimeexception(\"null authn data passed in!\"); } if (authn instanceof clientnameauthenicationdata) { final clientnameauthenicationdata data = (clientnameauthenicationdata) authn; final string identitylabel = data.getidentitylabel(); return identitylabel.startswith(\"accepted.\") ? authorization.accept : authorization.reject; } system.err.println(\"authn data type is not expected object type!\"); return authorization.reject; } catch (exception e) { return authorization.reject; } }; }","repo":"bgklika\/aws-iot-device-sdk-java-v2","label":[1,0,0,0]}
{"id":17543,"original_code":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n        \/\/ Don't register read-only classes\n        if (isClassReadOnly(object.getClass(), descriptor)) {\n            return null;\n        }\n        \/\/ Check if the working copy is again being registered in which case we return the same working copy\n        Object registeredObject = getCloneMapping().get(object);\n        if (registeredObject != null) {\n            return object;\n        }\n        \/\/ Check if object exists in my new objects if it is in the new objects cache then it means domain object is being \n        \/\/ re-registered and we should return the same working clone. This check holds only for the new registered objects \n        \/\/ PERF: Avoid initialization of new objects if none.\n        if (hasNewObjects()) {\n            registeredObject = getNewObjectsOriginalToClone().get(object);\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        if (this.isNestedUnitOfWork) {\n            \/\/ bug # 3228185\n            \/\/may be a new object from a parent Unit Of Work, let's check our new object in parent list to see\n            \/\/if it has already been registered locally\n            if (hasNewObjectsInParentOriginalToClone()) {\n                registeredObject = getNewObjectsInParentOriginalToClone().get(object);\n            }\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        return null;\n    }","code_wo_comment":"public Object checkIfAlreadyRegistered(Object object, ClassDescriptor descriptor) {\n       \n        if (isClassReadOnly(object.getClass(), descriptor)) {\n            return null;\n        }\n       \n        Object registeredObject = getCloneMapping().get(object);\n        if (registeredObject != null) {\n            return object;\n        }\n       \n       \n       \n        if (hasNewObjects()) {\n            registeredObject = getNewObjectsOriginalToClone().get(object);\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        if (this.isNestedUnitOfWork) {\n           \n           \n           \n            if (hasNewObjectsInParentOriginalToClone()) {\n                registeredObject = getNewObjectsInParentOriginalToClone().get(object);\n            }\n            if (registeredObject != null) {\n                return registeredObject;\n            }\n        }\n        return null;\n    }","cleancode":"public object checkifalreadyregistered(object object, classdescriptor descriptor) { if (isclassreadonly(object.getclass(), descriptor)) { return null; } object registeredobject = getclonemapping().get(object); if (registeredobject != null) { return object; } if (hasnewobjects()) { registeredobject = getnewobjectsoriginaltoclone().get(object); if (registeredobject != null) { return registeredobject; } } if (this.isnestedunitofwork) { if (hasnewobjectsinparentoriginaltoclone()) { registeredobject = getnewobjectsinparentoriginaltoclone().get(object); } if (registeredobject != null) { return registeredobject; } } return null; }","repo":"chenjiafan\/eclipselink","label":[0,0,1,0]}
{"id":17549,"original_code":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\n        if (toBeDeleted == null) {\n            return;\n        }\n        ClassDescriptor descriptor = getDescriptor(toBeDeleted);\n        if ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\n            throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n        }\n        logDebugMessage(toBeDeleted, \"deleting_object\");\n        \/\/bug 4568370+4599010; fix EntityManager.remove() to handle new objects\n        if (getDeletedObjects().containsKey(toBeDeleted)){\n          return;\n        }\n        visitedObjects.put(toBeDeleted,toBeDeleted);\n        Object registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\n        if (registeredObject == null) {\n            Object primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\n            DoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\n            existQuery = (DoesExistQuery)existQuery.clone();\n            existQuery.setObject(toBeDeleted);\n            existQuery.setPrimaryKey(primaryKey);\n            existQuery.setDescriptor(descriptor);\n            existQuery.setIsExecutionClone(true);\n            existQuery.setCheckCacheFirst(true);\n            if (((Boolean)executeQuery(existQuery)).booleanValue()){\n                throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n            }\/\/else, it is a new or previously deleted object that should be ignored (and delete should cascade)\n        } else {\n            \/\/fire events only if this is a managed object\n            if (descriptor.getEventManager().hasAnyEventListeners()) {\n                org.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\n                event.setEventCode(DescriptorEventManager.PreRemoveEvent);\n                event.setSession(this);\n                descriptor.getEventManager().executeEvent(event);\n            }\n            if (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\n                unregisterObject(registeredObject, DescriptorIterator.NoCascading);\n            } else {\n                getDeletedObjects().put(toBeDeleted, toBeDeleted);\n            }\n        }\n        descriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n    }","code_wo_comment":"public void performRemove(Object toBeDeleted, Map visitedObjects) {\n        if (toBeDeleted == null) {\n            return;\n        }\n        ClassDescriptor descriptor = getDescriptor(toBeDeleted);\n        if ((descriptor == null) || descriptor.isDescriptorTypeAggregate()) {\n            throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"not_an_entity\", new Object[] { toBeDeleted }));\n        }\n        logDebugMessage(toBeDeleted, \"deleting_object\");\n       \n        if (getDeletedObjects().containsKey(toBeDeleted)){\n          return;\n        }\n        visitedObjects.put(toBeDeleted,toBeDeleted);\n        Object registeredObject = checkIfAlreadyRegistered(toBeDeleted, descriptor);\n        if (registeredObject == null) {\n            Object primaryKey = descriptor.getObjectBuilder().extractPrimaryKeyFromObject(toBeDeleted, this);\n            DoesExistQuery existQuery = descriptor.getQueryManager().getDoesExistQuery();\n            existQuery = (DoesExistQuery)existQuery.clone();\n            existQuery.setObject(toBeDeleted);\n            existQuery.setPrimaryKey(primaryKey);\n            existQuery.setDescriptor(descriptor);\n            existQuery.setIsExecutionClone(true);\n            existQuery.setCheckCacheFirst(true);\n            if (((Boolean)executeQuery(existQuery)).booleanValue()){\n                throw new IllegalArgumentException(ExceptionLocalization.buildMessage(\"cannot_remove_detatched_entity\", new Object[]{toBeDeleted}));\n            \n        } else {\n           \n            if (descriptor.getEventManager().hasAnyEventListeners()) {\n                org.eclipse.persistence.descriptors.DescriptorEvent event = new org.eclipse.persistence.descriptors.DescriptorEvent(toBeDeleted);\n                event.setEventCode(DescriptorEventManager.PreRemoveEvent);\n                event.setSession(this);\n                descriptor.getEventManager().executeEvent(event);\n            }\n            if (hasNewObjects() && getNewObjectsCloneToOriginal().containsKey(registeredObject)){\n                unregisterObject(registeredObject, DescriptorIterator.NoCascading);\n            } else {\n                getDeletedObjects().put(toBeDeleted, toBeDeleted);\n            }\n        }\n        descriptor.getObjectBuilder().cascadePerformRemove(toBeDeleted, this, visitedObjects);\n    }","cleancode":"public void performremove(object tobedeleted, map visitedobjects) { if (tobedeleted == null) { return; } classdescriptor descriptor = getdescriptor(tobedeleted); if ((descriptor == null) || descriptor.isdescriptortypeaggregate()) { throw new illegalargumentexception(exceptionlocalization.buildmessage(\"not_an_entity\", new object[] { tobedeleted })); } logdebugmessage(tobedeleted, \"deleting_object\"); if (getdeletedobjects().containskey(tobedeleted)){ return; } visitedobjects.put(tobedeleted,tobedeleted); object registeredobject = checkifalreadyregistered(tobedeleted, descriptor); if (registeredobject == null) { object primarykey = descriptor.getobjectbuilder().extractprimarykeyfromobject(tobedeleted, this); doesexistquery existquery = descriptor.getquerymanager().getdoesexistquery(); existquery = (doesexistquery)existquery.clone(); existquery.setobject(tobedeleted); existquery.setprimarykey(primarykey); existquery.setdescriptor(descriptor); existquery.setisexecutionclone(true); existquery.setcheckcachefirst(true); if (((boolean)executequery(existquery)).booleanvalue()){ throw new illegalargumentexception(exceptionlocalization.buildmessage(\"cannot_remove_detatched_entity\", new object[]{tobedeleted})); } else { if (descriptor.geteventmanager().hasanyeventlisteners()) { org.eclipse.persistence.descriptors.descriptorevent event = new org.eclipse.persistence.descriptors.descriptorevent(tobedeleted); event.seteventcode(descriptoreventmanager.preremoveevent); event.setsession(this); descriptor.geteventmanager().executeevent(event); } if (hasnewobjects() && getnewobjectsclonetooriginal().containskey(registeredobject)){ unregisterobject(registeredobject, descriptoriterator.nocascading); } else { getdeletedobjects().put(tobedeleted, tobedeleted); } } descriptor.getobjectbuilder().cascadeperformremove(tobedeleted, this, visitedobjects); }","repo":"chenjiafan\/eclipselink","label":[0,0,1,0]}
{"id":17557,"original_code":"protected Map cloneMap(Map map){\n        \/\/ bug 270413.  This method is needed to avoid the class cast exception when the reference mode is weak.\n    \tif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\n        return (IdentityHashMap)((IdentityHashMap)map).clone();\n    }","code_wo_comment":"protected Map cloneMap(Map map){\n       \n    \tif (this.referenceMode != null && this.referenceMode != ReferenceMode.HARD) return (IdentityWeakHashMap)((IdentityWeakHashMap)map).clone();\n        return (IdentityHashMap)((IdentityHashMap)map).clone();\n    }","cleancode":"protected map clonemap(map map){ if (this.referencemode != null && this.referencemode != referencemode.hard) return (identityweakhashmap)((identityweakhashmap)map).clone(); return (identityhashmap)((identityhashmap)map).clone(); }","repo":"chenjiafan\/eclipselink","label":[0,0,1,0]}
{"id":1232,"original_code":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\t\t\/\/ Note that instances are not referenced by any other model entity, so\n\t\t\/\/ they can be safely deleted here\n\t\t\/\/ without leaving any references in place.\n\t\t\/\/ If there are textual references to the instance (i.e. in a property\n\t\t\/\/ that refers to it by name) then\n\t\t\/\/ these references must be manually cleaned up separately by the code\n\t\t\/\/ that calls this method.\n\t\t\/\/ First remove the instances individually from the list of all\n\t\t\/\/ instances\n\t\tArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\n\t\tfor (CeInstance thisInst : allInsts) {\n\t\t\tdeleteInstanceNoRefs(thisInst);\n\t\t}\n\t\t\/\/ Then remove all of the instances for the specified concept from the\n\t\t\/\/ other list\n\t\tthis.instancesByConcept.remove(pConcept);\n\t\t\/\/ Then remove the unused sentences and sources that may be left as a\n\t\t\/\/ result\n\t\tpAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n\t}","code_wo_comment":"protected void deleteAllInstancesForConcept(ActionContext pAc, CeConcept pConcept) {\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tArrayList<CeInstance> allInsts = getAllInstancesForConcept(pConcept);\n\t\tfor (CeInstance thisInst : allInsts) {\n\t\t\tdeleteInstanceNoRefs(thisInst);\n\t\t}\n\t\n\t\n\t\tthis.instancesByConcept.remove(pConcept);\n\t\n\t\n\t\tpAc.getModelBuilder().removeUnusedSentencesAndSources(pAc);\n\t}","cleancode":"protected void deleteallinstancesforconcept(actioncontext pac, ceconcept pconcept) { arraylist<ceinstance> allinsts = getallinstancesforconcept(pconcept); for (ceinstance thisinst : allinsts) { deleteinstancenorefs(thisinst); } this.instancesbyconcept.remove(pconcept); pac.getmodelbuilder().removeunusedsentencesandsources(pac); }","repo":"ce-store\/ce-store","label":[0,1,0,0]}
{"id":25901,"original_code":"@Test\n    public void testGetVotesForInstance() {\n        System.out.println(\"getVotesForInstance\");\n        FeS2 classifier = new FeS2();\n        Instance x = trainingSet.instance(0);\n        classifier.subspaceStrategyOption.setChosenIndex(0);\n        classifier.distanceStrategyOption.setChosenIndex(2);\n        classifier.initialClusterWeightOption.setValue(0.1);\n        classifier.learningRateAlphaOption.setValue(0.95);\n        classifier.minimumClusterSizeOption.setValue(3);\n        classifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n       \/\/ classifier.pruneThresholdOption.setValue(0.00001);\n        classifier.updateStrategyOption.setChosenIndex(1);\n        classifier.trainOnInstance(trainingSet.instance(0));\n        double[] result = classifier.getVotesForInstance(x);\n        int h = (int) result[weka.core.Utils.maxIndex(result)];\n        int y = 1;\n        assertEquals(y,h);\n        \/\/ TODO - add fuller set\n    }","code_wo_comment":"@Test\n    public void testGetVotesForInstance() {\n        System.out.println(\"getVotesForInstance\");\n        FeS2 classifier = new FeS2();\n        Instance x = trainingSet.instance(0);\n        classifier.subspaceStrategyOption.setChosenIndex(0);\n        classifier.distanceStrategyOption.setChosenIndex(2);\n        classifier.initialClusterWeightOption.setValue(0.1);\n        classifier.learningRateAlphaOption.setValue(0.95);\n        classifier.minimumClusterSizeOption.setValue(3);\n        classifier.outlierDefinitionStrategyOption.setChosenIndex(0);\n      \n        classifier.updateStrategyOption.setChosenIndex(1);\n        classifier.trainOnInstance(trainingSet.instance(0));\n        double[] result = classifier.getVotesForInstance(x);\n        int h = (int) result[weka.core.Utils.maxIndex(result)];\n        int y = 1;\n        assertEquals(y,h);\n       \n    }","cleancode":"@test public void testgetvotesforinstance() { system.out.println(\"getvotesforinstance\"); fes2 classifier = new fes2(); instance x = trainingset.instance(0); classifier.subspacestrategyoption.setchosenindex(0); classifier.distancestrategyoption.setchosenindex(2); classifier.initialclusterweightoption.setvalue(0.1); classifier.learningratealphaoption.setvalue(0.95); classifier.minimumclustersizeoption.setvalue(3); classifier.outlierdefinitionstrategyoption.setchosenindex(0); classifier.updatestrategyoption.setchosenindex(1); classifier.trainoninstance(trainingset.instance(0)); double[] result = classifier.getvotesforinstance(x); int h = (int) result[weka.core.utils.maxindex(result)]; int y = 1; assertequals(y,h); }","repo":"bigfastdata\/SluiceBox","label":[0,1,0,0]}
{"id":34109,"original_code":"public ReportHeaderGroup getReportHeaderGroup(int col)\n    {\n        \/* no report header groups? *\/\n        if (ListTools.isEmpty(this.rptHdrGrps)) {\n            return null;\n        }\n        \/* search for column *\/\n        for (ReportHeaderGroup rhg : this.rptHdrGrps) {\n            int C = rhg.getColIndex();\n            if (col == C) {\n                return rhg;\n            }\n            \/\/ TODO: optimize\n        }\n        \/* not found *\/\n        return null;\n    }","code_wo_comment":"public ReportHeaderGroup getReportHeaderGroup(int col)\n    {\n       \n        if (ListTools.isEmpty(this.rptHdrGrps)) {\n            return null;\n        }\n       \n        for (ReportHeaderGroup rhg : this.rptHdrGrps) {\n            int C = rhg.getColIndex();\n            if (col == C) {\n                return rhg;\n            }\n           \n        }\n       \n        return null;\n    }","cleancode":"public reportheadergroup getreportheadergroup(int col) { if (listtools.isempty(this.rpthdrgrps)) { return null; } for (reportheadergroup rhg : this.rpthdrgrps) { int c = rhg.getcolindex(); if (col == c) { return rhg; } } return null; }","repo":"aungphyopyaekyaw\/gpstrack","label":[1,0,0,0]}
{"id":9544,"original_code":"@Override\n  public int getPreferredHeight() {\n    \/\/ The superclass uses getOffsetHeight, which won't work for us.\n    return ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n  }","code_wo_comment":"@Override\n  public int getPreferredHeight() {\n   \n    return ComponentConstants.VIDEOPLAYER_PREFERRED_HEIGHT;\n  }","cleancode":"@override public int getpreferredheight() { return componentconstants.videoplayer_preferred_height; }","repo":"be1be1\/appinventor-polyu","label":[0,0,1,0]}
{"id":25966,"original_code":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\n\t\tif (obj.getString(\"kind\").equals(\"constant\")) {\n\t\t\tString name = obj.getString(\"name\");\n\t\t\tString desc = obj.optString(\"description\", \"\");\n\t\t\tObject defaultValue = obj.opt(\"defaultvalue\");\n\t\t\tString[] types;\n\t\t\tif (obj.has(\"type\")) {\n\t\t\t\tJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\n\t\t\t\ttypes = getStringArray(jsonTypes);\n\t\t\t} else {\n\t\t\t\t\/\/ FIXME: this is the case of blendModes and scaleModes\n\t\t\t\ttypes = new String[] { \"Object\" };\n\t\t\t}\n\t\t\tPhaserConstant cons = new PhaserConstant();\n\t\t\t{\n\t\t\t\t\/\/ static flag\n\t\t\t\tString scope = obj.optString(\"scope\", \"\");\n\t\t\t\tif (scope.equals(\"static\")) {\n\t\t\t\t\tcons.setStatic(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcons.setName(name);\n\t\t\tcons.setHelp(desc);\n\t\t\tcons.setTypes(types);\n\t\t\tcons.setDefaultValue(defaultValue);\n\t\t\tString memberof = obj.optString(\"memberof\", null);\n\t\t\tif (memberof == null) {\n\t\t\t\t\/\/ global constant\n\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t\/\/ FIXME: only add those Phaser.js constants\n\t\t\t\tif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n\t\t\t\t\t_globalConstants.add(cons);\n\t\t\t\t} else {\n\t\t\t\t\tout.println(obj.toString(2));\n\t\t\t\t\tthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n\t\t\t\t\t\t\t+ cons.getFile().getFileName() + \"#\" + cons.getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPhaserType type = typeMap.get(memberof);\n\t\t\t\tif (!type.getMemberMap().containsKey(name)) {\n\t\t\t\t\ttype.getMemberMap().put(name, cons);\n\t\t\t\t\tcons.setDeclType(type);\n\t\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"private void buildConstant(JSONObject obj, Map<String, PhaserType> typeMap) {\n\t\tif (obj.getString(\"kind\").equals(\"constant\")) {\n\t\t\tString name = obj.getString(\"name\");\n\t\t\tString desc = obj.optString(\"description\", \"\");\n\t\t\tObject defaultValue = obj.opt(\"defaultvalue\");\n\t\t\tString[] types;\n\t\t\tif (obj.has(\"type\")) {\n\t\t\t\tJSONArray jsonTypes = obj.getJSONObject(\"type\").getJSONArray(\"names\");\n\t\t\t\ttypes = getStringArray(jsonTypes);\n\t\t\t} else {\n\t\t\t\n\t\t\t\ttypes = new String[] { \"Object\" };\n\t\t\t}\n\t\t\tPhaserConstant cons = new PhaserConstant();\n\t\t\t{\n\t\t\t\n\t\t\t\tString scope = obj.optString(\"scope\", \"\");\n\t\t\t\tif (scope.equals(\"static\")) {\n\t\t\t\t\tcons.setStatic(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcons.setName(name);\n\t\t\tcons.setHelp(desc);\n\t\t\tcons.setTypes(types);\n\t\t\tcons.setDefaultValue(defaultValue);\n\t\t\tString memberof = obj.optString(\"memberof\", null);\n\t\t\tif (memberof == null) {\n\t\t\t\n\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\n\t\t\t\tif (cons.getFile().getFileName().toString().equals(\"Phaser.js\")) {\n\t\t\t\t\t_globalConstants.add(cons);\n\t\t\t\t} else {\n\t\t\t\t\tout.println(obj.toString(2));\n\t\t\t\t\tthrow new IllegalArgumentException(\"All global constants should come from Phaser.js and not from \"\n\t\t\t\t\t\t\t+ cons.getFile().getFileName() + \"#\" + cons.getName());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tPhaserType type = typeMap.get(memberof);\n\t\t\t\tif (!type.getMemberMap().containsKey(name)) {\n\t\t\t\t\ttype.getMemberMap().put(name, cons);\n\t\t\t\t\tcons.setDeclType(type);\n\t\t\t\t\tbuildMeta(cons, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","cleancode":"private void buildconstant(jsonobject obj, map<string, phasertype> typemap) { if (obj.getstring(\"kind\").equals(\"constant\")) { string name = obj.getstring(\"name\"); string desc = obj.optstring(\"description\", \"\"); object defaultvalue = obj.opt(\"defaultvalue\"); string[] types; if (obj.has(\"type\")) { jsonarray jsontypes = obj.getjsonobject(\"type\").getjsonarray(\"names\"); types = getstringarray(jsontypes); } else { types = new string[] { \"object\" }; } phaserconstant cons = new phaserconstant(); { string scope = obj.optstring(\"scope\", \"\"); if (scope.equals(\"static\")) { cons.setstatic(true); } } cons.setname(name); cons.sethelp(desc); cons.settypes(types); cons.setdefaultvalue(defaultvalue); string memberof = obj.optstring(\"memberof\", null); if (memberof == null) { buildmeta(cons, obj); if (cons.getfile().getfilename().tostring().equals(\"phaser.js\")) { _globalconstants.add(cons); } else { out.println(obj.tostring(2)); throw new illegalargumentexception(\"all global constants should come from phaser.js and not from \" + cons.getfile().getfilename() + \"#\" + cons.getname()); } } else { phasertype type = typemap.get(memberof); if (!type.getmembermap().containskey(name)) { type.getmembermap().put(name, cons); cons.setdecltype(type); buildmeta(cons, obj); } } } }","repo":"boniatillo-com\/rayo","label":[1,0,1,0]}
{"id":1477,"original_code":"@Override\n    public String getName() {\n        return \"Manage services\";\n    }","code_wo_comment":"@Override\n    public String getName() {\n        return \"Manage services\";\n    }","cleancode":"@override public string getname() { return \"manage services\"; }","repo":"civts\/AAC","label":[1,0,0,0]}
{"id":9669,"original_code":"@Override\n  public void testSave() {\n    \/\/ TODO Embedded Elasticsearch integration tests do not support has child operations\n  }","code_wo_comment":"@Override\n  public void testSave() {\n   \n  }","cleancode":"@override public void testsave() { }","repo":"commitd\/jonah-server","label":[0,1,0,0]}
{"id":1489,"original_code":"public void downloadTiles(){\n\t\tsetVisible(false);\n\t\tfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\")); \/\/$NON-NLS-1$\n\t\tint numberTiles = 0;\n\t\tfinal int startZoom = (Integer) startSpinner.getValue();\n\t\tfinal int endZoom = (Integer) endSpinner.getValue();\n\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\tnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n\t\t}\n\t\tfinal int number = numberTiles;\n\t\tfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\n\t\tprogressDialog.setRunnable(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number); \/\/$NON-NLS-1$\n\t\t\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\t\t\tfor(int x = x1; x <= x2; x++){\n\t\t\t\t\t\tfor(int y=y1; y<= y2; y++){\n\t\t\t\t\t\t\tString file = getFileForImage(x, y, zoom, map.getTileFormat());\n\t\t\t\t\t\t\tif(new File(tilesLocation, file).exists()){\n\t\t\t\t\t\t\t\tprogressDialog.progress(1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDownloadRequest req = new DownloadRequest(map.getUrlToLoad(x, y, zoom), \n\t\t\t\t\t\t\t\t\t\tnew File(tilesLocation, file), x, y, zoom);\n\t\t\t\t\t\t\t\tinstance.requestToDownload(req);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(instance.isSomethingBeingDownloaded()){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tArrayList<IMapDownloaderCallback> previousCallbacks = \n\t\t\tnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\n\t\tinstance.getDownloaderCallbacks().clear();\n\t\tinstance.addDownloaderCallback(new IMapDownloaderCallback(){\n\t\t\t@Override\n\t\t\tpublic void tileDownloaded(DownloadRequest request) {\n\t\t\t\t\/\/ TODO request could be null if bundle loading?\n\t\t\t\tprogressDialog.progress(1);\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tprogressDialog.run();\n\t\t\tinstance.refuseAllPreviousRequests();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tExceptionHandler.handle((Exception) e.getCause());\n\t\t} catch (InterruptedException e) {\n\t\t\tExceptionHandler.handle(e);\n\t\t} finally {\n\t\t\tinstance.getDownloaderCallbacks().clear();\n\t\t\tinstance.getDownloaderCallbacks().addAll(previousCallbacks);\n\t\t}\n\t}","code_wo_comment":"public void downloadTiles(){\n\t\tsetVisible(false);\n\t\tfinal ProgressDialog progressDialog = new ProgressDialog(this, Messages.getString(\"TileBundleDownloadDialog.DOWNLOADING.TILES\"));\n\t\tint numberTiles = 0;\n\t\tfinal int startZoom = (Integer) startSpinner.getValue();\n\t\tfinal int endZoom = (Integer) endSpinner.getValue();\n\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\tnumberTiles += (x2 - x1 + 1) * (y2 - y1 + 1);\n\t\t}\n\t\tfinal int number = numberTiles;\n\t\tfinal MapTileDownloader instance = MapTileDownloader.getInstance(MapCreatorVersion.APP_MAP_CREATOR_VERSION);\n\t\tprogressDialog.setRunnable(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tprogressDialog.startTask(Messages.getString(\"TileBundleDownloadDialog.LOADING\"), number);\n\t\t\t\tfor (int zoom = startZoom; zoom <= endZoom; zoom++) {\n\t\t\t\t\tint x1 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon1());\n\t\t\t\t\tint x2 = (int) MapUtils.getTileNumberX(zoom, selectionArea.getLon2());\n\t\t\t\t\tint y1 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat1());\n\t\t\t\t\tint y2 = (int) MapUtils.getTileNumberY(zoom, selectionArea.getLat2());\n\t\t\t\t\tfor(int x = x1; x <= x2; x++){\n\t\t\t\t\t\tfor(int y=y1; y<= y2; y++){\n\t\t\t\t\t\t\tString file = getFileForImage(x, y, zoom, map.getTileFormat());\n\t\t\t\t\t\t\tif(new File(tilesLocation, file).exists()){\n\t\t\t\t\t\t\t\tprogressDialog.progress(1);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDownloadRequest req = new DownloadRequest(map.getUrlToLoad(x, y, zoom), \n\t\t\t\t\t\t\t\t\t\tnew File(tilesLocation, file), x, y, zoom);\n\t\t\t\t\t\t\t\tinstance.requestToDownload(req);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(instance.isSomethingBeingDownloaded()){\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tArrayList<IMapDownloaderCallback> previousCallbacks = \n\t\t\tnew ArrayList<IMapDownloaderCallback>(instance.getDownloaderCallbacks());\n\t\tinstance.getDownloaderCallbacks().clear();\n\t\tinstance.addDownloaderCallback(new IMapDownloaderCallback(){\n\t\t\t@Override\n\t\t\tpublic void tileDownloaded(DownloadRequest request) {\n\t\t\t\n\t\t\t\tprogressDialog.progress(1);\n\t\t\t}\n\t\t});\n\t\ttry {\n\t\t\tprogressDialog.run();\n\t\t\tinstance.refuseAllPreviousRequests();\n\t\t} catch (InvocationTargetException e) {\n\t\t\tExceptionHandler.handle((Exception) e.getCause());\n\t\t} catch (InterruptedException e) {\n\t\t\tExceptionHandler.handle(e);\n\t\t} finally {\n\t\t\tinstance.getDownloaderCallbacks().clear();\n\t\t\tinstance.getDownloaderCallbacks().addAll(previousCallbacks);\n\t\t}\n\t}","cleancode":"public void downloadtiles(){ setvisible(false); final progressdialog progressdialog = new progressdialog(this, messages.getstring(\"tilebundledownloaddialog.downloading.tiles\")); int numbertiles = 0; final int startzoom = (integer) startspinner.getvalue(); final int endzoom = (integer) endspinner.getvalue(); for (int zoom = startzoom; zoom <= endzoom; zoom++) { int x1 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon1()); int x2 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon2()); int y1 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat1()); int y2 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat2()); numbertiles += (x2 - x1 + 1) * (y2 - y1 + 1); } final int number = numbertiles; final maptiledownloader instance = maptiledownloader.getinstance(mapcreatorversion.app_map_creator_version); progressdialog.setrunnable(new runnable(){ @override public void run() { progressdialog.starttask(messages.getstring(\"tilebundledownloaddialog.loading\"), number); for (int zoom = startzoom; zoom <= endzoom; zoom++) { int x1 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon1()); int x2 = (int) maputils.gettilenumberx(zoom, selectionarea.getlon2()); int y1 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat1()); int y2 = (int) maputils.gettilenumbery(zoom, selectionarea.getlat2()); for(int x = x1; x <= x2; x++){ for(int y=y1; y<= y2; y++){ string file = getfileforimage(x, y, zoom, map.gettileformat()); if(new file(tileslocation, file).exists()){ progressdialog.progress(1); } else { downloadrequest req = new downloadrequest(map.geturltoload(x, y, zoom), new file(tileslocation, file), x, y, zoom); instance.requesttodownload(req); } } } while(instance.issomethingbeingdownloaded()){ try { thread.sleep(100); } catch (interruptedexception e) { throw new illegalargumentexception(e); } } } } }); arraylist<imapdownloadercallback> previouscallbacks = new arraylist<imapdownloadercallback>(instance.getdownloadercallbacks()); instance.getdownloadercallbacks().clear(); instance.adddownloadercallback(new imapdownloadercallback(){ @override public void tiledownloaded(downloadrequest request) { progressdialog.progress(1); } }); try { progressdialog.run(); instance.refuseallpreviousrequests(); } catch (invocationtargetexception e) { exceptionhandler.handle((exception) e.getcause()); } catch (interruptedexception e) { exceptionhandler.handle(e); } finally { instance.getdownloadercallbacks().clear(); instance.getdownloadercallbacks().addall(previouscallbacks); } }","repo":"brownsys\/android-app-modes-osmand","label":[0,1,0,0]}
{"id":26161,"original_code":"@Override\n\tpublic boolean saveSettings() {\n\t\t\/\/ We might even consider updating the user-supplied file, if any...\n\t\treturn false;\n\t}","code_wo_comment":"@Override\n\tpublic boolean saveSettings() {\n\t\n\t\treturn false;\n\t}","cleancode":"@override public boolean savesettings() { return false; }","repo":"chbi\/gerrit-gitblit-plugin","label":[1,0,0,0]}
{"id":34429,"original_code":"public void setValue(Object newValue) {\n        Object checkedValue = checkValue(newValue);\n        setDirty(isDifferent(baseValue, checkedValue));\n        if (isDifferent(value, checkedValue)){ \/\/ firePropertyChange doesn't do this check sufficiently\n            firePropertyChange(VALUE, value, value = checkedValue); \/\/ set inline to avoid recursion\n        }\n    }","code_wo_comment":"public void setValue(Object newValue) {\n        Object checkedValue = checkValue(newValue);\n        setDirty(isDifferent(baseValue, checkedValue));\n        if (isDifferent(value, checkedValue)){\n            firePropertyChange(VALUE, value, value = checkedValue);\n        }\n    }","cleancode":"public void setvalue(object newvalue) { object checkedvalue = checkvalue(newvalue); setdirty(isdifferent(basevalue, checkedvalue)); if (isdifferent(value, checkedvalue)){ firepropertychange(value, value, value = checkedvalue); } }","repo":"canoo\/open-dolphin","label":[1,0,0,0]}
{"id":26262,"original_code":"@Override\n    public TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n      \/\/ TODO Should be split into different tests for mean, variance, covariance, covariancematrix\n      return new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\n        private final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\n        private final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\n        private final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\n        private final List<Integer> dataMean = Arrays.asList(496, 384);\n        private DRes<BigInteger> outputMean1;\n        private DRes<BigInteger> outputMean2;\n        private DRes<BigInteger> outputVariance;\n        private DRes<BigInteger> outputCovariance;\n        private List<List<DRes<BigInteger>>> outputCovarianceMatix;\n        @Override\n        public void test() throws Exception {\n          Application<Void, ProtocolBuilderNumeric> app = builder -> {\n            Numeric NumericBuilder = builder.numeric();\n            List<DRes<SInt>> input1 = data1.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input2 = data2.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input3 = data3.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> means = dataMean.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            DRes<SInt> mean1 = builder.seq(new Mean(input1));\n            DRes<SInt> mean2 = builder.seq(new Mean(input2));\n            DRes<SInt> variance = builder.seq(new Variance(input1, mean1));\n            DRes<SInt> covariance = builder.seq(new Covariance(input1, input2, mean1, mean2));\n            DRes<List<List<DRes<SInt>>>> covarianceMatrix =\n                builder.seq(new CovarianceMatrix(Arrays.asList(input1, input2, input3), means));\n            return builder.par((par) -> {\n              Numeric open = par.numeric();\n              outputMean1 = open.open(mean1);\n              outputMean2 = open.open(mean2);\n              outputVariance = open.open(variance);\n              outputCovariance = open.open(covariance);\n              List<List<DRes<SInt>>> covarianceMatrixOut = covarianceMatrix.out();\n              List<List<DRes<BigInteger>>> openCovarianceMatrix =\n                  new ArrayList<>(covarianceMatrixOut.size());\n              for (List<DRes<SInt>> computations : covarianceMatrixOut) {\n                List<DRes<BigInteger>> computationList = new ArrayList<>(computations.size());\n                openCovarianceMatrix.add(computationList);\n                for (DRes<SInt> computation : computations) {\n                  computationList.add(open.open(computation));\n                }\n              }\n              outputCovarianceMatix = openCovarianceMatrix;\n              return null;\n            });\n          };\n          runApplication(app);\n          BigInteger mean1 = outputMean1.out();\n          BigInteger mean2 = outputMean2.out();\n          BigInteger variance = outputVariance.out();\n          BigInteger covariance = outputCovariance.out();\n          double sum = 0.0;\n          for (int entry : data1) {\n            sum += entry;\n          }\n          double mean1Exact = sum \/ data1.size();\n          sum = 0.0;\n          for (int entry : data2) {\n            sum += entry;\n          }\n          double mean2Exact = sum \/ data2.size();\n          double ssd = 0.0;\n          for (int entry : data1) {\n            ssd += (entry - mean1Exact) * (entry - mean1Exact);\n          }\n          double varianceExact = ssd \/ (data1.size() - 1);\n          double covarianceExact = 0.0;\n          for (int i = 0; i < data1.size(); i++) {\n            covarianceExact += (data1.get(i) - mean1Exact) * (data2.get(i) - mean2Exact);\n          }\n          covarianceExact \/= (data1.size() - 1);\n          double tolerance = 1.0;\n          Assert.assertTrue(isInInterval(mean1, mean1Exact, tolerance));\n          Assert.assertTrue(isInInterval(mean2, mean2Exact, tolerance));\n          Assert.assertTrue(isInInterval(variance, varianceExact, tolerance));\n          System.out.println(covariance + \" \" + covarianceExact + \" - \" + tolerance);\n          Assert.assertTrue(isInInterval(covariance, covarianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(0).get(0).out(), varianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(1).get(0).out(), covarianceExact, tolerance));\n        }\n      };\n    }","code_wo_comment":"@Override\n    public TestThread<ResourcePoolT, ProtocolBuilderNumeric> next() {\n     \n      return new TestThread<ResourcePoolT, ProtocolBuilderNumeric>() {\n        private final List<Integer> data1 = Arrays.asList(543, 520, 532, 497, 450, 432);\n        private final List<Integer> data2 = Arrays.asList(432, 620, 232, 337, 250, 433);\n        private final List<Integer> data3 = Arrays.asList(80, 90, 123, 432, 145, 606);\n        private final List<Integer> dataMean = Arrays.asList(496, 384);\n        private DRes<BigInteger> outputMean1;\n        private DRes<BigInteger> outputMean2;\n        private DRes<BigInteger> outputVariance;\n        private DRes<BigInteger> outputCovariance;\n        private List<List<DRes<BigInteger>>> outputCovarianceMatix;\n        @Override\n        public void test() throws Exception {\n          Application<Void, ProtocolBuilderNumeric> app = builder -> {\n            Numeric NumericBuilder = builder.numeric();\n            List<DRes<SInt>> input1 = data1.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input2 = data2.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> input3 = data3.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            List<DRes<SInt>> means = dataMean.stream().map(BigInteger::valueOf)\n                .map(NumericBuilder::known).collect(Collectors.toList());\n            DRes<SInt> mean1 = builder.seq(new Mean(input1));\n            DRes<SInt> mean2 = builder.seq(new Mean(input2));\n            DRes<SInt> variance = builder.seq(new Variance(input1, mean1));\n            DRes<SInt> covariance = builder.seq(new Covariance(input1, input2, mean1, mean2));\n            DRes<List<List<DRes<SInt>>>> covarianceMatrix =\n                builder.seq(new CovarianceMatrix(Arrays.asList(input1, input2, input3), means));\n            return builder.par((par) -> {\n              Numeric open = par.numeric();\n              outputMean1 = open.open(mean1);\n              outputMean2 = open.open(mean2);\n              outputVariance = open.open(variance);\n              outputCovariance = open.open(covariance);\n              List<List<DRes<SInt>>> covarianceMatrixOut = covarianceMatrix.out();\n              List<List<DRes<BigInteger>>> openCovarianceMatrix =\n                  new ArrayList<>(covarianceMatrixOut.size());\n              for (List<DRes<SInt>> computations : covarianceMatrixOut) {\n                List<DRes<BigInteger>> computationList = new ArrayList<>(computations.size());\n                openCovarianceMatrix.add(computationList);\n                for (DRes<SInt> computation : computations) {\n                  computationList.add(open.open(computation));\n                }\n              }\n              outputCovarianceMatix = openCovarianceMatrix;\n              return null;\n            });\n          };\n          runApplication(app);\n          BigInteger mean1 = outputMean1.out();\n          BigInteger mean2 = outputMean2.out();\n          BigInteger variance = outputVariance.out();\n          BigInteger covariance = outputCovariance.out();\n          double sum = 0.0;\n          for (int entry : data1) {\n            sum += entry;\n          }\n          double mean1Exact = sum \/ data1.size();\n          sum = 0.0;\n          for (int entry : data2) {\n            sum += entry;\n          }\n          double mean2Exact = sum \/ data2.size();\n          double ssd = 0.0;\n          for (int entry : data1) {\n            ssd += (entry - mean1Exact) * (entry - mean1Exact);\n          }\n          double varianceExact = ssd \/ (data1.size() - 1);\n          double covarianceExact = 0.0;\n          for (int i = 0; i < data1.size(); i++) {\n            covarianceExact += (data1.get(i) - mean1Exact) * (data2.get(i) - mean2Exact);\n          }\n          covarianceExact \/= (data1.size() - 1);\n          double tolerance = 1.0;\n          Assert.assertTrue(isInInterval(mean1, mean1Exact, tolerance));\n          Assert.assertTrue(isInInterval(mean2, mean2Exact, tolerance));\n          Assert.assertTrue(isInInterval(variance, varianceExact, tolerance));\n          System.out.println(covariance + \" \" + covarianceExact + \" - \" + tolerance);\n          Assert.assertTrue(isInInterval(covariance, covarianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(0).get(0).out(), varianceExact, tolerance));\n          Assert.assertTrue(\n              isInInterval(outputCovarianceMatix.get(1).get(0).out(), covarianceExact, tolerance));\n        }\n      };\n    }","cleancode":"@override public testthread<resourcepoolt, protocolbuildernumeric> next() { return new testthread<resourcepoolt, protocolbuildernumeric>() { private final list<integer> data1 = arrays.aslist(543, 520, 532, 497, 450, 432); private final list<integer> data2 = arrays.aslist(432, 620, 232, 337, 250, 433); private final list<integer> data3 = arrays.aslist(80, 90, 123, 432, 145, 606); private final list<integer> datamean = arrays.aslist(496, 384); private dres<biginteger> outputmean1; private dres<biginteger> outputmean2; private dres<biginteger> outputvariance; private dres<biginteger> outputcovariance; private list<list<dres<biginteger>>> outputcovariancematix; @override public void test() throws exception { application<void, protocolbuildernumeric> app = builder -> { numeric numericbuilder = builder.numeric(); list<dres<sint>> input1 = data1.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> input2 = data2.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> input3 = data3.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); list<dres<sint>> means = datamean.stream().map(biginteger::valueof) .map(numericbuilder::known).collect(collectors.tolist()); dres<sint> mean1 = builder.seq(new mean(input1)); dres<sint> mean2 = builder.seq(new mean(input2)); dres<sint> variance = builder.seq(new variance(input1, mean1)); dres<sint> covariance = builder.seq(new covariance(input1, input2, mean1, mean2)); dres<list<list<dres<sint>>>> covariancematrix = builder.seq(new covariancematrix(arrays.aslist(input1, input2, input3), means)); return builder.par((par) -> { numeric open = par.numeric(); outputmean1 = open.open(mean1); outputmean2 = open.open(mean2); outputvariance = open.open(variance); outputcovariance = open.open(covariance); list<list<dres<sint>>> covariancematrixout = covariancematrix.out(); list<list<dres<biginteger>>> opencovariancematrix = new arraylist<>(covariancematrixout.size()); for (list<dres<sint>> computations : covariancematrixout) { list<dres<biginteger>> computationlist = new arraylist<>(computations.size()); opencovariancematrix.add(computationlist); for (dres<sint> computation : computations) { computationlist.add(open.open(computation)); } } outputcovariancematix = opencovariancematrix; return null; }); }; runapplication(app); biginteger mean1 = outputmean1.out(); biginteger mean2 = outputmean2.out(); biginteger variance = outputvariance.out(); biginteger covariance = outputcovariance.out(); double sum = 0.0; for (int entry : data1) { sum += entry; } double mean1exact = sum \/ data1.size(); sum = 0.0; for (int entry : data2) { sum += entry; } double mean2exact = sum \/ data2.size(); double ssd = 0.0; for (int entry : data1) { ssd += (entry - mean1exact) * (entry - mean1exact); } double varianceexact = ssd \/ (data1.size() - 1); double covarianceexact = 0.0; for (int i = 0; i < data1.size(); i++) { covarianceexact += (data1.get(i) - mean1exact) * (data2.get(i) - mean2exact); } covarianceexact \/= (data1.size() - 1); double tolerance = 1.0; assert.asserttrue(isininterval(mean1, mean1exact, tolerance)); assert.asserttrue(isininterval(mean2, mean2exact, tolerance)); assert.asserttrue(isininterval(variance, varianceexact, tolerance)); system.out.println(covariance + \" \" + covarianceexact + \" - \" + tolerance); assert.asserttrue(isininterval(covariance, covarianceexact, tolerance)); assert.asserttrue( isininterval(outputcovariancematix.get(0).get(0).out(), varianceexact, tolerance)); assert.asserttrue( isininterval(outputcovariancematix.get(1).get(0).out(), covarianceexact, tolerance)); } }; }","repo":"basitkhurram\/fresco","label":[0,0,0,1]}
{"id":1728,"original_code":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\t\t\/\/ prepare for a new iteration, clean the state\n\t\tclearData();\n\t\t\/\/ handle contract clause itself first (implicitly includes traversing unknown types and properties)\n\t\tString clauseOutput = \"\"; \n\t\tif (verifyOrFind)\n\t\t\tclauseOutput += generateSmtContractClauseVerify(cc);\n\t\telse \n\t\t\tclauseOutput += generateSmtContractClauseFind(cc);    \n\t\t\/\/ process input and output to collect info about components and\n\t\t\/\/ properties\n\t\ttraverseInputOutput(ac);\n\t\t\/\/ create definitions and facts\n\t\t\/\/ also populate string2int dictionary as a side effect\n\t\tString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\t\t\/\/ apply dictionary transform to clause output\n\t\t\/\/ FIXME collisions with other names possible\n\t\tfor (String str: stringToIntDict.keySet()) { \n\t\t\tclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n\t\t}\n\t\t\/\/ defs and facts come come first\n\t\treturn defFactOutput + clauseOutput;\n\t}","code_wo_comment":"public String generateSmtForClause(AnalysisContract ac, ContractClause cc, boolean verifyOrFind) {\n\t\n\t\tclearData();\n\t\n\t\tString clauseOutput = \"\"; \n\t\tif (verifyOrFind)\n\t\t\tclauseOutput += generateSmtContractClauseVerify(cc);\n\t\telse \n\t\t\tclauseOutput += generateSmtContractClauseFind(cc);    \n\t\n\t\n\t\ttraverseInputOutput(ac);\n\t\n\t\n\t\tString defFactOutput = psg.generateDefinitionsAndFacts(compToProp, ac, stringToIntDict);\n\t\n\t\n\t\tfor (String str: stringToIntDict.keySet()) { \n\t\t\tclauseOutput = clauseOutput.replace('$' + str + '$', String.valueOf(stringToIntDict.get(str)));\n\t\t}\n\t\n\t\treturn defFactOutput + clauseOutput;\n\t}","cleancode":"public string generatesmtforclause(analysiscontract ac, contractclause cc, boolean verifyorfind) { cleardata(); string clauseoutput = \"\"; if (verifyorfind) clauseoutput += generatesmtcontractclauseverify(cc); else clauseoutput += generatesmtcontractclausefind(cc); traverseinputoutput(ac); string deffactoutput = psg.generatedefinitionsandfacts(comptoprop, ac, stringtointdict); for (string str: stringtointdict.keyset()) { clauseoutput = clauseoutput.replace('$' + str + '$', string.valueof(stringtointdict.get(str))); } return deffactoutput + clauseoutput; }","repo":"bisc\/active","label":[0,0,1,0]}
{"id":34500,"original_code":"@NonNull\n    public static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\n        if (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ avoid updating to frequently\n        final long timeNow = System.currentTimeMillis();\n        if ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\n            return ensureTrack(lastRoutingPoints, start, destination);\n        }\n        \/\/ Disable routing for huge distances\n        final int maxThresholdKm = Settings.getBrouterThreshold();\n        final float targetDistance = start.distanceTo(destination);\n        if (targetDistance > maxThresholdKm) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ disable routing when near the target\n        if (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\n            return defaultTrack(start, destination);\n        }\n        \/\/ Use cached route if current position has not changed more than 5m and we had a route\n        \/\/ TODO: Maybe adjust this to current zoomlevel\n        if (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\n            return lastRoutingPoints;\n        }\n        \/\/ now really calculate a new route\n        lastDestination = destination;\n        lastRoutingPoints = calculateRouting(start, destination);\n        lastDirectionUpdatePoint = start;\n        timeLastUpdate = timeNow;\n        return ensureTrack(lastRoutingPoints, start, destination);\n    }","code_wo_comment":"@NonNull\n    public static Geopoint[] getTrack(final Geopoint start, final Geopoint destination) {\n        if (brouter == null || Settings.getRoutingMode() == RoutingMode.STRAIGHT) {\n            return defaultTrack(start, destination);\n        }\n       \n        final long timeNow = System.currentTimeMillis();\n        if ((timeNow - timeLastUpdate) < 1000 * UPDATE_MIN_DELAY_SECONDS) {\n            return ensureTrack(lastRoutingPoints, start, destination);\n        }\n       \n        final int maxThresholdKm = Settings.getBrouterThreshold();\n        final float targetDistance = start.distanceTo(destination);\n        if (targetDistance > maxThresholdKm) {\n            return defaultTrack(start, destination);\n        }\n       \n        if (targetDistance < MIN_ROUTING_DISTANCE_KILOMETERS) {\n            return defaultTrack(start, destination);\n        }\n       \n       \n        if (lastDirectionUpdatePoint != null && destination == lastDestination && start.distanceTo(lastDirectionUpdatePoint) < UPDATE_MIN_DISTANCE_KILOMETERS && lastRoutingPoints != null) {\n            return lastRoutingPoints;\n        }\n       \n        lastDestination = destination;\n        lastRoutingPoints = calculateRouting(start, destination);\n        lastDirectionUpdatePoint = start;\n        timeLastUpdate = timeNow;\n        return ensureTrack(lastRoutingPoints, start, destination);\n    }","cleancode":"@nonnull public static geopoint[] gettrack(final geopoint start, final geopoint destination) { if (brouter == null || settings.getroutingmode() == routingmode.straight) { return defaulttrack(start, destination); } final long timenow = system.currenttimemillis(); if ((timenow - timelastupdate) < 1000 * update_min_delay_seconds) { return ensuretrack(lastroutingpoints, start, destination); } final int maxthresholdkm = settings.getbrouterthreshold(); final float targetdistance = start.distanceto(destination); if (targetdistance > maxthresholdkm) { return defaulttrack(start, destination); } if (targetdistance < min_routing_distance_kilometers) { return defaulttrack(start, destination); } if (lastdirectionupdatepoint != null && destination == lastdestination && start.distanceto(lastdirectionupdatepoint) < update_min_distance_kilometers && lastroutingpoints != null) { return lastroutingpoints; } lastdestination = destination; lastroutingpoints = calculaterouting(start, destination); lastdirectionupdatepoint = start; timelastupdate = timenow; return ensuretrack(lastroutingpoints, start, destination); }","repo":"cayacdev\/cgeo","label":[0,1,0,0]}
{"id":26309,"original_code":"public static void load(Preferences options) {\n        fontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n        fontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n        markdownExtensions.init(options, \"markdownExtensions\");\n        \/\/ TODO rewrite after add extension dialogs\n        setMarkdownExtensions(MarkdownExtensions.ids());\n        showLineNo.init(options, \"showLineNo\", true);\n        showWhitespace.init(options, \"showWhitespace\", false);\n    }","code_wo_comment":"public static void load(Preferences options) {\n        fontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n        fontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n        markdownExtensions.init(options, \"markdownExtensions\");\n       \n        setMarkdownExtensions(MarkdownExtensions.ids());\n        showLineNo.init(options, \"showLineNo\", true);\n        showWhitespace.init(options, \"showWhitespace\", false);\n    }","cleancode":"public static void load(preferences options) { fontfamily.init(options, \"fontfamily\", null, value -> safefontfamily(value)); fontsize.init(options, \"fontsize\", def_font_size); markdownextensions.init(options, \"markdownextensions\"); setmarkdownextensions(markdownextensions.ids()); showlineno.init(options, \"showlineno\", true); showwhitespace.init(options, \"showwhitespace\", false); }","repo":"baobab-it\/notebookFX","label":[0,1,0,0]}
{"id":26319,"original_code":"@Override\n    public void close()\n    {\n        \/\/ TODO: Connect\n    }","code_wo_comment":"@Override\n    public void close()\n    {\n       \n    }","cleancode":"@override public void close() { }","repo":"ankitaagar\/felix-dev","label":[0,1,0,0]}
{"id":26320,"original_code":"@Override\n    public String getEntryAsNativeLibrary(String entryName)\n    {\n        \/\/ TODO: Connect\n        return null;\n    }","code_wo_comment":"@Override\n    public String getEntryAsNativeLibrary(String entryName)\n    {\n       \n        return null;\n    }","cleancode":"@override public string getentryasnativelibrary(string entryname) { return null; }","repo":"ankitaagar\/felix-dev","label":[0,1,0,0]}
{"id":26321,"original_code":"@Override\n    public URL getEntryAsURL(String name)\n    {\n        \/\/ TODO: Connect\n        return null;\n    }","code_wo_comment":"@Override\n    public URL getEntryAsURL(String name)\n    {\n       \n        return null;\n    }","cleancode":"@override public url getentryasurl(string name) { return null; }","repo":"ankitaagar\/felix-dev","label":[0,1,0,0]}
{"id":1778,"original_code":"public void testLayerHandle() throws Exception {\n        NbModuleProject project = TestBase.generateStandaloneModule(getWorkDir(), \"module\");\n        LayerHandle handle = LayerHandle.forProject(project);\n        FileObject expectedLayerXML = project.getProjectDirectory().getFileObject(\"src\/org\/example\/module\/resources\/layer.xml\");\n        assertNotNull(expectedLayerXML);\n        FileObject layerXML = handle.getLayerFile();\n        assertNotNull(\"layer.xml already exists\", layerXML);\n        assertEquals(\"right layer file\", expectedLayerXML, layerXML);\n        FileSystem fs = handle.layer(true);\n        assertEquals(\"initially empty\", 0, fs.getRoot().getChildren().length);\n        long initialSize = layerXML.getSize();\n        fs.getRoot().createData(\"foo\");\n        assertEquals(\"not saved yet\", initialSize, layerXML.getSize());\n        fs = handle.layer(true);\n        assertNotNull(\"still have in-memory mods\", fs.findResource(\"foo\"));\n        fs.getRoot().createData(\"bar\");\n        handle.save();\n        assertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\n        String xml =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n                \"<filesystem>\\n\" +\n                \"    <file name=\\\"bar\\\"\/>\\n\" +\n                \"    <file name=\\\"foo\\\"\/>\\n\" +\n                \"<\/filesystem>\\n\";\n        assertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n        \/\/ XXX test that nbres: file contents work\n    }","code_wo_comment":"public void testLayerHandle() throws Exception {\n        NbModuleProject project = TestBase.generateStandaloneModule(getWorkDir(), \"module\");\n        LayerHandle handle = LayerHandle.forProject(project);\n        FileObject expectedLayerXML = project.getProjectDirectory().getFileObject(\"src\/org\/example\/module\/resources\/layer.xml\");\n        assertNotNull(expectedLayerXML);\n        FileObject layerXML = handle.getLayerFile();\n        assertNotNull(\"layer.xml already exists\", layerXML);\n        assertEquals(\"right layer file\", expectedLayerXML, layerXML);\n        FileSystem fs = handle.layer(true);\n        assertEquals(\"initially empty\", 0, fs.getRoot().getChildren().length);\n        long initialSize = layerXML.getSize();\n        fs.getRoot().createData(\"foo\");\n        assertEquals(\"not saved yet\", initialSize, layerXML.getSize());\n        fs = handle.layer(true);\n        assertNotNull(\"still have in-memory mods\", fs.findResource(\"foo\"));\n        fs.getRoot().createData(\"bar\");\n        handle.save();\n        assertTrue(\"now it is saved\", layerXML.getSize() > initialSize);\n        String xml =\n                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<!DOCTYPE filesystem PUBLIC \\\"-\/\/NetBeans\/\/DTD Filesystem 1.2\/\/EN\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" +\n                \"<filesystem>\\n\" +\n                \"    <file name=\\\"bar\\\"\/>\\n\" +\n                \"    <file name=\\\"foo\\\"\/>\\n\" +\n                \"<\/filesystem>\\n\";\n        assertEquals(\"right contents too\", xml, TestBase.slurp(layerXML));\n       \n    }","cleancode":"public void testlayerhandle() throws exception { nbmoduleproject project = testbase.generatestandalonemodule(getworkdir(), \"module\"); layerhandle handle = layerhandle.forproject(project); fileobject expectedlayerxml = project.getprojectdirectory().getfileobject(\"src\/org\/example\/module\/resources\/layer.xml\"); assertnotnull(expectedlayerxml); fileobject layerxml = handle.getlayerfile(); assertnotnull(\"layer.xml already exists\", layerxml); assertequals(\"right layer file\", expectedlayerxml, layerxml); filesystem fs = handle.layer(true); assertequals(\"initially empty\", 0, fs.getroot().getchildren().length); long initialsize = layerxml.getsize(); fs.getroot().createdata(\"foo\"); assertequals(\"not saved yet\", initialsize, layerxml.getsize()); fs = handle.layer(true); assertnotnull(\"still have in-memory mods\", fs.findresource(\"foo\")); fs.getroot().createdata(\"bar\"); handle.save(); asserttrue(\"now it is saved\", layerxml.getsize() > initialsize); string xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\" + \"<!doctype filesystem public \\\"-\/\/netbeans\/\/dtd filesystem 1.2\/\/en\\\" \\\"http:\/\/www.netbeans.org\/dtds\/filesystem-1_2.dtd\\\">\\n\" + \"<filesystem>\\n\" + \" <file name=\\\"bar\\\"\/>\\n\" + \" <file name=\\\"foo\\\"\/>\\n\" + \"<\/filesystem>\\n\"; assertequals(\"right contents too\", xml, testbase.slurp(layerxml)); }","repo":"arusinha\/incubator-netbeans","label":[0,0,0,1]}
{"id":26391,"original_code":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n        \/\/null is easy\n        if (param == null) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\n                    return method.loadNull();\n                }\n            };\n        }\n        \/\/check the loaded object support (i.e. config) to see if this is a config item\n        DeferredParameter loadedObject = findLoaded(param);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n        \/\/Handle empty collections as returned by the Collections object\n        loadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n        \/\/create the appropriate DeferredParameter, a lot of these a fairly simple constant values,\n        \/\/but some are quite complex when dealing with objects and collections\n        if (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n            \/\/check for substitution types, if present we invoke recursively on the substitution\n            SubstitutionHolder holder = substitutions.get(param.getClass());\n            if (holder == null) {\n                holder = substitutions.get(expectedType);\n            }\n            try {\n                ObjectSubstitution substitution = holder.sub.newInstance();\n                Object res = substitution.serialize(param);\n                DeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\n                SubstitutionHolder finalHolder = holder;\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        serialized.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\n                        ResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\n                        return method.invokeInterfaceMethod(\n                                ofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\n                                creator.loadDeferred(serialized));\n                    }\n                };\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to substitute \" + param, e);\n            }\n        } else if (param instanceof Optional) {\n            Optional val = (Optional) param;\n            if (val.isPresent()) {\n                DeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        res.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\n                                context.loadDeferred(res));\n                    }\n                };\n            } else {\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n                    }\n                };\n            }\n        } else if (param instanceof String) {\n            if (((String) param).length() > 65535) {\n                throw new RuntimeException(\"String too large to record: \" + param);\n            }\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((String) param);\n                }\n            };\n        } else if (param instanceof Integer) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((Integer) param));\n                }\n            };\n        } else if (param instanceof Boolean) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((Boolean) param));\n                }\n            };\n        } else if (param instanceof URL) {\n            String url = ((URL) param).toExternalForm();\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    AssignableResultHandle value = method.createVariable(URL.class);\n                    try (TryBlock et = method.tryBlock()) {\n                        et.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\n                        try (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\n                            malformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n                        }\n                    }\n                    return value;\n                }\n            };\n        } else if (param instanceof Enum) {\n            Enum e = (Enum) param;\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    ResultHandle nm = method.load(e.name());\n                    return method.invokeStaticMethod(\n                            ofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\n                            nm);\n                }\n            };\n        } else if (param instanceof ReturnedProxy) {\n            \/\/if this is a proxy we just grab the value from the StartupContext\n            ReturnedProxy rp = (ReturnedProxy) param;\n            if (!rp.__static$$init() && staticInit) {\n                throw new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n            }\n            String proxyId = rp.__returned$proxy$key();\n            \/\/because this is the result of a method invocation that may not have happened at param deserialization time\n            \/\/we just load it from the startup context\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\n                            method.getMethodParam(0), method.load(proxyId));\n                }\n            };\n        } else if (param instanceof Duration) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\n                            method.load(param.toString()));\n                }\n            };\n        } else if (param instanceof Class<?>) {\n            if (!((Class) param).isPrimitive()) {\n                \/\/ Only try to load the class by name if it is not a primitive class\n                String name = classProxies.get(param);\n                if (name == null) {\n                    name = ((Class) param).getName();\n                }\n                String finalName = name;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        ResultHandle currentThread = method\n                                .invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\n                        ResultHandle tccl = method.invokeVirtualMethod(\n                                ofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\n                                currentThread);\n                        return method.invokeStaticMethod(\n                                ofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\n                                method.load(finalName), method.load(true), tccl);\n                    }\n                };\n            } else {\n                \/\/ Else load the primitive type by reference; double.class => Class var9 = Double.TYPE;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.loadClass((Class) param);\n                    }\n                };\n            }\n        } else if (expectedType == boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((boolean) param);\n                }\n            };\n        } else if (expectedType == Boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((boolean) param));\n                }\n            };\n        } else if (expectedType == int.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((int) param);\n                }\n            };\n        } else if (expectedType == Integer.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((int) param));\n                }\n            };\n        } else if (expectedType == short.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((short) param);\n                }\n            };\n        } else if (expectedType == Short.class || param instanceof Short) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\n                            method.load((short) param));\n                }\n            };\n        } else if (expectedType == byte.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((byte) param);\n                }\n            };\n        } else if (expectedType == Byte.class || param instanceof Byte) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\n                            method.load((byte) param));\n                }\n            };\n        } else if (expectedType == char.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((char) param);\n                }\n            };\n        } else if (expectedType == Character.class || param instanceof Character) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\n                            method.load((char) param));\n                }\n            };\n        } else if (expectedType == long.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((long) param);\n                }\n            };\n        } else if (expectedType == Long.class || param instanceof Long) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\n                            method.load((long) param));\n                }\n            };\n        } else if (expectedType == float.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((float) param);\n                }\n            };\n        } else if (expectedType == Float.class || param instanceof Float) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\n                            method.load((float) param));\n                }\n            };\n        } else if (expectedType == double.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((double) param);\n                }\n            };\n        } else if (expectedType == Double.class || param instanceof Double) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\n                            method.load((double) param));\n                }\n            };\n        } else if (expectedType.isArray()) {\n            int length = Array.getLength(param);\n            DeferredParameter[] components = new DeferredParameter[length];\n            for (int i = 0; i < length; ++i) {\n                DeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\n                        expectedType.getComponentType(), relaxedValidation);\n                components[i] = component;\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                void doPrepare(MethodContext context) {\n                    for (int i = 0; i < length; ++i) {\n                        components[i].prepare(context);\n                    }\n                    super.doPrepare(context);\n                }\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    \/\/TODO large arrays can still generate a fair bit of bytecode, and there appears to be a gizmo issue that prevents casting to an array\n                    \/\/fix this later\n                    ResultHandle out = method.newArray(expectedType.getComponentType(), length);\n                    for (int i = 0; i < length; ++i) {\n                        method.writeArrayValue(out, i, context.loadDeferred(components[i]));\n                    }\n                    return out;\n                }\n            };\n        } else if (param instanceof AnnotationProxy) {\n            \/\/ new com.foo.MyAnnotation_Proxy_AnnotationLiteral(\"foo\")\n            AnnotationProxy annotationProxy = (AnnotationProxy) param;\n            List<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n                    .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\n            Map<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n                    .collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\n            DeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\n            for (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\n                MethodInfo valueMethod = iterator.next();\n                Object explicitValue = annotationProxy.getValues().get(valueMethod.name());\n                if (explicitValue != null) {\n                    constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\n                            explicitValue.getClass(), relaxedValidation);\n                } else {\n                    AnnotationValue value = annotationValues.get(valueMethod.name());\n                    if (value == null) {\n                        \/\/ method.invokeInterfaceMethod(MAP_PUT, valuesHandle, method.load(entry.getKey()), loadObjectInstance(method, entry.getValue(),\n                        \/\/ returnValueResults, entry.getValue().getClass()));\n                        Object defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\n                        if (defaultValue != null) {\n                            constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\n                                    defaultValue.getClass(), relaxedValidation);\n                            continue;\n                        }\n                        if (value == null) {\n                            value = valueMethod.defaultValue();\n                        }\n                    }\n                    if (value == null) {\n                        throw new NullPointerException(\"Value not set for \" + param);\n                    }\n                    DeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\n                    constructorParamsHandles[iterator.previousIndex()] = retValue;\n                }\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    MethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\n                            constructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\n                    ResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\n                    for (int i = 0; i < constructorParamsHandles.length; i++) {\n                        DeferredParameter deferredParameter = constructorParamsHandles[i];\n                        if (deferredParameter instanceof DeferredArrayStoreParameter) {\n                            DeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\n                            arrayParam.doPrepare(context);\n                        }\n                        args[i] = context.loadDeferred(deferredParameter);\n                    }\n                    return method.newInstance(constructor, args);\n                }\n            };\n        } else {\n            return loadComplexObject(param, existing, expectedType, relaxedValidation);\n        }\n    }","code_wo_comment":"private DeferredParameter loadObjectInstanceImpl(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n       \n        if (param == null) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext creator, MethodCreator method, ResultHandle array) {\n                    return method.loadNull();\n                }\n            };\n        }\n       \n        DeferredParameter loadedObject = findLoaded(param);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n       \n        loadedObject = handleCollectionsObjects(param, existing, relaxedValidation);\n        if (loadedObject != null) {\n            return loadedObject;\n        }\n       \n       \n        if (substitutions.containsKey(param.getClass()) || substitutions.containsKey(expectedType)) {\n           \n            SubstitutionHolder holder = substitutions.get(param.getClass());\n            if (holder == null) {\n                holder = substitutions.get(expectedType);\n            }\n            try {\n                ObjectSubstitution substitution = holder.sub.newInstance();\n                Object res = substitution.serialize(param);\n                DeferredParameter serialized = loadObjectInstance(res, existing, holder.to, relaxedValidation);\n                SubstitutionHolder finalHolder = holder;\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        serialized.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext creator, MethodCreator method, ResultHandle array) {\n                        ResultHandle subInstance = method.newInstance(MethodDescriptor.ofConstructor(finalHolder.sub));\n                        return method.invokeInterfaceMethod(\n                                ofMethod(ObjectSubstitution.class, \"deserialize\", Object.class, Object.class), subInstance,\n                                creator.loadDeferred(serialized));\n                    }\n                };\n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to substitute \" + param, e);\n            }\n        } else if (param instanceof Optional) {\n            Optional val = (Optional) param;\n            if (val.isPresent()) {\n                DeferredParameter res = loadObjectInstance(val.get(), existing, Object.class, relaxedValidation);\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    void doPrepare(MethodContext context) {\n                        res.prepare(context);\n                        super.doPrepare(context);\n                    }\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"of\", Optional.class, Object.class),\n                                context.loadDeferred(res));\n                    }\n                };\n            } else {\n                return new DeferredArrayStoreParameter() {\n                    @Override\n                    ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.invokeStaticMethod(ofMethod(Optional.class, \"empty\", Optional.class));\n                    }\n                };\n            }\n        } else if (param instanceof String) {\n            if (((String) param).length() > 65535) {\n                throw new RuntimeException(\"String too large to record: \" + param);\n            }\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((String) param);\n                }\n            };\n        } else if (param instanceof Integer) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((Integer) param));\n                }\n            };\n        } else if (param instanceof Boolean) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((Boolean) param));\n                }\n            };\n        } else if (param instanceof URL) {\n            String url = ((URL) param).toExternalForm();\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    AssignableResultHandle value = method.createVariable(URL.class);\n                    try (TryBlock et = method.tryBlock()) {\n                        et.assign(value, et.newInstance(MethodDescriptor.ofConstructor(URL.class, String.class), et.load(url)));\n                        try (CatchBlockCreator malformed = et.addCatch(MalformedURLException.class)) {\n                            malformed.throwException(RuntimeException.class, \"Malformed URL\", malformed.getCaughtException());\n                        }\n                    }\n                    return value;\n                }\n            };\n        } else if (param instanceof Enum) {\n            Enum e = (Enum) param;\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    ResultHandle nm = method.load(e.name());\n                    return method.invokeStaticMethod(\n                            ofMethod(e.getDeclaringClass(), \"valueOf\", e.getDeclaringClass(), String.class),\n                            nm);\n                }\n            };\n        } else if (param instanceof ReturnedProxy) {\n           \n            ReturnedProxy rp = (ReturnedProxy) param;\n            if (!rp.__static$$init() && staticInit) {\n                throw new RuntimeException(\"Invalid proxy passed to recorder. \" + rp\n                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n            }\n            String proxyId = rp.__returned$proxy$key();\n           \n           \n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeVirtualMethod(ofMethod(StartupContext.class, \"getValue\", Object.class, String.class),\n                            method.getMethodParam(0), method.load(proxyId));\n                }\n            };\n        } else if (param instanceof Duration) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Duration.class, \"parse\", Duration.class, CharSequence.class),\n                            method.load(param.toString()));\n                }\n            };\n        } else if (param instanceof Class<?>) {\n            if (!((Class) param).isPrimitive()) {\n               \n                String name = classProxies.get(param);\n                if (name == null) {\n                    name = ((Class) param).getName();\n                }\n                String finalName = name;\n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        ResultHandle currentThread = method\n                                .invokeStaticMethod(ofMethod(Thread.class, \"currentThread\", Thread.class));\n                        ResultHandle tccl = method.invokeVirtualMethod(\n                                ofMethod(Thread.class, \"getContextClassLoader\", ClassLoader.class),\n                                currentThread);\n                        return method.invokeStaticMethod(\n                                ofMethod(Class.class, \"forName\", Class.class, String.class, boolean.class, ClassLoader.class),\n                                method.load(finalName), method.load(true), tccl);\n                    }\n                };\n            } else {\n               \n                return new DeferredParameter() {\n                    @Override\n                    ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                        return method.loadClass((Class) param);\n                    }\n                };\n            }\n        } else if (expectedType == boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((boolean) param);\n                }\n            };\n        } else if (expectedType == Boolean.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Boolean.class, \"valueOf\", Boolean.class, boolean.class),\n                            method.load((boolean) param));\n                }\n            };\n        } else if (expectedType == int.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((int) param);\n                }\n            };\n        } else if (expectedType == Integer.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Integer.class, \"valueOf\", Integer.class, int.class),\n                            method.load((int) param));\n                }\n            };\n        } else if (expectedType == short.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((short) param);\n                }\n            };\n        } else if (expectedType == Short.class || param instanceof Short) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Short.class, \"valueOf\", Short.class, short.class),\n                            method.load((short) param));\n                }\n            };\n        } else if (expectedType == byte.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((byte) param);\n                }\n            };\n        } else if (expectedType == Byte.class || param instanceof Byte) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Byte.class, \"valueOf\", Byte.class, byte.class),\n                            method.load((byte) param));\n                }\n            };\n        } else if (expectedType == char.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((char) param);\n                }\n            };\n        } else if (expectedType == Character.class || param instanceof Character) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Character.class, \"valueOf\", Character.class, char.class),\n                            method.load((char) param));\n                }\n            };\n        } else if (expectedType == long.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((long) param);\n                }\n            };\n        } else if (expectedType == Long.class || param instanceof Long) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Long.class, \"valueOf\", Long.class, long.class),\n                            method.load((long) param));\n                }\n            };\n        } else if (expectedType == float.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((float) param);\n                }\n            };\n        } else if (expectedType == Float.class || param instanceof Float) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Float.class, \"valueOf\", Float.class, float.class),\n                            method.load((float) param));\n                }\n            };\n        } else if (expectedType == double.class) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.load((double) param);\n                }\n            };\n        } else if (expectedType == Double.class || param instanceof Double) {\n            return new DeferredParameter() {\n                @Override\n                ResultHandle doLoad(MethodContext context, MethodCreator method, ResultHandle array) {\n                    return method.invokeStaticMethod(ofMethod(Double.class, \"valueOf\", Double.class, double.class),\n                            method.load((double) param));\n                }\n            };\n        } else if (expectedType.isArray()) {\n            int length = Array.getLength(param);\n            DeferredParameter[] components = new DeferredParameter[length];\n            for (int i = 0; i < length; ++i) {\n                DeferredParameter component = loadObjectInstance(Array.get(param, i), existing,\n                        expectedType.getComponentType(), relaxedValidation);\n                components[i] = component;\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                void doPrepare(MethodContext context) {\n                    for (int i = 0; i < length; ++i) {\n                        components[i].prepare(context);\n                    }\n                    super.doPrepare(context);\n                }\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                   \n                   \n                    ResultHandle out = method.newArray(expectedType.getComponentType(), length);\n                    for (int i = 0; i < length; ++i) {\n                        method.writeArrayValue(out, i, context.loadDeferred(components[i]));\n                    }\n                    return out;\n                }\n            };\n        } else if (param instanceof AnnotationProxy) {\n           \n            AnnotationProxy annotationProxy = (AnnotationProxy) param;\n            List<MethodInfo> constructorParams = annotationProxy.getAnnotationClass().methods().stream()\n                    .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(Collectors.toList());\n            Map<String, AnnotationValue> annotationValues = annotationProxy.getAnnotationInstance().values().stream()\n                    .collect(Collectors.toMap(AnnotationValue::name, Function.identity()));\n            DeferredParameter[] constructorParamsHandles = new DeferredParameter[constructorParams.size()];\n            for (ListIterator<MethodInfo> iterator = constructorParams.listIterator(); iterator.hasNext();) {\n                MethodInfo valueMethod = iterator.next();\n                Object explicitValue = annotationProxy.getValues().get(valueMethod.name());\n                if (explicitValue != null) {\n                    constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(explicitValue, existing,\n                            explicitValue.getClass(), relaxedValidation);\n                } else {\n                    AnnotationValue value = annotationValues.get(valueMethod.name());\n                    if (value == null) {\n                       \n                       \n                        Object defaultValue = annotationProxy.getDefaultValues().get(valueMethod.name());\n                        if (defaultValue != null) {\n                            constructorParamsHandles[iterator.previousIndex()] = loadObjectInstance(defaultValue, existing,\n                                    defaultValue.getClass(), relaxedValidation);\n                            continue;\n                        }\n                        if (value == null) {\n                            value = valueMethod.defaultValue();\n                        }\n                    }\n                    if (value == null) {\n                        throw new NullPointerException(\"Value not set for \" + param);\n                    }\n                    DeferredParameter retValue = loadValue(value, annotationProxy.getAnnotationClass(), valueMethod);\n                    constructorParamsHandles[iterator.previousIndex()] = retValue;\n                }\n            }\n            return new DeferredArrayStoreParameter() {\n                @Override\n                ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                    MethodDescriptor constructor = MethodDescriptor.ofConstructor(annotationProxy.getAnnotationLiteralType(),\n                            constructorParams.stream().map(m -> m.returnType().name().toString()).toArray());\n                    ResultHandle[] args = new ResultHandle[constructorParamsHandles.length];\n                    for (int i = 0; i < constructorParamsHandles.length; i++) {\n                        DeferredParameter deferredParameter = constructorParamsHandles[i];\n                        if (deferredParameter instanceof DeferredArrayStoreParameter) {\n                            DeferredArrayStoreParameter arrayParam = (DeferredArrayStoreParameter) deferredParameter;\n                            arrayParam.doPrepare(context);\n                        }\n                        args[i] = context.loadDeferred(deferredParameter);\n                    }\n                    return method.newInstance(constructor, args);\n                }\n            };\n        } else {\n            return loadComplexObject(param, existing, expectedType, relaxedValidation);\n        }\n    }","cleancode":"private deferredparameter loadobjectinstanceimpl(object param, map<object, deferredparameter> existing, class<?> expectedtype, boolean relaxedvalidation) { if (param == null) { return new deferredparameter() { @override resulthandle doload(methodcontext creator, methodcreator method, resulthandle array) { return method.loadnull(); } }; } deferredparameter loadedobject = findloaded(param); if (loadedobject != null) { return loadedobject; } loadedobject = handlecollectionsobjects(param, existing, relaxedvalidation); if (loadedobject != null) { return loadedobject; } if (substitutions.containskey(param.getclass()) || substitutions.containskey(expectedtype)) { substitutionholder holder = substitutions.get(param.getclass()); if (holder == null) { holder = substitutions.get(expectedtype); } try { objectsubstitution substitution = holder.sub.newinstance(); object res = substitution.serialize(param); deferredparameter serialized = loadobjectinstance(res, existing, holder.to, relaxedvalidation); substitutionholder finalholder = holder; return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { serialized.prepare(context); super.doprepare(context); } @override resulthandle createvalue(methodcontext creator, methodcreator method, resulthandle array) { resulthandle subinstance = method.newinstance(methoddescriptor.ofconstructor(finalholder.sub)); return method.invokeinterfacemethod( ofmethod(objectsubstitution.class, \"deserialize\", object.class, object.class), subinstance, creator.loaddeferred(serialized)); } }; } catch (exception e) { throw new runtimeexception(\"failed to substitute \" + param, e); } } else if (param instanceof optional) { optional val = (optional) param; if (val.ispresent()) { deferredparameter res = loadobjectinstance(val.get(), existing, object.class, relaxedvalidation); return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { res.prepare(context); super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(optional.class, \"of\", optional.class, object.class), context.loaddeferred(res)); } }; } else { return new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(optional.class, \"empty\", optional.class)); } }; } } else if (param instanceof string) { if (((string) param).length() > 65535) { throw new runtimeexception(\"string too large to record: \" + param); } return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((string) param); } }; } else if (param instanceof integer) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(integer.class, \"valueof\", integer.class, int.class), method.load((integer) param)); } }; } else if (param instanceof boolean) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(boolean.class, \"valueof\", boolean.class, boolean.class), method.load((boolean) param)); } }; } else if (param instanceof url) { string url = ((url) param).toexternalform(); return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { assignableresulthandle value = method.createvariable(url.class); try (tryblock et = method.tryblock()) { et.assign(value, et.newinstance(methoddescriptor.ofconstructor(url.class, string.class), et.load(url))); try (catchblockcreator malformed = et.addcatch(malformedurlexception.class)) { malformed.throwexception(runtimeexception.class, \"malformed url\", malformed.getcaughtexception()); } } return value; } }; } else if (param instanceof enum) { enum e = (enum) param; return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { resulthandle nm = method.load(e.name()); return method.invokestaticmethod( ofmethod(e.getdeclaringclass(), \"valueof\", e.getdeclaringclass(), string.class), nm); } }; } else if (param instanceof returnedproxy) { returnedproxy rp = (returnedproxy) param; if (!rp.__static$$init() && staticinit) { throw new runtimeexception(\"invalid proxy passed to recorder. \" + rp + \" was created in a runtime recorder method, while this recorder is for a static init method. the object will not have been created at the time this method is run.\"); } string proxyid = rp.__returned$proxy$key(); return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokevirtualmethod(ofmethod(startupcontext.class, \"getvalue\", object.class, string.class), method.getmethodparam(0), method.load(proxyid)); } }; } else if (param instanceof duration) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(duration.class, \"parse\", duration.class, charsequence.class), method.load(param.tostring())); } }; } else if (param instanceof class<?>) { if (!((class) param).isprimitive()) { string name = classproxies.get(param); if (name == null) { name = ((class) param).getname(); } string finalname = name; return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { resulthandle currentthread = method .invokestaticmethod(ofmethod(thread.class, \"currentthread\", thread.class)); resulthandle tccl = method.invokevirtualmethod( ofmethod(thread.class, \"getcontextclassloader\", classloader.class), currentthread); return method.invokestaticmethod( ofmethod(class.class, \"forname\", class.class, string.class, boolean.class, classloader.class), method.load(finalname), method.load(true), tccl); } }; } else { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.loadclass((class) param); } }; } } else if (expectedtype == boolean.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((boolean) param); } }; } else if (expectedtype == boolean.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(boolean.class, \"valueof\", boolean.class, boolean.class), method.load((boolean) param)); } }; } else if (expectedtype == int.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((int) param); } }; } else if (expectedtype == integer.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(integer.class, \"valueof\", integer.class, int.class), method.load((int) param)); } }; } else if (expectedtype == short.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((short) param); } }; } else if (expectedtype == short.class || param instanceof short) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(short.class, \"valueof\", short.class, short.class), method.load((short) param)); } }; } else if (expectedtype == byte.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((byte) param); } }; } else if (expectedtype == byte.class || param instanceof byte) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(byte.class, \"valueof\", byte.class, byte.class), method.load((byte) param)); } }; } else if (expectedtype == char.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((char) param); } }; } else if (expectedtype == character.class || param instanceof character) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(character.class, \"valueof\", character.class, char.class), method.load((char) param)); } }; } else if (expectedtype == long.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((long) param); } }; } else if (expectedtype == long.class || param instanceof long) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(long.class, \"valueof\", long.class, long.class), method.load((long) param)); } }; } else if (expectedtype == float.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((float) param); } }; } else if (expectedtype == float.class || param instanceof float) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(float.class, \"valueof\", float.class, float.class), method.load((float) param)); } }; } else if (expectedtype == double.class) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.load((double) param); } }; } else if (expectedtype == double.class || param instanceof double) { return new deferredparameter() { @override resulthandle doload(methodcontext context, methodcreator method, resulthandle array) { return method.invokestaticmethod(ofmethod(double.class, \"valueof\", double.class, double.class), method.load((double) param)); } }; } else if (expectedtype.isarray()) { int length = array.getlength(param); deferredparameter[] components = new deferredparameter[length]; for (int i = 0; i < length; ++i) { deferredparameter component = loadobjectinstance(array.get(param, i), existing, expectedtype.getcomponenttype(), relaxedvalidation); components[i] = component; } return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { for (int i = 0; i < length; ++i) { components[i].prepare(context); } super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { resulthandle out = method.newarray(expectedtype.getcomponenttype(), length); for (int i = 0; i < length; ++i) { method.writearrayvalue(out, i, context.loaddeferred(components[i])); } return out; } }; } else if (param instanceof annotationproxy) { annotationproxy annotationproxy = (annotationproxy) param; list<methodinfo> constructorparams = annotationproxy.getannotationclass().methods().stream() .filter(m -> !m.name().equals(\"<clinit>\") && !m.name().equals(\"<init>\")).collect(collectors.tolist()); map<string, annotationvalue> annotationvalues = annotationproxy.getannotationinstance().values().stream() .collect(collectors.tomap(annotationvalue::name, function.identity())); deferredparameter[] constructorparamshandles = new deferredparameter[constructorparams.size()]; for (listiterator<methodinfo> iterator = constructorparams.listiterator(); iterator.hasnext();) { methodinfo valuemethod = iterator.next(); object explicitvalue = annotationproxy.getvalues().get(valuemethod.name()); if (explicitvalue != null) { constructorparamshandles[iterator.previousindex()] = loadobjectinstance(explicitvalue, existing, explicitvalue.getclass(), relaxedvalidation); } else { annotationvalue value = annotationvalues.get(valuemethod.name()); if (value == null) { object defaultvalue = annotationproxy.getdefaultvalues().get(valuemethod.name()); if (defaultvalue != null) { constructorparamshandles[iterator.previousindex()] = loadobjectinstance(defaultvalue, existing, defaultvalue.getclass(), relaxedvalidation); continue; } if (value == null) { value = valuemethod.defaultvalue(); } } if (value == null) { throw new nullpointerexception(\"value not set for \" + param); } deferredparameter retvalue = loadvalue(value, annotationproxy.getannotationclass(), valuemethod); constructorparamshandles[iterator.previousindex()] = retvalue; } } return new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { methoddescriptor constructor = methoddescriptor.ofconstructor(annotationproxy.getannotationliteraltype(), constructorparams.stream().map(m -> m.returntype().name().tostring()).toarray()); resulthandle[] args = new resulthandle[constructorparamshandles.length]; for (int i = 0; i < constructorparamshandles.length; i++) { deferredparameter deferredparameter = constructorparamshandles[i]; if (deferredparameter instanceof deferredarraystoreparameter) { deferredarraystoreparameter arrayparam = (deferredarraystoreparameter) deferredparameter; arrayparam.doprepare(context); } args[i] = context.loaddeferred(deferredparameter); } return method.newinstance(constructor, args); } }; } else { return loadcomplexobject(param, existing, expectedtype, relaxedvalidation); } }","repo":"cdhermann\/quarkus","label":[0,0,1,0]}
{"id":26392,"original_code":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n        \/\/a list of steps that are performed on the object after it has been created\n        \/\/we need to create all these first, to ensure the required objects have already\n        \/\/been deserialized\n        List<SerialzationStep> setupSteps = new ArrayList<>();\n        List<SerialzationStep> ctorSetupSteps = new ArrayList<>();\n        boolean relaxedOk = false;\n        if (param instanceof Collection) {\n            \/\/if this is a collection we want to serialize every element\n            for (Object i : (Collection) param) {\n                DeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        \/\/each step can happen in a new method, so it is safe to do this\n                        method.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        \/\/handle the value serialization\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        if (param instanceof Map) {\n            \/\/map works the same as collection\n            for (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\n                DeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n                DeferredParameter val = i.getValue() != null\n                        ? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n                        : loadObjectInstance(null, existing, Object.class, relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        method.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\n                                context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        key.prepare(context);\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        \/\/check how the object is constructed\n        NonDefaultConstructorHolder nonDefaultConstructorHolder = null;\n        DeferredParameter[] nonDefaultConstructorHandles = null;\n        \/\/used to resolve the parameter position for @RecordableConstructor\n        Map<String, Integer> constructorParamNameMap = new HashMap<>();\n        if (nonDefaultConstructors.containsKey(param.getClass())) {\n            nonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\n            List<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\n            if (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\n                throw new RuntimeException(\"Unable to serialize \" + param\n                        + \" as the wrong number of parameters were generated for \"\n                        + nonDefaultConstructorHolder.constructor);\n            }\n            int count = 0;\n            nonDefaultConstructorHandles = new DeferredParameter[params.size()];\n            for (int i = 0; i < params.size(); i++) {\n                Object obj = params.get(i);\n                nonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\n                        nonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n            }\n        } else {\n            for (Constructor<?> ctor : param.getClass().getConstructors()) {\n                if (ctor.isAnnotationPresent(RecordableConstructor.class)) {\n                    nonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\n                    nonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\n                    for (int i = 0; i < ctor.getParameterCount(); ++i) {\n                        String name = ctor.getParameters()[i].getName();\n                        constructorParamNameMap.put(name, i);\n                    }\n                    break;\n                }\n            }\n        }\n        Set<String> handledProperties = new HashSet<>();\n        Property[] desc = PropertyUtils.getPropertyDescriptors(param);\n        for (Property i : desc) {\n            \/\/ check if the getter is ignored\n            if ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\n                continue;\n            }\n            \/\/ check if the matching field is ignored\n            try {\n                if (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\n                    continue;\n                }\n            } catch (NoSuchFieldException ignored) {\n            }\n            Integer ctorParamIndex = constructorParamNameMap.remove(i.name);\n            if (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\n                try {\n                    \/\/read only prop, we may still be able to do stuff with it if it is a collection\n                    if (Collection.class.isAssignableFrom(i.getPropertyType())) {\n                        \/\/special case, a collection with only a read method\n                        \/\/we assume we can just add to the connection\n                        handledProperties.add(i.getName());\n                        Collection propertyValue = (Collection) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            List<DeferredParameter> params = new ArrayList<>();\n                            for (Object c : propertyValue) {\n                                DeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\n                                params.add(toAdd);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    \/\/get the collection\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (DeferredParameter i : params) {\n                                        \/\/add the parameter\n                                        \/\/TODO: this is not guareded against large collections, probably not an issue in practice\n                                        method.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (DeferredParameter i : params) {\n                                        i.prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n                        \/\/special case, a map with only a read method\n                        \/\/we assume we can just add to the map\n                        \/\/similar to how collection works above\n                        handledProperties.add(i.getName());\n                        Map<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            Map<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\n                            for (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\n                                DeferredParameter key = loadObjectInstance(entry.getKey(), existing,\n                                        Object.class, relaxedValidation);\n                                DeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\n                                        relaxedValidation);\n                                def.put(key, val);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        method.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\n                                                context.loadDeferred(e.getValue()));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        e.getKey().prepare(context);\n                                        e.getValue().prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n                            && nonDefaultConstructorHolder == null) {\n                        \/\/check if there is actually a field with the name\n                        try {\n                            i.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\n                            throw new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n                                    + \"' as the property is read only\");\n                        } catch (NoSuchFieldException e) {\n                            \/\/if there is no underlying field then we ignore the property\n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n                \/\/normal javabean property\n                try {\n                    handledProperties.add(i.getName());\n                    Object propertyValue = i.read(param);\n                    if (propertyValue == null && ctorParamIndex == null) {\n                        \/\/we just assume properties are null by default\n                        \/\/TODO: is this a valid assumption? Should we check this by creating an instance?\n                        continue;\n                    }\n                    Class propertyType = i.getPropertyType();\n                    if (ctorParamIndex == null\n                            && i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\n                        if (relaxedValidation) {\n                            \/\/this is a weird situation where the reader and writer are different types\n                            \/\/we iterate and try and find a valid setter method for the type we have\n                            \/\/OpenAPI does some weird stuff like this\n                            for (Method m : param.getClass().getMethods()) {\n                                if (m.getName().equals(i.getWriteMethod().getName())) {\n                                    if (m.getParameterTypes().length > 0\n                                            && m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\n                                        propertyType = m.getParameterTypes()[0];\n                                        break;\n                                    }\n                                }\n                            }\n                        } else {\n                            throw new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n                                    + \" as setter and getters were different types\");\n                        }\n                    }\n                    DeferredParameter val = loadObjectInstance(propertyValue, existing,\n                            i.getPropertyType(), relaxedValidation);\n                    if (ctorParamIndex != null) {\n                        nonDefaultConstructorHandles[ctorParamIndex] = val;\n                        ctorSetupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    } else {\n                        Class finalPropertyType = propertyType;\n                        setupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                                method.invokeVirtualMethod(\n                                        ofMethod(param.getClass(), i.getWriteMethod().getName(),\n                                                i.getWriteMethod().getReturnType(),\n                                                finalPropertyType),\n                                        context.loadDeferred(out),\n                                        context.loadDeferred(val));\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        \/\/now handle accessible fields\n        for (Field field : param.getClass().getFields()) {\n            \/\/ check if the field is ignored\n            if (field.getAnnotation(IgnoreProperty.class) != null) {\n                continue;\n            }\n            if (!handledProperties.contains(field.getName())) {\n                Integer ctorParamIndex = constructorParamNameMap.remove(field.getName());\n                if ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n                        !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        DeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\n                                relaxedValidation);\n                        if (ctorParamIndex != null) {\n                            nonDefaultConstructorHandles[ctorParamIndex] = val;\n                            ctorSetupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        } else {\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    method.writeInstanceField(\n                                            FieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\n                                            context.loadDeferred(out),\n                                            context.loadDeferred(val));\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        }\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        }\n        if (!constructorParamNameMap.isEmpty()) {\n            throw new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n                    + \" could not read field values \" + constructorParamNameMap.keySet());\n        }\n        NonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\n        DeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n        \/\/create a deferred value to represet the object itself. This allows the creation to be split\n        \/\/over multiple methods, which is important if this is a large object\n        DeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                ResultHandle out;\n                \/\/do the creation\n                if (finalNonDefaultConstructorHolder != null) {\n                    out = method.newInstance(\n                            ofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\n                                    finalNonDefaultConstructorHolder.constructor.getParameterTypes()),\n                            Arrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n                                    .toArray(ResultHandle[]::new));\n                } else {\n                    try {\n                        param.getClass().getDeclaredConstructor();\n                        out = method.newInstance(ofConstructor(param.getClass()));\n                    } catch (NoSuchMethodException e) {\n                        \/\/fallback for collection types, such as unmodifiableMap\n                        if (SortedMap.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeMap.class));\n                        } else if (Map.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashMap.class));\n                        } else if (List.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(ArrayList.class));\n                        } else if (SortedSet.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeSet.class));\n                        } else if (Set.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashSet.class));\n                        } else {\n                            throw new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n                                    + \" to bytecode as it has no default constructor\");\n                        }\n                    }\n                }\n                return out;\n            }\n        };\n        \/\/now return the actual deferred parameter that represents the result of construction\n        return new DeferredArrayStoreParameter() {\n            @Override\n            void doPrepare(MethodContext context) {\n                \/\/this is where the object construction happens\n                \/\/first create the actial object\n                for (SerialzationStep i : ctorSetupSteps) {\n                    i.prepare(context);\n                }\n                objectValue.prepare(context);\n                for (SerialzationStep i : setupSteps) {\n                    \/\/then prepare the steps (i.e. creating the values to be placed into this object)\n                    i.prepare(context);\n                }\n                for (SerialzationStep i : setupSteps) {\n                    \/\/now actually run the steps (i.e. actually stick the values into the object)\n                    context.writeInstruction(new InstructionGroup() {\n                        @Override\n                        public void write(MethodContext context, MethodCreator method, ResultHandle array) {\n                            i.handle(context, method, objectValue);\n                        }\n                    });\n                }\n                super.doPrepare(context);\n            }\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                \/\/just return the already created object\n                return context.loadDeferred(objectValue);\n            }\n        };\n    }","code_wo_comment":"private DeferredParameter loadComplexObject(Object param, Map<Object, DeferredParameter> existing,\n            Class<?> expectedType, boolean relaxedValidation) {\n       \n       \n       \n        List<SerialzationStep> setupSteps = new ArrayList<>();\n        List<SerialzationStep> ctorSetupSteps = new ArrayList<>();\n        boolean relaxedOk = false;\n        if (param instanceof Collection) {\n           \n            for (Object i : (Collection) param) {\n                DeferredParameter val = loadObjectInstance(i, existing, i.getClass(), relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                       \n                        method.invokeInterfaceMethod(COLLECTION_ADD, context.loadDeferred(out), context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                       \n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n        if (param instanceof Map) {\n           \n            for (Map.Entry<?, ?> i : ((Map<?, ?>) param).entrySet()) {\n                DeferredParameter key = loadObjectInstance(i.getKey(), existing, i.getKey().getClass(), relaxedValidation);\n                DeferredParameter val = i.getValue() != null\n                        ? loadObjectInstance(i.getValue(), existing, i.getValue().getClass(), relaxedValidation)\n                        : loadObjectInstance(null, existing, Object.class, relaxedValidation);\n                setupSteps.add(new SerialzationStep() {\n                    @Override\n                    public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                        method.invokeInterfaceMethod(MAP_PUT, context.loadDeferred(out), context.loadDeferred(key),\n                                context.loadDeferred(val));\n                    }\n                    @Override\n                    public void prepare(MethodContext context) {\n                        key.prepare(context);\n                        val.prepare(context);\n                    }\n                });\n            }\n            relaxedOk = true;\n        }\n       \n        NonDefaultConstructorHolder nonDefaultConstructorHolder = null;\n        DeferredParameter[] nonDefaultConstructorHandles = null;\n       \n        Map<String, Integer> constructorParamNameMap = new HashMap<>();\n        if (nonDefaultConstructors.containsKey(param.getClass())) {\n            nonDefaultConstructorHolder = nonDefaultConstructors.get(param.getClass());\n            List<Object> params = nonDefaultConstructorHolder.paramGenerator.apply(param);\n            if (params.size() != nonDefaultConstructorHolder.constructor.getParameterCount()) {\n                throw new RuntimeException(\"Unable to serialize \" + param\n                        + \" as the wrong number of parameters were generated for \"\n                        + nonDefaultConstructorHolder.constructor);\n            }\n            int count = 0;\n            nonDefaultConstructorHandles = new DeferredParameter[params.size()];\n            for (int i = 0; i < params.size(); i++) {\n                Object obj = params.get(i);\n                nonDefaultConstructorHandles[i] = loadObjectInstance(obj, existing,\n                        nonDefaultConstructorHolder.constructor.getParameterTypes()[count++], relaxedValidation);\n            }\n        } else {\n            for (Constructor<?> ctor : param.getClass().getConstructors()) {\n                if (ctor.isAnnotationPresent(RecordableConstructor.class)) {\n                    nonDefaultConstructorHolder = new NonDefaultConstructorHolder(ctor, null);\n                    nonDefaultConstructorHandles = new DeferredParameter[ctor.getParameterCount()];\n                    for (int i = 0; i < ctor.getParameterCount(); ++i) {\n                        String name = ctor.getParameters()[i].getName();\n                        constructorParamNameMap.put(name, i);\n                    }\n                    break;\n                }\n            }\n        }\n        Set<String> handledProperties = new HashSet<>();\n        Property[] desc = PropertyUtils.getPropertyDescriptors(param);\n        for (Property i : desc) {\n           \n            if ((i.getReadMethod() != null) && (i.getReadMethod().getAnnotation(IgnoreProperty.class) != null)) {\n                continue;\n            }\n           \n            try {\n                if (param.getClass().getDeclaredField(i.getName()).getAnnotation(IgnoreProperty.class) != null) {\n                    continue;\n                }\n            } catch (NoSuchFieldException ignored) {\n            }\n            Integer ctorParamIndex = constructorParamNameMap.remove(i.name);\n            if (i.getReadMethod() != null && i.getWriteMethod() == null && ctorParamIndex == null) {\n                try {\n                   \n                    if (Collection.class.isAssignableFrom(i.getPropertyType())) {\n                       \n                       \n                        handledProperties.add(i.getName());\n                        Collection propertyValue = (Collection) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            List<DeferredParameter> params = new ArrayList<>();\n                            for (Object c : propertyValue) {\n                                DeferredParameter toAdd = loadObjectInstance(c, existing, Object.class, relaxedValidation);\n                                params.add(toAdd);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                   \n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (DeferredParameter i : params) {\n                                       \n                                       \n                                        method.invokeInterfaceMethod(COLLECTION_ADD, prop, context.loadDeferred(i));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (DeferredParameter i : params) {\n                                        i.prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (Map.class.isAssignableFrom(i.getPropertyType())) {\n                       \n                       \n                       \n                        handledProperties.add(i.getName());\n                        Map<Object, Object> propertyValue = (Map<Object, Object>) i.read(param);\n                        if (propertyValue != null && !propertyValue.isEmpty()) {\n                            Map<DeferredParameter, DeferredParameter> def = new LinkedHashMap<>();\n                            for (Map.Entry<Object, Object> entry : propertyValue.entrySet()) {\n                                DeferredParameter key = loadObjectInstance(entry.getKey(), existing,\n                                        Object.class, relaxedValidation);\n                                DeferredParameter val = loadObjectInstance(entry.getValue(), existing, Object.class,\n                                        relaxedValidation);\n                                def.put(key, val);\n                            }\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    ResultHandle prop = method.invokeVirtualMethod(\n                                            MethodDescriptor.ofMethod(i.getReadMethod()),\n                                            context.loadDeferred(out));\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        method.invokeInterfaceMethod(MAP_PUT, prop, context.loadDeferred(e.getKey()),\n                                                context.loadDeferred(e.getValue()));\n                                    }\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    for (Map.Entry<DeferredParameter, DeferredParameter> e : def.entrySet()) {\n                                        e.getKey().prepare(context);\n                                        e.getValue().prepare(context);\n                                    }\n                                }\n                            });\n                        }\n                    } else if (!relaxedValidation && !i.getName().equals(\"class\") && !relaxedOk\n                            && nonDefaultConstructorHolder == null) {\n                       \n                        try {\n                            i.getReadMethod().getDeclaringClass().getDeclaredField(i.getName());\n                            throw new RuntimeException(\"Cannot serialise field '\" + i.getName() + \"' on object '\" + param\n                                    + \"' as the property is read only\");\n                        } catch (NoSuchFieldException e) {\n                           \n                        }\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (i.getReadMethod() != null && (i.getWriteMethod() != null || ctorParamIndex != null)) {\n               \n                try {\n                    handledProperties.add(i.getName());\n                    Object propertyValue = i.read(param);\n                    if (propertyValue == null && ctorParamIndex == null) {\n                       \n                       \n                        continue;\n                    }\n                    Class propertyType = i.getPropertyType();\n                    if (ctorParamIndex == null\n                            && i.getReadMethod().getReturnType() != i.getWriteMethod().getParameterTypes()[0]) {\n                        if (relaxedValidation) {\n                           \n                           \n                           \n                            for (Method m : param.getClass().getMethods()) {\n                                if (m.getName().equals(i.getWriteMethod().getName())) {\n                                    if (m.getParameterTypes().length > 0\n                                            && m.getParameterTypes()[0].isAssignableFrom(param.getClass())) {\n                                        propertyType = m.getParameterTypes()[0];\n                                        break;\n                                    }\n                                }\n                            }\n                        } else {\n                            throw new RuntimeException(\"Cannot serialise field \" + i.getName() + \" on object \" + param\n                                    + \" as setter and getters were different types\");\n                        }\n                    }\n                    DeferredParameter val = loadObjectInstance(propertyValue, existing,\n                            i.getPropertyType(), relaxedValidation);\n                    if (ctorParamIndex != null) {\n                        nonDefaultConstructorHandles[ctorParamIndex] = val;\n                        ctorSetupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    } else {\n                        Class finalPropertyType = propertyType;\n                        setupSteps.add(new SerialzationStep() {\n                            @Override\n                            public void handle(MethodContext context, MethodCreator method, DeferredArrayStoreParameter out) {\n                                method.invokeVirtualMethod(\n                                        ofMethod(param.getClass(), i.getWriteMethod().getName(),\n                                                i.getWriteMethod().getReturnType(),\n                                                finalPropertyType),\n                                        context.loadDeferred(out),\n                                        context.loadDeferred(val));\n                            }\n                            @Override\n                            public void prepare(MethodContext context) {\n                                val.prepare(context);\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n       \n        for (Field field : param.getClass().getFields()) {\n           \n            if (field.getAnnotation(IgnoreProperty.class) != null) {\n                continue;\n            }\n            if (!handledProperties.contains(field.getName())) {\n                Integer ctorParamIndex = constructorParamNameMap.remove(field.getName());\n                if ((ctorParamIndex != null || !Modifier.isFinal(field.getModifiers())) &&\n                        !Modifier.isStatic(field.getModifiers())) {\n                    try {\n                        DeferredParameter val = loadObjectInstance(field.get(param), existing, field.getType(),\n                                relaxedValidation);\n                        if (ctorParamIndex != null) {\n                            nonDefaultConstructorHandles[ctorParamIndex] = val;\n                            ctorSetupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        } else {\n                            setupSteps.add(new SerialzationStep() {\n                                @Override\n                                public void handle(MethodContext context, MethodCreator method,\n                                        DeferredArrayStoreParameter out) {\n                                    method.writeInstanceField(\n                                            FieldDescriptor.of(param.getClass(), field.getName(), field.getType()),\n                                            context.loadDeferred(out),\n                                            context.loadDeferred(val));\n                                }\n                                @Override\n                                public void prepare(MethodContext context) {\n                                    val.prepare(context);\n                                }\n                            });\n                        }\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        }\n        if (!constructorParamNameMap.isEmpty()) {\n            throw new RuntimeException(\"Could not find parameters for constructor \" + nonDefaultConstructorHolder.constructor\n                    + \" could not read field values \" + constructorParamNameMap.keySet());\n        }\n        NonDefaultConstructorHolder finalNonDefaultConstructorHolder = nonDefaultConstructorHolder;\n        DeferredParameter[] finalCtorHandles = nonDefaultConstructorHandles;\n       \n       \n        DeferredArrayStoreParameter objectValue = new DeferredArrayStoreParameter() {\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n                ResultHandle out;\n               \n                if (finalNonDefaultConstructorHolder != null) {\n                    out = method.newInstance(\n                            ofConstructor(finalNonDefaultConstructorHolder.constructor.getDeclaringClass(),\n                                    finalNonDefaultConstructorHolder.constructor.getParameterTypes()),\n                            Arrays.stream(finalCtorHandles).map(m -> context.loadDeferred(m))\n                                    .toArray(ResultHandle[]::new));\n                } else {\n                    try {\n                        param.getClass().getDeclaredConstructor();\n                        out = method.newInstance(ofConstructor(param.getClass()));\n                    } catch (NoSuchMethodException e) {\n                       \n                        if (SortedMap.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeMap.class));\n                        } else if (Map.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashMap.class));\n                        } else if (List.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(ArrayList.class));\n                        } else if (SortedSet.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(TreeSet.class));\n                        } else if (Set.class.isAssignableFrom(expectedType)) {\n                            out = method.newInstance(ofConstructor(LinkedHashSet.class));\n                        } else {\n                            throw new RuntimeException(\"Unable to serialize objects of type \" + param.getClass()\n                                    + \" to bytecode as it has no default constructor\");\n                        }\n                    }\n                }\n                return out;\n            }\n        };\n       \n        return new DeferredArrayStoreParameter() {\n            @Override\n            void doPrepare(MethodContext context) {\n               \n               \n                for (SerialzationStep i : ctorSetupSteps) {\n                    i.prepare(context);\n                }\n                objectValue.prepare(context);\n                for (SerialzationStep i : setupSteps) {\n                   \n                    i.prepare(context);\n                }\n                for (SerialzationStep i : setupSteps) {\n                   \n                    context.writeInstruction(new InstructionGroup() {\n                        @Override\n                        public void write(MethodContext context, MethodCreator method, ResultHandle array) {\n                            i.handle(context, method, objectValue);\n                        }\n                    });\n                }\n                super.doPrepare(context);\n            }\n            @Override\n            ResultHandle createValue(MethodContext context, MethodCreator method, ResultHandle array) {\n               \n                return context.loadDeferred(objectValue);\n            }\n        };\n    }","cleancode":"private deferredparameter loadcomplexobject(object param, map<object, deferredparameter> existing, class<?> expectedtype, boolean relaxedvalidation) { list<serialzationstep> setupsteps = new arraylist<>(); list<serialzationstep> ctorsetupsteps = new arraylist<>(); boolean relaxedok = false; if (param instanceof collection) { for (object i : (collection) param) { deferredparameter val = loadobjectinstance(i, existing, i.getclass(), relaxedvalidation); setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokeinterfacemethod(collection_add, context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } relaxedok = true; } if (param instanceof map) { for (map.entry<?, ?> i : ((map<?, ?>) param).entryset()) { deferredparameter key = loadobjectinstance(i.getkey(), existing, i.getkey().getclass(), relaxedvalidation); deferredparameter val = i.getvalue() != null ? loadobjectinstance(i.getvalue(), existing, i.getvalue().getclass(), relaxedvalidation) : loadobjectinstance(null, existing, object.class, relaxedvalidation); setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokeinterfacemethod(map_put, context.loaddeferred(out), context.loaddeferred(key), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { key.prepare(context); val.prepare(context); } }); } relaxedok = true; } nondefaultconstructorholder nondefaultconstructorholder = null; deferredparameter[] nondefaultconstructorhandles = null; map<string, integer> constructorparamnamemap = new hashmap<>(); if (nondefaultconstructors.containskey(param.getclass())) { nondefaultconstructorholder = nondefaultconstructors.get(param.getclass()); list<object> params = nondefaultconstructorholder.paramgenerator.apply(param); if (params.size() != nondefaultconstructorholder.constructor.getparametercount()) { throw new runtimeexception(\"unable to serialize \" + param + \" as the wrong number of parameters were generated for \" + nondefaultconstructorholder.constructor); } int count = 0; nondefaultconstructorhandles = new deferredparameter[params.size()]; for (int i = 0; i < params.size(); i++) { object obj = params.get(i); nondefaultconstructorhandles[i] = loadobjectinstance(obj, existing, nondefaultconstructorholder.constructor.getparametertypes()[count++], relaxedvalidation); } } else { for (constructor<?> ctor : param.getclass().getconstructors()) { if (ctor.isannotationpresent(recordableconstructor.class)) { nondefaultconstructorholder = new nondefaultconstructorholder(ctor, null); nondefaultconstructorhandles = new deferredparameter[ctor.getparametercount()]; for (int i = 0; i < ctor.getparametercount(); ++i) { string name = ctor.getparameters()[i].getname(); constructorparamnamemap.put(name, i); } break; } } } set<string> handledproperties = new hashset<>(); property[] desc = propertyutils.getpropertydescriptors(param); for (property i : desc) { if ((i.getreadmethod() != null) && (i.getreadmethod().getannotation(ignoreproperty.class) != null)) { continue; } try { if (param.getclass().getdeclaredfield(i.getname()).getannotation(ignoreproperty.class) != null) { continue; } } catch (nosuchfieldexception ignored) { } integer ctorparamindex = constructorparamnamemap.remove(i.name); if (i.getreadmethod() != null && i.getwritemethod() == null && ctorparamindex == null) { try { if (collection.class.isassignablefrom(i.getpropertytype())) { handledproperties.add(i.getname()); collection propertyvalue = (collection) i.read(param); if (propertyvalue != null && !propertyvalue.isempty()) { list<deferredparameter> params = new arraylist<>(); for (object c : propertyvalue) { deferredparameter toadd = loadobjectinstance(c, existing, object.class, relaxedvalidation); params.add(toadd); } setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { resulthandle prop = method.invokevirtualmethod( methoddescriptor.ofmethod(i.getreadmethod()), context.loaddeferred(out)); for (deferredparameter i : params) { method.invokeinterfacemethod(collection_add, prop, context.loaddeferred(i)); } } @override public void prepare(methodcontext context) { for (deferredparameter i : params) { i.prepare(context); } } }); } } else if (map.class.isassignablefrom(i.getpropertytype())) { handledproperties.add(i.getname()); map<object, object> propertyvalue = (map<object, object>) i.read(param); if (propertyvalue != null && !propertyvalue.isempty()) { map<deferredparameter, deferredparameter> def = new linkedhashmap<>(); for (map.entry<object, object> entry : propertyvalue.entryset()) { deferredparameter key = loadobjectinstance(entry.getkey(), existing, object.class, relaxedvalidation); deferredparameter val = loadobjectinstance(entry.getvalue(), existing, object.class, relaxedvalidation); def.put(key, val); } setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { resulthandle prop = method.invokevirtualmethod( methoddescriptor.ofmethod(i.getreadmethod()), context.loaddeferred(out)); for (map.entry<deferredparameter, deferredparameter> e : def.entryset()) { method.invokeinterfacemethod(map_put, prop, context.loaddeferred(e.getkey()), context.loaddeferred(e.getvalue())); } } @override public void prepare(methodcontext context) { for (map.entry<deferredparameter, deferredparameter> e : def.entryset()) { e.getkey().prepare(context); e.getvalue().prepare(context); } } }); } } else if (!relaxedvalidation && !i.getname().equals(\"class\") && !relaxedok && nondefaultconstructorholder == null) { try { i.getreadmethod().getdeclaringclass().getdeclaredfield(i.getname()); throw new runtimeexception(\"cannot serialise field '\" + i.getname() + \"' on object '\" + param + \"' as the property is read only\"); } catch (nosuchfieldexception e) { } } } catch (exception e) { throw new runtimeexception(e); } } else if (i.getreadmethod() != null && (i.getwritemethod() != null || ctorparamindex != null)) { try { handledproperties.add(i.getname()); object propertyvalue = i.read(param); if (propertyvalue == null && ctorparamindex == null) { continue; } class propertytype = i.getpropertytype(); if (ctorparamindex == null && i.getreadmethod().getreturntype() != i.getwritemethod().getparametertypes()[0]) { if (relaxedvalidation) { for (method m : param.getclass().getmethods()) { if (m.getname().equals(i.getwritemethod().getname())) { if (m.getparametertypes().length > 0 && m.getparametertypes()[0].isassignablefrom(param.getclass())) { propertytype = m.getparametertypes()[0]; break; } } } } else { throw new runtimeexception(\"cannot serialise field \" + i.getname() + \" on object \" + param + \" as setter and getters were different types\"); } } deferredparameter val = loadobjectinstance(propertyvalue, existing, i.getpropertytype(), relaxedvalidation); if (ctorparamindex != null) { nondefaultconstructorhandles[ctorparamindex] = val; ctorsetupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { } @override public void prepare(methodcontext context) { val.prepare(context); } }); } else { class finalpropertytype = propertytype; setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.invokevirtualmethod( ofmethod(param.getclass(), i.getwritemethod().getname(), i.getwritemethod().getreturntype(), finalpropertytype), context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } } catch (exception e) { throw new runtimeexception(e); } } } for (field field : param.getclass().getfields()) { if (field.getannotation(ignoreproperty.class) != null) { continue; } if (!handledproperties.contains(field.getname())) { integer ctorparamindex = constructorparamnamemap.remove(field.getname()); if ((ctorparamindex != null || !modifier.isfinal(field.getmodifiers())) && !modifier.isstatic(field.getmodifiers())) { try { deferredparameter val = loadobjectinstance(field.get(param), existing, field.gettype(), relaxedvalidation); if (ctorparamindex != null) { nondefaultconstructorhandles[ctorparamindex] = val; ctorsetupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { } @override public void prepare(methodcontext context) { val.prepare(context); } }); } else { setupsteps.add(new serialzationstep() { @override public void handle(methodcontext context, methodcreator method, deferredarraystoreparameter out) { method.writeinstancefield( fielddescriptor.of(param.getclass(), field.getname(), field.gettype()), context.loaddeferred(out), context.loaddeferred(val)); } @override public void prepare(methodcontext context) { val.prepare(context); } }); } } catch (exception e) { throw new runtimeexception(e); } } } } if (!constructorparamnamemap.isempty()) { throw new runtimeexception(\"could not find parameters for constructor \" + nondefaultconstructorholder.constructor + \" could not read field values \" + constructorparamnamemap.keyset()); } nondefaultconstructorholder finalnondefaultconstructorholder = nondefaultconstructorholder; deferredparameter[] finalctorhandles = nondefaultconstructorhandles; deferredarraystoreparameter objectvalue = new deferredarraystoreparameter() { @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { resulthandle out; if (finalnondefaultconstructorholder != null) { out = method.newinstance( ofconstructor(finalnondefaultconstructorholder.constructor.getdeclaringclass(), finalnondefaultconstructorholder.constructor.getparametertypes()), arrays.stream(finalctorhandles).map(m -> context.loaddeferred(m)) .toarray(resulthandle[]::new)); } else { try { param.getclass().getdeclaredconstructor(); out = method.newinstance(ofconstructor(param.getclass())); } catch (nosuchmethodexception e) { if (sortedmap.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(treemap.class)); } else if (map.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(linkedhashmap.class)); } else if (list.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(arraylist.class)); } else if (sortedset.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(treeset.class)); } else if (set.class.isassignablefrom(expectedtype)) { out = method.newinstance(ofconstructor(linkedhashset.class)); } else { throw new runtimeexception(\"unable to serialize objects of type \" + param.getclass() + \" to bytecode as it has no default constructor\"); } } } return out; } }; return new deferredarraystoreparameter() { @override void doprepare(methodcontext context) { for (serialzationstep i : ctorsetupsteps) { i.prepare(context); } objectvalue.prepare(context); for (serialzationstep i : setupsteps) { i.prepare(context); } for (serialzationstep i : setupsteps) { context.writeinstruction(new instructiongroup() { @override public void write(methodcontext context, methodcreator method, resulthandle array) { i.handle(context, method, objectvalue); } }); } super.doprepare(context); } @override resulthandle createvalue(methodcontext context, methodcreator method, resulthandle array) { return context.loaddeferred(objectvalue); } }; }","repo":"cdhermann\/quarkus","label":[1,1,0,0]}
{"id":34583,"original_code":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n        \/\/ prompt may be null\n        \/\/ mask may be null\n        \/\/ buffer may be null\n        \/*\n         * This is the accumulator for VI-mode repeat count. That is, while in\n         * move mode, if you type 30x it will delete 30 characters. This is\n         * where the \"30\" is accumulated until the command is struck.\n         *\/\n        int repeatCount = 0;\n        \/\/ FIXME: This blows, each call to readLine will reset the console's state which doesn't seem very nice.\n        this.mask = mask != null ? mask : this.echoCharacter;\n        if (prompt != null) {\n            setPrompt(prompt);\n        }\n        else {\n            prompt = getPrompt();\n        }\n        try {\n            if (buffer != null) {\n                buf.write(buffer);\n            }\n            if (!terminal.isSupported()) {\n                beforeReadLine(prompt, mask);\n            }\n            if (buffer != null && buffer.length() > 0\n                    || prompt != null && prompt.length() > 0) {\n                drawLine();\n                out.flush();\n            }\n            \/\/ if the terminal is unsupported, just use plain-java reading\n            if (!terminal.isSupported()) {\n                return readLineSimple();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableInterruptCharacter();\n            }\n            if (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableLitteralNextCharacter();\n            }\n            String originalPrompt = this.prompt;\n            state = State.NORMAL;\n            boolean success = true;\n            pushBackChar.clear();\n            while (true) {\n                Object o = readBinding(getKeys());\n                if (o == null) {\n                    return null;\n                }\n                int c = 0;\n                if (opBuffer.length() > 0) {\n                    c = opBuffer.codePointBefore(opBuffer.length());\n                }\n                Log.trace(\"Binding: \", o);\n                \/\/ Handle macros\n                if (o instanceof String) {\n                    String macro = (String) o;\n                    for (int i = 0; i < macro.length(); i++) {\n                        pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                    }\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                \/\/ Handle custom callbacks\n                if (o instanceof ActionListener) {\n                    ((ActionListener) o).actionPerformed(null);\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                CursorBuffer oldBuf = new CursorBuffer();\n                oldBuf.buffer.append(buf.buffer);\n                oldBuf.cursor = buf.cursor;\n                \/\/ Search mode.\n                \/\/\n                \/\/ Note that we have to do this first, because if there is a command\n                \/\/ not linked to a search command, we leave the search mode and fall\n                \/\/ through to the normal state.\n                if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                    int cursorDest = -1;\n                    \/\/ TODO: check the isearch-terminators variable terminating the search\n                    switch ( ((Operation) o )) {\n                        case ABORT:\n                            state = State.NORMAL;\n                            buf.clear();\n                            buf.write(originalBuffer.buffer);\n                            buf.cursor = originalBuffer.cursor;\n                            break;\n                        case REVERSE_SEARCH_HISTORY:\n                            state = State.SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > 0) {\n                                searchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case FORWARD_SEARCH_HISTORY:\n                            state = State.FORWARD_SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > -1 && searchIndex < history.size() - 1) {\n                                searchIndex = searchForwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case BACKWARD_DELETE_CHAR:\n                            if (searchTerm.length() > 0) {\n                                searchTerm.deleteCharAt(searchTerm.length() - 1);\n                                if (state == State.SEARCH) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                } else {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                }\n                            }\n                            break;\n                        case SELF_INSERT:\n                            searchTerm.appendCodePoint(c);\n                            if (state == State.SEARCH) {\n                                searchIndex = searchBackwards(searchTerm.toString());\n                            } else {\n                                searchIndex = searchForwards(searchTerm.toString());\n                            }\n                            break;\n                        default:\n                            \/\/ Set buffer and cursor position to the found string.\n                            if (searchIndex != -1) {\n                                history.moveTo(searchIndex);\n                                \/\/ set cursor position to the found string\n                                cursorDest = history.current().toString().indexOf(searchTerm.toString());\n                            }\n                            if (o != Operation.ACCEPT_LINE) {\n                                o = null;\n                            }\n                            state = State.NORMAL;\n                            break;\n                    }\n                    \/\/ if we're still in search mode, print the search status\n                    if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                        if (searchTerm.length() == 0) {\n                            if (state == State.SEARCH) {\n                                printSearchStatus(\"\", \"\");\n                            } else {\n                                printForwardSearchStatus(\"\", \"\");\n                            }\n                            searchIndex = -1;\n                        } else {\n                            if (searchIndex == -1) {\n                                beep();\n                                printSearchStatus(searchTerm.toString(), \"\");\n                            } else if (state == State.SEARCH) {\n                                printSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            } else {\n                                printForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            }\n                        }\n                    }\n                    \/\/ otherwise, restore the line\n                    else {\n                        restoreLine(originalPrompt, cursorDest);\n                    }\n                }\n                if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                    \/*\n                     * If this is still false at the end of the switch, then\n                     * we reset our repeatCount to 0.\n                     *\/\n                    boolean isArgDigit = false;\n                    \/*\n                     * Every command that can be repeated a specified number\n                     * of times, needs to know how many times to repeat, so\n                     * we figure that out here.\n                     *\/\n                    int count = (repeatCount == 0) ? 1 : repeatCount;\n                    \/*\n                     * Default success to true. You only need to explicitly\n                     * set it if something goes wrong.\n                     *\/\n                    success = true;\n                    if (o instanceof Operation) {\n                        Operation op = (Operation)o;\n                        \/*\n                         * Current location of the cursor (prior to the operation).\n                         * These are used by vi *-to operation (e.g. delete-to)\n                         * so we know where we came from.\n                         *\/\n                        int     cursorStart = buf.cursor;\n                        State   origState   = state;\n                        \/*\n                         * If we are on a \"vi\" movement based operation, then we\n                         * need to restrict the sets of inputs pretty heavily.\n                         *\/\n                        if (state == State.VI_CHANGE_TO\n                            || state == State.VI_YANK_TO\n                            || state == State.VI_DELETE_TO) {\n                            op = viDeleteChangeYankToRemap(op);\n                        }\n                        switch ( op ) {\n                            case COMPLETE: \/\/ tab\n                                \/\/ There is an annoyance with tab completion in that\n                                \/\/ sometimes the user is actually pasting input in that\n                                \/\/ has physical tabs in it.  This attempts to look at how\n                                \/\/ quickly a character follows the tab, if the character\n                                \/\/ follows *immediately*, we assume it is a tab literal.\n                                boolean isTabLiteral = false;\n                                if (copyPasteDetection\n                                    && c == 9\n                                    && (!pushBackChar.isEmpty()\n                                        || (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\n                                    isTabLiteral = true;\n                                }\n                                if (! isTabLiteral) {\n                                    success = complete();\n                                }\n                                else {\n                                    putString(opBuffer);\n                                }\n                                break;\n                            case POSSIBLE_COMPLETIONS:\n                                printCompletionCandidates();\n                                break;\n                            case BEGINNING_OF_LINE:\n                                success = setCursorPosition(0);\n                                break;\n                            case YANK:\n                                success = yank();\n                                break;\n                            case YANK_POP:\n                                success = yankPop();\n                                break;\n                            case KILL_LINE: \/\/ CTRL-K\n                                success = killLine();\n                                break;\n                            case KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                break;\n                            case CLEAR_SCREEN: \/\/ CTRL-L\n                                success = clearScreen();\n                                redrawLine();\n                                break;\n                            case OVERWRITE_MODE:\n                                buf.setOverTyping(!buf.isOverTyping());\n                                break;\n                            case SELF_INSERT:\n                                putString(opBuffer);\n                                break;\n                            case ACCEPT_LINE:\n                                return accept();\n                            case ABORT:\n                                if (searchTerm == null) {\n                                    abort();\n                                }\n                                break;\n                            case INTERRUPT:\n                                if (handleUserInterrupt) {\n                                    println();\n                                    flush();\n                                    String partialLine = buf.buffer.toString();\n                                    buf.clear();\n                                    history.moveToEnd();\n                                    throw new UserInterruptException(partialLine);\n                                }\n                                break;\n                            \/*\n                             * VI_MOVE_ACCEPT_LINE is the result of an ENTER\n                             * while in move mode. This is the same as a normal\n                             * ACCEPT_LINE, except that we need to enter\n                             * insert mode as well.\n                             *\/\n                            case VI_MOVE_ACCEPT_LINE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                return accept();\n                            case BACKWARD_WORD:\n                                success = previousWord();\n                                break;\n                            case FORWARD_WORD:\n                                success = nextWord();\n                                break;\n                            case PREVIOUS_HISTORY:\n                                success = moveHistory(false);\n                                break;\n                            \/*\n                             * According to bash\/readline move through history\n                             * in \"vi\" mode will move the cursor to the\n                             * start of the line. If there is no previous\n                             * history, then the cursor doesn't move.\n                             *\/\n                            case VI_PREVIOUS_HISTORY:\n                                success = moveHistory(false, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case NEXT_HISTORY:\n                                success = moveHistory(true);\n                                break;\n                            \/*\n                             * According to bash\/readline move through history\n                             * in \"vi\" mode will move the cursor to the\n                             * start of the line. If there is no next history,\n                             * then the cursor doesn't move.\n                             *\/\n                            case VI_NEXT_HISTORY:\n                                success = moveHistory(true, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case BACKWARD_DELETE_CHAR: \/\/ backspace\n                                success = backspace();\n                                break;\n                            case EXIT_OR_DELETE_CHAR:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                success = deleteCurrentCharacter();\n                                break;\n                            case DELETE_CHAR: \/\/ delete\n                                success = deleteCurrentCharacter();\n                                break;\n                            case BACKWARD_CHAR:\n                                success = moveCursor(-(count)) != 0;\n                                break;\n                            case FORWARD_CHAR:\n                                success = moveCursor(count) != 0;\n                                break;\n                            case UNIX_LINE_DISCARD:\n                                success = resetLine();\n                                break;\n                            case UNIX_WORD_RUBOUT:\n                                success = unixWordRubout(count);\n                                break;\n                            case BACKWARD_KILL_WORD:\n                                success = deletePreviousWord();\n                                break;\n                            case KILL_WORD:\n                                success = deleteNextWord();\n                                break;\n                            case BEGINNING_OF_HISTORY:\n                                success = history.moveToFirst();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case END_OF_HISTORY:\n                                success = history.moveToLast();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case HISTORY_SEARCH_BACKWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                searchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\n                                if (searchIndex == -1) {\n                                    beep();\n                                } else {\n                                    \/\/ Maintain cursor position while searching.\n                                    success = history.moveTo(searchIndex);\n                                    if (success) {\n                                        setBufferKeepPos(history.current());\n                                    }\n                                }\n                                break;\n                            case HISTORY_SEARCH_FORWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                int index = history.index() + 1;\n                                if (index == history.size()) {\n                                    history.moveToEnd();\n                                    setBufferKeepPos(searchTerm.toString());\n                                } else if (index < history.size()) {\n                                    searchIndex = searchForwards(searchTerm.toString(), index, true);\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    } else {\n                                        \/\/ Maintain cursor position while searching.\n                                        success = history.moveTo(searchIndex);\n                                        if (success) {\n                                            setBufferKeepPos(history.current());\n                                        }\n                                    }\n                                }\n                                break;\n                            case REVERSE_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case FORWARD_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.FORWARD_SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printForwardSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printForwardSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case CAPITALIZE_WORD:\n                                success = capitalizeWord();\n                                break;\n                            case UPCASE_WORD:\n                                success = upCaseWord();\n                                break;\n                            case DOWNCASE_WORD:\n                                success = downCaseWord();\n                                break;\n                            case END_OF_LINE:\n                                success = moveToEnd();\n                                break;\n                            case TAB_INSERT:\n                                putString( \"\\t\" );\n                                break;\n                            case RE_READ_INIT_FILE:\n                                consoleKeys.loadKeys(appName, inputrcUrl);\n                                break;\n                            case START_KBD_MACRO:\n                                recording = true;\n                                break;\n                            case END_KBD_MACRO:\n                                recording = false;\n                                macro = macro.substring(0, macro.length() - opBuffer.length());\n                                break;\n                            case CALL_LAST_KBD_MACRO:\n                                for (int i = 0; i < macro.length(); i++) {\n                                    pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                                }\n                                opBuffer.setLength(0);\n                                break;\n                            case VI_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_MOVEMENT_MODE:\n                                \/*\n                                 * If we are re-entering move mode from an\n                                 * aborted yank-to, delete-to, change-to then\n                                 * don't move the cursor back. The cursor is\n                                 * only move on an expclit entry to movement\n                                 * mode.\n                                 *\/\n                                if (state == State.NORMAL) {\n                                    moveCursor(-1);\n                                }\n                                consoleKeys.setKeyMap(KeyMap.VI_MOVE);\n                                break;\n                            case VI_INSERTION_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_MODE:\n                                moveCursor(1);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_EOL:\n                                success = moveToEnd();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            \/*\n                             * Handler for CTRL-D. Attempts to follow readline\n                             * behavior. If the line is empty, then it is an EOF\n                             * otherwise it is as if the user hit enter.\n                             *\/\n                            case VI_EOF_MAYBE:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                return accept();\n                            case TRANSPOSE_CHARS:\n                                success = transposeChars(count);\n                                break;\n                            case INSERT_COMMENT:\n                                return insertComment (false);\n                            case INSERT_CLOSE_CURLY:\n                                insertClose(\"}\");\n                                break;\n                            case INSERT_CLOSE_PAREN:\n                                insertClose(\")\");\n                                break;\n                            case INSERT_CLOSE_SQUARE:\n                                insertClose(\"]\");\n                                break;\n                            case VI_INSERT_COMMENT:\n                                return insertComment (true);\n                            case VI_MATCH:\n                                success = viMatch ();\n                                break;\n                            case VI_SEARCH:\n                                int lastChar = viSearch(opBuffer.charAt(0));\n                                if (lastChar != -1) {\n                                    pushBackChar.push((char)lastChar);\n                                }\n                                break;\n                            case VI_ARG_DIGIT:\n                                repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                isArgDigit = true;\n                                break;\n                            case VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\n                                if (repeatCount > 0) {\n                                    repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                    isArgDigit = true;\n                                }\n                                else {\n                                    success = setCursorPosition(0);\n                                }\n                                break;\n                            case VI_FIRST_PRINT:\n                                success = setCursorPosition(0) && viNextWord(1);\n                                break;\n                            case VI_PREV_WORD:\n                                success = viPreviousWord(count);\n                                break;\n                            case VI_NEXT_WORD:\n                                success = viNextWord(count);\n                                break;\n                            case VI_END_WORD:\n                                success = viEndWord(count);\n                                break;\n                            case VI_INSERT_BEG:\n                                success = setCursorPosition(0);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_RUBOUT:\n                                success = viRubout(count);\n                                break;\n                            case VI_DELETE:\n                                success = viDelete(count);\n                                break;\n                            case VI_DELETE_TO:\n                                \/*\n                                 * This is a weird special case. In vi\n                                 * \"dd\" deletes the current line. So if we\n                                 * get a delete-to, followed by a delete-to,\n                                 * we delete the line.\n                                 *\/\n                                if (state == State.VI_DELETE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_DELETE_TO;\n                                }\n                                break;\n                            case VI_YANK_TO:\n                                \/\/ Similar to delete-to, a \"yy\" yanks the whole line.\n                                if (state == State.VI_YANK_TO) {\n                                    yankBuffer = buf.buffer.toString();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_YANK_TO;\n                                }\n                                break;\n                            case VI_CHANGE_TO:\n                                if (state == State.VI_CHANGE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                    consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                }\n                                else {\n                                    state = State.VI_CHANGE_TO;\n                                }\n                                break;\n                            case VI_KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_PUT:\n                                success = viPut(count);\n                                break;\n                            case VI_CHAR_SEARCH: {\n                                 \/\/ ';' and ',' don't need another character. They indicate repeat next or repeat prev.\n                                int searchChar = (c != ';' && c != ',')\n                                    ? (pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop ())\n                                    : 0;\n                                    success = viCharSearch(count, c, searchChar);\n                                }\n                                break;\n                            case VI_CHANGE_CASE:\n                                success = viChangeCase(count);\n                                break;\n                            case VI_CHANGE_CHAR:\n                                success = viChangeChar(count,\n                                    pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop());\n                                break;\n                            case VI_DELETE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), false);\n                                break;\n                            case VI_CHANGE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case EMACS_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.EMACS);\n                                break;\n                            case QUIT:\n                                getCursorBuffer().clear();\n                                return accept();\n                            case QUOTED_INSERT:\n                                quotedInsert = true;\n                                break;\n                            case PASTE_FROM_CLIPBOARD:\n                                paste();\n                                break;\n                            default:\n                                break;\n                        }\n                        \/*\n                         * If we were in a yank-to, delete-to, move-to\n                         * when this operation started, then fall back to\n                         *\/\n                        if (origState != State.NORMAL) {\n                            if (origState == State.VI_DELETE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, false);\n                            }\n                            else if (origState == State.VI_CHANGE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                            }\n                            else if (origState == State.VI_YANK_TO) {\n                                success = viYankTo(cursorStart, buf.cursor);\n                            }\n                            state = State.NORMAL;\n                        }\n                        \/*\n                         * Another subtly. The check for the NORMAL state is\n                         * to ensure that we do not clear out the repeat\n                         * count when in delete-to, yank-to, or move-to modes.\n                         *\/\n                        if (state == State.NORMAL && !isArgDigit) {\n                            \/*\n                             * If the operation performed wasn't a vi argument\n                             * digit, then clear out the current repeatCount;\n                             *\/\n                            repeatCount = 0;\n                        }\n                        if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                            originalBuffer = null;\n                            previousSearchTerm = \"\";\n                            searchTerm = null;\n                            searchIndex = -1;\n                        }\n                    }\n                }\n                if (!success) {\n                    beep();\n                }\n                opBuffer.setLength(0);\n                flush();\n            }\n        }\n        finally {\n            if (!terminal.isSupported()) {\n                afterReadLine();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).enableInterruptCharacter();\n            }\n        }\n    }","code_wo_comment":"public String readLine(String prompt, final Character mask, String buffer) throws IOException {\n       \n       \n       \n       \n        int repeatCount = 0;\n       \n        this.mask = mask != null ? mask : this.echoCharacter;\n        if (prompt != null) {\n            setPrompt(prompt);\n        }\n        else {\n            prompt = getPrompt();\n        }\n        try {\n            if (buffer != null) {\n                buf.write(buffer);\n            }\n            if (!terminal.isSupported()) {\n                beforeReadLine(prompt, mask);\n            }\n            if (buffer != null && buffer.length() > 0\n                    || prompt != null && prompt.length() > 0) {\n                drawLine();\n                out.flush();\n            }\n           \n            if (!terminal.isSupported()) {\n                return readLineSimple();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableInterruptCharacter();\n            }\n            if (handleLitteralNext && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).disableLitteralNextCharacter();\n            }\n            String originalPrompt = this.prompt;\n            state = State.NORMAL;\n            boolean success = true;\n            pushBackChar.clear();\n            while (true) {\n                Object o = readBinding(getKeys());\n                if (o == null) {\n                    return null;\n                }\n                int c = 0;\n                if (opBuffer.length() > 0) {\n                    c = opBuffer.codePointBefore(opBuffer.length());\n                }\n                Log.trace(\"Binding: \", o);\n               \n                if (o instanceof String) {\n                    String macro = (String) o;\n                    for (int i = 0; i < macro.length(); i++) {\n                        pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                    }\n                    opBuffer.setLength(0);\n                    continue;\n                }\n               \n                if (o instanceof ActionListener) {\n                    ((ActionListener) o).actionPerformed(null);\n                    opBuffer.setLength(0);\n                    continue;\n                }\n                CursorBuffer oldBuf = new CursorBuffer();\n                oldBuf.buffer.append(buf.buffer);\n                oldBuf.cursor = buf.cursor;\n               \n               \n               \n               \n               \n                if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                    int cursorDest = -1;\n                   \n                    switch ( ((Operation) o )) {\n                        case ABORT:\n                            state = State.NORMAL;\n                            buf.clear();\n                            buf.write(originalBuffer.buffer);\n                            buf.cursor = originalBuffer.cursor;\n                            break;\n                        case REVERSE_SEARCH_HISTORY:\n                            state = State.SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > 0) {\n                                searchIndex = searchBackwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case FORWARD_SEARCH_HISTORY:\n                            state = State.FORWARD_SEARCH;\n                            if (searchTerm.length() == 0) {\n                                searchTerm.append(previousSearchTerm);\n                            }\n                            if (searchIndex > -1 && searchIndex < history.size() - 1) {\n                                searchIndex = searchForwards(searchTerm.toString(), searchIndex);\n                            }\n                            break;\n                        case BACKWARD_DELETE_CHAR:\n                            if (searchTerm.length() > 0) {\n                                searchTerm.deleteCharAt(searchTerm.length() - 1);\n                                if (state == State.SEARCH) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                } else {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                }\n                            }\n                            break;\n                        case SELF_INSERT:\n                            searchTerm.appendCodePoint(c);\n                            if (state == State.SEARCH) {\n                                searchIndex = searchBackwards(searchTerm.toString());\n                            } else {\n                                searchIndex = searchForwards(searchTerm.toString());\n                            }\n                            break;\n                        default:\n                           \n                            if (searchIndex != -1) {\n                                history.moveTo(searchIndex);\n                               \n                                cursorDest = history.current().toString().indexOf(searchTerm.toString());\n                            }\n                            if (o != Operation.ACCEPT_LINE) {\n                                o = null;\n                            }\n                            state = State.NORMAL;\n                            break;\n                    }\n                   \n                    if (state == State.SEARCH || state == State.FORWARD_SEARCH) {\n                        if (searchTerm.length() == 0) {\n                            if (state == State.SEARCH) {\n                                printSearchStatus(\"\", \"\");\n                            } else {\n                                printForwardSearchStatus(\"\", \"\");\n                            }\n                            searchIndex = -1;\n                        } else {\n                            if (searchIndex == -1) {\n                                beep();\n                                printSearchStatus(searchTerm.toString(), \"\");\n                            } else if (state == State.SEARCH) {\n                                printSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            } else {\n                                printForwardSearchStatus(searchTerm.toString(), history.get(searchIndex).toString());\n                            }\n                        }\n                    }\n                   \n                    else {\n                        restoreLine(originalPrompt, cursorDest);\n                    }\n                }\n                if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                   \n                    boolean isArgDigit = false;\n                   \n                    int count = (repeatCount == 0) ? 1 : repeatCount;\n                   \n                    success = true;\n                    if (o instanceof Operation) {\n                        Operation op = (Operation)o;\n                       \n                        int     cursorStart = buf.cursor;\n                        State   origState   = state;\n                       \n                        if (state == State.VI_CHANGE_TO\n                            || state == State.VI_YANK_TO\n                            || state == State.VI_DELETE_TO) {\n                            op = viDeleteChangeYankToRemap(op);\n                        }\n                        switch ( op ) {\n                            case COMPLETE:\n                               \n                               \n                               \n                               \n                               \n                                boolean isTabLiteral = false;\n                                if (copyPasteDetection\n                                    && c == 9\n                                    && (!pushBackChar.isEmpty()\n                                        || (in.isNonBlockingEnabled() && in.peek(escapeTimeout) != -2))) {\n                                    isTabLiteral = true;\n                                }\n                                if (! isTabLiteral) {\n                                    success = complete();\n                                }\n                                else {\n                                    putString(opBuffer);\n                                }\n                                break;\n                            case POSSIBLE_COMPLETIONS:\n                                printCompletionCandidates();\n                                break;\n                            case BEGINNING_OF_LINE:\n                                success = setCursorPosition(0);\n                                break;\n                            case YANK:\n                                success = yank();\n                                break;\n                            case YANK_POP:\n                                success = yankPop();\n                                break;\n                            case KILL_LINE:\n                                success = killLine();\n                                break;\n                            case KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                break;\n                            case CLEAR_SCREEN:\n                                success = clearScreen();\n                                redrawLine();\n                                break;\n                            case OVERWRITE_MODE:\n                                buf.setOverTyping(!buf.isOverTyping());\n                                break;\n                            case SELF_INSERT:\n                                putString(opBuffer);\n                                break;\n                            case ACCEPT_LINE:\n                                return accept();\n                            case ABORT:\n                                if (searchTerm == null) {\n                                    abort();\n                                }\n                                break;\n                            case INTERRUPT:\n                                if (handleUserInterrupt) {\n                                    println();\n                                    flush();\n                                    String partialLine = buf.buffer.toString();\n                                    buf.clear();\n                                    history.moveToEnd();\n                                    throw new UserInterruptException(partialLine);\n                                }\n                                break;\n                           \n                            case VI_MOVE_ACCEPT_LINE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                return accept();\n                            case BACKWARD_WORD:\n                                success = previousWord();\n                                break;\n                            case FORWARD_WORD:\n                                success = nextWord();\n                                break;\n                            case PREVIOUS_HISTORY:\n                                success = moveHistory(false);\n                                break;\n                           \n                            case VI_PREVIOUS_HISTORY:\n                                success = moveHistory(false, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case NEXT_HISTORY:\n                                success = moveHistory(true);\n                                break;\n                           \n                            case VI_NEXT_HISTORY:\n                                success = moveHistory(true, count)\n                                    && setCursorPosition(0);\n                                break;\n                            case BACKWARD_DELETE_CHAR:\n                                success = backspace();\n                                break;\n                            case EXIT_OR_DELETE_CHAR:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                success = deleteCurrentCharacter();\n                                break;\n                            case DELETE_CHAR:\n                                success = deleteCurrentCharacter();\n                                break;\n                            case BACKWARD_CHAR:\n                                success = moveCursor(-(count)) != 0;\n                                break;\n                            case FORWARD_CHAR:\n                                success = moveCursor(count) != 0;\n                                break;\n                            case UNIX_LINE_DISCARD:\n                                success = resetLine();\n                                break;\n                            case UNIX_WORD_RUBOUT:\n                                success = unixWordRubout(count);\n                                break;\n                            case BACKWARD_KILL_WORD:\n                                success = deletePreviousWord();\n                                break;\n                            case KILL_WORD:\n                                success = deleteNextWord();\n                                break;\n                            case BEGINNING_OF_HISTORY:\n                                success = history.moveToFirst();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case END_OF_HISTORY:\n                                success = history.moveToLast();\n                                if (success) {\n                                    setBuffer(history.current());\n                                }\n                                break;\n                            case HISTORY_SEARCH_BACKWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                searchIndex = searchBackwards(searchTerm.toString(), history.index(), true);\n                                if (searchIndex == -1) {\n                                    beep();\n                                } else {\n                                   \n                                    success = history.moveTo(searchIndex);\n                                    if (success) {\n                                        setBufferKeepPos(history.current());\n                                    }\n                                }\n                                break;\n                            case HISTORY_SEARCH_FORWARD:\n                                searchTerm = new StringBuffer(buf.upToCursor());\n                                int index = history.index() + 1;\n                                if (index == history.size()) {\n                                    history.moveToEnd();\n                                    setBufferKeepPos(searchTerm.toString());\n                                } else if (index < history.size()) {\n                                    searchIndex = searchForwards(searchTerm.toString(), index, true);\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    } else {\n                                       \n                                        success = history.moveTo(searchIndex);\n                                        if (success) {\n                                            setBufferKeepPos(history.current());\n                                        }\n                                    }\n                                }\n                                break;\n                            case REVERSE_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchBackwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case FORWARD_SEARCH_HISTORY:\n                                originalBuffer = new CursorBuffer();\n                                originalBuffer.write(buf.buffer);\n                                originalBuffer.cursor = buf.cursor;\n                                if (searchTerm != null) {\n                                    previousSearchTerm = searchTerm.toString();\n                                }\n                                searchTerm = new StringBuffer(buf.buffer);\n                                state = State.FORWARD_SEARCH;\n                                if (searchTerm.length() > 0) {\n                                    searchIndex = searchForwards(searchTerm.toString());\n                                    if (searchIndex == -1) {\n                                        beep();\n                                    }\n                                    printForwardSearchStatus(searchTerm.toString(),\n                                            searchIndex > -1 ? history.get(searchIndex).toString() : \"\");\n                                } else {\n                                    searchIndex = -1;\n                                    printForwardSearchStatus(\"\", \"\");\n                                }\n                                break;\n                            case CAPITALIZE_WORD:\n                                success = capitalizeWord();\n                                break;\n                            case UPCASE_WORD:\n                                success = upCaseWord();\n                                break;\n                            case DOWNCASE_WORD:\n                                success = downCaseWord();\n                                break;\n                            case END_OF_LINE:\n                                success = moveToEnd();\n                                break;\n                            case TAB_INSERT:\n                                putString( \"\\t\" );\n                                break;\n                            case RE_READ_INIT_FILE:\n                                consoleKeys.loadKeys(appName, inputrcUrl);\n                                break;\n                            case START_KBD_MACRO:\n                                recording = true;\n                                break;\n                            case END_KBD_MACRO:\n                                recording = false;\n                                macro = macro.substring(0, macro.length() - opBuffer.length());\n                                break;\n                            case CALL_LAST_KBD_MACRO:\n                                for (int i = 0; i < macro.length(); i++) {\n                                    pushBackChar.push(macro.charAt(macro.length() - 1 - i));\n                                }\n                                opBuffer.setLength(0);\n                                break;\n                            case VI_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_MOVEMENT_MODE:\n                               \n                                if (state == State.NORMAL) {\n                                    moveCursor(-1);\n                                }\n                                consoleKeys.setKeyMap(KeyMap.VI_MOVE);\n                                break;\n                            case VI_INSERTION_MODE:\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_MODE:\n                                moveCursor(1);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_APPEND_EOL:\n                                success = moveToEnd();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                           \n                            case VI_EOF_MAYBE:\n                                if (buf.buffer.length() == 0) {\n                                    return null;\n                                }\n                                return accept();\n                            case TRANSPOSE_CHARS:\n                                success = transposeChars(count);\n                                break;\n                            case INSERT_COMMENT:\n                                return insertComment (false);\n                            case INSERT_CLOSE_CURLY:\n                                insertClose(\"}\");\n                                break;\n                            case INSERT_CLOSE_PAREN:\n                                insertClose(\")\");\n                                break;\n                            case INSERT_CLOSE_SQUARE:\n                                insertClose(\"]\");\n                                break;\n                            case VI_INSERT_COMMENT:\n                                return insertComment (true);\n                            case VI_MATCH:\n                                success = viMatch ();\n                                break;\n                            case VI_SEARCH:\n                                int lastChar = viSearch(opBuffer.charAt(0));\n                                if (lastChar != -1) {\n                                    pushBackChar.push((char)lastChar);\n                                }\n                                break;\n                            case VI_ARG_DIGIT:\n                                repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                isArgDigit = true;\n                                break;\n                            case VI_BEGINNING_OF_LINE_OR_ARG_DIGIT:\n                                if (repeatCount > 0) {\n                                    repeatCount = (repeatCount * 10) + opBuffer.charAt(0) - '0';\n                                    isArgDigit = true;\n                                }\n                                else {\n                                    success = setCursorPosition(0);\n                                }\n                                break;\n                            case VI_FIRST_PRINT:\n                                success = setCursorPosition(0) && viNextWord(1);\n                                break;\n                            case VI_PREV_WORD:\n                                success = viPreviousWord(count);\n                                break;\n                            case VI_NEXT_WORD:\n                                success = viNextWord(count);\n                                break;\n                            case VI_END_WORD:\n                                success = viEndWord(count);\n                                break;\n                            case VI_INSERT_BEG:\n                                success = setCursorPosition(0);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_RUBOUT:\n                                success = viRubout(count);\n                                break;\n                            case VI_DELETE:\n                                success = viDelete(count);\n                                break;\n                            case VI_DELETE_TO:\n                               \n                                if (state == State.VI_DELETE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_DELETE_TO;\n                                }\n                                break;\n                            case VI_YANK_TO:\n                               \n                                if (state == State.VI_YANK_TO) {\n                                    yankBuffer = buf.buffer.toString();\n                                    state = origState = State.NORMAL;\n                                }\n                                else {\n                                    state = State.VI_YANK_TO;\n                                }\n                                break;\n                            case VI_CHANGE_TO:\n                                if (state == State.VI_CHANGE_TO) {\n                                    success = setCursorPosition(0) && killLine();\n                                    state = origState = State.NORMAL;\n                                    consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                }\n                                else {\n                                    state = State.VI_CHANGE_TO;\n                                }\n                                break;\n                            case VI_KILL_WHOLE_LINE:\n                                success = setCursorPosition(0) && killLine();\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case VI_PUT:\n                                success = viPut(count);\n                                break;\n                            case VI_CHAR_SEARCH: {\n                                \n                                int searchChar = (c != ';' && c != ',')\n                                    ? (pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop ())\n                                    : 0;\n                                    success = viCharSearch(count, c, searchChar);\n                                }\n                                break;\n                            case VI_CHANGE_CASE:\n                                success = viChangeCase(count);\n                                break;\n                            case VI_CHANGE_CHAR:\n                                success = viChangeChar(count,\n                                    pushBackChar.isEmpty()\n                                        ? readCharacter()\n                                        : pushBackChar.pop());\n                                break;\n                            case VI_DELETE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), false);\n                                break;\n                            case VI_CHANGE_TO_EOL:\n                                success = viDeleteTo(buf.cursor, buf.buffer.length(), true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                                break;\n                            case EMACS_EDITING_MODE:\n                                consoleKeys.setKeyMap(KeyMap.EMACS);\n                                break;\n                            case QUIT:\n                                getCursorBuffer().clear();\n                                return accept();\n                            case QUOTED_INSERT:\n                                quotedInsert = true;\n                                break;\n                            case PASTE_FROM_CLIPBOARD:\n                                paste();\n                                break;\n                            default:\n                                break;\n                        }\n                       \n                        if (origState != State.NORMAL) {\n                            if (origState == State.VI_DELETE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, false);\n                            }\n                            else if (origState == State.VI_CHANGE_TO) {\n                                success = viDeleteTo(cursorStart, buf.cursor, true);\n                                consoleKeys.setKeyMap(KeyMap.VI_INSERT);\n                            }\n                            else if (origState == State.VI_YANK_TO) {\n                                success = viYankTo(cursorStart, buf.cursor);\n                            }\n                            state = State.NORMAL;\n                        }\n                       \n                        if (state == State.NORMAL && !isArgDigit) {\n                           \n                            repeatCount = 0;\n                        }\n                        if (state != State.SEARCH && state != State.FORWARD_SEARCH) {\n                            originalBuffer = null;\n                            previousSearchTerm = \"\";\n                            searchTerm = null;\n                            searchIndex = -1;\n                        }\n                    }\n                }\n                if (!success) {\n                    beep();\n                }\n                opBuffer.setLength(0);\n                flush();\n            }\n        }\n        finally {\n            if (!terminal.isSupported()) {\n                afterReadLine();\n            }\n            if (handleUserInterrupt && (terminal instanceof UnixTerminal)) {\n                ((UnixTerminal) terminal).enableInterruptCharacter();\n            }\n        }\n    }","cleancode":"public string readline(string prompt, final character mask, string buffer) throws ioexception { int repeatcount = 0; this.mask = mask != null ? mask : this.echocharacter; if (prompt != null) { setprompt(prompt); } else { prompt = getprompt(); } try { if (buffer != null) { buf.write(buffer); } if (!terminal.issupported()) { beforereadline(prompt, mask); } if (buffer != null && buffer.length() > 0 || prompt != null && prompt.length() > 0) { drawline(); out.flush(); } if (!terminal.issupported()) { return readlinesimple(); } if (handleuserinterrupt && (terminal instanceof unixterminal)) { ((unixterminal) terminal).disableinterruptcharacter(); } if (handlelitteralnext && (terminal instanceof unixterminal)) { ((unixterminal) terminal).disablelitteralnextcharacter(); } string originalprompt = this.prompt; state = state.normal; boolean success = true; pushbackchar.clear(); while (true) { object o = readbinding(getkeys()); if (o == null) { return null; } int c = 0; if (opbuffer.length() > 0) { c = opbuffer.codepointbefore(opbuffer.length()); } log.trace(\"binding: \", o); if (o instanceof string) { string macro = (string) o; for (int i = 0; i < macro.length(); i++) { pushbackchar.push(macro.charat(macro.length() - 1 - i)); } opbuffer.setlength(0); continue; } if (o instanceof actionlistener) { ((actionlistener) o).actionperformed(null); opbuffer.setlength(0); continue; } cursorbuffer oldbuf = new cursorbuffer(); oldbuf.buffer.append(buf.buffer); oldbuf.cursor = buf.cursor; if (state == state.search || state == state.forward_search) { int cursordest = -1; switch ( ((operation) o )) { case abort: state = state.normal; buf.clear(); buf.write(originalbuffer.buffer); buf.cursor = originalbuffer.cursor; break; case reverse_search_history: state = state.search; if (searchterm.length() == 0) { searchterm.append(previoussearchterm); } if (searchindex > 0) { searchindex = searchbackwards(searchterm.tostring(), searchindex); } break; case forward_search_history: state = state.forward_search; if (searchterm.length() == 0) { searchterm.append(previoussearchterm); } if (searchindex > -1 && searchindex < history.size() - 1) { searchindex = searchforwards(searchterm.tostring(), searchindex); } break; case backward_delete_char: if (searchterm.length() > 0) { searchterm.deletecharat(searchterm.length() - 1); if (state == state.search) { searchindex = searchbackwards(searchterm.tostring()); } else { searchindex = searchforwards(searchterm.tostring()); } } break; case self_insert: searchterm.appendcodepoint(c); if (state == state.search) { searchindex = searchbackwards(searchterm.tostring()); } else { searchindex = searchforwards(searchterm.tostring()); } break; default: if (searchindex != -1) { history.moveto(searchindex); cursordest = history.current().tostring().indexof(searchterm.tostring()); } if (o != operation.accept_line) { o = null; } state = state.normal; break; } if (state == state.search || state == state.forward_search) { if (searchterm.length() == 0) { if (state == state.search) { printsearchstatus(\"\", \"\"); } else { printforwardsearchstatus(\"\", \"\"); } searchindex = -1; } else { if (searchindex == -1) { beep(); printsearchstatus(searchterm.tostring(), \"\"); } else if (state == state.search) { printsearchstatus(searchterm.tostring(), history.get(searchindex).tostring()); } else { printforwardsearchstatus(searchterm.tostring(), history.get(searchindex).tostring()); } } } else { restoreline(originalprompt, cursordest); } } if (state != state.search && state != state.forward_search) { boolean isargdigit = false; int count = (repeatcount == 0) ? 1 : repeatcount; success = true; if (o instanceof operation) { operation op = (operation)o; int cursorstart = buf.cursor; state origstate = state; if (state == state.vi_change_to || state == state.vi_yank_to || state == state.vi_delete_to) { op = videletechangeyanktoremap(op); } switch ( op ) { case complete: boolean istabliteral = false; if (copypastedetection && c == 9 && (!pushbackchar.isempty() || (in.isnonblockingenabled() && in.peek(escapetimeout) != -2))) { istabliteral = true; } if (! istabliteral) { success = complete(); } else { putstring(opbuffer); } break; case possible_completions: printcompletioncandidates(); break; case beginning_of_line: success = setcursorposition(0); break; case yank: success = yank(); break; case yank_pop: success = yankpop(); break; case kill_line: success = killline(); break; case kill_whole_line: success = setcursorposition(0) && killline(); break; case clear_screen: success = clearscreen(); redrawline(); break; case overwrite_mode: buf.setovertyping(!buf.isovertyping()); break; case self_insert: putstring(opbuffer); break; case accept_line: return accept(); case abort: if (searchterm == null) { abort(); } break; case interrupt: if (handleuserinterrupt) { println(); flush(); string partialline = buf.buffer.tostring(); buf.clear(); history.movetoend(); throw new userinterruptexception(partialline); } break; case vi_move_accept_line: consolekeys.setkeymap(keymap.vi_insert); return accept(); case backward_word: success = previousword(); break; case forward_word: success = nextword(); break; case previous_history: success = movehistory(false); break; case vi_previous_history: success = movehistory(false, count) && setcursorposition(0); break; case next_history: success = movehistory(true); break; case vi_next_history: success = movehistory(true, count) && setcursorposition(0); break; case backward_delete_char: success = backspace(); break; case exit_or_delete_char: if (buf.buffer.length() == 0) { return null; } success = deletecurrentcharacter(); break; case delete_char: success = deletecurrentcharacter(); break; case backward_char: success = movecursor(-(count)) != 0; break; case forward_char: success = movecursor(count) != 0; break; case unix_line_discard: success = resetline(); break; case unix_word_rubout: success = unixwordrubout(count); break; case backward_kill_word: success = deletepreviousword(); break; case kill_word: success = deletenextword(); break; case beginning_of_history: success = history.movetofirst(); if (success) { setbuffer(history.current()); } break; case end_of_history: success = history.movetolast(); if (success) { setbuffer(history.current()); } break; case history_search_backward: searchterm = new stringbuffer(buf.uptocursor()); searchindex = searchbackwards(searchterm.tostring(), history.index(), true); if (searchindex == -1) { beep(); } else { success = history.moveto(searchindex); if (success) { setbufferkeeppos(history.current()); } } break; case history_search_forward: searchterm = new stringbuffer(buf.uptocursor()); int index = history.index() + 1; if (index == history.size()) { history.movetoend(); setbufferkeeppos(searchterm.tostring()); } else if (index < history.size()) { searchindex = searchforwards(searchterm.tostring(), index, true); if (searchindex == -1) { beep(); } else { success = history.moveto(searchindex); if (success) { setbufferkeeppos(history.current()); } } } break; case reverse_search_history: originalbuffer = new cursorbuffer(); originalbuffer.write(buf.buffer); originalbuffer.cursor = buf.cursor; if (searchterm != null) { previoussearchterm = searchterm.tostring(); } searchterm = new stringbuffer(buf.buffer); state = state.search; if (searchterm.length() > 0) { searchindex = searchbackwards(searchterm.tostring()); if (searchindex == -1) { beep(); } printsearchstatus(searchterm.tostring(), searchindex > -1 ? history.get(searchindex).tostring() : \"\"); } else { searchindex = -1; printsearchstatus(\"\", \"\"); } break; case forward_search_history: originalbuffer = new cursorbuffer(); originalbuffer.write(buf.buffer); originalbuffer.cursor = buf.cursor; if (searchterm != null) { previoussearchterm = searchterm.tostring(); } searchterm = new stringbuffer(buf.buffer); state = state.forward_search; if (searchterm.length() > 0) { searchindex = searchforwards(searchterm.tostring()); if (searchindex == -1) { beep(); } printforwardsearchstatus(searchterm.tostring(), searchindex > -1 ? history.get(searchindex).tostring() : \"\"); } else { searchindex = -1; printforwardsearchstatus(\"\", \"\"); } break; case capitalize_word: success = capitalizeword(); break; case upcase_word: success = upcaseword(); break; case downcase_word: success = downcaseword(); break; case end_of_line: success = movetoend(); break; case tab_insert: putstring( \"\\t\" ); break; case re_read_init_file: consolekeys.loadkeys(appname, inputrcurl); break; case start_kbd_macro: recording = true; break; case end_kbd_macro: recording = false; macro = macro.substring(0, macro.length() - opbuffer.length()); break; case call_last_kbd_macro: for (int i = 0; i < macro.length(); i++) { pushbackchar.push(macro.charat(macro.length() - 1 - i)); } opbuffer.setlength(0); break; case vi_editing_mode: consolekeys.setkeymap(keymap.vi_insert); break; case vi_movement_mode: if (state == state.normal) { movecursor(-1); } consolekeys.setkeymap(keymap.vi_move); break; case vi_insertion_mode: consolekeys.setkeymap(keymap.vi_insert); break; case vi_append_mode: movecursor(1); consolekeys.setkeymap(keymap.vi_insert); break; case vi_append_eol: success = movetoend(); consolekeys.setkeymap(keymap.vi_insert); break; case vi_eof_maybe: if (buf.buffer.length() == 0) { return null; } return accept(); case transpose_chars: success = transposechars(count); break; case insert_comment: return insertcomment (false); case insert_close_curly: insertclose(\"}\"); break; case insert_close_paren: insertclose(\")\"); break; case insert_close_square: insertclose(\"]\"); break; case vi_insert_comment: return insertcomment (true); case vi_match: success = vimatch (); break; case vi_search: int lastchar = visearch(opbuffer.charat(0)); if (lastchar != -1) { pushbackchar.push((char)lastchar); } break; case vi_arg_digit: repeatcount = (repeatcount * 10) + opbuffer.charat(0) - '0'; isargdigit = true; break; case vi_beginning_of_line_or_arg_digit: if (repeatcount > 0) { repeatcount = (repeatcount * 10) + opbuffer.charat(0) - '0'; isargdigit = true; } else { success = setcursorposition(0); } break; case vi_first_print: success = setcursorposition(0) && vinextword(1); break; case vi_prev_word: success = vipreviousword(count); break; case vi_next_word: success = vinextword(count); break; case vi_end_word: success = viendword(count); break; case vi_insert_beg: success = setcursorposition(0); consolekeys.setkeymap(keymap.vi_insert); break; case vi_rubout: success = virubout(count); break; case vi_delete: success = videlete(count); break; case vi_delete_to: if (state == state.vi_delete_to) { success = setcursorposition(0) && killline(); state = origstate = state.normal; } else { state = state.vi_delete_to; } break; case vi_yank_to: if (state == state.vi_yank_to) { yankbuffer = buf.buffer.tostring(); state = origstate = state.normal; } else { state = state.vi_yank_to; } break; case vi_change_to: if (state == state.vi_change_to) { success = setcursorposition(0) && killline(); state = origstate = state.normal; consolekeys.setkeymap(keymap.vi_insert); } else { state = state.vi_change_to; } break; case vi_kill_whole_line: success = setcursorposition(0) && killline(); consolekeys.setkeymap(keymap.vi_insert); break; case vi_put: success = viput(count); break; case vi_char_search: { int searchchar = (c != ';' && c != ',') ? (pushbackchar.isempty() ? readcharacter() : pushbackchar.pop ()) : 0; success = vicharsearch(count, c, searchchar); } break; case vi_change_case: success = vichangecase(count); break; case vi_change_char: success = vichangechar(count, pushbackchar.isempty() ? readcharacter() : pushbackchar.pop()); break; case vi_delete_to_eol: success = videleteto(buf.cursor, buf.buffer.length(), false); break; case vi_change_to_eol: success = videleteto(buf.cursor, buf.buffer.length(), true); consolekeys.setkeymap(keymap.vi_insert); break; case emacs_editing_mode: consolekeys.setkeymap(keymap.emacs); break; case quit: getcursorbuffer().clear(); return accept(); case quoted_insert: quotedinsert = true; break; case paste_from_clipboard: paste(); break; default: break; } if (origstate != state.normal) { if (origstate == state.vi_delete_to) { success = videleteto(cursorstart, buf.cursor, false); } else if (origstate == state.vi_change_to) { success = videleteto(cursorstart, buf.cursor, true); consolekeys.setkeymap(keymap.vi_insert); } else if (origstate == state.vi_yank_to) { success = viyankto(cursorstart, buf.cursor); } state = state.normal; } if (state == state.normal && !isargdigit) { repeatcount = 0; } if (state != state.search && state != state.forward_search) { originalbuffer = null; previoussearchterm = \"\"; searchterm = null; searchindex = -1; } } } if (!success) { beep(); } opbuffer.setlength(0); flush(); } } finally { if (!terminal.issupported()) { afterreadline(); } if (handleuserinterrupt && (terminal instanceof unixterminal)) { ((unixterminal) terminal).enableinterruptcharacter(); } } }","repo":"boris-gelman\/jline2","label":[0,1,1,0]}
{"id":10081,"original_code":"public int undo()\n\t{\n\t\tif (turn == 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t\/\/ Restore game history (pop current moves frame and reset selected move):\n\t\tmoves_frame = moves[moves_frame + 1];\n\t\tfinal var move = moves[moves_frame + 2];\/\/ TODO: fix when moves_selected contains index not move\n\t\tmoves[moves_frame + 2] = 0;\n\t\t\/\/ Restore cached current game situation (figure constellation, king positions,\n\t\t\/\/\tcastlings, active player and turn number):\n\t\tfinal var x = Move.x(move);\n\t\tfinal var y = Move.y(move);\n\t\tfinal var X = Move.X(move);\n\t\tfinal var Y = Move.Y(move);\n\t\tfinal var figure_moved = Move.figure_moved(move);\n\t\tfinal var figure_destination = Move.figure_destination(move);\n\t\tboard[x][y] = figure_moved;\n\t\tboard[X][Y] = figure_destination;\n\t\tif (figure_moved.is_king())\n\t\t{\n\t\t\tif (player)\n\t\t\t{\n\t\t\t\tking_x_b = x;\n\t\t\t\tking_y_b = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tking_x_w = x;\n\t\t\t\tking_y_w = y;\n\t\t\t}\n\t\t\tif (X == x - 2)\n\t\t\t{ \/\/ Castling left:\n\t\t\t\tboard[0][Y] = board[3][Y];\n\t\t\t\tboard[3][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (X == x + 2)\n\t\t\t{ \/\/ Castling right:\n\t\t\t\tboard[7][Y] = board[5][Y];\n\t\t\t\tboard[5][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n\t\t{ \/\/ Undo en passant capture:\n\t\t\tboard[X][y] = Figure.pawn(!figure_moved.owner);\n\t\t}\n\t\tcastlings_allowed ^= Move.castling_changes(move);\n\t\tplayer = !player;\n\t\tturn--;\n\t\treturn move;\n\t}","code_wo_comment":"public int undo()\n\t{\n\t\tif (turn == 1)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tmoves_frame = moves[moves_frame + 1];\n\t\tfinal var move = moves[moves_frame + 2]\n\t\tmoves[moves_frame + 2] = 0;\n\t\n\t\n\t\tfinal var x = Move.x(move);\n\t\tfinal var y = Move.y(move);\n\t\tfinal var X = Move.X(move);\n\t\tfinal var Y = Move.Y(move);\n\t\tfinal var figure_moved = Move.figure_moved(move);\n\t\tfinal var figure_destination = Move.figure_destination(move);\n\t\tboard[x][y] = figure_moved;\n\t\tboard[X][Y] = figure_destination;\n\t\tif (figure_moved.is_king())\n\t\t{\n\t\t\tif (player)\n\t\t\t{\n\t\t\t\tking_x_b = x;\n\t\t\t\tking_y_b = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tking_x_w = x;\n\t\t\t\tking_y_w = y;\n\t\t\t}\n\t\t\tif (X == x - 2)\n\t\t\t{\n\t\t\t\tboard[0][Y] = board[3][Y];\n\t\t\t\tboard[3][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (X == x + 2)\n\t\t\t{\n\t\t\t\tboard[7][Y] = board[5][Y];\n\t\t\t\tboard[5][Y] = null;\n\t\t\t\tif (figure_moved.owner)\n\t\t\t\t{\n\t\t\t\t\tcastling_done_w = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcastling_done_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (figure_moved.is_pawn() && X != x && figure_destination == null)\n\t\t{\n\t\t\tboard[X][y] = Figure.pawn(!figure_moved.owner);\n\t\t}\n\t\tcastlings_allowed ^= Move.castling_changes(move);\n\t\tplayer = !player;\n\t\tturn--;\n\t\treturn move;\n\t}","cleancode":"public int undo() { if (turn == 1) { return 0; } moves_frame = moves[moves_frame + 1]; final var move = moves[moves_frame + 2] moves[moves_frame + 2] = 0; final var x = move.x(move); final var y = move.y(move); final var x = move.x(move); final var y = move.y(move); final var figure_moved = move.figure_moved(move); final var figure_destination = move.figure_destination(move); board[x][y] = figure_moved; board[x][y] = figure_destination; if (figure_moved.is_king()) { if (player) { king_x_b = x; king_y_b = y; } else { king_x_w = x; king_y_w = y; } if (x == x - 2) { board[0][y] = board[3][y]; board[3][y] = null; if (figure_moved.owner) { castling_done_w = false; } else { castling_done_b = false; } } else if (x == x + 2) { board[7][y] = board[5][y]; board[5][y] = null; if (figure_moved.owner) { castling_done_w = false; } else { castling_done_b = false; } } } else if (figure_moved.is_pawn() && x != x && figure_destination == null) { board[x][y] = figure.pawn(!figure_moved.owner); } castlings_allowed ^= move.castling_changes(move); player = !player; turn--; return move; }","repo":"christoff-buerger\/pmChess","label":[1,0,0,0]}
{"id":34697,"original_code":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\n\tthrows InterruptedException {\n\tdriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\n\tAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\n\tint lastindex = -1;\n\tboolean emplidfound = false;\n\tboolean dataprocessed = false;\n\tfor (int i = 1; i <= 25; i++) {\n\t\tSystem.out.println(\"\\nIteration no.: \" + i);\n\t\tWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\n\t\tString keydata = key.getText();\n\t\tSystem.out.println(keydata);\n\t\tboolean result = keydata.contains(\"Key: \" + emplid);\n\t\tString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\n\t\tThread.sleep(5000);\n\t\tif (result == true && actualDirection.equals(direction)) { \/\/ Validate if emplid is in the key\n\t\t\templidfound = true;\n\t\t\tString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tSystem.out.println(status);\n\t\t\tboolean statusresult = status.equals(\"PROCESSED\");\n\t\t\tString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO get the data id\n\t\t\tSystem.out.println(dataID);\n\t\t\t\/\/Validation if Data is processed\n\t\tif (statusresult == true) {\/\/ Validate if processed\n\t\t\tSystem.out.println(\"Data PROCESSED\");\n\t\t\tdataprocessed = true;\n\t\t\tlastindex = i;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tSystem.out.println(\"Data Not Yet Processed\");\n\t\t\tint count = 20;\n\t\t\tString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText();\/\/TODO to remove\n\t\t\tboolean correctdataid = dataID.equals(dataIDafterrefresh);\/\/TODO to remove\n\t\t\tSystem.out.println(correctdataid);\/\/TODO to remove\n\t\t\twhile (count != 0 && statusresult == false) {\/\/ Loop for\n\t\t\t\/\/ processed\n\t\t\t\tif(correctdataid==true){\n\t\t\tSystem.out.println(\"Status check: \" + status);\n\t\t\tSystem.out.println(count);\n\t\t\tdriver.navigate().refresh();\n\t\t\tThread.sleep(15000);\n\t\t\tstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tstatusresult = status.equals(\"PROCESSED\");\n\t\t\tcount--;\n\t\t\t}else\n\t\t\t{\n\t\t\t\t\/\/TODO GO BACK TO CHECK EMPLID\n\t\t\t}\n\t\t\t}\t\t\n\t\tif(statusresult==true)\n\t\t{\n\t\t\tlastindex = i;\n\t\t\tdataprocessed = true;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t\t} else {\n\t\tSystem.out.println(\"Checking next data\");\n\t\t}\n\t}\n\t\tif(!emplidfound)\n\t\t{\n\t\t\tSystem.out.println(\"No data in Sync Monitor\");\n\t\t\tAssert.assertTrue(emplidfound);\n\t\t}\n\t\tif(dataprocessed)\n\t\t{\n\t\t\tThread.sleep(3000);\n\t\t\tWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\t\t\t\/\/ Get data content\n\t\t\tString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\t\t\t\/\/ Validate that content was correct\n\t\t\tboolean contenttypefound = dataBlock.contains(contenttype);\n\t\t\tboolean contentfound = dataBlock.contains(content);\n\t\t\tAssert.assertEquals(true, contenttypefound);\n\t\t\tAssert.assertEquals(true, contentfound);\n\t\t}else{\n\t\t\tSystem.out.println(\"Data was not processed in sync monitor\");\n\t\t\tAssert.assertTrue(dataprocessed);\n\t\t}\n\t\t}","code_wo_comment":"public static void SyncMonitorDataValidation(WebDriver driver, String emplid, String contenttype, String content, TestParameters testParameters, String direction)\n\tthrows InterruptedException {\n\tdriver.get(testParameters.mURLMyInsead+testParameters.msyncMonitor);\n\tAssert.assertEquals(driver.getTitle(), \"MyINSEAD - Sync Monitor\");\n\tint lastindex = -1;\n\tboolean emplidfound = false;\n\tboolean dataprocessed = false;\n\tfor (int i = 1; i <= 25; i++) {\n\t\tSystem.out.println(\"\\nIteration no.: \" + i);\n\t\tWebElement key = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\"));\n\t\tString keydata = key.getText();\n\t\tSystem.out.println(keydata);\n\t\tboolean result = keydata.contains(\"Key: \" + emplid);\n\t\tString actualDirection = driver.findElement(By.xpath(\"\/\/*[@id='tblResult']\/tbody\/tr[\"+i+\"]\/td[3]\")).getText().trim();\n\t\tThread.sleep(5000);\n\t\tif (result == true && actualDirection.equals(direction)) {\n\t\t\templidfound = true;\n\t\t\tString status = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tSystem.out.println(status);\n\t\t\tboolean statusresult = status.equals(\"PROCESSED\");\n\t\t\tString dataID = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText()\n\t\t\tSystem.out.println(dataID);\n\t\t\n\t\tif (statusresult == true) \n\t\t\tSystem.out.println(\"Data PROCESSED\");\n\t\t\tdataprocessed = true;\n\t\t\tlastindex = i;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tSystem.out.println(\"Data Not Yet Processed\");\n\t\t\tint count = 20;\n\t\t\tString dataIDafterrefresh = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).getText()\n\t\t\tboolean correctdataid = dataID.equals(dataIDafterrefresh)\n\t\t\tSystem.out.println(correctdataid)\n\t\t\twhile (count != 0 && statusresult == false) \n\t\t\n\t\t\t\tif(correctdataid==true){\n\t\t\tSystem.out.println(\"Status check: \" + status);\n\t\t\tSystem.out.println(count);\n\t\t\tdriver.navigate().refresh();\n\t\t\tThread.sleep(15000);\n\t\t\tstatus = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).getText();\n\t\t\tstatusresult = status.equals(\"PROCESSED\");\n\t\t\tcount--;\n\t\t\t}else\n\t\t\t{\n\t\t\t\n\t\t\t}\n\t\t\t}\t\t\n\t\tif(statusresult==true)\n\t\t{\n\t\t\tlastindex = i;\n\t\t\tdataprocessed = true;\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\tbreak;\n\t\t} else {\n\t\tSystem.out.println(\"Checking next data\");\n\t\t}\n\t}\n\t\tif(!emplidfound)\n\t\t{\n\t\t\tSystem.out.println(\"No data in Sync Monitor\");\n\t\t\tAssert.assertTrue(emplidfound);\n\t\t}\n\t\tif(dataprocessed)\n\t\t{\n\t\t\tThread.sleep(3000);\n\t\t\tWebElement button = driver.findElement(By.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\"));\n\t\t\n\t\t\tString dataBlock = button.getAttribute(\"data-content\").replaceAll(\"\\\\s+\", \"\");\n\t\t\n\t\t\tboolean contenttypefound = dataBlock.contains(contenttype);\n\t\t\tboolean contentfound = dataBlock.contains(content);\n\t\t\tAssert.assertEquals(true, contenttypefound);\n\t\t\tAssert.assertEquals(true, contentfound);\n\t\t}else{\n\t\t\tSystem.out.println(\"Data was not processed in sync monitor\");\n\t\t\tAssert.assertTrue(dataprocessed);\n\t\t}\n\t\t}","cleancode":"public static void syncmonitordatavalidation(webdriver driver, string emplid, string contenttype, string content, testparameters testparameters, string direction) throws interruptedexception { driver.get(testparameters.murlmyinsead+testparameters.msyncmonitor); assert.assertequals(driver.gettitle(), \"myinsead - sync monitor\"); int lastindex = -1; boolean emplidfound = false; boolean dataprocessed = false; for (int i = 1; i <= 25; i++) { system.out.println(\"\\niteration no.: \" + i); webelement key = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[5]\")); string keydata = key.gettext(); system.out.println(keydata); boolean result = keydata.contains(\"key: \" + emplid); string actualdirection = driver.findelement(by.xpath(\"\/\/*[@id='tblresult']\/tbody\/tr[\"+i+\"]\/td[3]\")).gettext().trim(); thread.sleep(5000); if (result == true && actualdirection.equals(direction)) { emplidfound = true; string status = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).gettext(); system.out.println(status); boolean statusresult = status.equals(\"processed\"); string dataid = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).gettext() system.out.println(dataid); if (statusresult == true) system.out.println(\"data processed\"); dataprocessed = true; lastindex = i; break; } else { system.out.println(\"data not yet processed\"); int count = 20; string dataidafterrefresh = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\"+i+\"]\/td)[1]\")).gettext() boolean correctdataid = dataid.equals(dataidafterrefresh) system.out.println(correctdataid) while (count != 0 && statusresult == false) if(correctdataid==true){ system.out.println(\"status check: \" + status); system.out.println(count); driver.navigate().refresh(); thread.sleep(15000); status = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + i + \"]\/td)[2]\")).gettext(); statusresult = status.equals(\"processed\"); count--; }else { } } if(statusresult==true) { lastindex = i; dataprocessed = true; break; } } break; } else { system.out.println(\"checking next data\"); } } if(!emplidfound) { system.out.println(\"no data in sync monitor\"); assert.asserttrue(emplidfound); } if(dataprocessed) { thread.sleep(3000); webelement button = driver.findelement(by.xpath(\"(\/\/tbody\/tr[\" + lastindex + \"]\/td)[1]\/button\")); string datablock = button.getattribute(\"data-content\").replaceall(\"\\\\s+\", \"\"); boolean contenttypefound = datablock.contains(contenttype); boolean contentfound = datablock.contains(content); assert.assertequals(true, contenttypefound); assert.assertequals(true, contentfound); }else{ system.out.println(\"data was not processed in sync monitor\"); assert.asserttrue(dataprocessed); } }","repo":"aurelienartus\/testproject","label":[1,0,0,0]}
{"id":1954,"original_code":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        Security security = (Security)request.getAttribute(\"security\");\n        GenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\n        ServletContext servletContext = session.getServletContext();\n        String webSiteId = WebSiteWorker.getWebSiteId(request);\n        Delegator delegator = (Delegator)request.getAttribute(\"delegator\");\n        LocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\n        Map<String, Object> paramMap = UtilHttp.getParameterMap(request);\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, paramMap:\" + paramMap , module);\n        String targContentId = (String)paramMap.get(\"contentId\"); \/\/ The content to be linked to one or more sites\n        String roles = null;\n        String authorId = null;\n        GenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\n        if (authorContent != null) {\n            authorId = authorContent.getString(\"contentId\");\n        } else {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\n            return \"error\";\n        }\n        \/\/ Determine if user is owner of target content\n        String userLoginId = userLogin.getString(\"userLoginId\");\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, userLoginId:\" + userLoginId + \" authorId:\" + authorId , module);\n        List<String> roleTypeList = null;\n        if (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\n            roles = \"OWNER\";\n            roleTypeList = StringUtil.split(roles, \"|\");\n        }\n        List<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\n        List<String> contentPurposeList = null; \/\/UtilMisc.toList(\"ARTICLE\");\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, roles:\" + roles +\" roleTypeList:\" + roleTypeList , module);\n        String permittedAction = (String)paramMap.get(\"permittedAction\"); \/\/ The content to be linked to one or more sites\n        String permittedOperations = (String)paramMap.get(\"permittedOperations\"); \/\/ The content to be linked to one or more sites\n        if (UtilValidate.isEmpty(targContentId)) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\n            return \"error\";\n        }\n        \/\/ Get all the subSites that the user is permitted to link to\n        List<Object []> origPublishedLinkList = null;\n        try {\n            \/\/ TODO: this needs to be given author userLogin\n            EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\n            origPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n        } catch (GenericEntityException e) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n            return \"error\";\n        } catch (GeneralException e2) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n            return \"error\";\n        }\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origPublishedLinkList:\" + origPublishedLinkList , module);\n        \/\/ make a map of the values that are passed in using the top subSite as the key.\n        \/\/ Content can only be linked to one subsite under a top site (ends with \"_MASTER\")\n        Map<String, String> siteIdLookup = new HashMap<String, String>();\n        for (String param : paramMap.keySet()) {\n            int pos = param.indexOf(\"select_\");\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, param:\" + param + \" pos:\" + pos , module);\n            if (pos >= 0) {\n                String siteId = param.substring(7);\n                String subSiteVal = (String)paramMap.get(param);\n                siteIdLookup.put(siteId, subSiteVal);\n            }\n        }\n        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, siteIdLookup:\" + siteIdLookup , module);\n        \/\/ Loop thru all the possible subsites\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \/\/ int counter = 0;\n        String responseMessage = null;\n        String errorMessage = null;\n        \/\/ String permissionMessage = null;\n        boolean statusIdUpdated = false;\n        Map<String, Object> results = null;\n        for (Object [] arr : origPublishedLinkList) {\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, arr:\" + Arrays.asList(arr) , module);\n            String contentId = (String)arr[0]; \/\/ main (2nd level) site id\n            String origSubContentId = null;\n            List<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n            \/\/ Timestamp topFromDate = (Timestamp)arr[3];\n            Timestamp origFromDate = null;\n            for (Object [] pubArr : origSubList) {\n            \/\/ see if a link already exists by looking for non-null fromDate\n                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, pubArr:\" + Arrays.asList(pubArr) , module);\n                Timestamp fromDate = (Timestamp)pubArr[2];\n                origSubContentId = null;\n                if (fromDate != null) {\n                    origSubContentId = (String)pubArr[0];\n                    origFromDate = fromDate;\n                    break;\n                }\n            }\n            String currentSubContentId = siteIdLookup.get(contentId);\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, currentSubContentId:\" + currentSubContentId , module);\n            \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, origSubContentId:\" + origSubContentId , module);\n            try {\n                if (UtilValidate.isNotEmpty(currentSubContentId)) {\n                    if (!currentSubContentId.equals(origSubContentId)) {\n                        \/\/ disable existing link\n                        if (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\n                            List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                                    .where(\"contentId\", targContentId, \n                                            \"contentIdTo\", origSubContentId, \n                                            \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                            \"thruDate\", null)\n                                    .queryList();\n                            for (GenericValue cAssoc : oldActiveValues) {\n                                cAssoc.set(\"thruDate\", nowTimestamp);\n                                cAssoc.store();\n                                \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, deactivating:\" + cAssoc , module);\n                            }\n                        }\n                        \/\/ create new link\n                        Map<String, Object> serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", currentSubContentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        responseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\n                        if (UtilValidate.isNotEmpty(responseMessage)) {\n                            errorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\n                            Debug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\n                            Debug.logError(errorMessage, module);\n                            request.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\n                            return \"error\";\n                        }\n                        serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", contentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, serviceIn(3b):\" + serviceIn , module);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        \/\/if (Debug.infoOn()) Debug.logInfo(\"in updatePublishLinks, results(3b):\" + results , module);\n                        if (!statusIdUpdated) {\n                            try {\n                                GenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\n                                targContent.set(\"statusId\", \"CTNT_PUBLISHED\");\n                                targContent.store();\n                                statusIdUpdated = true;\n                            } catch (GenericEntityException e) {\n                                Debug.logError(e.getMessage(), module);\n                                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                                return \"error\";\n                            }\n                        }\n                    }\n                } else if (UtilValidate.isNotEmpty(origSubContentId)) {\n                    \/\/ if no current link is passed in, look to see if there is an existing link(s) that must be disabled\n                    List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                            .where(\"contentId\", targContentId, \n                                    \"contentIdTo\", origSubContentId, \n                                    \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                    \"thruDate\", null)\n                            .queryList();\n                    for (GenericValue cAssoc : oldActiveValues) {\n                        cAssoc.set(\"thruDate\", nowTimestamp);\n                        cAssoc.store();\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logError(e.getMessage(), module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                return \"error\";\n            } catch (GenericServiceException e2) {\n                Debug.logError(e2, module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n                return \"error\";\n            }\n        }\n        return \"success\";\n    }","code_wo_comment":"public static String updatePublishLinks(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        Security security = (Security)request.getAttribute(\"security\");\n        GenericValue userLogin = (GenericValue)session.getAttribute(\"userLogin\");\n        ServletContext servletContext = session.getServletContext();\n        String webSiteId = WebSiteWorker.getWebSiteId(request);\n        Delegator delegator = (Delegator)request.getAttribute(\"delegator\");\n        LocalDispatcher dispatcher = (LocalDispatcher)request.getAttribute(\"dispatcher\");\n        Map<String, Object> paramMap = UtilHttp.getParameterMap(request);\n       \n        String targContentId = (String)paramMap.get(\"contentId\");\n        String roles = null;\n        String authorId = null;\n        GenericValue authorContent = ContentManagementWorker.getAuthorContent(delegator, targContentId);\n        if (authorContent != null) {\n            authorId = authorContent.getString(\"contentId\");\n        } else {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"authorContent is empty.\");\n            return \"error\";\n        }\n       \n        String userLoginId = userLogin.getString(\"userLoginId\");\n       \n        List<String> roleTypeList = null;\n        if (authorId != null && userLoginId != null && authorId.equals(userLoginId)) {\n            roles = \"OWNER\";\n            roleTypeList = StringUtil.split(roles, \"|\");\n        }\n        List<String> targetOperationList = UtilMisc.<String>toList(\"CONTENT_PUBLISH\");\n        List<String> contentPurposeList = null;\n       \n        String permittedAction = (String)paramMap.get(\"permittedAction\");\n        String permittedOperations = (String)paramMap.get(\"permittedOperations\");\n        if (UtilValidate.isEmpty(targContentId)) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", \"targContentId is empty.\");\n            return \"error\";\n        }\n       \n        List<Object []> origPublishedLinkList = null;\n        try {\n           \n            EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", authorId).cache().queryOne();\n            origPublishedLinkList = ContentManagementWorker.getPublishedLinks(delegator, targContentId, webSiteId, userLogin, security, permittedAction, permittedOperations, roles);\n        } catch (GenericEntityException e) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n            return \"error\";\n        } catch (GeneralException e2) {\n            request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n            return \"error\";\n        }\n               \n       \n       \n        Map<String, String> siteIdLookup = new HashMap<String, String>();\n        for (String param : paramMap.keySet()) {\n            int pos = param.indexOf(\"select_\");\n               \n            if (pos >= 0) {\n                String siteId = param.substring(7);\n                String subSiteVal = (String)paramMap.get(param);\n                siteIdLookup.put(siteId, subSiteVal);\n            }\n        }\n       \n       \n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n       \n        String responseMessage = null;\n        String errorMessage = null;\n       \n        boolean statusIdUpdated = false;\n        Map<String, Object> results = null;\n        for (Object [] arr : origPublishedLinkList) {\n           \n            String contentId = (String)arr[0];\n            String origSubContentId = null;\n            List<Object []> origSubList = UtilGenerics.checkList(arr[1]);\n           \n            Timestamp origFromDate = null;\n            for (Object [] pubArr : origSubList) {\n           \n               \n                Timestamp fromDate = (Timestamp)pubArr[2];\n                origSubContentId = null;\n                if (fromDate != null) {\n                    origSubContentId = (String)pubArr[0];\n                    origFromDate = fromDate;\n                    break;\n                }\n            }\n            String currentSubContentId = siteIdLookup.get(contentId);\n           \n           \n            try {\n                if (UtilValidate.isNotEmpty(currentSubContentId)) {\n                    if (!currentSubContentId.equals(origSubContentId)) {\n                       \n                        if (UtilValidate.isNotEmpty(origSubContentId) && origFromDate != null) {\n                            List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                                    .where(\"contentId\", targContentId, \n                                            \"contentIdTo\", origSubContentId, \n                                            \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                            \"thruDate\", null)\n                                    .queryList();\n                            for (GenericValue cAssoc : oldActiveValues) {\n                                cAssoc.set(\"thruDate\", nowTimestamp);\n                                cAssoc.store();\n                               \n                            }\n                        }\n                       \n                        Map<String, Object> serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", currentSubContentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                        responseMessage = (String)results.get(ModelService.RESPONSE_MESSAGE);\n                        if (UtilValidate.isNotEmpty(responseMessage)) {\n                            errorMessage = (String)results.get(ModelService.ERROR_MESSAGE);\n                            Debug.logError(\"in updatePublishLinks, serviceIn:\" + serviceIn , module);\n                            Debug.logError(errorMessage, module);\n                            request.setAttribute(\"_ERROR_MESSAGE_\", errorMessage);\n                            return \"error\";\n                        }\n                        serviceIn = new HashMap<String, Object>();\n                        serviceIn.put(\"userLogin\", userLogin);\n                        serviceIn.put(\"contentId\", targContentId);\n                        serviceIn.put(\"contentAssocTypeId\", \"PUBLISH_LINK\");\n                        serviceIn.put(\"fromDate\", nowTimestamp);\n                        serviceIn.put(\"contentIdTo\", contentId);\n                        serviceIn.put(\"roleTypeList\", roleTypeList);\n                        serviceIn.put(\"targetOperationList\", targetOperationList);\n                        serviceIn.put(\"contentPurposeList\", contentPurposeList);\n                       \n                        results = dispatcher.runSync(\"createContentAssoc\", serviceIn);\n                       \n                        if (!statusIdUpdated) {\n                            try {\n                                GenericValue targContent = EntityQuery.use(delegator).from(\"Content\").where(\"contentId\", targContentId).queryOne();\n                                targContent.set(\"statusId\", \"CTNT_PUBLISHED\");\n                                targContent.store();\n                                statusIdUpdated = true;\n                            } catch (GenericEntityException e) {\n                                Debug.logError(e.getMessage(), module);\n                                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                                return \"error\";\n                            }\n                        }\n                    }\n                } else if (UtilValidate.isNotEmpty(origSubContentId)) {\n                   \n                    List<GenericValue> oldActiveValues = EntityQuery.use(delegator).from(\"ContentAssoc\")\n                            .where(\"contentId\", targContentId, \n                                    \"contentIdTo\", origSubContentId, \n                                    \"contentAssocTypeId\", \"PUBLISH_LINK\", \n                                    \"thruDate\", null)\n                            .queryList();\n                    for (GenericValue cAssoc : oldActiveValues) {\n                        cAssoc.set(\"thruDate\", nowTimestamp);\n                        cAssoc.store();\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logError(e.getMessage(), module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e.getMessage());\n                return \"error\";\n            } catch (GenericServiceException e2) {\n                Debug.logError(e2, module);\n                request.setAttribute(\"_ERROR_MESSAGE_\", e2.getMessage());\n                return \"error\";\n            }\n        }\n        return \"success\";\n    }","cleancode":"public static string updatepublishlinks(httpservletrequest request, httpservletresponse response) { httpsession session = request.getsession(); security security = (security)request.getattribute(\"security\"); genericvalue userlogin = (genericvalue)session.getattribute(\"userlogin\"); servletcontext servletcontext = session.getservletcontext(); string websiteid = websiteworker.getwebsiteid(request); delegator delegator = (delegator)request.getattribute(\"delegator\"); localdispatcher dispatcher = (localdispatcher)request.getattribute(\"dispatcher\"); map<string, object> parammap = utilhttp.getparametermap(request); string targcontentid = (string)parammap.get(\"contentid\"); string roles = null; string authorid = null; genericvalue authorcontent = contentmanagementworker.getauthorcontent(delegator, targcontentid); if (authorcontent != null) { authorid = authorcontent.getstring(\"contentid\"); } else { request.setattribute(\"_error_message_\", \"authorcontent is empty.\"); return \"error\"; } string userloginid = userlogin.getstring(\"userloginid\"); list<string> roletypelist = null; if (authorid != null && userloginid != null && authorid.equals(userloginid)) { roles = \"owner\"; roletypelist = stringutil.split(roles, \"|\"); } list<string> targetoperationlist = utilmisc.<string>tolist(\"content_publish\"); list<string> contentpurposelist = null; string permittedaction = (string)parammap.get(\"permittedaction\"); string permittedoperations = (string)parammap.get(\"permittedoperations\"); if (utilvalidate.isempty(targcontentid)) { request.setattribute(\"_error_message_\", \"targcontentid is empty.\"); return \"error\"; } list<object []> origpublishedlinklist = null; try { entityquery.use(delegator).from(\"userlogin\").where(\"userloginid\", authorid).cache().queryone(); origpublishedlinklist = contentmanagementworker.getpublishedlinks(delegator, targcontentid, websiteid, userlogin, security, permittedaction, permittedoperations, roles); } catch (genericentityexception e) { request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } catch (generalexception e2) { request.setattribute(\"_error_message_\", e2.getmessage()); return \"error\"; } map<string, string> siteidlookup = new hashmap<string, string>(); for (string param : parammap.keyset()) { int pos = param.indexof(\"select_\"); if (pos >= 0) { string siteid = param.substring(7); string subsiteval = (string)parammap.get(param); siteidlookup.put(siteid, subsiteval); } } timestamp nowtimestamp = utildatetime.nowtimestamp(); string responsemessage = null; string errormessage = null; boolean statusidupdated = false; map<string, object> results = null; for (object [] arr : origpublishedlinklist) { string contentid = (string)arr[0]; string origsubcontentid = null; list<object []> origsublist = utilgenerics.checklist(arr[1]); timestamp origfromdate = null; for (object [] pubarr : origsublist) { timestamp fromdate = (timestamp)pubarr[2]; origsubcontentid = null; if (fromdate != null) { origsubcontentid = (string)pubarr[0]; origfromdate = fromdate; break; } } string currentsubcontentid = siteidlookup.get(contentid); try { if (utilvalidate.isnotempty(currentsubcontentid)) { if (!currentsubcontentid.equals(origsubcontentid)) { if (utilvalidate.isnotempty(origsubcontentid) && origfromdate != null) { list<genericvalue> oldactivevalues = entityquery.use(delegator).from(\"contentassoc\") .where(\"contentid\", targcontentid, \"contentidto\", origsubcontentid, \"contentassoctypeid\", \"publish_link\", \"thrudate\", null) .querylist(); for (genericvalue cassoc : oldactivevalues) { cassoc.set(\"thrudate\", nowtimestamp); cassoc.store(); } } map<string, object> servicein = new hashmap<string, object>(); servicein.put(\"userlogin\", userlogin); servicein.put(\"contentid\", targcontentid); servicein.put(\"contentassoctypeid\", \"publish_link\"); servicein.put(\"fromdate\", nowtimestamp); servicein.put(\"contentidto\", currentsubcontentid); servicein.put(\"roletypelist\", roletypelist); servicein.put(\"targetoperationlist\", targetoperationlist); servicein.put(\"contentpurposelist\", contentpurposelist); results = dispatcher.runsync(\"createcontentassoc\", servicein); responsemessage = (string)results.get(modelservice.response_message); if (utilvalidate.isnotempty(responsemessage)) { errormessage = (string)results.get(modelservice.error_message); debug.logerror(\"in updatepublishlinks, servicein:\" + servicein , module); debug.logerror(errormessage, module); request.setattribute(\"_error_message_\", errormessage); return \"error\"; } servicein = new hashmap<string, object>(); servicein.put(\"userlogin\", userlogin); servicein.put(\"contentid\", targcontentid); servicein.put(\"contentassoctypeid\", \"publish_link\"); servicein.put(\"fromdate\", nowtimestamp); servicein.put(\"contentidto\", contentid); servicein.put(\"roletypelist\", roletypelist); servicein.put(\"targetoperationlist\", targetoperationlist); servicein.put(\"contentpurposelist\", contentpurposelist); results = dispatcher.runsync(\"createcontentassoc\", servicein); if (!statusidupdated) { try { genericvalue targcontent = entityquery.use(delegator).from(\"content\").where(\"contentid\", targcontentid).queryone(); targcontent.set(\"statusid\", \"ctnt_published\"); targcontent.store(); statusidupdated = true; } catch (genericentityexception e) { debug.logerror(e.getmessage(), module); request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } } } } else if (utilvalidate.isnotempty(origsubcontentid)) { list<genericvalue> oldactivevalues = entityquery.use(delegator).from(\"contentassoc\") .where(\"contentid\", targcontentid, \"contentidto\", origsubcontentid, \"contentassoctypeid\", \"publish_link\", \"thrudate\", null) .querylist(); for (genericvalue cassoc : oldactivevalues) { cassoc.set(\"thrudate\", nowtimestamp); cassoc.store(); } } } catch (genericentityexception e) { debug.logerror(e.getmessage(), module); request.setattribute(\"_error_message_\", e.getmessage()); return \"error\"; } catch (genericserviceexception e2) { debug.logerror(e2, module); request.setattribute(\"_error_message_\", e2.getmessage()); return \"error\"; } } return \"success\"; }","repo":"atb\/ofbiz","label":[1,0,0,0]}
{"id":1998,"original_code":"public boolean storedRSVs(String operator) {\n        return true;\n    }","code_wo_comment":"public boolean storedRSVs(String operator) {\n        return true;\n    }","cleancode":"public boolean storedrsvs(string operator) { return true; }","repo":"automenta\/java-unidu-pire","label":[1,0,0,0]}
{"id":34787,"original_code":"@NotNull\n    @Override\n    public UserReference toReference(@NotNull RedditClient reddit) {\n        return reddit.user(getName());\n    }","code_wo_comment":"@NotNull\n    @Override\n    public UserReference toReference(@NotNull RedditClient reddit) {\n        return reddit.user(getName());\n    }","cleancode":"@notnull @override public userreference toreference(@notnull redditclient reddit) { return reddit.user(getname()); }","repo":"andsala\/JRAW","label":[1,0,0,0]}
{"id":34902,"original_code":"public static int[] parseJavaVersion(final String jdkVer) {\n    final int p0, p1;\n    try {\n      String[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\");\/\/grab only number groups and \".\"\n      parts = parts[0].split(\"\\\\.\"); \/\/split out the number groups\n      p0 = Integer.parseInt(parts[0]); \/\/the first number group\n      p1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0; \/\/2nd number group, or 0\n    } catch (final NumberFormatException | ArrayIndexOutOfBoundsException  e) {\n      throw new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n    }\n    \/\/checkJavaVersion(jdkVer, p0, p1); \/\/TODO Optional to omit this.\n    return new int[] {p0, p1};\n  }","code_wo_comment":"public static int[] parseJavaVersion(final String jdkVer) {\n    final int p0, p1;\n    try {\n      String[] parts = jdkVer.trim().split(\"[^0-9\\\\.]\")\n      parts = parts[0].split(\"\\\\.\");\n      p0 = Integer.parseInt(parts[0]);\n      p1 = (parts.length > 1) ? Integer.parseInt(parts[1]) : 0;\n    } catch (final NumberFormatException | ArrayIndexOutOfBoundsException  e) {\n      throw new IllegalArgumentException(\"Improper Java -version string: \" + jdkVer + \"\\n\" + e);\n    }\n   \n    return new int[] {p0, p1};\n  }","cleancode":"public static int[] parsejavaversion(final string jdkver) { final int p0, p1; try { string[] parts = jdkver.trim().split(\"[^0-9\\\\.]\") parts = parts[0].split(\"\\\\.\"); p0 = integer.parseint(parts[0]); p1 = (parts.length > 1) ? integer.parseint(parts[1]) : 0; } catch (final numberformatexception | arrayindexoutofboundsexception e) { throw new illegalargumentexception(\"improper java -version string: \" + jdkver + \"\\n\" + e); } return new int[] {p0, p1}; }","repo":"apache\/incubator-datasketches-memory","label":[1,0,0,0]}
{"id":34920,"original_code":"@Deprecated\n    public static float getScreenPixelRatio() {\n        \/\/TODO replace with API from Java 9 once that is released\n        if (Platform.isMac()) {\n            Toolkit toolkit = Toolkit.getDefaultToolkit();\n            Object contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\n            if (contentScaleFactor instanceof Number) {\n                return ((Number) contentScaleFactor).floatValue();\n            } else {\n                return 1.0f;\n            }\n        } else {\n            return 1.0f;\n        }\n    }","code_wo_comment":"@Deprecated\n    public static float getScreenPixelRatio() {\n       \n        if (Platform.isMac()) {\n            Toolkit toolkit = Toolkit.getDefaultToolkit();\n            Object contentScaleFactor = toolkit.getDesktopProperty(\"apple.awt.contentScaleFactor\");\n            if (contentScaleFactor instanceof Number) {\n                return ((Number) contentScaleFactor).floatValue();\n            } else {\n                return 1.0f;\n            }\n        } else {\n            return 1.0f;\n        }\n    }","cleancode":"@deprecated public static float getscreenpixelratio() { if (platform.ismac()) { toolkit toolkit = toolkit.getdefaulttoolkit(); object contentscalefactor = toolkit.getdesktopproperty(\"apple.awt.contentscalefactor\"); if (contentscalefactor instanceof number) { return ((number) contentscalefactor).floatvalue(); } else { return 1.0f; } } else { return 1.0f; } }","repo":"colorizenl\/colorize-java-commons","label":[1,0,0,0]}
{"id":10429,"original_code":"@Override\n    public Object onExecute(ExecutionEvent event) throws ExecutionException {\n        project = PluginUtil.getSelectedProject();\n        try {\n            if (project == null) {\n                throw new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n            }\n            basePath = project.getLocation().toString();\n            if (MavenUtils.isMavenProject(project)) {\n                destinationPath = MavenUtils.getTargetPath(project);\n            } else {\n                destinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n                        .normalize().toString();\n            }\n            \/\/ Stop running container\n            String runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\n            if (runningContainerId != null) {\n                boolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\n                        Constant.MESSAGE_CONFIRM_STOP_CONTAINER);\n                if (stop) {\n                    DockerRuntime.getInstance().cleanRuningContainer(basePath);\n                } else {\n                    return null;\n                }\n            }\n            \/\/ Build artifact\n            ConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\n            if (MavenUtils.isMavenProject(project)) {\n                MavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\n                IContainer container;\n                container = MavenUtils.getPomFile(project).getParent();\n                action.launch(container, () -> {\n                    \/\/ TODO: callback after mvn package done. IMPORTANT\n                    buildAndRun(event);\n                    return null;\n                });\n            } else {\n                WarUtil.export(project, destinationPath);\n                buildAndRun(event);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            ConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\n            sendTelemetryOnException(event, e);\n        }\n        return null;\n    }","code_wo_comment":"@Override\n    public Object onExecute(ExecutionEvent event) throws ExecutionException {\n        project = PluginUtil.getSelectedProject();\n        try {\n            if (project == null) {\n                throw new Exception(Constant.ERROR_NO_SELECTED_PROJECT);\n            }\n            basePath = project.getLocation().toString();\n            if (MavenUtils.isMavenProject(project)) {\n                destinationPath = MavenUtils.getTargetPath(project);\n            } else {\n                destinationPath = Paths.get(basePath, Constant.DOCKERFILE_FOLDER, project.getName() + \".war\")\n                        .normalize().toString();\n            }\n           \n            String runningContainerId = DockerRuntime.getInstance().getRunningContainerId(basePath);\n            if (runningContainerId != null) {\n                boolean stop = MessageDialog.openConfirm(PluginUtil.getParentShell(), \"Confirmation\",\n                        Constant.MESSAGE_CONFIRM_STOP_CONTAINER);\n                if (stop) {\n                    DockerRuntime.getInstance().cleanRuningContainer(basePath);\n                } else {\n                    return null;\n                }\n            }\n           \n            ConsoleLogger.info(String.format(Constant.MESSAGE_EXPORTING_PROJECT, destinationPath));\n            if (MavenUtils.isMavenProject(project)) {\n                MavenExecuteAction action = new MavenExecuteAction(MAVEN_GOALS);\n                IContainer container;\n                container = MavenUtils.getPomFile(project).getParent();\n                action.launch(container, () -> {\n                   \n                    buildAndRun(event);\n                    return null;\n                });\n            } else {\n                WarUtil.export(project, destinationPath);\n                buildAndRun(event);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            ConsoleLogger.error(String.format(Constant.ERROR_RUNNING_DOCKER, e.getMessage()));\n            sendTelemetryOnException(event, e);\n        }\n        return null;\n    }","cleancode":"@override public object onexecute(executionevent event) throws executionexception { project = pluginutil.getselectedproject(); try { if (project == null) { throw new exception(constant.error_no_selected_project); } basepath = project.getlocation().tostring(); if (mavenutils.ismavenproject(project)) { destinationpath = mavenutils.gettargetpath(project); } else { destinationpath = paths.get(basepath, constant.dockerfile_folder, project.getname() + \".war\") .normalize().tostring(); } string runningcontainerid = dockerruntime.getinstance().getrunningcontainerid(basepath); if (runningcontainerid != null) { boolean stop = messagedialog.openconfirm(pluginutil.getparentshell(), \"confirmation\", constant.message_confirm_stop_container); if (stop) { dockerruntime.getinstance().cleanruningcontainer(basepath); } else { return null; } } consolelogger.info(string.format(constant.message_exporting_project, destinationpath)); if (mavenutils.ismavenproject(project)) { mavenexecuteaction action = new mavenexecuteaction(maven_goals); icontainer container; container = mavenutils.getpomfile(project).getparent(); action.launch(container, () -> { buildandrun(event); return null; }); } else { warutil.export(project, destinationpath); buildandrun(event); } } catch (exception e) { e.printstacktrace(); consolelogger.error(string.format(constant.error_running_docker, e.getmessage())); sendtelemetryonexception(event, e); } return null; }","repo":"andxu\/azure-tools-for-java","label":[0,1,0,0]}
{"id":2322,"original_code":"public ValueInstantiator createOptimized()\n    {\n        \/* [Issue#11]: Need to avoid optimizing if we use delegate- or\n         *  property-based creators.\n         *\/\n        if (_originalInstantiator.canCreateFromObjectWith()\n                || _originalInstantiator.canCreateUsingDelegate()) {\n            return null;\n        }\n        \/\/ for now, only consider need to handle default creator\n        AnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\n        if (defaultCreator != null) {\n            AnnotatedElement elem = defaultCreator.getAnnotated();\n            if (elem instanceof Constructor<?>) {\n                \/\/ First things first: as per [Issue#34], can NOT access private ctors or methods\n                Constructor<?> ctor = (Constructor<?>) elem;\n                if (!Modifier.isPrivate(ctor.getModifiers())) {\n                    return createSubclass(ctor, null).with(_originalInstantiator);\n                }\n            } else if (elem instanceof Method) {\n                Method m = (Method) elem;\n                int mods = m.getModifiers();\n                \/\/ and as above, can't access private ones\n                if (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\n                    return createSubclass(null, m).with(_originalInstantiator);\n                }\n            }\n        }\n        return null;\n    }","code_wo_comment":"public ValueInstantiator createOptimized()\n    {\n       \n        if (_originalInstantiator.canCreateFromObjectWith()\n                || _originalInstantiator.canCreateUsingDelegate()) {\n            return null;\n        }\n       \n        AnnotatedWithParams defaultCreator = _originalInstantiator.getDefaultCreator();\n        if (defaultCreator != null) {\n            AnnotatedElement elem = defaultCreator.getAnnotated();\n            if (elem instanceof Constructor<?>) {\n               \n                Constructor<?> ctor = (Constructor<?>) elem;\n                if (!Modifier.isPrivate(ctor.getModifiers())) {\n                    return createSubclass(ctor, null).with(_originalInstantiator);\n                }\n            } else if (elem instanceof Method) {\n                Method m = (Method) elem;\n                int mods = m.getModifiers();\n               \n                if (Modifier.isStatic(mods) && !Modifier.isPrivate(mods)) {\n                    return createSubclass(null, m).with(_originalInstantiator);\n                }\n            }\n        }\n        return null;\n    }","cleancode":"public valueinstantiator createoptimized() { if (_originalinstantiator.cancreatefromobjectwith() || _originalinstantiator.cancreateusingdelegate()) { return null; } annotatedwithparams defaultcreator = _originalinstantiator.getdefaultcreator(); if (defaultcreator != null) { annotatedelement elem = defaultcreator.getannotated(); if (elem instanceof constructor<?>) { constructor<?> ctor = (constructor<?>) elem; if (!modifier.isprivate(ctor.getmodifiers())) { return createsubclass(ctor, null).with(_originalinstantiator); } } else if (elem instanceof method) { method m = (method) elem; int mods = m.getmodifiers(); if (modifier.isstatic(mods) && !modifier.isprivate(mods)) { return createsubclass(null, m).with(_originalinstantiator); } } } return null; }","repo":"bsanchezb\/jackson-modules-base","label":[1,0,0,0]}
{"id":10679,"original_code":"@Override\n  public void flush(long timeoutMillis) {\n    \/\/ TODO: Flush transport\n  }","code_wo_comment":"@Override\n  public void flush(long timeoutMillis) {\n   \n  }","cleancode":"@override public void flush(long timeoutmillis) { }","repo":"bsergean\/sentry-android","label":[0,1,0,0]}
{"id":18946,"original_code":"protected boolean startsWithReferenceAnchor(TextLine line) {\n    if (line == null) {\n      return false;\n    }\n    String text = line.getText();\n    if (text == null) {\n      return false;\n    }\n    return REFERENCE_ANCHOR.matcher(text).find();\n  }","code_wo_comment":"protected boolean startsWithReferenceAnchor(TextLine line) {\n    if (line == null) {\n      return false;\n    }\n    String text = line.getText();\n    if (text == null) {\n      return false;\n    }\n    return REFERENCE_ANCHOR.matcher(text).find();\n  }","cleancode":"protected boolean startswithreferenceanchor(textline line) { if (line == null) { return false; } string text = line.gettext(); if (text == null) { return false; } return reference_anchor.matcher(text).find(); }","repo":"ckorzen\/pdfact","label":[0,1,0,0]}
{"id":10779,"original_code":"public Future<?>  greetMeSometimeAsync(String requestType, \n                                           AsyncHandler<GreetMeSometimeResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Future<?>  greetMeSometimeAsync(String requestType, \n                                           AsyncHandler<GreetMeSometimeResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmesometimeasync(string requesttype, asynchandler<greetmesometimeresponse> asynchandler) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10780,"original_code":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Response<GreetMeSometimeResponse> greetMeSometimeAsync(String requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmesometimeresponse> greetmesometimeasync(string requesttype) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10781,"original_code":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {  \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Response<TestDocLitFaultResponse> testDocLitFaultAsync(String faultType) {  \n        return null; \n       \n    }","cleancode":"public response<testdoclitfaultresponse> testdoclitfaultasync(string faulttype) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10782,"original_code":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {  \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Future<?> testDocLitFaultAsync(String faultType, AsyncHandler ah) {  \n        return null; \n       \n    }","cleancode":"public future<?> testdoclitfaultasync(string faulttype, asynchandler ah) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10783,"original_code":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\n        return null;\n        \/* not called *\/\n    }","code_wo_comment":"public Future<?> testDocLitBareAsync(String bare, AsyncHandler ah) {\n        return null;\n       \n    }","cleancode":"public future<?> testdoclitbareasync(string bare, asynchandler ah) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10784,"original_code":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\n        return null;\n        \/* not called *\/\n    }","code_wo_comment":"public Response<BareDocumentResponse> testDocLitBareAsync(String bare) {\n        return null;\n       \n    }","cleancode":"public response<baredocumentresponse> testdoclitbareasync(string bare) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10785,"original_code":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Future<?> greetMeAsync(String requestType, AsyncHandler<GreetMeResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmeasync(string requesttype, asynchandler<greetmeresponse> asynchandler) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10786,"original_code":"public Response<GreetMeResponse> greetMeAsync(String requestType) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Response<GreetMeResponse> greetMeAsync(String requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmeresponse> greetmeasync(string requesttype) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10787,"original_code":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Future<?> greetMeLaterAsync(long requestType, AsyncHandler<GreetMeLaterResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> greetmelaterasync(long requesttype, asynchandler<greetmelaterresponse> asynchandler) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10788,"original_code":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Response<GreetMeLaterResponse> greetMeLaterAsync(long requestType) { \n        return null; \n       \n    }","cleancode":"public response<greetmelaterresponse> greetmelaterasync(long requesttype) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10789,"original_code":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Future<?> sayHiAsync(AsyncHandler<SayHiResponse> asyncHandler) { \n        return null; \n       \n    }","cleancode":"public future<?> sayhiasync(asynchandler<sayhiresponse> asynchandler) { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10790,"original_code":"public Response<SayHiResponse> sayHiAsync() { \n        return null; \n        \/*not called *\/\n    }","code_wo_comment":"public Response<SayHiResponse> sayHiAsync() { \n        return null; \n       \n    }","cleancode":"public response<sayhiresponse> sayhiasync() { return null; }","repo":"apache\/servicemix4-features","label":[0,0,0,0]}
{"id":10852,"original_code":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n    {\n        if (command instanceof SinglePartitionReadCommand)\n        {\n            \/\/ Note: as yet there's no route to get here - a 2i query *always* uses a\n            \/\/ PartitionRangeReadCommand. This is here in preparation for coming changes\n            \/\/ in SelectStatement.\n            SinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\n            ByteBuffer pk = sprc.partitionKey().getKey();\n            ClusteringIndexFilter filter = sprc.clusteringIndexFilter();\n            if (filter instanceof ClusteringIndexNamesFilter)\n            {\n                NavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\n                NavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\n                for (Clustering c : requested)\n                    clusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\n                return new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n            }\n            else\n            {\n                Slices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\n                Slices.Builder builder = new Slices.Builder(index.getIndexComparator());\n                for (Slice slice : requested)\n                    builder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\n                return new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n            }\n        }\n        else\n        {\n            DataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\n            AbstractBounds<PartitionPosition> range = dataRange.keyRange();\n            Slice slice = Slice.ALL;\n            \/*\n             * XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of\n             * the indexed row unfortunately (which will be inefficient), because we have no way to intuit the smallest possible\n             * key having a given token. A potential fix would be to actually store the token along the key in the indexed row.\n             *\/\n            if (range.left instanceof DecoratedKey)\n            {\n                \/\/ the right hand side of the range may not be a DecoratedKey (for instance if we're paging),\n                \/\/ but if it is, we can optimise slightly by restricting the slice\n                if (range.right instanceof DecoratedKey)\n                {\n                    DecoratedKey startKey = (DecoratedKey) range.left;\n                    DecoratedKey endKey = (DecoratedKey) range.right;\n                    Slice.Bound start = Slice.Bound.BOTTOM;\n                    Slice.Bound end = Slice.Bound.TOP;\n                    \/*\n                     * For index queries over a range, we can't do a whole lot better than querying everything for the key range, though for\n                     * slice queries where we can slightly restrict the beginning and end.\n                     *\/\n                    if (!dataRange.isNamesQuery())\n                    {\n                        ClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\n                        ClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n                        \/\/ We can't effectively support reversed queries when we have a range, so we don't support it\n                        \/\/ (or through post-query reordering) and shouldn't get there.\n                        assert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\n                        Slices startSlices = startSliceFilter.requestedSlices();\n                        Slices endSlices = endSliceFilter.requestedSlices();\n                        if (startSlices.size() > 0)\n                            start = startSlices.get(0).start();\n                        if (endSlices.size() > 0)\n                            end = endSlices.get(endSlices.size() - 1).end();\n                    }\n                    slice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\n                                       index.makeIndexBound(endKey.getKey(), end));\n                }\n                else\n                {\n                   \/\/ otherwise, just start the index slice from the key we do have\n                   slice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\n                                      Slice.Bound.TOP);\n                }\n            }\n            return new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n        }\n    }","code_wo_comment":"private ClusteringIndexFilter makeIndexFilter(AbstractSimplePerColumnSecondaryIndex index, ReadCommand command)\n    {\n        if (command instanceof SinglePartitionReadCommand)\n        {\n           \n           \n           \n            SinglePartitionReadCommand sprc = (SinglePartitionReadCommand)command;\n            ByteBuffer pk = sprc.partitionKey().getKey();\n            ClusteringIndexFilter filter = sprc.clusteringIndexFilter();\n            if (filter instanceof ClusteringIndexNamesFilter)\n            {\n                NavigableSet<Clustering> requested = ((ClusteringIndexNamesFilter)filter).requestedRows();\n                NavigableSet<Clustering> clusterings = new TreeSet<>(index.getIndexComparator());\n                for (Clustering c : requested)\n                    clusterings.add(index.makeIndexClustering(pk, c, (Cell)null).takeAlias());\n                return new ClusteringIndexNamesFilter(clusterings, filter.isReversed());\n            }\n            else\n            {\n                Slices requested = ((ClusteringIndexSliceFilter)filter).requestedSlices();\n                Slices.Builder builder = new Slices.Builder(index.getIndexComparator());\n                for (Slice slice : requested)\n                    builder.add(index.makeIndexBound(pk, slice.start()), index.makeIndexBound(pk, slice.end()));\n                return new ClusteringIndexSliceFilter(builder.build(), filter.isReversed());\n            }\n        }\n        else\n        {\n            DataRange dataRange = ((PartitionRangeReadCommand)command).dataRange();\n            AbstractBounds<PartitionPosition> range = dataRange.keyRange();\n            Slice slice = Slice.ALL;\n           \n            if (range.left instanceof DecoratedKey)\n            {\n               \n               \n                if (range.right instanceof DecoratedKey)\n                {\n                    DecoratedKey startKey = (DecoratedKey) range.left;\n                    DecoratedKey endKey = (DecoratedKey) range.right;\n                    Slice.Bound start = Slice.Bound.BOTTOM;\n                    Slice.Bound end = Slice.Bound.TOP;\n                   \n                    if (!dataRange.isNamesQuery())\n                    {\n                        ClusteringIndexSliceFilter startSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(startKey));\n                        ClusteringIndexSliceFilter endSliceFilter = ((ClusteringIndexSliceFilter) dataRange.clusteringIndexFilter(endKey));\n                       \n                       \n                        assert !startSliceFilter.isReversed() && !endSliceFilter.isReversed();\n                        Slices startSlices = startSliceFilter.requestedSlices();\n                        Slices endSlices = endSliceFilter.requestedSlices();\n                        if (startSlices.size() > 0)\n                            start = startSlices.get(0).start();\n                        if (endSlices.size() > 0)\n                            end = endSlices.get(endSlices.size() - 1).end();\n                    }\n                    slice = Slice.make(index.makeIndexBound(startKey.getKey(), start),\n                                       index.makeIndexBound(endKey.getKey(), end));\n                }\n                else\n                {\n                  \n                   slice = Slice.make(index.makeIndexBound(((DecoratedKey)range.left).getKey(), Slice.Bound.BOTTOM),\n                                      Slice.Bound.TOP);\n                }\n            }\n            return new ClusteringIndexSliceFilter(Slices.with(index.getIndexComparator(), slice), false);\n        }\n    }","cleancode":"private clusteringindexfilter makeindexfilter(abstractsimplepercolumnsecondaryindex index, readcommand command) { if (command instanceof singlepartitionreadcommand) { singlepartitionreadcommand sprc = (singlepartitionreadcommand)command; bytebuffer pk = sprc.partitionkey().getkey(); clusteringindexfilter filter = sprc.clusteringindexfilter(); if (filter instanceof clusteringindexnamesfilter) { navigableset<clustering> requested = ((clusteringindexnamesfilter)filter).requestedrows(); navigableset<clustering> clusterings = new treeset<>(index.getindexcomparator()); for (clustering c : requested) clusterings.add(index.makeindexclustering(pk, c, (cell)null).takealias()); return new clusteringindexnamesfilter(clusterings, filter.isreversed()); } else { slices requested = ((clusteringindexslicefilter)filter).requestedslices(); slices.builder builder = new slices.builder(index.getindexcomparator()); for (slice slice : requested) builder.add(index.makeindexbound(pk, slice.start()), index.makeindexbound(pk, slice.end())); return new clusteringindexslicefilter(builder.build(), filter.isreversed()); } } else { datarange datarange = ((partitionrangereadcommand)command).datarange(); abstractbounds<partitionposition> range = datarange.keyrange(); slice slice = slice.all; if (range.left instanceof decoratedkey) { if (range.right instanceof decoratedkey) { decoratedkey startkey = (decoratedkey) range.left; decoratedkey endkey = (decoratedkey) range.right; slice.bound start = slice.bound.bottom; slice.bound end = slice.bound.top; if (!datarange.isnamesquery()) { clusteringindexslicefilter startslicefilter = ((clusteringindexslicefilter) datarange.clusteringindexfilter(startkey)); clusteringindexslicefilter endslicefilter = ((clusteringindexslicefilter) datarange.clusteringindexfilter(endkey)); assert !startslicefilter.isreversed() && !endslicefilter.isreversed(); slices startslices = startslicefilter.requestedslices(); slices endslices = endslicefilter.requestedslices(); if (startslices.size() > 0) start = startslices.get(0).start(); if (endslices.size() > 0) end = endslices.get(endslices.size() - 1).end(); } slice = slice.make(index.makeindexbound(startkey.getkey(), start), index.makeindexbound(endkey.getkey(), end)); } else { slice = slice.make(index.makeindexbound(((decoratedkey)range.left).getkey(), slice.bound.bottom), slice.bound.top); } } return new clusteringindexslicefilter(slices.with(index.getindexcomparator(), slice), false); } }","repo":"chaordic\/cassandra","label":[1,0,0,0]}
{"id":10876,"original_code":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\n            final int tClassifierId) {\n        \/\/ --- precondition\n        if (catalog == null && schema == null) {\n            return false;\n        }\n        RelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n            @Override\n            protected T doSwitch(int classifierID, EObject theEObject) {\n                if (theEObject.eClass().getClassifierID() != tClassifierId) {\n                    return null;\n                } else {\n                    return super.doSwitch(classifierID, theEObject);\n                }\n            }\n            @Override\n            public T caseColumnSet(ColumnSet object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTable(Table object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdTable(TdTable object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdView(TdView object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseView(View object) {\n                return castObject(object);\n            }\n            @SuppressWarnings(\"unchecked\")\n            private T castObject(Object object) {\n                return (T) object;\n            }\n        };\n        EList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\n        if (elements.isEmpty()) {\n            \/\/ no element found\n            return false;\n        }\n        for (EObject elt : elements) {\n            T columnSet = relationalSwitch.doSwitch(elt);\n            if (columnSet != null) {\n                output.add(columnSet);\n            }\n        }\n        return true;\n    }","code_wo_comment":"public static <T extends ColumnSet> boolean fillColumnSets(Catalog catalog, Schema schema, Collection<T> output,\n            final int tClassifierId) {\n       \n        if (catalog == null && schema == null) {\n            return false;\n        }\n        RelationalSwitch<T> relationalSwitch = new RelationalSwitch<T>() {\n            @Override\n            protected T doSwitch(int classifierID, EObject theEObject) {\n                if (theEObject.eClass().getClassifierID() != tClassifierId) {\n                    return null;\n                } else {\n                    return super.doSwitch(classifierID, theEObject);\n                }\n            }\n            @Override\n            public T caseColumnSet(ColumnSet object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTable(Table object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdTable(TdTable object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseTdView(TdView object) {\n                return castObject(object);\n            }\n            @Override\n            public T caseView(View object) {\n                return castObject(object);\n            }\n            @SuppressWarnings(\"unchecked\")\n            private T castObject(Object object) {\n                return (T) object;\n            }\n        };\n        EList<ModelElement> elements = (schema != null) ? schema.getOwnedElement() : catalog.getOwnedElement();\n        if (elements.isEmpty()) {\n           \n            return false;\n        }\n        for (EObject elt : elements) {\n            T columnSet = relationalSwitch.doSwitch(elt);\n            if (columnSet != null) {\n                output.add(columnSet);\n            }\n        }\n        return true;\n    }","cleancode":"public static <t extends columnset> boolean fillcolumnsets(catalog catalog, schema schema, collection<t> output, final int tclassifierid) { if (catalog == null && schema == null) { return false; } relationalswitch<t> relationalswitch = new relationalswitch<t>() { @override protected t doswitch(int classifierid, eobject theeobject) { if (theeobject.eclass().getclassifierid() != tclassifierid) { return null; } else { return super.doswitch(classifierid, theeobject); } } @override public t casecolumnset(columnset object) { return castobject(object); } @override public t casetable(table object) { return castobject(object); } @override public t casetdtable(tdtable object) { return castobject(object); } @override public t casetdview(tdview object) { return castobject(object); } @override public t caseview(view object) { return castobject(object); } @suppresswarnings(\"unchecked\") private t castobject(object object) { return (t) object; } }; elist<modelelement> elements = (schema != null) ? schema.getownedelement() : catalog.getownedelement(); if (elements.isempty()) { return false; } for (eobject elt : elements) { t columnset = relationalswitch.doswitch(elt); if (columnset != null) { output.add(columnset); } } return true; }","repo":"coheigea\/tcommon-studio-se","label":[0,0,0,1]}
{"id":2699,"original_code":"public void controllerStatusChanged(boolean isPlaying) {\n        \/\/ Rocket doesn't implement this yet!\n        \/\/ Would be useful to control Rocket from demo's side\n    }","code_wo_comment":"public void controllerStatusChanged(boolean isPlaying) {\n       \n       \n    }","cleancode":"public void controllerstatuschanged(boolean isplaying) { }","repo":"bjakke\/moonlander","label":[0,1,0,0]}
{"id":2728,"original_code":"@Override\n    public boolean addPendingAuthorisationtoBlock() {\n        logger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\n        block = new Block();\n        try{\n            ArrayList<BlockChainAuthorisedObj>  pendingAuthorisationArrayList;\n            synchronized (pendingAuthorisationContainer){\n                pendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\n                logger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\n                pendingAuthorisationContainer.reset();\n                logger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n            }\n            \/\/ We need to order Merkle tree 1st before acually\n            \/\/ Actual Merkel Tree implementation in Java. We probably will go with a less dramatic version for POC.\n        }catch (Exception ex){\n            logger.error(ex.getStackTrace());\n        }\n        return false;\n    }","code_wo_comment":"@Override\n    public boolean addPendingAuthorisationtoBlock() {\n        logger.info(\"DefaultBlockChainPublisher:: addPendingAuthorisationtoBlock method called with Client ID:\");\n        block = new Block();\n        try{\n            ArrayList<BlockChainAuthorisedObj>  pendingAuthorisationArrayList;\n            synchronized (pendingAuthorisationContainer){\n                pendingAuthorisationArrayList = pendingAuthorisationContainer.getPendingAccessTokens();\n                logger.info(\"pendingAuthorisationArrayList Size: \"+ pendingAuthorisationArrayList.size());\n                pendingAuthorisationContainer.reset();\n                logger.info(\"pendingAuthorisationArrayList Size post reset: \"+ pendingAuthorisationArrayList.size());\n            }\n           \n           \n        }catch (Exception ex){\n            logger.error(ex.getStackTrace());\n        }\n        return false;\n    }","cleancode":"@override public boolean addpendingauthorisationtoblock() { logger.info(\"defaultblockchainpublisher:: addpendingauthorisationtoblock method called with client id:\"); block = new block(); try{ arraylist<blockchainauthorisedobj> pendingauthorisationarraylist; synchronized (pendingauthorisationcontainer){ pendingauthorisationarraylist = pendingauthorisationcontainer.getpendingaccesstokens(); logger.info(\"pendingauthorisationarraylist size: \"+ pendingauthorisationarraylist.size()); pendingauthorisationcontainer.reset(); logger.info(\"pendingauthorisationarraylist size post reset: \"+ pendingauthorisationarraylist.size()); } }catch (exception ex){ logger.error(ex.getstacktrace()); } return false; }","repo":"anubandhan\/spring-security-oauth-BlockChain","label":[1,0,0,0]}
{"id":19202,"original_code":"private void getToken(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n                \/\/todo send to background\n                SSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","code_wo_comment":"private void getToken(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n               \n                SSOHelper.getToken(this, this.cordova.getActivity(), clientId, clientSecret, clientScopes, clientRedirectUri, production);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","cleancode":"private void gettoken(jsonarray args) { if (args == null || args.length() == 0) { return; } try { if (args.length() >= 5) { jsonarray jsonarray = args.getjsonarray(2); arraylist<string> clientscopes = new arraylist<string>(); if (jsonarray != null) { for (int i = 0; i < jsonarray.length(); i++) { clientscopes.add(jsonarray.get(i).tostring()); } } this.clientid = args.getstring(0); this.clientsecret = args.getstring(1); this.clientscopes = clientscopes; this.clientredirecturi = args.getstring(3); this.production = args.getboolean(4); ssohelper.gettoken(this, this.cordova.getactivity(), clientid, clientsecret, clientscopes, clientredirecturi, production); } } catch (jsonexception e) { e.printstacktrace(); callbackcontext.error(e.getmessage()); } }","repo":"benbenxiaoluchi\/com.accenture.cordova.plugin.sso","label":[0,1,0,0]}
{"id":19203,"original_code":"private void logout(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n                \/\/todo send to background\n                SSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\n                this.callbackContext.success();\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","code_wo_comment":"private void logout(JSONArray args) {\n        if (args == null || args.length() == 0) {\n            return;\n        }\n        try {\n            if (args.length() >= 5) {\n                JSONArray jsonArray = args.getJSONArray(2);\n                ArrayList<String> clientScopes = new ArrayList<String>();\n                if (jsonArray != null) {\n                    for (int i = 0; i < jsonArray.length(); i++) {\n                        clientScopes.add(jsonArray.get(i).toString());\n                    }\n                }\n                this.clientId = args.getString(0);\n                this.clientSecret = args.getString(1);\n                this.clientScopes = clientScopes;\n                this.clientRedirectUri = args.getString(3);\n                this.production = args.getBoolean(4);\n               \n                SSOHelper.logout(this.cordova.getActivity(), clientId, clientSecret, production);\n                this.callbackContext.success();\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            callbackContext.error(e.getMessage());\n        }\n    }","cleancode":"private void logout(jsonarray args) { if (args == null || args.length() == 0) { return; } try { if (args.length() >= 5) { jsonarray jsonarray = args.getjsonarray(2); arraylist<string> clientscopes = new arraylist<string>(); if (jsonarray != null) { for (int i = 0; i < jsonarray.length(); i++) { clientscopes.add(jsonarray.get(i).tostring()); } } this.clientid = args.getstring(0); this.clientsecret = args.getstring(1); this.clientscopes = clientscopes; this.clientredirecturi = args.getstring(3); this.production = args.getboolean(4); ssohelper.logout(this.cordova.getactivity(), clientid, clientsecret, production); this.callbackcontext.success(); } } catch (jsonexception e) { e.printstacktrace(); callbackcontext.error(e.getmessage()); } }","repo":"benbenxiaoluchi\/com.accenture.cordova.plugin.sso","label":[0,1,0,0]}
{"id":11077,"original_code":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\n    name = name.toLowerCase();\n    if (name.equals(\"secp224r1\")) {\n      return 224;\n    } else if (name.equals(\"secp256r1\")) {\n      return 256;\n    } else if (name.equals(\"secp384r1\")) {\n      return 384;\n    } else if (name.equals(\"secp521r1\")) {\n      return 521;\n    } else if (name.equals(\"secp256k1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp224r1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp224t1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp256r1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp256t1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp320r1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp320t1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp384r1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp384t1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp512r1\")) {\n      return 512;\n    } else if (name.equals(\"brainpoolp512t1\")) {\n      return 512;\n    } else {\n      throw new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n    }\n  }","code_wo_comment":"public static int getCurveSize(String name) throws NoSuchAlgorithmException {\n    name = name.toLowerCase();\n    if (name.equals(\"secp224r1\")) {\n      return 224;\n    } else if (name.equals(\"secp256r1\")) {\n      return 256;\n    } else if (name.equals(\"secp384r1\")) {\n      return 384;\n    } else if (name.equals(\"secp521r1\")) {\n      return 521;\n    } else if (name.equals(\"secp256k1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp224r1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp224t1\")) {\n      return 224;\n    } else if (name.equals(\"brainpoolp256r1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp256t1\")) {\n      return 256;\n    } else if (name.equals(\"brainpoolp320r1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp320t1\")) {\n      return 320;\n    } else if (name.equals(\"brainpoolp384r1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp384t1\")) {\n      return 384;\n    } else if (name.equals(\"brainpoolp512r1\")) {\n      return 512;\n    } else if (name.equals(\"brainpoolp512t1\")) {\n      return 512;\n    } else {\n      throw new NoSuchAlgorithmException(\"Curve not implemented:\" + name);\n    }\n  }","cleancode":"public static int getcurvesize(string name) throws nosuchalgorithmexception { name = name.tolowercase(); if (name.equals(\"secp224r1\")) { return 224; } else if (name.equals(\"secp256r1\")) { return 256; } else if (name.equals(\"secp384r1\")) { return 384; } else if (name.equals(\"secp521r1\")) { return 521; } else if (name.equals(\"secp256k1\")) { return 256; } else if (name.equals(\"brainpoolp224r1\")) { return 224; } else if (name.equals(\"brainpoolp224t1\")) { return 224; } else if (name.equals(\"brainpoolp256r1\")) { return 256; } else if (name.equals(\"brainpoolp256t1\")) { return 256; } else if (name.equals(\"brainpoolp320r1\")) { return 320; } else if (name.equals(\"brainpoolp320t1\")) { return 320; } else if (name.equals(\"brainpoolp384r1\")) { return 384; } else if (name.equals(\"brainpoolp384t1\")) { return 384; } else if (name.equals(\"brainpoolp512r1\")) { return 512; } else if (name.equals(\"brainpoolp512t1\")) { return 512; } else { throw new nosuchalgorithmexception(\"curve not implemented:\" + name); } }","repo":"avineshwar\/wycheproof","label":[0,1,0,0]}
{"id":2922,"original_code":"protected Boolean Authenticated()\n    {\n        String OauthToken = request().getHeader(\"token\");\n        if (OauthToken == null || OauthToken.isEmpty()) {\n            return false;\n        }\n        Oauth token = Oauth\n                .find\n                .where()\n                .eq(\"token\", OauthToken)\n                .eq(\"active\", OathTokenActive)\n                .findUnique();\n        if (token != null) {\n            return  true;\n        }\n        return false;\n    }","code_wo_comment":"protected Boolean Authenticated()\n    {\n        String OauthToken = request().getHeader(\"token\");\n        if (OauthToken == null || OauthToken.isEmpty()) {\n            return false;\n        }\n        Oauth token = Oauth\n                .find\n                .where()\n                .eq(\"token\", OauthToken)\n                .eq(\"active\", OathTokenActive)\n                .findUnique();\n        if (token != null) {\n            return  true;\n        }\n        return false;\n    }","cleancode":"protected boolean authenticated() { string oauthtoken = request().getheader(\"token\"); if (oauthtoken == null || oauthtoken.isempty()) { return false; } oauth token = oauth .find .where() .eq(\"token\", oauthtoken) .eq(\"active\", oathtokenactive) .findunique(); if (token != null) { return true; } return false; }","repo":"channing-froom\/playframework-2.5.2","label":[0,1,0,0]}
{"id":19359,"original_code":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        getLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\n        checkEnvProperties();\n        Connection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\n        conn.setLog(getLog());\n        String projectDirectory = project.getBasedir().getAbsolutePath();\n        try {\n            \/\/TODO add copy prop file to \/target\/config\/ with filtering.\n            \/\/ Update - just copy the one file... for now lets copy them all\n            copyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\n            conn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\n            conn.updateConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(e.getMessage());\n        }\n    }","code_wo_comment":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException {\n        getLog().info(\"Updating Connection:\" + connection + \" for integration \" + integrationName + \"_\" + integrationVersion + \" from \" + baseUrl);\n        checkEnvProperties();\n        Connection conn = new Connection(connection, baseUrl, icsUser, icsPassword);\n        conn.setLog(getLog());\n        String projectDirectory = project.getBasedir().getAbsolutePath();\n        try {\n           \n           \n            copyConfigFiles(projectDirectory + connectionConfigDir, projectDirectory + \"\/target\/connections\");\n            conn.setConfigDirectory(projectDirectory + \"\/target\/connections\");\n            conn.updateConnection();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new MojoExecutionException(e.getMessage());\n        }\n    }","cleancode":"@override public void execute() throws mojoexecutionexception, mojofailureexception { getlog().info(\"updating connection:\" + connection + \" for integration \" + integrationname + \"_\" + integrationversion + \" from \" + baseurl); checkenvproperties(); connection conn = new connection(connection, baseurl, icsuser, icspassword); conn.setlog(getlog()); string projectdirectory = project.getbasedir().getabsolutepath(); try { copyconfigfiles(projectdirectory + connectionconfigdir, projectdirectory + \"\/target\/connections\"); conn.setconfigdirectory(projectdirectory + \"\/target\/connections\"); conn.updateconnection(); } catch (exception e) { e.printstacktrace(); throw new mojoexecutionexception(e.getmessage()); } }","repo":"avioconsulting\/ics-maven-plugin","label":[1,0,0,0]}
{"id":19372,"original_code":"static String resolve(String message, Object[] args) {\n        String formatted = String.format(message, args);\n        \/\/ TODO - fix!  this case fails: ^cyan^warn^r^ if ^warn^ is evaluated first...really meant for ^cyan^ and ^r^\n        \/\/ TODO - to be resolved\n        for (String key : TERM_CODES.keySet()) {\n            TermCode termCode = TERM_CODES.get(key);\n            Matcher matcher = termCode.pattern.matcher(formatted);\n            if (matcher.find()) {\n                if ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n                        || (\"dbug\".equals(key) && !dbugLevel.get())) {\n                    \/\/ this is a log statement for a disabled log-level, skip.\n                    return null;\n                }\n                if (decorated.get()) {\n                    String output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\n                    formatted = matcher.replaceAll(output);\n                }\n            }\n        }\n        return formatted;\n    }","code_wo_comment":"static String resolve(String message, Object[] args) {\n        String formatted = String.format(message, args);\n       \n       \n        for (String key : TERM_CODES.keySet()) {\n            TermCode termCode = TERM_CODES.get(key);\n            Matcher matcher = termCode.pattern.matcher(formatted);\n            if (matcher.find()) {\n                if ((\"warn\".equals(key) && !warnLevel.get()) || (\"info\".equals(key) && !infoLevel.get())\n                        || (\"dbug\".equals(key) && !dbugLevel.get())) {\n                   \n                    return null;\n                }\n                if (decorated.get()) {\n                    String output = isColoredOutput() ? termCode.output : termCode.nonColoredOutput;\n                    formatted = matcher.replaceAll(output);\n                }\n            }\n        }\n        return formatted;\n    }","cleancode":"static string resolve(string message, object[] args) { string formatted = string.format(message, args); for (string key : term_codes.keyset()) { termcode termcode = term_codes.get(key); matcher matcher = termcode.pattern.matcher(formatted); if (matcher.find()) { if ((\"warn\".equals(key) && !warnlevel.get()) || (\"info\".equals(key) && !infolevel.get()) || (\"dbug\".equals(key) && !dbuglevel.get())) { return null; } if (decorated.get()) { string output = iscoloredoutput() ? termcode.output : termcode.noncoloredoutput; formatted = matcher.replaceall(output); } } } return formatted; }","repo":"blangel\/ply","label":[0,0,1,0]}
{"id":3003,"original_code":"public void removeSegment(IndexSegment segment) {\n    \/\/ TODO(saurabh): Explain reload scenario here\n    Iterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\n    while (primaryKeyIterator.hasNext()) {\n      PrimaryKey pk = primaryKeyIterator.next();\n      _primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n          (primaryKey, currentSegment) -> {\n            if (currentSegment == segment) {\n              return null;\n            } else {\n              return currentSegment;\n            }\n          });\n    }\n    _serverMetrics.setValueOfPartitionGauge(_tableNameWithType, _partitionId, ServerGauge.DEDUP_PRIMARY_KEYS_COUNT,\n        _primaryKeyToSegmentMap.size());\n  }","code_wo_comment":"public void removeSegment(IndexSegment segment) {\n   \n    Iterator<PrimaryKey> primaryKeyIterator = getPrimaryKeyIterator(segment, _primaryKeyColumns);\n    while (primaryKeyIterator.hasNext()) {\n      PrimaryKey pk = primaryKeyIterator.next();\n      _primaryKeyToSegmentMap.compute(HashUtils.hashPrimaryKey(pk, _hashFunction),\n          (primaryKey, currentSegment) -> {\n            if (currentSegment == segment) {\n              return null;\n            } else {\n              return currentSegment;\n            }\n          });\n    }\n    _serverMetrics.setValueOfPartitionGauge(_tableNameWithType, _partitionId, ServerGauge.DEDUP_PRIMARY_KEYS_COUNT,\n        _primaryKeyToSegmentMap.size());\n  }","cleancode":"public void removesegment(indexsegment segment) { iterator<primarykey> primarykeyiterator = getprimarykeyiterator(segment, _primarykeycolumns); while (primarykeyiterator.hasnext()) { primarykey pk = primarykeyiterator.next(); _primarykeytosegmentmap.compute(hashutils.hashprimarykey(pk, _hashfunction), (primarykey, currentsegment) -> { if (currentsegment == segment) { return null; } else { return currentsegment; } }); } _servermetrics.setvalueofpartitiongauge(_tablenamewithtype, _partitionid, servergauge.dedup_primary_keys_count, _primarykeytosegmentmap.size()); }","repo":"asf-transfer\/pinot","label":[0,0,0,0]}
{"id":11202,"original_code":"protected InputStream getContentStream()\n\t\t\t\t\tthrows MessagingException {\n\ttry {\n\tsynchronized(this) {\n\t    if (contentStream == null) {\n\t\tInputStream rawcontent = folder.getProtocol().retr(msgnum,\n\t\t\t\t\tmsgSize > 0 ? msgSize + hdrSize : 0);\n\t\tif (rawcontent == null) {\n\t\t    expunged = true;\n\t\t    throw new MessageRemovedException();    \/\/  XXX - what else?\n\t\t}\n\t\tif (headers == null ||\n\t\t\t((POP3Store)(folder.getStore())).forgetTopHeaders) {\n\t\t    headers = new InternetHeaders(rawcontent);\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t} else {\n\t\t    \/*\n\t\t     * Already have the headers, have to skip the headers\n\t\t     * in the content array and return the body.\n\t\t     *\n\t\t     * XXX - It seems that some mail servers return slightly\n\t\t     * different headers in the RETR results than were returned\n\t\t     * in the TOP results, so we can't depend on remembering\n\t\t     * the size of the headers from the TOP command and just\n\t\t     * skipping that many bytes.  Instead, we have to process\n\t\t     * the content, skipping over the header until we come to\n\t\t     * the empty line that separates the header from the body.\n\t\t     *\/\n\t\t    int offset = 0;\n\t\t    for (;;) {\n\t\t\tint len = 0;\t\/\/ number of bytes in this line\n\t\t\tint c1;\n\t\t\twhile ((c1 = rawcontent.read()) >= 0) {\n\t\t\t    if (c1 == '\\n')\t\/\/ end of line\n\t\t\t\tbreak;\n\t\t\t    else if (c1 == '\\r') {\n\t\t\t\t\/\/ got CR, is the next char LF?\n\t\t\t\tif (rawcontent.available() > 0) {\n\t\t\t\t    rawcontent.mark(1);\n\t\t\t\t    if (rawcontent.read() != '\\n')\n\t\t\t\t\trawcontent.reset();\n\t\t\t\t}\n\t\t\t\tbreak;\t\/\/ in any case, end of line\n\t\t\t    }\n\t\t\t    \/\/ not CR, NL, or CRLF, count the byte\n\t\t\t    len++;\n\t\t\t}\n\t\t\t\/\/ here when end of line or out of data\n\t\t\t\/\/ if out of data, we're done\n\t\t\tif (rawcontent.available() == 0)\n\t\t\t    break;\n\t\t\t\/\/ if it was an empty line, we're done\n\t\t\tif (len == 0)\n\t\t\t    break;\n\t\t    }\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t}\n\t\tcontentStream =\n\t\t    ((SharedInputStream)rawcontent).newStream(hdrSize, -1);\n\t\trawcontent = null;\t\/\/ help GC\n\t    }\n\t}\n\t} catch (EOFException eex) {\n\t    folder.close(false);\n\t    throw new FolderClosedException(folder, eex.toString());\n\t} catch (IOException ex) {\n\t    throw new MessagingException(\"error fetching POP3 content\", ex);\n\t}\n\treturn super.getContentStream();\n    }","code_wo_comment":"protected InputStream getContentStream()\n\t\t\t\t\tthrows MessagingException {\n\ttry {\n\tsynchronized(this) {\n\t    if (contentStream == null) {\n\t\tInputStream rawcontent = folder.getProtocol().retr(msgnum,\n\t\t\t\t\tmsgSize > 0 ? msgSize + hdrSize : 0);\n\t\tif (rawcontent == null) {\n\t\t    expunged = true;\n\t\t    throw new MessageRemovedException();   \n\t\t}\n\t\tif (headers == null ||\n\t\t\t((POP3Store)(folder.getStore())).forgetTopHeaders) {\n\t\t    headers = new InternetHeaders(rawcontent);\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t} else {\n\t\t   \n\t\t    int offset = 0;\n\t\t    for (;;) {\n\t\t\tint len = 0;\n\t\t\tint c1;\n\t\t\twhile ((c1 = rawcontent.read()) >= 0) {\n\t\t\t    if (c1 == '\\n')\n\t\t\t\tbreak;\n\t\t\t    else if (c1 == '\\r') {\n\t\t\t\n\t\t\t\tif (rawcontent.available() > 0) {\n\t\t\t\t    rawcontent.mark(1);\n\t\t\t\t    if (rawcontent.read() != '\\n')\n\t\t\t\t\trawcontent.reset();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t   \n\t\t\t    len++;\n\t\t\t}\n\t\t\n\t\t\n\t\t\tif (rawcontent.available() == 0)\n\t\t\t    break;\n\t\t\n\t\t\tif (len == 0)\n\t\t\t    break;\n\t\t    }\n\t\t    hdrSize =\n\t\t\t(int)((SharedInputStream)rawcontent).getPosition();\n\t\t}\n\t\tcontentStream =\n\t\t    ((SharedInputStream)rawcontent).newStream(hdrSize, -1);\n\t\trawcontent = null;\n\t    }\n\t}\n\t} catch (EOFException eex) {\n\t    folder.close(false);\n\t    throw new FolderClosedException(folder, eex.toString());\n\t} catch (IOException ex) {\n\t    throw new MessagingException(\"error fetching POP3 content\", ex);\n\t}\n\treturn super.getContentStream();\n    }","cleancode":"protected inputstream getcontentstream() throws messagingexception { try { synchronized(this) { if (contentstream == null) { inputstream rawcontent = folder.getprotocol().retr(msgnum, msgsize > 0 ? msgsize + hdrsize : 0); if (rawcontent == null) { expunged = true; throw new messageremovedexception(); } if (headers == null || ((pop3store)(folder.getstore())).forgettopheaders) { headers = new internetheaders(rawcontent); hdrsize = (int)((sharedinputstream)rawcontent).getposition(); } else { int offset = 0; for (;;) { int len = 0; int c1; while ((c1 = rawcontent.read()) >= 0) { if (c1 == '\\n') break; else if (c1 == '\\r') { if (rawcontent.available() > 0) { rawcontent.mark(1); if (rawcontent.read() != '\\n') rawcontent.reset(); } break; } len++; } if (rawcontent.available() == 0) break; if (len == 0) break; } hdrsize = (int)((sharedinputstream)rawcontent).getposition(); } contentstream = ((sharedinputstream)rawcontent).newstream(hdrsize, -1); rawcontent = null; } } } catch (eofexception eex) { folder.close(false); throw new folderclosedexception(folder, eex.tostring()); } catch (ioexception ex) { throw new messagingexception(\"error fetching pop3 content\", ex); } return super.getcontentstream(); }","repo":"cesarmo759\/android_kernel_samsung_msm8916","label":[1,0,0,0]}
{"id":11203,"original_code":"public void setHeader(String name, String value)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code_wo_comment":"public void setHeader(String name, String value)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void setheader(string name, string value) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","repo":"cesarmo759\/android_kernel_samsung_msm8916","label":[0,1,0,0]}
{"id":11204,"original_code":"public void addHeader(String name, String value)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code_wo_comment":"public void addHeader(String name, String value)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void addheader(string name, string value) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","repo":"cesarmo759\/android_kernel_samsung_msm8916","label":[0,1,0,0]}
{"id":11205,"original_code":"public void removeHeader(String name)\n                                throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code_wo_comment":"public void removeHeader(String name)\n                                throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void removeheader(string name) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","repo":"cesarmo759\/android_kernel_samsung_msm8916","label":[0,1,0,0]}
{"id":11206,"original_code":"public void addHeaderLine(String line) throws MessagingException {\n\t\/\/ XXX - should check for read-only folder?\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","code_wo_comment":"public void addHeaderLine(String line) throws MessagingException {\n\n\tthrow new IllegalWriteException(\"POP3 messages are read-only\");\n    }","cleancode":"public void addheaderline(string line) throws messagingexception { throw new illegalwriteexception(\"pop3 messages are read-only\"); }","repo":"cesarmo759\/android_kernel_samsung_msm8916","label":[0,1,0,0]}
{"id":11257,"original_code":"private void findEvents(Context context, String name, MultiName multiName, int pos, Watcher watcher, ReferenceValue ref)\n    {\n        String srcTypeName = null;\n        if (watcher.isPartOfAnonObjectGraph())\n        {\n            srcTypeName = standardDefs.CLASS_OBJECTPROXY;\n        }\n        else if (! srcTypeStack.empty())\n        {\n            srcTypeName = srcTypeStack.peek();\n        }\n        Watcher parentWatcher = watcher.getParent();\n        if ((parentWatcher != null) && parentWatcher.isOperation())\n        {\n            watcher.addChangeEvent(\"resultForBinding\");\n        }\n        else if (srcTypeName != null)\n        {\n            AbcClass watchedClass = typeTable.getClass(srcTypeName);\n            if (watchedClass != null)\n            {\n                if ( watchedClass.isSubclassOf(standardDefs.CLASS_OBJECTPROXY) )\n                {\n                    watcher.setPartOfAnonObjectGraph(true);\n                }\n                List metaData = watchedClass.getMetaData(BINDABLE, true);\n                boolean foundEvents = addBindables(watcher, metaData);\n                boolean foundSource = false;\n                Variable variable = getVariable(context, watchedClass, ref, multiName);\n                if (variable != null)\n                {\n                    metaData = variable.getMetaData(BINDABLE);\n                    foundEvents = addBindables(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(CHANGE_EVENT);\n                    foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                    foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                    \/\/ Object has a public static const variable names \"length\", which is\n                    \/\/ some legacy compatibility crap left over from EMCA script 262, so\n                    \/\/ we ignore it.\n                    if (variable.isConst() &&\n                        !(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        \/\/ We didn't really find any events, but we want\n                        \/\/ to follow the same code path below as if we did.\n                        foundEvents = true;\n                        \/\/    TODO will this ever be something besides a PropertyWatcher?\n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher) watcher).suppress();\n                        }\n                    }\n                    \/\/ See comment above.\n                    if (!(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        checkForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n                    }\n                    foundSource = true;\n                }\n                if (!foundEvents)\n                {\n                    Method getter = getGetter(context, watchedClass, ref, multiName);\n                    if (getter != null)\n                    {\n                        metaData = getter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\n                        checkForStaticProperty(getter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    Method setter = getSetter(context, watchedClass, ref, multiName);\n                    if (setter != null)\n                    {\n                        metaData = setter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        checkForStaticProperty(setter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    else\n                    {\n                        if (getter != null)\n                        {\n                            \/\/    getters without setters are de facto const, use same bypass as above for const vars\n                            foundEvents = true;\n                        }\n                    }\n                }\n                if (!foundSource)\n                {\n                    Method function = getMethod(context, watchedClass, ref, multiName);\n                    if (function != null)\n                    {\n                        metaData = function.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        foundSource = true;\n                        if (!foundEvents && callExpressionStack.isEmpty())\n                        {\n                            foundEvents = true;\n                            \/\/    TODO will this ever be something besides a PropertyWatcher?\n                            if (watcher instanceof PropertyWatcher)\n                            {\n                                ((PropertyWatcher)watcher).suppress();\n                            }\n                        }\n                    }\n                }\n                if ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n                {\n                    watcher.setOperation(true);\n                }\n                else if (!foundEvents &&\n                         !(watcher instanceof FunctionReturnWatcher) &&\n                         !(watcher instanceof XMLWatcher) &&\n                         !watcher.isOperation())\n                {\n                    \/***\n                     * NOTE: when we've failed to find change events for properties of untyped or Object-typed parents, we go\n                     * ahead and generate code to create a runtime PropertyWatcher with no change events specified. The lack\n                     * of change events tells the runtime PW to introspect RTTI to discover change events associated with the\n                     * actual type of the actual value being assigned to the property.\n                     * OTOH for strongly-typed properties, we still require change events to be reachable at compile time.\n                     *\/\n                    if (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n                    {\n                        \/\/    TODO do we still want this to be configurable?\n                        if (showBindingWarnings)\n                        {\n                            context.localizedWarning2(pos, new UnableToDetectChanges(name));\n                        }\n                        \/\/    TODO will this ever be something besides a PropertyWatcher?\n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher)watcher).suppress();\n                        }\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"private void findEvents(Context context, String name, MultiName multiName, int pos, Watcher watcher, ReferenceValue ref)\n    {\n        String srcTypeName = null;\n        if (watcher.isPartOfAnonObjectGraph())\n        {\n            srcTypeName = standardDefs.CLASS_OBJECTPROXY;\n        }\n        else if (! srcTypeStack.empty())\n        {\n            srcTypeName = srcTypeStack.peek();\n        }\n        Watcher parentWatcher = watcher.getParent();\n        if ((parentWatcher != null) && parentWatcher.isOperation())\n        {\n            watcher.addChangeEvent(\"resultForBinding\");\n        }\n        else if (srcTypeName != null)\n        {\n            AbcClass watchedClass = typeTable.getClass(srcTypeName);\n            if (watchedClass != null)\n            {\n                if ( watchedClass.isSubclassOf(standardDefs.CLASS_OBJECTPROXY) )\n                {\n                    watcher.setPartOfAnonObjectGraph(true);\n                }\n                List metaData = watchedClass.getMetaData(BINDABLE, true);\n                boolean foundEvents = addBindables(watcher, metaData);\n                boolean foundSource = false;\n                Variable variable = getVariable(context, watchedClass, ref, multiName);\n                if (variable != null)\n                {\n                    metaData = variable.getMetaData(BINDABLE);\n                    foundEvents = addBindables(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(CHANGE_EVENT);\n                    foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                    metaData = variable.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                    foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                   \n                   \n                   \n                    if (variable.isConst() &&\n                        !(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                       \n                       \n                        foundEvents = true;\n                       \n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher) watcher).suppress();\n                        }\n                    }\n                   \n                    if (!(multiName.getLocalPart().equals(\"length\") &&\n                          variable.getDeclaringClassName().equals(SymbolTable.OBJECT)))\n                    {\n                        checkForStaticProperty(variable.isStatic(), watcher, srcTypeName);\n                    }\n                    foundSource = true;\n                }\n                if (!foundEvents)\n                {\n                    Method getter = getGetter(context, watchedClass, ref, multiName);\n                    if (getter != null)\n                    {\n                        metaData = getter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = getter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents( watcher, metaData) || foundEvents;\n                        checkForStaticProperty(getter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    Method setter = getSetter(context, watchedClass, ref, multiName);\n                    if (setter != null)\n                    {\n                        metaData = setter.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = setter.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        checkForStaticProperty(setter.isStatic(), watcher, srcTypeName);\n                        foundSource = true;\n                    }\n                    else\n                    {\n                        if (getter != null)\n                        {\n                           \n                            foundEvents = true;\n                        }\n                    }\n                }\n                if (!foundSource)\n                {\n                    Method function = getMethod(context, watchedClass, ref, multiName);\n                    if (function != null)\n                    {\n                        metaData = function.getMetaData(BINDABLE);\n                        foundEvents = addBindables(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(CHANGE_EVENT);\n                        foundEvents = addChangeEvents(watcher, metaData) || foundEvents;\n                        metaData = function.getMetaData(NON_COMMITTING_CHANGE_EVENT);\n                        foundEvents = addNonCommittingChangeEvents(watcher, metaData) || foundEvents;\n                        foundSource = true;\n                        if (!foundEvents && callExpressionStack.isEmpty())\n                        {\n                            foundEvents = true;\n                           \n                            if (watcher instanceof PropertyWatcher)\n                            {\n                                ((PropertyWatcher)watcher).suppress();\n                            }\n                        }\n                    }\n                }\n                if ((!foundSource) && watchedClass.isSubclassOf(standardDefs.CLASS_ABSTRACTSERVICE))\n                {\n                    watcher.setOperation(true);\n                }\n                else if (!foundEvents &&\n                         !(watcher instanceof FunctionReturnWatcher) &&\n                         !(watcher instanceof XMLWatcher) &&\n                         !watcher.isOperation())\n                {\n                   \n                    if (!(watchedClass.getName().equals(SymbolTable.OBJECT) || watchedClass.getName().equals(SymbolTable.NOTYPE)))\n                    {\n                       \n                        if (showBindingWarnings)\n                        {\n                            context.localizedWarning2(pos, new UnableToDetectChanges(name));\n                        }\n                       \n                        if (watcher instanceof PropertyWatcher)\n                        {\n                            ((PropertyWatcher)watcher).suppress();\n                        }\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void findevents(context context, string name, multiname multiname, int pos, watcher watcher, referencevalue ref) { string srctypename = null; if (watcher.ispartofanonobjectgraph()) { srctypename = standarddefs.class_objectproxy; } else if (! srctypestack.empty()) { srctypename = srctypestack.peek(); } watcher parentwatcher = watcher.getparent(); if ((parentwatcher != null) && parentwatcher.isoperation()) { watcher.addchangeevent(\"resultforbinding\"); } else if (srctypename != null) { abcclass watchedclass = typetable.getclass(srctypename); if (watchedclass != null) { if ( watchedclass.issubclassof(standarddefs.class_objectproxy) ) { watcher.setpartofanonobjectgraph(true); } list metadata = watchedclass.getmetadata(bindable, true); boolean foundevents = addbindables(watcher, metadata); boolean foundsource = false; variable variable = getvariable(context, watchedclass, ref, multiname); if (variable != null) { metadata = variable.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = variable.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = variable.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; if (variable.isconst() && !(multiname.getlocalpart().equals(\"length\") && variable.getdeclaringclassname().equals(symboltable.object))) { foundevents = true; if (watcher instanceof propertywatcher) { ((propertywatcher) watcher).suppress(); } } if (!(multiname.getlocalpart().equals(\"length\") && variable.getdeclaringclassname().equals(symboltable.object))) { checkforstaticproperty(variable.isstatic(), watcher, srctypename); } foundsource = true; } if (!foundevents) { method getter = getgetter(context, watchedclass, ref, multiname); if (getter != null) { metadata = getter.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = getter.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = getter.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents( watcher, metadata) || foundevents; checkforstaticproperty(getter.isstatic(), watcher, srctypename); foundsource = true; } method setter = getsetter(context, watchedclass, ref, multiname); if (setter != null) { metadata = setter.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = setter.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = setter.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; checkforstaticproperty(setter.isstatic(), watcher, srctypename); foundsource = true; } else { if (getter != null) { foundevents = true; } } } if (!foundsource) { method function = getmethod(context, watchedclass, ref, multiname); if (function != null) { metadata = function.getmetadata(bindable); foundevents = addbindables(watcher, metadata) || foundevents; metadata = function.getmetadata(change_event); foundevents = addchangeevents(watcher, metadata) || foundevents; metadata = function.getmetadata(non_committing_change_event); foundevents = addnoncommittingchangeevents(watcher, metadata) || foundevents; foundsource = true; if (!foundevents && callexpressionstack.isempty()) { foundevents = true; if (watcher instanceof propertywatcher) { ((propertywatcher)watcher).suppress(); } } } } if ((!foundsource) && watchedclass.issubclassof(standarddefs.class_abstractservice)) { watcher.setoperation(true); } else if (!foundevents && !(watcher instanceof functionreturnwatcher) && !(watcher instanceof xmlwatcher) && !watcher.isoperation()) { if (!(watchedclass.getname().equals(symboltable.object) || watchedclass.getname().equals(symboltable.notype))) { if (showbindingwarnings) { context.localizedwarning2(pos, new unabletodetectchanges(name)); } if (watcher instanceof propertywatcher) { ((propertywatcher)watcher).suppress(); } } } } } }","repo":"blackjyn\/flex-sdk","label":[1,0,0,0]}
{"id":11345,"original_code":"@Override\n    public void show() {\n        super.show();\n        this.x = r.nextFloat();\n        this.y = r.nextFloat();\n        float angle = r.nextFloat() * 2 * 3.14159f;\n        this.vx = (float)java.lang.Math.cos(angle);\n        this.vy = (float)java.lang.Math.sin(angle);\n        \/\/todo instead of going back to main menu, pause the game with pause screen?\n        Gdx.input.setCatchBackKey(true);\n        getStage().addListener(new InputListener() {\n            @Override\n            public boolean keyUp(InputEvent event, int keycode) {\n                if (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\n                    app.setScreen(app.getMainScreen());\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n    }","code_wo_comment":"@Override\n    public void show() {\n        super.show();\n        this.x = r.nextFloat();\n        this.y = r.nextFloat();\n        float angle = r.nextFloat() * 2 * 3.14159f;\n        this.vx = (float)java.lang.Math.cos(angle);\n        this.vy = (float)java.lang.Math.sin(angle);\n       \n        Gdx.input.setCatchBackKey(true);\n        getStage().addListener(new InputListener() {\n            @Override\n            public boolean keyUp(InputEvent event, int keycode) {\n                if (keycode == Input.Keys.BACK || keycode == Input.Keys.ESCAPE) {\n                    app.setScreen(app.getMainScreen());\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        });\n    }","cleancode":"@override public void show() { super.show(); this.x = r.nextfloat(); this.y = r.nextfloat(); float angle = r.nextfloat() * 2 * 3.14159f; this.vx = (float)java.lang.math.cos(angle); this.vy = (float)java.lang.math.sin(angle); gdx.input.setcatchbackkey(true); getstage().addlistener(new inputlistener() { @override public boolean keyup(inputevent event, int keycode) { if (keycode == input.keys.back || keycode == input.keys.escape) { app.setscreen(app.getmainscreen()); return true; } else { return false; } } }); }","repo":"cmsd2\/toyapp","label":[1,0,0,0]}
{"id":19729,"original_code":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code_wo_comment":"public void GetStatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.GetStatus param5) {\n\t\n\t}","cleancode":"public void getstatusoperation(org.oasis_open.docs.ws_tx.wsba._2006._06.getstatus param5) { }","repo":"apache\/kandula","label":[0,1,0,0]}
{"id":19730,"original_code":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n\t{\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code_wo_comment":"public void NotCompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.NotCompleted param6)\n\t{\n\t\n\t}","cleancode":"public void notcompleted(org.oasis_open.docs.ws_tx.wsba._2006._06.notcompleted param6) { }","repo":"apache\/kandula","label":[0,1,0,0]}
{"id":19731,"original_code":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n\t{\n\t\t\/\/ Todo fill this with the necessary business logic\n\t}","code_wo_comment":"public void StatusOperation(org.oasis_open.docs.ws_tx.wsba._2006._06.Status param7)\n\t{\n\t\n\t}","cleancode":"public void statusoperation(org.oasis_open.docs.ws_tx.wsba._2006._06.status param7) { }","repo":"apache\/kandula","label":[0,1,0,0]}
{"id":11728,"original_code":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\n        GenomicLocation normalizedGenomicLocation = new GenomicLocation();\n        \/\/ if original input is set in the incoming genomic location object then use the same value\n        \/\/ for the normalized genomic location object returned, otherwise set it to the\n        \/\/ string representation of the incoming genomic location object\n        if (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n        } else {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n        }\n        \/\/ normalize chromosome name\n        String chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\n        normalizedGenomicLocation.setChromosome(chr);\n        \/\/ convert vcf style start,end,ref,alt to MAF style\n        Integer start = genomicLocation.getStart();\n        Integer end = genomicLocation.getEnd();\n        String ref = genomicLocation.getReferenceAllele().trim();\n        String var = genomicLocation.getVariantAllele().trim();\n        String prefix = \"\";\n        if (!ref.equals(var)) {\n            prefix = longestCommonPrefix(ref, var);\n        }\n        \/\/ Remove common prefix and adjust variant position accordingly\n        if (prefix.length() > 0) {\n            ref = ref.substring(prefix.length());\n            var = var.substring(prefix.length());\n            int nStart = start + prefix.length();\n            if (ref.length() == 0) {\n                nStart -= 1;\n            }\n            start = nStart;\n        }\n        normalizedGenomicLocation.setStart(start);\n        normalizedGenomicLocation.setEnd(end);\n        normalizedGenomicLocation.setReferenceAllele(ref);\n        normalizedGenomicLocation.setVariantAllele(var);\n        return normalizedGenomicLocation;\n    }","code_wo_comment":"public GenomicLocation normalizeGenomicLocation(GenomicLocation genomicLocation) {\n        GenomicLocation normalizedGenomicLocation = new GenomicLocation();\n       \n       \n       \n        if (genomicLocation.getOriginalInput() != null && !genomicLocation.getOriginalInput().isEmpty()) {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.getOriginalInput());\n        } else {\n            normalizedGenomicLocation.setOriginalInput(genomicLocation.toString());\n        }\n       \n        String chr = chromosomeNormalizer(genomicLocation.getChromosome().trim());\n        normalizedGenomicLocation.setChromosome(chr);\n       \n        Integer start = genomicLocation.getStart();\n        Integer end = genomicLocation.getEnd();\n        String ref = genomicLocation.getReferenceAllele().trim();\n        String var = genomicLocation.getVariantAllele().trim();\n        String prefix = \"\";\n        if (!ref.equals(var)) {\n            prefix = longestCommonPrefix(ref, var);\n        }\n       \n        if (prefix.length() > 0) {\n            ref = ref.substring(prefix.length());\n            var = var.substring(prefix.length());\n            int nStart = start + prefix.length();\n            if (ref.length() == 0) {\n                nStart -= 1;\n            }\n            start = nStart;\n        }\n        normalizedGenomicLocation.setStart(start);\n        normalizedGenomicLocation.setEnd(end);\n        normalizedGenomicLocation.setReferenceAllele(ref);\n        normalizedGenomicLocation.setVariantAllele(var);\n        return normalizedGenomicLocation;\n    }","cleancode":"public genomiclocation normalizegenomiclocation(genomiclocation genomiclocation) { genomiclocation normalizedgenomiclocation = new genomiclocation(); if (genomiclocation.getoriginalinput() != null && !genomiclocation.getoriginalinput().isempty()) { normalizedgenomiclocation.setoriginalinput(genomiclocation.getoriginalinput()); } else { normalizedgenomiclocation.setoriginalinput(genomiclocation.tostring()); } string chr = chromosomenormalizer(genomiclocation.getchromosome().trim()); normalizedgenomiclocation.setchromosome(chr); integer start = genomiclocation.getstart(); integer end = genomiclocation.getend(); string ref = genomiclocation.getreferenceallele().trim(); string var = genomiclocation.getvariantallele().trim(); string prefix = \"\"; if (!ref.equals(var)) { prefix = longestcommonprefix(ref, var); } if (prefix.length() > 0) { ref = ref.substring(prefix.length()); var = var.substring(prefix.length()); int nstart = start + prefix.length(); if (ref.length() == 0) { nstart -= 1; } start = nstart; } normalizedgenomiclocation.setstart(start); normalizedgenomiclocation.setend(end); normalizedgenomiclocation.setreferenceallele(ref); normalizedgenomiclocation.setvariantallele(var); return normalizedgenomiclocation; }","repo":"as1000\/genome-nexus","label":[1,0,0,0]}
{"id":20003,"original_code":"public Builder withOriginalCourseId(final String originalCourseId) {\n            getObject().setOriginalCourseId(originalCourseId);\n            return thisBuilder();\n        }","code_wo_comment":"public Builder withOriginalCourseId(final String originalCourseId) {\n            getObject().setOriginalCourseId(originalCourseId);\n            return thisBuilder();\n        }","cleancode":"public builder withoriginalcourseid(final string originalcourseid) { getobject().setoriginalcourseid(originalcourseid); return thisbuilder(); }","repo":"bcgov\/EDUC-GRAD-REPORT-API","label":[1,0,0,0]}
{"id":3835,"original_code":"protected Serializable[] getParamValues(Serializable[] rawParamValues) throws SQLException\n    {\n        int nonPositionedParametersCount = 0;\n        for (Serializable rawParamValue : rawParamValues)\n        {\n            if (rawParamValue != null && rawParamValue instanceof NonPositionedParameter) ++nonPositionedParametersCount;\n        }\n        Serializable[] paramValues = new Serializable[parameterNames.size() + nonPositionedParametersCount];\n        Entity entity = (Entity)Optional.ofNullable(getParent()).filter(x -> x instanceof Entity).orElse(null);\n        if (entity == null)\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                paramValues[i] = rawParamValues[paramMapping[i]];\n            }\n        }\n        else\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                String paramName = parameterNames.get(i);\n                paramValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n            }\n        }\n        \/\/ non positioned parameters should always be given last (CB TODO - document)\n        for (int i = 0; i < nonPositionedParametersCount; ++i)\n        {\n            paramValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n        }\n        return paramValues;\n    }","code_wo_comment":"protected Serializable[] getParamValues(Serializable[] rawParamValues) throws SQLException\n    {\n        int nonPositionedParametersCount = 0;\n        for (Serializable rawParamValue : rawParamValues)\n        {\n            if (rawParamValue != null && rawParamValue instanceof NonPositionedParameter) ++nonPositionedParametersCount;\n        }\n        Serializable[] paramValues = new Serializable[parameterNames.size() + nonPositionedParametersCount];\n        Entity entity = (Entity)Optional.ofNullable(getParent()).filter(x -> x instanceof Entity).orElse(null);\n        if (entity == null)\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                paramValues[i] = rawParamValues[paramMapping[i]];\n            }\n        }\n        else\n        {\n            for (int i = 0; i < paramValues.length - nonPositionedParametersCount; ++i)\n            {\n                String paramName = parameterNames.get(i);\n                paramValues[i] = entity.filterValue(paramName, rawParamValues[paramMapping[i]]);\n            }\n        }\n       \n        for (int i = 0; i < nonPositionedParametersCount; ++i)\n        {\n            paramValues[paramValues.length - nonPositionedParametersCount + i] = rawParamValues[rawParamValues.length - nonPositionedParametersCount + i];\n        }\n        return paramValues;\n    }","cleancode":"protected serializable[] getparamvalues(serializable[] rawparamvalues) throws sqlexception { int nonpositionedparameterscount = 0; for (serializable rawparamvalue : rawparamvalues) { if (rawparamvalue != null && rawparamvalue instanceof nonpositionedparameter) ++nonpositionedparameterscount; } serializable[] paramvalues = new serializable[parameternames.size() + nonpositionedparameterscount]; entity entity = (entity)optional.ofnullable(getparent()).filter(x -> x instanceof entity).orelse(null); if (entity == null) { for (int i = 0; i < paramvalues.length - nonpositionedparameterscount; ++i) { paramvalues[i] = rawparamvalues[parammapping[i]]; } } else { for (int i = 0; i < paramvalues.length - nonpositionedparameterscount; ++i) { string paramname = parameternames.get(i); paramvalues[i] = entity.filtervalue(paramname, rawparamvalues[parammapping[i]]); } } for (int i = 0; i < nonpositionedparameterscount; ++i) { paramvalues[paramvalues.length - nonpositionedparameterscount + i] = rawparamvalues[rawparamvalues.length - nonpositionedparameterscount + i]; } return paramvalues; }","repo":"arkanovicz\/velocity-model","label":[0,0,0,0]}
{"id":12164,"original_code":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n        \/\/ NOTE:\n        \/\/ seekTo() call will be ignored if the player is attached as a next\n        \/\/ player.\n        try {\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            \/\/ prepare\n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            \/\/ seek\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n            \/\/ NOTE: valid position is returned\n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ start\n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ wait for the next player started\n            Thread.sleep(player.getDuration());\n            \/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n            \/\/ NOTE: valid current position position is returned\n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n            \/\/ wait for the next player completion\n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n                \/\/ WTF! Android's native audio decoder gives very poor seek\n                \/\/ accuracy!\n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n                \/\/ wait for the next player completion\n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","code_wo_comment":"public void testSeekToBeforeAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n       \n       \n       \n        try {\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n           \n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n           \n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n           \n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            Thread.sleep(player.getDuration());\n           \n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n           \n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n           \n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToBeforeAttachedAsNextMediaPlayer() - WORKAROUND\");\n               \n               \n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n               \n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","cleancode":"public void testseektobeforeattachedasnextmediaplayer() throws throwable { ibasicmediaplayer player = createwrappedplayerinstance(); ibasicmediaplayer nextplayer = null; object args = gettestparams(); try { seekcompletelistenerobject seekcomp = new seekcompletelistenerobject(); transitstatetoprepared(player, args); nextplayer = createnextplayer(player, nextplayertype.prepared); nextplayer.setonseekcompletelistener(seekcomp); int seekposition = nextplayer.getduration() \/ 2; nextplayer.seekto(seekposition); if (!seekcomp.await(default_event_wait_duration)) { fail(); } assertequals(seekposition, nextplayer.getcurrentposition()); setunwrappedtnextplayer(player, nextplayer); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); player.start(); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(short_event_wait_duration); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(player.getduration()); assertequals(player.getduration(), player.getcurrentposition()); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); assertlargerthanorequal(seekposition, nextplayer.getcurrentposition()); thread.sleep(nextplayer.getduration() - seekposition + short_event_wait_duration); if (true) { log.w(\"xxx\", \"testseektobeforeattachedasnextmediaplayer() - workaround\"); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); thread.sleep(seekposition); } assertequals(nextplayer.getduration(), nextplayer.getcurrentposition()); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); } finally { releasequietly(nextplayer); releasequietly(player); } }","repo":"cirnoftw\/android-openslmediaplayer","label":[1,0,1,0]}
{"id":12165,"original_code":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n        \/\/ NOTE:\n        \/\/ seekTo() call will be ignored if the player is attached as a next\n        \/\/ player.\n        try {\n            \/\/ prepare\n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ start\n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n            \/\/ NOTE: valid position is returned\n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            \/\/ wait for the next player started\n            Thread.sleep(player.getDuration());\n            \/\/ NOTE: StandardMediaPlayer fails on this assertion if using NuPlayer\n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n            \/\/ NOTE: valid current position position is returned\n            \/\/ XXX Galaxy S4 (SC-04E, Android 4.4.2) fails on this assertion\n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n            \/\/ wait for the next player completion\n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n                \/\/ WTF! Android's native audio decoder gives very poor seek\n                \/\/ accuracy!\n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n                \/\/ wait for the next player completion\n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","code_wo_comment":"public void testSeekToAfterAttachedAsNextMediaPlayer() throws Throwable {\n        IBasicMediaPlayer player = createWrappedPlayerInstance();\n        IBasicMediaPlayer nextPlayer = null;\n        Object args = getTestParams();\n       \n       \n       \n        try {\n           \n            transitStateToPrepared(player, args);\n            nextPlayer = createNextPlayer(player, NextPlayerType.PREPARED);\n            setUnwrappedtNextPlayer(player, nextPlayer);\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            player.start();\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n            int seekPosition = nextPlayer.getDuration() \/ 2;\n            SeekCompleteListenerObject seekComp = new SeekCompleteListenerObject();\n            nextPlayer.setOnSeekCompleteListener(seekComp);\n            nextPlayer.seekTo(seekPosition);\n            if (!seekComp.await(DEFAULT_EVENT_WAIT_DURATION)) {\n                fail();\n            }\n           \n            assertEquals(seekPosition, nextPlayer.getCurrentPosition());\n            Thread.sleep(SHORT_EVENT_WAIT_DURATION);\n            assertTrue(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n           \n            Thread.sleep(player.getDuration());\n           \n            assertEquals(player.getDuration(), player.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertTrue(nextPlayer.isPlaying());\n           \n           \n            assertLargerThanOrEqual(seekPosition,\n                    nextPlayer.getCurrentPosition());\n           \n            Thread.sleep(nextPlayer.getDuration() - seekPosition\n                    + SHORT_EVENT_WAIT_DURATION);\n            if (true) {\n                Log.w(\"XXX\",\n                        \"testSeekToAfterAttachedAsNextMediaPlayer() - WORKAROUND\");\n               \n               \n                assertFalse(player.isPlaying());\n                assertTrue(nextPlayer.isPlaying());\n               \n                Thread.sleep(seekPosition);\n            }\n            assertEquals(nextPlayer.getDuration(),\n                    nextPlayer.getCurrentPosition());\n            assertFalse(player.isPlaying());\n            assertFalse(nextPlayer.isPlaying());\n        } finally {\n            releaseQuietly(nextPlayer);\n            releaseQuietly(player);\n        }\n    }","cleancode":"public void testseektoafterattachedasnextmediaplayer() throws throwable { ibasicmediaplayer player = createwrappedplayerinstance(); ibasicmediaplayer nextplayer = null; object args = gettestparams(); try { transitstatetoprepared(player, args); nextplayer = createnextplayer(player, nextplayertype.prepared); setunwrappedtnextplayer(player, nextplayer); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); player.start(); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); int seekposition = nextplayer.getduration() \/ 2; seekcompletelistenerobject seekcomp = new seekcompletelistenerobject(); nextplayer.setonseekcompletelistener(seekcomp); nextplayer.seekto(seekposition); if (!seekcomp.await(default_event_wait_duration)) { fail(); } assertequals(seekposition, nextplayer.getcurrentposition()); thread.sleep(short_event_wait_duration); asserttrue(player.isplaying()); assertfalse(nextplayer.isplaying()); thread.sleep(player.getduration()); assertequals(player.getduration(), player.getcurrentposition()); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); assertlargerthanorequal(seekposition, nextplayer.getcurrentposition()); thread.sleep(nextplayer.getduration() - seekposition + short_event_wait_duration); if (true) { log.w(\"xxx\", \"testseektoafterattachedasnextmediaplayer() - workaround\"); assertfalse(player.isplaying()); asserttrue(nextplayer.isplaying()); thread.sleep(seekposition); } assertequals(nextplayer.getduration(), nextplayer.getcurrentposition()); assertfalse(player.isplaying()); assertfalse(nextplayer.isplaying()); } finally { releasequietly(nextplayer); releasequietly(player); } }","repo":"cirnoftw\/android-openslmediaplayer","label":[1,0,1,0]}
{"id":20677,"original_code":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\n        return CompletableFuture.supplyAsync(() -> {\n            \/\/ TODO: explore a more relaxed locking strategy.\n            writeLock.lock();\n            try {\n                return supplier.get();\n            } catch (Throwable ex) {\n                log.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\n                throw ex;\n            } finally {\n                writeLock.unlock();\n            }\n        }, contextExecutor);\n    }","code_wo_comment":"private <U> CompletableFuture<U> supplyInContext(Supplier<U> supplier, String opDescription) {\n        return CompletableFuture.supplyAsync(() -> {\n           \n            writeLock.lock();\n            try {\n                return supplier.get();\n            } catch (Throwable ex) {\n                log.error(\"Exception in P4Runtime client of {}, executing {}\", deviceId, opDescription, ex);\n                throw ex;\n            } finally {\n                writeLock.unlock();\n            }\n        }, contextExecutor);\n    }","cleancode":"private <u> completablefuture<u> supplyincontext(supplier<u> supplier, string opdescription) { return completablefuture.supplyasync(() -> { writelock.lock(); try { return supplier.get(); } catch (throwable ex) { log.error(\"exception in p4runtime client of {}, executing {}\", deviceid, opdescription, ex); throw ex; } finally { writelock.unlock(); } }, contextexecutor); }","repo":"antiguru\/onos","label":[1,0,0,0]}
{"id":20862,"original_code":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\n    LongRange idsToRead = getIdsToRead();\n    \/\/ No more entries to read\n    if (idsToRead.getMaximumLong() == 0) {\n      return;\n    }\n    \/\/ TODO: Remove left outer join and command type filter once the\n    \/\/ exchange partition bug is fixed in HIVE-12215\n    String queryFormatString = \"SELECT a.id, a.create_time, \"\n        + \"command_type, command, name, category, \"\n        + \"type, serialized_object \"\n        + \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n        + \"WHERE a.id >= ? AND a.id <= ? \"\n        + \"AND (command_type IS NULL OR command_type \"\n        + \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n        + \"ORDER BY id \"\n        \/\/ Get read locks on the specified rows to prevent skipping of rows that haven't committed\n        \/\/ yet, but have an ID between idsToRead. For example, one transaction starts and\n        \/\/ inserts id = 1, but another transaction starts, inserts, and commits i=2 before the\n        \/\/ first transaction commits. Locking can also be done with serializable isolation level.\n        + \"LOCK IN SHARE MODE\";\n    String query = String.format(queryFormatString,\n        auditLogTableName, outputObjectsTableName,\n        idsToRead.getMinimumLong(), idsToRead.getMaximumLong());\n    Connection connection = dbConnectionFactory.getConnection();\n    PreparedStatement ps = connection.prepareStatement(query);\n    int index = 1;\n    ps.setLong(index++, idsToRead.getMinimumLong());\n    ps.setLong(index++, idsToRead.getMaximumLong());\n    ResultSet rs = ps.executeQuery();\n    long id = -1;\n    Timestamp createTime = null;\n    HiveOperation commandType = null;\n    String command = null;\n    String objectName;\n    String objectCategory;\n    String objectType;\n    String objectSerialized;\n    long previouslyReadId = -1;\n    Timestamp previouslyReadTs = null;\n    HiveOperation previousCommandType = null;\n    String previousCommand = null;\n    \/\/ For a given audit log ID, the join would have produced multiple rows\n    \/\/ for each ID. Each row contains a single output. Group all the rows\n    \/\/ and the outputs into a AuditLogEntry.\n    \/\/ For a given audit log ID, these accumulate the outputs from the\n    \/\/ different rows.\n    List<String> outputDirectories = new LinkedList<>();\n    List<Table> outputTables = new LinkedList<>();\n    List<NamedPartition> outputPartitions = new LinkedList<>();\n    List<Table> referenceTables = new LinkedList<>();\n    Table inputTable = null;\n    NamedPartition renameFromPartition = null;\n    while (rs.next()) {\n      id = rs.getLong(\"id\");\n      createTime = rs.getTimestamp(\"create_time\");\n      \/\/ Invalid operations are returned as null\n      String commandTypeString = rs.getString(\"command_type\");\n      commandType = convertToHiveOperation(commandTypeString);\n      if (commandType == null) {\n        LOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n      }\n      command = rs.getString(\"command\");\n      objectName = rs.getString(\"name\");\n      objectCategory = rs.getString(\"category\");\n      objectType = rs.getString(\"type\");\n      objectSerialized = rs.getString(\"serialized_object\");\n      if (previouslyReadId != -1 && id != previouslyReadId) {\n        lastReadId = previouslyReadId;\n        \/\/ This means that all the outputs for a given audit log entry\n        \/\/ has been read.\n        AuditLogEntry entry = new AuditLogEntry(\n            previouslyReadId,\n            previouslyReadTs,\n            previousCommandType,\n            previousCommand,\n            outputDirectories,\n            referenceTables,\n            outputTables,\n            outputPartitions,\n            inputTable,\n            renameFromPartition);\n        auditLogEntries.add(entry);\n        \/\/ Reset these accumulated values\n        outputDirectories = new LinkedList<>();\n        referenceTables = new LinkedList<>();\n        outputTables = new LinkedList<>();\n        outputPartitions = new LinkedList<>();\n        renameFromPartition = null;\n        inputTable = null;\n      }\n      previouslyReadId = id;\n      previouslyReadTs = createTime;\n      previousCommandType = commandType;\n      previousCommand = command;\n      if (\"DIRECTORY\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"TABLE\".equals(objectType)) {\n        Table table = new Table();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, table);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(table);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputTables.add(table);\n        } else if (\"REFERENCE_TABLE\".equals(objectCategory)) {\n          referenceTables.add(table);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          inputTable = table;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"PARTITION\".equals(objectType)) {\n        Partition partition = new Partition();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, partition);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(partition);\n        String partitionName = getPartitionNameFromOutputCol(objectName);\n        NamedPartition namedPartition = new NamedPartition(partitionName, partition);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputPartitions.add(namedPartition);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          renameFromPartition = namedPartition;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"DFS_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"LOCAL_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"DATABASE\".equals(objectType)) {\n        \/\/ Currently, nothing is done with DB's\n      } else if (objectType == null) {\n        \/\/ This will happen for queries that don't have any output\n        \/\/ objects. This can be removed a long with the OUTER aspect\n        \/\/ of the join above once the bug with exchange partitions is\n        \/\/ fixed.\n        LOG.debug(\"No output objects\");\n      } else {\n        throw new RuntimeException(\"Unhandled output type: \" + objectType);\n      }\n    }\n    \/\/ This is the case where we read to the end of the table.\n    if (id != -1) {\n      AuditLogEntry entry = new AuditLogEntry(\n          id,\n          createTime,\n          commandType,\n          command,\n          outputDirectories,\n          referenceTables,\n          outputTables,\n          outputPartitions,\n          inputTable,\n          renameFromPartition);\n      auditLogEntries.add(entry);\n    }\n    \/\/ Note: if we constantly get empty results (i.e. no valid entries\n    \/\/ because all the commands got filtered out), then the lastReadId won't\n    \/\/ be updated for a while.\n    lastReadId = idsToRead.getMaximumLong();\n    return;\n  }","code_wo_comment":"private void fetchMoreEntries() throws SQLException, AuditLogEntryException {\n    LongRange idsToRead = getIdsToRead();\n   \n    if (idsToRead.getMaximumLong() == 0) {\n      return;\n    }\n   \n   \n    String queryFormatString = \"SELECT a.id, a.create_time, \"\n        + \"command_type, command, name, category, \"\n        + \"type, serialized_object \"\n        + \"FROM %s a LEFT OUTER JOIN %s b on a.id = b.audit_log_id \"\n        + \"WHERE a.id >= ? AND a.id <= ? \"\n        + \"AND (command_type IS NULL OR command_type \"\n        + \"NOT IN('SHOWTABLES', 'SHOWPARTITIONS', 'SWITCHDATABASE')) \"\n        + \"ORDER BY id \"\n       \n       \n       \n       \n        + \"LOCK IN SHARE MODE\";\n    String query = String.format(queryFormatString,\n        auditLogTableName, outputObjectsTableName,\n        idsToRead.getMinimumLong(), idsToRead.getMaximumLong());\n    Connection connection = dbConnectionFactory.getConnection();\n    PreparedStatement ps = connection.prepareStatement(query);\n    int index = 1;\n    ps.setLong(index++, idsToRead.getMinimumLong());\n    ps.setLong(index++, idsToRead.getMaximumLong());\n    ResultSet rs = ps.executeQuery();\n    long id = -1;\n    Timestamp createTime = null;\n    HiveOperation commandType = null;\n    String command = null;\n    String objectName;\n    String objectCategory;\n    String objectType;\n    String objectSerialized;\n    long previouslyReadId = -1;\n    Timestamp previouslyReadTs = null;\n    HiveOperation previousCommandType = null;\n    String previousCommand = null;\n   \n   \n   \n   \n   \n    List<String> outputDirectories = new LinkedList<>();\n    List<Table> outputTables = new LinkedList<>();\n    List<NamedPartition> outputPartitions = new LinkedList<>();\n    List<Table> referenceTables = new LinkedList<>();\n    Table inputTable = null;\n    NamedPartition renameFromPartition = null;\n    while (rs.next()) {\n      id = rs.getLong(\"id\");\n      createTime = rs.getTimestamp(\"create_time\");\n     \n      String commandTypeString = rs.getString(\"command_type\");\n      commandType = convertToHiveOperation(commandTypeString);\n      if (commandType == null) {\n        LOG.debug(String.format(\"Invalid operation %s in audit log id: %s\", commandTypeString, id));\n      }\n      command = rs.getString(\"command\");\n      objectName = rs.getString(\"name\");\n      objectCategory = rs.getString(\"category\");\n      objectType = rs.getString(\"type\");\n      objectSerialized = rs.getString(\"serialized_object\");\n      if (previouslyReadId != -1 && id != previouslyReadId) {\n        lastReadId = previouslyReadId;\n       \n       \n        AuditLogEntry entry = new AuditLogEntry(\n            previouslyReadId,\n            previouslyReadTs,\n            previousCommandType,\n            previousCommand,\n            outputDirectories,\n            referenceTables,\n            outputTables,\n            outputPartitions,\n            inputTable,\n            renameFromPartition);\n        auditLogEntries.add(entry);\n       \n        outputDirectories = new LinkedList<>();\n        referenceTables = new LinkedList<>();\n        outputTables = new LinkedList<>();\n        outputPartitions = new LinkedList<>();\n        renameFromPartition = null;\n        inputTable = null;\n      }\n      previouslyReadId = id;\n      previouslyReadTs = createTime;\n      previousCommandType = commandType;\n      previousCommand = command;\n      if (\"DIRECTORY\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"TABLE\".equals(objectType)) {\n        Table table = new Table();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, table);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(table);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputTables.add(table);\n        } else if (\"REFERENCE_TABLE\".equals(objectCategory)) {\n          referenceTables.add(table);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          inputTable = table;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"PARTITION\".equals(objectType)) {\n        Partition partition = new Partition();\n        try {\n          ReplicationUtils.deserializeObject(objectSerialized, partition);\n        } catch (MetadataException e) {\n          throw new AuditLogEntryException(e);\n        }\n        ReplicationUtils.normalizeNames(partition);\n        String partitionName = getPartitionNameFromOutputCol(objectName);\n        NamedPartition namedPartition = new NamedPartition(partitionName, partition);\n        if (\"OUTPUT\".equals(objectCategory)) {\n          outputPartitions.add(namedPartition);\n        } else if (\"RENAME_FROM\".equals(objectCategory) || \"INPUT\".equals(objectCategory)) {\n          renameFromPartition = namedPartition;\n        } else {\n          throw new RuntimeException(\"Unhandled category: \" + objectCategory);\n        }\n      } else if (\"DFS_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"LOCAL_DIR\".equals(objectType)) {\n        outputDirectories.add(objectName);\n      } else if (\"DATABASE\".equals(objectType)) {\n       \n      } else if (objectType == null) {\n       \n       \n       \n       \n        LOG.debug(\"No output objects\");\n      } else {\n        throw new RuntimeException(\"Unhandled output type: \" + objectType);\n      }\n    }\n   \n    if (id != -1) {\n      AuditLogEntry entry = new AuditLogEntry(\n          id,\n          createTime,\n          commandType,\n          command,\n          outputDirectories,\n          referenceTables,\n          outputTables,\n          outputPartitions,\n          inputTable,\n          renameFromPartition);\n      auditLogEntries.add(entry);\n    }\n   \n   \n   \n    lastReadId = idsToRead.getMaximumLong();\n    return;\n  }","cleancode":"private void fetchmoreentries() throws sqlexception, auditlogentryexception { longrange idstoread = getidstoread(); if (idstoread.getmaximumlong() == 0) { return; } string queryformatstring = \"select a.id, a.create_time, \" + \"command_type, command, name, category, \" + \"type, serialized_object \" + \"from %s a left outer join %s b on a.id = b.audit_log_id \" + \"where a.id >= ? and a.id <= ? \" + \"and (command_type is null or command_type \" + \"not in('showtables', 'showpartitions', 'switchdatabase')) \" + \"order by id \" + \"lock in share mode\"; string query = string.format(queryformatstring, auditlogtablename, outputobjectstablename, idstoread.getminimumlong(), idstoread.getmaximumlong()); connection connection = dbconnectionfactory.getconnection(); preparedstatement ps = connection.preparestatement(query); int index = 1; ps.setlong(index++, idstoread.getminimumlong()); ps.setlong(index++, idstoread.getmaximumlong()); resultset rs = ps.executequery(); long id = -1; timestamp createtime = null; hiveoperation commandtype = null; string command = null; string objectname; string objectcategory; string objecttype; string objectserialized; long previouslyreadid = -1; timestamp previouslyreadts = null; hiveoperation previouscommandtype = null; string previouscommand = null; list<string> outputdirectories = new linkedlist<>(); list<table> outputtables = new linkedlist<>(); list<namedpartition> outputpartitions = new linkedlist<>(); list<table> referencetables = new linkedlist<>(); table inputtable = null; namedpartition renamefrompartition = null; while (rs.next()) { id = rs.getlong(\"id\"); createtime = rs.gettimestamp(\"create_time\"); string commandtypestring = rs.getstring(\"command_type\"); commandtype = converttohiveoperation(commandtypestring); if (commandtype == null) { log.debug(string.format(\"invalid operation %s in audit log id: %s\", commandtypestring, id)); } command = rs.getstring(\"command\"); objectname = rs.getstring(\"name\"); objectcategory = rs.getstring(\"category\"); objecttype = rs.getstring(\"type\"); objectserialized = rs.getstring(\"serialized_object\"); if (previouslyreadid != -1 && id != previouslyreadid) { lastreadid = previouslyreadid; auditlogentry entry = new auditlogentry( previouslyreadid, previouslyreadts, previouscommandtype, previouscommand, outputdirectories, referencetables, outputtables, outputpartitions, inputtable, renamefrompartition); auditlogentries.add(entry); outputdirectories = new linkedlist<>(); referencetables = new linkedlist<>(); outputtables = new linkedlist<>(); outputpartitions = new linkedlist<>(); renamefrompartition = null; inputtable = null; } previouslyreadid = id; previouslyreadts = createtime; previouscommandtype = commandtype; previouscommand = command; if (\"directory\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"table\".equals(objecttype)) { table table = new table(); try { replicationutils.deserializeobject(objectserialized, table); } catch (metadataexception e) { throw new auditlogentryexception(e); } replicationutils.normalizenames(table); if (\"output\".equals(objectcategory)) { outputtables.add(table); } else if (\"reference_table\".equals(objectcategory)) { referencetables.add(table); } else if (\"rename_from\".equals(objectcategory) || \"input\".equals(objectcategory)) { inputtable = table; } else { throw new runtimeexception(\"unhandled category: \" + objectcategory); } } else if (\"partition\".equals(objecttype)) { partition partition = new partition(); try { replicationutils.deserializeobject(objectserialized, partition); } catch (metadataexception e) { throw new auditlogentryexception(e); } replicationutils.normalizenames(partition); string partitionname = getpartitionnamefromoutputcol(objectname); namedpartition namedpartition = new namedpartition(partitionname, partition); if (\"output\".equals(objectcategory)) { outputpartitions.add(namedpartition); } else if (\"rename_from\".equals(objectcategory) || \"input\".equals(objectcategory)) { renamefrompartition = namedpartition; } else { throw new runtimeexception(\"unhandled category: \" + objectcategory); } } else if (\"dfs_dir\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"local_dir\".equals(objecttype)) { outputdirectories.add(objectname); } else if (\"database\".equals(objecttype)) { } else if (objecttype == null) { log.debug(\"no output objects\"); } else { throw new runtimeexception(\"unhandled output type: \" + objecttype); } } if (id != -1) { auditlogentry entry = new auditlogentry( id, createtime, commandtype, command, outputdirectories, referencetables, outputtables, outputpartitions, inputtable, renamefrompartition); auditlogentries.add(entry); } lastreadid = idstoread.getmaximumlong(); return; }","repo":"aoen\/reair","label":[1,1,1,0]}
{"id":12727,"original_code":"@Override\n    public void run(Engine.Negative negative) { \/\/ TODO: Use \"advanced probabilistic techniques\".\n        for (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\n            int j, bufferX, bufferY; \/\/ location of (zR, zI) in histogram\n            double cR, cI, zR, zI, p;\n            \/\/ use ThreadLocalRandom for improved performance\n            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\n            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n            \/\/ check if the sequence generated by (cR, cI) escapes\n            for (j = 0; j < iterationLimit; j++) {\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {\n                    break;\n                }\n            }\n            if (j == iterationLimit) { \/\/ does the sequence escape?\n                continue;\n            }\n            zR = cR;\n            zI = cI;\n            for (j = 0; j < iterationLimit; j++) {\n                \/\/ Is the point within the rendering region?\n                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\n                    bufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\n                    bufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\n                    negative.buffer.setElem(bufferY * negative.size.width + bufferX,\n                            negative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n                }\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n            }\n        }\n    }","code_wo_comment":"@Override\n    public void run(Engine.Negative negative) {\n        for (int i = 1; i <= TASK_SAMPLE_SIZE; i++) {\n            int j, bufferX, bufferY;\n            double cR, cI, zR, zI, p;\n           \n            cR = zR = minX + ThreadLocalRandom.current().nextDouble(rangeX);\n            cI = zI = minY + ThreadLocalRandom.current().nextDouble(rangeY);\n           \n            for (j = 0; j < iterationLimit; j++) {\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n                if (zR * zR + zI * zI > escapeDistance * escapeDistance) {\n                    break;\n                }\n            }\n            if (j == iterationLimit) {\n                continue;\n            }\n            zR = cR;\n            zI = cI;\n            for (j = 0; j < iterationLimit; j++) {\n               \n                if (zR >= minX && zR - minX <= rangeX && zI >= minY && zI - minY <= rangeY) {\n                    bufferX = (int) (((zR - minX) \/ rangeX) * negative.size.width);\n                    bufferY = (int) (((zI - minY) \/ rangeY) * negative.size.height);\n                    negative.buffer.setElem(bufferY * negative.size.width + bufferX,\n                            negative.buffer.getElem(bufferY * negative.size.width + bufferX) + 1);\n                }\n                for (int k = 1; k < degree; k++) {\n                    p = zR;\n                    zR = zR * zR - zI * zI;\n                    zI = 2 * p * zI;\n                }\n                zR += cR;\n                zI += cI;\n            }\n        }\n    }","cleancode":"@override public void run(engine.negative negative) { for (int i = 1; i <= task_sample_size; i++) { int j, bufferx, buffery; double cr, ci, zr, zi, p; cr = zr = minx + threadlocalrandom.current().nextdouble(rangex); ci = zi = miny + threadlocalrandom.current().nextdouble(rangey); for (j = 0; j < iterationlimit; j++) { for (int k = 1; k < degree; k++) { p = zr; zr = zr * zr - zi * zi; zi = 2 * p * zi; } zr += cr; zi += ci; if (zr * zr + zi * zi > escapedistance * escapedistance) { break; } } if (j == iterationlimit) { continue; } zr = cr; zi = ci; for (j = 0; j < iterationlimit; j++) { if (zr >= minx && zr - minx <= rangex && zi >= miny && zi - miny <= rangey) { bufferx = (int) (((zr - minx) \/ rangex) * negative.size.width); buffery = (int) (((zi - miny) \/ rangey) * negative.size.height); negative.buffer.setelem(buffery * negative.size.width + bufferx, negative.buffer.getelem(buffery * negative.size.width + bufferx) + 1); } for (int k = 1; k < degree; k++) { p = zr; zr = zr * zr - zi * zi; zi = 2 * p * zi; } zr += cr; zi += ci; } } }","repo":"ari-b\/neb","label":[1,0,0,0]}
{"id":20951,"original_code":"public void xtestNameClash() {\n        WritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\n        try {\n            doTestVersion(wv);\n            doTestVersion(wv);\n            fail(\"created two groups with same name\");\n        } catch (ModelException ex) {\n            wv.abort();\n            Throwable cause = ex;\n            while (null != cause.getCause()) {\n                cause = cause.getCause();\n            }\n            cause.printStackTrace();\n            fail(cause.getClass().getName() + \": \" + cause.getMessage());\n        } finally {\n            if (!wv.isCompleted()) {\n                wv.abort();\n            } \/\/ not testing persistence here\n        }\n    }","code_wo_comment":"public void xtestNameClash() {\n        WritableVersion wv = model.getWritableVersion(AbstractModel.SUPERUSER);\n        try {\n            doTestVersion(wv);\n            doTestVersion(wv);\n            fail(\"created two groups with same name\");\n        } catch (ModelException ex) {\n            wv.abort();\n            Throwable cause = ex;\n            while (null != cause.getCause()) {\n                cause = cause.getCause();\n            }\n            cause.printStackTrace();\n            fail(cause.getClass().getName() + \": \" + cause.getMessage());\n        } finally {\n            if (!wv.isCompleted()) {\n                wv.abort();\n            }\n        }\n    }","cleancode":"public void xtestnameclash() { writableversion wv = model.getwritableversion(abstractmodel.superuser); try { dotestversion(wv); dotestversion(wv); fail(\"created two groups with same name\"); } catch (modelexception ex) { wv.abort(); throwable cause = ex; while (null != cause.getcause()) { cause = cause.getcause(); } cause.printstacktrace(); fail(cause.getclass().getname() + \": \" + cause.getmessage()); } finally { if (!wv.iscompleted()) { wv.abort(); } } }","repo":"chrishmorris\/PiMS","label":[0,0,1,0]}
{"id":13109,"original_code":"public void hasLength(int length) {\n        \/\/ TODO Support string length?\n        checkArgument(length >= 0, \"length (%s) must be >= 0\", length);\n        if (actual() == null || !actual().isContainerNode()) {\n            fail(\"is a container\");\n        } else if (actual().size() != length) {\n            fail(\"has length\", length);\n        }\n    }","code_wo_comment":"public void hasLength(int length) {\n       \n        checkArgument(length >= 0, \"length (%s) must be >= 0\", length);\n        if (actual() == null || !actual().isContainerNode()) {\n            fail(\"is a container\");\n        } else if (actual().size() != length) {\n            fail(\"has length\", length);\n        }\n    }","cleancode":"public void haslength(int length) { checkargument(length >= 0, \"length (%s) must be >= 0\", length); if (actual() == null || !actual().iscontainernode()) { fail(\"is a container\"); } else if (actual().size() != length) { fail(\"has length\", length); } }","repo":"blackducksoftware\/magpie-libraries","label":[1,0,1,0]}
{"id":13111,"original_code":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\n            objectMapper.configure(feature, state);\n            return this;\n        }","code_wo_comment":"public JsonSubjectFactory configure(DeserializationFeature feature, boolean state) {\n            objectMapper.configure(feature, state);\n            return this;\n        }","cleancode":"public jsonsubjectfactory configure(deserializationfeature feature, boolean state) { objectmapper.configure(feature, state); return this; }","repo":"blackducksoftware\/magpie-libraries","label":[1,0,0,0]}
{"id":21976,"original_code":"@Override\n    public void onBindViewHolder(final ViewHolder holder, final int position) {\n        final Item item = mItemList.get(position);\n        setListener(mListener);\n        String dateStr = item.getPubDate();\n        DateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.getDefault());\n        try {\n            Date date = formatter.parse(dateStr);\n            String pubDateStr = DateUtils.formatAbbrev(mContext, date);\n            String[] dateMonth = pubDateStr.split(\" \");\n            holder.mTvMonth.setText(dateMonth[0]);\n            holder.mTvDate.setText(dateMonth[1]);\n        } catch (ParseException e) {\n            e.printStackTrace();\n            GoogleAnalyticsUtil.trackException(mContext, e);\n        }\n        if (null != item.getItunesDuration()) {\n            \/\/Check if the duration is already formatted\n            if (item.getItunesDuration().contains(\":\")) {\n                holder.mTvPodcastDuration.setText(item.getItunesDuration());\n            } else {\n                long min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\n                long sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\n                holder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n            }\n        }\n        holder.mTvPodcastTitle.setText(item.getTitle());\n        holder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                \/\/TODO:: Change Icon based on action. If playing, equalizer icon, pause pause-icon etc\n                String imageUrl = \"\";\n                Cursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\n                if (cursor != null) {\n                    while (cursor.moveToNext()) {\n                        imageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n                    }\n                }\n                Track track = new Track();\n                track.setTitle(item.getTitle());\n                track.setStreamUrl(item.getEnclosure().getUrl());\n                track.setArtist(item.getItunesAuthor());\n                track.setArtworkUrl(imageUrl);\n                track.setDurationInMilli(Converter.getMilliSeconds(item.getItunesDuration()));\n                if (mListener != null) {\n                    mListener.onTrackClicked(track);\n                }\n            }\n        });\n        holder.mEpisodeRl.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                displayBottomSheet(item);\n            }\n        });\n    }","code_wo_comment":"@Override\n    public void onBindViewHolder(final ViewHolder holder, final int position) {\n        final Item item = mItemList.get(position);\n        setListener(mListener);\n        String dateStr = item.getPubDate();\n        DateFormat formatter = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.getDefault());\n        try {\n            Date date = formatter.parse(dateStr);\n            String pubDateStr = DateUtils.formatAbbrev(mContext, date);\n            String[] dateMonth = pubDateStr.split(\" \");\n            holder.mTvMonth.setText(dateMonth[0]);\n            holder.mTvDate.setText(dateMonth[1]);\n        } catch (ParseException e) {\n            e.printStackTrace();\n            GoogleAnalyticsUtil.trackException(mContext, e);\n        }\n        if (null != item.getItunesDuration()) {\n           \n            if (item.getItunesDuration().contains(\":\")) {\n                holder.mTvPodcastDuration.setText(item.getItunesDuration());\n            } else {\n                long min = Integer.parseInt(item.getItunesDuration()) \/ 60000;\n                long sec = Integer.parseInt(item.getItunesDuration()) % 60000 \/ 1000;\n                holder.mTvPodcastDuration.setText(String.format(mContext.getResources().getString(R.string.duration), min, sec));\n            }\n        }\n        holder.mTvPodcastTitle.setText(item.getTitle());\n        holder.mPlayImageButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               \n                String imageUrl = \"\";\n                Cursor cursor = mContext.getContentResolver().query(mUri, null, null, null, null);\n                if (cursor != null) {\n                    while (cursor.moveToNext()) {\n                        imageUrl = cursor.getString(ApplicationConstants.COLUMN_SUBSCRIBED_PODCAST_FEED_IMAGE_URL);\n                    }\n                }\n                Track track = new Track();\n                track.setTitle(item.getTitle());\n                track.setStreamUrl(item.getEnclosure().getUrl());\n                track.setArtist(item.getItunesAuthor());\n                track.setArtworkUrl(imageUrl);\n                track.setDurationInMilli(Converter.getMilliSeconds(item.getItunesDuration()));\n                if (mListener != null) {\n                    mListener.onTrackClicked(track);\n                }\n            }\n        });\n        holder.mEpisodeRl.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                displayBottomSheet(item);\n            }\n        });\n    }","cleancode":"@override public void onbindviewholder(final viewholder holder, final int position) { final item item = mitemlist.get(position); setlistener(mlistener); string datestr = item.getpubdate(); dateformat formatter = new simpledateformat(\"eee, dd mmm yyyy hh:mm:ss\", locale.getdefault()); try { date date = formatter.parse(datestr); string pubdatestr = dateutils.formatabbrev(mcontext, date); string[] datemonth = pubdatestr.split(\" \"); holder.mtvmonth.settext(datemonth[0]); holder.mtvdate.settext(datemonth[1]); } catch (parseexception e) { e.printstacktrace(); googleanalyticsutil.trackexception(mcontext, e); } if (null != item.getitunesduration()) { if (item.getitunesduration().contains(\":\")) { holder.mtvpodcastduration.settext(item.getitunesduration()); } else { long min = integer.parseint(item.getitunesduration()) \/ 60000; long sec = integer.parseint(item.getitunesduration()) % 60000 \/ 1000; holder.mtvpodcastduration.settext(string.format(mcontext.getresources().getstring(r.string.duration), min, sec)); } } holder.mtvpodcasttitle.settext(item.gettitle()); holder.mplayimagebutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { string imageurl = \"\"; cursor cursor = mcontext.getcontentresolver().query(muri, null, null, null, null); if (cursor != null) { while (cursor.movetonext()) { imageurl = cursor.getstring(applicationconstants.column_subscribed_podcast_feed_image_url); } } track track = new track(); track.settitle(item.gettitle()); track.setstreamurl(item.getenclosure().geturl()); track.setartist(item.getitunesauthor()); track.setartworkurl(imageurl); track.setdurationinmilli(converter.getmilliseconds(item.getitunesduration())); if (mlistener != null) { mlistener.ontrackclicked(track); } } }); holder.mepisoderl.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { displaybottomsheet(item); } }); }","repo":"c0de-wizard\/pod-adddict","label":[0,1,0,0]}
{"id":21985,"original_code":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n    {\n        final boolean IGNORE_STYLESHEETS = true;\n        final boolean IGNORE_FAVICON = true;\n        final boolean DOCBASE_ONLY = false;\n        ValueFactory factory = SimpleValueFactory.getInstance();\n        String documentBaseUriStr = documentBaseUri.toString();\n        Iterator<Statement> iter = model.iterator();\n        \/\/Note that the model has a \"predictable iteration order\", and since we get a ConcurrentModException while altering the model itself,\n        \/\/ we choose to instance a new one, and add the valid filtered nodes in order to this new one\n        Model filteredModel = new LinkedHashModel();\n        while (iter.hasNext()) {\n            Statement stmt = iter.next();\n            \/\/!!! Note !!!\n            \/\/The double (eg. both XHTML_NS_STYLESHEET and LOCAL_NS_STYLESHEET) checks below are the result of a bug:\n            \/\/Because we set the @vocab attribute on the <html> element, all the stylesheet-links are prefixed with that namespace,\n            \/\/so they're actually not real XHTML predicates, but changed into eg. http:\/\/www.mot.be\/ontology\/stylesheet\n            \/\/Because it's quite a hard fix to implement, we work around it here.\n            \/\/remove all the XHTML stylesheets predicates from the model\n            boolean removed = false;\n            if (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\n                removed = true;\n            }\n            \/\/removes all favicon statements. Note that this last check isn't waterproof (we can use any name for our favicons), but it works 99% of the time\n            if (!removed && IGNORE_FAVICON &&\n                stmt.getObject().toString().contains(\"favicon\") &&\n                (stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\n                 stmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\n                 stmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n                )) {\n                removed = true;\n            }\n            \/\/remove all non-documentBaseUri subjects from the model\n            if (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\n                removed = true;\n            }\n            \/\/we're not interested in blank nodes because they don't have a page as subject, so we might as well filter them out\n            if (!removed && stmt.getSubject() instanceof BNode) {\n                removed = true;\n            }\n            \/\/we'll use this loop to whitespace-trim the values while we're at it\n            \/\/Note that this is a bit hacky. The more proper way would be to edit the com.beligum.blocks.rdf.importers.semargl.SesameSink.addPlainLiteral()\n            \/\/ method, but that class is supposed to be part of the core Sesame library (only copied over to have RDFa support in Sesame4), so I opted to implement it here\n            \/\/Also note that this implementation doens't trim the non-plain literal values (like datetime). They are passed over via the @content attribute inside RDFa,\n            \/\/ so it should be quite clean already. Also because the HTML input stream, coming from JSoup is minified before passed to Sesame.\n            \/\/ But it can be easily supported (the part where the exception is thrown)\n            if (!removed) {\n                \/\/these will hold possible modified pieces of the statement\n                Resource newSubject = null;\n                IRI newPredicate = null;\n                Value newObject = null;\n                \/\/trim all \"lang\" params from the subject\n                \/\/This is an important change:\n                \/\/ From time to time, the eg. ?lang=en part of an URI seeps through, even though we set every RDFa html tag with a clear @about attribute\n                \/\/ eg. this is the case as subject of \"http:\/\/www.w3.org\/ns\/rdfa#usesVocabulary\"\n                \/\/ Because we don't save the statements of a resource by language (the @lang tag makes sure it is added statement-per-statement for certain datatypes),\n                \/\/ the subject of the resource needs to be cleared from all lang query params to avoid false doubles while querying the triplestore (eg. using SPARQL).\n                \/\/ We group by subject-URI and double (or triple, or ..., depends on the amount of languages in the system) entries mess up the counts, iterations, group-by's, etc.\n                \/\/ That's why we try hard here to avoid these during import.\n                if (stmt.getSubject() instanceof IRI) {\n                    URI subject = URI.create(stmt.getSubject().stringValue());\n                    MultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\n                    if (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\n                        URI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\n                        newSubject = factory.createIRI(noLangUri.toString());\n                    }\n                }\n                \/\/if the object is a literal, check if it needs to be trimmed\n                \/\/BIG NOTE: XSD.anyURI is also an instance of a Literal!!\n                if (stmt.getObject() instanceof Literal) {\n                    Literal literal = (Literal) stmt.getObject();\n                    String objectValue = literal.getLabel();\n                    \/\/we like to use and save relative URIs as relative URIs because it means we don't need to\n                    \/\/update them if the site domain changes. But the RDFa doc clearly states all relative URIs need\n                    \/\/to be converted to absolute URIs: https:\/\/www.w3.org\/TR\/rdfa-core\/#s_curieprocessing\n                    \/\/However, when dealing with custom html tags (eg. <meta datatype=\"xsd:anyURI\"> tags), this doesn't happen\n                    \/\/automatically, so let's do it manually.\n                    if (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n                        \/\/this is important: blank URIs (and this happens; eg. a tag <meta property=\"sameAs\" datatype=\"xsd:anyURI\" \/> will yield a blank value for \"sameAs\"!)\n                        \/\/ would get filled in without this check; eg. a \"\" value would become \"http:\/\/localhost:8080\/en\/\" by default and this is bad! (eg. for sameAs properties)\n                        if (!StringUtils.isBlank(objectValue)) {\n                            URI objectUri = URI.create(objectValue);\n                            if (!objectUri.isAbsolute()) {\n                                objectUri = documentBaseUri.resolve(objectUri);\n                            }\n                            \/\/it makes sense to convert the data type to IRI as well\n                            newObject = factory.createIRI(objectUri.toString());\n                        }\n                    }\n                    \/\/this means it's a 'true' literal -> check if we can trim\n                    else {\n                        String objectValueTrimmed = StringUtils.strip(objectValue);\n                        if (!objectValue.equals(objectValueTrimmed)) {\n                            \/\/Note: this makes sense: see SimpleLiteral(String label, IRI datatype) constructor code\n                            if (literal.getDatatype().equals(RDF.LANGSTRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n                            }\n                            else if (literal.getDatatype().equals(XMLSchema.STRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else if (literal.getDatatype().equals(RDF.HTML)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else {\n                                throw new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n                            }\n                        }\n                    }\n                }\n                \/\/After all the filtering above, check if we need to change the statement: remove it from the model and add it again later on\n                Statement validStmt = null;\n                if (newSubject != null || newObject != null || newPredicate != null) {\n                    if (newSubject == null) {\n                        newSubject = stmt.getSubject();\n                    }\n                    if (newPredicate == null) {\n                        newPredicate = stmt.getPredicate();\n                    }\n                    if (newObject == null) {\n                        newObject = stmt.getObject();\n                    }\n                    if (stmt.getContext() == null) {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject);\n                    }\n                    else {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n                    }\n                }\n                else {\n                    validStmt = stmt;\n                }\n                filteredModel.add(validStmt);\n            }\n        }\n        \/\/ if the settings say so, validate the incoming (filtered) model\n        if (Settings.instance().getEnableRdfValidation()) {\n            new RdfModelImpl(filteredModel).validate();\n        }\n        \/\/DEBUG\n        \/\/RDFDataMgr.write(System.out, model, RDFFormat.NTRIPLES);\n        return filteredModel;\n    }","code_wo_comment":"protected Model filterModel(Model model, URI documentBaseUri) throws IOException\n    {\n        final boolean IGNORE_STYLESHEETS = true;\n        final boolean IGNORE_FAVICON = true;\n        final boolean DOCBASE_ONLY = false;\n        ValueFactory factory = SimpleValueFactory.getInstance();\n        String documentBaseUriStr = documentBaseUri.toString();\n        Iterator<Statement> iter = model.iterator();\n       \n       \n        Model filteredModel = new LinkedHashModel();\n        while (iter.hasNext()) {\n            Statement stmt = iter.next();\n           \n           \n           \n           \n           \n           \n            boolean removed = false;\n            if (!removed && IGNORE_STYLESHEETS && (stmt.getPredicate().toString().equals(XHTML_NS_STYLESHEET) || stmt.getPredicate().toString().equals(LOCAL_NS_STYLESHEET))) {\n                removed = true;\n            }\n           \n            if (!removed && IGNORE_FAVICON &&\n                stmt.getObject().toString().contains(\"favicon\") &&\n                (stmt.getPredicate().toString().equals(XHTML_NS_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_ICON) ||\n                 stmt.getPredicate().toString().equals(XHTML_NS_APPLE_TOUCH_ICON) || stmt.getPredicate().toString().equals(LOCAL_NS_APPLE_TOUCH_ICON) ||\n                 stmt.getPredicate().toString().equals(LOCAL_NS_MANIFEST)\n                )) {\n                removed = true;\n            }\n           \n            if (!removed && DOCBASE_ONLY && !stmt.getSubject().toString().equals(documentBaseUriStr)) {\n                removed = true;\n            }\n           \n            if (!removed && stmt.getSubject() instanceof BNode) {\n                removed = true;\n            }\n           \n           \n           \n           \n           \n           \n            if (!removed) {\n               \n                Resource newSubject = null;\n                IRI newPredicate = null;\n                Value newObject = null;\n               \n               \n               \n               \n               \n               \n               \n               \n                if (stmt.getSubject() instanceof IRI) {\n                    URI subject = URI.create(stmt.getSubject().stringValue());\n                    MultivaluedMap<String, String> queryParams = StringFunctions.getQueryParameters(subject);\n                    if (queryParams != null && queryParams.containsKey(I18nFactory.LANG_QUERY_PARAM)) {\n                        URI noLangUri = UriBuilder.fromUri(subject).replaceQueryParam(I18nFactory.LANG_QUERY_PARAM).build();\n                        newSubject = factory.createIRI(noLangUri.toString());\n                    }\n                }\n               \n               \n                if (stmt.getObject() instanceof Literal) {\n                    Literal literal = (Literal) stmt.getObject();\n                    String objectValue = literal.getLabel();\n                   \n                   \n                   \n                   \n                   \n                    if (literal.getDatatype().equals(XMLSchema.ANYURI)) {\n                       \n                       \n                        if (!StringUtils.isBlank(objectValue)) {\n                            URI objectUri = URI.create(objectValue);\n                            if (!objectUri.isAbsolute()) {\n                                objectUri = documentBaseUri.resolve(objectUri);\n                            }\n                           \n                            newObject = factory.createIRI(objectUri.toString());\n                        }\n                    }\n                   \n                    else {\n                        String objectValueTrimmed = StringUtils.strip(objectValue);\n                        if (!objectValue.equals(objectValueTrimmed)) {\n                           \n                            if (literal.getDatatype().equals(RDF.LANGSTRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getLanguage().get());\n                            }\n                            else if (literal.getDatatype().equals(XMLSchema.STRING)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else if (literal.getDatatype().equals(RDF.HTML)) {\n                                newObject = factory.createLiteral(objectValueTrimmed, literal.getDatatype());\n                            }\n                            else {\n                                throw new IOException(\"Encountered unsupported simple literal value, this shouldn't happen; \" + literal.getDatatype() + \" - \" + objectValue);\n                            }\n                        }\n                    }\n                }\n               \n                Statement validStmt = null;\n                if (newSubject != null || newObject != null || newPredicate != null) {\n                    if (newSubject == null) {\n                        newSubject = stmt.getSubject();\n                    }\n                    if (newPredicate == null) {\n                        newPredicate = stmt.getPredicate();\n                    }\n                    if (newObject == null) {\n                        newObject = stmt.getObject();\n                    }\n                    if (stmt.getContext() == null) {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject);\n                    }\n                    else {\n                        validStmt = factory.createStatement(newSubject, newPredicate, newObject, stmt.getContext());\n                    }\n                }\n                else {\n                    validStmt = stmt;\n                }\n                filteredModel.add(validStmt);\n            }\n        }\n       \n        if (Settings.instance().getEnableRdfValidation()) {\n            new RdfModelImpl(filteredModel).validate();\n        }\n       \n       \n        return filteredModel;\n    }","cleancode":"protected model filtermodel(model model, uri documentbaseuri) throws ioexception { final boolean ignore_stylesheets = true; final boolean ignore_favicon = true; final boolean docbase_only = false; valuefactory factory = simplevaluefactory.getinstance(); string documentbaseuristr = documentbaseuri.tostring(); iterator<statement> iter = model.iterator(); model filteredmodel = new linkedhashmodel(); while (iter.hasnext()) { statement stmt = iter.next(); boolean removed = false; if (!removed && ignore_stylesheets && (stmt.getpredicate().tostring().equals(xhtml_ns_stylesheet) || stmt.getpredicate().tostring().equals(local_ns_stylesheet))) { removed = true; } if (!removed && ignore_favicon && stmt.getobject().tostring().contains(\"favicon\") && (stmt.getpredicate().tostring().equals(xhtml_ns_icon) || stmt.getpredicate().tostring().equals(local_ns_icon) || stmt.getpredicate().tostring().equals(xhtml_ns_apple_touch_icon) || stmt.getpredicate().tostring().equals(local_ns_apple_touch_icon) || stmt.getpredicate().tostring().equals(local_ns_manifest) )) { removed = true; } if (!removed && docbase_only && !stmt.getsubject().tostring().equals(documentbaseuristr)) { removed = true; } if (!removed && stmt.getsubject() instanceof bnode) { removed = true; } if (!removed) { resource newsubject = null; iri newpredicate = null; value newobject = null; if (stmt.getsubject() instanceof iri) { uri subject = uri.create(stmt.getsubject().stringvalue()); multivaluedmap<string, string> queryparams = stringfunctions.getqueryparameters(subject); if (queryparams != null && queryparams.containskey(i18nfactory.lang_query_param)) { uri nolanguri = uribuilder.fromuri(subject).replacequeryparam(i18nfactory.lang_query_param).build(); newsubject = factory.createiri(nolanguri.tostring()); } } if (stmt.getobject() instanceof literal) { literal literal = (literal) stmt.getobject(); string objectvalue = literal.getlabel(); if (literal.getdatatype().equals(xmlschema.anyuri)) { if (!stringutils.isblank(objectvalue)) { uri objecturi = uri.create(objectvalue); if (!objecturi.isabsolute()) { objecturi = documentbaseuri.resolve(objecturi); } newobject = factory.createiri(objecturi.tostring()); } } else { string objectvaluetrimmed = stringutils.strip(objectvalue); if (!objectvalue.equals(objectvaluetrimmed)) { if (literal.getdatatype().equals(rdf.langstring)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getlanguage().get()); } else if (literal.getdatatype().equals(xmlschema.string)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getdatatype()); } else if (literal.getdatatype().equals(rdf.html)) { newobject = factory.createliteral(objectvaluetrimmed, literal.getdatatype()); } else { throw new ioexception(\"encountered unsupported simple literal value, this shouldn't happen; \" + literal.getdatatype() + \" - \" + objectvalue); } } } } statement validstmt = null; if (newsubject != null || newobject != null || newpredicate != null) { if (newsubject == null) { newsubject = stmt.getsubject(); } if (newpredicate == null) { newpredicate = stmt.getpredicate(); } if (newobject == null) { newobject = stmt.getobject(); } if (stmt.getcontext() == null) { validstmt = factory.createstatement(newsubject, newpredicate, newobject); } else { validstmt = factory.createstatement(newsubject, newpredicate, newobject, stmt.getcontext()); } } else { validstmt = stmt; } filteredmodel.add(validstmt); } } if (settings.instance().getenablerdfvalidation()) { new rdfmodelimpl(filteredmodel).validate(); } return filteredmodel; }","repo":"bramdvrepublic\/com.beligum.blocks.core","label":[1,0,0,0]}
{"id":13815,"original_code":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n        \/\/ since ratios are sorted, we send in ordered array of corresponding standard values\n        \/\/TODO: make more robust\n        SortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting();\/\/getValidRawRatios();\n        int count = 0;\n        Iterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\n        while (ratiosSortedSetIterator.hasNext()) {\n            DataModelInterface ratio = ratiosSortedSetIterator.next();\n            ((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n            \/\/ oct 2012 check for zero or missing standard ratio and remove ratio from fractination consideration\n            \/\/if ( standardValuesMap[count] == 0.0 ) {\n            ((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n            \/\/}\n            count++;\n        }\n    }","code_wo_comment":"public void updateRawRatioDataModelsWithPrimaryStandardValue(Double[] standardValuesMap) {\n       \n       \n        SortedSet<DataModelInterface> ratiosSortedSet = getRatiosForFractionFitting()\n        int count = 0;\n        Iterator<DataModelInterface> ratiosSortedSetIterator = ratiosSortedSet.iterator();\n        while (ratiosSortedSetIterator.hasNext()) {\n            DataModelInterface ratio = ratiosSortedSetIterator.next();\n            ((RawRatioDataModel) ratio).setStandardValue(standardValuesMap[count]);\n           \n           \n            ((RawRatioDataModel) ratio).setUsedForFractionationCorrections(standardValuesMap[count] != 0.0);\n           \n            count++;\n        }\n    }","cleancode":"public void updaterawratiodatamodelswithprimarystandardvalue(double[] standardvaluesmap) { sortedset<datamodelinterface> ratiossortedset = getratiosforfractionfitting() int count = 0; iterator<datamodelinterface> ratiossortedsetiterator = ratiossortedset.iterator(); while (ratiossortedsetiterator.hasnext()) { datamodelinterface ratio = ratiossortedsetiterator.next(); ((rawratiodatamodel) ratio).setstandardvalue(standardvaluesmap[count]); ((rawratiodatamodel) ratio).setusedforfractionationcorrections(standardvaluesmap[count] != 0.0); count++; } }","repo":"bowring\/ET_Redux","label":[1,0,0,0]}
{"id":13882,"original_code":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\n    FiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n    \/\/ Compute the chaining distances.\n    \/\/ We do <i>not<\/i> bother to materialize the chaining order.\n    for(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\n      final KNNList neighbors = knnq.getKNNForDBID(iter, k);\n      final int r = neighbors.size();\n      DoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n      \/\/ Store the current lowest reachability.\n      final double[] mindists = new double[r];\n      for(int i = 0; it1.valid(); it1.advance(), ++i) {\n        mindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n      }\n      double acsum = 0.;\n      for(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n        \/\/ Find the minimum:\n        int minpos = -1;\n        double mindist = Double.NaN;\n        for(int i = 0; i < mindists.length; ++i) {\n          double curdist = mindists[i];\n          \/\/ Both values could be NaN, deliberately.\n          if(curdist == curdist && !(curdist > mindist)) {\n            minpos = i;\n            mindist = curdist;\n          }\n        }\n        acsum += mindist * j; \/\/ Weighted sum, decreasing weights\n        mindists[minpos] = Double.NaN;\n        it1.seek(minpos);\n        \/\/ Update distances\n        it2.seek(0);\n        for(int i = 0; it2.valid(); it2.advance(), ++i) {\n          final double curdist = mindists[i];\n          if(curdist != curdist) {\n            continue; \/\/ NaN = processed!\n          }\n          double newdist = dq.distance(it1, it2);\n          if(newdist < curdist) {\n            mindists[i] = newdist;\n          }\n        }\n      }\n      acds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\n      LOG.incrementProcessed(lrdsProgress);\n    }\n    LOG.ensureCompleted(lrdsProgress);\n  }","code_wo_comment":"protected void computeAverageChainingDistances(KNNQuery<O> knnq, DistanceQuery<O> dq, DBIDs ids, WritableDoubleDataStore acds) {\n    FiniteProgress lrdsProgress = LOG.isVerbose() ? new FiniteProgress(\"Computing average chaining distances\", ids.size(), LOG) : null;\n   \n   \n    for(DBIDIter iter = ids.iter(); iter.valid(); iter.advance()) {\n      final KNNList neighbors = knnq.getKNNForDBID(iter, k);\n      final int r = neighbors.size();\n      DoubleDBIDListIter it1 = neighbors.iter(), it2 = neighbors.iter();\n     \n      final double[] mindists = new double[r];\n      for(int i = 0; it1.valid(); it1.advance(), ++i) {\n        mindists[i] = DBIDUtil.equal(it1, iter) ? Double.NaN : it1.doubleValue();\n      }\n      double acsum = 0.;\n      for(int j = ((r < k) ? r : k) - 1; j > 0; --j) {\n       \n        int minpos = -1;\n        double mindist = Double.NaN;\n        for(int i = 0; i < mindists.length; ++i) {\n          double curdist = mindists[i];\n         \n          if(curdist == curdist && !(curdist > mindist)) {\n            minpos = i;\n            mindist = curdist;\n          }\n        }\n        acsum += mindist * j;\n        mindists[minpos] = Double.NaN;\n        it1.seek(minpos);\n       \n        it2.seek(0);\n        for(int i = 0; it2.valid(); it2.advance(), ++i) {\n          final double curdist = mindists[i];\n          if(curdist != curdist) {\n            continue;\n          }\n          double newdist = dq.distance(it1, it2);\n          if(newdist < curdist) {\n            mindists[i] = newdist;\n          }\n        }\n      }\n      acds.putDouble(iter, acsum \/ (r * 0.5 * (r - 1.)));\n      LOG.incrementProcessed(lrdsProgress);\n    }\n    LOG.ensureCompleted(lrdsProgress);\n  }","cleancode":"protected void computeaveragechainingdistances(knnquery<o> knnq, distancequery<o> dq, dbids ids, writabledoubledatastore acds) { finiteprogress lrdsprogress = log.isverbose() ? new finiteprogress(\"computing average chaining distances\", ids.size(), log) : null; for(dbiditer iter = ids.iter(); iter.valid(); iter.advance()) { final knnlist neighbors = knnq.getknnfordbid(iter, k); final int r = neighbors.size(); doubledbidlistiter it1 = neighbors.iter(), it2 = neighbors.iter(); final double[] mindists = new double[r]; for(int i = 0; it1.valid(); it1.advance(), ++i) { mindists[i] = dbidutil.equal(it1, iter) ? double.nan : it1.doublevalue(); } double acsum = 0.; for(int j = ((r < k) ? r : k) - 1; j > 0; --j) { int minpos = -1; double mindist = double.nan; for(int i = 0; i < mindists.length; ++i) { double curdist = mindists[i]; if(curdist == curdist && !(curdist > mindist)) { minpos = i; mindist = curdist; } } acsum += mindist * j; mindists[minpos] = double.nan; it1.seek(minpos); it2.seek(0); for(int i = 0; it2.valid(); it2.advance(), ++i) { final double curdist = mindists[i]; if(curdist != curdist) { continue; } double newdist = dq.distance(it1, it2); if(newdist < curdist) { mindists[i] = newdist; } } } acds.putdouble(iter, acsum \/ (r * 0.5 * (r - 1.))); log.incrementprocessed(lrdsprogress); } log.ensurecompleted(lrdsprogress); }","repo":"bertl4398\/ssdbm2020","label":[1,0,0,0]}
{"id":22220,"original_code":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\n        PerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\n        String author = \"\";\n        String cite = \"\";\n       \/\/ System.out.println(\"Start\");\n        ArrayList<String> perspectives = new ArrayList<String>();\n        if (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\n            ArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n           \/\/ System.out.println(\"perspectiveTriples.size() = \" + perspectiveTriples.size());\n            for (int i = 0; i < perspectiveTriples.size(); i++) {\n                Statement statement = perspectiveTriples.get(i);\n                String subject = statement.getSubject().getURI();\n                String predicate = statement.getPredicate().getURI();\n                String object = statement.getObject().toString();\n                if (predicate.endsWith(\"#hasAttribution\")) {\n                    if (trigTripleData.tripleMapGrasp.containsKey(object)) {\n                        ArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\n                        for (int j = 0; j < perspectiveValues.size(); j++) {\n                            Statement statement1 = perspectiveValues.get(j);\n                            \/\/System.out.println(\"statement1.toString() = \" + statement1.toString());\n                           \/\/ System.out.println(\"statement1.getObject().toString() = \" + statement1.getObject().toString());\n                            \/\/ttp:\/\/www.w3.org\/ns\/prov#wasAttributedTo,\n                            if (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\n                                if (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n                                    \/\/\/\/ this means the source has properties so it is likely to be the document with an author\n                                    ArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\n                                    for (int k = 0; k < provStatements.size(); k++) {\n                                        Statement statement2 = provStatements.get(k);\n                                        author = statement2.getObject().toString();\n                                        int idx = author.lastIndexOf(\"\/\");\n                                        if (idx > -1) {\n                                            author = author.substring(idx + 1);\n                                        }\n                                     \/\/   System.out.println(\"author source = \" + author);\n                                    }\n                                } else {\n                                    \/\/\/\/ it is not the document so a cited source\n                                    cite = statement1.getObject().toString();\n                                    int idx = cite.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        cite = cite.substring(idx + 1);\n                                    }\n\/*                                  THIS DOES NOT WORK: PRONOUNS, RECEPTIONIST, ETC...\n                                    \/\/\/\/ There can be source documents without meta data.\n                                    \/\/\/\/ In that case, there are no triples for in tripleMapGrasp with this subject but it is still a document\n                                    \/\/\/\/ The next hack checks for upper case characters in the URI\n                                    \/\/\/\/ If they are present, we assume it is somebody otherwise we assume it is a document and we assign it to the meta string\n                                    if (cite.toLowerCase().equals(cite)) {\n                                        \/\/\/\/ no uppercase characters\n                                        cite = meta;\n                                    }\n*\/\n                                  \/\/  System.out.println(\"quote source = \" + cite);\n                                }\n                            } else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\n                                String perspective = \"\";\n                                String str = statement1.getObject().toString();\n                                \/\/   System.out.println(\"str = \" + str);\n                                int idx = str.lastIndexOf(\"#\");\n                                if (idx > -1) {\n                                    perspective = str.substring(idx + 1);\n                                } else {\n                                    idx = str.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        perspective = str.substring(idx + 1);\n                                    } else {\n                                        perspective = str;\n                                    }\n                                }\n                                ArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\n                                for (int k = 0; k < myPerspectives.size(); k++) {\n                                    String myPerspective = myPerspectives.get(k);\n                                    if (!perspectives.contains(myPerspective)) {\n                                      \/\/  System.out.println(\"myPerspective = \" + myPerspective);\n                                        perspectives.add(myPerspective);\n                                    }\n                                }\n                            } else {\n                               \/\/     System.out.println(\"statement1.getPredicate().getURI() = \" + statement1.getPredicate().getURI());\n                            }\n                        }\n                    }\n                }\n            }\n            if (perspectives.size() > 0) {\n              \/\/  System.out.println(\"final author = \" + author);\n                perspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n            }\n        }\n        return perspectiveJsonObject;\n    }","code_wo_comment":"public static PerspectiveJsonObject getPerspectiveObjectForEvent(TrigTripleData trigTripleData, String mentionUri, String meta) {\n        PerspectiveJsonObject perspectiveJsonObject = new PerspectiveJsonObject();\n        String author = \"\";\n        String cite = \"\";\n      \n        ArrayList<String> perspectives = new ArrayList<String>();\n        if (trigTripleData.tripleMapGrasp.containsKey(mentionUri)) {\n            ArrayList<Statement> perspectiveTriples = trigTripleData.tripleMapGrasp.get(mentionUri);\n          \n            for (int i = 0; i < perspectiveTriples.size(); i++) {\n                Statement statement = perspectiveTriples.get(i);\n                String subject = statement.getSubject().getURI();\n                String predicate = statement.getPredicate().getURI();\n                String object = statement.getObject().toString();\n                if (predicate.endsWith(\"#hasAttribution\")) {\n                    if (trigTripleData.tripleMapGrasp.containsKey(object)) {\n                        ArrayList<Statement> perspectiveValues = trigTripleData.tripleMapGrasp.get(object);\n                        for (int j = 0; j < perspectiveValues.size(); j++) {\n                            Statement statement1 = perspectiveValues.get(j);\n                           \n                          \n                           \n                            if (statement1.getPredicate().getURI().endsWith(\"#wasAttributedTo\")) {\n                                if (trigTripleData.tripleMapGrasp.containsKey(statement1.getObject().toString())) {\n                                   \n                                    ArrayList<Statement> provStatements = trigTripleData.tripleMapGrasp.get(statement1.getObject().toString());\n                                    for (int k = 0; k < provStatements.size(); k++) {\n                                        Statement statement2 = provStatements.get(k);\n                                        author = statement2.getObject().toString();\n                                        int idx = author.lastIndexOf(\"\/\");\n                                        if (idx > -1) {\n                                            author = author.substring(idx + 1);\n                                        }\n                                    \n                                    }\n                                } else {\n                                   \n                                    cite = statement1.getObject().toString();\n                                    int idx = cite.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        cite = cite.substring(idx + 1);\n                                    }\n                                 \n                                }\n                            } else if (statement1.getPredicate().getURI().endsWith(\"#value\")) {\n                                String perspective = \"\";\n                                String str = statement1.getObject().toString();\n                               \n                                int idx = str.lastIndexOf(\"#\");\n                                if (idx > -1) {\n                                    perspective = str.substring(idx + 1);\n                                } else {\n                                    idx = str.lastIndexOf(\"\/\");\n                                    if (idx > -1) {\n                                        perspective = str.substring(idx + 1);\n                                    } else {\n                                        perspective = str;\n                                    }\n                                }\n                                ArrayList<String> myPerspectives = PerspectiveJsonObject.normalizePerspectiveValue(perspective);\n                                for (int k = 0; k < myPerspectives.size(); k++) {\n                                    String myPerspective = myPerspectives.get(k);\n                                    if (!perspectives.contains(myPerspective)) {\n                                     \n                                        perspectives.add(myPerspective);\n                                    }\n                                }\n                            } else {\n                              \n                            }\n                        }\n                    }\n                }\n            }\n            if (perspectives.size() > 0) {\n             \n                perspectiveJsonObject = new PerspectiveJsonObject(perspectives, author, cite, \"\", \"\", \"\", mentionUri, null);\n            }\n        }\n        return perspectiveJsonObject;\n    }","cleancode":"public static perspectivejsonobject getperspectiveobjectforevent(trigtripledata trigtripledata, string mentionuri, string meta) { perspectivejsonobject perspectivejsonobject = new perspectivejsonobject(); string author = \"\"; string cite = \"\"; arraylist<string> perspectives = new arraylist<string>(); if (trigtripledata.triplemapgrasp.containskey(mentionuri)) { arraylist<statement> perspectivetriples = trigtripledata.triplemapgrasp.get(mentionuri); for (int i = 0; i < perspectivetriples.size(); i++) { statement statement = perspectivetriples.get(i); string subject = statement.getsubject().geturi(); string predicate = statement.getpredicate().geturi(); string object = statement.getobject().tostring(); if (predicate.endswith(\"#hasattribution\")) { if (trigtripledata.triplemapgrasp.containskey(object)) { arraylist<statement> perspectivevalues = trigtripledata.triplemapgrasp.get(object); for (int j = 0; j < perspectivevalues.size(); j++) { statement statement1 = perspectivevalues.get(j); if (statement1.getpredicate().geturi().endswith(\"#wasattributedto\")) { if (trigtripledata.triplemapgrasp.containskey(statement1.getobject().tostring())) { arraylist<statement> provstatements = trigtripledata.triplemapgrasp.get(statement1.getobject().tostring()); for (int k = 0; k < provstatements.size(); k++) { statement statement2 = provstatements.get(k); author = statement2.getobject().tostring(); int idx = author.lastindexof(\"\/\"); if (idx > -1) { author = author.substring(idx + 1); } } } else { cite = statement1.getobject().tostring(); int idx = cite.lastindexof(\"\/\"); if (idx > -1) { cite = cite.substring(idx + 1); } } } else if (statement1.getpredicate().geturi().endswith(\"#value\")) { string perspective = \"\"; string str = statement1.getobject().tostring(); int idx = str.lastindexof(\"#\"); if (idx > -1) { perspective = str.substring(idx + 1); } else { idx = str.lastindexof(\"\/\"); if (idx > -1) { perspective = str.substring(idx + 1); } else { perspective = str; } } arraylist<string> myperspectives = perspectivejsonobject.normalizeperspectivevalue(perspective); for (int k = 0; k < myperspectives.size(); k++) { string myperspective = myperspectives.get(k); if (!perspectives.contains(myperspective)) { perspectives.add(myperspective); } } } else { } } } } } if (perspectives.size() > 0) { perspectivejsonobject = new perspectivejsonobject(perspectives, author, cite, \"\", \"\", \"\", mentionuri, null); } } return perspectivejsonobject; }","repo":"cltl\/EventCoreference","label":[0,0,1,0]}
{"id":14154,"original_code":"@Test\n  void buildTask() throws Exception {\n    VelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\n    CountDownLatch latch = new CountDownLatch(1);\n    ScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n        .schedule();\n    latch.await();\n    assertEquals(TaskStatus.FINISHED, task.status());\n  }","code_wo_comment":"@Test\n  void buildTask() throws Exception {\n    VelocityScheduler scheduler = new VelocityScheduler(new FakePluginManager());\n    CountDownLatch latch = new CountDownLatch(1);\n    ScheduledTask task = scheduler.buildTask(FakePluginManager.PLUGIN_A, latch::countDown)\n        .schedule();\n    latch.await();\n    assertEquals(TaskStatus.FINISHED, task.status());\n  }","cleancode":"@test void buildtask() throws exception { velocityscheduler scheduler = new velocityscheduler(new fakepluginmanager()); countdownlatch latch = new countdownlatch(1); scheduledtask task = scheduler.buildtask(fakepluginmanager.plugin_a, latch::countdown) .schedule(); latch.await(); assertequals(taskstatus.finished, task.status()); }","repo":"astei\/velocity","label":[0,0,1,0]}
{"id":30548,"original_code":"@Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        ParseUser currentUser = ParseUser.getCurrentUser();\n        String role = currentUser.getString(\"role\");\n        if(convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.product_list_item, null);\n            holder = new ViewHolder();\n            holder.companyNameLabel = (TextView) convertView.findViewById(R.id.companyName);\n            holder.productNameLabel = (TextView) convertView.findViewById(R.id.productNameLabel);\n            holder.priceNameLabel = (TextView) convertView.findViewById(R.id.productPriceLabel);\n            holder.addItemButton = (Button) convertView.findViewById(R.id.btnAddToCart);\n            holder.editItemButton = (Button) convertView.findViewById(R.id.btnEditButton);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        if (role.equals(\"Company Account\")) {\n            holder.editItemButton.setVisibility(View.VISIBLE);\n        }\n        else if (role.equals(\"Personal Account\")) {\n            holder.addItemButton.setVisibility(View.VISIBLE);\n        }\n        final Product product = mProducts.get(position);\n        holder.companyNameLabel.setText(product.getCompany());\n        holder.productNameLabel.setText(product.getProductName());\n        holder.priceNameLabel.setText(product.getPrice() + \"\");\n        holder.addItemButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(mContext, CheckoutActivity.class);\n                intent.putExtra(\"product\", product.getProductName());\n                mContext.startActivity(intent);\n                \/\/TODO: Add functionality for edit button\n            }\n        });\n        return convertView;\n    }","code_wo_comment":"@Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        ParseUser currentUser = ParseUser.getCurrentUser();\n        String role = currentUser.getString(\"role\");\n        if(convertView == null) {\n            convertView = LayoutInflater.from(mContext).inflate(R.layout.product_list_item, null);\n            holder = new ViewHolder();\n            holder.companyNameLabel = (TextView) convertView.findViewById(R.id.companyName);\n            holder.productNameLabel = (TextView) convertView.findViewById(R.id.productNameLabel);\n            holder.priceNameLabel = (TextView) convertView.findViewById(R.id.productPriceLabel);\n            holder.addItemButton = (Button) convertView.findViewById(R.id.btnAddToCart);\n            holder.editItemButton = (Button) convertView.findViewById(R.id.btnEditButton);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n        if (role.equals(\"Company Account\")) {\n            holder.editItemButton.setVisibility(View.VISIBLE);\n        }\n        else if (role.equals(\"Personal Account\")) {\n            holder.addItemButton.setVisibility(View.VISIBLE);\n        }\n        final Product product = mProducts.get(position);\n        holder.companyNameLabel.setText(product.getCompany());\n        holder.productNameLabel.setText(product.getProductName());\n        holder.priceNameLabel.setText(product.getPrice() + \"\");\n        holder.addItemButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                Intent intent = new Intent(mContext, CheckoutActivity.class);\n                intent.putExtra(\"product\", product.getProductName());\n                mContext.startActivity(intent);\n               \n            }\n        });\n        return convertView;\n    }","cleancode":"@override public view getview(int position, view convertview, viewgroup parent) { viewholder holder; parseuser currentuser = parseuser.getcurrentuser(); string role = currentuser.getstring(\"role\"); if(convertview == null) { convertview = layoutinflater.from(mcontext).inflate(r.layout.product_list_item, null); holder = new viewholder(); holder.companynamelabel = (textview) convertview.findviewbyid(r.id.companyname); holder.productnamelabel = (textview) convertview.findviewbyid(r.id.productnamelabel); holder.pricenamelabel = (textview) convertview.findviewbyid(r.id.productpricelabel); holder.additembutton = (button) convertview.findviewbyid(r.id.btnaddtocart); holder.edititembutton = (button) convertview.findviewbyid(r.id.btneditbutton); convertview.settag(holder); } else { holder = (viewholder) convertview.gettag(); } if (role.equals(\"company account\")) { holder.edititembutton.setvisibility(view.visible); } else if (role.equals(\"personal account\")) { holder.additembutton.setvisibility(view.visible); } final product product = mproducts.get(position); holder.companynamelabel.settext(product.getcompany()); holder.productnamelabel.settext(product.getproductname()); holder.pricenamelabel.settext(product.getprice() + \"\"); holder.additembutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(mcontext, checkoutactivity.class); intent.putextra(\"product\", product.getproductname()); mcontext.startactivity(intent); } }); return convertview; }","repo":"ashleysullins\/Postmates-android","label":[0,1,0,0]}
{"id":22367,"original_code":"public static void main(String[] args) {\n        \/\/ TODO Implement me, pls :(\n    }","code_wo_comment":"public static void main(String[] args) {\n       \n    }","cleancode":"public static void main(string[] args) { }","repo":"awwitecki\/kafka-samples","label":[0,1,0,0]}
{"id":30563,"original_code":"private boolean hasTimedOut(SentMessage sentMessage) {\n        \/\/ NPE fix.  For some reason under heavy load redis can return null records.\n        if (sentMessage == null) {            \n            return false;\n        }\n        long now = new Date().getTime();\n        Date createdTs = sentMessage.getCreatedTs();\n        return createdTs.getTime() + faxTimeout < now;\n    }","code_wo_comment":"private boolean hasTimedOut(SentMessage sentMessage) {\n       \n        if (sentMessage == null) {            \n            return false;\n        }\n        long now = new Date().getTime();\n        Date createdTs = sentMessage.getCreatedTs();\n        return createdTs.getTime() + faxTimeout < now;\n    }","cleancode":"private boolean hastimedout(sentmessage sentmessage) { if (sentmessage == null) { return false; } long now = new date().gettime(); date createdts = sentmessage.getcreatedts(); return createdts.gettime() + faxtimeout < now; }","repo":"bcgov\/jag-efax","label":[0,0,1,0]}
{"id":22568,"original_code":"public long forceSkip(long bytesToSkip) throws IOException {\n      long skipped = mUpstream.skip(bytesToSkip);\n      try {\n        \/\/ Figure out where we need to jump to...\n        int skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\n        long blockOffset = bytesToSkip - skip;\n        long numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n        \/\/ TODO: This is designed for CTS mode, for other modes this routine code has to be changed\n        \/\/ So that we don't have to read the entire stream, we have to compute what the IV should be at this point in time in CTS mode\n        BigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\n        byte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\n        IvParameterSpec computedIvParameterSpecForOffset;\n        if (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\n          byte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\n          System.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\n          computedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n        } else {\n          computedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n        }\n        \/\/ Setup the cipher to use the new IV at the proper offset...\n        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\n        byte[] skipBuffer = new byte[skip];\n        \/\/ And read\/update the buffer to be decrypted\n        mCipher.update(skipBuffer, 0, skip, skipBuffer);\n        Arrays.fill(skipBuffer, (byte) 0);\n      } catch (Exception e) {\n        return 0;\n      }\n      return skipped;\n    }","code_wo_comment":"public long forceSkip(long bytesToSkip) throws IOException {\n      long skipped = mUpstream.skip(bytesToSkip);\n      try {\n       \n        int skip = (int) (bytesToSkip % AES_BLOCK_SIZE);\n        long blockOffset = bytesToSkip - skip;\n        long numberOfBlocks = blockOffset \/ AES_BLOCK_SIZE;\n       \n       \n        BigInteger ivForOffsetAsBigInteger = new BigInteger(1, mIvParameterSpec.getIV()).add(BigInteger.valueOf(numberOfBlocks));\n        byte[] ivForOffsetByteArray = ivForOffsetAsBigInteger.toByteArray();\n        IvParameterSpec computedIvParameterSpecForOffset;\n        if (ivForOffsetByteArray.length < AES_BLOCK_SIZE) {\n          byte[] resizedIvForOffsetByteArray = new byte[AES_BLOCK_SIZE];\n          System.arraycopy(ivForOffsetByteArray, 0, resizedIvForOffsetByteArray, AES_BLOCK_SIZE - ivForOffsetByteArray.length, ivForOffsetByteArray.length);\n          computedIvParameterSpecForOffset = new IvParameterSpec(resizedIvForOffsetByteArray);\n        } else {\n          computedIvParameterSpecForOffset = new IvParameterSpec(ivForOffsetByteArray, ivForOffsetByteArray.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n        }\n       \n        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, computedIvParameterSpecForOffset);\n        byte[] skipBuffer = new byte[skip];\n       \n        mCipher.update(skipBuffer, 0, skip, skipBuffer);\n        Arrays.fill(skipBuffer, (byte) 0);\n      } catch (Exception e) {\n        return 0;\n      }\n      return skipped;\n    }","cleancode":"public long forceskip(long bytestoskip) throws ioexception { long skipped = mupstream.skip(bytestoskip); try { int skip = (int) (bytestoskip % aes_block_size); long blockoffset = bytestoskip - skip; long numberofblocks = blockoffset \/ aes_block_size; biginteger ivforoffsetasbiginteger = new biginteger(1, mivparameterspec.getiv()).add(biginteger.valueof(numberofblocks)); byte[] ivforoffsetbytearray = ivforoffsetasbiginteger.tobytearray(); ivparameterspec computedivparameterspecforoffset; if (ivforoffsetbytearray.length < aes_block_size) { byte[] resizedivforoffsetbytearray = new byte[aes_block_size]; system.arraycopy(ivforoffsetbytearray, 0, resizedivforoffsetbytearray, aes_block_size - ivforoffsetbytearray.length, ivforoffsetbytearray.length); computedivparameterspecforoffset = new ivparameterspec(resizedivforoffsetbytearray); } else { computedivparameterspecforoffset = new ivparameterspec(ivforoffsetbytearray, ivforoffsetbytearray.length - aes_block_size, aes_block_size); } mcipher.init(cipher.encrypt_mode, msecretkeyspec, computedivparameterspecforoffset); byte[] skipbuffer = new byte[skip]; mcipher.update(skipbuffer, 0, skip, skipbuffer); arrays.fill(skipbuffer, (byte) 0); } catch (exception e) { return 0; } return skipped; }","repo":"bancha2nd\/nativescript-plugins","label":[1,0,0,0]}
{"id":30915,"original_code":"@BeforeEach\n\tprotected void setup() throws Exception {\n\t\t\/\/ Remove the existing program data folder\n\t\tString suffix = \"-\" + Profile.TEST;\n\t\tProductCard metadata = ProductCard.info( Program.class );\n\t\tPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\n\t\tassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\t\t\/\/ For the parameters to be available using Java 9, the following needs to be added\n\t\t\/\/ to the test JVM command line parameters because com.sun.javafx.application.ParametersImpl\n\t\t\/\/ is not exposed, nor is there a \"proper\" way to access it:\n\t\t\/\/\n\t\t\/\/ --add-opens=javafx.graphics\/com.sun.javafx.application=ALL-UNNAMED\n\t\tprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\n\t\tprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\t\/\/ NOTE Thread.yield() is helpful but not consistent\n\t\tThread.yield();\n\t\tprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\t\/\/ NOTE Thread.yield() is helpful but not consistent\n\t\tThread.yield();\n\t\t\/\/ Wait for the active workarea\n\t\t\/\/ FIXME This should use an event listener to wait for the workarea\n\t\tlong limit = System.currentTimeMillis() + TIMEOUT;\n\t\twhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\n\t\t\tThreadUtil.pause( 100 );\n\t\t}\n\t\tassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\n\t\tWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\n\t\tworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\n\t\tinitialMemoryUse = getMemoryUse();\n\t}","code_wo_comment":"@BeforeEach\n\tprotected void setup() throws Exception {\n\t\n\t\tString suffix = \"-\" + Profile.TEST;\n\t\tProductCard metadata = ProductCard.info( Program.class );\n\t\tPath programDataFolder = OperatingSystem.getUserProgramDataFolder( metadata.getArtifact() + suffix, metadata.getName() + suffix );\n\t\tassertThat( aggressiveDelete( programDataFolder ) ).withFailMessage( \"Failed to delete program data folder\" ).isTrue();\n\t\n\t\n\t\n\t\n\t\n\t\tprogram = (Program)FxToolkit.setupApplication( Program.class, ProgramTestConfig.getParameterValues() );\n\t\tprogram.register( ProgramEvent.ANY, programWatcher = new EventWatcher( TIMEOUT ) );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\n\t\tThread.yield();\n\t\tprogramWatcher.waitForEvent( ProgramEvent.STARTED, TIMEOUT );\n\t\tFx.waitForWithExceptions( TIMEOUT );\n\t\n\t\tThread.yield();\n\t\n\t\n\t\tlong limit = System.currentTimeMillis() + TIMEOUT;\n\t\twhile( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() == null && System.currentTimeMillis() < limit ) {\n\t\t\tThreadUtil.pause( 100 );\n\t\t}\n\t\tassertThat( program ).withFailMessage( \"Program is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager() ).withFailMessage( \"Workspace manager is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace() ).withFailMessage( \"Active workspace is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea() ).withFailMessage( \"Active workarea is null\" ).isNotNull();\n\t\tassertThat( program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane() ).withFailMessage( \"Active workpane is null\" ).isNotNull();\n\t\tWorkpane workpane = program.getWorkspaceManager().getActiveWorkspace().getActiveWorkarea().getWorkpane();\n\t\tworkpane.addEventHandler( WorkpaneEvent.ANY, workpaneWatcher = new FxEventWatcher() );\n\t\tinitialMemoryUse = getMemoryUse();\n\t}","cleancode":"@beforeeach protected void setup() throws exception { string suffix = \"-\" + profile.test; productcard metadata = productcard.info( program.class ); path programdatafolder = operatingsystem.getuserprogramdatafolder( metadata.getartifact() + suffix, metadata.getname() + suffix ); assertthat( aggressivedelete( programdatafolder ) ).withfailmessage( \"failed to delete program data folder\" ).istrue(); program = (program)fxtoolkit.setupapplication( program.class, programtestconfig.getparametervalues() ); program.register( programevent.any, programwatcher = new eventwatcher( timeout ) ); fx.waitforwithexceptions( timeout ); thread.yield(); programwatcher.waitforevent( programevent.started, timeout ); fx.waitforwithexceptions( timeout ); thread.yield(); long limit = system.currenttimemillis() + timeout; while( program.getworkspacemanager().getactiveworkspace().getactiveworkarea() == null && system.currenttimemillis() < limit ) { threadutil.pause( 100 ); } assertthat( program ).withfailmessage( \"program is null\" ).isnotnull(); assertthat( program.getworkspacemanager() ).withfailmessage( \"workspace manager is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace() ).withfailmessage( \"active workspace is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace().getactiveworkarea() ).withfailmessage( \"active workarea is null\" ).isnotnull(); assertthat( program.getworkspacemanager().getactiveworkspace().getactiveworkarea().getworkpane() ).withfailmessage( \"active workpane is null\" ).isnotnull(); workpane workpane = program.getworkspacemanager().getactiveworkspace().getactiveworkarea().getworkpane(); workpane.addeventhandler( workpaneevent.any, workpanewatcher = new fxeventwatcher() ); initialmemoryuse = getmemoryuse(); }","repo":"avereon\/xenon","label":[1,0,0,0]}
{"id":14698,"original_code":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\n        List<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\n        RepositoryCache.enter(cacheConfigurationManager);\n        try {\n            for (AssignmentType assignmentType: assignments) {\n                try {\n                    PrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\n                    if (definition == null) {\n                        \/\/ TODO: optimize\n                        definition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n                    }\n                    ItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\n                            new ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\n                    EvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\n                    evaluatedAssignments.add(assignment);\n                } catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\n                    LOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\n                            assignmentHolder, e.getMessage(), assignmentType, e);\n                }\n            }\n        } finally {\n            RepositoryCache.exit();\n        }\n        return evaluatedAssignments;\n    }","code_wo_comment":"private <AH extends AssignmentHolderType> Collection<EvaluatedAssignment<AH>> evaluateAssignments(AH assignmentHolder, Collection<AssignmentType> assignments, boolean virtual, AssignmentEvaluator<AH> assignmentEvaluator, Task task, OperationResult result) {\n        List<EvaluatedAssignment<AH>> evaluatedAssignments = new ArrayList<>();\n        RepositoryCache.enter(cacheConfigurationManager);\n        try {\n            for (AssignmentType assignmentType: assignments) {\n                try {\n                    PrismContainerDefinition definition = assignmentType.asPrismContainerValue().getDefinition();\n                    if (definition == null) {\n                       \n                        definition = prismContext.getSchemaRegistry().findObjectDefinitionByCompileTimeClass(AssignmentHolderType.class).findContainerDefinition(AssignmentHolderType.F_ASSIGNMENT);\n                    }\n                    ItemDeltaItem<PrismContainerValue<AssignmentType>,PrismContainerDefinition<AssignmentType>> assignmentIdi =\n                            new ItemDeltaItem<>(LensUtil.createAssignmentSingleValueContainer(assignmentType), definition);\n                    EvaluatedAssignment<AH> assignment = assignmentEvaluator.evaluate(assignmentIdi, PlusMinusZero.ZERO, false, assignmentHolder, assignmentHolder.toString(), virtual, task, result);\n                    evaluatedAssignments.add(assignment);\n                } catch (SchemaException | ObjectNotFoundException | ExpressionEvaluationException | PolicyViolationException | SecurityViolationException | ConfigurationException | CommunicationException e) {\n                    LOGGER.error(\"Error while processing assignment of {}: {}; assignment: {}\",\n                            assignmentHolder, e.getMessage(), assignmentType, e);\n                }\n            }\n        } finally {\n            RepositoryCache.exit();\n        }\n        return evaluatedAssignments;\n    }","cleancode":"private <ah extends assignmentholdertype> collection<evaluatedassignment<ah>> evaluateassignments(ah assignmentholder, collection<assignmenttype> assignments, boolean virtual, assignmentevaluator<ah> assignmentevaluator, task task, operationresult result) { list<evaluatedassignment<ah>> evaluatedassignments = new arraylist<>(); repositorycache.enter(cacheconfigurationmanager); try { for (assignmenttype assignmenttype: assignments) { try { prismcontainerdefinition definition = assignmenttype.asprismcontainervalue().getdefinition(); if (definition == null) { definition = prismcontext.getschemaregistry().findobjectdefinitionbycompiletimeclass(assignmentholdertype.class).findcontainerdefinition(assignmentholdertype.f_assignment); } itemdeltaitem<prismcontainervalue<assignmenttype>,prismcontainerdefinition<assignmenttype>> assignmentidi = new itemdeltaitem<>(lensutil.createassignmentsinglevaluecontainer(assignmenttype), definition); evaluatedassignment<ah> assignment = assignmentevaluator.evaluate(assignmentidi, plusminuszero.zero, false, assignmentholder, assignmentholder.tostring(), virtual, task, result); evaluatedassignments.add(assignment); } catch (schemaexception | objectnotfoundexception | expressionevaluationexception | policyviolationexception | securityviolationexception | configurationexception | communicationexception e) { logger.error(\"error while processing assignment of {}: {}; assignment: {}\", assignmentholder, e.getmessage(), assignmenttype, e); } } } finally { repositorycache.exit(); } return evaluatedassignments; }","repo":"bshp\/midpoint","label":[1,0,0,0]}
{"id":22947,"original_code":"private void decode(byte[] sensorData) {\n        kiwriousReader.setRawValues(sensorData);\n        switch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n            \/\/TODO: complete decode calls using bye array data\n            case SENSOR_COLOUR:\n                String[] colorValues = sensorDecoder.decodeColor(sensorData);\n                kiwriousReader.setR(Integer.parseInt(colorValues[0]));\n                kiwriousReader.setG(Integer.parseInt(colorValues[1]));\n                kiwriousReader.setB(Integer.parseInt(colorValues[2]));\n                break;\n            case SENSOR_CONDUCTIVITY:\n                String[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\n                kiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\n                kiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\n                break;\n            case SENSOR_HEART_RATE:\n                String heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\n                kiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\n                break;\n            case SENSOR_HUMIDITY:\n                Float[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\n                kiwriousReader.setTemperature(humidityValues[0]);\n                kiwriousReader.setHumidity(humidityValues[1]);\n                break;\n            case SENSOR_SOUND:\n\/\/                sensorDecoder.decodeSound(values);\n                break;\n            case SENSOR_TEMPERATURE:\n                String[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\n                break;\n            case SENSOR_TEMPERATURE2:\n                String[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));\n                break;\n            case SENSOR_UV:\n                String[] lightValues = sensorDecoder.decodeUV(sensorData);\n                kiwriousReader.setLux(Long.parseLong(lightValues[0]));\n                kiwriousReader.setUv(Float.parseFloat(lightValues[1]));\n                break;\n            case SENSOR_VOC:\n                String[] vocValues = sensorDecoder.decodeVOC(sensorData);\n                kiwriousReader.setVoc(Integer.parseInt(vocValues[0]));\n                kiwriousReader.setCo2(Integer.parseInt(vocValues[1]));\n                break;\n            default:\n                Log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensorData[KIWRIOUS_SENSOR_TYPE]);\n                break;\n        }\n    }","code_wo_comment":"private void decode(byte[] sensorData) {\n        kiwriousReader.setRawValues(sensorData);\n        switch (sensorData[KIWRIOUS_SENSOR_TYPE]) {\n           \n            case SENSOR_COLOUR:\n                String[] colorValues = sensorDecoder.decodeColor(sensorData);\n                kiwriousReader.setR(Integer.parseInt(colorValues[0]));\n                kiwriousReader.setG(Integer.parseInt(colorValues[1]));\n                kiwriousReader.setB(Integer.parseInt(colorValues[2]));\n                break;\n            case SENSOR_CONDUCTIVITY:\n                String[] conductivityValues = sensorDecoder.decodeConductivity(sensorData);\n                kiwriousReader.setResistance(Long.parseLong(conductivityValues[0]));\n                kiwriousReader.setConductivity(Float.parseFloat(conductivityValues[1]));\n                break;\n            case SENSOR_HEART_RATE:\n                String heartRateValue = sensorDecoder.decodeHeartRate(sensorData);\n                kiwriousReader.setHeartRate(Integer.parseInt(heartRateValue));\n                break;\n            case SENSOR_HUMIDITY:\n                Float[] humidityValues = sensorDecoder.decodeHumidity(sensorData);\n                kiwriousReader.setTemperature(humidityValues[0]);\n                kiwriousReader.setHumidity(humidityValues[1]);\n                break;\n            case SENSOR_SOUND:\n                break;\n            case SENSOR_TEMPERATURE:\n                String[] temperatureValues = sensorDecoder.decodeTemperature(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperatureValues[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperatureValues[1]));\n                break;\n            case SENSOR_TEMPERATURE2:\n                String[] temperature2Values = sensorDecoder.decodeTemperature2(sensorData);\n                kiwriousReader.setAmbientTemperature(Integer.parseInt(temperature2Values[0]));\n                kiwriousReader.setInfraredTemperature(Integer.parseInt(temperature2Values[1]));\n                break;\n            case SENSOR_UV:\n                String[] lightValues = sensorDecoder.decodeUV(sensorData);\n                kiwriousReader.setLux(Long.parseLong(lightValues[0]));\n                kiwriousReader.setUv(Float.parseFloat(lightValues[1]));\n                break;\n            case SENSOR_VOC:\n                String[] vocValues = sensorDecoder.decodeVOC(sensorData);\n                kiwriousReader.setVoc(Integer.parseInt(vocValues[0]));\n                kiwriousReader.setCo2(Integer.parseInt(vocValues[1]));\n                break;\n            default:\n                Log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensorData[KIWRIOUS_SENSOR_TYPE]);\n                break;\n        }\n    }","cleancode":"private void decode(byte[] sensordata) { kiwriousreader.setrawvalues(sensordata); switch (sensordata[kiwrious_sensor_type]) { case sensor_colour: string[] colorvalues = sensordecoder.decodecolor(sensordata); kiwriousreader.setr(integer.parseint(colorvalues[0])); kiwriousreader.setg(integer.parseint(colorvalues[1])); kiwriousreader.setb(integer.parseint(colorvalues[2])); break; case sensor_conductivity: string[] conductivityvalues = sensordecoder.decodeconductivity(sensordata); kiwriousreader.setresistance(long.parselong(conductivityvalues[0])); kiwriousreader.setconductivity(float.parsefloat(conductivityvalues[1])); break; case sensor_heart_rate: string heartratevalue = sensordecoder.decodeheartrate(sensordata); kiwriousreader.setheartrate(integer.parseint(heartratevalue)); break; case sensor_humidity: float[] humidityvalues = sensordecoder.decodehumidity(sensordata); kiwriousreader.settemperature(humidityvalues[0]); kiwriousreader.sethumidity(humidityvalues[1]); break; case sensor_sound: break; case sensor_temperature: string[] temperaturevalues = sensordecoder.decodetemperature(sensordata); kiwriousreader.setambienttemperature(integer.parseint(temperaturevalues[0])); kiwriousreader.setinfraredtemperature(integer.parseint(temperaturevalues[1])); break; case sensor_temperature2: string[] temperature2values = sensordecoder.decodetemperature2(sensordata); kiwriousreader.setambienttemperature(integer.parseint(temperature2values[0])); kiwriousreader.setinfraredtemperature(integer.parseint(temperature2values[1])); break; case sensor_uv: string[] lightvalues = sensordecoder.decodeuv(sensordata); kiwriousreader.setlux(long.parselong(lightvalues[0])); kiwriousreader.setuv(float.parsefloat(lightvalues[1])); break; case sensor_voc: string[] vocvalues = sensordecoder.decodevoc(sensordata); kiwriousreader.setvoc(integer.parseint(vocvalues[0])); kiwriousreader.setco2(integer.parseint(vocvalues[1])); break; default: log.e(\"kiwrious-plugin\", \"unexpected sensor type \"+sensordata[kiwrious_sensor_type]); break; } }","repo":"augmented-human-lab\/kiwrious-android-library","label":[0,1,0,0]}
{"id":23039,"original_code":"@GetMapping(\"\/sign-in\")\n    Mono<JwtToken> signIn(@RequestParam(\"login\") String login,\/\/FIXME use Auth header with basic auth\n                          @RequestParam(\"password\") String password) {\n        return userRepository.findByEmailOrMobile(login, login)\n                .filter(u -> u.validatePassword(password))\n                .map(this::createToken)\n                .map(Mono::just)\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n    }","code_wo_comment":"@GetMapping(\"\/sign-in\")\n    Mono<JwtToken> signIn(@RequestParam(\"login\") String login\n                          @RequestParam(\"password\") String password) {\n        return userRepository.findByEmailOrMobile(login, login)\n                .filter(u -> u.validatePassword(password))\n                .map(this::createToken)\n                .map(Mono::just)\n                .orElseThrow(() -> new IllegalArgumentException(\"Invalid login or password\"));\n    }","cleancode":"@getmapping(\"\/sign-in\") mono<jwttoken> signin(@requestparam(\"login\") string login @requestparam(\"password\") string password) { return userrepository.findbyemailormobile(login, login) .filter(u -> u.validatepassword(password)) .map(this::createtoken) .map(mono::just) .orelsethrow(() -> new illegalargumentexception(\"invalid login or password\")); }","repo":"batiaev\/provisioner","label":[0,0,1,0]}
{"id":23061,"original_code":"@Override\n\t\tvoid testBaseLib() {}","code_wo_comment":"@Override\n\t\tvoid testBaseLib() {}","cleancode":"@override void testbaselib() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":23062,"original_code":"@Override\n\t\tvoid testCoroutineLib() {}","code_wo_comment":"@Override\n\t\tvoid testCoroutineLib() {}","cleancode":"@override void testcoroutinelib() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":23063,"original_code":"@Override\n\t\tvoid testIoLib() {}","code_wo_comment":"@Override\n\t\tvoid testIoLib() {}","cleancode":"@override void testiolib() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":23064,"original_code":"@Override\n\t\tvoid testMetatags() {}","code_wo_comment":"@Override\n\t\tvoid testMetatags() {}","cleancode":"@override void testmetatags() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":23065,"original_code":"@Override\n\t\tvoid testOsLib() {}","code_wo_comment":"@Override\n\t\tvoid testOsLib() {}","cleancode":"@override void testoslib() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":23066,"original_code":"@Override\n\t\tvoid testStringLib() {}","code_wo_comment":"@Override\n\t\tvoid testStringLib() {}","cleancode":"@override void teststringlib() {}","repo":"baodingfengyun\/luaj","label":[0,0,0,1]}
{"id":14968,"original_code":"@Override\n\tpublic String explainIncompleteness() {\n\t\tString result = null;\n\t\tif (isValueDomain()) {\n\t\t\t\/\/This concept name is value so do special processing\n\t\t\tresult = explainIfNotAllTokensProcessed(\"\");\n\t\t\tif (this.instanceName == null) {\n\t\t\t\tresult = appendReason(result, \"No instance name was identified\");\n\t\t\t} else {\n\t\t\t\t\/\/TODO: Eventually remove this test\n\t\t\t\tif (this.instanceName.equals(TOKEN_NAMED)) {\n\t\t\t\t\tresult = appendReason(result, \"Instance name of 'named' was detected\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/Do normal processing\n\t\t\tresult = super.explainIncompleteness();\n\t\t}\n\t\treturn result;\n\t}","code_wo_comment":"@Override\n\tpublic String explainIncompleteness() {\n\t\tString result = null;\n\t\tif (isValueDomain()) {\n\t\t\n\t\t\tresult = explainIfNotAllTokensProcessed(\"\");\n\t\t\tif (this.instanceName == null) {\n\t\t\t\tresult = appendReason(result, \"No instance name was identified\");\n\t\t\t} else {\n\t\t\t\n\t\t\t\tif (this.instanceName.equals(TOKEN_NAMED)) {\n\t\t\t\t\tresult = appendReason(result, \"Instance name of 'named' was detected\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\n\t\t\tresult = super.explainIncompleteness();\n\t\t}\n\t\treturn result;\n\t}","cleancode":"@override public string explainincompleteness() { string result = null; if (isvaluedomain()) { result = explainifnotalltokensprocessed(\"\"); if (this.instancename == null) { result = appendreason(result, \"no instance name was identified\"); } else { if (this.instancename.equals(token_named)) { result = appendreason(result, \"instance name of 'named' was detected\"); } } } else { result = super.explainincompleteness(); } return result; }","repo":"ce-store\/ce-store","label":[1,0,0,0]}
{"id":31429,"original_code":"@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\/\/ Bounds\n\t\t\t\t\t\tif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getX()+hs < colorPane.getX() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\n\t\t\t\t\t\tif ( colorPick.getY()+hs < colorPane.getY()+1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\n\t\t\t\t\t\tVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\n\t\t\t\t\t\tint index = (offset.y*(int)colorPane.getWidth())+offset.x;\n\t\t\t\t\t\tint rgb = colorPane.colors[index];\n\t\t\t\t\t\t\/\/ Swap blue\/red channel? Why do I need to do this?\n\t\t\t\t\t\tColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\t\t\t\t\t\t\/\/ Update the temp color\n\t\t\t\t\t\tcolorS.setBackgroundLegacy(c);\n\t\t\t\t\t\tr.setText(\"\"+c.getRed());\n\t\t\t\t\t\tg.setText(\"\"+c.getGreen());\n\t\t\t\t\t\tb.setText(\"\"+c.getBlue());\n\t\t\t\t\t\tcolorPick.setBackgroundLegacy(c);\n\t\t\t\t\t\ttempColor(c);\n\t\t\t\t\t}","code_wo_comment":"@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\t\tif ( colorPick.getX()+hs > colorPane.getX()+colorPane.getWidth()-1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()+colorPane.getWidth()-hs-1, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getX()+hs < colorPane.getX() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPane.getX()-hs, colorPick.getY());\n\t\t\t\t\t\tif ( colorPick.getY()+hs > colorPane.getY()+colorPane.getHeight() )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()+colorPane.getHeight()-hs);\n\t\t\t\t\t\tif ( colorPick.getY()+hs < colorPane.getY()+1 )\n\t\t\t\t\t\t\tcolorPick.setAbsolutePosition(colorPick.getX(), colorPane.getY()-hs+1);\n\t\t\t\t\t\tVector2i offset = new Vector2i( (int)(colorPick.getX()+hs-colorPane.getX()), (int)colorPane.getHeight()-(int)(colorPick.getY()+hs-colorPane.getY()) );\n\t\t\t\t\t\tint index = (offset.y*(int)colorPane.getWidth())+offset.x;\n\t\t\t\t\t\tint rgb = colorPane.colors[index];\n\t\t\t\t\t\n\t\t\t\t\t\tColor c = new Color((rgb >> 0) & 0xFF, (rgb >> 8) & 0xFF, (rgb >> 16) & 0xFF, 255);\n\t\t\t\t\t\n\t\t\t\t\t\tcolorS.setBackgroundLegacy(c);\n\t\t\t\t\t\tr.setText(\"\"+c.getRed());\n\t\t\t\t\t\tg.setText(\"\"+c.getGreen());\n\t\t\t\t\t\tb.setText(\"\"+c.getBlue());\n\t\t\t\t\t\tcolorPick.setBackgroundLegacy(c);\n\t\t\t\t\t\ttempColor(c);\n\t\t\t\t\t}","cleancode":"@override public void run() { if ( colorpick.getx()+hs > colorpane.getx()+colorpane.getwidth()-1 ) colorpick.setabsoluteposition(colorpane.getx()+colorpane.getwidth()-hs-1, colorpick.gety()); if ( colorpick.getx()+hs < colorpane.getx() ) colorpick.setabsoluteposition(colorpane.getx()-hs, colorpick.gety()); if ( colorpick.gety()+hs > colorpane.gety()+colorpane.getheight() ) colorpick.setabsoluteposition(colorpick.getx(), colorpane.gety()+colorpane.getheight()-hs); if ( colorpick.gety()+hs < colorpane.gety()+1 ) colorpick.setabsoluteposition(colorpick.getx(), colorpane.gety()-hs+1); vector2i offset = new vector2i( (int)(colorpick.getx()+hs-colorpane.getx()), (int)colorpane.getheight()-(int)(colorpick.gety()+hs-colorpane.gety()) ); int index = (offset.y*(int)colorpane.getwidth())+offset.x; int rgb = colorpane.colors[index]; color c = new color((rgb >> 0) & 0xff, (rgb >> 8) & 0xff, (rgb >> 16) & 0xff, 255); colors.setbackgroundlegacy(c); r.settext(\"\"+c.getred()); g.settext(\"\"+c.getgreen()); b.settext(\"\"+c.getblue()); colorpick.setbackgroundlegacy(c); tempcolor(c); }","repo":"bumfo\/LWJGUI","label":[1,0,0,0]}
{"id":31545,"original_code":"@Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        IdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\n        return getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n    }","code_wo_comment":"@Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        IdConstruct idConstruct = (IdConstruct) getAvailablePrincipal(principals);\n        return getIOTAccount(idConstruct.getPartition(), idConstruct.getUsername());\n    }","cleancode":"@override protected authorizationinfo dogetauthorizationinfo(principalcollection principals) { idconstruct idconstruct = (idconstruct) getavailableprincipal(principals); return getiotaccount(idconstruct.getpartition(), idconstruct.getusername()); }","repo":"caricah\/mq.tracah","label":[0,0,0,0]}
{"id":15338,"original_code":"public static boolean yesNo(String yesNoQuestion){\n\t\tint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n        \/\/ 0=yes, 1=no, 2=cancel\n\t\treturn input==0;\n\t\t\/\/TODO remove the Cancel button. Should only be Yes and No.\n\t}","code_wo_comment":"public static boolean yesNo(String yesNoQuestion){\n\t\tint input = JOptionPane.showConfirmDialog(null, yesNoQuestion);\n       \n\t\treturn input==0;\n\t\n\t}","cleancode":"public static boolean yesno(string yesnoquestion){ int input = joptionpane.showconfirmdialog(null, yesnoquestion); return input==0; }","repo":"benrayfield\/occamsworkspace","label":[1,0,0,0]}
{"id":15390,"original_code":"private void findActionVerbsAndArguments(TreeGraphNode node, \n\t\t\tMap<Pair<Integer, Integer>, String> edge_rels,\n\t\t\tMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\n\t\t\tMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\n\t\t\tString root_type,\n\t\t\tList<Tree> leaves,\n\t\t\tList<String> lemmas, List<Label> tags, List<HasWord> words,\n\t\t\tString recipe_name, int sentence_idx, int curr_sentence_char_offset, \n\t\t\tString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\n\t\tString node_string = node.nodeString();\n\t\tint index = node.index();\n\t\tLabel tag = tags.get(index - 1);\n\t\tint hw_character_offset = charOffset(leaves.get(index - 1));\n\t\t\/\/ Find the no-space character offset of the predicate\n\t\tint no_space_character_offset = hw_character_offset;\n\t\tString sentence_prefix = sentence_string.substring(0, hw_character_offset);\n\t\twhile (sentence_prefix.contains(\" I would \")) {\n\t\t\tno_space_character_offset -= 9;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\"I would \")) {\n\t\t\tno_space_character_offset -= 8;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\" \")) {\n\t\t\tno_space_character_offset--;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n\t\t}\n\t\tif (tag.value().startsWith(\"V\")) {\n\t\t\tSet<TreeGraphNode> deps = node_to_deps.get(node);\n\t\t\tif (deps == null) {\n\t\t\t\tSystem.out.println(node + \" \" + deps);\n\t\t\t\t\/\/ Create RecipeEvent\n\t\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\t\tpredicate_idx_to_event.put(hw_character_offset, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ check for pcomp\n\t\t\tboolean has_pcomp = false;\n\t\t\tTreeGraphNode pcomp = null;\n\t\t\tfor (TreeGraphNode dep3 : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\n\t\t\t\tif (rel_string2.equals(\"pcomp\")) {\n\t\t\t\t\thas_pcomp = true;\n\t\t\t\t\tpcomp = dep3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_pcomp) {\n\t\t\t\tSystem.out.println(\"has pcomp\");\n\t\t\t\tTreeGraphNode grandgov = dep_to_gov.get(node);\n\t\t\t\tif (grandgov != null) {\n\t\t\t\t\tint grandgov_index = grandgov.index();\n\t\t\t\t\tRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\n\t\t\t\t\tif (grandevent != null) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tgrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ Create RecipeEvent\n\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\tboolean has_subj = false;\n\t\t\tTreeGraphNode subj = null;\n\t\t\tfor (TreeGraphNode dep : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\n\t\t\t\tif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\n\t\t\t\t\thas_subj = true;\n\t\t\t\t\tsubj = dep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ If the verb has a subject other than \"I\", assume parse error and add the subject as an argument.\n\t\t\tif (has_subj && !root_type.equals(\"SINV\")) {\n\t\t\t\tSystem.out.println(has_subj + \" \" + root_type);\n\t\t\t\tif (!subj.nodeString().equals(\"I\")) {\n\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\t\t\tif (verbs.size() == 1) {\n\t\t\t\t\t\tTreeGraphNode verb = verbs.iterator().next();\n\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\tRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\n\t\t\t\t\t\tif (dep_event != null) {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(node.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tags.get(index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tdep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdep_event.addOtherArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\/\/ TODO(chloe): do something else in this case?\n\t\t\t\t\t\tfor (TreeGraphNode verb : verbs) {\n\t\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Search through the dependents of the verb and add each expanded dependent as an argument.\n\t\t\tSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\n\t\t\tTreeGraphNode pobj = null;\n\t\t\twhile (new_deps.size() != 0) {\n\t\t\t\tList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\n\t\t\t\tnew_deps.clear();\n\t\t\t\tfor (TreeGraphNode dep : deps_list) {\n\t\t\t\t\tTreeGraphNode gov = dep_to_gov.get(dep);\n\t\t\t\t\tif (gov == null) {\n\t\t\t\t\t\tgov = node;\n\t\t\t\t\t}\n\t\t\t\t\tint gov_index = index;\n\t\t\t\t\tint gov_hw_offset = hw_character_offset;\n\t\t\t\t\tString gov_string = node_string;\n\t\t\t\t\tif (gov != null) {\n\t\t\t\t\t\tgov_index = gov.index();\n\t\t\t\t\t\tgov_hw_offset = charOffset(leaves.get(gov_index - 1));\n\t\t\t\t\t\tgov_string = gov.nodeString();\n\t\t\t\t\t}\n\t\t\t\t\tint dep_index = dep.index();\n\t\t\t\t\tint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\n\t\t\t\t\tString dep_string = dep.nodeString();\n\t\t\t\t\tif (dep.nodeString().equals(\"would\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\n\t\t\t\t\tif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\t\t\t\t\t\t\/\/ skip subjects\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (rel_string.startsWith(\"pobj\")) {\n\t\t\t\t\t\t\/\/ Store the prepositional object, but ignore for now. We will deal with it when the\n\t\t\t\t\t\t\/\/ prepositional phrase is found.\n\t\t\t\t\t\tpobj = dep;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ For vmod and xcomp edges, create an argument for the current verb\n\t\t\t\t\tif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ Deal with prepositional phrases and determining whether or not a dependent verb is a new verb or\n\t\t\t\t\t\/\/ part of the current verb. Uses heuristics to find out.\n\t\t\t\t\tboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\n\t\t\t\t\tLabel dep_tag = tags.get(dep_index - 1);\n\t\t\t\t\tif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\tif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tString conj_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\tnode_string += \" \" + conj_string + \" \" + dep_string;\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n\t\t\t\t\t\t} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\thas_subj = false;\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\t\t\thas_subj = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (has_subj) {\n\t\t\t\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {  \/\/ prepositional phrase\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_prep) {\n\t\t\t\t\t\t\tString pobj_arg_string = null;\n\t\t\t\t\t\t\tif (pobj != null) {\n\t\t\t\t\t\t\t\targs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode dep2 : deps_list) {\n\t\t\t\t\t\t\t\t\tTreeGraphNode gov2 = dep_to_gov.get(dep2);\n\t\t\t\t\t\t\t\t\tif (gov2 == null) {\n\t\t\t\t\t\t\t\t\t\tgov2 = gov;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"pobj\")) {\n\t\t\t\t\t\t\t\t\t\targs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\/\/ Find the true preposition from the collapsed dependency relation\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tif (underscore != -1) {\n\t\t\t\t\t\t\t\tString prep_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\t\tprep_string = prep_string.replace('_', ' ');\n\t\t\t\t\t\t\t\tif (pobj_arg_string != null) {\n\t\t\t\t\t\t\t\t\tif (prep_string.contains(arg_string)) {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\/\/\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"DIRECTOBJECT \" + arg_string);\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\n\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"prep\");\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(event);\n\t\t\tpredicate_idx_to_event.put(index, event);\n\t\t} else {\n\t\t\t\/\/ This method should not be called if the node is not a verb.\n\t\t\t\/\/\n\t\t\t\/\/ Not sure if this happens, so I will currently have it crash so I can investigate it.\n\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\tString arg_string = args.getFirst();\n\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\tSystem.out.println(arg_string);\n\t\t\tSystem.out.println(\"getting args error\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","code_wo_comment":"private void findActionVerbsAndArguments(TreeGraphNode node, \n\t\t\tMap<Pair<Integer, Integer>, String> edge_rels,\n\t\t\tMap<TreeGraphNode, Set<TreeGraphNode>> node_to_deps,\n\t\t\tMap<TreeGraphNode, TreeGraphNode> dep_to_gov,\n\t\t\tString root_type,\n\t\t\tList<Tree> leaves,\n\t\t\tList<String> lemmas, List<Label> tags, List<HasWord> words,\n\t\t\tString recipe_name, int sentence_idx, int curr_sentence_char_offset, \n\t\t\tString sentence_string, TreeMap<Integer, RecipeEvent> predicate_idx_to_event) {\n\t\tString node_string = node.nodeString();\n\t\tint index = node.index();\n\t\tLabel tag = tags.get(index - 1);\n\t\tint hw_character_offset = charOffset(leaves.get(index - 1));\n\t\n\t\tint no_space_character_offset = hw_character_offset;\n\t\tString sentence_prefix = sentence_string.substring(0, hw_character_offset);\n\t\twhile (sentence_prefix.contains(\" I would \")) {\n\t\t\tno_space_character_offset -= 9;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\"I would \")) {\n\t\t\tno_space_character_offset -= 8;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\"I would \", \"\");\n\t\t}\n\t\twhile (sentence_prefix.contains(\" \")) {\n\t\t\tno_space_character_offset--;\n\t\t\tsentence_prefix = sentence_prefix.replaceFirst(\" \", \"\");\n\t\t}\n\t\tif (tag.value().startsWith(\"V\")) {\n\t\t\tSet<TreeGraphNode> deps = node_to_deps.get(node);\n\t\t\tif (deps == null) {\n\t\t\t\tSystem.out.println(node + \" \" + deps);\n\t\t\t\n\t\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\t\tpredicate_idx_to_event.put(hw_character_offset, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tboolean has_pcomp = false;\n\t\t\tTreeGraphNode pcomp = null;\n\t\t\tfor (TreeGraphNode dep3 : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep3)));\n\t\t\t\tif (rel_string2.equals(\"pcomp\")) {\n\t\t\t\t\thas_pcomp = true;\n\t\t\t\t\tpcomp = dep3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (has_pcomp) {\n\t\t\t\tSystem.out.println(\"has pcomp\");\n\t\t\t\tTreeGraphNode grandgov = dep_to_gov.get(node);\n\t\t\t\tif (grandgov != null) {\n\t\t\t\t\tint grandgov_index = grandgov.index();\n\t\t\t\t\tRecipeEvent grandevent = predicate_idx_to_event.get(grandgov_index);\n\t\t\t\t\tif (grandevent != null) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tgrandevent.addPrepositionalArgument(hw_character_offset, args.getFirst(), pcomp.nodeString());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\n\t\t\tRecipeEvent event = new RecipeEvent(node_string.toLowerCase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset);\n\t\t\tboolean has_subj = false;\n\t\t\tTreeGraphNode subj = null;\n\t\t\tfor (TreeGraphNode dep : deps) {\n\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(hw_character_offset, charOffset(dep)));\n\t\t\t\tif (rel_string2.equals(\"nsubj\") && !root_type.equals(\"SINV\")) {\n\t\t\t\t\thas_subj = true;\n\t\t\t\t\tsubj = dep;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (has_subj && !root_type.equals(\"SINV\")) {\n\t\t\t\tSystem.out.println(has_subj + \" \" + root_type);\n\t\t\t\tif (!subj.nodeString().equals(\"I\")) {\n\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\t\t\tif (verbs.size() == 1) {\n\t\t\t\t\t\tTreeGraphNode verb = verbs.iterator().next();\n\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\tRecipeEvent dep_event = predicate_idx_to_event.get(charOffset(leaves.get(verb.index() - 1)));\n\t\t\t\t\t\tif (dep_event != null) {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(node.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tags.get(index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tdep_event.addPrepositionalArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdep_event.addOtherArgument(hw_character_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\tfor (TreeGraphNode verb : verbs) {\n\t\t\t\t\t\t\tdep_to_gov.put(verb, node);\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tSet<TreeGraphNode> new_deps = new HashSet<TreeGraphNode>(deps);\n\t\t\tTreeGraphNode pobj = null;\n\t\t\twhile (new_deps.size() != 0) {\n\t\t\t\tList<TreeGraphNode> deps_list = new ArrayList<TreeGraphNode>(new_deps);\n\t\t\t\tnew_deps.clear();\n\t\t\t\tfor (TreeGraphNode dep : deps_list) {\n\t\t\t\t\tTreeGraphNode gov = dep_to_gov.get(dep);\n\t\t\t\t\tif (gov == null) {\n\t\t\t\t\t\tgov = node;\n\t\t\t\t\t}\n\t\t\t\t\tint gov_index = index;\n\t\t\t\t\tint gov_hw_offset = hw_character_offset;\n\t\t\t\t\tString gov_string = node_string;\n\t\t\t\t\tif (gov != null) {\n\t\t\t\t\t\tgov_index = gov.index();\n\t\t\t\t\t\tgov_hw_offset = charOffset(leaves.get(gov_index - 1));\n\t\t\t\t\t\tgov_string = gov.nodeString();\n\t\t\t\t\t}\n\t\t\t\t\tint dep_index = dep.index();\n\t\t\t\t\tint dep_hw_offset = charOffset(leaves.get(dep_index - 1));\n\t\t\t\t\tString dep_string = dep.nodeString();\n\t\t\t\t\tif (dep.nodeString().equals(\"would\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tString rel_string = edge_rels.get(new Pair<Integer, Integer>(gov_hw_offset, dep_hw_offset));\n\t\t\t\t\tif (rel_string.startsWith(\"nsubj\") && !root_type.equals(\"SINV\") && (gov == node || dep.nodeString().equals(\"I\"))) {\n\t\t\t\t\t\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (rel_string.startsWith(\"pobj\")) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tpobj = dep;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) {\n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tboolean is_prep = rel_string.startsWith(\"prep\") || tags.get(dep_index - 1).value().equals(\"IN\");\n\t\t\t\t\tLabel dep_tag = tags.get(dep_index - 1);\n\t\t\t\t\tif (dep_tag.value().startsWith(\"V\") && !is_prep && !rel_string.equals(\"advcl\")\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\tif (dep_index == index + 2 && rel_string.startsWith(\"conj\")) {\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tString conj_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\tnode_string += \" \" + conj_string + \" \" + dep_string;\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), conj_string, (dep.index() > gov_index));\n\t\t\t\t\t\t} else if (rel_string.startsWith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\thas_subj = false;\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(dep_hw_offset, charOffset(leaves.get(depdep.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"nsubj\")) {\n\t\t\t\t\t\t\t\t\t\thas_subj = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (has_subj) {\n\t\t\t\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, true);\n\t\t\t\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSet<TreeGraphNode> depdeps = node_to_deps.get(dep);\n\t\t\t\t\t\t\tif (depdeps != null) {\n\t\t\t\t\t\t\t\tnew_deps.addAll(depdeps);\n\t\t\t\t\t\t\t\tfor (TreeGraphNode depdep : depdeps) {\n\t\t\t\t\t\t\t\t\tdep_to_gov.put(depdep, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addVerbToPredicate(dep.nodeString(), \"\", (dep.index() > gov_index));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { \n\t\t\t\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\"));\n\t\t\t\t\t\tString arg_string = args.getFirst();\n\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_prep) {\n\t\t\t\t\t\t\tString pobj_arg_string = null;\n\t\t\t\t\t\t\tif (pobj != null) {\n\t\t\t\t\t\t\t\targs = getTreeGraphString(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (TreeGraphNode dep2 : deps_list) {\n\t\t\t\t\t\t\t\t\tTreeGraphNode gov2 = dep_to_gov.get(dep2);\n\t\t\t\t\t\t\t\t\tif (gov2 == null) {\n\t\t\t\t\t\t\t\t\t\tgov2 = gov;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tString rel_string2 = edge_rels.get(new Pair<Integer, Integer>(charOffset(leaves.get(gov2.index() - 1)), charOffset(leaves.get(dep2.index() - 1))));\n\t\t\t\t\t\t\t\t\tif (rel_string2.equals(\"pobj\")) {\n\t\t\t\t\t\t\t\t\t\targs = getTreeGraphString(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep);\n\t\t\t\t\t\t\t\t\t\tpobj_arg_string = args.getFirst();\n\t\t\t\t\t\t\t\t\t\tfor (TreeGraphNode verb : args.getSecond()) {\n\t\t\t\t\t\t\t\t\t\t\tfindActionVerbsAndArguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurr_sentence_char_offset, sentence_string, predicate_idx_to_event);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tint underscore = rel_string.indexOf('_');\n\t\t\t\t\t\t\tif (underscore != -1) {\n\t\t\t\t\t\t\t\tString prep_string = rel_string.substring(underscore + 1);\n\t\t\t\t\t\t\t\tprep_string = prep_string.replace('_', ' ');\n\t\t\t\t\t\t\t\tif (pobj_arg_string != null) {\n\t\t\t\t\t\t\t\t\tif (prep_string.contains(arg_string)) {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\targ_string = prep_string + \" \" + arg_string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t} else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tSystem.out.println(\"DIRECTOBJECT \" + arg_string);\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) {\n\t\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string, \"for\");\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tevent.setDirectObject(arg_string);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tString[] split = arg_string.split(\" \");\n\t\t\t\t\t\t\tint found = -1;\n\t\t\t\t\t\t\tfor (int i = 0; i < split.length; i++) {\n\t\t\t\t\t\t\t\tif (split[i].equals(dep.nodeString())) {\n\t\t\t\t\t\t\t\t\tfound = i;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found != -1) {\n\t\t\t\t\t\t\t\tif (tags.get(dep_index - found - 1).value().equals(\"IN\")) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"prep\");\n\t\t\t\t\t\t\t\t\tevent.addPrepositionalArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tevent.addOtherArgument(dep_hw_offset, arg_string);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(event);\n\t\t\tpredicate_idx_to_event.put(index, event);\n\t\t} else {\n\t\t\n\t\t\n\t\t\n\t\t\tPair<String, Set<TreeGraphNode>> args = getTreeGraphString(node, node_to_deps, edge_rels, lemmas, tags, words, false);\n\t\t\tString arg_string = args.getFirst();\n\t\t\tSet<TreeGraphNode> verbs = args.getSecond();\n\t\t\tSystem.out.println(arg_string);\n\t\t\tSystem.out.println(\"getting args error\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","cleancode":"private void findactionverbsandarguments(treegraphnode node, map<pair<integer, integer>, string> edge_rels, map<treegraphnode, set<treegraphnode>> node_to_deps, map<treegraphnode, treegraphnode> dep_to_gov, string root_type, list<tree> leaves, list<string> lemmas, list<label> tags, list<hasword> words, string recipe_name, int sentence_idx, int curr_sentence_char_offset, string sentence_string, treemap<integer, recipeevent> predicate_idx_to_event) { string node_string = node.nodestring(); int index = node.index(); label tag = tags.get(index - 1); int hw_character_offset = charoffset(leaves.get(index - 1)); int no_space_character_offset = hw_character_offset; string sentence_prefix = sentence_string.substring(0, hw_character_offset); while (sentence_prefix.contains(\" i would \")) { no_space_character_offset -= 9; sentence_prefix = sentence_prefix.replacefirst(\" i would \", \"\"); } while (sentence_prefix.contains(\"i would \")) { no_space_character_offset -= 8; sentence_prefix = sentence_prefix.replacefirst(\"i would \", \"\"); } while (sentence_prefix.contains(\" \")) { no_space_character_offset--; sentence_prefix = sentence_prefix.replacefirst(\" \", \"\"); } if (tag.value().startswith(\"v\")) { set<treegraphnode> deps = node_to_deps.get(node); if (deps == null) { system.out.println(node + \" \" + deps); recipeevent event = new recipeevent(node_string.tolowercase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset); predicate_idx_to_event.put(hw_character_offset, event); return; } boolean has_pcomp = false; treegraphnode pcomp = null; for (treegraphnode dep3 : deps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(hw_character_offset, charoffset(dep3))); if (rel_string2.equals(\"pcomp\")) { has_pcomp = true; pcomp = dep3; break; } } if (has_pcomp) { system.out.println(\"has pcomp\"); treegraphnode grandgov = dep_to_gov.get(node); if (grandgov != null) { int grandgov_index = grandgov.index(); recipeevent grandevent = predicate_idx_to_event.get(grandgov_index); if (grandevent != null) { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, true); grandevent.addprepositionalargument(hw_character_offset, args.getfirst(), pcomp.nodestring()); } } return; } recipeevent event = new recipeevent(node_string.tolowercase(), recipe_name, sentence_idx, curr_sentence_char_offset + no_space_character_offset); boolean has_subj = false; treegraphnode subj = null; for (treegraphnode dep : deps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(hw_character_offset, charoffset(dep))); if (rel_string2.equals(\"nsubj\") && !root_type.equals(\"sinv\")) { has_subj = true; subj = dep; break; } } if (has_subj && !root_type.equals(\"sinv\")) { system.out.println(has_subj + \" \" + root_type); if (!subj.nodestring().equals(\"i\")) { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, false); string arg_string = args.getfirst(); set<treegraphnode> verbs = args.getsecond(); if (verbs.size() == 1) { treegraphnode verb = verbs.iterator().next(); dep_to_gov.put(verb, node); findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); recipeevent dep_event = predicate_idx_to_event.get(charoffset(leaves.get(verb.index() - 1))); if (dep_event != null) { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(node.nodestring())) { found = i; break; } } if (tags.get(index - found - 1).value().equals(\"in\")) { dep_event.addprepositionalargument(hw_character_offset, arg_string); } else { dep_event.addotherargument(hw_character_offset, arg_string); } } } else { for (treegraphnode verb : verbs) { dep_to_gov.put(verb, node); findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } return; } } set<treegraphnode> new_deps = new hashset<treegraphnode>(deps); treegraphnode pobj = null; while (new_deps.size() != 0) { list<treegraphnode> deps_list = new arraylist<treegraphnode>(new_deps); new_deps.clear(); for (treegraphnode dep : deps_list) { treegraphnode gov = dep_to_gov.get(dep); if (gov == null) { gov = node; } int gov_index = index; int gov_hw_offset = hw_character_offset; string gov_string = node_string; if (gov != null) { gov_index = gov.index(); gov_hw_offset = charoffset(leaves.get(gov_index - 1)); gov_string = gov.nodestring(); } int dep_index = dep.index(); int dep_hw_offset = charoffset(leaves.get(dep_index - 1)); string dep_string = dep.nodestring(); if (dep.nodestring().equals(\"would\")) { continue; } string rel_string = edge_rels.get(new pair<integer, integer>(gov_hw_offset, dep_hw_offset)); if (rel_string.startswith(\"nsubj\") && !root_type.equals(\"sinv\") && (gov == node || dep.nodestring().equals(\"i\"))) { continue; } if (rel_string.startswith(\"pobj\")) { pobj = dep; continue; } if (rel_string.equals(\"vmod\") || rel_string.equals(\"xcomp\")) { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, true); string arg_string = args.getfirst(); string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } continue; } boolean is_prep = rel_string.startswith(\"prep\") || tags.get(dep_index - 1).value().equals(\"in\"); label dep_tag = tags.get(dep_index - 1); if (dep_tag.value().startswith(\"v\") && !is_prep && !rel_string.equals(\"advcl\") ) { if (dep_index == index + 2 && rel_string.startswith(\"conj\")) { int underscore = rel_string.indexof('_'); string conj_string = rel_string.substring(underscore + 1); node_string += \" \" + conj_string + \" \" + dep_string; set<treegraphnode> depdeps = node_to_deps.get(dep); if (depdeps != null) { new_deps.addall(depdeps); for (treegraphnode depdep : depdeps) { dep_to_gov.put(depdep, dep); } } event.addverbtopredicate(dep.nodestring(), conj_string, (dep.index() > gov_index)); } else if (rel_string.startswith(\"conj\") || rel_string.equals(\"parataxis\") || rel_string.equals(\"dep\")) { set<treegraphnode> depdeps = node_to_deps.get(dep); has_subj = false; if (depdeps != null) { for (treegraphnode depdep : depdeps) { string rel_string2 = edge_rels.get(new pair<integer, integer>(dep_hw_offset, charoffset(leaves.get(depdep.index() - 1)))); if (rel_string2.equals(\"nsubj\")) { has_subj = true; break; } } if (has_subj) { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, true); string arg_string = args.getfirst(); string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } } else { findactionverbsandarguments(dep, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } } else { set<treegraphnode> depdeps = node_to_deps.get(dep); if (depdeps != null) { new_deps.addall(depdeps); for (treegraphnode depdep : depdeps) { dep_to_gov.put(depdep, dep); } } event.addverbtopredicate(dep.nodestring(), \"\", (dep.index() > gov_index)); } } else { pair<string, set<treegraphnode>> args = gettreegraphstring(dep, node_to_deps, edge_rels, lemmas, tags, words, is_prep || rel_string.equals(\"dobj\")); string arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } if (is_prep) { string pobj_arg_string = null; if (pobj != null) { args = gettreegraphstring(pobj, node_to_deps, edge_rels, lemmas, tags, words, is_prep); pobj_arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\" , leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } } else { for (treegraphnode dep2 : deps_list) { treegraphnode gov2 = dep_to_gov.get(dep2); if (gov2 == null) { gov2 = gov; } string rel_string2 = edge_rels.get(new pair<integer, integer>(charoffset(leaves.get(gov2.index() - 1)), charoffset(leaves.get(dep2.index() - 1)))); if (rel_string2.equals(\"pobj\")) { args = gettreegraphstring(dep2, node_to_deps, edge_rels, lemmas, tags, words, is_prep); pobj_arg_string = args.getfirst(); for (treegraphnode verb : args.getsecond()) { findactionverbsandarguments(verb, edge_rels, node_to_deps, dep_to_gov, \"\", leaves, lemmas, tags, words, recipe_name, sentence_idx, curr_sentence_char_offset, sentence_string, predicate_idx_to_event); } break; } } } int underscore = rel_string.indexof('_'); if (underscore != -1) { string prep_string = rel_string.substring(underscore + 1); prep_string = prep_string.replace('_', ' '); if (pobj_arg_string != null) { if (prep_string.contains(arg_string)) { arg_string = prep_string + \" \" + pobj_arg_string; } else { arg_string = prep_string + \" \" + arg_string + \" \" + pobj_arg_string; } } else { arg_string = prep_string + \" \" + arg_string; } } event.addprepositionalargument(dep_hw_offset, arg_string); } else if (rel_string.equals(\"dobj\") || rel_string.equals(\"nsubj\")) { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { system.out.println(\"directobject \" + arg_string); if (tags.get(dep_index - found - 1).value().equals(\"in\")) { event.addprepositionalargument(dep_hw_offset, arg_string); } else { if (arg_string.contains(\"minutes\") || arg_string.contains(\"hours\")) { event.addprepositionalargument(dep_hw_offset, arg_string, \"for\"); } else { event.setdirectobject(arg_string); } } } } else { string[] split = arg_string.split(\" \"); int found = -1; for (int i = 0; i < split.length; i++) { if (split[i].equals(dep.nodestring())) { found = i; break; } } if (found != -1) { if (tags.get(dep_index - found - 1).value().equals(\"in\")) { system.out.println(\"prep\"); event.addprepositionalargument(dep_hw_offset, arg_string); } else { event.addotherargument(dep_hw_offset, arg_string); } } } } } } system.out.println(event); predicate_idx_to_event.put(index, event); } else { pair<string, set<treegraphnode>> args = gettreegraphstring(node, node_to_deps, edge_rels, lemmas, tags, words, false); string arg_string = args.getfirst(); set<treegraphnode> verbs = args.getsecond(); system.out.println(arg_string); system.out.println(\"getting args error\"); system.exit(1); } }","repo":"atcbosselut\/recipe-interpretation","label":[1,0,0,0]}
{"id":23710,"original_code":"@Provides\n    @Singleton\n    Retrofit provideCall() {\n        Cache cache = null;\n        try {\n            cache = new Cache(cacheFile, 10 * 1024 * 1024);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        \/* TODO Consider moving elsewhere. *\/\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n                        Request original = chain.request();\n                        HttpUrl originalHttpUrl = original.url();\n                        HttpUrl url = originalHttpUrl.newBuilder()\n                                .addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n                                .build();\n                        Request request = original.newBuilder()\n                                .header(\"Content-Type\", \"application\/json\")\n                                .removeHeader(\"Pragma\")\n                                .header(\"Cache-Control\", String.format(\"max-age=%d\", BuildConfig.CACHETIME))\n                                .url(url)\n                                .build();\n                        okhttp3.Response response = chain.proceed(request);\n                        response.cacheResponse();\n                        return response;\n                    }\n                })\n                .cache(cache)\n                .build();\n        return new Retrofit.Builder()\n                .baseUrl(BuildConfig.API_OPENWEATHERMAP_BASEURL)\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .build();\n    }","code_wo_comment":"@Provides\n    @Singleton\n    Retrofit provideCall() {\n        Cache cache = null;\n        try {\n            cache = new Cache(cacheFile, 10 * 1024 * 1024);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n       \n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .addInterceptor(new Interceptor() {\n                    @Override\n                    public okhttp3.Response intercept(Chain chain) throws IOException {\n                        Request original = chain.request();\n                        HttpUrl originalHttpUrl = original.url();\n                        HttpUrl url = originalHttpUrl.newBuilder()\n                                .addQueryParameter(\"APPID\", BuildConfig.API_OPENWEATHERMAP_KEY)\n                                .build();\n                        Request request = original.newBuilder()\n                                .header(\"Content-Type\", \"application\/json\")\n                                .removeHeader(\"Pragma\")\n                                .header(\"Cache-Control\", String.format(\"max-age=%d\", BuildConfig.CACHETIME))\n                                .url(url)\n                                .build();\n                        okhttp3.Response response = chain.proceed(request);\n                        response.cacheResponse();\n                        return response;\n                    }\n                })\n                .cache(cache)\n                .build();\n        return new Retrofit.Builder()\n                .baseUrl(BuildConfig.API_OPENWEATHERMAP_BASEURL)\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create())\n                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())\n                .build();\n    }","cleancode":"@provides @singleton retrofit providecall() { cache cache = null; try { cache = new cache(cachefile, 10 * 1024 * 1024); } catch (exception e) { e.printstacktrace(); } okhttpclient okhttpclient = new okhttpclient.builder() .addinterceptor(new interceptor() { @override public okhttp3.response intercept(chain chain) throws ioexception { request original = chain.request(); httpurl originalhttpurl = original.url(); httpurl url = originalhttpurl.newbuilder() .addqueryparameter(\"appid\", buildconfig.api_openweathermap_key) .build(); request request = original.newbuilder() .header(\"content-type\", \"application\/json\") .removeheader(\"pragma\") .header(\"cache-control\", string.format(\"max-age=%d\", buildconfig.cachetime)) .url(url) .build(); okhttp3.response response = chain.proceed(request); response.cacheresponse(); return response; } }) .cache(cache) .build(); return new retrofit.builder() .baseurl(buildconfig.api_openweathermap_baseurl) .client(okhttpclient) .addconverterfactory(gsonconverterfactory.create()) .addcalladapterfactory(rxjavacalladapterfactory.create()) .build(); }","repo":"arenaq\/weather-app","label":[0,1,0,0]}
{"id":32099,"original_code":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\n        if (matchPattern == null) {\n            return Collections.emptyList();\n        }\n        Matcher matcher = matchPattern.matcher(clippedText);\n        List<Rectangle> highlightAreas = null;\n        int startFrom = 0;\n        while (startFrom < clippedText.length() && matcher.find(startFrom)) {\n            if (highlightAreas == null) {\n                highlightAreas = new ArrayList<Rectangle>();\n            }\n            int start = matcher.start();\n            int end = matcher.end();\n            if (start == end) {\n                \/\/ empty matcher will cause infinite loop\n                break;\n            }\n            startFrom = end;\n            int highlightx;\n            int highlightWidth;\n            if (start == 0) {\n                \/\/ start highlight from the start of the field\n                highlightx = xOffset;\n            } else {\n                \/\/ Calculate the width of the unhighlighted text to get the\n                \/\/ start of the highlighted region.\n                String strToStart = clippedText.substring(0, start);\n                highlightx = fm.stringWidth(strToStart) + xOffset;\n            }\n            \/\/ Get the width of the highlighted region\n            String highlightText = clippedText.substring(start, end);\n            highlightWidth = fm.stringWidth(highlightText);\n            highlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n        }\/\/ while ( startFrom < text.length() && matcher.find( startFrom ) )\n        if (highlightAreas == null) {\n            highlightAreas = Collections.emptyList();\n        } else {\n            coalesceHighlightAreas(highlightAreas);\n        }\n        return highlightAreas;\n    }","code_wo_comment":"protected List<Rectangle> createHighlightAreas2(String fullText, String clippedText, FontMetrics fm, int xOffset, int yOffset, int height) {\n        if (matchPattern == null) {\n            return Collections.emptyList();\n        }\n        Matcher matcher = matchPattern.matcher(clippedText);\n        List<Rectangle> highlightAreas = null;\n        int startFrom = 0;\n        while (startFrom < clippedText.length() && matcher.find(startFrom)) {\n            if (highlightAreas == null) {\n                highlightAreas = new ArrayList<Rectangle>();\n            }\n            int start = matcher.start();\n            int end = matcher.end();\n            if (start == end) {\n               \n                break;\n            }\n            startFrom = end;\n            int highlightx;\n            int highlightWidth;\n            if (start == 0) {\n               \n                highlightx = xOffset;\n            } else {\n               \n               \n                String strToStart = clippedText.substring(0, start);\n                highlightx = fm.stringWidth(strToStart) + xOffset;\n            }\n           \n            String highlightText = clippedText.substring(start, end);\n            highlightWidth = fm.stringWidth(highlightText);\n            highlightAreas.add(new Rectangle(highlightx, yOffset, highlightWidth, height));\n        \n        if (highlightAreas == null) {\n            highlightAreas = Collections.emptyList();\n        } else {\n            coalesceHighlightAreas(highlightAreas);\n        }\n        return highlightAreas;\n    }","cleancode":"protected list<rectangle> createhighlightareas2(string fulltext, string clippedtext, fontmetrics fm, int xoffset, int yoffset, int height) { if (matchpattern == null) { return collections.emptylist(); } matcher matcher = matchpattern.matcher(clippedtext); list<rectangle> highlightareas = null; int startfrom = 0; while (startfrom < clippedtext.length() && matcher.find(startfrom)) { if (highlightareas == null) { highlightareas = new arraylist<rectangle>(); } int start = matcher.start(); int end = matcher.end(); if (start == end) { break; } startfrom = end; int highlightx; int highlightwidth; if (start == 0) { highlightx = xoffset; } else { string strtostart = clippedtext.substring(0, start); highlightx = fm.stringwidth(strtostart) + xoffset; } string highlighttext = clippedtext.substring(start, end); highlightwidth = fm.stringwidth(highlighttext); highlightareas.add(new rectangle(highlightx, yoffset, highlightwidth, height)); if (highlightareas == null) { highlightareas = collections.emptylist(); } else { coalescehighlightareas(highlightareas); } return highlightareas; }","repo":"aragozin\/stackviewer","label":[1,0,0,0]}
{"id":32113,"original_code":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\n    List<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\n    for(int i = 0; i < node.getNumEntries(); i++) {\n      RdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\n      double minDist = distanceFunction.minDist(entry, q);\n      result.add(new DoubleObjPair<>(minDist, entry));\n    }\n    Collections.sort(result);\n    return result;\n  }","code_wo_comment":"protected List<DoubleObjPair<RdKNNEntry>> getSortedEntries(AbstractRStarTreeNode<?, ?> node, SpatialComparable q, SpatialPrimitiveDistanceFunction<?> distanceFunction) {\n    List<DoubleObjPair<RdKNNEntry>> result = new ArrayList<>();\n    for(int i = 0; i < node.getNumEntries(); i++) {\n      RdKNNEntry entry = (RdKNNEntry) node.getEntry(i);\n      double minDist = distanceFunction.minDist(entry, q);\n      result.add(new DoubleObjPair<>(minDist, entry));\n    }\n    Collections.sort(result);\n    return result;\n  }","cleancode":"protected list<doubleobjpair<rdknnentry>> getsortedentries(abstractrstartreenode<?, ?> node, spatialcomparable q, spatialprimitivedistancefunction<?> distancefunction) { list<doubleobjpair<rdknnentry>> result = new arraylist<>(); for(int i = 0; i < node.getnumentries(); i++) { rdknnentry entry = (rdknnentry) node.getentry(i); double mindist = distancefunction.mindist(entry, q); result.add(new doubleobjpair<>(mindist, entry)); } collections.sort(result); return result; }","repo":"bertl4398\/ssdbm2020","label":[1,0,0,0]}
{"id":23927,"original_code":"public void recordCorpusData (Corpus c, Learner l){\n\t\tif (!isRecording) return;\n\t\tthis.c=c;\n\t\tVocabulary v = c.getVocabulary();\n\t\tSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\n\t\tSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\n\t\tStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\n\t\tcorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\n\t\ts.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\n\t\ts.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\n\t\ts.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\n\t\ts.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\n\t\ts.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\t\t\/\/TODO add proper number formatters\n\t\ts.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\n\t\ts.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\n\t\ts.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\n\t\tfor (Map.Entry<String, Integer> e: entrySet){\n\t\t\tif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){ \/\/TODO see if necessary\n\t\t\t\ts.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n\t\t\t}\n\t\t}\n\t\ts.append(\"},\\n\");\n\t\ts.append(\"\\tidToType: {\");\n\t\tfor (Map.Entry<Integer, Word> e: wordSet){ \/\/No rare word check here, to keep vector status\n\t\t\tif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\t\n\t\t\t}\n\t\t}\n\t\ts.append(\"}\");\n\t\ts.append(\"\\n};\");\n\t\ttry {\n\t\t\tcorpusFile.createNewFile();\n\t\t\tBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\n\t\t\tout.append(s);\n\t\t\tout.close();\n\t\t} catch (IOException e1) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t}\n\t}","code_wo_comment":"public void recordCorpusData (Corpus c, Learner l){\n\t\tif (!isRecording) return;\n\t\tthis.c=c;\n\t\tVocabulary v = c.getVocabulary();\n\t\tSet<Map.Entry<String, Integer>> entrySet = v.getWordIndicesEntrySet();\n\t\tSet<Map.Entry<Integer, Word>> wordSet = v.getWordEntrySet();\n\t\tStringBuilder s = new StringBuilder(v.getNumOfWords()*30);\n\t\tcorpusFile = new File(mainPath, \"corpus_\"+name+\".js\");\n\t\ts.append(String.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name));\n\t\ts.append(String.format(\"\\ttokenCount: %1$s,\\n\", c.tokenCount));\n\t\ts.append(String.format(\"\\ttypeCount: %1$s,\\n\", v.getNumOfWords()));\n\t\ts.append(String.format(\"\\tcommonTypes: %1$s,\\n\", (v.getNumOfWords()-v.countWordsBelowThreshold(l.RARE_WORD_THRESHOLD))));\n\t\ts.append(String.format(\"\\tclusterCount: %1$s,\\n\", l.NUMBER_OF_CLUSTERS));\n\t\n\t\ts.append(String.format(\"\\tidentityEps: %1$s,\\n\", l.IDENTITY_EPSILON));\n\t\ts.append(String.format(\"\\titerationCount: %1$s,\\n\", iterationCounter));\n\t\ts.append(\"\\ttypeToId: \\n\\t{\\n\\t\");\n\t\tfor (Map.Entry<String, Integer> e: entrySet){\n\t\t\tif (v.getWord(e.getValue()).frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getKey(), e.getValue()));\n\t\t\t}\n\t\t}\n\t\ts.append(\"},\\n\");\n\t\ts.append(\"\\tidToType: {\");\n\t\tfor (Map.Entry<Integer, Word> e: wordSet){\n\t\t\tif (e.getValue().frequency >= l.RARE_WORD_THRESHOLD){\n\t\t\t\ts.append(String.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getKey(), e.getValue().name));\t\n\t\t\t}\n\t\t}\n\t\ts.append(\"}\");\n\t\ts.append(\"\\n};\");\n\t\ttry {\n\t\t\tcorpusFile.createNewFile();\n\t\t\tBufferedWriter out = new BufferedWriter(new FileWriter(corpusFile));\n\t\t\tout.append(s);\n\t\t\tout.close();\n\t\t} catch (IOException e1) {\n\t\t\n\t\t\te1.printStackTrace();\n\t\t}\n\t}","cleancode":"public void recordcorpusdata (corpus c, learner l){ if (!isrecording) return; this.c=c; vocabulary v = c.getvocabulary(); set<map.entry<string, integer>> entryset = v.getwordindicesentryset(); set<map.entry<integer, word>> wordset = v.getwordentryset(); stringbuilder s = new stringbuilder(v.getnumofwords()*30); corpusfile = new file(mainpath, \"corpus_\"+name+\".js\"); s.append(string.format(\"corpus_%1$s = \\n{\\n\\tname:\\\"%1$s\\\",\\n\", name)); s.append(string.format(\"\\ttokencount: %1$s,\\n\", c.tokencount)); s.append(string.format(\"\\ttypecount: %1$s,\\n\", v.getnumofwords())); s.append(string.format(\"\\tcommontypes: %1$s,\\n\", (v.getnumofwords()-v.countwordsbelowthreshold(l.rare_word_threshold)))); s.append(string.format(\"\\tclustercount: %1$s,\\n\", l.number_of_clusters)); s.append(string.format(\"\\tidentityeps: %1$s,\\n\", l.identity_epsilon)); s.append(string.format(\"\\titerationcount: %1$s,\\n\", iterationcounter)); s.append(\"\\ttypetoid: \\n\\t{\\n\\t\"); for (map.entry<string, integer> e: entryset){ if (v.getword(e.getvalue()).frequency >= l.rare_word_threshold){ s.append(string.format(\"\\t\\t\\\"%1$s\\\": %2$s,\\n\", e.getkey(), e.getvalue())); } } s.append(\"},\\n\"); s.append(\"\\tidtotype: {\"); for (map.entry<integer, word> e: wordset){ if (e.getvalue().frequency >= l.rare_word_threshold){ s.append(string.format(\"\\t\\t%1$s: \\\"%2$s\\\",\\n\",e.getkey(), e.getvalue().name)); } } s.append(\"}\"); s.append(\"\\n};\"); try { corpusfile.createnewfile(); bufferedwriter out = new bufferedwriter(new filewriter(corpusfile)); out.append(s); out.close(); } catch (ioexception e1) { e1.printstacktrace(); } }","repo":"aureatesting\/Syntactic","label":[1,1,0,0]}
{"id":15912,"original_code":"@Test\n    public void testSpendInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 0;\n        \/\/ spend coins\n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n        \/\/ wait while balance be a 100\n        waitForBalance(100);\n        \/\/ wait while balance isn't update\n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        coinOutput.check(matches(withText(balanceString)));\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        \/\/ submit disabled\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ empty string is valid zero\n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n        \/\/ valid value\n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ @TODO potentially, may break test, as coin can be created\n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n        \/\/ we can send transaction even if coin does not exists, because it can be no a true\n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_get_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n        \/\/ visible \"use max\" for spend tab\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        actionUseMax.perform(click());\n        amountInput.check(matches(withText(\"100\")));\n        Response<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate2.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n    }","code_wo_comment":"@Test\n    public void testSpendInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 0;\n       \n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n       \n        waitForBalance(100);\n       \n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(100.d)));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        coinOutput.check(matches(withText(balanceString)));\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n       \n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n       \n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n       \n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_get_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeSellValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n       \n        String expectEstimate3 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate3, mExchangeCoin.getSymbol()))));\n       \n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        actionUseMax.perform(click());\n        amountInput.check(matches(withText(\"100\")));\n        Response<GateResult<ExchangeSellValue>> estimate2 = estimateRepo.getCoinExchangeCurrencyToSell(MinterSDK.DEFAULT_COIN, new BigDecimal(\"100\"), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate2.body().isOk());\n       \n        String expectEstimate2 = bdHuman(estimate2.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate2, mExchangeCoin.getSymbol()))));\n    }","cleancode":"@test public void testspendinputs() throws throwable { explorercoinsrepository repo = testwallet.app().explorercoinsrepo(); gateestimaterepository estimaterepo = testwallet.app().estimaterepo(); final int tabpos = 0; mactivitytestrule.runonuithread(() -> { mactivitytestrule.getactivity().setcurrentpage(tabpos); }); waitforbalance(100); waitforbalanceupdate(); final string balancestring = string.format(\"%s (%s)\", mintersdk.default_coin, bdhuman(new bigdecimal(100.d))); viewinteraction actionbtn = onview(allof( withid(r.id.action), withtext(\"exchange\"), inviewpager(tabpos, r.id.pager) )); viewinteraction actionusemax = onview(allof( withid(r.id.action_maximum), inviewpager(tabpos, r.id.pager) )); viewinteraction amountinput = onview(allof(withid(r.id.input_amount), inviewpager(tabpos, r.id.pager))); viewinteraction coininput = onview(allof(withid(r.id.input_incoming_coin), inviewpager(tabpos, r.id.pager))); viewinteraction coinoutput = onview(allof(withid(r.id.input_outgoing_coin), inviewpager(tabpos, r.id.pager))); viewinteraction layoutcalculation = onview(allof( withid(r.id.layout_calculation), inviewpager(tabpos, r.id.pager) )); viewinteraction calculationsum = onview(allof(withid(r.id.calculation), inviewpager(tabpos, r.id.pager))); coinoutput.check(matches(withtext(balancestring))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); actionbtn.check(matches(not(isenabled()))); amountinput.check(matches(withinputlayouthint(r.string.label_amount))); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"0\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); final string amount = \"1\"; amountinput.perform(replacetext(amount)); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); coininput.perform(replacetext(\"dosntexist\")); coininput.check(matches(withinputlayouterror(\"coin to buy not exists\"))); actionbtn.check(matches(isenabled())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coininput.perform(scrollto(), replacetext(mexchangecoin.getsymbol())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); onview(allof(withid(r.id.calculation_title), inviewpager(tabpos, r.id.pager))) .check(matches(withtext(r.string.label_you_will_get_approximately))); calculationsum.perform(scrollto()); response<gateresult<exchangesellvalue>> estimate1 = estimaterepo.getcoinexchangecurrencytosell(mintersdk.default_coin, new bigdecimal(amount), mexchangecoin.getsymbol()).execute(); asserttrue(estimate1.body().isok()); string expectestimate3 = bdhuman(estimate1.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate3, mexchangecoin.getsymbol())))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); actionusemax.perform(click()); amountinput.check(matches(withtext(\"100\"))); response<gateresult<exchangesellvalue>> estimate2 = estimaterepo.getcoinexchangecurrencytosell(mintersdk.default_coin, new bigdecimal(\"100\"), mexchangecoin.getsymbol()).execute(); asserttrue(estimate2.body().isok()); string expectestimate2 = bdhuman(estimate2.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate2, mexchangecoin.getsymbol())))); }","repo":"bogdyak\/Android-Bip-Wallet-crypttp","label":[0,0,0,1]}
{"id":15913,"original_code":"@Test\n    public void testGetInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 1;\n        \/\/ spend coins\n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n        \/\/ wait while balance be a 100\n        waitForBalance(100);\n        \/\/ wait while balance isn't update\n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n        \/\/ invisible \"use max\" for spend tab\n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinOutput.check(matches(withText(balanceString)));\n        \/\/ submit disabled\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ empty string is valid zero\n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n        \/\/ valid value\n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        \/\/ @TODO potentially, may break test, as coin can be created\n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n        \/\/ we can send transaction even if coin does not exists, because it can be no a true\n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_pay_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n        \/\/ amount without commission\n        String expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n    }","code_wo_comment":"@Test\n    public void testGetInputs() throws Throwable {\n        ExplorerCoinsRepository repo = TestWallet.app().explorerCoinsRepo();\n        GateEstimateRepository estimateRepo = TestWallet.app().estimateRepo();\n        final int tabPos = 1;\n       \n        mActivityTestRule.runOnUiThread(() -> {\n            mActivityTestRule.getActivity().setCurrentPage(tabPos);\n        });\n       \n        waitForBalance(100);\n       \n        waitForBalanceUpdate();\n        final String balanceString = String.format(\"%s (%s)\", MinterSDK.DEFAULT_COIN, bdHuman(new BigDecimal(\"100\")));\n        ViewInteraction actionBtn = onView(allOf(\n                withId(R.id.action),\n                withText(\"EXCHANGE\"),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction actionUseMax = onView(allOf(\n                withId(R.id.action_maximum),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction amountInput = onView(allOf(withId(R.id.input_amount), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinInput = onView(allOf(withId(R.id.input_incoming_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction coinOutput = onView(allOf(withId(R.id.input_outgoing_coin), inViewPager(tabPos, R.id.pager)));\n        ViewInteraction layoutCalculation = onView(allOf(\n                withId(R.id.layout_calculation),\n                inViewPager(tabPos, R.id.pager)\n        ));\n        ViewInteraction calculationSum = onView(allOf(withId(R.id.calculation), inViewPager(tabPos, R.id.pager)));\n       \n        actionUseMax.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinOutput.check(matches(withText(balanceString)));\n       \n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.check(matches(withInputLayoutHint(R.string.label_amount)));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n        amountInput.perform(replaceText(\"0\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        amountInput.perform(replaceText(\"\"));\n        amountInput.check(matches(withInputLayoutError(\"Amount must be greater than 0\")));\n        actionBtn.check(matches(not(isEnabled())));\n        final String amount = \"1\";\n       \n        amountInput.perform(replaceText(amount));\n        amountInput.check(matches(withInputLayoutError(null)));\n        actionBtn.check(matches(not(isEnabled())));\n       \n        coinInput.perform(replaceText(\"DOSNTEXIST\"));\n        coinInput.check(matches(withInputLayoutError(\"Coin to buy not exists\")));\n       \n        actionBtn.check(matches(isEnabled()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.GONE)));\n        coinInput.perform(scrollTo(), replaceText(mExchangeCoin.getSymbol()));\n        layoutCalculation.check(matches(withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE)));\n        onView(allOf(withId(R.id.calculation_title), inViewPager(tabPos, R.id.pager)))\n                .check(matches(withText(R.string.label_you_will_pay_approximately)));\n        calculationSum.perform(scrollTo());\n        Response<GateResult<ExchangeBuyValue>> estimate1 = estimateRepo.getCoinExchangeCurrencyToBuy(MinterSDK.DEFAULT_COIN, new BigDecimal(amount), mExchangeCoin.getSymbol()).execute();\n        assertTrue(estimate1.body().isOk());\n       \n        String expectEstimate1 = bdHuman(estimate1.body().result.getAmount());\n        calculationSum.check(matches(withText(String.format(\"%s %s\", expectEstimate1, MinterSDK.DEFAULT_COIN))));\n    }","cleancode":"@test public void testgetinputs() throws throwable { explorercoinsrepository repo = testwallet.app().explorercoinsrepo(); gateestimaterepository estimaterepo = testwallet.app().estimaterepo(); final int tabpos = 1; mactivitytestrule.runonuithread(() -> { mactivitytestrule.getactivity().setcurrentpage(tabpos); }); waitforbalance(100); waitforbalanceupdate(); final string balancestring = string.format(\"%s (%s)\", mintersdk.default_coin, bdhuman(new bigdecimal(\"100\"))); viewinteraction actionbtn = onview(allof( withid(r.id.action), withtext(\"exchange\"), inviewpager(tabpos, r.id.pager) )); viewinteraction actionusemax = onview(allof( withid(r.id.action_maximum), inviewpager(tabpos, r.id.pager) )); viewinteraction amountinput = onview(allof(withid(r.id.input_amount), inviewpager(tabpos, r.id.pager))); viewinteraction coininput = onview(allof(withid(r.id.input_incoming_coin), inviewpager(tabpos, r.id.pager))); viewinteraction coinoutput = onview(allof(withid(r.id.input_outgoing_coin), inviewpager(tabpos, r.id.pager))); viewinteraction layoutcalculation = onview(allof( withid(r.id.layout_calculation), inviewpager(tabpos, r.id.pager) )); viewinteraction calculationsum = onview(allof(withid(r.id.calculation), inviewpager(tabpos, r.id.pager))); actionusemax.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coinoutput.check(matches(withtext(balancestring))); actionbtn.check(matches(not(isenabled()))); amountinput.check(matches(withinputlayouthint(r.string.label_amount))); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"0\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); amountinput.perform(replacetext(\"\")); amountinput.check(matches(withinputlayouterror(\"amount must be greater than 0\"))); actionbtn.check(matches(not(isenabled()))); final string amount = \"1\"; amountinput.perform(replacetext(amount)); amountinput.check(matches(withinputlayouterror(null))); actionbtn.check(matches(not(isenabled()))); coininput.perform(replacetext(\"dosntexist\")); coininput.check(matches(withinputlayouterror(\"coin to buy not exists\"))); actionbtn.check(matches(isenabled())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.gone))); coininput.perform(scrollto(), replacetext(mexchangecoin.getsymbol())); layoutcalculation.check(matches(witheffectivevisibility(viewmatchers.visibility.visible))); onview(allof(withid(r.id.calculation_title), inviewpager(tabpos, r.id.pager))) .check(matches(withtext(r.string.label_you_will_pay_approximately))); calculationsum.perform(scrollto()); response<gateresult<exchangebuyvalue>> estimate1 = estimaterepo.getcoinexchangecurrencytobuy(mintersdk.default_coin, new bigdecimal(amount), mexchangecoin.getsymbol()).execute(); asserttrue(estimate1.body().isok()); string expectestimate1 = bdhuman(estimate1.body().result.getamount()); calculationsum.check(matches(withtext(string.format(\"%s %s\", expectestimate1, mintersdk.default_coin)))); }","repo":"bogdyak\/Android-Bip-Wallet-crypttp","label":[0,0,0,1]}
{"id":24399,"original_code":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\n    List<LP2Rule> result = new ArrayList<LP2Rule>();\n    \/\/ TODO make all other tags contextual tags here. for now we take only\n    \/\/ the counterpart\n    \/\/ tag of the current learning process: (opening\/closing tags)\n    LP2RuleItem ctxItem = new LP2RuleItem();\n    MLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\n            slotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\n            aStartRule);\n    ctxItem.setContextConstraint(ctxConstraint);\n    LP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\n    ctxStartRule.setIsContextualRule(true);\n    if (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\n      ctxStartRule.addPostFillerItem(ctxItem);\n    else\n      ctxStartRule.addPreFillerItem(ctxItem);\n    result.add(ctxStartRule);\n    return result;\n  }","code_wo_comment":"protected List<LP2Rule> createContextStartRulesForStartRule(final LP2Rule aStartRule) {\n    List<LP2Rule> result = new ArrayList<LP2Rule>();\n   \n   \n   \n    LP2RuleItem ctxItem = new LP2RuleItem();\n    MLLP2ContextConstraint ctxConstraint = new MLLP2ContextConstraint(\n            slotMaximumTokenCountMap.get(aStartRule.getTarget().getSingleSlotRawTypeName()),\n            aStartRule);\n    ctxItem.setContextConstraint(ctxConstraint);\n    LP2Rule ctxStartRule = new LP2Rule(this, aStartRule.getTarget());\n    ctxStartRule.setIsContextualRule(true);\n    if (aStartRule.getTarget().type == MLTargetType.SINGLE_LEFT_BOUNDARY)\n      ctxStartRule.addPostFillerItem(ctxItem);\n    else\n      ctxStartRule.addPreFillerItem(ctxItem);\n    result.add(ctxStartRule);\n    return result;\n  }","cleancode":"protected list<lp2rule> createcontextstartrulesforstartrule(final lp2rule astartrule) { list<lp2rule> result = new arraylist<lp2rule>(); lp2ruleitem ctxitem = new lp2ruleitem(); mllp2contextconstraint ctxconstraint = new mllp2contextconstraint( slotmaximumtokencountmap.get(astartrule.gettarget().getsingleslotrawtypename()), astartrule); ctxitem.setcontextconstraint(ctxconstraint); lp2rule ctxstartrule = new lp2rule(this, astartrule.gettarget()); ctxstartrule.setiscontextualrule(true); if (astartrule.gettarget().type == mltargettype.single_left_boundary) ctxstartrule.addpostfilleritem(ctxitem); else ctxstartrule.addprefilleritem(ctxitem); result.add(ctxstartrule); return result; }","repo":"apache\/uima-ruta","label":[0,1,0,0]}
{"id":24503,"original_code":"@Override\n    public void runOpMode(){\n        \/\/When the robot begins, it is in initialized state\n        \/\/In this state, initialize the robot sensors and actuators\n        \/\/and wait for the event: driver pushes START\n        \/\/************************************************************\n        \/\/***   INITIALIZE THE ROBOT\n        \/\/************************************************************\n        autonParameters = AutonParameters.DEBUG_TWO_WHEEL;\n        autonParameters.setSpeed(Speed.FAST);\n        autonParameters.getSpeed().setK_i(0.3);\n        robot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\n        targetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\n        launchLine = new LaunchLine();\n        autonState = AutonState.INITIALIZE;\n        stateStopWatch = new StopWatch();\n        \/\/Initialize the wheels\n        robot.initializeStandardDriveWheels(hardwareMap);\n        \/\/Initialize the imu\n        robot.initializeImu(hardwareMap);\n        \/\/Initialize the color sensors\n        robot.initializeColorSensors(hardwareMap);\n        \/\/Initialize the digitalTouch sensors\n        robot.initializeEbotsDigitalTouches(hardwareMap);\n        \/\/Initialize the LED lights\n        robot.initializeRevBlinkinLedDriver(hardwareMap);\n        \/\/Initialize the Rev2mDistance Sensors\n        robot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n        \/\/Prepare the expansion hubs for bulk reads\n        robot.initializeExpansionHubsForBulkRead(hardwareMap);\n        telemetry.addLine(robot.getActualPose().toString());\n        telemetry.addLine(\"Initialization Complete!\");\n        telemetry.update();\n        Pose newPose = robot.getActualPose();\n        newPose.getX();\n        robot.setTargetPose(newPose);\n        waitForStart();\n        telemetry.clearAll();\n        long stateTimeLimit = 0L;\n        while(opModeIsActive()){\n            switch (autonState) {\n                case INITIALIZE:\n                    if (this.isStarted()) {       \/\/EVENT TO TRIGGER NEXT STATE IS PUSHING START BUTTON\n                        \/\/Perform the transitional actions\n                        \/\/Initialize the encoders\n                        robot.initializeEncoderTrackers(autonParameters);\n                        \/\/Set the target pose (where the robot should drive to + heading)\n                        Pose targetPose = new Pose(targetZone.getFieldPosition(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.MOVE_TO_TARGET_ZONE;\n                        standardStateTransitionActions();\n                    } else {\n                        telemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\n                        telemetry.update();\n                    }\n                    break;\n                case MOVE_TO_TARGET_ZONE:\n                    if (robot.getEbotsMotionController().isTargetPoseReached(robot)      \/\/check if trigger event occurred\n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n                        \/\/Perform transitional actions\n                        robot.stop();\n                        \/\/Set the new state\n                        autonState = AutonState.PLACE_WOBBLE_GOAL;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000;     \/\/set a timelimit of 5 seconds for next state\n                    } else {\n                        \/\/Perform the state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case PLACE_WOBBLE_GOAL:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){  \/\/trigger event?\n                        \/\/Perform transitional actions\n                        \/\/TBD code to fold Wobble Arm\n                        \/\/Create a new target pose on the launch line in center of field\n                        double xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\n                        Pose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.MOVE_TO_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {   \/\/perform the state actions\n                        \/\/TBD code to place the wobble goal\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case MOVE_TO_LAUNCH_LINE:\n                    if(robot.getEbotsMotionController().isTargetPoseReached(robot)          \/\/trigger event?\n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){      \/\/or timed out?\n                        \/\/Perform transitional actions\n                        robot.stop();\n                        \/\/TBD spin up the ring launcher\n                        \/\/Set the new state\n                        autonState = AutonState.SHOOT_POWER_SHOTS;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000L;\n                    } else {                    \/\/perform the state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case SHOOT_POWER_SHOTS:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){     \/\/trigger event?\n                        robot.stop();\n                        \/\/Create a new target pose on the launch line in center of field\n                        Pose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                        \/\/Set the new state\n                        autonState = AutonState.PARK_ON_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {            \/\/perform state actions\n                        \/\/TBD action to launch rings at powershots\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case PARK_ON_LAUNCH_LINE:\n                    if(!opModeIsActive()){      \/\/check for trigger event\n                        robot.stop();\n                    } else {                \/\/perform state actions\n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                        \/\/Report telemetry\n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n            }\n        }\n        \/\/Exit opmode\n        robot.stop();\n        \/\/State debug info\n\/\/        if (debugOn) {\n\/\/            Log.d(logTag, \"Transitioning out of state \" + autonState.toString());\n\/\/            if (robot.getEbotsMotionController().isTargetPoseReached(robot)) {\n\/\/                Log.d(logTag, \"Pose Achieved in \" + format(\"%.2f\", stateStopWatch.getElapsedTimeSeconds()));\n\/\/            } else {\n\/\/                Log.d(logTag, \"Failed to reach target, timed out!!! \" + robot.getPoseError().toString());\n\/\/            }\n\/\/        }\n    }","code_wo_comment":"@Override\n    public void runOpMode(){\n       \n       \n       \n       \n       \n       \n        autonParameters = AutonParameters.DEBUG_TWO_WHEEL;\n        autonParameters.setSpeed(Speed.FAST);\n        autonParameters.getSpeed().setK_i(0.3);\n        robot = new Robot(Pose.PresetPose.INNER_START_LINE, Alliance.RED, autonParameters);\n        targetZone = new TargetZone(robot.getAlliance(),TargetZone.Zone.B);\n        launchLine = new LaunchLine();\n        autonState = AutonState.INITIALIZE;\n        stateStopWatch = new StopWatch();\n       \n        robot.initializeStandardDriveWheels(hardwareMap);\n       \n        robot.initializeImu(hardwareMap);\n       \n        robot.initializeColorSensors(hardwareMap);\n       \n        robot.initializeEbotsDigitalTouches(hardwareMap);\n       \n        robot.initializeRevBlinkinLedDriver(hardwareMap);\n       \n        robot.initializeEbotsRev2mDistanceSensors(hardwareMap);\n       \n        robot.initializeExpansionHubsForBulkRead(hardwareMap);\n        telemetry.addLine(robot.getActualPose().toString());\n        telemetry.addLine(\"Initialization Complete!\");\n        telemetry.update();\n        Pose newPose = robot.getActualPose();\n        newPose.getX();\n        robot.setTargetPose(newPose);\n        waitForStart();\n        telemetry.clearAll();\n        long stateTimeLimit = 0L;\n        while(opModeIsActive()){\n            switch (autonState) {\n                case INITIALIZE:\n                    if (this.isStarted()) {      \n                       \n                       \n                        robot.initializeEncoderTrackers(autonParameters);\n                       \n                        Pose targetPose = new Pose(targetZone.getFieldPosition(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.MOVE_TO_TARGET_ZONE;\n                        standardStateTransitionActions();\n                    } else {\n                        telemetry.addLine(\"Stuck in INITIALIZED state, something is wrong\");\n                        telemetry.update();\n                    }\n                    break;\n                case MOVE_TO_TARGET_ZONE:\n                    if (robot.getEbotsMotionController().isTargetPoseReached(robot)     \n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit) {\n                       \n                        robot.stop();\n                       \n                        autonState = AutonState.PLACE_WOBBLE_GOAL;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000;    \n                    } else {\n                       \n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case PLACE_WOBBLE_GOAL:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){ \n                       \n                       \n                       \n                        double xCoord = launchLine.getX()-(robot.getSizeCoordinate(CsysDirection.X)\/2);\n                        Pose targetPose = new Pose(xCoord, robot.getActualPose().getY(), 0);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.MOVE_TO_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {  \n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case MOVE_TO_LAUNCH_LINE:\n                    if(robot.getEbotsMotionController().isTargetPoseReached(robot)         \n                            | stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){     \n                       \n                        robot.stop();\n                       \n                       \n                        autonState = AutonState.SHOOT_POWER_SHOTS;\n                        standardStateTransitionActions();\n                        stateTimeLimit = 5000L;\n                    } else {                   \n                        robot.getEbotsMotionController().moveToTargetPose(robot,stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n                case SHOOT_POWER_SHOTS:\n                    if(stateStopWatch.getElapsedTimeMillis() > stateTimeLimit){    \n                        robot.stop();\n                       \n                        Pose targetPose = new Pose(launchLine.getX(), robot.getActualPose().getY(), 180);\n                        robot.setTargetPose(targetPose);\n                        stateTimeLimit = robot.getEbotsMotionController().calculateTimeLimitMillis(robot);\n                       \n                        autonState = AutonState.PARK_ON_LAUNCH_LINE;\n                        standardStateTransitionActions();\n                    } else {           \n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString() + \" time limit \" + stateTimeLimit);\n                    }\n                    break;\n                case PARK_ON_LAUNCH_LINE:\n                    if(!opModeIsActive()){     \n                        robot.stop();\n                    } else {               \n                        robot.getEbotsMotionController().moveToTargetPose(robot, stateStopWatch);\n                       \n                        telemetry.addData(\"Current State\", autonState.toString());\n                        telemetry.addLine(stateStopWatch.toString(robot.getEbotsMotionController().getLoopCount()));\n                        telemetry.addData(\"Actual Pose: \", robot.getActualPose().toString());\n                        telemetry.addData(\"Target Pose: \", robot.getTargetPose().toString());\n                        telemetry.addData(\"Error: \", robot.getPoseError().toString());\n                        telemetry.update();\n                    }\n                    break;\n            }\n        }\n       \n        robot.stop();\n       \n    }","cleancode":"@override public void runopmode(){ autonparameters = autonparameters.debug_two_wheel; autonparameters.setspeed(speed.fast); autonparameters.getspeed().setk_i(0.3); robot = new robot(pose.presetpose.inner_start_line, alliance.red, autonparameters); targetzone = new targetzone(robot.getalliance(),targetzone.zone.b); launchline = new launchline(); autonstate = autonstate.initialize; statestopwatch = new stopwatch(); robot.initializestandarddrivewheels(hardwaremap); robot.initializeimu(hardwaremap); robot.initializecolorsensors(hardwaremap); robot.initializeebotsdigitaltouches(hardwaremap); robot.initializerevblinkinleddriver(hardwaremap); robot.initializeebotsrev2mdistancesensors(hardwaremap); robot.initializeexpansionhubsforbulkread(hardwaremap); telemetry.addline(robot.getactualpose().tostring()); telemetry.addline(\"initialization complete!\"); telemetry.update(); pose newpose = robot.getactualpose(); newpose.getx(); robot.settargetpose(newpose); waitforstart(); telemetry.clearall(); long statetimelimit = 0l; while(opmodeisactive()){ switch (autonstate) { case initialize: if (this.isstarted()) { robot.initializeencodertrackers(autonparameters); pose targetpose = new pose(targetzone.getfieldposition(), 0); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.move_to_target_zone; standardstatetransitionactions(); } else { telemetry.addline(\"stuck in initialized state, something is wrong\"); telemetry.update(); } break; case move_to_target_zone: if (robot.getebotsmotioncontroller().istargetposereached(robot) | statestopwatch.getelapsedtimemillis() > statetimelimit) { robot.stop(); autonstate = autonstate.place_wobble_goal; standardstatetransitionactions(); statetimelimit = 5000; } else { robot.getebotsmotioncontroller().movetotargetpose(robot, statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; case place_wobble_goal: if(statestopwatch.getelapsedtimemillis() > statetimelimit){ double xcoord = launchline.getx()-(robot.getsizecoordinate(csysdirection.x)\/2); pose targetpose = new pose(xcoord, robot.getactualpose().gety(), 0); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.move_to_launch_line; standardstatetransitionactions(); } else { telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring() + \" time limit \" + statetimelimit); } break; case move_to_launch_line: if(robot.getebotsmotioncontroller().istargetposereached(robot) | statestopwatch.getelapsedtimemillis() > statetimelimit){ robot.stop(); autonstate = autonstate.shoot_power_shots; standardstatetransitionactions(); statetimelimit = 5000l; } else { robot.getebotsmotioncontroller().movetotargetpose(robot,statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; case shoot_power_shots: if(statestopwatch.getelapsedtimemillis() > statetimelimit){ robot.stop(); pose targetpose = new pose(launchline.getx(), robot.getactualpose().gety(), 180); robot.settargetpose(targetpose); statetimelimit = robot.getebotsmotioncontroller().calculatetimelimitmillis(robot); autonstate = autonstate.park_on_launch_line; standardstatetransitionactions(); } else { telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring() + \" time limit \" + statetimelimit); } break; case park_on_launch_line: if(!opmodeisactive()){ robot.stop(); } else { robot.getebotsmotioncontroller().movetotargetpose(robot, statestopwatch); telemetry.adddata(\"current state\", autonstate.tostring()); telemetry.addline(statestopwatch.tostring(robot.getebotsmotioncontroller().getloopcount())); telemetry.adddata(\"actual pose: \", robot.getactualpose().tostring()); telemetry.adddata(\"target pose: \", robot.gettargetpose().tostring()); telemetry.adddata(\"error: \", robot.getposeerror().tostring()); telemetry.update(); } break; } } robot.stop(); }","repo":"bignaczak\/eBots2020_V2","label":[0,1,0,0]}

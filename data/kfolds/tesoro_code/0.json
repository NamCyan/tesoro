{"id":24576,"original_code":"private void addEntriesToMainManifest(Manifest manifest) {\n    Attributes attrs = manifest.getMainAttributes();\n    \/\/ If a manifest doesn't have a version, the other attributes won't get written out.  Lame.\n    attrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\n    for (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\n      attrs.put(entry.getKey(), entry.getValue());\n    }\n  }","code":"private void addEntriesToMainManifest(Manifest manifest) {\n    Attributes attrs = manifest.getMainAttributes();\n   \n    attrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\n    for (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\n      attrs.put(entry.getKey(), entry.getValue());\n    }\n  }","cleancode":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) { attrs.put(entry.getkey(), entry.getvalue()); } }","comment":"\/\/ if a manifest doesn't have a version, the other attributes won't get written out. lame.","repo":"DavidWhitlock\/PortlandStateJava","code_context_2":"private void addEntriesToMainManifest(Manifest manifest) {\nAttributes attrs = manifest.getMainAttributes();\n\/\/ If a manifest doesn't have a version, the other attributes won't get written out. Lame.\nattrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\nfor (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {","code_context_10":"private void addEntriesToMainManifest(Manifest manifest) {\nAttributes attrs = manifest.getMainAttributes();\n\/\/ If a manifest doesn't have a version, the other attributes won't get written out. Lame.\nattrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\nfor (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\nattrs.put(entry.getKey(), entry.getValue());\n}\n}","code_context_20":"private void addEntriesToMainManifest(Manifest manifest) {\nAttributes attrs = manifest.getMainAttributes();\n\/\/ If a manifest doesn't have a version, the other attributes won't get written out. Lame.\nattrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\nfor (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\nattrs.put(entry.getKey(), entry.getValue());\n}\n}","label":[0,0,1,0]}
{"id":32849,"original_code":"private boolean isTelLenthLegal(String tel) {\n        \/\/TODO: Replace this with your own logic\n        return tel.length() == 11;\n    }","code":"private boolean isTelLenthLegal(String tel) {\n       \n        return tel.length() == 11;\n    }","cleancode":"private boolean istellenthlegal(string tel) { return tel.length() == 11; }","comment":"\/\/\u9a8c\u8bc1\u624b\u673a\u53f7\u662f\u542611\u4f4d\n\/\/todo: replace this with your own logic","repo":"Asucanc\/FishMail","code_context_2":"private boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}\n\nprivate boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}","code_context_10":"private boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}\n\nprivate boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}","code_context_20":"private boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}\n\nprivate boolean isTelLenthLegal(String tel) {\n\/\/TODO: Replace this with your own logic\nreturn tel.length() == 11;\n}","label":[0,1,0,0]}
{"id":32850,"original_code":"private boolean isEmailValid(String email) {\n        \/\/TODO: Replace this with your own logic\n        return email.contains(\"@\")&&email.contains(\".\");\n    }","code":"private boolean isEmailValid(String email) {\n       \n        return email.contains(\"@\")&&email.contains(\".\");\n    }","cleancode":"private boolean isemailvalid(string email) { return email.contains(\"@\")&&email.contains(\".\"); }","comment":"\/\/\u662f\u5426\u662f\u90ae\u7bb1\n\/\/todo: replace this with your own logic","repo":"Asucanc\/FishMail","code_context_2":"private boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}\n\nprivate boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}","code_context_10":"private boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}\n\nprivate boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}","code_context_20":"private boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}\n\nprivate boolean isEmailValid(String email) {\n\/\/TODO: Replace this with your own logic\nreturn email.contains(\"@\")&&email.contains(\".\");\n}","label":[0,1,0,0]}
{"id":85,"original_code":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\n    if (moduleInfo.getIsBlocked()) {\n      return this;\n    }\n    \/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n    \/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n    \/\/ place or receive the call should be ignored for voice calls.\n    CallIntentBuilder callIntentBuilder =\n        new CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n            .setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\n    modules.add(IntentModule.newCallModule(context, callIntentBuilder));\n    return this;\n  }","code":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\n    if (moduleInfo.getIsBlocked()) {\n      return this;\n    }\n   \n   \n   \n    CallIntentBuilder callIntentBuilder =\n        new CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n            .setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\n    modules.add(IntentModule.newCallModule(context, callIntentBuilder));\n    return this;\n  }","cleancode":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","comment":"\/** * adds a module for placing a voice call. * * <p>the method is a no-op if the number is blocked. *\/\n\/\/ todo(zachh): support post-dial digits; consider using dialerphonenumber. \/\/ do not set phoneaccounthandle so that regular precall logic will be used. the account used to \/\/ place or receive the call should be ignored for voice calls.","repo":"DerpGang\/packages_apps_Dialer","code_context_2":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\nif (moduleInfo.getIsBlocked()) {\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n.setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\nmodules.add(IntentModule.newCallModule(context, callIntentBuilder));\nreturn this;\n}\n\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())","code_context_10":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\nif (moduleInfo.getIsBlocked()) {\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n.setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\nmodules.add(IntentModule.newCallModule(context, callIntentBuilder));\nreturn this;\n}\n\npublic HistoryItemActionModulesBuilder addModuleForVoiceCall() {\nif (moduleInfo.getIsBlocked()) {\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n.setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\nmodules.add(IntentModule.newCallModule(context, callIntentBuilder));\nreturn this;\n}","code_context_20":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\nif (moduleInfo.getIsBlocked()) {\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n.setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\nmodules.add(IntentModule.newCallModule(context, callIntentBuilder));\nreturn this;\n}\n\npublic HistoryItemActionModulesBuilder addModuleForVoiceCall() {\nif (moduleInfo.getIsBlocked()) {\nreturn this;\n}\n\/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n\/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n\/\/ place or receive the call should be ignored for voice calls.\nCallIntentBuilder callIntentBuilder =\nnew CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n.setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\nmodules.add(IntentModule.newCallModule(context, callIntentBuilder));\nreturn this;\n}","label":[0,1,0,0]}
{"id":16486,"original_code":"public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\n\t\tif(args.length != 4) {\n\t\t\tSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\tint k = Integer.valueOf(args[2]) ;\n\t\tint dim = Integer.valueOf(args[3]) ;\n\t\tJob init_job = Job.getInstance() ;\n\t\tConfiguration init_conf = init_job.getConfiguration();\n\t\tinit_conf.set(\"kmeans.k\", args[2]);\n\t\tinit_conf.set(\"kmeans.dim\", args[3]);\n\t\tinit_job.setJarByClass(KMean.class);\n\t\tinit_job.setJobName(\"clustered kmeans\");\n\t\tinit_job.setMapperClass(KMeanInitMapper.class);\n\t\tinit_job.setReducerClass(KMeanInitReducer.class);\n\t\tinit_job.setOutputKeyClass(IntWritable.class);\n\t\tinit_job.setOutputValueClass(Text.class);\n\t\tFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\t\t\/\/TODO check rewrite in future\n\t\tFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\n\t\tinit_job.waitForCompletion(true);\n\t\tdouble[][] old_centroids = new double[k][dim] ;\n\t\tint fi = 1 ;\n\t\tlong t1 =  System.currentTimeMillis() ;\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"start iteration\") ;\n\t\t\tJob kmean_cluster_jb = Job.getInstance() ;\n\t\t\tConfiguration conf = kmean_cluster_jb.getConfiguration() ;\n\t\t\tconf.set(\"kmeans.k\", args[2]);\n\t\t\tconf.set(\"kmeans.dim\", args[3]);\n\t\t\tkmean_cluster_jb.setJarByClass(KMean.class);\n\t\t\tkmean_cluster_jb.setJobName(\"clustered kmeans\");\n\t\t\tkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\n\t\t\tkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\n\t\t\tkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\n\t\t\tkmean_cluster_jb.setOutputValueClass(Text.class);\n\t\t\t\/\/ TODO check rewrite in future\n\t\t\tString uri =  args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\n\t\t\tConfiguration temp_conf = new Configuration();\n\t\t\tFileSystem fs = FileSystem.get(URI.create(uri), temp_conf); \n\t\t\tPath input_path = new Path(uri);\n\t\t\tFSDataInputStream input_stream = fs.open(input_path);\n\t\t\tBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\n\t\t\tdouble total_dis = 0 ;\n\t\t\tdouble[][] new_centroids = new double[k][dim] ;\n\t\t\tfor(int i = 0 ; i < k ; i++) {\t\n\t\t\t\tString line = input_buffer.readLine() ;\n\t\t\t\tif(line == null) {\n\t\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\t\tnew_centroids[i][j] = Double.valueOf(old_centroids[i][j]) ;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\t\n\t\t\t\tint key = Integer.valueOf(line.split(\"\\t\")[0]) ;\n\t\t\t\tString[] new_centroid = line.split(\"\\t\")[1].split(\",\") ;\n\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\tnew_centroids[key][j] = Double.valueOf(new_centroid[j]) ;\n\t\t\t\t\ttotal_dis += Math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ;\n\t\t\t\t}\n\t\t\t\tconf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]);\n\t\t\t}\n\t\t\tdouble threshold = Math.pow(0.001 ,2) * k * dim  ;\n\t\t\tif(total_dis < threshold)\n\t\t\t\tbreak ;\n\t\t\tFileInputFormat.addInputPath(kmean_cluster_jb, new Path(args[0]));\n\t\t\t\/\/TODO check rewrite in future\n\t\t\tFileOutputFormat.setOutputPath(kmean_cluster_jb, new Path(args[1] + \"_m_\" + Integer.toString(fi)));\n\t\t\tkmean_cluster_jb.waitForCompletion(true);\n\t\t\told_centroids = new_centroids;\n\t\t\tfi++ ;\n\t\t}\n\t\tlong t2 =  System.currentTimeMillis() ;\n\t\tSystem.out.println(\"\\n Time token by un-parallel is : \" + (t2-t1) + \"ms\");\n\t}","code":"public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\n\t\tif(args.length != 4) {\n\t\t\tSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\tint k = Integer.valueOf(args[2]) ;\n\t\tint dim = Integer.valueOf(args[3]) ;\n\t\tJob init_job = Job.getInstance() ;\n\t\tConfiguration init_conf = init_job.getConfiguration();\n\t\tinit_conf.set(\"kmeans.k\", args[2]);\n\t\tinit_conf.set(\"kmeans.dim\", args[3]);\n\t\tinit_job.setJarByClass(KMean.class);\n\t\tinit_job.setJobName(\"clustered kmeans\");\n\t\tinit_job.setMapperClass(KMeanInitMapper.class);\n\t\tinit_job.setReducerClass(KMeanInitReducer.class);\n\t\tinit_job.setOutputKeyClass(IntWritable.class);\n\t\tinit_job.setOutputValueClass(Text.class);\n\t\tFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\t\n\t\tFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\n\t\tinit_job.waitForCompletion(true);\n\t\tdouble[][] old_centroids = new double[k][dim] ;\n\t\tint fi = 1 ;\n\t\tlong t1 =  System.currentTimeMillis() ;\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"start iteration\") ;\n\t\t\tJob kmean_cluster_jb = Job.getInstance() ;\n\t\t\tConfiguration conf = kmean_cluster_jb.getConfiguration() ;\n\t\t\tconf.set(\"kmeans.k\", args[2]);\n\t\t\tconf.set(\"kmeans.dim\", args[3]);\n\t\t\tkmean_cluster_jb.setJarByClass(KMean.class);\n\t\t\tkmean_cluster_jb.setJobName(\"clustered kmeans\");\n\t\t\tkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\n\t\t\tkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\n\t\t\tkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\n\t\t\tkmean_cluster_jb.setOutputValueClass(Text.class);\n\t\t\n\t\t\tString uri =  args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\n\t\t\tConfiguration temp_conf = new Configuration();\n\t\t\tFileSystem fs = FileSystem.get(URI.create(uri), temp_conf); \n\t\t\tPath input_path = new Path(uri);\n\t\t\tFSDataInputStream input_stream = fs.open(input_path);\n\t\t\tBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\n\t\t\tdouble total_dis = 0 ;\n\t\t\tdouble[][] new_centroids = new double[k][dim] ;\n\t\t\tfor(int i = 0 ; i < k ; i++) {\t\n\t\t\t\tString line = input_buffer.readLine() ;\n\t\t\t\tif(line == null) {\n\t\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\t\tnew_centroids[i][j] = Double.valueOf(old_centroids[i][j]) ;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\t\n\t\t\t\tint key = Integer.valueOf(line.split(\"\\t\")[0]) ;\n\t\t\t\tString[] new_centroid = line.split(\"\\t\")[1].split(\",\") ;\n\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\tnew_centroids[key][j] = Double.valueOf(new_centroid[j]) ;\n\t\t\t\t\ttotal_dis += Math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ;\n\t\t\t\t}\n\t\t\t\tconf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]);\n\t\t\t}\n\t\t\tdouble threshold = Math.pow(0.001 ,2) * k * dim  ;\n\t\t\tif(total_dis < threshold)\n\t\t\t\tbreak ;\n\t\t\tFileInputFormat.addInputPath(kmean_cluster_jb, new Path(args[0]));\n\t\t\n\t\t\tFileOutputFormat.setOutputPath(kmean_cluster_jb, new Path(args[1] + \"_m_\" + Integer.toString(fi)));\n\t\t\tkmean_cluster_jb.waitForCompletion(true);\n\t\t\told_centroids = new_centroids;\n\t\t\tfi++ ;\n\t\t}\n\t\tlong t2 =  System.currentTimeMillis() ;\n\t\tSystem.out.println(\"\\n Time token by un-parallel is : \" + (t2-t1) + \"ms\");\n\t}","cleancode":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ; total_dis += math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ; } conf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]); } double threshold = math.pow(0.001 ,2) * k * dim ; if(total_dis < threshold) break ; fileinputformat.addinputpath(kmean_cluster_jb, new path(args[0])); fileoutputformat.setoutputpath(kmean_cluster_jb, new path(args[1] + \"_m_\" + integer.tostring(fi))); kmean_cluster_jb.waitforcompletion(true); old_centroids = new_centroids; fi++ ; } long t2 = system.currenttimemillis() ; system.out.println(\"\\n time token by un-parallel is : \" + (t2-t1) + \"ms\"); }","comment":"\/\/todo check rewrite in future\n\/\/ todo check rewrite in future\n\/\/todo check rewrite in future","repo":"AmrHendy\/K-Means","code_context_2":"init_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\n\nkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\nkmean_cluster_jb.setOutputValueClass(Text.class);\n\/\/ TODO check rewrite in future\nString uri = args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\nConfiguration temp_conf = new Configuration();\n\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);","code_context_10":"Configuration init_conf = init_job.getConfiguration();\ninit_conf.set(\"kmeans.k\", args[2]);\ninit_conf.set(\"kmeans.dim\", args[3]);\ninit_job.setJarByClass(KMean.class);\ninit_job.setJobName(\"clustered kmeans\");\ninit_job.setMapperClass(KMeanInitMapper.class);\ninit_job.setReducerClass(KMeanInitReducer.class);\ninit_job.setOutputKeyClass(IntWritable.class);\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\ndouble[][] old_centroids = new double[k][dim] ;\nint fi = 1 ;\nlong t1 = System.currentTimeMillis() ;\nwhile(true) {\nSystem.out.print(\"start iteration\") ;\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);\n\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);\nconf.set(\"kmeans.dim\", args[3]);\nkmean_cluster_jb.setJarByClass(KMean.class);\nkmean_cluster_jb.setJobName(\"clustered kmeans\");\nkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\nkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\nkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\nkmean_cluster_jb.setOutputValueClass(Text.class);\n\/\/ TODO check rewrite in future\nString uri = args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\nConfiguration temp_conf = new Configuration();\nFileSystem fs = FileSystem.get(URI.create(uri), temp_conf);\nPath input_path = new Path(uri);\nFSDataInputStream input_stream = fs.open(input_path);\nBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\ndouble total_dis = 0 ;\ndouble[][] new_centroids = new double[k][dim] ;\nfor(int i = 0 ; i < k ; i++) {\nString line = input_buffer.readLine() ;\n\nConfiguration init_conf = init_job.getConfiguration();\ninit_conf.set(\"kmeans.k\", args[2]);\ninit_conf.set(\"kmeans.dim\", args[3]);\ninit_job.setJarByClass(KMean.class);\ninit_job.setJobName(\"clustered kmeans\");\ninit_job.setMapperClass(KMeanInitMapper.class);\ninit_job.setReducerClass(KMeanInitReducer.class);\ninit_job.setOutputKeyClass(IntWritable.class);\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\ndouble[][] old_centroids = new double[k][dim] ;\nint fi = 1 ;\nlong t1 = System.currentTimeMillis() ;\nwhile(true) {\nSystem.out.print(\"start iteration\") ;\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);","code_context_20":"public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\nif(args.length != 4) {\nSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\nSystem.exit(-1);\n}\nint k = Integer.valueOf(args[2]) ;\nint dim = Integer.valueOf(args[3]) ;\nJob init_job = Job.getInstance() ;\nConfiguration init_conf = init_job.getConfiguration();\ninit_conf.set(\"kmeans.k\", args[2]);\ninit_conf.set(\"kmeans.dim\", args[3]);\ninit_job.setJarByClass(KMean.class);\ninit_job.setJobName(\"clustered kmeans\");\ninit_job.setMapperClass(KMeanInitMapper.class);\ninit_job.setReducerClass(KMeanInitReducer.class);\ninit_job.setOutputKeyClass(IntWritable.class);\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\ndouble[][] old_centroids = new double[k][dim] ;\nint fi = 1 ;\nlong t1 = System.currentTimeMillis() ;\nwhile(true) {\nSystem.out.print(\"start iteration\") ;\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);\nconf.set(\"kmeans.dim\", args[3]);\nkmean_cluster_jb.setJarByClass(KMean.class);\nkmean_cluster_jb.setJobName(\"clustered kmeans\");\nkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\nkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\nkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\nkmean_cluster_jb.setOutputValueClass(Text.class);\n\/\/ TODO check rewrite in future\nString uri = args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\nConfiguration temp_conf = new Configuration();\n\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\ndouble[][] old_centroids = new double[k][dim] ;\nint fi = 1 ;\nlong t1 = System.currentTimeMillis() ;\nwhile(true) {\nSystem.out.print(\"start iteration\") ;\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);\nconf.set(\"kmeans.dim\", args[3]);\nkmean_cluster_jb.setJarByClass(KMean.class);\nkmean_cluster_jb.setJobName(\"clustered kmeans\");\nkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\nkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\nkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\nkmean_cluster_jb.setOutputValueClass(Text.class);\n\/\/ TODO check rewrite in future\nString uri = args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\nConfiguration temp_conf = new Configuration();\nFileSystem fs = FileSystem.get(URI.create(uri), temp_conf);\nPath input_path = new Path(uri);\nFSDataInputStream input_stream = fs.open(input_path);\nBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\ndouble total_dis = 0 ;\ndouble[][] new_centroids = new double[k][dim] ;\nfor(int i = 0 ; i < k ; i++) {\nString line = input_buffer.readLine() ;\nif(line == null) {\nfor(int j = 0 ; j < dim ; j++) {\nnew_centroids[i][j] = Double.valueOf(old_centroids[i][j]) ;\n}\ncontinue ;\n}\nint key = Integer.valueOf(line.split(\"\\t\")[0]) ;\nString[] new_centroid = line.split(\"\\t\")[1].split(\",\") ;\nfor(int j = 0 ; j < dim ; j++) {\nnew_centroids[key][j] = Double.valueOf(new_centroid[j]) ;\n\npublic static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\nif(args.length != 4) {\nSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\nSystem.exit(-1);\n}\nint k = Integer.valueOf(args[2]) ;\nint dim = Integer.valueOf(args[3]) ;\nJob init_job = Job.getInstance() ;\nConfiguration init_conf = init_job.getConfiguration();\ninit_conf.set(\"kmeans.k\", args[2]);\ninit_conf.set(\"kmeans.dim\", args[3]);\ninit_job.setJarByClass(KMean.class);\ninit_job.setJobName(\"clustered kmeans\");\ninit_job.setMapperClass(KMeanInitMapper.class);\ninit_job.setReducerClass(KMeanInitReducer.class);\ninit_job.setOutputKeyClass(IntWritable.class);\ninit_job.setOutputValueClass(Text.class);\nFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\/\/TODO check rewrite in future\nFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\ninit_job.waitForCompletion(true);\ndouble[][] old_centroids = new double[k][dim] ;\nint fi = 1 ;\nlong t1 = System.currentTimeMillis() ;\nwhile(true) {\nSystem.out.print(\"start iteration\") ;\nJob kmean_cluster_jb = Job.getInstance() ;\nConfiguration conf = kmean_cluster_jb.getConfiguration() ;\nconf.set(\"kmeans.k\", args[2]);\nconf.set(\"kmeans.dim\", args[3]);\nkmean_cluster_jb.setJarByClass(KMean.class);\nkmean_cluster_jb.setJobName(\"clustered kmeans\");\nkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\nkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\nkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\nkmean_cluster_jb.setOutputValueClass(Text.class);\n\/\/ TODO check rewrite in future\nString uri = args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\nConfiguration temp_conf = new Configuration();","label":[0,1,0,0]}
{"id":32941,"original_code":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n        \/\/ this can probably work on contentValues_\n        String paramFullPath = item.getFullPath();\n        for ( XTCEContainerContentEntry entry : contentList_ ) {\n            if ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n                 ( entry.getEntryType() != FieldType.ARGUMENT  ) ) {\n                continue;\n            }\n            XTCEContainerEntryValue valueObj = entry.getValue();\n            if ( entry.getValue() == null ) {\n                continue;\n            }\n            if ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\n                if ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\n                    try {\n                        return Long.parseLong( valueObj.getCalibratedValue() );\n                    } catch ( NumberFormatException ex ) {\n                        warnings_.add(\n                            XTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n                            \" \" + \/\/ NOI18N\n                            item.getName() +\n                            \" (\" + \/\/ NOI18N\n                            XTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n                            \" '\" + \/\/ NOI18N\n                            valueObj.getCalibratedValue() +\n                            \"')\" ); \/\/ NOI18N\n                        return 1;\n                    }\n                }\n                warnings_.add(\n                    XTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n                    \" \" + \/\/ NOI18N\n                    item.getName() +\n                    \", \" + \/\/ NOI18N\n                    XTCEFunctions.getText( \"xml_dynamic_count_assume1\" ) ); \/\/ NOI18N\n                return 1;\n            }\n        }\n        return 1;\n    }","code":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n       \n        String paramFullPath = item.getFullPath();\n        for ( XTCEContainerContentEntry entry : contentList_ ) {\n            if ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n                 ( entry.getEntryType() != FieldType.ARGUMENT  ) ) {\n                continue;\n            }\n            XTCEContainerEntryValue valueObj = entry.getValue();\n            if ( entry.getValue() == null ) {\n                continue;\n            }\n            if ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\n                if ( valueObj.getOperator().equals( \"==\" ) == true ) {\n                    try {\n                        return Long.parseLong( valueObj.getCalibratedValue() );\n                    } catch ( NumberFormatException ex ) {\n                        warnings_.add(\n                            XTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) +\n                            \" \" +\n                            item.getName() +\n                            \" (\" +\n                            XTCEFunctions.getText( \"general_value\" ) +\n                            \" '\" +\n                            valueObj.getCalibratedValue() +\n                            \"')\" );\n                        return 1;\n                    }\n                }\n                warnings_.add(\n                    XTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) +\n                    \" \" +\n                    item.getName() +\n                    \", \" +\n                    XTCEFunctions.getText( \"xml_dynamic_count_assume1\" ) );\n                return 1;\n            }\n        }\n        return 1;\n    }","cleancode":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \" \" + item.getname() + \" (\" + xtcefunctions.gettext( \"general_value\" ) + \" '\" + valueobj.getcalibratedvalue() + \"')\" ); return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \" \" + item.getname() + \", \" + xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); return 1; } } return 1; }","comment":"\/\/ this can probably work on contentvalues_\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n\n\/\/ noi18n","repo":"CesarCoelho\/xtcetools","code_context_2":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );","code_context_10":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\n\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N","code_context_20":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N\n\nprotected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n\/\/ this can probably work on contentValues_\nString paramFullPath = item.getFullPath();\nfor ( XTCEContainerContentEntry entry : contentList_ ) {\nif ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n( entry.getEntryType() != FieldType.ARGUMENT ) ) {\ncontinue;\n}\nXTCEContainerEntryValue valueObj = entry.getValue();\nif ( entry.getValue() == null ) {\ncontinue;\n}\nif ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\nif ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\ntry {\nreturn Long.parseLong( valueObj.getCalibratedValue() );\n} catch ( NumberFormatException ex ) {\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\" (\" + \/\/ NOI18N\nXTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n\" '\" + \/\/ NOI18N\nvalueObj.getCalibratedValue() +\n\"')\" ); \/\/ NOI18N\nreturn 1;\n}\n}\nwarnings_.add(\nXTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n\" \" + \/\/ NOI18N\nitem.getName() +\n\", \" + \/\/ NOI18N","label":[1,0,0,0]}
{"id":32983,"original_code":"private static void registerFluids(BlockRegistry blockRegistry) {\n        \/\/ TODO Adjust properties\n        Fluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n                        .setTemperature(1000).setViscosity(200);\n        if(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\n            FluidRegistry.registerFluid(steam);\n            FluidRegistry.addBucketForFluid(steam);\n        }\n        blockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\n        Fluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n                        .setGaseous(true).setDensity(-100);\n        FluidRegistry.registerFluid(sulphur_dioxide);\n        FluidRegistry.addBucketForFluid(sulphur_dioxide);\n        blockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\n                Material.WATER, SARBlocks.damageSourceGas, 2));\n        Fluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\n        FluidRegistry.registerFluid(sulphuric_acid);\n        FluidRegistry.addBucketForFluid(sulphuric_acid);\n        blockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\n                Material.WATER, SARBlocks.damageSourceAcid, 4));\n        \/\/ TODO TE compat?\n        Fluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n                        .setGaseous(true);\n        FluidRegistry.registerFluid(liquid_glowstone);\n        FluidRegistry.addBucketForFluid(liquid_glowstone);\n        blockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\n                Material.LAVA));\n        Fluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public String getLocalizedName(FluidStack stack) {\n                return I18n.translateToLocal(\n                        PotionUtils.getPotionTypeFromNBT(stack.tag).getNamePrefixed(\"potion.effect.\"));\n            }\n            @Override\n            public int getColor(FluidStack stack) {\n                return PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromTag(stack.tag));\n            }\n        };\n        FluidRegistry.registerFluid(potion);\n        FluidRegistry.addBucketForFluid(potion);\n        FluidRegistry\n                .registerFluid(new Fluid(\"slime\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                        new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\")) {\n                    @Override\n                    public int getColor() {\n                        return Color.GREEN.getRGB();\n                    }\n                });\n    }","code":"private static void registerFluids(BlockRegistry blockRegistry) {\n       \n        Fluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n                        .setTemperature(1000).setViscosity(200);\n        if(!(FluidRegistry.isFluidRegistered(steam))) {\n            FluidRegistry.registerFluid(steam);\n            FluidRegistry.addBucketForFluid(steam);\n        }\n        blockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\n        Fluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n                        .setGaseous(true).setDensity(-100);\n        FluidRegistry.registerFluid(sulphur_dioxide);\n        FluidRegistry.addBucketForFluid(sulphur_dioxide);\n        blockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\n                Material.WATER, SARBlocks.damageSourceGas, 2));\n        Fluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\n        FluidRegistry.registerFluid(sulphuric_acid);\n        FluidRegistry.addBucketForFluid(sulphuric_acid);\n        blockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\n                Material.WATER, SARBlocks.damageSourceAcid, 4));\n       \n        Fluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n                        .setGaseous(true);\n        FluidRegistry.registerFluid(liquid_glowstone);\n        FluidRegistry.addBucketForFluid(liquid_glowstone);\n        blockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\n                Material.LAVA));\n        Fluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public String getLocalizedName(FluidStack stack) {\n                return I18n.translateToLocal(\n                        PotionUtils.getPotionTypeFromNBT(stack.tag).getNamePrefixed(\"potion.effect.\"));\n            }\n            @Override\n            public int getColor(FluidStack stack) {\n                return PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromTag(stack.tag));\n            }\n        };\n        FluidRegistry.registerFluid(potion);\n        FluidRegistry.addBucketForFluid(potion);\n        FluidRegistry\n                .registerFluid(new Fluid(\"slime\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                        new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\")) {\n                    @Override\n                    public int getColor() {\n                        return Color.GREEN.getRGB();\n                    }\n                });\n    }","cleancode":"private static void registerfluids(blockregistry blockregistry) { fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); } }; fluidregistry.registerfluid(potion); fluidregistry.addbucketforfluid(potion); fluidregistry .registerfluid(new fluid(\"slime\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution\")) { @override public int getcolor() { return color.green.getrgb(); } }); }","comment":"\/\/ todo adjust properties\n\/\/ soft registration\n\/\/ todo te compat?","repo":"BrassGoggledCoders\/SteamAgeRevolution","code_context_2":"private static void registerFluids(BlockRegistry blockRegistry) {\n\/\/ TODO Adjust properties\nFluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n.setTemperature(1000).setViscosity(200);\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n\nblockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\nMaterial.WATER, SARBlocks.damageSourceAcid, 4));\n\/\/ TODO TE compat?\nFluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),","code_context_10":"private static void registerFluids(BlockRegistry blockRegistry) {\n\/\/ TODO Adjust properties\nFluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n.setTemperature(1000).setViscosity(200);\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n}\nblockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\nFluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\n\nprivate static void registerFluids(BlockRegistry blockRegistry) {\n\/\/ TODO Adjust properties\nFluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n.setTemperature(1000).setViscosity(200);\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n}\nblockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\nFluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n.setGaseous(true).setDensity(-100);\nFluidRegistry.registerFluid(sulphur_dioxide);\nFluidRegistry.addBucketForFluid(sulphur_dioxide);\n\nFluidRegistry.addBucketForFluid(sulphur_dioxide);\nblockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\nMaterial.WATER, SARBlocks.damageSourceGas, 2));\nFluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\nFluidRegistry.registerFluid(sulphuric_acid);\nFluidRegistry.addBucketForFluid(sulphuric_acid);\nblockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\nMaterial.WATER, SARBlocks.damageSourceAcid, 4));\n\/\/ TODO TE compat?\nFluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n.setGaseous(true);\nFluidRegistry.registerFluid(liquid_glowstone);\nFluidRegistry.addBucketForFluid(liquid_glowstone);\nblockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\nMaterial.LAVA));\nFluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {","code_context_20":"private static void registerFluids(BlockRegistry blockRegistry) {\n\/\/ TODO Adjust properties\nFluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n.setTemperature(1000).setViscosity(200);\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n}\nblockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\nFluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n.setGaseous(true).setDensity(-100);\nFluidRegistry.registerFluid(sulphur_dioxide);\nFluidRegistry.addBucketForFluid(sulphur_dioxide);\nblockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\nMaterial.WATER, SARBlocks.damageSourceGas, 2));\nFluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\nFluidRegistry.registerFluid(sulphuric_acid);\n\nprivate static void registerFluids(BlockRegistry blockRegistry) {\n\/\/ TODO Adjust properties\nFluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n.setTemperature(1000).setViscosity(200);\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n}\nblockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\nFluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n.setGaseous(true).setDensity(-100);\nFluidRegistry.registerFluid(sulphur_dioxide);\nFluidRegistry.addBucketForFluid(sulphur_dioxide);\nblockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\nMaterial.WATER, SARBlocks.damageSourceGas, 2));\nFluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\nFluidRegistry.registerFluid(sulphuric_acid);\nFluidRegistry.addBucketForFluid(sulphuric_acid);\nblockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\nMaterial.WATER, SARBlocks.damageSourceAcid, 4));\n\/\/ TODO TE compat?\n\nif(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\nFluidRegistry.registerFluid(steam);\nFluidRegistry.addBucketForFluid(steam);\n}\nblockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\nFluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n.setGaseous(true).setDensity(-100);\nFluidRegistry.registerFluid(sulphur_dioxide);\nFluidRegistry.addBucketForFluid(sulphur_dioxide);\nblockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\nMaterial.WATER, SARBlocks.damageSourceGas, 2));\nFluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\nFluidRegistry.registerFluid(sulphuric_acid);\nFluidRegistry.addBucketForFluid(sulphuric_acid);\nblockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\nMaterial.WATER, SARBlocks.damageSourceAcid, 4));\n\/\/ TODO TE compat?\nFluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n.setGaseous(true);\nFluidRegistry.registerFluid(liquid_glowstone);\nFluidRegistry.addBucketForFluid(liquid_glowstone);\nblockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\nMaterial.LAVA));\nFluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\nnew ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {\n@SuppressWarnings(\"deprecation\")\n@Override\npublic String getLocalizedName(FluidStack stack) {\nreturn I18n.translateToLocal(\nPotionUtils.getPotionTypeFromNBT(stack.tag).getNamePrefixed(\"potion.effect.\"));\n}\n@Override\npublic int getColor(FluidStack stack) {\nreturn PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromTag(stack.tag));\n}","label":[1,1,0,0]}
{"id":33071,"original_code":"@Test void testUnquotedBuiltInFunctionNames() {\n    \/\/ TODO: Once Oracle is an officially supported dialect, this test\n    \/\/ should be moved to OracleValidatorTest.java.\n    final Sql oracle = sql(\"?\")\n        .withUnquotedCasing(Casing.TO_UPPER)\n        .withCaseSensitive(true);\n    \/\/ Built-in functions are always case-insensitive.\n    oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\n    oracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\n    oracle.sql(\"select current_time from dept\").ok();\n    oracle.sql(\"select Current_Time from dept\").ok();\n    oracle.sql(\"select CURRENT_TIME from dept\").ok();\n    oracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n  }","code":"@Test void testUnquotedBuiltInFunctionNames() {\n   \n   \n    final Sql oracle = sql(\"?\")\n        .withUnquotedCasing(Casing.TO_UPPER)\n        .withCaseSensitive(true);\n   \n    oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\n    oracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\n    oracle.sql(\"select current_time from dept\").ok();\n    oracle.sql(\"select Current_Time from dept\").ok();\n    oracle.sql(\"select CURRENT_TIME from dept\").ok();\n    oracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n  }","cleancode":"@test void testunquotedbuiltinfunctionnames() { final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","comment":"\/** tests matching of built-in operator names. *\/\n\/\/ todo: once oracle is an officially supported dialect, this test \/\/ should be moved to oraclevalidatortest.java.\n\/\/ built-in functions are always case-insensitive.","repo":"AndrewPochapsky\/calcite","code_context_2":"@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}\n\n@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();","code_context_10":"@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}\n\n@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\n\n@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}","code_context_20":"@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}\n\n@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}\n\n@Test void testUnquotedBuiltInFunctionNames() {\n\/\/ TODO: Once Oracle is an officially supported dialect, this test\n\/\/ should be moved to OracleValidatorTest.java.\nfinal Sql oracle = sql(\"?\")\n.withUnquotedCasing(Casing.TO_UPPER)\n.withCaseSensitive(true);\n\/\/ Built-in functions are always case-insensitive.\noracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\noracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\noracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\noracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\noracle.sql(\"select current_time from dept\").ok();\noracle.sql(\"select Current_Time from dept\").ok();\noracle.sql(\"select CURRENT_TIME from dept\").ok();\noracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n}","label":[0,0,0,1]}
{"id":8635,"original_code":"private void tryConnectToIPv6() throws Exception {\n            Collection<Inet6Address> possibleInetAddresses = AddressUtil\n                    .getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\n            Level level = silent ? Level.FINEST : Level.INFO;\n            \/\/TODO: collection.toString() will likely not produce any useful output!\n            if (logger.isLoggable(level)) {\n                logger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n            }\n            boolean connected = false;\n            Exception error = null;\n            int configuredTimeoutMillis =\n                    ioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\n            int timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n                    ? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\n            for (Inet6Address inetAddress : possibleInetAddresses) {\n                try {\n                    tryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\n                    connected = true;\n                    break;\n                } catch (Exception e) {\n                    error = e;\n                }\n            }\n            if (!connected && error != null) {\n                \/\/ could not connect any of addresses\n                throw error;\n            }\n        }","code":"private void tryConnectToIPv6() throws Exception {\n            Collection<Inet6Address> possibleInetAddresses = AddressUtil\n                    .getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\n            Level level = silent ? Level.FINEST : Level.INFO;\n           \n            if (logger.isLoggable(level)) {\n                logger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n            }\n            boolean connected = false;\n            Exception error = null;\n            int configuredTimeoutMillis =\n                    ioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\n            int timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n                    ? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\n            for (Inet6Address inetAddress : possibleInetAddresses) {\n                try {\n                    tryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\n                    connected = true;\n                    break;\n                } catch (Exception e) {\n                    error = e;\n                }\n            }\n            if (!connected && error != null) {\n               \n                throw error;\n            }\n        }","cleancode":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { throw error; } }","comment":"\/\/todo: collection.tostring() will likely not produce any useful output!\n\/\/ could not connect any of addresses","repo":"HugeOrangeDev\/hazelcast","code_context_2":".getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\nLevel level = silent ? Level.FINEST : Level.INFO;\n\/\/TODO: collection.toString() will likely not produce any useful output!\nif (logger.isLoggable(level)) {\nlogger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n\n}\nif (!connected && error != null) {\n\/\/ could not connect any of addresses\nthrow error;\n}","code_context_10":"private void tryConnectToIPv6() throws Exception {\nCollection<Inet6Address> possibleInetAddresses = AddressUtil\n.getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\nLevel level = silent ? Level.FINEST : Level.INFO;\n\/\/TODO: collection.toString() will likely not produce any useful output!\nif (logger.isLoggable(level)) {\nlogger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n}\nboolean connected = false;\nException error = null;\nint configuredTimeoutMillis =\nioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\nint timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\nfor (Inet6Address inetAddress : possibleInetAddresses) {\n\nfor (Inet6Address inetAddress : possibleInetAddresses) {\ntry {\ntryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\nconnected = true;\nbreak;\n} catch (Exception e) {\nerror = e;\n}\n}\nif (!connected && error != null) {\n\/\/ could not connect any of addresses\nthrow error;\n}\n}","code_context_20":"private void tryConnectToIPv6() throws Exception {\nCollection<Inet6Address> possibleInetAddresses = AddressUtil\n.getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\nLevel level = silent ? Level.FINEST : Level.INFO;\n\/\/TODO: collection.toString() will likely not produce any useful output!\nif (logger.isLoggable(level)) {\nlogger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n}\nboolean connected = false;\nException error = null;\nint configuredTimeoutMillis =\nioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\nint timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\nfor (Inet6Address inetAddress : possibleInetAddresses) {\ntry {\ntryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\nconnected = true;\nbreak;\n} catch (Exception e) {\nerror = e;\n}\n}\nif (!connected && error != null) {\n\/\/ could not connect any of addresses\n\n\/\/TODO: collection.toString() will likely not produce any useful output!\nif (logger.isLoggable(level)) {\nlogger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n}\nboolean connected = false;\nException error = null;\nint configuredTimeoutMillis =\nioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\nint timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\nfor (Inet6Address inetAddress : possibleInetAddresses) {\ntry {\ntryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\nconnected = true;\nbreak;\n} catch (Exception e) {\nerror = e;\n}\n}\nif (!connected && error != null) {\n\/\/ could not connect any of addresses\nthrow error;\n}\n}","label":[0,0,1,0]}
{"id":33242,"original_code":"public @NotNull FramedPacket retrieve() {\n        if (!PacketUtils.CACHED_PACKET) {\n            \/\/ TODO: Using a local buffer may be possible\n            return PacketUtils.allocateTrimmedPacket(packet());\n        }\n        SoftReference<FramedPacket> ref;\n        FramedPacket cache;\n        if (updated == 0 ||\n                ((ref = packet) == null ||\n                        (cache = ref.get()) == null)) {\n            cache = PacketUtils.allocateTrimmedPacket(packet());\n            this.packet = new SoftReference<>(cache);\n            UPDATER.compareAndSet(this, 0, 1);\n        }\n        return cache;\n    }","code":"public @NotNull FramedPacket retrieve() {\n        if (!PacketUtils.CACHED_PACKET) {\n           \n            return PacketUtils.allocateTrimmedPacket(packet());\n        }\n        SoftReference<FramedPacket> ref;\n        FramedPacket cache;\n        if (updated == 0 ||\n                ((ref = packet) == null ||\n                        (cache = ref.get()) == null)) {\n            cache = PacketUtils.allocateTrimmedPacket(packet());\n            this.packet = new SoftReference<>(cache);\n            UPDATER.compareAndSet(this, 0, 1);\n        }\n        return cache;\n    }","cleancode":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","comment":"\/** * retrieves the packet content. may be recomputed if the packet is invalidated or * if there is memory demand (handled by a soft reference). * <p> * {@link framedpacket#body()} will contain a buffer allocated by this method. *\/\n\/\/ todo: using a local buffer may be possible","repo":"Avinesia-Union\/Minestom","code_context_2":"public @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}\nSoftReference<FramedPacket> ref;\nFramedPacket cache;\nif (updated == 0 ||\n((ref = packet) == null ||\n(cache = ref.get()) == null)) {\ncache = PacketUtils.allocateTrimmedPacket(packet());\nthis.packet = new SoftReference<>(cache);\nUPDATER.compareAndSet(this, 0, 1);\n}\nreturn cache;\n}\n\npublic @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}","code_context_10":"public @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}\nSoftReference<FramedPacket> ref;\nFramedPacket cache;\nif (updated == 0 ||\n((ref = packet) == null ||\n(cache = ref.get()) == null)) {\ncache = PacketUtils.allocateTrimmedPacket(packet());\nthis.packet = new SoftReference<>(cache);\nUPDATER.compareAndSet(this, 0, 1);\n}\nreturn cache;\n}\n\npublic @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}\nSoftReference<FramedPacket> ref;\nFramedPacket cache;\nif (updated == 0 ||\n((ref = packet) == null ||\n(cache = ref.get()) == null)) {\ncache = PacketUtils.allocateTrimmedPacket(packet());\nthis.packet = new SoftReference<>(cache);\nUPDATER.compareAndSet(this, 0, 1);","code_context_20":"public @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}\nSoftReference<FramedPacket> ref;\nFramedPacket cache;\nif (updated == 0 ||\n((ref = packet) == null ||\n(cache = ref.get()) == null)) {\ncache = PacketUtils.allocateTrimmedPacket(packet());\nthis.packet = new SoftReference<>(cache);\nUPDATER.compareAndSet(this, 0, 1);\n}\nreturn cache;\n}\n\npublic @NotNull FramedPacket retrieve() {\nif (!PacketUtils.CACHED_PACKET) {\n\/\/ TODO: Using a local buffer may be possible\nreturn PacketUtils.allocateTrimmedPacket(packet());\n}\nSoftReference<FramedPacket> ref;\nFramedPacket cache;\nif (updated == 0 ||\n((ref = packet) == null ||\n(cache = ref.get()) == null)) {\ncache = PacketUtils.allocateTrimmedPacket(packet());\nthis.packet = new SoftReference<>(cache);\nUPDATER.compareAndSet(this, 0, 1);\n}\nreturn cache;\n}","label":[1,0,0,0]}
{"id":25149,"original_code":"@Override\n    @JRubyMethod(name = \"===\")\n    public RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n        \/\/ maybe we could handle java.lang === java.lang.reflect as well ?\n        return context.runtime.newBoolean(obj == this || isInstance(obj));\n    }","code":"@Override\n    @JRubyMethod(name = \"===\")\n    public RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n       \n        return context.runtime.newBoolean(obj == this || isInstance(obj));\n    }","cleancode":"@override @jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { return context.runtime.newboolean(obj == this || isinstance(obj)); }","comment":"\/\/ maybe we could handle java.lang === java.lang.reflect as well ?","repo":"DJRickyB\/jruby","code_context_2":"@JRubyMethod(name = \"===\")\npublic RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n\/\/ maybe we could handle java.lang === java.lang.reflect as well ?\nreturn context.runtime.newBoolean(obj == this || isInstance(obj));\n}","code_context_10":"@Override\n@JRubyMethod(name = \"===\")\npublic RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n\/\/ maybe we could handle java.lang === java.lang.reflect as well ?\nreturn context.runtime.newBoolean(obj == this || isInstance(obj));\n}","code_context_20":"@Override\n@JRubyMethod(name = \"===\")\npublic RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n\/\/ maybe we could handle java.lang === java.lang.reflect as well ?\nreturn context.runtime.newBoolean(obj == this || isInstance(obj));\n}","label":[1,0,0,0]}
{"id":25166,"original_code":"@Test\n  public void testCEV() {\n    int timeSteps = 200;\/\/ TODO why is this working with so few steps?\n    int priceSteps = 100;\n    double lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\n    double upperMoneyness = 3.0;\n    double volTol = 5e-3;\n    boolean print = false; \/\/ set to false before pushing\n    TESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n  }","code":"@Test\n  public void testCEV() {\n    int timeSteps = 200\n    int priceSteps = 100;\n    double lowerMoneyness = 0.3;\n    double upperMoneyness = 3.0;\n    double volTol = 5e-3;\n    boolean print = false;\n    TESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n  }","cleancode":"@test public void testcev() { int timesteps = 200 int pricesteps = 100; double lowermoneyness = 0.3; double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","comment":"\/\/ todo why is this working with so few steps?\n\/\/ not working well for itm calls\n\/\/ set to false before pushing","repo":"Incapture\/OG-Platform","code_context_2":"@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\n\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\n\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}","code_context_10":"@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}\n\n@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}\n\n@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}","code_context_20":"@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}\n\n@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}\n\n@Test\npublic void testCEV() {\nint timeSteps = 200;\/\/ TODO why is this working with so few steps?\nint priceSteps = 100;\ndouble lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\ndouble upperMoneyness = 3.0;\ndouble volTol = 5e-3;\nboolean print = false; \/\/ set to false before pushing\nTESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n}","label":[1,0,1,0]}
{"id":8849,"original_code":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\n\treturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n    }","code":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\n\treturn performCalculationSX(srcX, srcY, 2, strategy);\n    }","cleancode":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); }","comment":"\/** * perform's size 2 calculations. *\/\n\/\/ todo optimized algorhytm's.","repo":"CSS-Lletya\/open633","code_context_2":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}\n\nprivate static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}","code_context_10":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}\n\nprivate static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}","code_context_20":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}\n\nprivate static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\nreturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n}","label":[1,0,0,0]}
{"id":25271,"original_code":"public void addQualifNoDip() throws IOException {\n        if (isValidIndCursus(QualifNonDiplomante.class, true)) {\n            \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n            pojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n            \/\/TODO: Fix this !!\n\/\/\t\t\t\torg.esupportail.commons.utils.strings.StringUtils\n\/\/\t\t\t\t\t.htmlToText(pojoQualif.getCursus().getComment()));\n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n                \/\/ajout en base\n                addOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n                \/\/Ajout dans l'individu courant\n                getCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n            }\n            pojoQualif.addCursus();\n            Collections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","code":"public void addQualifNoDip() throws IOException {\n        if (isValidIndCursus(QualifNonDiplomante.class, true)) {\n                      pojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n           \n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n               \n                addOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n               \n                getCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n            }\n            pojoQualif.addCursus();\n            Collections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","cleancode":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); if (actionenum.getwhataction().equals(actionenum.update_action)) { addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","comment":"\/** * add a qualification non diplemantes. *\/\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n\/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(pojoqualif.getcursus().getcomment()));\n\/\/ajout en base\n\/\/ajout dans l'individu courant","repo":"EsupPortail\/esup-opi","code_context_2":"public void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\n\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\n\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}","code_context_10":"public void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}","code_context_20":"public void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addQualifNoDip() throws IOException {\nif (isValidIndCursus(QualifNonDiplomante.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\npojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(pojoQualif.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n}\npojoQualif.addCursus();\nCollections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}","label":[0,0,1,0]}
{"id":25270,"original_code":"public void addCursusPro() throws IOException {\n        if (isValidIndCursus(CursusPro.class, true)) {\n            \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n            indCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n            \/\/TODO: Fix this !!\n\/\/\t\t\t\torg.esupportail.commons.utils.strings.StringUtils\n\/\/\t\t\t\t\t.htmlToText(indCursusPojo.getCursus().getComment()));\n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n                \/\/ajout en base\n                addOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n                \/\/Ajout dans l'individu courant\n                getCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n            }\n            indCursusPojo.addCursus();\n            Collections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","code":"public void addCursusPro() throws IOException {\n        if (isValidIndCursus(CursusPro.class, true)) {\n                      indCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n           \n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n               \n                addOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n               \n                getCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n            }\n            indCursusPojo.addCursus();\n            Collections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","cleancode":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); if (actionenum.getwhataction().equals(actionenum.update_action)) { addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","comment":"\/** * add a cursuspro. *\/\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n\/\/todo: fix this !! \/\/ org.esupportail.commons.utils.strings.stringutils \/\/ .htmltotext(indcursuspojo.getcursus().getcomment()));\n\/\/ajout en base\n\/\/ajout dans l'individu courant","repo":"EsupPortail\/esup-opi","code_context_2":"public void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\n\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\n\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}","code_context_10":"public void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}","code_context_20":"public void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}\n\npublic void addCursusPro() throws IOException {\nif (isValidIndCursus(CursusPro.class, true)) {\n\/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\nindCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n\/\/TODO: Fix this !!\n\/\/ org.esupportail.commons.utils.strings.StringUtils\n\/\/ .htmlToText(indCursusPojo.getCursus().getComment()));\nif (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n\/\/ajout en base\naddOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n\/\/Ajout dans l'individu courant\ngetCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n}\nindCursusPojo.addCursus();\nCollections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n}\n}","label":[0,0,1,0]}
{"id":17130,"original_code":"@Override\n    public void updateTask()\n    {\n        double distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\n        boolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\n        if (canSeeTarget)\n        {\n            ++this.targetTimeLost;\n        }\n        else\n        {\n            this.targetTimeLost = 0;\n        }\n        if (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n        {\n            this.host.getNavigator().clearPathEntity();\n        }\n        else\n        {\n            this.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n        }\n        this.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\n        float f;\n        if (--this.rangedAttackTime == 0)\n        {\n            if (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n            {\n                return;\n            }\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            \/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n        else if (this.rangedAttackTime < 0)\n        {\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n    }","code":"@Override\n    public void updateTask()\n    {\n        double distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\n        boolean canSeeTarget = true;\n        if (canSeeTarget)\n        {\n            ++this.targetTimeLost;\n        }\n        else\n        {\n            this.targetTimeLost = 0;\n        }\n        if (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n        {\n            this.host.getNavigator().clearPathEntity();\n        }\n        else\n        {\n            this.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n        }\n        this.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\n        float f;\n        if (--this.rangedAttackTime == 0)\n        {\n            if (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n            {\n                return;\n            }\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n           \n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n        else if (this.rangedAttackTime < 0)\n        {\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n    }","cleancode":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","comment":"\/** updates the task *\/\n\/\/this.host.getentitysenses().cansee(this.attacktarget);\n\/\/ todo replace this.rangedattackentityhost.attackentitywithrangedattack(thost.getattacktarget(), f);","repo":"DarkGuardsman\/Artillects","code_context_2":"@Override\npublic void updateTask()\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n++this.targetTimeLost;\n}\nelse\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\nthis.host.getNavigator().clearPathEntity();\n}\nelse\n{\nthis.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\nif (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n{\nreturn;\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\nelse if (this.rangedAttackTime < 0)\n{\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\n}\n\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}","code_context_10":"@Override\npublic void updateTask()\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n++this.targetTimeLost;\n}\nelse\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\nthis.host.getNavigator().clearPathEntity();\n}\nelse\n{\nthis.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\nif (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n{\nreturn;\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\nelse if (this.rangedAttackTime < 0)\n{\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\n}\n\n@Override\npublic void updateTask()\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n++this.targetTimeLost;\n}\nelse\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\n\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\nif (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n{\nreturn;\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\nelse if (this.rangedAttackTime < 0)\n{\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\n}","code_context_20":"@Override\npublic void updateTask()\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n++this.targetTimeLost;\n}\nelse\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\nthis.host.getNavigator().clearPathEntity();\n}\nelse\n{\nthis.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\nif (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n{\nreturn;\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\nelse if (this.rangedAttackTime < 0)\n{\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\n}\n\n@Override\npublic void updateTask()\n{\ndouble distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\nboolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\nif (canSeeTarget)\n{\n++this.targetTimeLost;\n}\nelse\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\nthis.host.getNavigator().clearPathEntity();\n}\nelse\n{\nthis.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\n\n{\nthis.targetTimeLost = 0;\n}\nif (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n{\nthis.host.getNavigator().clearPathEntity();\n}\nelse\n{\nthis.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n}\nthis.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\nfloat f;\nif (--this.rangedAttackTime == 0)\n{\nif (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n{\nreturn;\n}\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n\/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\nelse if (this.rangedAttackTime < 0)\n{\nf = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\nthis.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n}\n}","label":[1,0,0,0]}
{"id":17208,"original_code":"protected void runOperations(String directoryPath, UseCase useCase) throws IOException {\n    log.info(System.lineSeparator() +\n      \"================================================\" + System.lineSeparator() +\n      \"     ____     ____________________     ____\" + System.lineSeparator() +\n      \"    \/    \\\\   \/  __|__    __|   _  \\\\   \/    \\\\\" + System.lineSeparator() +\n      \"   \/  \/\\\\  \\\\  \\\\  \\\\    |  |  |  |\/  \/  \/  \/\\\\  \\\\\" + System.lineSeparator() +\n      \"  \/  \/__\\\\  \\\\__\\\\  \\\\   |  |  |  |\\\\  \\\\ \/  \/__\\\\  \\\\\" + System.lineSeparator() +\n      \" \/__\/    \\\\__\\\\____\/   |__|  |__| \\\\__\\\\__\/    \\\\__\\\\\" + System.lineSeparator() +\n      \"================================================\");\n    log.info(\"Starting Astra run for directory: \" + directoryPath);\n    AtomicLong currentFileIndex = new AtomicLong();\n    AtomicLong currentPercentage = new AtomicLong();\n    log.info(\"Counting files (this may take a few seconds)\");\n    Instant startTime = Instant.now();\n    List<Path> javaFilesInDirectory;\n    try (Stream<Path> walk = Files.walk(Paths.get(directoryPath))) {\n      javaFilesInDirectory = walk\n          .filter(f -> f.toFile().isFile())\n          .filter(f -> f.getFileName().toString().endsWith(\"java\"))\n          .collect(Collectors.toList());\n    }\n    log.info(javaFilesInDirectory.size() + \" .java files in directory to review\");\n    log.info(\"Applying prefilters to files in directory\");\n    Predicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\n    List<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n        .filter(f -> prefilteringPredicate.test(f.toString()))\n        .collect(Collectors.toList());\n    log.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\n    final Set<? extends ASTOperation> operations = useCase.getOperations();\n    final String[] sources = useCase.getSources();\n    final String[] classPath = useCase.getClassPath();\n    for (Path f : filteredJavaFiles) {\n      \/\/ TODO AstUtils.getClassFilesForSource(f.toString()); - attempt to get only relevant classpaths for a given source file?\n      \/\/ TODO Naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.\n      applyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\n      long newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\n      if (newPercentage != currentPercentage.get()) {\n        currentPercentage.set(newPercentage);\n        logProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n      }\n    }\n    log.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n  }","code":"protected void runOperations(String directoryPath, UseCase useCase) throws IOException {\n    log.info(System.lineSeparator() +\n      \"================================================\" + System.lineSeparator() +\n      \"     ____     ____________________     ____\" + System.lineSeparator() +\n      \"    \/    \\\\   \/  __|__    __|   _  \\\\   \/    \\\\\" + System.lineSeparator() +\n      \"   \/  \/\\\\  \\\\  \\\\  \\\\    |  |  |  |\/  \/  \/  \/\\\\  \\\\\" + System.lineSeparator() +\n      \"  \/  \/__\\\\  \\\\__\\\\  \\\\   |  |  |  |\\\\  \\\\ \/  \/__\\\\  \\\\\" + System.lineSeparator() +\n      \" \/__\/    \\\\__\\\\____\/   |__|  |__| \\\\__\\\\__\/    \\\\__\\\\\" + System.lineSeparator() +\n      \"================================================\");\n    log.info(\"Starting Astra run for directory: \" + directoryPath);\n    AtomicLong currentFileIndex = new AtomicLong();\n    AtomicLong currentPercentage = new AtomicLong();\n    log.info(\"Counting files (this may take a few seconds)\");\n    Instant startTime = Instant.now();\n    List<Path> javaFilesInDirectory;\n    try (Stream<Path> walk = Files.walk(Paths.get(directoryPath))) {\n      javaFilesInDirectory = walk\n          .filter(f -> f.toFile().isFile())\n          .filter(f -> f.getFileName().toString().endsWith(\"java\"))\n          .collect(Collectors.toList());\n    }\n    log.info(javaFilesInDirectory.size() + \" .java files in directory to review\");\n    log.info(\"Applying prefilters to files in directory\");\n    Predicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\n    List<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n        .filter(f -> prefilteringPredicate.test(f.toString()))\n        .collect(Collectors.toList());\n    log.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\n    final Set<? extends ASTOperation> operations = useCase.getOperations();\n    final String[] sources = useCase.getSources();\n    final String[] classPath = useCase.getClassPath();\n    for (Path f : filteredJavaFiles) {\n     \n     \n      applyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\n      long newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\n      if (newPercentage != currentPercentage.get()) {\n        currentPercentage.set(newPercentage);\n        logProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n      }\n    }\n    log.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n  }","cleancode":"protected void runoperations(string directorypath, usecase usecase) throws ioexception { log.info(system.lineseparator() + \"================================================\" + system.lineseparator() + \" ____ ____________________ ____\" + system.lineseparator() + \" \/ \\\\ \/ __|__ __| _ \\\\ \/ \\\\\" + system.lineseparator() + \" \/ \/\\\\ \\\\ \\\\ \\\\ | | | |\/ \/ \/ \/\\\\ \\\\\" + system.lineseparator() + \" \/ \/__\\\\ \\\\__\\\\ \\\\ | | | |\\\\ \\\\ \/ \/__\\\\ \\\\\" + system.lineseparator() + \" \/__\/ \\\\__\\\\____\/ |__| |__| \\\\__\\\\__\/ \\\\__\\\\\" + system.lineseparator() + \"================================================\"); log.info(\"starting astra run for directory: \" + directorypath); atomiclong currentfileindex = new atomiclong(); atomiclong currentpercentage = new atomiclong(); log.info(\"counting files (this may take a few seconds)\"); instant starttime = instant.now(); list<path> javafilesindirectory; try (stream<path> walk = files.walk(paths.get(directorypath))) { javafilesindirectory = walk .filter(f -> f.tofile().isfile()) .filter(f -> f.getfilename().tostring().endswith(\"java\")) .collect(collectors.tolist()); } log.info(javafilesindirectory.size() + \" .java files in directory to review\"); log.info(\"applying prefilters to files in directory\"); predicate<string> prefilteringpredicate = usecase.getprefilteringpredicate(); list<path> filteredjavafiles = javafilesindirectory.stream() .filter(f -> prefilteringpredicate.test(f.tostring())) .collect(collectors.tolist()); log.info(filteredjavafiles.size() + \" files remain after prefiltering\"); final set<? extends astoperation> operations = usecase.getoperations(); final string[] sources = usecase.getsources(); final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size(); if (newpercentage != currentpercentage.get()) { currentpercentage.set(newpercentage); logprogress(currentfileindex.get(), currentpercentage.get(), starttime, filteredjavafiles.size()); } } log.info(getprintableduration(duration.between(starttime, instant.now()))); }","comment":"\/\/ todo astutils.getclassfilesforsource(f.tostring()); - attempt to get only relevant classpaths for a given source file? \/\/ todo naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.","repo":"Arraying\/astra","code_context_2":"final String[] classPath = useCase.getClassPath();\nfor (Path f : filteredJavaFiles) {\n\/\/ TODO AstUtils.getClassFilesForSource(f.toString()); - attempt to get only relevant classpaths for a given source file?\n\/\/ TODO Naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.\napplyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\nlong newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();","code_context_10":"log.info(\"Applying prefilters to files in directory\");\nPredicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\nList<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n.filter(f -> prefilteringPredicate.test(f.toString()))\n.collect(Collectors.toList());\nlog.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\nfinal Set<? extends ASTOperation> operations = useCase.getOperations();\nfinal String[] sources = useCase.getSources();\nfinal String[] classPath = useCase.getClassPath();\nfor (Path f : filteredJavaFiles) {\n\/\/ TODO AstUtils.getClassFilesForSource(f.toString()); - attempt to get only relevant classpaths for a given source file?\n\/\/ TODO Naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.\napplyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\nlong newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\nif (newPercentage != currentPercentage.get()) {\ncurrentPercentage.set(newPercentage);\nlogProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n}\n}\nlog.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n}","code_context_20":"log.info(\"Counting files (this may take a few seconds)\");\nInstant startTime = Instant.now();\nList<Path> javaFilesInDirectory;\ntry (Stream<Path> walk = Files.walk(Paths.get(directoryPath))) {\njavaFilesInDirectory = walk\n.filter(f -> f.toFile().isFile())\n.filter(f -> f.getFileName().toString().endsWith(\"java\"))\n.collect(Collectors.toList());\n}\nlog.info(javaFilesInDirectory.size() + \" .java files in directory to review\");\nlog.info(\"Applying prefilters to files in directory\");\nPredicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\nList<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n.filter(f -> prefilteringPredicate.test(f.toString()))\n.collect(Collectors.toList());\nlog.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\nfinal Set<? extends ASTOperation> operations = useCase.getOperations();\nfinal String[] sources = useCase.getSources();\nfinal String[] classPath = useCase.getClassPath();\nfor (Path f : filteredJavaFiles) {\n\/\/ TODO AstUtils.getClassFilesForSource(f.toString()); - attempt to get only relevant classpaths for a given source file?\n\/\/ TODO Naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.\napplyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\nlong newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\nif (newPercentage != currentPercentage.get()) {\ncurrentPercentage.set(newPercentage);\nlogProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n}\n}\nlog.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n}","label":[1,0,0,0]}
{"id":25405,"original_code":"public static FragmentHostManager get(View view) {\n        try {\n            return Dependency.get(FragmentService.class).getFragmentHostManager(view);\n        } catch (ClassCastException e) {\n            \/\/ TODO: Some auto handling here?\n            throw e;\n        }\n    }","code":"public static FragmentHostManager get(View view) {\n        try {\n            return Dependency.get(FragmentService.class).getFragmentHostManager(view);\n        } catch (ClassCastException e) {\n           \n            throw e;\n        }\n    }","cleancode":"public static fragmenthostmanager get(view view) { try { return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { throw e; } }","comment":"\/\/ todo: some auto handling here?","repo":"FrankKwok\/Oreo","code_context_2":"return Dependency.get(FragmentService.class).getFragmentHostManager(view);\n} catch (ClassCastException e) {\n\/\/ TODO: Some auto handling here?\nthrow e;\n}","code_context_10":"public static FragmentHostManager get(View view) {\ntry {\nreturn Dependency.get(FragmentService.class).getFragmentHostManager(view);\n} catch (ClassCastException e) {\n\/\/ TODO: Some auto handling here?\nthrow e;\n}\n}","code_context_20":"public static FragmentHostManager get(View view) {\ntry {\nreturn Dependency.get(FragmentService.class).getFragmentHostManager(view);\n} catch (ClassCastException e) {\n\/\/ TODO: Some auto handling here?\nthrow e;\n}\n}","label":[0,1,0,0]}
{"id":25463,"original_code":"public static void getText(Node node, StringBuilder sb) {\n\t\tNodeList children = node.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeType() == Node.TEXT_NODE) {\n\t\t\t\tsb.append(' '); \/\/ BUG: this is a hack\n\t\t\t\tsb.append(child.getNodeValue().trim());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tgetText(child, sb);\n\t\t\t}\n\t\t}\n\t}","code":"public static void getText(Node node, StringBuilder sb) {\n\t\tNodeList children = node.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeType() == Node.TEXT_NODE) {\n\t\t\t\tsb.append(' ');\n\t\t\t\tsb.append(child.getNodeValue().trim());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tgetText(child, sb);\n\t\t\t}\n\t\t}\n\t}","cleancode":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","comment":"\/** * <p>constructs the textual content of the given node and * recursively the textual content of its sub element nodes. * appends the result to the given stringbuilder.<\/p> * * @param node xml node * @param sb stringbuilder that will contain the textual content of the node *\/\n\/\/ bug: this is a hack","repo":"GoVivaceInc\/SpeechPlugin","code_context_2":"public static void getText(Node node, StringBuilder sb) {\nNodeList children = node.getChildNodes();\nfor (int i = 0; i < children.getLength(); i++) {\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {\ngetText(child, sb);\n}\n}\n}\n\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {","code_context_10":"public static void getText(Node node, StringBuilder sb) {\nNodeList children = node.getChildNodes();\nfor (int i = 0; i < children.getLength(); i++) {\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {\ngetText(child, sb);\n}\n}\n}\n\npublic static void getText(Node node, StringBuilder sb) {\nNodeList children = node.getChildNodes();\nfor (int i = 0; i < children.getLength(); i++) {\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {\ngetText(child, sb);\n}\n}\n}","code_context_20":"public static void getText(Node node, StringBuilder sb) {\nNodeList children = node.getChildNodes();\nfor (int i = 0; i < children.getLength(); i++) {\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {\ngetText(child, sb);\n}\n}\n}\n\npublic static void getText(Node node, StringBuilder sb) {\nNodeList children = node.getChildNodes();\nfor (int i = 0; i < children.getLength(); i++) {\nNode child = children.item(i);\nif (child.getNodeType() == Node.TEXT_NODE) {\nsb.append(' '); \/\/ BUG: this is a hack\nsb.append(child.getNodeValue().trim());\n} else if (child.getNodeType() == Node.ELEMENT_NODE) {\ngetText(child, sb);\n}\n}\n}","label":[0,0,1,0]}
{"id":9271,"original_code":"private static String encodeComponent(String s, Charset charset) {\n        \/\/ TODO: Optimize me.\n        try {\n            return URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n        } catch (UnsupportedEncodingException ignored) {\n            throw new UnsupportedCharsetException(charset.name());\n        }\n    }","code":"private static String encodeComponent(String s, Charset charset) {\n       \n        try {\n            return URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n        } catch (UnsupportedEncodingException ignored) {\n            throw new UnsupportedCharsetException(charset.name());\n        }\n    }","cleancode":"private static string encodecomponent(string s, charset charset) { try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\"); } catch (unsupportedencodingexception ignored) { throw new unsupportedcharsetexception(charset.name()); } }","comment":"\/\/ todo: optimize me.","repo":"AIPaaS\/sky-walking","code_context_2":"private static String encodeComponent(String s, Charset charset) {\n\/\/ TODO: Optimize me.\ntry {\nreturn URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");","code_context_10":"private static String encodeComponent(String s, Charset charset) {\n\/\/ TODO: Optimize me.\ntry {\nreturn URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n} catch (UnsupportedEncodingException ignored) {\nthrow new UnsupportedCharsetException(charset.name());\n}\n}","code_context_20":"private static String encodeComponent(String s, Charset charset) {\n\/\/ TODO: Optimize me.\ntry {\nreturn URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n} catch (UnsupportedEncodingException ignored) {\nthrow new UnsupportedCharsetException(charset.name());\n}\n}","label":[1,0,0,0]}
{"id":25701,"original_code":"@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.queue_list, container, false);\n        \/\/Instantiate Firebase objects\n        mDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\n        mDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n        \/\/Instantiate other variables\n        queueListView = rootView.findViewById(R.id.list);\n        loadingIndicator = rootView.findViewById(R.id.loading_indicator);\n        final List<Payment> paymentsList = new ArrayList<Payment>();\n        postAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\n        queueListView.setAdapter(postAdapter);\n        \/**Delete this post adapter when you finish*\/\n\/\/        postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n        \/\/Add ChildEventListener, so that changes made in the database are reflected\n        mChildEventListener = new ChildEventListener() {\n            @Override\n            public void onChildAdded(DataSnapshot dataSnapshot, String s) {\n                if (dataSnapshot.exists()) {\n                    loadingIndicator.setVisibility(View.GONE);\n                    Payment payment = dataSnapshot.getValue(Payment.class);\n                    \/**Uncomment this when you've finished*\/\n                    postAdapter.add(payment); \/\/here, you could use queueListView.add() too\n                }\n            }\n            @Override\n            public void onChildChanged(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onChildRemoved(DataSnapshot dataSnapshot) {\n            }\n            @Override\n            public void onChildMoved(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onCancelled(DatabaseError databaseError) {\n                Log.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n            }\n        };\n        mDepositQueueReference.addChildEventListener(mChildEventListener);\n        queueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                Payment payment = paymentsList.get(position);\n                Intent intent = new Intent(getActivity(), ConfirmDetailsActivity.class);\n                intent.putExtra(\"pushID\", payment.getPushID());\n                intent.putExtra(\"accountName\", payment.getAccountName());\n                intent.putExtra(\"accountNumber\", payment.getAccountNumber());\n                intent.putExtra(\"depositAmount\", payment.getDepositAmount());\n                intent.putExtra(\"depositorName\", payment.getDepositorName());\n                intent.putExtra(\"depositorPhoneNumber\", payment.getDepositorPhoneNumber());\n                intent.putExtra(\"depositorEmail\", payment.getDepositorEmail());\n                Log.e(TAG, \"Phone Number\" + payment.depositorPhoneNumber);\n                startActivity(intent);\n            }\n        });\n        return rootView;\n    }","code":"@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.queue_list, container, false);\n       \n        mDatabase = FirebaseDatabase.getInstance();\n        mDepositQueueReference = mDatabase.getReference(\"depositQueue\");\n       \n        queueListView = rootView.findViewById(R.id.list);\n        loadingIndicator = rootView.findViewById(R.id.loading_indicator);\n        final List<Payment> paymentsList = new ArrayList<Payment>();\n        postAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\n        queueListView.setAdapter(postAdapter);\n       \n       \n        mChildEventListener = new ChildEventListener() {\n            @Override\n            public void onChildAdded(DataSnapshot dataSnapshot, String s) {\n                if (dataSnapshot.exists()) {\n                    loadingIndicator.setVisibility(View.GONE);\n                    Payment payment = dataSnapshot.getValue(Payment.class);\n                   \n                    postAdapter.add(payment);\n                }\n            }\n            @Override\n            public void onChildChanged(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onChildRemoved(DataSnapshot dataSnapshot) {\n            }\n            @Override\n            public void onChildMoved(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onCancelled(DatabaseError databaseError) {\n                Log.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n            }\n        };\n        mDepositQueueReference.addChildEventListener(mChildEventListener);\n        queueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                Payment payment = paymentsList.get(position);\n                Intent intent = new Intent(getActivity(), ConfirmDetailsActivity.class);\n                intent.putExtra(\"pushID\", payment.getPushID());\n                intent.putExtra(\"accountName\", payment.getAccountName());\n                intent.putExtra(\"accountNumber\", payment.getAccountNumber());\n                intent.putExtra(\"depositAmount\", payment.getDepositAmount());\n                intent.putExtra(\"depositorName\", payment.getDepositorName());\n                intent.putExtra(\"depositorPhoneNumber\", payment.getDepositorPhoneNumber());\n                intent.putExtra(\"depositorEmail\", payment.getDepositorEmail());\n                Log.e(TAG, \"Phone Number\" + payment.depositorPhoneNumber);\n                startActivity(intent);\n            }\n        });\n        return rootView;\n    }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); mdatabase = firebasedatabase.getinstance(); mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); postadapter.add(payment); } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","comment":"\/\/instantiate firebase objects\n\/\/instance of firebase object(i.e. database root object)\n\/\/reference to depositqueue child object in root object\n\/\/instantiate other variables\n\/**delete this post adapter when you finish*\/ \/\/ postadapter.add(new payment(\"james blunt\", \"0149603509\", \"4500\", \"waec\", \"07033513241\", \"igwenus619@gmail.com\")); \/\/add childeventlistener, so that changes made in the database are reflected\n\/**uncomment this when you've finished*\/\n\/\/here, you could use queuelistview.add() too","repo":"HemlockBane\/cashier-demo","code_context_2":"Bundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\n\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\n\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\n\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\n\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}","code_context_10":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\n\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onChildRemoved(DataSnapshot dataSnapshot) {\n}\n@Override\n\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onChildRemoved(DataSnapshot dataSnapshot) {\n}\n@Override\npublic void onChildMoved(DataSnapshot dataSnapshot, String s) {","code_context_20":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container,\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onChildRemoved(DataSnapshot dataSnapshot) {\n}\n@Override\npublic void onChildMoved(DataSnapshot dataSnapshot, String s) {\n}\n@Override\n\nBundle savedInstanceState) {\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onChildRemoved(DataSnapshot dataSnapshot) {\n}\n@Override\npublic void onChildMoved(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onCancelled(DatabaseError databaseError) {\nLog.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n}\n};\nmDepositQueueReference.addChildEventListener(mChildEventListener);\nqueueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n@Override\n\nView rootView = inflater.inflate(R.layout.queue_list, container, false);\n\/\/Instantiate Firebase objects\nmDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\nmDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n\/\/Instantiate other variables\nqueueListView = rootView.findViewById(R.id.list);\nloadingIndicator = rootView.findViewById(R.id.loading_indicator);\nfinal List<Payment> paymentsList = new ArrayList<Payment>();\npostAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\nqueueListView.setAdapter(postAdapter);\n\/**Delete this post adapter when you finish*\/\n\/\/ postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n\/\/Add ChildEventListener, so that changes made in the database are reflected\nmChildEventListener = new ChildEventListener() {\n@Override\npublic void onChildAdded(DataSnapshot dataSnapshot, String s) {\nif (dataSnapshot.exists()) {\nloadingIndicator.setVisibility(View.GONE);\nPayment payment = dataSnapshot.getValue(Payment.class);\n\/**Uncomment this when you've finished*\/\npostAdapter.add(payment); \/\/here, you could use queueListView.add() too\n}\n}\n@Override\npublic void onChildChanged(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onChildRemoved(DataSnapshot dataSnapshot) {\n}\n@Override\npublic void onChildMoved(DataSnapshot dataSnapshot, String s) {\n}\n@Override\npublic void onCancelled(DatabaseError databaseError) {\nLog.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n}\n};\nmDepositQueueReference.addChildEventListener(mChildEventListener);\nqueueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n@Override\npublic void onItemClick(AdapterView<?> parent, View view, int position, long id) {","label":[0,0,0,0]}
{"id":25731,"original_code":"public static void symbols(PrintWriter out,\n\t\t\tboolean emit_non_terms, boolean sym_interface)\n\t{\n\t\tterminal term;\n\t\tnon_terminal nt;\n\t\tString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\n\t\tlong start_time = System.currentTimeMillis();\n\t\t\/* top of file *\/\n\t\tout.println();\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println(\"\/\/ The following code was generated by \" + version.title_str);\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println();\n\t\temit_package(out);\n\t\t\/* class header *\/\n\t\tout.println(\"\/** CUP generated \" + class_or_interface +\n\t\t\t\t\" containing symbol constants. *\/\");\n\t\tout.println(\"public \" + class_or_interface + \" \" +\n\t\t\t\tsymbol_const_class_name + \" {\");\n\t\tout.println(\"  \/* terminals *\/\");\n\t\t\/* walk over the terminals *\/\/* later might sort these *\/\n\t\tfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n\t\t{\n\t\t\tterm = (terminal) e.nextElement();\n\t\t\t\/* output a constant decl for the terminal *\/\n\t\t\tout.println(\"  public static final int \" + term.name() + \" = \" +\n\t\t\t\t\tterm.index() + \";\");\n\t\t}\n\t\t\/* Emit names of terminals *\/\n\t\tout.println(\"  public static final String[] terminalNames = new String[] {\");\n\t\tfor (int i = 0; i < terminal.number(); i++) {\n\t\t\tout.print(\"  \\\"\");\n\t\t\tout.print(terminal.find(i).name());\n\t\t\tout.print(\"\\\"\");\n\t\t\tif (i < terminal.number() - 1) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println(\"  };\");\n\t\t\/* do the non terminals if they want them (parser doesn't need them) *\/\n\t\tif (emit_non_terms)\n\t\t{\n\t\t\tout.println();\n\t\t\tout.println(\"  \/* non terminals *\/\");\n\t\t\t\/* walk over the non terminals *\/\/* later might sort these *\/\n\t\t\tfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tnt = (non_terminal) e.nextElement();\n\t\t\t\t\/\/ ****\n\t\t\t\t\/\/ TUM Comment: here we could add a typesafe enumeration\n\t\t\t\t\/\/ ****\n\t\t\t\t\/* output a constant decl for the terminal *\/\n\t\t\t\tout.println(\"  static final int \" + nt.name() + \" = \" +\n\t\t\t\t\t\tnt.index() + \";\");\n\t\t\t}\n\t\t}\n\t\t\/* end of class *\/\n\t\tout.println(\"}\");\n\t\tout.println();\n\t\tsymbols_time = System.currentTimeMillis() - start_time;\n\t}","code":"public static void symbols(PrintWriter out,\n\t\t\tboolean emit_non_terms, boolean sym_interface)\n\t{\n\t\tterminal term;\n\t\tnon_terminal nt;\n\t\tString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\n\t\tlong start_time = System.currentTimeMillis();\n\t\n\t\tout.println();\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println(\"\/\/ The following code was generated by \" + version.title_str);\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println();\n\t\temit_package(out);\n\t\n\t\tout.println(\"\/** CUP generated \" + class_or_interface +\n\t\t\t\t\" containing symbol constants. *\/\");\n\t\tout.println(\"public \" + class_or_interface + \" \" +\n\t\t\t\tsymbol_const_class_name + \" {\");\n\t\tout.println(\"  \/* terminals *\/\");\n\t\n\t\tfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n\t\t{\n\t\t\tterm = (terminal) e.nextElement();\n\t\t\n\t\t\tout.println(\"  public static final int \" + term.name() + \" = \" +\n\t\t\t\t\tterm.index() + \";\");\n\t\t}\n\t\n\t\tout.println(\"  public static final String[] terminalNames = new String[] {\");\n\t\tfor (int i = 0; i < terminal.number(); i++) {\n\t\t\tout.print(\"  \\\"\");\n\t\t\tout.print(terminal.find(i).name());\n\t\t\tout.print(\"\\\"\");\n\t\t\tif (i < terminal.number() - 1) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println(\"  };\");\n\t\n\t\tif (emit_non_terms)\n\t\t{\n\t\t\tout.println();\n\t\t\tout.println(\"  \/* non terminals *\/\");\n\t\t\n\t\t\tfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tnt = (non_terminal) e.nextElement();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tout.println(\"  static final int \" + nt.name() + \" = \" +\n\t\t\t\t\t\tnt.index() + \";\");\n\t\t\t}\n\t\t}\n\t\n\t\tout.println(\"}\");\n\t\tout.println();\n\t\tsymbols_time = System.currentTimeMillis() - start_time;\n\t}","cleancode":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","comment":"\/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*\/ \/** emit code for the symbol constant class, optionally including non terms, * if they have been requested. * @param out stream to produce output on. * @param emit_non_terms do we emit constants for non terminals? * @param sym_interface should we emit an interface, rather than a class? *\/\n\/* top of file *\/\n\/* class header *\/\n\/* walk over the terminals *\/ \/* later might sort these *\/\n\/* output a constant decl for the terminal *\/\n\/* emit names of terminals *\/\n\/* do the non terminals if they want them (parser doesn't need them) *\/\n\/* walk over the non terminals *\/ \/* later might sort these *\/\n\/\/ **** \/\/ tum comment: here we could add a typesafe enumeration \/\/ **** \/* output a constant decl for the terminal *\/\n\/* end of class *\/","repo":"AsaiKen\/phpscan","code_context_2":"public static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\n\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\n\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\n\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\n\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\n\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\n\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();","code_context_10":"public static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\npublic static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\n\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\n\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\n\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\n\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\n\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}","code_context_20":"public static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\npublic static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\npublic static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\n\npublic static void symbols(PrintWriter out,\nboolean emit_non_terms, boolean sym_interface)\n{\nterminal term;\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\n\nnon_terminal nt;\nString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\nlong start_time = System.currentTimeMillis();\n\/* top of file *\/\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\nout.println();\nout.println(\"\/\/----------------------------------------------------\");\nout.println(\"\/\/ The following code was generated by \" + version.title_str);\nout.println(\"\/\/----------------------------------------------------\");\nout.println();\nemit_package(out);\n\/* class header *\/\nout.println(\"\/** CUP generated \" + class_or_interface +\n\" containing symbol constants. *\/\");\nout.println(\"public \" + class_or_interface + \" \" +\nsymbol_const_class_name + \" {\");\nout.println(\" \/* terminals *\/\");\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\n\/* walk over the terminals *\/\/* later might sort these *\/\nfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n{\nterm = (terminal) e.nextElement();\n\/* output a constant decl for the terminal *\/\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n\nout.println(\" public static final int \" + term.name() + \" = \" +\nterm.index() + \";\");\n}\n\/* Emit names of terminals *\/\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\nout.println(\" public static final String[] terminalNames = new String[] {\");\nfor (int i = 0; i < terminal.number(); i++) {\nout.print(\" \\\"\");\nout.print(terminal.find(i).name());\nout.print(\"\\\"\");\nif (i < terminal.number() - 1) {\nout.print(\",\");\n}\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}\n\nout.println();\n}\nout.println(\" };\");\n\/* do the non terminals if they want them (parser doesn't need them) *\/\nif (emit_non_terms)\n{\nout.println();\nout.println(\" \/* non terminals *\/\");\n\/* walk over the non terminals *\/\/* later might sort these *\/\nfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n{\nnt = (non_terminal) e.nextElement();\n\/\/ ****\n\/\/ TUM Comment: here we could add a typesafe enumeration\n\/\/ ****\n\/* output a constant decl for the terminal *\/\nout.println(\" static final int \" + nt.name() + \" = \" +\nnt.index() + \";\");\n}\n}\n\/* end of class *\/\nout.println(\"}\");\nout.println();\nsymbols_time = System.currentTimeMillis() - start_time;\n}","label":[0,0,0,0]}
{"id":9378,"original_code":"private void transferData(RawPacket[] pkts)\n    {\n        for (int i = 0; i < pkts.length; i++)\n        {\n            RawPacket pkt = pkts[i];\n            pkts[i] = null;\n            if (pkt != null)\n            {\n                if (pkt.isInvalid())\n                {\n                    \/*\n                     * Return pkt to the pool because it is invalid and,\n                     * consequently, will not be made available to reading.\n                     *\/\n                    poolRawPacket(pkt);\n                }\n                else\n                {\n                    RawPacket oldPkt;\n                    synchronized (pktSyncRoot)\n                    {\n                        oldPkt = this.pkt;\n                        this.pkt = pkt;\n                    }\n                    if (oldPkt != null)\n                    {\n                        \/*\n                         * Return oldPkt to the pool because it was made\n                         * available to reading and it was not read.\n                         *\/\n                        poolRawPacket(oldPkt);\n                    }\n                    if (transferHandler != null && !closed)\n                    {\n                        try\n                        {\n                            transferHandler.transferData(this);\n                        }\n                        catch (Throwable t)\n                        {\n                            \/\/ XXX We cannot allow transferHandler to kill us.\n                            if (t instanceof InterruptedException)\n                            {\n                                Thread.currentThread().interrupt();\n                            }\n                            else if (t instanceof ThreadDeath)\n                            {\n                                throw (ThreadDeath) t;\n                            }\n                            else\n                            {\n                                logger.warn(\n                                    \"An RTP packet may have not been fully\"\n                                        + \" handled.\",\n                                    t);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","code":"private void transferData(RawPacket[] pkts)\n    {\n        for (int i = 0; i < pkts.length; i++)\n        {\n            RawPacket pkt = pkts[i];\n            pkts[i] = null;\n            if (pkt != null)\n            {\n                if (pkt.isInvalid())\n                {\n                   \n                    poolRawPacket(pkt);\n                }\n                else\n                {\n                    RawPacket oldPkt;\n                    synchronized (pktSyncRoot)\n                    {\n                        oldPkt = this.pkt;\n                        this.pkt = pkt;\n                    }\n                    if (oldPkt != null)\n                    {\n                       \n                        poolRawPacket(oldPkt);\n                    }\n                    if (transferHandler != null && !closed)\n                    {\n                        try\n                        {\n                            transferHandler.transferData(this);\n                        }\n                        catch (Throwable t)\n                        {\n                           \n                            if (t instanceof InterruptedException)\n                            {\n                                Thread.currentThread().interrupt();\n                            }\n                            else if (t instanceof ThreadDeath)\n                            {\n                                throw (ThreadDeath) t;\n                            }\n                            else\n                            {\n                                logger.warn(\n                                    \"An RTP packet may have not been fully\"\n                                        + \" handled.\",\n                                    t);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","comment":"\/** * invokes {@link sourcetransferhandler#transferdata(pushsourcestream)} on * {@link #transferhandler} for each of <tt>pkts<\/tt> in order to * consecutively push them out of\/make them available outside this * <tt>pushsourcestream<\/tt>. * * @param pkts the set of <tt>rawpacket<\/tt>s to push out of this * <tt>pushsourcestream<\/tt> *\/\n\/* * return pkt to the pool because it is invalid and, * consequently, will not be made available to reading. *\/\n\/* * return oldpkt to the pool because it was made * available to reading and it was not read. *\/\n\/\/ xxx we cannot allow transferhandler to kill us.","repo":"GNUDimarik\/libjitsi","code_context_2":"private void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\ntry\n{\ntransferHandler.transferData(this);\n}\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{\nThread.currentThread().interrupt();\n}\nelse if (t instanceof ThreadDeath)\n{\nthrow (ThreadDeath) t;\n}\nelse\n{\nlogger.warn(\n\"An RTP packet may have not been fully\"\n+ \" handled.\",\nt);\n}\n}\n}\n}\n}\n}\n}\n\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\n\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\n\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{","code_context_10":"private void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\ntry\n{\ntransferHandler.transferData(this);\n}\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{\nThread.currentThread().interrupt();\n}\nelse if (t instanceof ThreadDeath)\n{\nthrow (ThreadDeath) t;\n}\nelse\n{\nlogger.warn(\n\"An RTP packet may have not been fully\"\n+ \" handled.\",\nt);\n}\n}\n}\n}\n}\n}\n}\n\nprivate void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\n\nprivate void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\n\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\ntry\n{\ntransferHandler.transferData(this);\n}\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{\nThread.currentThread().interrupt();\n}\nelse if (t instanceof ThreadDeath)\n{\nthrow (ThreadDeath) t;\n}\nelse\n{","code_context_20":"private void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\ntry\n{\ntransferHandler.transferData(this);\n}\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{\nThread.currentThread().interrupt();\n}\nelse if (t instanceof ThreadDeath)\n{\nthrow (ThreadDeath) t;\n}\nelse\n{\nlogger.warn(\n\"An RTP packet may have not been fully\"\n+ \" handled.\",\nt);\n}\n}\n}\n}\n}\n}\n}\n\nprivate void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\n\nprivate void transferData(RawPacket[] pkts)\n{\nfor (int i = 0; i < pkts.length; i++)\n{\nRawPacket pkt = pkts[i];\npkts[i] = null;\nif (pkt != null)\n{\nif (pkt.isInvalid())\n{\n\/*\n* Return pkt to the pool because it is invalid and,\n* consequently, will not be made available to reading.\n*\/\npoolRawPacket(pkt);\n}\nelse\n{\nRawPacket oldPkt;\nsynchronized (pktSyncRoot)\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\n\n{\noldPkt = this.pkt;\nthis.pkt = pkt;\n}\nif (oldPkt != null)\n{\n\/*\n* Return oldPkt to the pool because it was made\n* available to reading and it was not read.\n*\/\npoolRawPacket(oldPkt);\n}\nif (transferHandler != null && !closed)\n{\ntry\n{\ntransferHandler.transferData(this);\n}\ncatch (Throwable t)\n{\n\/\/ XXX We cannot allow transferHandler to kill us.\nif (t instanceof InterruptedException)\n{\nThread.currentThread().interrupt();\n}\nelse if (t instanceof ThreadDeath)\n{\nthrow (ThreadDeath) t;\n}\nelse\n{\nlogger.warn(\n\"An RTP packet may have not been fully\"\n+ \" handled.\",\nt);\n}\n}\n}\n}\n}\n}","label":[1,0,0,0]}
{"id":34098,"original_code":"@Override\n    public void runOpMode() {\n        telemetry.addData(\"Status\", \"Initialized\");\n        telemetry.update();\n        left_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\n        right_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\n        front_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\n        front_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\n        Shooter = hardwareMap.dcMotor.get(\"Shooter\");\n        Conveyor = hardwareMap.dcMotor.get(\"Conveyor\");\n        clow_moter = hardwareMap.dcMotor.get(\"clow moter\");\n        Claw = hardwareMap.servo.get(\"Claw\");\n        touchfront = hardwareMap.touchSensor.get(\"touchfront\");\n        touch2 = hardwareMap.touchSensor.get(\"touch2\");\n        \/\/ values is a reference to the hsvValues array.\n        float[] hsvValues = new float[3];\n        final float values[] = hsvValues;\n        \/\/ bPrevState and bCurrState keep track of the previous and current state of the button\n        boolean bPrevState = false;\n        boolean bCurrState = false;\n        String mode=\"\";\n        Claw.setPosition(0);\n        right_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\n        right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        clow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        initVuforia();\n        initTfod();\n        \/**\n         * Activate TensorFlow Object Detection before we wait for the start command.\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n         **\/\n        if (tfod != null) {\n            tfod.activate();\n            \/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n            \/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n            \/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n            \/\/ to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\n            \/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n            \/\/ (typically 1.78 or 16\/9).\n            \/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n            \/\/tfod.setZoom(2.5, 1.78);\n        }\n        \/** Wait for the game to begin *\/\n        telemetry.addData(\">\", \"Press Play to start op mode\");\n        telemetry.update();\n        waitForStart();\n        if (opModeIsActive()) {\n            halt();\n            sleep(1000);\n            turnRight(0.5);\n            haltSequence(450);\n            goForward(.5);\n            haltSequence(150);\n            turnLeft(.5);\n            haltSequence(450);\n            goForward(0.4);\n            sleep(450);\n            halt();\n            sleep(1000);\n            telemetry.addData(\"Status\", \"Started\");\n            telemetry.update();\n            if (tfod != null) {\n                \/\/ getUpdatedRecognitions() will return null if no new information is available since\n                \/\/ the last time that call was made.\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    if (updatedRecognitions.size() == 0) {\n                        mode = \"A\";\n                    }\n                    \/\/ step through the list of recognitions and display boundary info.\n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                        if (recognition.getLabel() ==\"Quad\"){\n                            mode = \"C\";\n                        } else {\n                            mode = \"B\";\n                        }\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getLeft(), recognition.getTop());\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getRight(), recognition.getBottom());\n                    }\n                    \/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\n                    telemetry.update();\n                    sleep(2000);\n                }\n            }\n        }\n        \/\/ go somewhere based on mode\n            if (mode == \"A\") {\n                doModeA();\n            } else if (mode == \"B\") {\n                doModeB();\n            } else if (mode == \"C\") {\n                doModeC();\n            } else {\n                \/\/ not sure what to do here\n            }\n        if (tfod != null) {\n             tfod.shutdown();\n        }\n    }","code":"@Override\n    public void runOpMode() {\n        telemetry.addData(\"Status\", \"Initialized\");\n        telemetry.update();\n        left_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\n        right_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\n        front_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\n        front_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\n        Shooter = hardwareMap.dcMotor.get(\"Shooter\");\n        Conveyor = hardwareMap.dcMotor.get(\"Conveyor\");\n        clow_moter = hardwareMap.dcMotor.get(\"clow moter\");\n        Claw = hardwareMap.servo.get(\"Claw\");\n        touchfront = hardwareMap.touchSensor.get(\"touchfront\");\n        touch2 = hardwareMap.touchSensor.get(\"touch2\");\n       \n        float[] hsvValues = new float[3];\n        final float values[] = hsvValues;\n       \n        boolean bPrevState = false;\n        boolean bCurrState = false;\n        String mode=\"\";\n        Claw.setPosition(0);\n        right_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\n        right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        clow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        initVuforia();\n        initTfod();\n       \n        if (tfod != null) {\n            tfod.activate();\n           \n           \n           \n           \n           \n           \n           \n           \n        }\n       \n        telemetry.addData(\">\", \"Press Play to start op mode\");\n        telemetry.update();\n        waitForStart();\n        if (opModeIsActive()) {\n            halt();\n            sleep(1000);\n            turnRight(0.5);\n            haltSequence(450);\n            goForward(.5);\n            haltSequence(150);\n            turnLeft(.5);\n            haltSequence(450);\n            goForward(0.4);\n            sleep(450);\n            halt();\n            sleep(1000);\n            telemetry.addData(\"Status\", \"Started\");\n            telemetry.update();\n            if (tfod != null) {\n               \n               \n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    if (updatedRecognitions.size() == 0) {\n                        mode = \"A\";\n                    }\n                   \n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                        if (recognition.getLabel() ==\"Quad\"){\n                            mode = \"C\";\n                        } else {\n                            mode = \"B\";\n                        }\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getLeft(), recognition.getTop());\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getRight(), recognition.getBottom());\n                    }\n                   \n                    telemetry.update();\n                    sleep(2000);\n                }\n            }\n        }\n       \n            if (mode == \"A\") {\n                doModeA();\n            } else if (mode == \"B\") {\n                doModeB();\n            } else if (mode == \"C\") {\n                doModeC();\n            } else {\n               \n            }\n        if (tfod != null) {\n             tfod.shutdown();\n        }\n    }","cleancode":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); float[] hsvvalues = new float[3]; final float values[] = hsvvalues; boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); if (tfod != null) { tfod.activate(); } telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } telemetry.update(); sleep(2000); } } } if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { } if (tfod != null) { tfod.shutdown(); } }","comment":"\/\/ todo: write your code here\n\/\/ values is a reference to the hsvvalues array.\n\/\/ bprevstate and bcurrstate keep track of the previous and current state of the button\n\/** * activate tensorflow object detection before we wait for the start command. * do it here so that the camera stream window will have the tensorflow annotations visible. **\/\n\/\/ the tensorflow software will scale the input images from the camera to a lower resolution. \/\/ this can result in lower detection accuracy at longer distances (> 55cm or 22\"). \/\/ if your target is at distance greater than 50 cm (20\") you can adjust the magnification value \/\/ to artificially zoom in to the center of image. for best results, the \"aspectratio\" argument \/\/ should be set to the value of the images used to create the tensorflow object detection model \/\/ (typically 1.78 or 16\/9). \/\/ uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images. \/\/tfod.setzoom(2.5, 1.78);\n\/** wait for the game to begin *\/\n\/\/ getupdatedrecognitions() will return null if no new information is available since \/\/ the last time that call was made.\n\/\/ step through the list of recognitions and display boundary info.\n\/\/telemetry.adddata(string.format(\"mode (%s)\", mode), \"\");\n\/\/ go somewhere based on mode\n\/\/ not sure what to do here","repo":"FTC16694\/FtcRobotController","code_context_2":"@Override\npublic void runOpMode() {\ntelemetry.addData(\"Status\", \"Initialized\");\ntelemetry.update();\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}\n\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\n\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\n\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\n\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\n\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\n\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {","code_context_10":"@Override\npublic void runOpMode() {\ntelemetry.addData(\"Status\", \"Initialized\");\ntelemetry.update();\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}\n\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\n\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\n\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\n\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\n\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}","code_context_20":"@Override\npublic void runOpMode() {\ntelemetry.addData(\"Status\", \"Initialized\");\ntelemetry.update();\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}\n\n@Override\npublic void runOpMode() {\ntelemetry.addData(\"Status\", \"Initialized\");\ntelemetry.update();\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n\n@Override\npublic void runOpMode() {\ntelemetry.addData(\"Status\", \"Initialized\");\ntelemetry.update();\nleft_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\nright_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\nfront_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\nfront_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\nShooter = hardwareMap.dcMotor.get(\"Shooter\");\nConveyor = hardwareMap.dcMotor.get(\"Conveyor\");\nclow_moter = hardwareMap.dcMotor.get(\"clow moter\");\nClaw = hardwareMap.servo.get(\"Claw\");\ntouchfront = hardwareMap.touchSensor.get(\"touchfront\");\ntouch2 = hardwareMap.touchSensor.get(\"touch2\");\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\n\n\/\/ values is a reference to the hsvValues array.\nfloat[] hsvValues = new float[3];\nfinal float values[] = hsvValues;\n\/\/ bPrevState and bCurrState keep track of the previous and current state of the button\nboolean bPrevState = false;\nboolean bCurrState = false;\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\n\nString mode=\"\";\nClaw.setPosition(0);\nright_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\nright_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nleft_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nfront_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nclow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\nright_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\n\nleft_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\nfront_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\ninitVuforia();\ninitTfod();\n\/**\n* Activate TensorFlow Object Detection before we wait for the start command.\n* Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n**\/\nif (tfod != null) {\ntfod.activate();\n\/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n\/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n\/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n\/\/ to artificially zoom in to the center of image. For best results, the \"aspectRatio\" argument\n\/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n\/\/ (typically 1.78 or 16\/9).\n\/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n\/\/tfod.setZoom(2.5, 1.78);\n}\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\n\/** Wait for the game to begin *\/\ntelemetry.addData(\">\", \"Press Play to start op mode\");\ntelemetry.update();\nwaitForStart();\nif (opModeIsActive()) {\nhalt();\nsleep(1000);\nturnRight(0.5);\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\nhaltSequence(450);\ngoForward(.5);\nhaltSequence(150);\nturnLeft(.5);\nhaltSequence(450);\ngoForward(0.4);\nsleep(450);\nhalt();\nsleep(1000);\ntelemetry.addData(\"Status\", \"Started\");\ntelemetry.update();\nif (tfod != null) {\n\/\/ getUpdatedRecognitions() will return null if no new information is available since\n\/\/ the last time that call was made.\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\n\nList<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\nif (updatedRecognitions != null) {\ntelemetry.addData(\"# Object Detected\", updatedRecognitions.size());\nif (updatedRecognitions.size() == 0) {\nmode = \"A\";\n}\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}\n\n\/\/ step through the list of recognitions and display boundary info.\nint i = 0;\nfor (Recognition recognition : updatedRecognitions) {\ntelemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\nif (recognition.getLabel() ==\"Quad\"){\nmode = \"C\";\n} else {\nmode = \"B\";\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}\n\n}\ntelemetry.addData(String.format(\" left,top (%d)\", i), \"%.03f , %.03f\",\nrecognition.getLeft(), recognition.getTop());\ntelemetry.addData(String.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\",\nrecognition.getRight(), recognition.getBottom());\n}\n\/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\ntelemetry.update();\nsleep(2000);\n}\n}\n}\n\/\/ go somewhere based on mode\nif (mode == \"A\") {\ndoModeA();\n} else if (mode == \"B\") {\ndoModeB();\n} else if (mode == \"C\") {\ndoModeC();\n} else {\n\/\/ not sure what to do here\n}\nif (tfod != null) {\ntfod.shutdown();\n}\n}","label":[1,1,0,0]}
{"id":9539,"original_code":"private void filter() {\n                String text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\n                if (text.length() == 0) {\n                    rowSorter.setRowFilter(null);\n                }\n                else {\n                \t\/\/TODO escape special characters\n                    rowSorter.setRowFilter(RowFilter.regexFilter(text));\n                }\n                if (rowSorter.getViewRowCount() == 0) {\n            \t\tingredientMappingLogPanel.removeAll();\n            \t\tingredientMappingResultPanel.removeAll();\n            \t\tmainFrame.getFrame().repaint();\n                }\n                if (ingredientsTable.getRowCount() > 0) {\n            \t\tListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\n            \t\tselectionModel.setSelectionInterval(0, 0);\n                }\n             }","code":"private void filter() {\n                String text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\n                if (text.length() == 0) {\n                    rowSorter.setRowFilter(null);\n                }\n                else {\n                \n                    rowSorter.setRowFilter(RowFilter.regexFilter(text));\n                }\n                if (rowSorter.getViewRowCount() == 0) {\n            \t\tingredientMappingLogPanel.removeAll();\n            \t\tingredientMappingResultPanel.removeAll();\n            \t\tmainFrame.getFrame().repaint();\n                }\n                if (ingredientsTable.getRowCount() > 0) {\n            \t\tListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\n            \t\tselectionModel.setSelectionInterval(0, 0);\n                }\n             }","cleancode":"private void filter() { string text = drugmappingstringutilities.safetouppercase(searchfield.gettext()); if (text.length() == 0) { rowsorter.setrowfilter(null); } else { rowsorter.setrowfilter(rowfilter.regexfilter(text)); } if (rowsorter.getviewrowcount() == 0) { ingredientmappinglogpanel.removeall(); ingredientmappingresultpanel.removeall(); mainframe.getframe().repaint(); } if (ingredientstable.getrowcount() > 0) { listselectionmodel selectionmodel = ingredientstable.getselectionmodel(); selectionmodel.setselectioninterval(0, 0); } }","comment":"\/\/todo escape special characters","repo":"EHDEN\/DrugMapping","code_context_2":"}\nelse {\n\/\/TODO escape special characters\nrowSorter.setRowFilter(RowFilter.regexFilter(text));\n}","code_context_10":"private void filter() {\nString text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\nif (text.length() == 0) {\nrowSorter.setRowFilter(null);\n}\nelse {\n\/\/TODO escape special characters\nrowSorter.setRowFilter(RowFilter.regexFilter(text));\n}\nif (rowSorter.getViewRowCount() == 0) {\ningredientMappingLogPanel.removeAll();\ningredientMappingResultPanel.removeAll();\nmainFrame.getFrame().repaint();\n}\nif (ingredientsTable.getRowCount() > 0) {\nListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\nselectionModel.setSelectionInterval(0, 0);","code_context_20":"private void filter() {\nString text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\nif (text.length() == 0) {\nrowSorter.setRowFilter(null);\n}\nelse {\n\/\/TODO escape special characters\nrowSorter.setRowFilter(RowFilter.regexFilter(text));\n}\nif (rowSorter.getViewRowCount() == 0) {\ningredientMappingLogPanel.removeAll();\ningredientMappingResultPanel.removeAll();\nmainFrame.getFrame().repaint();\n}\nif (ingredientsTable.getRowCount() > 0) {\nListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\nselectionModel.setSelectionInterval(0, 0);\n}\n}","label":[0,1,0,0]}
{"id":9553,"original_code":"public void move(double inches, double power) {\n        robotInstance.drivetrain.povDrive(power, 0);\n    }","code":"public void move(double inches, double power) {\n        robotInstance.drivetrain.povDrive(power, 0);\n    }","cleancode":"public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","comment":"\/\/todo: add pid to move method","repo":"Centennial-FTC-Robotics\/Omnitech2021-22","code_context_2":"public void move(double inches, double power) {\nrobotInstance.drivetrain.povDrive(power, 0);\n}","code_context_10":"public void move(double inches, double power) {\nrobotInstance.drivetrain.povDrive(power, 0);\n}","code_context_20":"public void move(double inches, double power) {\nrobotInstance.drivetrain.povDrive(power, 0);\n}","label":[0,1,0,0]}
{"id":17777,"original_code":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n        \/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\n        Alert alert = new Alert(AlertType.NONE);\n        alert.setAlertType(type);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(text);\n        \/\/ HACK: since it is not possible to set the owner of an javafx alert to\n        \/\/       a swing frame, we use the following approach to set the modality!\n        ((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n        \/\/ if no button was pressed, the dialog got canceled (ESC, close)\n        return alert.showAndWait().orElse(ButtonType.CANCEL);\n    }","code":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n       \n        Alert alert = new Alert(AlertType.NONE);\n        alert.setAlertType(type);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(text);\n       \n       \n        ((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n       \n        return alert.showAndWait().orElse(ButtonType.CANCEL);\n    }","cleancode":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); return alert.showandwait().orelse(buttontype.cancel); }","comment":"\/** * returns the pressed button of the alert. * that can be used to in a condition, eg.: * showalert(alerttype.confirmation, \"ok?\", \"is it ok?\") == buttontype.ok * * @param type the alert type * @param title the title of the alert * @param text the text of the alert * @param ontop the alert \"modality\"; true if the alert should be always * on top, false otherwise * @return the button type (depends on the alert type) *\/\n\/\/ note: alert must be (re-)created everytime, otherwise the following hack doesn't work!\n\/\/ hack: since it is not possible to set the owner of an javafx alert to \/\/ a swing frame, we use the following approach to set the modality!\n\/\/ if no button was pressed, the dialog got canceled (esc, close)","repo":"BerlinUnited\/NaoTH","code_context_2":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\n\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\n\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}","code_context_10":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}","code_context_20":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}\n\npublic static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n\/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\nAlert alert = new Alert(AlertType.NONE);\nalert.setAlertType(type);\nalert.setTitle(title);\nalert.setHeaderText(null);\nalert.setContentText(text);\n\/\/ HACK: since it is not possible to set the owner of an javafx alert to\n\/\/ a swing frame, we use the following approach to set the modality!\n((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n\/\/ if no button was pressed, the dialog got canceled (ESC, close)\nreturn alert.showAndWait().orElse(ButtonType.CANCEL);\n}","label":[1,0,0,0]}
{"id":25987,"original_code":"@Override\n    public QueryProfileVariant clone() {\n        if (frozen) return this;\n       try {\n           QueryProfileVariant clone = (QueryProfileVariant)super.clone();\n           if (this.inherited != null)\n               clone.inherited = new ArrayList<>(this.inherited); \/\/ TODO: Deep clone is more correct, but probably does not matter in practice\n           clone.values = CopyOnWriteContent.deepClone(this.values);\n           return clone;\n       }\n       catch (CloneNotSupportedException e) {\n           throw new RuntimeException(e);\n       }\n    }","code":"@Override\n    public QueryProfileVariant clone() {\n        if (frozen) return this;\n       try {\n           QueryProfileVariant clone = (QueryProfileVariant)super.clone();\n           if (this.inherited != null)\n               clone.inherited = new ArrayList<>(this.inherited);\n           clone.values = CopyOnWriteContent.deepClone(this.values);\n           return clone;\n       }\n       catch (CloneNotSupportedException e) {\n           throw new RuntimeException(e);\n       }\n    }","cleancode":"@override public queryprofilevariant clone() { if (frozen) return this; try { queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); clone.values = copyonwritecontent.deepclone(this.values); return clone; } catch (clonenotsupportedexception e) { throw new runtimeexception(e); } }","comment":"\/\/ todo: deep clone is more correct, but probably does not matter in practice","repo":"Anlon-Burke\/vespa","code_context_2":"QueryProfileVariant clone = (QueryProfileVariant)super.clone();\nif (this.inherited != null)\nclone.inherited = new ArrayList<>(this.inherited); \/\/ TODO: Deep clone is more correct, but probably does not matter in practice\nclone.values = CopyOnWriteContent.deepClone(this.values);\nreturn clone;","code_context_10":"@Override\npublic QueryProfileVariant clone() {\nif (frozen) return this;\ntry {\nQueryProfileVariant clone = (QueryProfileVariant)super.clone();\nif (this.inherited != null)\nclone.inherited = new ArrayList<>(this.inherited); \/\/ TODO: Deep clone is more correct, but probably does not matter in practice\nclone.values = CopyOnWriteContent.deepClone(this.values);\nreturn clone;\n}\ncatch (CloneNotSupportedException e) {\nthrow new RuntimeException(e);\n}\n}","code_context_20":"@Override\npublic QueryProfileVariant clone() {\nif (frozen) return this;\ntry {\nQueryProfileVariant clone = (QueryProfileVariant)super.clone();\nif (this.inherited != null)\nclone.inherited = new ArrayList<>(this.inherited); \/\/ TODO: Deep clone is more correct, but probably does not matter in practice\nclone.values = CopyOnWriteContent.deepClone(this.values);\nreturn clone;\n}\ncatch (CloneNotSupportedException e) {\nthrow new RuntimeException(e);\n}\n}","label":[1,0,0,0]}
{"id":9614,"original_code":"void loadUi(EmpSeries series) {\n        this.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\n        RecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\n        episodesCarousel.setAdapter(this.episodesCarouselAdapter);\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\n        episodesCarousel.setLayoutManager(layoutManager);\n        if(series.episodes == null) {\n            \/\/ TODO: get programs for a specific series && seasonID\n        }\n    }","code":"void loadUi(EmpSeries series) {\n        this.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\n        RecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\n        episodesCarousel.setAdapter(this.episodesCarouselAdapter);\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\n        episodesCarousel.setLayoutManager(layoutManager);\n        if(series.episodes == null) {\n           \n        }\n    }","cleancode":"void loadui(empseries series) { this.episodescarouseladapter = new episodescarouseladapter(this, series); recyclerview episodescarousel = (recyclerview) findviewbyid(r.id.carousel_series_items); episodescarousel.setadapter(this.episodescarouseladapter); linearlayoutmanager layoutmanager = new linearlayoutmanager(this, linearlayoutmanager.horizontal, false); episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { } }","comment":"\/\/ todo: get programs for a specific series && seasonid","repo":"EricssonBroadcastServices\/AndroidClientReferenceApp","code_context_2":"episodesCarousel.setLayoutManager(layoutManager);\nif(series.episodes == null) {\n\/\/ TODO: get programs for a specific series && seasonID\n}\n}","code_context_10":"void loadUi(EmpSeries series) {\nthis.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\nRecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\nepisodesCarousel.setAdapter(this.episodesCarouselAdapter);\nLinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\nepisodesCarousel.setLayoutManager(layoutManager);\nif(series.episodes == null) {\n\/\/ TODO: get programs for a specific series && seasonID\n}\n}","code_context_20":"void loadUi(EmpSeries series) {\nthis.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\nRecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\nepisodesCarousel.setAdapter(this.episodesCarouselAdapter);\nLinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\nepisodesCarousel.setLayoutManager(layoutManager);\nif(series.episodes == null) {\n\/\/ TODO: get programs for a specific series && seasonID\n}\n}","label":[0,1,0,0]}
{"id":17865,"original_code":"@Test(expected = AmazonClientException.class)\n    public void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\n        mockServer.setResponseFileName(\"sessionResponseExpired\");\n        mockServer.setAvailableSecurityCredentials(\"test-credentials\");\n        InstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\n        Thread.sleep(1000);\n        \/\/Hacky assert but we know that this mockServer will create an exception that will be logged, if there's no log entry\n        \/\/then there's no exception, which means that getCredentials didn't get called on the fetcher\n        assertThat(loggedEvents(), is(empty()));\n        credentialsProvider.getCredentials();\n    }","code":"@Test(expected = AmazonClientException.class)\n    public void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\n        mockServer.setResponseFileName(\"sessionResponseExpired\");\n        mockServer.setAvailableSecurityCredentials(\"test-credentials\");\n        InstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\n        Thread.sleep(1000);\n       \n       \n        assertThat(loggedEvents(), is(empty()));\n        credentialsProvider.getCredentials();\n    }","cleancode":"@test(expected = amazonclientexception.class) public void canbeconfiguredtoonlyrefreshcredentialsafterfirstcalltogetcredentials() throws interruptedexception { mockserver.setresponsefilename(\"sessionresponseexpired\"); mockserver.setavailablesecuritycredentials(\"test-credentials\"); instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials(); }","comment":"\/\/hacky assert but we know that this mockserver will create an exception that will be logged, if there's no log entry \/\/then there's no exception, which means that getcredentials didn't get called on the fetcher","repo":"IBM\/ibm-cos-sdk-java","code_context_2":"InstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\nThread.sleep(1000);\n\/\/Hacky assert but we know that this mockServer will create an exception that will be logged, if there's no log entry\n\/\/then there's no exception, which means that getCredentials didn't get called on the fetcher\nassertThat(loggedEvents(), is(empty()));\ncredentialsProvider.getCredentials();","code_context_10":"@Test(expected = AmazonClientException.class)\npublic void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\nmockServer.setResponseFileName(\"sessionResponseExpired\");\nmockServer.setAvailableSecurityCredentials(\"test-credentials\");\nInstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\nThread.sleep(1000);\n\/\/Hacky assert but we know that this mockServer will create an exception that will be logged, if there's no log entry\n\/\/then there's no exception, which means that getCredentials didn't get called on the fetcher\nassertThat(loggedEvents(), is(empty()));\ncredentialsProvider.getCredentials();\n}","code_context_20":"@Test(expected = AmazonClientException.class)\npublic void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\nmockServer.setResponseFileName(\"sessionResponseExpired\");\nmockServer.setAvailableSecurityCredentials(\"test-credentials\");\nInstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\nThread.sleep(1000);\n\/\/Hacky assert but we know that this mockServer will create an exception that will be logged, if there's no log entry\n\/\/then there's no exception, which means that getCredentials didn't get called on the fetcher\nassertThat(loggedEvents(), is(empty()));\ncredentialsProvider.getCredentials();\n}","label":[1,0,0,0]}
{"id":17941,"original_code":"@Override\n    public ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\n        Request.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\n        List<CalendarModel> calendarModels = new ArrayList<>();\n        try (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\n            ResponseBody body = graphResponse.body();\n            if (body == null) {\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n            }\n            String graphBody = new String(body.bytes());\n            Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n            \/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n            \/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\n            if (rawCalendars == null) {\n                return new ExportResult<>(ExportResult.ResultType.END);\n            }\n            for (Map<String, Object> rawCalendar : rawCalendars) {\n                TransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\n                if (result.hasProblems()) {\n                    \/\/ discard\n                    \/\/ FIXME log problem\n                    continue;\n                }\n                calendarModels.add(result.getTransformed());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  \/\/ FIXME log error\n            return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n        }\n        List<CalendarEventModel> calendarEventModels = new ArrayList<>();\n        for (CalendarModel calendarModel : calendarModels) {\n            String id = calendarModel.getId();\n            Request.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\n            try (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\n                ResponseBody body = graphResponse.body();\n                if (body == null) {\n                    return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n                }\n                String graphBody = new String(body.bytes());\n                Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n                \/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n                \/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n                @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\n                if (rawEvents == null) {\n                    return new ExportResult<>(ExportResult.ResultType.END);\n                }\n                for (Map<String, Object> rawEvent : rawEvents) {\n                    Map<String, String> properties = new HashMap<>();\n                    properties.put(CALENDAR_ID, id);\n                    TransformResult<CalendarEventModel> result = transformerService.transform(CalendarEventModel.class, rawEvent, properties);\n                    if (result.hasProblems()) {\n                        \/\/ discard\n                        \/\/ FIXME log problem\n                        continue;\n                    }\n                    calendarEventModels.add(result.getTransformed());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();  \/\/ FIXME log error\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: \" + e.getMessage());\n            }\n        }\n        CalendarContainerResource resource = new CalendarContainerResource(calendarModels, calendarEventModels);\n        return new ExportResult<>(ExportResult.ResultType.END, resource, null);\n    }","code":"@Override\n    public ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\n        Request.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\n        List<CalendarModel> calendarModels = new ArrayList<>();\n        try (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\n            ResponseBody body = graphResponse.body();\n            if (body == null) {\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n            }\n            String graphBody = new String(body.bytes());\n            Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n           \n           \n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\n            if (rawCalendars == null) {\n                return new ExportResult<>(ExportResult.ResultType.END);\n            }\n            for (Map<String, Object> rawCalendar : rawCalendars) {\n                TransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\n                if (result.hasProblems()) {\n                   \n                   \n                    continue;\n                }\n                calendarModels.add(result.getTransformed());\n            }\n        } catch (IOException e) {\n            e.printStackTrace(); \n            return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n        }\n        List<CalendarEventModel> calendarEventModels = new ArrayList<>();\n        for (CalendarModel calendarModel : calendarModels) {\n            String id = calendarModel.getId();\n            Request.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\n            try (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\n                ResponseBody body = graphResponse.body();\n                if (body == null) {\n                    return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n                }\n                String graphBody = new String(body.bytes());\n                Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n               \n               \n                @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\n                if (rawEvents == null) {\n                    return new ExportResult<>(ExportResult.ResultType.END);\n                }\n                for (Map<String, Object> rawEvent : rawEvents) {\n                    Map<String, String> properties = new HashMap<>();\n                    properties.put(CALENDAR_ID, id);\n                    TransformResult<CalendarEventModel> result = transformerService.transform(CalendarEventModel.class, rawEvent, properties);\n                    if (result.hasProblems()) {\n                       \n                       \n                        continue;\n                    }\n                    calendarEventModels.add(result.getTransformed());\n                }\n            } catch (IOException e) {\n                e.printStackTrace(); \n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: \" + e.getMessage());\n            }\n        }\n        CalendarContainerResource resource = new CalendarContainerResource(calendarModels, calendarEventModels);\n        return new ExportResult<>(ExportResult.ResultType.END, resource, null);\n    }","cleancode":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","comment":"\/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink));\n\/\/ discard \/\/ fixme log problem\n\/\/ fixme log error\n\/\/ todo string nextlink = (string) graphmap.get(odata_next); \/\/ todo continuationdata continuationdata = nextlink == null ? null : new continuationdata(new graphpagination(nextlink));\n\/\/ discard \/\/ fixme log problem\n\/\/ fixme log error","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project","code_context_2":"String graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\n\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\n\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\n\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\n\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\n\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}","code_context_10":"public ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\n\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n\npublic ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\n\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");","code_context_20":"@Override\npublic ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\n\n@Override\npublic ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawEvents == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawEvent : rawEvents) {\n\n@Override\npublic ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\n\n@Override\npublic ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\nRequest.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\nList<CalendarModel> calendarModels = new ArrayList<>();\ntry (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawCalendars == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawCalendar : rawCalendars) {\nTransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\nif (result.hasProblems()) {\n\/\/ discard\n\/\/ FIXME log problem\ncontinue;\n}\ncalendarModels.add(result.getTransformed());\n}\n} catch (IOException e) {\ne.printStackTrace(); \/\/ FIXME log error\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n}\nList<CalendarEventModel> calendarEventModels = new ArrayList<>();\nfor (CalendarModel calendarModel : calendarModels) {\nString id = calendarModel.getId();\nRequest.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\ntry (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\nResponseBody body = graphResponse.body();\nif (body == null) {\nreturn new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n}\nString graphBody = new String(body.bytes());\nMap graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n\/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n\/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n@SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\nif (rawEvents == null) {\nreturn new ExportResult<>(ExportResult.ResultType.END);\n}\nfor (Map<String, Object> rawEvent : rawEvents) {","label":[0,0,1,0]}
{"id":9775,"original_code":"public static void main(String[] args) {\n\t\tFile dir = new File(\".\");\n\t\tArrays.stream(dir.listFiles()).forEach(file -> {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\t\/\/ Ouch, my fingers hurt! All this typing!\n\t\t});\n\t\t\/\/ TODO use Unchecked.consumer from JOOL library\n\t\t\/\/ SOLUTION(\n\t\tArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\n\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t}));\n\t\t\/\/ SOLUTION)\n\t}","code":"public static void main(String[] args) {\n\t\tFile dir = new File(\".\");\n\t\tArrays.stream(dir.listFiles()).forEach(file -> {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\n\t\t});\n\t\n\t\n\t\tArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\n\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t}));\n\t\n\t}","cleancode":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } }); arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); }","comment":"\/\/ ouch, my fingers hurt! all this typing!\n\/\/ todo use unchecked.consumer from jool library \/\/ solution(\n\/\/ solution)","repo":"AdrianaDinca\/training","code_context_2":"throw new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}","code_context_10":"public static void main(String[] args) {\nFile dir = new File(\".\");\nArrays.stream(dir.listFiles()).forEach(file -> {\ntry {\nSystem.out.println(file.getCanonicalPath());\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}\n\npublic static void main(String[] args) {\nFile dir = new File(\".\");\nArrays.stream(dir.listFiles()).forEach(file -> {\ntry {\nSystem.out.println(file.getCanonicalPath());\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}\n\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}","code_context_20":"public static void main(String[] args) {\nFile dir = new File(\".\");\nArrays.stream(dir.listFiles()).forEach(file -> {\ntry {\nSystem.out.println(file.getCanonicalPath());\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}\n\npublic static void main(String[] args) {\nFile dir = new File(\".\");\nArrays.stream(dir.listFiles()).forEach(file -> {\ntry {\nSystem.out.println(file.getCanonicalPath());\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}\n\npublic static void main(String[] args) {\nFile dir = new File(\".\");\nArrays.stream(dir.listFiles()).forEach(file -> {\ntry {\nSystem.out.println(file.getCanonicalPath());\n} catch (IOException e) {\nthrow new RuntimeException(e);\n}\n\/\/ Ouch, my fingers hurt! All this typing!\n});\n\/\/ TODO use Unchecked.consumer from JOOL library\n\/\/ SOLUTION(\nArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\nSystem.out.println(file.getCanonicalPath());\n}));\n\/\/ SOLUTION)\n}","label":[0,0,0,0]}
{"id":1657,"original_code":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (replaceWith == null) {\n\t\t\treplaceWith = \"\";\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tresult.append(origStr.substring(0, index));\n\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\tresult.append(findThis);\n\t\t\t} else {\n\t\t\t\tresult.append(replaceWith);\n\t\t\t}\n\t\t\t\/\/ TODO :: improve speed by not calling substring but keeping track of start!\n\t\t\torigStr = origStr.substring(index + findThis.length());\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","code":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (replaceWith == null) {\n\t\t\treplaceWith = \"\";\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tresult.append(origStr.substring(0, index));\n\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\tresult.append(findThis);\n\t\t\t} else {\n\t\t\t\tresult.append(replaceWith);\n\t\t\t}\n\t\t\n\t\t\torigStr = origStr.substring(index + findThis.length());\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","cleancode":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","comment":"\/** * replaces all except if a match is immediately preceded by a > sign, in which case this * match is not replaced *\/\n\/\/ todo :: improve speed by not calling substring but keeping track of start!","repo":"ASofterSpace\/Toolbox-Java","code_context_2":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\nif (origStr == null) {\nreturn null;\n}\nif (findThis == null) {\nreturn origStr;\n}\nif (replaceWith == null) {\nreplaceWith = \"\";\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nresult.append(origStr.substring(0, index));\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nresult.append(findThis);\n} else {\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}\n\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);","code_context_10":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\nif (origStr == null) {\nreturn null;\n}\nif (findThis == null) {\nreturn origStr;\n}\nif (replaceWith == null) {\nreplaceWith = \"\";\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nresult.append(origStr.substring(0, index));\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nresult.append(findThis);\n} else {\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}\n\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nresult.append(origStr.substring(0, index));\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nresult.append(findThis);\n} else {\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}","code_context_20":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\nif (origStr == null) {\nreturn null;\n}\nif (findThis == null) {\nreturn origStr;\n}\nif (replaceWith == null) {\nreplaceWith = \"\";\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nresult.append(origStr.substring(0, index));\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nresult.append(findThis);\n} else {\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}\n\npublic static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\nif (origStr == null) {\nreturn null;\n}\nif (findThis == null) {\nreturn origStr;\n}\nif (replaceWith == null) {\nreplaceWith = \"\";\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nresult.append(origStr.substring(0, index));\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nresult.append(findThis);\n} else {\nresult.append(replaceWith);\n}\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(index + findThis.length());\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}","label":[1,0,0,0]}
{"id":1659,"original_code":"private static String addAfterLinesContainingEx(String origStr, String findThis, String addThat,\n\t\tString eolMarker, boolean notInsideTag) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((addThat == null) || \"\".equals(addThat)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((eolMarker == null) || \"\".equals(eolMarker)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (\"\".equals(findThis)) {\n\t\t\treturn replaceAll(origStr, \"\\n\", \"\\n\" + addThat) + \"\\n\" + addThat;\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tif (notInsideTag) {\n\t\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\t\tindex = origStr.indexOf(findThis, index + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint eol = origStr.indexOf(eolMarker, index);\n\t\t\tif (eol < 0) {\n\t\t\t\tresult.append(origStr);\n\t\t\t\tresult.append(eolMarker);\n\t\t\t\torigStr = \"\";\n\t\t\t} else {\n\t\t\t\tresult.append(origStr.substring(0, eol + eolMarker.length()));\n\t\t\t\t\/\/ TODO :: improve speed by not calling substring but keeping track of start!\n\t\t\t\torigStr = origStr.substring(eol + eolMarker.length());\n\t\t\t}\n\t\t\tresult.append(addThat);\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","code":"private static String addAfterLinesContainingEx(String origStr, String findThis, String addThat,\n\t\tString eolMarker, boolean notInsideTag) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((addThat == null) || \"\".equals(addThat)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((eolMarker == null) || \"\".equals(eolMarker)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (\"\".equals(findThis)) {\n\t\t\treturn replaceAll(origStr, \"\\n\", \"\\n\" + addThat) + \"\\n\" + addThat;\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tif (notInsideTag) {\n\t\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\t\tindex = origStr.indexOf(findThis, index + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint eol = origStr.indexOf(eolMarker, index);\n\t\t\tif (eol < 0) {\n\t\t\t\tresult.append(origStr);\n\t\t\t\tresult.append(eolMarker);\n\t\t\t\torigStr = \"\";\n\t\t\t} else {\n\t\t\t\tresult.append(origStr.substring(0, eol + eolMarker.length()));\n\t\t\t\n\t\t\t\torigStr = origStr.substring(eol + eolMarker.length());\n\t\t\t}\n\t\t\tresult.append(addThat);\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","cleancode":"private static string addafterlinescontainingex(string origstr, string findthis, string addthat, string eolmarker, boolean notinsidetag) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if ((addthat == null) || \"\".equals(addthat)) { return origstr; } if ((eolmarker == null) || \"\".equals(eolmarker)) { return origstr; } if (\"\".equals(findthis)) { return replaceall(origstr, \"\\n\", \"\\n\" + addthat) + \"\\n\" + addthat; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { if (notinsidetag) { if ((index > 0) && origstr.charat(index - 1) == '>') { index = origstr.indexof(findthis, index + 1); continue; } } int eol = origstr.indexof(eolmarker, index); if (eol < 0) { result.append(origstr); result.append(eolmarker); origstr = \"\"; } else { result.append(origstr.substring(0, eol + eolmarker.length())); origstr = origstr.substring(eol + eolmarker.length()); } result.append(addthat); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","comment":"\/\/ todo :: improve speed by not calling substring but keeping track of start!","repo":"ASofterSpace\/Toolbox-Java","code_context_2":"} else {\nresult.append(origStr.substring(0, eol + eolMarker.length()));\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(eol + eolMarker.length());\n}","code_context_10":"continue;\n}\n}\nint eol = origStr.indexOf(eolMarker, index);\nif (eol < 0) {\nresult.append(origStr);\nresult.append(eolMarker);\norigStr = \"\";\n} else {\nresult.append(origStr.substring(0, eol + eolMarker.length()));\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(eol + eolMarker.length());\n}\nresult.append(addThat);\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}","code_context_20":"}\nif (\"\".equals(findThis)) {\nreturn replaceAll(origStr, \"\\n\", \"\\n\" + addThat) + \"\\n\" + addThat;\n}\nStringBuilder result = new StringBuilder();\nint index = origStr.indexOf(findThis);\nwhile (index >= 0) {\nif (notInsideTag) {\nif ((index > 0) && origStr.charAt(index - 1) == '>') {\nindex = origStr.indexOf(findThis, index + 1);\ncontinue;\n}\n}\nint eol = origStr.indexOf(eolMarker, index);\nif (eol < 0) {\nresult.append(origStr);\nresult.append(eolMarker);\norigStr = \"\";\n} else {\nresult.append(origStr.substring(0, eol + eolMarker.length()));\n\/\/ TODO :: improve speed by not calling substring but keeping track of start!\norigStr = origStr.substring(eol + eolMarker.length());\n}\nresult.append(addThat);\nindex = origStr.indexOf(findThis);\n}\nresult.append(origStr);\nreturn result.toString();\n}","label":[1,0,0,0]}
{"id":9929,"original_code":"@Nullable\n  public String getPartitionColumn() {\n    return _partitionColumn;\n  }","code":"@Nullable\n  public String getPartitionColumn() {\n    return _partitionColumn;\n  }","cleancode":"@nullable public string getpartitioncolumn() { return _partitioncolumn; }","comment":"\/** * returns the name of column used for partitioning. if this is set to null, we use the table level replica groups. * otherwise, we use the partition level replica groups. * todo: use partition info from segmentpartitionconfig * * @return name of partitioning column. *\/","repo":"HoraceChoi95\/incubator-pinot","code_context_2":"@Nullable\npublic String getPartitionColumn() {\nreturn _partitionColumn;\n}","code_context_10":"@Nullable\npublic String getPartitionColumn() {\nreturn _partitionColumn;\n}","code_context_20":"@Nullable\npublic String getPartitionColumn() {\nreturn _partitionColumn;\n}","label":[0,1,0,0]}
{"id":10010,"original_code":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    \/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    \/\/ side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    \/\/ find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    \/\/ We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    \/\/ So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      \/\/ The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        \/\/ Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      \/\/ No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      \/\/ The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        \/\/ Yes: return what we just built\n        return rval;\n      }\n      \/\/ No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }","code":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n   \n   \n   \n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n   \n   \n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n     \n      if (testPointInside) {\n       \n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n     \n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n     \n      if (!testPointInside) {\n       \n        return rval;\n      }\n     \n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }","cleancode":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { if (testpointinside) { rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { if (!testpointinside) { return rval; } rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","comment":"\/** * create a geopolygon using the specified points and holes and a test point. * * @param filteredpointlist is a filtered list of the geopoints to build an arbitrary polygon out of. * @param holes is a list of polygons representing \"holes\" in the outside polygon. null == none. * @param testpoint is a test point that is either known to be within the polygon area, or not. * @param testpointinside is true if the test point is within the area, false otherwise. * @return a geopolygon corresponding to what was specified, or null if what was specified * cannot be turned into a valid non-degenerate polygon. *\/\n\/\/ we will be trying twice to find the right geopolygon, using alternate siding choices for the first polygon \/\/ side. while this looks like it might be 2x as expensive as it could be, there's really no other choice i can \/\/ find.\n\/\/ we don't know if this is the correct siding choice. we will only know as we build the complex polygon. \/\/ so we need to be prepared to try both possibilities.\n\/\/ the testpoint was within the shape. was that intended?\n\/\/ yes: build it for real\n\/\/ no: do the complement and return that.\n\/\/ the testpoint was outside the shape. was that intended?\n\/\/ yes: return what we just built\n\/\/ no: return the complement","repo":"AliGhaff\/testLucene","code_context_2":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\n\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\n\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\n\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\n\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\n\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();","code_context_10":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\n\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}","code_context_20":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\n\nstatic GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\nfinal List<GeoPoint> filteredPointList,\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n\nfinal List<GeoPolygon> holes,\nfinal GeoPoint testPoint,\nfinal boolean testPointInside) {\n\/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n\/\/ side. While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n\/\/ find.\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nfinal SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n\/\/ We don't know if this is the correct siding choice. We will only know as we build the complex polygon.\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\n\/\/ So we need to be prepared to try both possibilities.\nGeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\nMutableBoolean seenConcave = new MutableBoolean();\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}\n\nif (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n\/\/ The testPoint was within the shape. Was that intended?\nif (testPointInside) {\n\/\/ Yes: build it for real\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\nreturn rval;\n}\n\/\/ No: do the complement and return that.\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n} else {\n\/\/ The testPoint was outside the shape. Was that intended?\nif (!testPointInside) {\n\/\/ Yes: return what we just built\nreturn rval;\n}\n\/\/ No: return the complement\nrval = new GeoCompositePolygon(planetModel);\nseenConcave = new MutableBoolean();\nbuildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\nreturn rval;\n}\n}","label":[1,0,0,0]}
{"id":10073,"original_code":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\n            throws ParseException {\n        \/\/ Note that that this could be a double byte character\n        \/\/ set - bug report by Masafumi Watanabe\n        computeContentLength(content);\n        if ((!computeContentLength)) {\n            if ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n                    || this.contentLengthHeader.getContentLength() < givenLength) {\n                throw new ParseException(\"Invalid content length \"\n                        + this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n            }\n        }\n        messageContent = null;\n        messageContentBytes = content;\n        messageContentObject = null;\n    }","code":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\n            throws ParseException {\n       \n       \n        computeContentLength(content);\n        if ((!computeContentLength)) {\n            if ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n                    || this.contentLengthHeader.getContentLength() < givenLength) {\n                throw new ParseException(\"Invalid content length \"\n                        + this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n            }\n        }\n        messageContent = null;\n        messageContentBytes = content;\n        messageContentObject = null;\n    }","cleancode":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","comment":"\/** * set the message content for this message. * * @param content message body as a string. *\/\n\/\/ note that that this could be a double byte character \/\/ set - bug report by masafumi watanabe","repo":"E-C-Group\/jsip","code_context_2":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {\nif ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n|| this.contentLengthHeader.getContentLength() < givenLength) {\nthrow new ParseException(\"Invalid content length \"\n+ this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n}\n}\nmessageContent = null;\nmessageContentBytes = content;\nmessageContentObject = null;\n}\n\npublic void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {","code_context_10":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {\nif ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n|| this.contentLengthHeader.getContentLength() < givenLength) {\nthrow new ParseException(\"Invalid content length \"\n+ this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n}\n}\nmessageContent = null;\nmessageContentBytes = content;\nmessageContentObject = null;\n}\n\npublic void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {\nif ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n|| this.contentLengthHeader.getContentLength() < givenLength) {\nthrow new ParseException(\"Invalid content length \"\n+ this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n}\n}\nmessageContent = null;\nmessageContentBytes = content;","code_context_20":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {\nif ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n|| this.contentLengthHeader.getContentLength() < givenLength) {\nthrow new ParseException(\"Invalid content length \"\n+ this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n}\n}\nmessageContent = null;\nmessageContentBytes = content;\nmessageContentObject = null;\n}\n\npublic void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\nthrows ParseException {\n\/\/ Note that that this could be a double byte character\n\/\/ set - bug report by Masafumi Watanabe\ncomputeContentLength(content);\nif ((!computeContentLength)) {\nif ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n|| this.contentLengthHeader.getContentLength() < givenLength) {\nthrow new ParseException(\"Invalid content length \"\n+ this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n}\n}\nmessageContent = null;\nmessageContentBytes = content;\nmessageContentObject = null;\n}","label":[0,0,1,0]}
{"id":2275,"original_code":"void doJob() {\n\t\t\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\t\t\/\/init\n\t\tfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\n\t\tSurfaceTexture surface = tv.getSurfaceTexture();\n\t\tTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\n\t\tView view = getWindow().getDecorView();\n\t\trt.init(surface);\n\t\trt.begin();\n\t\tint[] buf = new int[1];\n\t\tglGenTextures(1, buf, 0);\n\t\tint texName = buf[0];\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\t\tFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n\t\t\t\t* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\n\t\ttriangleVertices.put(mTriangleVerticesData).position(0);\n\t\tint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\n\t\tint attribPosition = glGetAttribLocation(program, \"position\");\n\t\tcheckGlError();\n\t\tint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\n\t\tcheckGlError();\n\t\tint uniformTexture = glGetUniformLocation(program, \"texture\");\n\t\tcheckGlError();\n\t    int textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\n\t\tcheckGlError();\n\t\tSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\n\t\tHwUiRender render = HwUiRender.create(this);\n\t\trender.setSurface(tex);\n\t\t\/\/draw\n\t\tfor(int i=0;i<1;++i) {\n\t\tlong startTime = System.currentTimeMillis();\n\t\trender.drawToSurface(view);\n\t\trt.begin();\/\/TODO: replace on check & makecurrent\n\t\ttex.updateTexImage();\n\t\tfloat[] texTransform = new float[16];\n\t\ttex.getTransformMatrix(texTransform);\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tcheckGlError();\n\t\tglUseProgram(program);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribPosition);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribTexCoords);\n\t\tcheckGlError();\n\t\tglUniform1i(uniformTexture, 0);\n\t\tglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\n\t\tglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\n\t\tglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\t\trt.end();\n\t\tmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n\t\t}\n\t\trender.setSurface(null);\n\t\t\/\/rt.cleanup();\n\t}","code":"void doJob() {\n\t\n\t\n\t\tfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\n\t\tSurfaceTexture surface = tv.getSurfaceTexture();\n\t\tTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\n\t\tView view = getWindow().getDecorView();\n\t\trt.init(surface);\n\t\trt.begin();\n\t\tint[] buf = new int[1];\n\t\tglGenTextures(1, buf, 0);\n\t\tint texName = buf[0];\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\t\tFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n\t\t\t\t* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\n\t\ttriangleVertices.put(mTriangleVerticesData).position(0);\n\t\tint program = buildProgram(sSimpleVS, sBasicFS);\n\t\tint attribPosition = glGetAttribLocation(program, \"position\");\n\t\tcheckGlError();\n\t\tint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\n\t\tcheckGlError();\n\t\tint uniformTexture = glGetUniformLocation(program, \"texture\");\n\t\tcheckGlError();\n\t    int textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\n\t\tcheckGlError();\n\t\tSurfaceTexture tex = new SurfaceTexture(texName)\n\t\tHwUiRender render = HwUiRender.create(this);\n\t\trender.setSurface(tex);\n\t\n\t\tfor(int i=0;i<1;++i) {\n\t\tlong startTime = System.currentTimeMillis();\n\t\trender.drawToSurface(view);\n\t\trt.begin()\n\t\ttex.updateTexImage();\n\t\tfloat[] texTransform = new float[16];\n\t\ttex.getTransformMatrix(texTransform);\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tcheckGlError();\n\t\tglUseProgram(program);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribPosition);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribTexCoords);\n\t\tcheckGlError();\n\t\tglUniform1i(uniformTexture, 0);\n\t\tglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\n\t\tglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\n\t\tglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\t\trt.end();\n\t\tmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n\t\t}\n\t\trender.setSurface(null);\n\t\n\t}","cleancode":"void dojob() { final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname) hwuirender render = hwuirender.create(this); render.setsurface(tex); for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin() tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); }","comment":"\/\/mrenderthread = new renderthread(getresources(), surface, v); \/\/init\n\/*ssimplefs*\/\n\/\/todo: wait for onframeavailable() ??\n\/\/draw\n\/\/todo: replace on check & makecurrent\n\/\/rt.cleanup();","repo":"ChGen\/AndroidGpuGraphicsTest","code_context_2":"void doJob() {\n\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\/\/init\nfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\nSurfaceTexture surface = tv.getSurfaceTexture();\n\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\n\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\n\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\n\n}\nrender.setSurface(null);\n\/\/rt.cleanup();\n}","code_context_10":"void doJob() {\n\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\/\/init\nfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\nSurfaceTexture surface = tv.getSurfaceTexture();\nTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\nView view = getWindow().getDecorView();\nrt.init(surface);\nrt.begin();\nint[] buf = new int[1];\nglGenTextures(1, buf, 0);\nint texName = buf[0];\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\nglGenTextures(1, buf, 0);\nint texName = buf[0];\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\n\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\n\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\ncheckGlError();\nglUseProgram(program);\n\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\ncheckGlError();\nglUseProgram(program);\ncheckGlError();\nglEnableVertexAttribArray(attribPosition);\ncheckGlError();\nglEnableVertexAttribArray(attribTexCoords);\n\nTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\nglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\nTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nrt.end();\nmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n}\nrender.setSurface(null);\n\/\/rt.cleanup();\n}","code_context_20":"void doJob() {\n\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\/\/init\nfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\nSurfaceTexture surface = tv.getSurfaceTexture();\nTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\nView view = getWindow().getDecorView();\nrt.init(surface);\nrt.begin();\nint[] buf = new int[1];\nglGenTextures(1, buf, 0);\nint texName = buf[0];\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\n\nvoid doJob() {\n\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\/\/init\nfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\nSurfaceTexture surface = tv.getSurfaceTexture();\nTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\nView view = getWindow().getDecorView();\nrt.init(surface);\nrt.begin();\nint[] buf = new int[1];\nglGenTextures(1, buf, 0);\nint texName = buf[0];\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\nint[] buf = new int[1];\nglGenTextures(1, buf, 0);\nint texName = buf[0];\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\ncheckGlError();\nglUseProgram(program);\ncheckGlError();\nglEnableVertexAttribArray(attribPosition);\ncheckGlError();\nglEnableVertexAttribArray(attribTexCoords);\ncheckGlError();\nglUniform1i(uniformTexture, 0);\nglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\n\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\ncheckGlError();\nglUseProgram(program);\ncheckGlError();\nglEnableVertexAttribArray(attribPosition);\ncheckGlError();\nglEnableVertexAttribArray(attribTexCoords);\ncheckGlError();\nglUniform1i(uniformTexture, 0);\nglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\nglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\n\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\ntriangleVertices.put(mTriangleVerticesData).position(0);\nint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\nint attribPosition = glGetAttribLocation(program, \"position\");\ncheckGlError();\nint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\ncheckGlError();\nint uniformTexture = glGetUniformLocation(program, \"texture\");\ncheckGlError();\nint textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\ncheckGlError();\nSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\nHwUiRender render = HwUiRender.create(this);\nrender.setSurface(tex);\n\/\/draw\nfor(int i=0;i<1;++i) {\nlong startTime = System.currentTimeMillis();\nrender.drawToSurface(view);\nrt.begin();\/\/TODO: replace on check & makecurrent\ntex.updateTexImage();\nfloat[] texTransform = new float[16];\ntex.getTransformMatrix(texTransform);\nglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\ncheckGlError();\nglUseProgram(program);\ncheckGlError();\nglEnableVertexAttribArray(attribPosition);\ncheckGlError();\nglEnableVertexAttribArray(attribTexCoords);\ncheckGlError();\nglUniform1i(uniformTexture, 0);\nglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\nglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\nTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\nglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\n\ncheckGlError();\nglEnableVertexAttribArray(attribPosition);\ncheckGlError();\nglEnableVertexAttribArray(attribTexCoords);\ncheckGlError();\nglUniform1i(uniformTexture, 0);\nglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\nglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\nTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\ncheckGlError();\ntriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\nglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\nTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\nglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\nrt.end();\nmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n}\nrender.setSurface(null);\n\/\/rt.cleanup();\n}","label":[0,1,0,0]}
{"id":18664,"original_code":"@Test\n    public void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\n        Event event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\n                tag(\"description\", Variant.ofString(\"This is the annotation\")).\n                tag(\"tags\", Variant.ofVector(Vector.ofContainers(\n                        Container.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\n                        Container.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\n                build();\n        Properties properties = new Properties();\n        properties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\n        EventToJsonFormatter formatter = new EventToJsonFormatter(properties);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        DocumentWriter.writeTo(stream, formatter.format(event));\n        assertEquals(\"{\" +\n                        \"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n                        \"\\\"environment\\\":\\\"staging\\\",\" +\n                        \"\\\"project\\\":\\\"test\\\",\" +\n                        \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n                        \"\\\"description\\\":\\\"This is the annotation\\\"\" +\n                        \"}\",\n                stream.toString(StandardCharsets.UTF_8.name())\n        );\n    }","code":"@Test\n    public void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\n        Event event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\n                tag(\"description\", Variant.ofString(\"This is the annotation\")).\n                tag(\"tags\", Variant.ofVector(Vector.ofContainers(\n                        Container.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\n                        Container.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\n                build();\n        Properties properties = new Properties();\n        properties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\n        EventToJsonFormatter formatter = new EventToJsonFormatter(properties);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        DocumentWriter.writeTo(stream, formatter.format(event));\n        assertEquals(\"{\" +\n                        \"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n                        \"\\\"environment\\\":\\\"staging\\\",\" +\n                        \"\\\"project\\\":\\\"test\\\",\" +\n                        \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n                        \"\\\"description\\\":\\\"This is the annotation\\\"\" +\n                        \"}\",\n                stream.toString(StandardCharsets.UTF_8.name())\n        );\n    }","cleancode":"@test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","comment":"\/** * fixme: delete this test with a workaround in the grafanaannotationtagstransformer * * @throws ioexception should never happen *\/","repo":"InHavk\/hercules","code_context_2":"@Test\npublic void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\nEvent event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\ntag(\"description\", Variant.ofString(\"This is the annotation\")).\ntag(\"tags\", Variant.ofVector(Vector.ofContainers(\nContainer.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\nContainer.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\nbuild();\nProperties properties = new Properties();\nproperties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\nEventToJsonFormatter formatter = new EventToJsonFormatter(properties);\nByteArrayOutputStream stream = new ByteArrayOutputStream();\nDocumentWriter.writeTo(stream, formatter.format(event));\nassertEquals(\"{\" +\n\"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n\"\\\"environment\\\":\\\"staging\\\",\" +\n\"\\\"project\\\":\\\"test\\\",\" +\n\"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n\"\\\"description\\\":\\\"This is the annotation\\\"\" +\n\"}\",\nstream.toString(StandardCharsets.UTF_8.name())\n);\n}","code_context_10":"@Test\npublic void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\nEvent event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\ntag(\"description\", Variant.ofString(\"This is the annotation\")).\ntag(\"tags\", Variant.ofVector(Vector.ofContainers(\nContainer.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\nContainer.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\nbuild();\nProperties properties = new Properties();\nproperties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\nEventToJsonFormatter formatter = new EventToJsonFormatter(properties);\nByteArrayOutputStream stream = new ByteArrayOutputStream();\nDocumentWriter.writeTo(stream, formatter.format(event));\nassertEquals(\"{\" +\n\"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n\"\\\"environment\\\":\\\"staging\\\",\" +\n\"\\\"project\\\":\\\"test\\\",\" +\n\"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n\"\\\"description\\\":\\\"This is the annotation\\\"\" +\n\"}\",\nstream.toString(StandardCharsets.UTF_8.name())\n);\n}","code_context_20":"@Test\npublic void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\nEvent event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\ntag(\"description\", Variant.ofString(\"This is the annotation\")).\ntag(\"tags\", Variant.ofVector(Vector.ofContainers(\nContainer.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\nContainer.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\nbuild();\nProperties properties = new Properties();\nproperties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\nEventToJsonFormatter formatter = new EventToJsonFormatter(properties);\nByteArrayOutputStream stream = new ByteArrayOutputStream();\nDocumentWriter.writeTo(stream, formatter.format(event));\nassertEquals(\"{\" +\n\"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n\"\\\"environment\\\":\\\"staging\\\",\" +\n\"\\\"project\\\":\\\"test\\\",\" +\n\"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n\"\\\"description\\\":\\\"This is the annotation\\\"\" +\n\"}\",\nstream.toString(StandardCharsets.UTF_8.name())\n);\n}","label":[1,0,0,0]}
{"id":18794,"original_code":"@Test\n        public void test() {\n                ChatDirector chatDirector = new ChatDirector(new File(\n                                this.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\n                assertTrue(chatDirector.load());\n                \/\/ Checking Chain metrics\n                assertTrue(chatDirector.getChains().size() == 5);\n                assertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\n                assertNotNull(chatDirector.getChains().get(\"loading-test\"));\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\"));\n                assertNotNull(chatDirector.getChains().get(\"echo-test\"));\n                assertNotNull(chatDirector.getChains().get(\"halt-test\"));\n                assertNotNull(chatDirector.getChains().get(\"reload-test\"));\n                \/\/ Checking Per Chain metrics\n                assertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\n                assertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\n                assertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\n                assertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n                \/\/ Checking Each item in chain\n                IItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"%CURRENT%\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(5);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"raw string\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(6);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(7);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(8);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(2);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(3);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the third value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"hello!\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<, but before that it was >%LAST%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\n                assertTrue(item instanceof ReloadItem);\n                \/\/ TODO: Preform a check for reload?\n        }","code":"@Test\n        public void test() {\n                ChatDirector chatDirector = new ChatDirector(new File(\n                                this.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\n                assertTrue(chatDirector.load());\n               \n                assertTrue(chatDirector.getChains().size() == 5);\n                assertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\n                assertNotNull(chatDirector.getChains().get(\"loading-test\"));\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\"));\n                assertNotNull(chatDirector.getChains().get(\"echo-test\"));\n                assertNotNull(chatDirector.getChains().get(\"halt-test\"));\n                assertNotNull(chatDirector.getChains().get(\"reload-test\"));\n               \n                assertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\n                assertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\n                assertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\n                assertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n               \n                IItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"%CURRENT%\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(5);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"raw string\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(6);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(7);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(8);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(2);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(3);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the third value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"hello!\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<, but before that it was >%LAST%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\n                assertTrue(item instanceof ReloadItem);\n               \n        }","cleancode":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); }","comment":"\/\/ checking chain metrics\n\/\/ checking per chain metrics\n\/\/ checking each item in chain\n\/\/ todo: preform a check for reload?","repo":"AtomicPulsee\/ChatDirector","code_context_2":"this.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\nassertTrue(chatDirector.load());\n\/\/ Checking Chain metrics\nassertTrue(chatDirector.getChains().size() == 5);\nassertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\n\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\nassertNotNull(chatDirector.getChains().get(\"reload-test\"));\n\/\/ Checking Per Chain metrics\nassertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\n\nassertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n\/\/ Checking Each item in chain\nIItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\nassertTrue(item instanceof BreakItem);\n\nitem = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\nassertTrue(item instanceof ReloadItem);\n\/\/ TODO: Preform a check for reload?\n}","code_context_10":"@Test\npublic void test() {\nChatDirector chatDirector = new ChatDirector(new File(\nthis.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\nassertTrue(chatDirector.load());\n\/\/ Checking Chain metrics\nassertTrue(chatDirector.getChains().size() == 5);\nassertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\nassertNotNull(chatDirector.getChains().get(\"loading-test\"));\nassertNotNull(chatDirector.getChains().get(\"breaking-test\"));\nassertNotNull(chatDirector.getChains().get(\"echo-test\"));\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\n\nassertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\nassertNotNull(chatDirector.getChains().get(\"loading-test\"));\nassertNotNull(chatDirector.getChains().get(\"breaking-test\"));\nassertNotNull(chatDirector.getChains().get(\"echo-test\"));\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\nassertNotNull(chatDirector.getChains().get(\"reload-test\"));\n\/\/ Checking Per Chain metrics\nassertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\nassertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\nassertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\nassertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\n\nassertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\nassertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\nassertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\nassertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n\/\/ Checking Each item in chain\nIItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\nassertTrue(item instanceof BreakItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\nassertTrue(item instanceof BreakItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\nassertTrue(item instanceof EchoItem);\n\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This is the first value\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This is the second value\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\nassertTrue(item instanceof ReloadItem);\n\/\/ TODO: Preform a check for reload?\n}","code_context_20":"@Test\npublic void test() {\nChatDirector chatDirector = new ChatDirector(new File(\nthis.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\nassertTrue(chatDirector.load());\n\/\/ Checking Chain metrics\nassertTrue(chatDirector.getChains().size() == 5);\nassertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\nassertNotNull(chatDirector.getChains().get(\"loading-test\"));\nassertNotNull(chatDirector.getChains().get(\"breaking-test\"));\nassertNotNull(chatDirector.getChains().get(\"echo-test\"));\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\nassertNotNull(chatDirector.getChains().get(\"reload-test\"));\n\/\/ Checking Per Chain metrics\nassertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\nassertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\nassertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\nassertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\n\n@Test\npublic void test() {\nChatDirector chatDirector = new ChatDirector(new File(\nthis.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\nassertTrue(chatDirector.load());\n\/\/ Checking Chain metrics\nassertTrue(chatDirector.getChains().size() == 5);\nassertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\nassertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\nassertNotNull(chatDirector.getChains().get(\"loading-test\"));\nassertNotNull(chatDirector.getChains().get(\"breaking-test\"));\nassertNotNull(chatDirector.getChains().get(\"echo-test\"));\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\nassertNotNull(chatDirector.getChains().get(\"reload-test\"));\n\/\/ Checking Per Chain metrics\nassertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\nassertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\nassertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\nassertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\nassertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n\/\/ Checking Each item in chain\nIItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\nassertTrue(item instanceof BreakItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\nassertTrue(item instanceof BreakItem);\n\nassertNotNull(chatDirector.getChains().get(\"breaking-test\"));\nassertNotNull(chatDirector.getChains().get(\"echo-test\"));\nassertNotNull(chatDirector.getChains().get(\"halt-test\"));\nassertNotNull(chatDirector.getChains().get(\"reload-test\"));\n\/\/ Checking Per Chain metrics\nassertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\nassertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\nassertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\nassertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\nassertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\nassertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\nassertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\nassertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n\/\/ Checking Each item in chain\nIItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\nassertTrue(item instanceof BreakItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\nassertTrue(item instanceof BreakItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"%CURRENT%\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(5);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"raw string\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(6);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(7);\nassertTrue(item instanceof ReloadItem);\nitem = chatDirector.getChains().get(\"loading-test\").getItems().get(8);\n\nassertEquals(\"This is the third value\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"echo-test\").getItems().get(0);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"hello!\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"echo-test\").getItems().get(1);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This was >%CURRENT%<\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"echo-test\").getItems().get(2);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This was >%CURRENT%<, but before that it was >%LAST%<\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This is the first value\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\nassertTrue(item instanceof HaltItem);\nitem = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\nassertTrue(item instanceof EchoItem);\nassertEquals(\"This is the second value\", ((EchoItem) item).format);\nitem = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\nassertTrue(item instanceof ReloadItem);\n\/\/ TODO: Preform a check for reload?\n}","label":[1,0,0,0]}
{"id":18795,"original_code":"@Override\n    public void initialize(URL location, ResourceBundle resources) {\n        \/\/ load the quiz\n        for (Question question : quiz.questions) {\n            questionsList.getItems().add(question.title);\n        }\n        populateView();\n        questionTextField.setOnKeyReleased(e -> {\n            questionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\n            quiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\n            saved = false;\n        });\n        newAnswerButton.setOnMouseClicked(e -> {\n            quiz.questions.get(currentQuestionIndex).options.add(new Option(\"\"));\n            addAnswer(questionsTilePane.getChildren().size());\n            saved = false;\n        });\n        rightAnswerComboBox.setOnAction(e -> {\n            if (rightAnswerComboBox.getItems().size() > 0) {\n                currentQuestion.answer = rightAnswerComboBox.getSelectionModel().getSelectedIndex();\n            }\n            saved = false;\n        });\n        questionsList.setOnMouseClicked(e -> {\n            int selectedIndex = questionsList.getSelectionModel().getSelectedIndex();\n            if (selectedIndex < quiz.questions.size() && selectedIndex >= 0) {\n                currentQuestionIndex = selectedIndex;\n                currentQuestion = quiz.questions.get(selectedIndex);\n            }\n            populateView();\n            saved = false;\n        });\n        newQuestionButton.setOnAction(e -> {\n            newQuestion();\n            questionsList.getItems().add(\"\");\n            currentQuestion = this.quiz.questions.get(currentQuestionIndex);\n            populateView();\n            saved = false;\n        });\n        deleteQuestionButton.setOnAction(e -> removeQuestion());\n        quizOptionsButton.setOnAction(e -> {\n            Stage stage = new Stage();\n            Window win = new Window(window.getApp(), stage, \"Settings for '\" + quiz.name + \"'\");\n            win.openView(new QuizSettingsPopupControl(quiz));\n            saved = false;\n        });\n        maxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\n            if (e.getCharacter().matches(\"[\\\\D]\")) {\n                e.consume();\n            }\n        });\n        maxPointsTextInput.setOnKeyReleased(e -> {\n            if (!maxPointsTextInput.getText().isEmpty()) {\n                currentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n            } else {\n                currentQuestion.maxReward = 50; \/\/ TODO un hardcode this\n            }\n            saved = false;\n        });\n        FileMenu.getItems().get(2).setOnAction(e -> {\n            if (!saved) {\n                askForSave();\n                closeApp = false;\n            } else {\n                window.openView(new ChooseQuizScreenControl(true));\n            }\n        });\n        FileMenu.getItems().get(0).setOnAction(e -> InitSave());\n        FileMenu.getItems().get(1).setOnAction(e -> {\n            openSaveDialog();\n        });\n        window.getStage().setOnCloseRequest(e -> {\n            if (!saved) {\n                e.consume();\n                askForSave();\n                closeApp = true;\n            }\n        });\n    }","code":"@Override\n    public void initialize(URL location, ResourceBundle resources) {\n       \n        for (Question question : quiz.questions) {\n            questionsList.getItems().add(question.title);\n        }\n        populateView();\n        questionTextField.setOnKeyReleased(e -> {\n            questionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\n            quiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\n            saved = false;\n        });\n        newAnswerButton.setOnMouseClicked(e -> {\n            quiz.questions.get(currentQuestionIndex).options.add(new Option(\"\"));\n            addAnswer(questionsTilePane.getChildren().size());\n            saved = false;\n        });\n        rightAnswerComboBox.setOnAction(e -> {\n            if (rightAnswerComboBox.getItems().size() > 0) {\n                currentQuestion.answer = rightAnswerComboBox.getSelectionModel().getSelectedIndex();\n            }\n            saved = false;\n        });\n        questionsList.setOnMouseClicked(e -> {\n            int selectedIndex = questionsList.getSelectionModel().getSelectedIndex();\n            if (selectedIndex < quiz.questions.size() && selectedIndex >= 0) {\n                currentQuestionIndex = selectedIndex;\n                currentQuestion = quiz.questions.get(selectedIndex);\n            }\n            populateView();\n            saved = false;\n        });\n        newQuestionButton.setOnAction(e -> {\n            newQuestion();\n            questionsList.getItems().add(\"\");\n            currentQuestion = this.quiz.questions.get(currentQuestionIndex);\n            populateView();\n            saved = false;\n        });\n        deleteQuestionButton.setOnAction(e -> removeQuestion());\n        quizOptionsButton.setOnAction(e -> {\n            Stage stage = new Stage();\n            Window win = new Window(window.getApp(), stage, \"Settings for '\" + quiz.name + \"'\");\n            win.openView(new QuizSettingsPopupControl(quiz));\n            saved = false;\n        });\n        maxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\n            if (e.getCharacter().matches(\"[\\\\D]\")) {\n                e.consume();\n            }\n        });\n        maxPointsTextInput.setOnKeyReleased(e -> {\n            if (!maxPointsTextInput.getText().isEmpty()) {\n                currentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n            } else {\n                currentQuestion.maxReward = 50;\n            }\n            saved = false;\n        });\n        FileMenu.getItems().get(2).setOnAction(e -> {\n            if (!saved) {\n                askForSave();\n                closeApp = false;\n            } else {\n                window.openView(new ChooseQuizScreenControl(true));\n            }\n        });\n        FileMenu.getItems().get(0).setOnAction(e -> InitSave());\n        FileMenu.getItems().get(1).setOnAction(e -> {\n            openSaveDialog();\n        });\n        window.getStage().setOnCloseRequest(e -> {\n            if (!saved) {\n                e.consume();\n                askForSave();\n                closeApp = true;\n            }\n        });\n    }","cleancode":"@override public void initialize(url location, resourcebundle resources) { for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> { quiz.questions.get(currentquestionindex).options.add(new option(\"\")); addanswer(questionstilepane.getchildren().size()); saved = false; }); rightanswercombobox.setonaction(e -> { if (rightanswercombobox.getitems().size() > 0) { currentquestion.answer = rightanswercombobox.getselectionmodel().getselectedindex(); } saved = false; }); questionslist.setonmouseclicked(e -> { int selectedindex = questionslist.getselectionmodel().getselectedindex(); if (selectedindex < quiz.questions.size() && selectedindex >= 0) { currentquestionindex = selectedindex; currentquestion = quiz.questions.get(selectedindex); } populateview(); saved = false; }); newquestionbutton.setonaction(e -> { newquestion(); questionslist.getitems().add(\"\"); currentquestion = this.quiz.questions.get(currentquestionindex); populateview(); saved = false; }); deletequestionbutton.setonaction(e -> removequestion()); quizoptionsbutton.setonaction(e -> { stage stage = new stage(); window win = new window(window.getapp(), stage, \"settings for '\" + quiz.name + \"'\"); win.openview(new quizsettingspopupcontrol(quiz)); saved = false; }); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); } }); filemenu.getitems().get(0).setonaction(e -> initsave()); filemenu.getitems().get(1).setonaction(e -> { opensavedialog(); }); window.getstage().setoncloserequest(e -> { if (!saved) { e.consume(); askforsave(); closeapp = true; } }); }","comment":"\/\/ load the quiz\n\/\/ todo un hardcode this","repo":"ExodiusStudios\/quizzibles","code_context_2":"@Override\npublic void initialize(URL location, ResourceBundle resources) {\n\/\/ load the quiz\nfor (Question question : quiz.questions) {\nquestionsList.getItems().add(question.title);\n\ncurrentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n} else {\ncurrentQuestion.maxReward = 50; \/\/ TODO un hardcode this\n}\nsaved = false;","code_context_10":"@Override\npublic void initialize(URL location, ResourceBundle resources) {\n\/\/ load the quiz\nfor (Question question : quiz.questions) {\nquestionsList.getItems().add(question.title);\n}\npopulateView();\nquestionTextField.setOnKeyReleased(e -> {\nquestionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\nquiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\nsaved = false;\n});\nnewAnswerButton.setOnMouseClicked(e -> {\n\n});\nmaxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\nif (e.getCharacter().matches(\"[\\\\D]\")) {\ne.consume();\n}\n});\nmaxPointsTextInput.setOnKeyReleased(e -> {\nif (!maxPointsTextInput.getText().isEmpty()) {\ncurrentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n} else {\ncurrentQuestion.maxReward = 50; \/\/ TODO un hardcode this\n}\nsaved = false;\n});\nFileMenu.getItems().get(2).setOnAction(e -> {\nif (!saved) {\naskForSave();\ncloseApp = false;\n} else {\nwindow.openView(new ChooseQuizScreenControl(true));\n}","code_context_20":"@Override\npublic void initialize(URL location, ResourceBundle resources) {\n\/\/ load the quiz\nfor (Question question : quiz.questions) {\nquestionsList.getItems().add(question.title);\n}\npopulateView();\nquestionTextField.setOnKeyReleased(e -> {\nquestionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\nquiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\nsaved = false;\n});\nnewAnswerButton.setOnMouseClicked(e -> {\nquiz.questions.get(currentQuestionIndex).options.add(new Option(\"\"));\naddAnswer(questionsTilePane.getChildren().size());\nsaved = false;\n});\nrightAnswerComboBox.setOnAction(e -> {\nif (rightAnswerComboBox.getItems().size() > 0) {\ncurrentQuestion.answer = rightAnswerComboBox.getSelectionModel().getSelectedIndex();\n}\nsaved = false;\n});\n\ncurrentQuestion = this.quiz.questions.get(currentQuestionIndex);\npopulateView();\nsaved = false;\n});\ndeleteQuestionButton.setOnAction(e -> removeQuestion());\nquizOptionsButton.setOnAction(e -> {\nStage stage = new Stage();\nWindow win = new Window(window.getApp(), stage, \"Settings for '\" + quiz.name + \"'\");\nwin.openView(new QuizSettingsPopupControl(quiz));\nsaved = false;\n});\nmaxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\nif (e.getCharacter().matches(\"[\\\\D]\")) {\ne.consume();\n}\n});\nmaxPointsTextInput.setOnKeyReleased(e -> {\nif (!maxPointsTextInput.getText().isEmpty()) {\ncurrentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n} else {\ncurrentQuestion.maxReward = 50; \/\/ TODO un hardcode this\n}\nsaved = false;\n});\nFileMenu.getItems().get(2).setOnAction(e -> {\nif (!saved) {\naskForSave();\ncloseApp = false;\n} else {\nwindow.openView(new ChooseQuizScreenControl(true));\n}\n});\nFileMenu.getItems().get(0).setOnAction(e -> InitSave());\nFileMenu.getItems().get(1).setOnAction(e -> {\nopenSaveDialog();\n});\nwindow.getStage().setOnCloseRequest(e -> {\nif (!saved) {\ne.consume();\naskForSave();\ncloseApp = true;","label":[1,0,0,0]}
{"id":10647,"original_code":"public void testBuildMalformedDocumentWithUnpairedSurrogate() \n      throws IOException {\n        String doc = \"<doc>A\\uD800A<\/doc>\";\n        try {\n            builder.build(doc, \"http:\/\/www.example.com\");   \n            fail(\"Allowed malformed doc\");\n        }\n        catch (ParsingException success) {\n            assertNotNull(success.getMessage());\n            assertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n        }\n    }","code":"public void testBuildMalformedDocumentWithUnpairedSurrogate() \n      throws IOException {\n        String doc = \"<doc>A\\uD800A<\/doc>\";\n        try {\n            builder.build(doc, \"http:\/\/www.example.com\");   \n            fail(\"Allowed malformed doc\");\n        }\n        catch (ParsingException success) {\n            assertNotNull(success.getMessage());\n            assertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n        }\n    }","cleancode":"public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","comment":"\/\/ this is testing a work-around for a xerces bug \/\/ http:\/\/nagoya.apache.org\/bugzilla\/show_bug.cgi?id=27583 \/\/ that reports this as an ioexception rather than a saxexception","repo":"Evegen55\/TIJ4_code","code_context_2":"public void testBuildMalformedDocumentWithUnpairedSurrogate()\nthrows IOException {\nString doc = \"<doc>A\\uD800A<\/doc>\";\ntry {\nbuilder.build(doc, \"http:\/\/www.example.com\");\nfail(\"Allowed malformed doc\");\n}\ncatch (ParsingException success) {\nassertNotNull(success.getMessage());\nassertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n}\n}","code_context_10":"public void testBuildMalformedDocumentWithUnpairedSurrogate()\nthrows IOException {\nString doc = \"<doc>A\\uD800A<\/doc>\";\ntry {\nbuilder.build(doc, \"http:\/\/www.example.com\");\nfail(\"Allowed malformed doc\");\n}\ncatch (ParsingException success) {\nassertNotNull(success.getMessage());\nassertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n}\n}","code_context_20":"public void testBuildMalformedDocumentWithUnpairedSurrogate()\nthrows IOException {\nString doc = \"<doc>A\\uD800A<\/doc>\";\ntry {\nbuilder.build(doc, \"http:\/\/www.example.com\");\nfail(\"Allowed malformed doc\");\n}\ncatch (ParsingException success) {\nassertNotNull(success.getMessage());\nassertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n}\n}","label":[1,0,0,0]}
{"id":2472,"original_code":"@Override\n        protected Config getConfig() {\n            Config c = new Config();\n            c.caption = \"custom tile listener\";\n            c.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n            \/\/TODO: Implement this in the future\n            \/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\n            c.bindPermission =\n                    cyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n            \/\/TODO: Implement this in the future\n            \/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\n            c.clientLabel = R.string.custom_tile_listener_binding_label;\n            return c;\n        }","code":"@Override\n        protected Config getConfig() {\n            Config c = new Config();\n            c.caption = \"custom tile listener\";\n            c.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n           \n           \n            c.bindPermission =\n                    cyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n           \n           \n            c.clientLabel = R.string.custom_tile_listener_binding_label;\n            return c;\n        }","cleancode":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","comment":"\/\/todo: implement this in the future \/\/c.securesettingname = settings.secure.enabled_custom_tile_listeners;\n\/\/todo: implement this in the future \/\/c.settingsaction = settings.action_custom_tile_listener_settings;","repo":"Ant-OS\/android_vendor_cmsdk","code_context_2":"c.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n\nc.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;","code_context_10":"@Override\nprotected Config getConfig() {\nConfig c = new Config();\nc.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n\/\/TODO: Implement this in the future\n\/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\nc.clientLabel = R.string.custom_tile_listener_binding_label;\nreturn c;\n}\n\n@Override\nprotected Config getConfig() {\nConfig c = new Config();\nc.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n\/\/TODO: Implement this in the future\n\/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\nc.clientLabel = R.string.custom_tile_listener_binding_label;\nreturn c;\n}","code_context_20":"@Override\nprotected Config getConfig() {\nConfig c = new Config();\nc.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n\/\/TODO: Implement this in the future\n\/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\nc.clientLabel = R.string.custom_tile_listener_binding_label;\nreturn c;\n}\n\n@Override\nprotected Config getConfig() {\nConfig c = new Config();\nc.caption = \"custom tile listener\";\nc.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n\/\/TODO: Implement this in the future\n\/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\nc.bindPermission =\ncyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n\/\/TODO: Implement this in the future\n\/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\nc.clientLabel = R.string.custom_tile_listener_binding_label;\nreturn c;\n}","label":[0,1,0,0]}
{"id":18884,"original_code":"@Override\n\tpublic void offer(HttpContent chunk) {\n\t\tif (this.channel.isClosed())\n\t\t\treturn;\t\t\/\/ TODO somehow connect the cancel back to netsession \n\t\tif (chunk.content().readableBytes() > this.max) {\n\t\t\tthis.channel.abort();\t\t\/\/ TODO somehow connect the cancel back to netsession\n\t\t\treturn;\n\t\t}\n\t\tByteBuf bb = chunk.content();\n\t\tbb.retain();\t\t\/\/ we will use it in upcoming send\n\t\tSystem.out.println(\"ref count a: \" + bb.refCnt());\n\t\tStreamMessage b = new StreamMessage(\"Block\", bb);\n\t\tb.setField(\"Sequence\", this.seq);\n\t\tOperationResult or = this.channel.send(b);\n\t\t\/\/ bb should now be back to 1\n\t\tSystem.out.println(\"ref count b: \" + bb.refCnt());\n\t\tif (or.hasErrors()) {\n\t\t\tthis.channel.close();\n\t\t\treturn;\n\t\t}\n\t\tthis.seq++;\n\t\t\/\/ TODO track progress if possible\n\t\t\/\/ final only if not canceled\n\t\tif (chunk instanceof LastHttpContent)\n\t\t\tthis.channel.send(MessageUtil.streamFinal());\n\t}","code":"@Override\n\tpublic void offer(HttpContent chunk) {\n\t\tif (this.channel.isClosed())\n\t\t\treturn;\t\n\t\tif (chunk.content().readableBytes() > this.max) {\n\t\t\tthis.channel.abort();\t\n\t\t\treturn;\n\t\t}\n\t\tByteBuf bb = chunk.content();\n\t\tbb.retain();\t\n\t\tSystem.out.println(\"ref count a: \" + bb.refCnt());\n\t\tStreamMessage b = new StreamMessage(\"Block\", bb);\n\t\tb.setField(\"Sequence\", this.seq);\n\t\tOperationResult or = this.channel.send(b);\n\t\n\t\tSystem.out.println(\"ref count b: \" + bb.refCnt());\n\t\tif (or.hasErrors()) {\n\t\t\tthis.channel.close();\n\t\t\treturn;\n\t\t}\n\t\tthis.seq++;\n\t\n\t\n\t\tif (chunk instanceof LastHttpContent)\n\t\t\tthis.channel.send(MessageUtil.streamFinal());\n\t}","cleancode":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; if (chunk.content().readablebytes() > this.max) { this.channel.abort(); return; } bytebuf bb = chunk.content(); bb.retain(); system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","comment":"\/\/ todo somehow connect the cancel back to netsession\n\/\/ todo somehow connect the cancel back to netsession\n\/\/ we will use it in upcoming send\n\/\/ bb should now be back to 1\n\/\/ todo track progress if possible \/\/ final only if not canceled","repo":"Gadreel\/divconq","code_context_2":"public void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\n\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\n\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\n\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\n\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());","code_context_10":"@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\n@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\n@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\n\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());\n\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());\n}","code_context_20":"@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\n\n@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\n\n@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());\n}\n\n@Override\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());\n}\n\npublic void offer(HttpContent chunk) {\nif (this.channel.isClosed())\nreturn; \/\/ TODO somehow connect the cancel back to netsession\nif (chunk.content().readableBytes() > this.max) {\nthis.channel.abort(); \/\/ TODO somehow connect the cancel back to netsession\nreturn;\n}\nByteBuf bb = chunk.content();\nbb.retain(); \/\/ we will use it in upcoming send\nSystem.out.println(\"ref count a: \" + bb.refCnt());\nStreamMessage b = new StreamMessage(\"Block\", bb);\nb.setField(\"Sequence\", this.seq);\nOperationResult or = this.channel.send(b);\n\/\/ bb should now be back to 1\nSystem.out.println(\"ref count b: \" + bb.refCnt());\nif (or.hasErrors()) {\nthis.channel.close();\nreturn;\n}\nthis.seq++;\n\/\/ TODO track progress if possible\n\/\/ final only if not canceled\nif (chunk instanceof LastHttpContent)\nthis.channel.send(MessageUtil.streamFinal());\n}","label":[1,1,0,0]}
{"id":10828,"original_code":"private Printer escapeCharacter(char c) {\n    if (c == '\"') {\n      return backslashChar(c);\n    }\n    switch (c) {\n      case '\\\\':\n        return backslashChar('\\\\');\n      case '\\r':\n        return backslashChar('r');\n      case '\\n':\n        return backslashChar('n');\n      case '\\t':\n        return backslashChar('t');\n      default:\n        if (c < 32) {\n          \/\/ TODO(bazel-team): support \\x escapes\n          return this.append(String.format(\"\\\\x%02x\", (int) c));\n        }\n        return this.append(c); \/\/ no need to support UTF-8\n    }\n  }","code":"private Printer escapeCharacter(char c) {\n    if (c == '\"') {\n      return backslashChar(c);\n    }\n    switch (c) {\n      case '\\\\':\n        return backslashChar('\\\\');\n      case '\\r':\n        return backslashChar('r');\n      case '\\n':\n        return backslashChar('n');\n      case '\\t':\n        return backslashChar('t');\n      default:\n        if (c < 32) {\n         \n          return this.append(String.format(\"\\\\x%02x\", (int) c));\n        }\n        return this.append(c);\n    }\n  }","cleancode":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); } }","comment":"\/\/ todo(bazel-team): support \\x escapes\n\/\/ no need to support utf-8","repo":"AyuMol758\/bazel","code_context_2":"default:\nif (c < 32) {\n\/\/ TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\n\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n}\n}","code_context_10":"case '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/ TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n}\n}\n\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/ TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n}\n}","code_context_20":"private Printer escapeCharacter(char c) {\nif (c == '\"') {\nreturn backslashChar(c);\n}\nswitch (c) {\ncase '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/ TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n}\n}\n\nprivate Printer escapeCharacter(char c) {\nif (c == '\"') {\nreturn backslashChar(c);\n}\nswitch (c) {\ncase '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/ TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n}\n}","label":[0,1,0,0]}
{"id":10844,"original_code":"@Override\n    public void meet(Projection node) throws RuntimeException {\n        super.meet(node);\n        ProjectionElemList list = node.getProjectionElemList();\n        String set = null;\n        StringBuilder projList = new StringBuilder();\n        boolean first = true;\n        \/\/TODO: we do not support projections from multiple pig statements yet\n        for (String name : list.getTargetNames()) {\n            set = varToSet.get(name);  \/\/TODO: overwrite\n            if (set == null) {\n                throw new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n            }\n            if (!first) {\n                projList.append(\",\");\n            }\n            first = false;\n            projList.append(name);\n        }\n        if (set == null)\n            throw new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n        \/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\n        pigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n    }","code":"@Override\n    public void meet(Projection node) throws RuntimeException {\n        super.meet(node);\n        ProjectionElemList list = node.getProjectionElemList();\n        String set = null;\n        StringBuilder projList = new StringBuilder();\n        boolean first = true;\n       \n        for (String name : list.getTargetNames()) {\n            set = varToSet.get(name); \n            if (set == null) {\n                throw new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n            }\n            if (!first) {\n                projList.append(\",\");\n            }\n            first = false;\n            projList.append(name);\n        }\n        if (set == null)\n            throw new IllegalArgumentException(\"\");\n       \n        pigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n    }","cleancode":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; for (string name : list.gettargetnames()) { set = vartoset.get(name); if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","comment":"\/\/todo: we do not support projections from multiple pig statements yet\n\/\/todo: overwrite\n\/\/todo: fill this\n\/\/suborg = foreach suborg_l generate dept, univ;","repo":"DLotts\/incubator-rya","code_context_2":"StringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\n\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}","code_context_10":"@Override\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n\n@Override\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\n\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}\n\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}","code_context_20":"@Override\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}\n\n@Override\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}\n\n@Override\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}\n\npublic void meet(Projection node) throws RuntimeException {\nsuper.meet(node);\nProjectionElemList list = node.getProjectionElemList();\nString set = null;\nStringBuilder projList = new StringBuilder();\nboolean first = true;\n\/\/TODO: we do not support projections from multiple pig statements yet\nfor (String name : list.getTargetNames()) {\nset = varToSet.get(name); \/\/TODO: overwrite\nif (set == null) {\nthrow new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n}\nif (!first) {\nprojList.append(\",\");\n}\nfirst = false;\nprojList.append(name);\n}\nif (set == null)\nthrow new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n\/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\npigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n}","label":[1,1,0,0]}
{"id":2684,"original_code":"public List<JsonMessage> processDatasets(List<String> datasetIncludeList,\n                                             List<String> datasetExcludeList,\n                                             List<String> tableExcludeList,\n                                             String dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\n        List<String> tablesIncludeList = new ArrayList<>();\n        for (String dataset : datasetIncludeList) {\n            try {\n                if (!datasetExcludeList.contains(dataset)) {\n                    List<String> tokens = Utils.tokenize(dataset, \".\", true);\n                    String projectId = tokens.get(0);\n                    String datasetId = tokens.get(1);\n                    String datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n                \/*\n                 TODO: Support tagging in multiple locations\n                 to support all locations:\n                 1- Taxonomies\/PolicyTags have to be created in each required location\n                 2- Update the Tagger Cloud Function to read one mapping per location\n                 For now, we don't submit tasks for tables in other locations than the PolicyTag location\n                 *\/\n                    if (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\n                        logger.logWarnWithTracker(runId,\n                                String.format(\n                                        \"Ignoring dataset %s in location %s. Only location %s is configured\",\n                                        dataset,\n                                        datasetLocation,\n                                        dataRegionId)\n                        );\n                        continue;\n                    }\n                    \/\/ get all tables that have DLP findings\n                    List<String> datasetTables = scanner.listChildren(projectId, datasetId);\n                    tablesIncludeList.addAll(datasetTables);\n                    if (datasetTables.isEmpty()) {\n                        String msg = String.format(\n                                \"No Tables found under dataset '%s'\",\n                                dataset);\n                        logger.logWarnWithTracker(runId, msg);\n                    } else {\n                        logger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n                    }\n                }\n            } catch (Exception exception) {\n                \/\/ log and continue\n                logger.logFailedDispatcherEntityId(runId, dataset, exception);\n            }\n        }\n        return processTables(tablesIncludeList, tableExcludeList);\n    }","code":"public List<JsonMessage> processDatasets(List<String> datasetIncludeList,\n                                             List<String> datasetExcludeList,\n                                             List<String> tableExcludeList,\n                                             String dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\n        List<String> tablesIncludeList = new ArrayList<>();\n        for (String dataset : datasetIncludeList) {\n            try {\n                if (!datasetExcludeList.contains(dataset)) {\n                    List<String> tokens = Utils.tokenize(dataset, \".\", true);\n                    String projectId = tokens.get(0);\n                    String datasetId = tokens.get(1);\n                    String datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n               \n                    if (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\n                        logger.logWarnWithTracker(runId,\n                                String.format(\n                                        \"Ignoring dataset %s in location %s. Only location %s is configured\",\n                                        dataset,\n                                        datasetLocation,\n                                        dataRegionId)\n                        );\n                        continue;\n                    }\n                   \n                    List<String> datasetTables = scanner.listChildren(projectId, datasetId);\n                    tablesIncludeList.addAll(datasetTables);\n                    if (datasetTables.isEmpty()) {\n                        String msg = String.format(\n                                \"No Tables found under dataset '%s'\",\n                                dataset);\n                        logger.logWarnWithTracker(runId, msg);\n                    } else {\n                        logger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n                    }\n                }\n            } catch (Exception exception) {\n               \n                logger.logFailedDispatcherEntityId(runId, dataset, exception);\n            }\n        }\n        return processTables(tablesIncludeList, tableExcludeList);\n    }","cleancode":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","comment":"\/* todo: support tagging in multiple locations to support all locations: 1- taxonomies\/policytags have to be created in each required location 2- update the tagger cloud function to read one mapping per location for now, we don't submit tasks for tables in other locations than the policytag location *\/\n\/\/ get all tables that have dlp findings\n\/\/ log and continue","repo":"GoogleCloudPlatform\/bq-pii-classifier","code_context_2":"String datasetId = tokens.get(1);\nString datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n\/*\nTODO: Support tagging in multiple locations\nto support all locations:\n1- Taxonomies\/PolicyTags have to be created in each required location\n2- Update the Tagger Cloud Function to read one mapping per location\nFor now, we don't submit tasks for tables in other locations than the PolicyTag location\n*\/\nif (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\nlogger.logWarnWithTracker(runId,\n\ncontinue;\n}\n\/\/ get all tables that have DLP findings\nList<String> datasetTables = scanner.listChildren(projectId, datasetId);\ntablesIncludeList.addAll(datasetTables);\n\n}\n} catch (Exception exception) {\n\/\/ log and continue\nlogger.logFailedDispatcherEntityId(runId, dataset, exception);\n}","code_context_10":"List<String> tableExcludeList,\nString dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\nList<String> tablesIncludeList = new ArrayList<>();\nfor (String dataset : datasetIncludeList) {\ntry {\nif (!datasetExcludeList.contains(dataset)) {\nList<String> tokens = Utils.tokenize(dataset, \".\", true);\nString projectId = tokens.get(0);\nString datasetId = tokens.get(1);\nString datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n\/*\nTODO: Support tagging in multiple locations\nto support all locations:\n1- Taxonomies\/PolicyTags have to be created in each required location\n2- Update the Tagger Cloud Function to read one mapping per location\nFor now, we don't submit tasks for tables in other locations than the PolicyTag location\n*\/\nif (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\nlogger.logWarnWithTracker(runId,\nString.format(\n\"Ignoring dataset %s in location %s. Only location %s is configured\",\ndataset,\ndatasetLocation,\ndataRegionId)\n);\ncontinue;\n}\n\nif (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\nlogger.logWarnWithTracker(runId,\nString.format(\n\"Ignoring dataset %s in location %s. Only location %s is configured\",\ndataset,\ndatasetLocation,\ndataRegionId)\n);\ncontinue;\n}\n\/\/ get all tables that have DLP findings\nList<String> datasetTables = scanner.listChildren(projectId, datasetId);\ntablesIncludeList.addAll(datasetTables);\nif (datasetTables.isEmpty()) {\nString msg = String.format(\n\"No Tables found under dataset '%s'\",\ndataset);\nlogger.logWarnWithTracker(runId, msg);\n} else {\nlogger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n}\n\nif (datasetTables.isEmpty()) {\nString msg = String.format(\n\"No Tables found under dataset '%s'\",\ndataset);\nlogger.logWarnWithTracker(runId, msg);\n} else {\nlogger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n}\n}\n} catch (Exception exception) {\n\/\/ log and continue\nlogger.logFailedDispatcherEntityId(runId, dataset, exception);\n}\n}\nreturn processTables(tablesIncludeList, tableExcludeList);\n}","code_context_20":"public List<JsonMessage> processDatasets(List<String> datasetIncludeList,\nList<String> datasetExcludeList,\nList<String> tableExcludeList,\nString dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\nList<String> tablesIncludeList = new ArrayList<>();\nfor (String dataset : datasetIncludeList) {\ntry {\nif (!datasetExcludeList.contains(dataset)) {\nList<String> tokens = Utils.tokenize(dataset, \".\", true);\nString projectId = tokens.get(0);\nString datasetId = tokens.get(1);\nString datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n\/*\nTODO: Support tagging in multiple locations\nto support all locations:\n1- Taxonomies\/PolicyTags have to be created in each required location\n2- Update the Tagger Cloud Function to read one mapping per location\nFor now, we don't submit tasks for tables in other locations than the PolicyTag location\n*\/\nif (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\nlogger.logWarnWithTracker(runId,\nString.format(\n\"Ignoring dataset %s in location %s. Only location %s is configured\",\ndataset,\ndatasetLocation,\ndataRegionId)\n);\ncontinue;\n}\n\/\/ get all tables that have DLP findings\nList<String> datasetTables = scanner.listChildren(projectId, datasetId);\ntablesIncludeList.addAll(datasetTables);\nif (datasetTables.isEmpty()) {\nString msg = String.format(\n\"No Tables found under dataset '%s'\",\ndataset);\nlogger.logWarnWithTracker(runId, msg);\n} else {\nlogger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n\nString projectId = tokens.get(0);\nString datasetId = tokens.get(1);\nString datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n\/*\nTODO: Support tagging in multiple locations\nto support all locations:\n1- Taxonomies\/PolicyTags have to be created in each required location\n2- Update the Tagger Cloud Function to read one mapping per location\nFor now, we don't submit tasks for tables in other locations than the PolicyTag location\n*\/\nif (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\nlogger.logWarnWithTracker(runId,\nString.format(\n\"Ignoring dataset %s in location %s. Only location %s is configured\",\ndataset,\ndatasetLocation,\ndataRegionId)\n);\ncontinue;\n}\n\/\/ get all tables that have DLP findings\nList<String> datasetTables = scanner.listChildren(projectId, datasetId);\ntablesIncludeList.addAll(datasetTables);\nif (datasetTables.isEmpty()) {\nString msg = String.format(\n\"No Tables found under dataset '%s'\",\ndataset);\nlogger.logWarnWithTracker(runId, msg);\n} else {\nlogger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n}\n}\n} catch (Exception exception) {\n\/\/ log and continue\nlogger.logFailedDispatcherEntityId(runId, dataset, exception);\n}\n}\nreturn processTables(tablesIncludeList, tableExcludeList);\n}\n\n\"Ignoring dataset %s in location %s. Only location %s is configured\",\ndataset,\ndatasetLocation,\ndataRegionId)\n);\ncontinue;\n}\n\/\/ get all tables that have DLP findings\nList<String> datasetTables = scanner.listChildren(projectId, datasetId);\ntablesIncludeList.addAll(datasetTables);\nif (datasetTables.isEmpty()) {\nString msg = String.format(\n\"No Tables found under dataset '%s'\",\ndataset);\nlogger.logWarnWithTracker(runId, msg);\n} else {\nlogger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n}\n}\n} catch (Exception exception) {\n\/\/ log and continue\nlogger.logFailedDispatcherEntityId(runId, dataset, exception);\n}\n}\nreturn processTables(tablesIncludeList, tableExcludeList);\n}","label":[0,1,0,0]}
{"id":10989,"original_code":"@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\n    public void displayView() {\n        boolean keepGoing = true;\n        while (keepGoing == true) {\n            \/\/check to see if the game should end and if so, display a message and return to Main Menu \n            \/\/TODO Implement try catch.\n            \/\/TODO when fully implemented, this will contain mortality rate variable from annual report \n            \/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n            \/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n            \/\/display the annual report above the GameMenuView\n            liveTheYear();\n            getAnnualReport();\n            if (GameControl.gameShouldEnd(0)) {\n                \/\/TODO when fully implemented, this will contain mortality rate variable from annual report \n                this.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\n                return;\n            } else if (GameControl.gameMatures(1)) {\n                \/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n                \/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n                this.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\n                return;\n            }\n            \/\/ get message that should be displayed\n            \/\/ only print if it is non-null\n            String message = getMessage();\n            if (message != null) {\n                this.console.println(getMessage());\n            }\n            String[] inputs = getInputs();\n            keepGoing = doAction(inputs);\n        }\n    }","code":"@Override     public void displayView() {\n        boolean keepGoing = true;\n        while (keepGoing == true) {\n           \n           \n           \n           \n           \n           \n            liveTheYear();\n            getAnnualReport();\n            if (GameControl.gameShouldEnd(0)) {\n               \n                this.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\n                return;\n            } else if (GameControl.gameMatures(1)) {\n               \n               \n                this.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\n                return;\n            }\n           \n           \n            String message = getMessage();\n            if (message != null) {\n                this.console.println(getMessage());\n            }\n            String[] inputs = getInputs();\n            keepGoing = doAction(inputs);\n        }\n    }","cleancode":"@override public void displayview() { boolean keepgoing = true; while (keepgoing == true) { livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","comment":"\/** * control this view's display\/prompt\/action loop until the user chooses and * action that causes this view to close. *\/\n\/\/using this override to place getannualreport and gameshouldend inside displayview while loop.\n\/\/check to see if the game should end and if so, display a message and return to main menu \/\/todo implement try catch. \/\/todo when fully implemented, this will contain mortality rate variable from annual report \/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year. \/\/display the annual report above the gamemenuview\n\/\/todo when fully implemented, this will contain mortality rate variable from annual report\n\/\/todo when fully implemented, this will contain currentyear variable from annual report. \/\/todo create end of game report showing total game statistics. use annual report format but bring in stats from every year.\n\/\/ get message that should be displayed \/\/ only print if it is non-null","repo":"Hsia-Esther\/CityOfAaronGroup1","code_context_2":"@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n}\n}\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\n\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\n\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\n\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {","code_context_10":"@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n}\n}\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n}\n}","code_context_20":"@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n}\n}\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n\n@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\npublic void displayView() {\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\n\nboolean keepGoing = true;\nwhile (keepGoing == true) {\n\/\/check to see if the game should end and if so, display a message and return to Main Menu\n\/\/TODO Implement try catch.\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n\/\/display the annual report above the GameMenuView\nliveTheYear();\ngetAnnualReport();\nif (GameControl.gameShouldEnd(0)) {\n\/\/TODO when fully implemented, this will contain mortality rate variable from annual report\nthis.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\nreturn;\n} else if (GameControl.gameMatures(1)) {\n\/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n\/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\nthis.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\nreturn;\n}\n\/\/ get message that should be displayed\n\/\/ only print if it is non-null\nString message = getMessage();\nif (message != null) {\nthis.console.println(getMessage());\n}\nString[] inputs = getInputs();\nkeepGoing = doAction(inputs);\n}\n}","label":[0,1,0,0]}
{"id":2869,"original_code":"public void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ x, 1 for y, 2 for heading)\n\t\tposLog.add(x);\n\t\tposLog.add(y);\n\t\tposLog.add(heading);\n\t}","code":"public void updatePosLog(double x, double y, double heading) { \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tposLog.add(x);\n\t\tposLog.add(y);\n\t\tposLog.add(heading);\n\t}","cleancode":"public void updateposlog(double x, double y, double heading) { poslog.add(x); poslog.add(y); poslog.add(heading); }","comment":"\/** * not sure what this does * * @param x * x coordinate * @param y * y coordinate * @param heading * idk *\/\n\/\/ reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)","repo":"AutonomousCarProject\/Steering","code_context_2":"public void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);","code_context_10":"public void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}","code_context_20":"public void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}\n\npublic void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\/\/ x, 1 for y, 2 for heading)\nposLog.add(x);\nposLog.add(y);\nposLog.add(heading);\n}","label":[1,0,0,0]}
{"id":11109,"original_code":"@Override\n\tprotected void configure() {\n\t\tinstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\t\t\/\/ make sure app is embedded in a correct DIV\n\t\tbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\t\t\/\/ Main Application must bind generic Presenter and custom View !!\n\t\tbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\t\t\/\/ bind app-specific pages\n\t\t\/\/ TODO - implement pages\n\t\tbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\n\t\tbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\t\t\/\/ pre-defined places\n\t\tbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\n\t\tbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\t\tbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\t\t\/\/ generic pages\n\t\tbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\n\t\tbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\n\t\tbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\n\t\tbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n\t}","code":"@Override\n\tprotected void configure() {\n\t\tinstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\t\n\t\tbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\t\n\t\tbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\t\n\t\n\t\tbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\n\t\tbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\t\n\t\tbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\n\t\tbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\t\tbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\t\n\t\tbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\n\t\tbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\n\t\tbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\n\t\tbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n\t}","cleancode":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","comment":"\/\/ make sure app is embedded in a correct div\n\/\/ main application must bind generic presenter and custom view !!\n\/\/ bind app-specific pages \/\/ todo - implement pages\n\/\/ pre-defined places\n\/\/ generic pages","repo":"Gaeldrin\/perun-wui","code_context_2":"protected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\n\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);","code_context_10":"@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\n\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}\n\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}","code_context_20":"@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}\n\n@Override\nprotected void configure() {\ninstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\/\/ make sure app is embedded in a correct DIV\nbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\/\/ Main Application must bind generic Presenter and custom View !!\nbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\/\/ bind app-specific pages\n\/\/ TODO - implement pages\nbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\nbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\/\/ pre-defined places\nbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\nbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\nbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\/\/ generic pages\nbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\nbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\nbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\nbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n}","label":[0,1,0,0]}
{"id":3131,"original_code":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\n        try (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\n            String checkpointName = export(processKey, checkpointId, checkpointArchive.path());\n            if (checkpointName == null) {\n                return null;\n            }\n            try (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\n                IOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n                \/\/ TODO: only for v1 runtime\n                String eventName = readCheckpointEventName(extractedDir.path());\n                stateManager.tx(tx -> {\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\n                    stateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n                });\n                Map<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\n                if (out.isEmpty()) {\n                    queueDao.removeMeta(processKey, \"out\");\n                } else {\n                    queueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n                }\n                return CheckpointInfo.of(checkpointName, eventName);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n        }\n    }","code":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\n        try (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\n            String checkpointName = export(processKey, checkpointId, checkpointArchive.path());\n            if (checkpointName == null) {\n                return null;\n            }\n            try (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\n                IOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n               \n                String eventName = readCheckpointEventName(extractedDir.path());\n                stateManager.tx(tx -> {\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\n                    stateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n                });\n                Map<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\n                if (out.isEmpty()) {\n                    queueDao.removeMeta(processKey, \"out\");\n                } else {\n                    queueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n                }\n                return CheckpointInfo.of(checkpointName, eventName);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n        }\n    }","cleancode":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","comment":"\/** * restore process to a saved checkpoint. *\/\n\/\/ todo: only for v1 runtime","repo":"700software\/concord","code_context_2":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\ntry (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\nString checkpointName = export(processKey, checkpointId, checkpointArchive.path());\nif (checkpointName == null) {\nreturn null;\n}\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {\nstateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\nstateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\nstateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n});\nMap<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\nif (out.isEmpty()) {\nqueueDao.removeMeta(processKey, \"out\");\n} else {\nqueueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n}\nreturn CheckpointInfo.of(checkpointName, eventName);\n}\n} catch (Exception e) {\nthrow new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n}\n}\n\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {","code_context_10":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\ntry (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\nString checkpointName = export(processKey, checkpointId, checkpointArchive.path());\nif (checkpointName == null) {\nreturn null;\n}\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {\nstateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\nstateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\nstateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n});\nMap<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\nif (out.isEmpty()) {\nqueueDao.removeMeta(processKey, \"out\");\n} else {\nqueueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n}\nreturn CheckpointInfo.of(checkpointName, eventName);\n}\n} catch (Exception e) {\nthrow new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n}\n}\n\npublic CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\ntry (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\nString checkpointName = export(processKey, checkpointId, checkpointArchive.path());\nif (checkpointName == null) {\nreturn null;\n}\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {\nstateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\nstateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\nstateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n});\nMap<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\nif (out.isEmpty()) {\nqueueDao.removeMeta(processKey, \"out\");\n} else {","code_context_20":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\ntry (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\nString checkpointName = export(processKey, checkpointId, checkpointArchive.path());\nif (checkpointName == null) {\nreturn null;\n}\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {\nstateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\nstateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\nstateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n});\nMap<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\nif (out.isEmpty()) {\nqueueDao.removeMeta(processKey, \"out\");\n} else {\nqueueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n}\nreturn CheckpointInfo.of(checkpointName, eventName);\n}\n} catch (Exception e) {\nthrow new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n}\n}\n\npublic CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\ntry (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\nString checkpointName = export(processKey, checkpointId, checkpointArchive.path());\nif (checkpointName == null) {\nreturn null;\n}\ntry (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\nIOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n\/\/ TODO: only for v1 runtime\nString eventName = readCheckpointEventName(extractedDir.path());\nstateManager.tx(tx -> {\nstateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\nstateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\nstateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n});\nMap<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\nif (out.isEmpty()) {\nqueueDao.removeMeta(processKey, \"out\");\n} else {\nqueueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n}\nreturn CheckpointInfo.of(checkpointName, eventName);\n}\n} catch (Exception e) {\nthrow new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n}\n}","label":[1,0,0,0]}
{"id":19591,"original_code":"protected List createEmptyList() {\n        return new BackedList(this, contentList(), 0);\n    }","code":"protected List createEmptyList() {\n        return new BackedList(this, contentList(), 0);\n    }","cleancode":"protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","comment":"\/** * a factory method pattern which creates an empty a backedlist * implementation * * @return document me! *\/","repo":"Gravitational-Field\/Dive-In-Java","code_context_2":"protected List createEmptyList() {\nreturn new BackedList(this, contentList(), 0);\n}","code_context_10":"protected List createEmptyList() {\nreturn new BackedList(this, contentList(), 0);\n}","code_context_20":"protected List createEmptyList() {\nreturn new BackedList(this, contentList(), 0);\n}","label":[0,0,0,0]}
{"id":3223,"original_code":"protected void initFromRaFile() throws IOException {\n\t\t\/\/ Central directory structure \/ central file header signature\n\t\tint censig = raFile.readInt( fileOffset );\n\t\tif( censig!=CENSIG ) {\n\t\t\tthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n\t\t} else if( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"found censigOffset=\" + fileOffset );\n\t\t}\n\t\tshort flag = raFile.readShort( fileOffset + 8 );\n\t\tthis.isEncrypted = (flag&1)>0;\n\t\tthis.fileNameLength = raFile.readShort( fileOffset + 28 );\n\t\tbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\n\t\tthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"fileName = \" + this.fileName );\n\t\t}\n\t\tthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\n\t\tthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\n\t\tthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\tLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\n\t\t\tLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n\t\t}\n\t\t\/\/ TODO - check, why we have to use the local header instead of the CDS sometimes...\n\t\tif( this.isEncrypted ) {\n\t\t\tbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\n\t\t\tif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\n\t\t\t\tthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\n\t\t\t\tthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\n\t\t\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\t\t\tLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\t\t\tLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n\t\t\t\t}\n\t\t\t\tif( 0==extraFieldLength ) {\n\t\t\t\t\tthrow new ZipException(\"extra field is of length 0 - this is probably not a WinZip AES encrypted entry\");\n\t\t\t\t}\n\t\t\t\tefhid = raFile.readByteArray( extraFieldOffset, 2);\n\t\t\t\tif( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) {\n\t\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t}\n\t\t\tif( this.isAesEncrypted ) {\n\t\t\t\tthis.actualCompressionMethod = raFile.readShort( getExtraFieldOffset() + 9 );\n\t\t\t\tthis.localHeaderSize = 30 + getExtraFieldLength() + getFileNameLength();\n\t\t\t}\n\t\t}\n\t\tthis.compressedSize = raFile.readInt( fileOffset + 20 );\n\t\tthis.uncompressedSize = raFile.readInt( fileOffset + 24 );\n\t}","code":"protected void initFromRaFile() throws IOException {\n\t\n\t\tint censig = raFile.readInt( fileOffset );\n\t\tif( censig!=CENSIG ) {\n\t\t\tthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n\t\t} else if( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"found censigOffset=\" + fileOffset );\n\t\t}\n\t\tshort flag = raFile.readShort( fileOffset + 8 );\n\t\tthis.isEncrypted = (flag&1)>0;\n\t\tthis.fileNameLength = raFile.readShort( fileOffset + 28 );\n\t\tbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\n\t\tthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"fileName = \" + this.fileName );\n\t\t}\n\t\tthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\n\t\tthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\n\t\tthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\tLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\n\t\t\tLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n\t\t}\n\t\n\t\tif( this.isEncrypted ) {\n\t\t\tbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\n\t\t\tif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\n\t\t\t\tthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\n\t\t\t\tthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\n\t\t\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\t\t\tLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\t\t\tLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n\t\t\t\t}\n\t\t\t\tif( 0==extraFieldLength ) {\n\t\t\t\t\tthrow new ZipException(\"extra field is of length 0 - this is probably not a WinZip AES encrypted entry\");\n\t\t\t\t}\n\t\t\t\tefhid = raFile.readByteArray( extraFieldOffset, 2);\n\t\t\t\tif( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) {\n\t\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t}\n\t\t\tif( this.isAesEncrypted ) {\n\t\t\t\tthis.actualCompressionMethod = raFile.readShort( getExtraFieldOffset() + 9 );\n\t\t\t\tthis.localHeaderSize = 30 + getExtraFieldLength() + getFileNameLength();\n\t\t\t}\n\t\t}\n\t\tthis.compressedSize = raFile.readInt( fileOffset + 20 );\n\t\tthis.uncompressedSize = raFile.readInt( fileOffset + 24 );\n\t}","cleancode":"protected void initfromrafile() throws ioexception { int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) { throw new zipexception(\"extra field is of length 0 - this is probably not a winzip aes encrypted entry\"); } efhid = rafile.readbytearray( extrafieldoffset, 2); if( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) { this.isaesencrypted = true; } } else { this.isaesencrypted = true; } if( this.isaesencrypted ) { this.actualcompressionmethod = rafile.readshort( getextrafieldoffset() + 9 ); this.localheadersize = 30 + getextrafieldlength() + getfilenamelength(); } } this.compressedsize = rafile.readint( fileoffset + 20 ); this.uncompressedsize = rafile.readint( fileoffset + 24 ); }","comment":"\/\/ central directory structure \/ central file header signature\n\/\/ todo - check, why we have to use the local header instead of the cds sometimes...","repo":"CATION-M\/X-moe","code_context_2":"protected void initFromRaFile() throws IOException {\n\/\/ Central directory structure \/ central file header signature\nint censig = raFile.readInt( fileOffset );\nif( censig!=CENSIG ) {\n\nLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n}\n\/\/ TODO - check, why we have to use the local header instead of the CDS sometimes...\nif( this.isEncrypted ) {\nbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );","code_context_10":"protected void initFromRaFile() throws IOException {\n\/\/ Central directory structure \/ central file header signature\nint censig = raFile.readInt( fileOffset );\nif( censig!=CENSIG ) {\nthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n} else if( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"found censigOffset=\" + fileOffset );\n}\nshort flag = raFile.readShort( fileOffset + 8 );\nthis.isEncrypted = (flag&1)>0;\nthis.fileNameLength = raFile.readShort( fileOffset + 28 );\nbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\n\nLOG.fine( \"fileName = \" + this.fileName );\n}\nthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\nthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\nthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\nLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\nLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n}\n\/\/ TODO - check, why we have to use the local header instead of the CDS sometimes...\nif( this.isEncrypted ) {\nbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\nif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\nthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\nthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\nLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n}\nif( 0==extraFieldLength ) {","code_context_20":"protected void initFromRaFile() throws IOException {\n\/\/ Central directory structure \/ central file header signature\nint censig = raFile.readInt( fileOffset );\nif( censig!=CENSIG ) {\nthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n} else if( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"found censigOffset=\" + fileOffset );\n}\nshort flag = raFile.readShort( fileOffset + 8 );\nthis.isEncrypted = (flag&1)>0;\nthis.fileNameLength = raFile.readShort( fileOffset + 28 );\nbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\nthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"fileName = \" + this.fileName );\n}\nthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\nthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\nthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\nLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\n\nthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n} else if( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"found censigOffset=\" + fileOffset );\n}\nshort flag = raFile.readShort( fileOffset + 8 );\nthis.isEncrypted = (flag&1)>0;\nthis.fileNameLength = raFile.readShort( fileOffset + 28 );\nbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\nthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"fileName = \" + this.fileName );\n}\nthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\nthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\nthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\nLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\nLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n}\n\/\/ TODO - check, why we have to use the local header instead of the CDS sometimes...\nif( this.isEncrypted ) {\nbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\nif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\nthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\nthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\nif( LOG.isLoggable(Level.FINE) ) {\nLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\nLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n}\nif( 0==extraFieldLength ) {\nthrow new ZipException(\"extra field is of length 0 - this is probably not a WinZip AES encrypted entry\");\n}\nefhid = raFile.readByteArray( extraFieldOffset, 2);\nif( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) {\nthis.isAesEncrypted = true;\n}\n} else {\nthis.isAesEncrypted = true;\n}\nif( this.isAesEncrypted ) {","label":[1,0,0,0]}
{"id":3224,"original_code":"public short getCryptoHeaderLength() {\n\t\t\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\n\t\treturn 18;\n\t}","code":"public short getCryptoHeaderLength() {\n\t\n\t\treturn 18;\n\t}","cleancode":"public short getcryptoheaderlength() { return 18; }","comment":"\/** fixed 256 key size, 16 bytes salt + 2 bytes pwverification *\/\n\/\/ todo support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2","repo":"CATION-M\/X-moe","code_context_2":"public short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}\n\npublic short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}","code_context_10":"public short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}\n\npublic short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}","code_context_20":"public short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}\n\npublic short getCryptoHeaderLength() {\n\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\nreturn 18;\n}","label":[0,1,0,0]}
{"id":11510,"original_code":"@Override\n    public Set< Justification > computeJustifications() {\n        Set< Set< OWLAxiom > > justifications = null;\n        try {\n            justifications = explainAxiom( axiom_ );\n        }\n        catch ( OWLException e ) {\n            throw new RuntimeException( e );\n        }\n        \/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n        \/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\n        Set< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\n        for ( Set< OWLAxiom > justification : justifications ) {\n            \/\/ JAVA 8:\n            \/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n            \/\/\n            \/\/ JAVA < 8 (there is probably a better way even then):\n            for ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\n                OWLAxiom a = it.next();\n                if ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\n                    it.remove();\n                }\n            }\n            return_justifications.add( new Justification( justification ) );\n        }\n*\/\n        for ( Set< OWLAxiom > justification : justifications ) {\n            return_justifications.add( new Justification( justification ) );\n        }\n        \/\/if ( SparqlUpdater.verbose_level > 0 ) {\n            \/\/Justification.print( return_justifications, axiom_ );\n        \/\/}\n        \/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n        \/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\n        for ( Justification justification : return_justifications ) {\n            justification.removeTBoxAndRBoxAxioms();\n        }\n        return return_justifications;\n    }","code":"@Override\n    public Set< Justification > computeJustifications() {\n        Set< Set< OWLAxiom > > justifications = null;\n        try {\n            justifications = explainAxiom( axiom_ );\n        }\n        catch ( OWLException e ) {\n            throw new RuntimeException( e );\n        }\n       \n       \n        Set< Justification > return_justifications = new TreeSet< Justification > ();\n        for ( Set< OWLAxiom > justification : justifications ) {\n            return_justifications.add( new Justification( justification ) );\n        }\n       \n           \n       \n       \n       \n        for ( Justification justification : return_justifications ) {\n            justification.removeTBoxAndRBoxAxioms();\n        }\n        return return_justifications;\n    }","cleancode":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } set< justification > return_justifications = new treeset< justification > (); for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","comment":"\/** * @brief compute justifications for the predefined assertion. * * note that this will not contain tbox-assertions (i.e. subclassof, ...) * @return a set of justifications for the assertion (basically a set of wrappers around sets of owl-axioms) *\/\n\/\/ we represent justifications as instances of a custom class outside of this function, which requires transitioning \/\/ this is done in order to hide usage of the owlapi in code that does not need to rely directly on it.\n\/\/ order is important for hitting set computation -> use treeset!\n\/* \/\/todo use this if printing is not desired for ( set< owlaxiom > justification : justifications ) { \/\/ java 8: \/\/ justification.removeif( ( owlaxiom a ) -> { return a.isoftype( axiomtype.tboxandrboxaxiomtypes ) } ); \/\/ \/\/ java < 8 (there is probably a better way even then): for ( iterator< owlaxiom > it = justification.iterator(); it.hasnext(); ) { owlaxiom a = it.next(); if ( a.isoftype( axiomtype.tboxandrboxaxiomtypes ) ) { it.remove(); } } return_justifications.add( new justification( justification ) ); } *\/\n\/\/if ( sparqlupdater.verbose_level > 0 ) { \/\/justification.print( return_justifications, axiom_ ); \/\/} \/\/ we only consider abox axioms for deletion. therefore, we remove tbox and rbox assertions. \/\/ todo if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the justification class.","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater","code_context_2":"@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}\n\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\n\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();","code_context_10":"@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}\n\n@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\n\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}","code_context_20":"@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}\n\n@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\n@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\n@Override\npublic Set< Justification > computeJustifications() {\nSet< Set< OWLAxiom > > justifications = null;\ntry {\njustifications = explainAxiom( axiom_ );\n}\ncatch ( OWLException e ) {\nthrow new RuntimeException( e );\n}\n\/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}\n\n\/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\nSet< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\nfor ( Set< OWLAxiom > justification : justifications ) {\n\/\/ JAVA 8:\n\/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n\/\/\n\/\/ JAVA < 8 (there is probably a better way even then):\nfor ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\nOWLAxiom a = it.next();\nif ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\nit.remove();\n}\n}\nreturn_justifications.add( new Justification( justification ) );\n}\n*\/\nfor ( Set< OWLAxiom > justification : justifications ) {\nreturn_justifications.add( new Justification( justification ) );\n}\n\/\/if ( SparqlUpdater.verbose_level > 0 ) {\n\/\/Justification.print( return_justifications, axiom_ );\n\/\/}\n\/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n\/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\nfor ( Justification justification : return_justifications ) {\njustification.removeTBoxAndRBoxAxioms();\n}\nreturn return_justifications;\n}","label":[1,0,0,0]}
{"id":19708,"original_code":"public boolean canKick(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanKick) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code":"public boolean canKick(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanKick) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","comment":"\/** * can they kick? * * @param name * @return *\/","repo":"CoderMMK\/RSPS","code_context_2":"public boolean canKick(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanKick) {\nreturn true;\n}\nreturn false;\n}","code_context_10":"public boolean canKick(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanKick) {\nreturn true;\n}\nreturn false;\n}","code_context_20":"public boolean canKick(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanKick) {\nreturn true;\n}\nreturn false;\n}","label":[0,0,0,1]}
{"id":19709,"original_code":"public boolean canBan(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanBan) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code":"public boolean canBan(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanBan) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","comment":"\/** * can they ban? * * @param name * @return *\/","repo":"CoderMMK\/RSPS","code_context_2":"public boolean canBan(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanBan) {\nreturn true;\n}\nreturn false;\n}","code_context_10":"public boolean canBan(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanBan) {\nreturn true;\n}\nreturn false;\n}","code_context_20":"public boolean canBan(String name) {\nif (isFounder(name)) {\nreturn true;\n}\nif (getRank(name) >= whoCanBan) {\nreturn true;\n}\nreturn false;\n}","label":[0,0,0,1]}
{"id":3404,"original_code":"public void GetLiveTvProgramsAsync(ProgramQuery query, final Response<ItemsResult> response)\n    {\n        if (query == null)\n        {\n            throw new IllegalArgumentException(\"query\");\n        }\n        QueryStringDictionary dict = new QueryStringDictionary ();\n        String isoDateFormat = \"o\";\n        if (query.getMaxEndDate() != null)\n        {\n            dict.Add(\"MaxEndDate\", getIsoString(query.getMaxEndDate()));\n        }\n        if (query.getMaxStartDate() != null)\n        {\n            dict.Add(\"MaxStartDate\", getIsoString(query.getMaxStartDate()));\n        }\n        if (query.getMinEndDate() != null)\n        {\n            dict.Add(\"MinEndDate\", getIsoString(query.getMinEndDate()));\n        }\n        if (query.getMinStartDate() != null)\n        {\n            dict.Add(\"MinStartDate\", getIsoString(query.getMinStartDate()));\n        }\n        if (!query.getEnableTotalRecordCount())\n        {\n            dict.Add(\"EnableTotalRecordCount\", \"false\");\n        }\n        dict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\n        dict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\n        dict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\n        dict.AddIfNotNull(\"Fields\", query.getFields());\n        dict.AddIfNotNull(\"SortBy\", query.getSortBy());\n        dict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\n        if (query.getChannelIds() != null)\n        {\n            dict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n        }\n        \/\/ TODO: This endpoint supports POST if the query String is too long\n        String url = GetApiUrl(\"LiveTv\/Programs\", dict);\n        url = AddDataFormat(url);\n        Send(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n    }","code":"public void GetLiveTvProgramsAsync(ProgramQuery query, final Response<ItemsResult> response)\n    {\n        if (query == null)\n        {\n            throw new IllegalArgumentException(\"query\");\n        }\n        QueryStringDictionary dict = new QueryStringDictionary ();\n        String isoDateFormat = \"o\";\n        if (query.getMaxEndDate() != null)\n        {\n            dict.Add(\"MaxEndDate\", getIsoString(query.getMaxEndDate()));\n        }\n        if (query.getMaxStartDate() != null)\n        {\n            dict.Add(\"MaxStartDate\", getIsoString(query.getMaxStartDate()));\n        }\n        if (query.getMinEndDate() != null)\n        {\n            dict.Add(\"MinEndDate\", getIsoString(query.getMinEndDate()));\n        }\n        if (query.getMinStartDate() != null)\n        {\n            dict.Add(\"MinStartDate\", getIsoString(query.getMinStartDate()));\n        }\n        if (!query.getEnableTotalRecordCount())\n        {\n            dict.Add(\"EnableTotalRecordCount\", \"false\");\n        }\n        dict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\n        dict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\n        dict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\n        dict.AddIfNotNull(\"Fields\", query.getFields());\n        dict.AddIfNotNull(\"SortBy\", query.getSortBy());\n        dict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\n        if (query.getChannelIds() != null)\n        {\n            dict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n        }\n       \n        String url = GetApiUrl(\"LiveTv\/Programs\", dict);\n        url = AddDataFormat(url);\n        Send(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n    }","cleancode":"public void getlivetvprogramsasync(programquery query, final response<itemsresult> response) { if (query == null) { throw new illegalargumentexception(\"query\"); } querystringdictionary dict = new querystringdictionary (); string isodateformat = \"o\"; if (query.getmaxenddate() != null) { dict.add(\"maxenddate\", getisostring(query.getmaxenddate())); } if (query.getmaxstartdate() != null) { dict.add(\"maxstartdate\", getisostring(query.getmaxstartdate())); } if (query.getminenddate() != null) { dict.add(\"minenddate\", getisostring(query.getminenddate())); } if (query.getminstartdate() != null) { dict.add(\"minstartdate\", getisostring(query.getminstartdate())); } if (!query.getenabletotalrecordcount()) { dict.add(\"enabletotalrecordcount\", \"false\"); } dict.addifnotnull(\"enableimages\", query.getenableimages()); dict.addifnotnull(\"imagetypelimit\", query.getimagetypelimit()); dict.addifnotnull(\"enableimagetypes\", query.getenableimagetypes()); dict.addifnotnull(\"fields\", query.getfields()); dict.addifnotnull(\"sortby\", query.getsortby()); dict.addifnotnullorempty(\"userid\", query.getuserid()); if (query.getchannelids() != null) { dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url); send(url, \"get\", new serializedresponse<>(response, jsonserializer, itemsresult.class)); }","comment":"\/\/ todo: this endpoint supports post if the query string is too long","repo":"AndreasGB\/jellyfin-apiclient-java","code_context_2":"dict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n}\n\/\/ TODO: This endpoint supports POST if the query String is too long\nString url = GetApiUrl(\"LiveTv\/Programs\", dict);\nurl = AddDataFormat(url);","code_context_10":"dict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\ndict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\ndict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\ndict.AddIfNotNull(\"Fields\", query.getFields());\ndict.AddIfNotNull(\"SortBy\", query.getSortBy());\ndict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\nif (query.getChannelIds() != null)\n{\ndict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n}\n\/\/ TODO: This endpoint supports POST if the query String is too long\nString url = GetApiUrl(\"LiveTv\/Programs\", dict);\nurl = AddDataFormat(url);\nSend(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n}","code_context_20":"dict.Add(\"MinEndDate\", getIsoString(query.getMinEndDate()));\n}\nif (query.getMinStartDate() != null)\n{\ndict.Add(\"MinStartDate\", getIsoString(query.getMinStartDate()));\n}\nif (!query.getEnableTotalRecordCount())\n{\ndict.Add(\"EnableTotalRecordCount\", \"false\");\n}\ndict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\ndict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\ndict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\ndict.AddIfNotNull(\"Fields\", query.getFields());\ndict.AddIfNotNull(\"SortBy\", query.getSortBy());\ndict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\nif (query.getChannelIds() != null)\n{\ndict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n}\n\/\/ TODO: This endpoint supports POST if the query String is too long\nString url = GetApiUrl(\"LiveTv\/Programs\", dict);\nurl = AddDataFormat(url);\nSend(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n}","label":[0,1,0,0]}
{"id":19828,"original_code":"@Test\n\tpublic void testPositionConstructor() {\n\t\tposition = new Position(rowInRange, cellInRange);\n\t\t\/\/ I know tests need to be independent but not sure how else to do this\n\t\tassertEquals(rowInRange, position.getRow());\n\t\tassertEquals(cellInRange, position.getCell());\n\t}","code":"@Test\n\tpublic void testPositionConstructor() {\n\t\tposition = new Position(rowInRange, cellInRange);\n\t\n\t\tassertEquals(rowInRange, position.getRow());\n\t\tassertEquals(cellInRange, position.getCell());\n\t}","cleancode":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","comment":"\/** * tests that the component will be initialized correctly. *\/\n\/\/ i know tests need to be independent but not sure how else to do this","repo":"DaniloSosa98\/SE-WebCheckers","code_context_2":"@Test\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());\n}\n\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());","code_context_10":"@Test\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());\n}\n\n@Test\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());\n}","code_context_20":"@Test\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());\n}\n\n@Test\npublic void testPositionConstructor() {\nposition = new Position(rowInRange, cellInRange);\n\/\/ I know tests need to be independent but not sure how else to do this\nassertEquals(rowInRange, position.getRow());\nassertEquals(cellInRange, position.getCell());\n}","label":[1,0,0,0]}
{"id":11711,"original_code":"@GET\n  @Path(\"{connectorId}\/contents\")\n  public Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\n    Connector connector = getConnector(connectorId);\n    InputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\n    if (content == null) {\n      return JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n    }\n    \/\/ nre: TODO: Why not guess by extension?\n    try {\n      return JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n              .header(\"Content-Type\", type.getMimeType())\n              .build();\n    } finally {\n      IoUtil.closeSilently(content);\n    }\n  }","code":"@GET\n  @Path(\"{connectorId}\/contents\")\n  public Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\n    Connector connector = getConnector(connectorId);\n    InputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\n    if (content == null) {\n      return JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n    }\n   \n    try {\n      return JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n              .header(\"Content-Type\", type.getMimeType())\n              .build();\n    } finally {\n      IoUtil.closeSilently(content);\n    }\n  }","cleancode":"@get @path(\"{connectorid}\/contents\") public response gettypedcontent(@pathparam(\"connectorid\") long connectorid, @queryparam(\"nodeid\") string nodeid, @queryparam(\"type\") connectornodetype type) { connector connector = getconnector(connectorid); inputstream content = connector.getcontent(new connectornode(nodeid, null, type)); if (content == null) { return jaxrsutil.createresponse().status(response.status.not_found).build(); } try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\")) .header(\"content-type\", type.getmimetype()) .build(); } finally { ioutil.closesilently(content); } }","comment":"\/\/ nre: todo: why not guess by extension?","repo":"1and1\/camunda-bpm-platform","code_context_2":"return JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n}\n\/\/ nre: TODO: Why not guess by extension?\ntry {\nreturn JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))","code_context_10":"@GET\n@Path(\"{connectorId}\/contents\")\npublic Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\nConnector connector = getConnector(connectorId);\nInputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\nif (content == null) {\nreturn JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n}\n\/\/ nre: TODO: Why not guess by extension?\ntry {\nreturn JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n.header(\"Content-Type\", type.getMimeType())\n.build();\n} finally {\nIoUtil.closeSilently(content);\n}\n}","code_context_20":"@GET\n@Path(\"{connectorId}\/contents\")\npublic Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\nConnector connector = getConnector(connectorId);\nInputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\nif (content == null) {\nreturn JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n}\n\/\/ nre: TODO: Why not guess by extension?\ntry {\nreturn JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n.header(\"Content-Type\", type.getMimeType())\n.build();\n} finally {\nIoUtil.closeSilently(content);\n}\n}","label":[1,0,0,0]}
{"id":3528,"original_code":"private Complex getFeederLoadVA(String sourceBusId) {\n\t\tBus3Phase sourceBus = (Bus3Phase) this.net.getBus(sourceBusId);\n\t\tComplex3x1 vabc_1 = sourceBus.get3PhaseVotlages();\n\t\tComplex3x1 currInj3Phase = new Complex3x1();\n\t\tfor(Branch bra: sourceBus.getConnectedPhysicalBranchList()){\n\t\t\tif(bra.isActive()){\n\t\t\t\tBranch3Phase acLine = (Branch3Phase) bra;\n\t\t\t\tComplex3x1 Isource = null;\n\t\t\t\tif(bra.getFromBus().getId().equals(sourceBus.getId())){\n\t\t\t\t\tBus3Phase toBus = (Bus3Phase) bra.getToBus();\n\t\t\t\t\tComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Yft = acLine.getYftabc();\n\t\t\t\t\tComplex3x3 Yff = acLine.getYffabc();\n\t\t\t\t\tIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\n\t\t\t\t\tComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Ytf = acLine.getYtfabc();\n\t\t\t\t\tComplex3x3 Ytt = acLine.getYttabc();\n\t\t\t\t\tIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/TODO this needs to be updated if actual values are used in the distribution system\n\t\tdouble distVABase = this.net.getBaseMva()*1.0E6;\n\t\tBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus; \n\t\t\/\/ from distribution to transmission\n\t\tComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\n\t\treturn totalPower.multiply(-1.0);\n\t}","code":"private Complex getFeederLoadVA(String sourceBusId) {\n\t\tBus3Phase sourceBus = (Bus3Phase) this.net.getBus(sourceBusId);\n\t\tComplex3x1 vabc_1 = sourceBus.get3PhaseVotlages();\n\t\tComplex3x1 currInj3Phase = new Complex3x1();\n\t\tfor(Branch bra: sourceBus.getConnectedPhysicalBranchList()){\n\t\t\tif(bra.isActive()){\n\t\t\t\tBranch3Phase acLine = (Branch3Phase) bra;\n\t\t\t\tComplex3x1 Isource = null;\n\t\t\t\tif(bra.getFromBus().getId().equals(sourceBus.getId())){\n\t\t\t\t\tBus3Phase toBus = (Bus3Phase) bra.getToBus();\n\t\t\t\t\tComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Yft = acLine.getYftabc();\n\t\t\t\t\tComplex3x3 Yff = acLine.getYffabc();\n\t\t\t\t\tIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\n\t\t\t\t\tComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Ytf = acLine.getYtfabc();\n\t\t\t\t\tComplex3x3 Ytt = acLine.getYttabc();\n\t\t\t\t\tIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tdouble distVABase = this.net.getBaseMva()*1.0E6;\n\t\tBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus; \n\t\n\t\tComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\n\t\treturn totalPower.multiply(-1.0);\n\t}","cleancode":"private complex getfeederloadva(string sourcebusid) { bus3phase sourcebus = (bus3phase) this.net.getbus(sourcebusid); complex3x1 vabc_1 = sourcebus.get3phasevotlages(); complex3x1 currinj3phase = new complex3x1(); for(branch bra: sourcebus.getconnectedphysicalbranchlist()){ if(bra.isactive()){ branch3phase acline = (branch3phase) bra; complex3x1 isource = null; if(bra.getfrombus().getid().equals(sourcebus.getid())){ bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","comment":"\/\/todo this needs to be updated if actual values are used in the distribution system\n\/\/ from distribution to transmission","repo":"GMLC-TDC\/Use-Cases","code_context_2":"}\n}\n\/\/TODO this needs to be updated if actual values are used in the distribution system\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\/\/ from distribution to transmission\nComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\nreturn totalPower.multiply(-1.0);","code_context_10":"else{\nBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\nComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\nComplex3x3 Ytf = acLine.getYtfabc();\nComplex3x3 Ytt = acLine.getYttabc();\nIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource);\n}\n}\n}\n\/\/TODO this needs to be updated if actual values are used in the distribution system\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\/\/ from distribution to transmission\nComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\nreturn totalPower.multiply(-1.0);\n}\n\nComplex3x3 Ytf = acLine.getYtfabc();\nComplex3x3 Ytt = acLine.getYttabc();\nIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource);\n}\n}\n}\n\/\/TODO this needs to be updated if actual values are used in the distribution system\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\/\/ from distribution to transmission\nComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\nreturn totalPower.multiply(-1.0);\n}","code_context_20":"Branch3Phase acLine = (Branch3Phase) bra;\nComplex3x1 Isource = null;\nif(bra.getFromBus().getId().equals(sourceBus.getId())){\nBus3Phase toBus = (Bus3Phase) bra.getToBus();\nComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\nComplex3x3 Yft = acLine.getYftabc();\nComplex3x3 Yff = acLine.getYffabc();\nIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource );\n}\nelse{\nBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\nComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\nComplex3x3 Ytf = acLine.getYtfabc();\nComplex3x3 Ytt = acLine.getYttabc();\nIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource);\n}\n}\n}\n\/\/TODO this needs to be updated if actual values are used in the distribution system\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\/\/ from distribution to transmission\nComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\nreturn totalPower.multiply(-1.0);\n}\n\nBus3Phase toBus = (Bus3Phase) bra.getToBus();\nComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\nComplex3x3 Yft = acLine.getYftabc();\nComplex3x3 Yff = acLine.getYffabc();\nIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource );\n}\nelse{\nBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\nComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\nComplex3x3 Ytf = acLine.getYtfabc();\nComplex3x3 Ytt = acLine.getYttabc();\nIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\ncurrInj3Phase = currInj3Phase.subtract(Isource);\n}\n}\n}\n\/\/TODO this needs to be updated if actual values are used in the distribution system\ndouble distVABase = this.net.getBaseMva()*1.0E6;\nBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus;\n\/\/ from distribution to transmission\nComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\nreturn totalPower.multiply(-1.0);\n}","label":[1,0,0,0]}
{"id":11856,"original_code":"@Override\n   public <K> void executeTask(\n           final AdvancedCacheLoader.KeyFilter<K> filter,\n           final ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n   ) throws InterruptedException{\n      if (filter == null)\n         throw new IllegalArgumentException(\"No filter specified\");\n      if (action == null)\n         throw new IllegalArgumentException(\"No action specified\");\n      ParallelIterableMap<Object, InternalCacheEntry> map =\n              (ParallelIterableMap<Object, InternalCacheEntry>) entries;\n       map.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n           @Override\n           public void apply(Object o, InternalCacheEntry internalCacheEntry) {\n           }\n\/\/         @Override\n\/\/         public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/            if (filter.shouldLoadKey((K)key)) {\n\/\/               action.apply((K)key, value);\n\/\/            }\n\/\/         }\n      });\n      \/\/TODO figure out the way how to do interruption better (during iteration)\n      if(Thread.currentThread().isInterrupted()){\n         throw new InterruptedException();\n      }\n   }","code":"@Override\n   public <K> void executeTask(\n           final AdvancedCacheLoader.KeyFilter<K> filter,\n           final ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n   ) throws InterruptedException{\n      if (filter == null)\n         throw new IllegalArgumentException(\"No filter specified\");\n      if (action == null)\n         throw new IllegalArgumentException(\"No action specified\");\n      ParallelIterableMap<Object, InternalCacheEntry> map =\n              (ParallelIterableMap<Object, InternalCacheEntry>) entries;\n       map.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n           @Override\n           public void apply(Object o, InternalCacheEntry internalCacheEntry) {\n           }\n      });\n     \n      if(Thread.currentThread().isInterrupted()){\n         throw new InterruptedException();\n      }\n   }","cleancode":"@override public <k> void executetask( final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } }); if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","comment":"\/\/ @override \/\/ public void apply(object key, offheapinternalcacheentry value) { \/\/ if (filter.shouldloadkey((k)key)) { \/\/ action.apply((k)key, value); \/\/ } \/\/ }\n\/\/todo figure out the way how to do interruption better (during iteration)","repo":"Cotton-Ben\/infinispan","code_context_2":"public void apply(Object o, InternalCacheEntry internalCacheEntry) {\n}\n\/\/ @Override\n\/\/ public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/ if (filter.shouldLoadKey((K)key)) {\n\/\/ action.apply((K)key, value);\n\/\/ }\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\n\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\nif(Thread.currentThread().isInterrupted()){\nthrow new InterruptedException();","code_context_10":"if (filter == null)\nthrow new IllegalArgumentException(\"No filter specified\");\nif (action == null)\nthrow new IllegalArgumentException(\"No action specified\");\nParallelIterableMap<Object, InternalCacheEntry> map =\n(ParallelIterableMap<Object, InternalCacheEntry>) entries;\nmap.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n@Override\npublic void apply(Object o, InternalCacheEntry internalCacheEntry) {\n}\n\/\/ @Override\n\/\/ public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/ if (filter.shouldLoadKey((K)key)) {\n\/\/ action.apply((K)key, value);\n\/\/ }\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\nif(Thread.currentThread().isInterrupted()){\nthrow new InterruptedException();\n}\n}\n\n@Override\npublic void apply(Object o, InternalCacheEntry internalCacheEntry) {\n}\n\/\/ @Override\n\/\/ public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/ if (filter.shouldLoadKey((K)key)) {\n\/\/ action.apply((K)key, value);\n\/\/ }\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\nif(Thread.currentThread().isInterrupted()){\nthrow new InterruptedException();\n}\n}","code_context_20":"@Override\npublic <K> void executeTask(\nfinal AdvancedCacheLoader.KeyFilter<K> filter,\nfinal ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n) throws InterruptedException{\nif (filter == null)\nthrow new IllegalArgumentException(\"No filter specified\");\nif (action == null)\nthrow new IllegalArgumentException(\"No action specified\");\nParallelIterableMap<Object, InternalCacheEntry> map =\n(ParallelIterableMap<Object, InternalCacheEntry>) entries;\nmap.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n@Override\npublic void apply(Object o, InternalCacheEntry internalCacheEntry) {\n}\n\/\/ @Override\n\/\/ public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/ if (filter.shouldLoadKey((K)key)) {\n\/\/ action.apply((K)key, value);\n\/\/ }\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\nif(Thread.currentThread().isInterrupted()){\nthrow new InterruptedException();\n}\n}\n\nfinal AdvancedCacheLoader.KeyFilter<K> filter,\nfinal ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n) throws InterruptedException{\nif (filter == null)\nthrow new IllegalArgumentException(\"No filter specified\");\nif (action == null)\nthrow new IllegalArgumentException(\"No action specified\");\nParallelIterableMap<Object, InternalCacheEntry> map =\n(ParallelIterableMap<Object, InternalCacheEntry>) entries;\nmap.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n@Override\npublic void apply(Object o, InternalCacheEntry internalCacheEntry) {\n}\n\/\/ @Override\n\/\/ public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/ if (filter.shouldLoadKey((K)key)) {\n\/\/ action.apply((K)key, value);\n\/\/ }\n\/\/ }\n});\n\/\/TODO figure out the way how to do interruption better (during iteration)\nif(Thread.currentThread().isInterrupted()){\nthrow new InterruptedException();\n}\n}","label":[1,0,0,0]}
{"id":11891,"original_code":"@Override\n    public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n      Iterator<Integer> indexItr = order.iterator();\n      V result = initResult();\n      for (Future<K> future : futures) {\n        \/\/ TODO: the max time this can take is actually N * timeout. Consider fixing this.\n        result = aggregate(future.get(timeout, unit), indexItr, result);\n      }\n      return result;\n    }","code":"@Override\n    public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n      Iterator<Integer> indexItr = order.iterator();\n      V result = initResult();\n      for (Future<K> future : futures) {\n       \n        result = aggregate(future.get(timeout, unit), indexItr, result);\n      }\n      return result;\n    }","cleancode":"@override public final v get(long timeout, timeunit unit) throws interruptedexception, executionexception, timeoutexception { iterator<integer> indexitr = order.iterator(); v result = initresult(); for (future<k> future : futures) { result = aggregate(future.get(timeout, unit), indexitr, result); } return result; }","comment":"\/\/ todo: the max time this can take is actually n * timeout. consider fixing this.","repo":"CyberFlameGO\/appengine-java-standard","code_context_2":"V result = initResult();\nfor (Future<K> future : futures) {\n\/\/ TODO: the max time this can take is actually N * timeout. Consider fixing this.\nresult = aggregate(future.get(timeout, unit), indexItr, result);\n}","code_context_10":"@Override\npublic final V get(long timeout, TimeUnit unit)\nthrows InterruptedException, ExecutionException, TimeoutException {\nIterator<Integer> indexItr = order.iterator();\nV result = initResult();\nfor (Future<K> future : futures) {\n\/\/ TODO: the max time this can take is actually N * timeout. Consider fixing this.\nresult = aggregate(future.get(timeout, unit), indexItr, result);\n}\nreturn result;\n}","code_context_20":"@Override\npublic final V get(long timeout, TimeUnit unit)\nthrows InterruptedException, ExecutionException, TimeoutException {\nIterator<Integer> indexItr = order.iterator();\nV result = initResult();\nfor (Future<K> future : futures) {\n\/\/ TODO: the max time this can take is actually N * timeout. Consider fixing this.\nresult = aggregate(future.get(timeout, unit), indexItr, result);\n}\nreturn result;\n}","label":[1,0,0,0]}
{"id":11905,"original_code":"private void processCommands(GuildMessageReceivedEvent event, GuildData guildData, String trigger, String[] args, boolean isMention) {\n        ICommandMain cmd = CascadeBot.INS.getCommandManager().getCommand(trigger, event.getAuthor(), guildData);\n        if (cmd != null) {\n            if (cmd.getModule().isPublicModule() &&\n                    !guildData.isModuleEnabled(cmd.getModule())) {\n                if (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\n                    EmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\n                    builder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\n                    builder.setTimestamp(Instant.now());\n                    builder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\n                    Messaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n                }\n                \/\/ TODO: Modlog?\n                return;\n            }\n            CommandContext context = new CommandContext(\n                    event.getJDA(),\n                    event.getChannel(),\n                    event.getMessage(),\n                    event.getGuild(),\n                    guildData,\n                    args,\n                    event.getMember(),\n                    trigger,\n                    isMention\n            );\n            if (args.length >= 1) {\n                if (processSubCommands(cmd, args, context)) {\n                    return;\n                }\n            }\n            dispatchCommand(cmd, context);\n        }\n    }","code":"private void processCommands(GuildMessageReceivedEvent event, GuildData guildData, String trigger, String[] args, boolean isMention) {\n        ICommandMain cmd = CascadeBot.INS.getCommandManager().getCommand(trigger, event.getAuthor(), guildData);\n        if (cmd != null) {\n            if (cmd.getModule().isPublicModule() &&\n                    !guildData.isModuleEnabled(cmd.getModule())) {\n                if (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\n                    EmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\n                    builder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\n                    builder.setTimestamp(Instant.now());\n                    builder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\n                    Messaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n                }\n               \n                return;\n            }\n            CommandContext context = new CommandContext(\n                    event.getJDA(),\n                    event.getChannel(),\n                    event.getMessage(),\n                    event.getGuild(),\n                    guildData,\n                    args,\n                    event.getMember(),\n                    trigger,\n                    isMention\n            );\n            if (args.length >= 1) {\n                if (processSubCommands(cmd, args, context)) {\n                    return;\n                }\n            }\n            dispatchCommand(cmd, context);\n        }\n    }","cleancode":"private void processcommands(guildmessagereceivedevent event, guilddata guilddata, string trigger, string[] args, boolean ismention) { icommandmain cmd = cascadebot.ins.getcommandmanager().getcommand(trigger, event.getauthor(), guilddata); if (cmd != null) { if (cmd.getmodule().ispublicmodule() && !guilddata.ismoduleenabled(cmd.getmodule())) { if (guilddata.getsettings().willdisplaymoduleerrors() || environment.isdevelopment()) { embedbuilder builder = messagingobjects.getclearthreadlocalembedbuilder(); builder.setdescription(string.format(\"the module `%s` for command `%s` is disabled!\", cmd.getmodule().tostring(), trigger)); builder.settimestamp(instant.now()); builder.setfooter(\"requested by \" + event.getauthor().getastag(), event.getauthor().geteffectiveavatarurl()); messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } return; } commandcontext context = new commandcontext( event.getjda(), event.getchannel(), event.getmessage(), event.getguild(), guilddata, args, event.getmember(), trigger, ismention ); if (args.length >= 1) { if (processsubcommands(cmd, args, context)) { return; } } dispatchcommand(cmd, context); } }","comment":"\/\/ todo: modlog?","repo":"Ikinon\/CascadeBot","code_context_2":"Messaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n}\n\/\/ TODO: Modlog?\nreturn;\n}","code_context_10":"if (cmd != null) {\nif (cmd.getModule().isPublicModule() &&\n!guildData.isModuleEnabled(cmd.getModule())) {\nif (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\nEmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\nbuilder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\nbuilder.setTimestamp(Instant.now());\nbuilder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\nMessaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n}\n\/\/ TODO: Modlog?\nreturn;\n}\nCommandContext context = new CommandContext(\nevent.getJDA(),\nevent.getChannel(),\nevent.getMessage(),\nevent.getGuild(),\nguildData,\nargs,\nevent.getMember(),","code_context_20":"private void processCommands(GuildMessageReceivedEvent event, GuildData guildData, String trigger, String[] args, boolean isMention) {\nICommandMain cmd = CascadeBot.INS.getCommandManager().getCommand(trigger, event.getAuthor(), guildData);\nif (cmd != null) {\nif (cmd.getModule().isPublicModule() &&\n!guildData.isModuleEnabled(cmd.getModule())) {\nif (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\nEmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\nbuilder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\nbuilder.setTimestamp(Instant.now());\nbuilder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\nMessaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n}\n\/\/ TODO: Modlog?\nreturn;\n}\nCommandContext context = new CommandContext(\nevent.getJDA(),\nevent.getChannel(),\nevent.getMessage(),\nevent.getGuild(),\nguildData,\nargs,\nevent.getMember(),\ntrigger,\nisMention\n);\nif (args.length >= 1) {\nif (processSubCommands(cmd, args, context)) {\nreturn;\n}\n}\ndispatchCommand(cmd, context);\n}","label":[0,1,0,0]}
{"id":3730,"original_code":"@Override\n        public MutableList<T> clone()\n        {\n            return new FastList<T>(this);\n        }","code":"@Override\n        public MutableList<T> clone()\n        {\n            return new FastList<T>(this);\n        }","cleancode":"@override public mutablelist<t> clone() { return new fastlist<t>(this); }","comment":"\/\/ weird implementation of clone() is ok on final classes","repo":"DiegoEliasCosta\/gs-collections","code_context_2":"@Override\npublic MutableList<T> clone()\n{\nreturn new FastList<T>(this);\n}","code_context_10":"@Override\npublic MutableList<T> clone()\n{\nreturn new FastList<T>(this);\n}","code_context_20":"@Override\npublic MutableList<T> clone()\n{\nreturn new FastList<T>(this);\n}","label":[1,0,0,0]}
{"id":3764,"original_code":"@PostMapping(\"{id}\/bloqueio\")\n    public ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\n        String ip = request.getRemoteAddr();\n        String userAgent = request.getHeader(HttpHeaders.USER_AGENT);\n        Optional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\n        if(possivelProposta.isEmpty()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\n            return ResponseEntity.notFound().build();\n        }\n        Proposta proposta = possivelProposta.get();\n        if(proposta.estaBloqueado()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\n            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n        }\n        if(!notificarLegado(id)){\n            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n                    .body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n        }\n        proposta.bloquear(ip, userAgent);\n        propostaRepository.save(proposta);\n        logger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\n        return ResponseEntity.ok().build();\n    }","code":"@PostMapping(\"{id}\/bloqueio\")\n    public ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\n        String ip = request.getRemoteAddr();\n        String userAgent = request.getHeader(HttpHeaders.USER_AGENT);\n        Optional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\n        if(possivelProposta.isEmpty()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\n            return ResponseEntity.notFound().build();\n        }\n        Proposta proposta = possivelProposta.get();\n        if(proposta.estaBloqueado()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\n            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n        }\n        if(!notificarLegado(id)){\n            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n                    .body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n        }\n        proposta.bloquear(ip, userAgent);\n        propostaRepository.save(proposta);\n        logger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\n        return ResponseEntity.ok().build();\n    }","cleancode":"@postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","comment":"\/\/todo: refatorar","repo":"EDUMATT3\/orange-talents-06-template-proposta","code_context_2":"@PostMapping(\"{id}\/bloqueio\")\npublic ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\nString ip = request.getRemoteAddr();\nString userAgent = request.getHeader(HttpHeaders.USER_AGENT);\nOptional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\nif(possivelProposta.isEmpty()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\nreturn ResponseEntity.notFound().build();\n}\nProposta proposta = possivelProposta.get();\nif(proposta.estaBloqueado()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\nreturn ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n}\nif(!notificarLegado(id)){\nreturn ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n.body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n}\nproposta.bloquear(ip, userAgent);\npropostaRepository.save(proposta);\nlogger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\nreturn ResponseEntity.ok().build();\n}","code_context_10":"@PostMapping(\"{id}\/bloqueio\")\npublic ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\nString ip = request.getRemoteAddr();\nString userAgent = request.getHeader(HttpHeaders.USER_AGENT);\nOptional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\nif(possivelProposta.isEmpty()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\nreturn ResponseEntity.notFound().build();\n}\nProposta proposta = possivelProposta.get();\nif(proposta.estaBloqueado()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\nreturn ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n}\nif(!notificarLegado(id)){\nreturn ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n.body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n}\nproposta.bloquear(ip, userAgent);\npropostaRepository.save(proposta);\nlogger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\nreturn ResponseEntity.ok().build();\n}","code_context_20":"@PostMapping(\"{id}\/bloqueio\")\npublic ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\nString ip = request.getRemoteAddr();\nString userAgent = request.getHeader(HttpHeaders.USER_AGENT);\nOptional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\nif(possivelProposta.isEmpty()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\nreturn ResponseEntity.notFound().build();\n}\nProposta proposta = possivelProposta.get();\nif(proposta.estaBloqueado()){\nlogger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\nreturn ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n}\nif(!notificarLegado(id)){\nreturn ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n.body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n}\nproposta.bloquear(ip, userAgent);\npropostaRepository.save(proposta);\nlogger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\nreturn ResponseEntity.ok().build();\n}","label":[1,0,0,0]}
{"id":20267,"original_code":"@Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.send_to_this_address_action: {\n                if (onSendToAddressClickListener != null) {\n                    onSendToAddressClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.add_custom_token_action: {\n                if (onAddCustonTokenClickListener != null) {\n                    onAddCustonTokenClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.watch_account_action: {\n                if (onWatchWalletClickListener != null) {\n                    onWatchWalletClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.open_in_etherscan_action: {\n                if (onOpenInEtherscanClickListener != null) {\n                    onOpenInEtherscanClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.close_action: {\n                if (onCloseActionListener != null) {\n                    onCloseActionListener.onClick(view);\n                }\n                break;\n            }\n        }\n    }","code":"@Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.send_to_this_address_action: {\n                if (onSendToAddressClickListener != null) {\n                    onSendToAddressClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.add_custom_token_action: {\n                if (onAddCustonTokenClickListener != null) {\n                    onAddCustonTokenClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.watch_account_action: {\n                if (onWatchWalletClickListener != null) {\n                    onWatchWalletClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.open_in_etherscan_action: {\n                if (onOpenInEtherscanClickListener != null) {\n                    onOpenInEtherscanClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.close_action: {\n                if (onCloseActionListener != null) {\n                    onCloseActionListener.onClick(view);\n                }\n                break;\n            }\n        }\n    }","cleancode":"@override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","comment":"\/\/todo: refactor with if\/else","repo":"HTSUPK\/alpha-wallet-android","code_context_2":"@Override\npublic void onClick(View view) {\nswitch (view.getId()) {\ncase R.id.send_to_this_address_action: {\nif (onSendToAddressClickListener != null) {\nonSendToAddressClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.add_custom_token_action: {\nif (onAddCustonTokenClickListener != null) {\nonAddCustonTokenClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.watch_account_action: {\nif (onWatchWalletClickListener != null) {\nonWatchWalletClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.open_in_etherscan_action: {\nif (onOpenInEtherscanClickListener != null) {\nonOpenInEtherscanClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.close_action: {\nif (onCloseActionListener != null) {\nonCloseActionListener.onClick(view);\n}\nbreak;\n}\n}\n}","code_context_10":"@Override\npublic void onClick(View view) {\nswitch (view.getId()) {\ncase R.id.send_to_this_address_action: {\nif (onSendToAddressClickListener != null) {\nonSendToAddressClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.add_custom_token_action: {\nif (onAddCustonTokenClickListener != null) {\nonAddCustonTokenClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.watch_account_action: {\nif (onWatchWalletClickListener != null) {\nonWatchWalletClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.open_in_etherscan_action: {\nif (onOpenInEtherscanClickListener != null) {\nonOpenInEtherscanClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.close_action: {\nif (onCloseActionListener != null) {\nonCloseActionListener.onClick(view);\n}\nbreak;\n}\n}\n}","code_context_20":"@Override\npublic void onClick(View view) {\nswitch (view.getId()) {\ncase R.id.send_to_this_address_action: {\nif (onSendToAddressClickListener != null) {\nonSendToAddressClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.add_custom_token_action: {\nif (onAddCustonTokenClickListener != null) {\nonAddCustonTokenClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.watch_account_action: {\nif (onWatchWalletClickListener != null) {\nonWatchWalletClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.open_in_etherscan_action: {\nif (onOpenInEtherscanClickListener != null) {\nonOpenInEtherscanClickListener.onClick(view);\n}\nbreak;\n}\ncase R.id.close_action: {\nif (onCloseActionListener != null) {\nonCloseActionListener.onClick(view);\n}\nbreak;\n}\n}\n}","label":[1,0,0,0]}
{"id":20270,"original_code":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\n\t\tif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\n\t\t\tthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n\t\t}\n\t\tURI source = extractParameterAsUri(req, \"source\");\n\t\tURI target = extractParameterAsUri(req, \"target\");\n\t\t\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\n\t\tif (source.equals(target)) {\n\t\t\tthrow new BadRequestException(\"Source and target URL must not be identical.\");\n\t\t}\n\t\t\/\/ TODO: allow configuration of allowed target URI hosts.\n\t\tLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\t\t\/\/ TODO: perform check async\n\t\t\/*\n\t\t * Spec:\n\t\t * 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n\t\t * incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n\t\t * on source [...] to confirm that it actually mentions the target.\n\t\t *\/\n\t\ttry {\n\t\t\tif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\t\t\t\tLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget);\n\t\t\t} else {\n\t\t\t\tthrow new BadRequestException(\"Source does not contain link to target URL.\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\t\t\t\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\n\t\t\tthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n\t\t} catch (VerificationService.UnsupportedContentTypeException e) {\n\t\t\tthrow new BadRequestException(\n\t\t\t\t\"Verification of source URL failed due to no supported content type being served.\",\n\t\t\t\te);\n\t\t}\n\t\thandleSubmission(source, target);\n\t}","code":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\n\t\tif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\n\t\t\tthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n\t\t}\n\t\tURI source = extractParameterAsUri(req, \"source\");\n\t\tURI target = extractParameterAsUri(req, \"target\");\n\t\n\t\tif (source.equals(target)) {\n\t\t\tthrow new BadRequestException(\"Source and target URL must not be identical.\");\n\t\t}\n\t\n\t\tLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\t\n\t\n\t\ttry {\n\t\t\tif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\t\t\t\tLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget);\n\t\t\t} else {\n\t\t\t\tthrow new BadRequestException(\"Source does not contain link to target URL.\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\n\t\t\n\t\t\tthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n\t\t} catch (VerificationService.UnsupportedContentTypeException e) {\n\t\t\tthrow new BadRequestException(\n\t\t\t\t\"Verification of source URL failed due to no supported content type being served.\",\n\t\t\t\te);\n\t\t}\n\t\thandleSubmission(source, target);\n\t}","cleancode":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","comment":"\/\/ spec: 'the receiver must reject the request if the source url is the same as the target url.'\n\/\/ todo: allow configuration of allowed target uri hosts.\n\/\/ todo: perform check async \/* * spec: * 'if the receiver is going to use the webmention in some way, (displaying it as a comment on a post, * incrementing a \"like\" counter, notifying the author of a post), then it must perform an http get request * on source [...] to confirm that it actually mentions the target. *\/\n\/\/ in theory i\/o failures cold also be issues on our side (e.g. trusted cas being wrong), but \/\/ differentiating between those and issues on the source uris side (e.g. 404s) seems hard.","repo":"FelixRilling\/webmention4j","code_context_2":"URI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\nthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n} catch (VerificationService.UnsupportedContentTypeException e) {","code_context_10":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\nif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n\nprivate void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\nif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\nthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n} catch (VerificationService.UnsupportedContentTypeException e) {\nthrow new BadRequestException(\n\"Verification of source URL failed due to no supported content type being served.\",\ne);\n}\nhandleSubmission(source, target);\n}","code_context_20":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\nif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n\nprivate void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\nif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\nthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n\nprivate void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\nif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\nthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n}\nURI source = extractParameterAsUri(req, \"source\");\nURI target = extractParameterAsUri(req, \"target\");\n\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\nif (source.equals(target)) {\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\nthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n} catch (VerificationService.UnsupportedContentTypeException e) {\nthrow new BadRequestException(\n\"Verification of source URL failed due to no supported content type being served.\",\ne);\n}\nhandleSubmission(source, target);\n}\n\nthrow new BadRequestException(\"Source and target URL must not be identical.\");\n}\n\/\/ TODO: allow configuration of allowed target URI hosts.\nLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\/\/ TODO: perform check async\n\/*\n* Spec:\n* 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n* incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n* on source [...] to confirm that it actually mentions the target.\n*\/\ntry {\nif (verificationService.isSubmissionValid(httpClient, source, target)) {\nLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\nsource,\ntarget);\n} else {\nthrow new BadRequestException(\"Source does not contain link to target URL.\");\n}\n} catch (IOException e) {\n\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\nthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n} catch (VerificationService.UnsupportedContentTypeException e) {\nthrow new BadRequestException(\n\"Verification of source URL failed due to no supported content type being served.\",\ne);\n}\nhandleSubmission(source, target);\n}","label":[1,1,0,0]}
{"id":20319,"original_code":"@BeforeEach\n    public void setUp() throws Exception {\n        \/\/ Hack our RouteBuilder into the context. Bean definition \/ ComponentScan doesn't work for RouteBuilders.\n        if (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\n            camelContext.addRoutes(ccrsAdapter);\n        }\n        if (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\n            camelContext.addRoutes(ccrsClient);\n        }\n    }","code":"@BeforeEach\n    public void setUp() throws Exception {\n       \n        if (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\n            camelContext.addRoutes(ccrsAdapter);\n        }\n        if (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\n            camelContext.addRoutes(ccrsClient);\n        }\n    }","cleancode":"@beforeeach public void setup() throws exception { if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter); } if (camelcontext.getroute(camelcustomerratingserviceclient.uri) == null) { camelcontext.addroutes(ccrsclient); } }","comment":"\/\/ hack our routebuilder into the context. bean definition \/ componentscan doesn't work for routebuilders.","repo":"BertKoor\/camelCase","code_context_2":"@BeforeEach\npublic void setUp() throws Exception {\n\/\/ Hack our RouteBuilder into the context. Bean definition \/ ComponentScan doesn't work for RouteBuilders.\nif (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\ncamelContext.addRoutes(ccrsAdapter);","code_context_10":"@BeforeEach\npublic void setUp() throws Exception {\n\/\/ Hack our RouteBuilder into the context. Bean definition \/ ComponentScan doesn't work for RouteBuilders.\nif (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\ncamelContext.addRoutes(ccrsAdapter);\n}\nif (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\ncamelContext.addRoutes(ccrsClient);\n}\n}","code_context_20":"@BeforeEach\npublic void setUp() throws Exception {\n\/\/ Hack our RouteBuilder into the context. Bean definition \/ ComponentScan doesn't work for RouteBuilders.\nif (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\ncamelContext.addRoutes(ccrsAdapter);\n}\nif (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\ncamelContext.addRoutes(ccrsClient);\n}\n}","label":[0,0,1,0]}
{"id":20732,"original_code":"public static void exportTaskgraph() {\n        final TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\n        final FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\n        int result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\n        if (result == TFileChooser.APPROVE_OPTION) {\n            Thread thread = new Thread() {\n                public void run() {\n                    TrianaProgressBar pb = null;\n                    String filename = \"\";\n                    try {\n                        \/\/ Bug fix for not picking up file name text.\n                        if (fc.getUI() instanceof BasicFileChooserUI) {\n                            filename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n                        }\n                        pb = new TrianaProgressBar(\"exporting: \" + filename, false);\n                        chooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n                    } catch (IOException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } catch (TaskGraphException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } finally {\n                        if (pb != null) {\n                            pb.disposeProgressBar();\n                        }\n                    }\n                }\n            };\n            thread.setName(\"Export Task Graph\");\n            thread.setPriority(Thread.NORM_PRIORITY);\n            thread.start();\n        }\n    }","code":"public static void exportTaskgraph() {\n        final TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\n        final FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\n        int result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\n        if (result == TFileChooser.APPROVE_OPTION) {\n            Thread thread = new Thread() {\n                public void run() {\n                    TrianaProgressBar pb = null;\n                    String filename = \"\";\n                    try {\n                       \n                        if (fc.getUI() instanceof BasicFileChooserUI) {\n                            filename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n                        }\n                        pb = new TrianaProgressBar(\"exporting: \" + filename, false);\n                        chooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n                    } catch (IOException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } catch (TaskGraphException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } finally {\n                        if (pb != null) {\n                            pb.disposeProgressBar();\n                        }\n                    }\n                }\n            };\n            thread.setName(\"Export Task Graph\");\n            thread.setPriority(Thread.NORM_PRIORITY);\n            thread.start();\n        }\n    }","cleancode":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","comment":"\/** * show the export file dialog and export the current selected task graph using the selected * <code>fileimportexportdecorator.exportworkflow<\/code> method. *\/\n\/\/ bug fix for not picking up file name text.","repo":"CSCSI\/Triana","code_context_2":"public static void exportTaskgraph() {\nfinal TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\nfinal FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\nint result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\nif (result == TFileChooser.APPROVE_OPTION) {\nThread thread = new Thread() {\npublic void run() {\nTrianaProgressBar pb = null;\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n}\npb = new TrianaProgressBar(\"exporting: \" + filename, false);\nchooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n} catch (IOException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} catch (TaskGraphException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} finally {\nif (pb != null) {\npb.disposeProgressBar();\n}\n}\n}\n};\nthread.setName(\"Export Task Graph\");\nthread.setPriority(Thread.NORM_PRIORITY);\nthread.start();\n}\n}\n\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();","code_context_10":"public static void exportTaskgraph() {\nfinal TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\nfinal FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\nint result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\nif (result == TFileChooser.APPROVE_OPTION) {\nThread thread = new Thread() {\npublic void run() {\nTrianaProgressBar pb = null;\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n}\npb = new TrianaProgressBar(\"exporting: \" + filename, false);\nchooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n} catch (IOException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} catch (TaskGraphException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} finally {\nif (pb != null) {\npb.disposeProgressBar();\n}\n}\n}\n};\nthread.setName(\"Export Task Graph\");\nthread.setPriority(Thread.NORM_PRIORITY);\nthread.start();\n}\n}\n\npublic static void exportTaskgraph() {\nfinal TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\nfinal FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\nint result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\nif (result == TFileChooser.APPROVE_OPTION) {\nThread thread = new Thread() {\npublic void run() {\nTrianaProgressBar pb = null;\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n}\npb = new TrianaProgressBar(\"exporting: \" + filename, false);\nchooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n} catch (IOException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} catch (TaskGraphException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());","code_context_20":"public static void exportTaskgraph() {\nfinal TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\nfinal FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\nint result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\nif (result == TFileChooser.APPROVE_OPTION) {\nThread thread = new Thread() {\npublic void run() {\nTrianaProgressBar pb = null;\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n}\npb = new TrianaProgressBar(\"exporting: \" + filename, false);\nchooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n} catch (IOException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} catch (TaskGraphException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} finally {\nif (pb != null) {\npb.disposeProgressBar();\n}\n}\n}\n};\nthread.setName(\"Export Task Graph\");\nthread.setPriority(Thread.NORM_PRIORITY);\nthread.start();\n}\n}\n\npublic static void exportTaskgraph() {\nfinal TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\nfinal FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\nint result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\nif (result == TFileChooser.APPROVE_OPTION) {\nThread thread = new Thread() {\npublic void run() {\nTrianaProgressBar pb = null;\nString filename = \"\";\ntry {\n\/\/ Bug fix for not picking up file name text.\nif (fc.getUI() instanceof BasicFileChooserUI) {\nfilename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n}\npb = new TrianaProgressBar(\"exporting: \" + filename, false);\nchooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n} catch (IOException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} catch (TaskGraphException e) {\nErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\ne.printStackTrace();\n} finally {\nif (pb != null) {\npb.disposeProgressBar();\n}\n}\n}\n};\nthread.setName(\"Export Task Graph\");\nthread.setPriority(Thread.NORM_PRIORITY);","label":[0,0,1,0]}
{"id":20999,"original_code":"@Override\n\tpublic KVMessage putKV(final int clientPort, final String key, final String value)\n\t\t\tthrows InvalidMessageException {\n\t\tlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\n\t\tKVMessage res;\n\t\tStatusType putStat;\n\t\t\/\/ TODO: Cleanup the clientRequests after the requests are completed\n\t\tclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\n\t\tNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\t\t\/\/ add thread to back of list for this key - add is thread safe\n\t\tint[] node = { clientPort, op.getVal() };\n\t\tclientRequests.get(key).addToQueue(node);\n\t\tif (test) {\n\t\t\tlogger.info(clientPort + \"> !!!!===wait===!!!!\");\n\t\t\twhile (wait)\n\t\t\t\t;\n\t\t\tlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n\t\t}\n\t\t\/\/ wait (spin) until threads turn and no one is reading\n\t\t\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\t\t\/\/ work\n\t\twhile (clientRequests.get(key).peek()[0] != clientPort)\n\t\t\t;\n\t\t\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\t\t\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\n\t\tlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\n\t\tif (value.equals(\"null\")) {\n\t\t\t\/\/ Delete the key\n\t\t\tlogger.info(clientPort + \"> Trying to delete record ...\");\n\t\t\tputStat = StatusType.DELETE_SUCCESS;\n\t\t\ttry {\n\t\t\t\t\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\t\t\t\t\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\t\t\t\t\/\/ operation cancels)\n\t\t\t\t\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\t\t\t\t\/\/ return key DNE\n\t\t\t\t\/\/ Otherwise, return the key\n\t\t\t\t\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\t\t\t\t\/\/ remove it from the clientRequests\n\t\t\t\t\/\/ Delete it from the cache as well!\n\t\t\t\t\/\/ remove the top item from the list for this key\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\tlogger.info(clientPort + \"> Not in storage ...\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t} else if (!clientRequests.get(key).isDeleted()) {\n\t\t\t\t\tlogger.info(clientPort + \"> Marked for deletion\");\n\t\t\t\t\tclientRequests.get(key).setDeleted(true);\n\t\t\t\t\tRunnable pruneDelete = new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> Starting pruning thread\");\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\/\/ logger.debug(\"Prune waiting\");\n\t\t\t\t\t\t\t} while (!clientRequests.get(key).isEmpty());\n\t\t\t\t\t\t\tclientRequests.remove(key);\n\t\t\t\t\t\t\tif (cache != null) {\n\t\t\t\t\t\t\t\tcache.remove(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFile file = new File(storageDirectory + key);\n\t\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tclientRequests.get(key).startPruning(pruneDelete);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.info(clientPort + \"> Deletion exception ...\");\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/ Insert\/update the key\n\t\t\tlogger.info(clientPort + \"> Trying to insert\/update record\");\n\t\t\ttry {\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\t\/\/ Inserting a new key\n\t\t\t\t\tlogger.info(clientPort + \"> Going to insert record\");\n\t\t\t\t\tputStat = StatusType.PUT_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ Updating a key\n\t\t\t\t\tlogger.info(clientPort + \"> Going to update record\");\n\t\t\t\t\tputStat = StatusType.PUT_UPDATE;\n\t\t\t\t\tif (clientRequests.get(key).isDeleted()) {\n\t\t\t\t\t\t\/\/ Stop the deletion\n\t\t\t\t\t\tclientRequests.get(key).stopPruning();\n\t\t\t\t\t\tclientRequests.get(key).setDeleted(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinsertCache(key, value);\n\t\t\t\tFileWriter myWriter = new FileWriter(storageDirectory + key);\n\t\t\t\tmyWriter.write(value);\n\t\t\t\tmyWriter.close();\n\t\t\t\t\/\/ Sleep for a bit to let data take effect\n\t\t\t\t\/\/ Thread.sleep(1000);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.PUT_ERROR;\n\t\t\t}\n\t\t}\n\t\t\/\/ remove the top item from the list for this key\n\t\tremoveTopQueue(key);\n\t\tlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\n\t\ttry {\n\t\t\tres = new KVMessage(key, value, putStat);\n\t\t} catch (InvalidMessageException ime) {\n\t\t\tthrow ime;\n\t\t}\n\t\treturn res;\n\t}","code":"@Override\n\tpublic KVMessage putKV(final int clientPort, final String key, final String value)\n\t\t\tthrows InvalidMessageException {\n\t\tlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\n\t\tKVMessage res;\n\t\tStatusType putStat;\n\t\n\t\tclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\n\t\tNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\t\n\t\tint[] node = { clientPort, op.getVal() };\n\t\tclientRequests.get(key).addToQueue(node);\n\t\tif (test) {\n\t\t\tlogger.info(clientPort + \"> !!!!===wait===!!!!\");\n\t\t\twhile (wait)\n\t\t\t\t;\n\t\t\tlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n\t\t}\n\t\n\t\n\t\n\t\twhile (clientRequests.get(key).peek()[0] != clientPort)\n\t\t\t;\n\t\n\t\n\t\tlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\n\t\tif (value.equals(\"null\")) {\n\t\t\n\t\t\tlogger.info(clientPort + \"> Trying to delete record ...\");\n\t\t\tputStat = StatusType.DELETE_SUCCESS;\n\t\t\ttry {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\tlogger.info(clientPort + \"> Not in storage ...\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t} else if (!clientRequests.get(key).isDeleted()) {\n\t\t\t\t\tlogger.info(clientPort + \"> Marked for deletion\");\n\t\t\t\t\tclientRequests.get(key).setDeleted(true);\n\t\t\t\t\tRunnable pruneDelete = new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> Starting pruning thread\");\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} while (!clientRequests.get(key).isEmpty());\n\t\t\t\t\t\t\tclientRequests.remove(key);\n\t\t\t\t\t\t\tif (cache != null) {\n\t\t\t\t\t\t\t\tcache.remove(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFile file = new File(storageDirectory + key);\n\t\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tclientRequests.get(key).startPruning(pruneDelete);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.info(clientPort + \"> Deletion exception ...\");\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\n\t\t\tlogger.info(clientPort + \"> Trying to insert\/update record\");\n\t\t\ttry {\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\n\t\t\t\t\tlogger.info(clientPort + \"> Going to insert record\");\n\t\t\t\t\tputStat = StatusType.PUT_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tlogger.info(clientPort + \"> Going to update record\");\n\t\t\t\t\tputStat = StatusType.PUT_UPDATE;\n\t\t\t\t\tif (clientRequests.get(key).isDeleted()) {\n\t\t\t\t\t\n\t\t\t\t\t\tclientRequests.get(key).stopPruning();\n\t\t\t\t\t\tclientRequests.get(key).setDeleted(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinsertCache(key, value);\n\t\t\t\tFileWriter myWriter = new FileWriter(storageDirectory + key);\n\t\t\t\tmyWriter.write(value);\n\t\t\t\tmyWriter.close();\n\t\t\t\n\t\t\t\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.PUT_ERROR;\n\t\t\t}\n\t\t}\n\t\n\t\tremoveTopQueue(key);\n\t\tlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\n\t\ttry {\n\t\t\tres = new KVMessage(key, value, putStat);\n\t\t} catch (InvalidMessageException ime) {\n\t\t\tthrow ime;\n\t\t}\n\t\treturn res;\n\t}","cleancode":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } while (clientrequests.get(key).peek()[0] != clientport) ; logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","comment":"\/\/ todo: cleanup the clientrequests after the requests are completed\n\/\/ add thread to back of list for this key - add is thread safe\n\/\/ wait (spin) until threads turn and no one is reading \/\/ todo: if a key gets deleted, i think clientrequests.get(key) would no longer \/\/ work\n\/\/ while (clientrequests.get(key).peek()[0] != clientport || \/\/ clientrequests.get(key).availablepermits() != max_reads);\n\/\/ delete the key\n\/\/ todo: mark it as deleted then loop to see if anybody is reading\/writing to it \/\/ if a write is after, keep the row by unmarking it as deleted (since the \/\/ operation cancels) \/\/ if a read is after, check the deleted flag, if its deleted, make sure to \/\/ return key dne \/\/ otherwise, return the key \/\/ if at any point the queue is empty, and the row is marked as deleted, then \/\/ remove it from the clientrequests \/\/ delete it from the cache as well! \/\/ remove the top item from the list for this key\n\/\/ logger.debug(\"prune waiting\");\n\/\/ insert\/update the key\n\/\/ inserting a new key\n\/\/ updating a key\n\/\/ stop the deletion\n\/\/ sleep for a bit to let data take effect \/\/ thread.sleep(1000);\n\/\/ remove the top item from the list for this key","repo":"CAPIndustries\/capDB","code_context_2":"KVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\n\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\n\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\n\nlogger.info(clientPort + \"> Starting pruning thread\");\ndo {\n\/\/ logger.debug(\"Prune waiting\");\n} while (!clientRequests.get(key).isEmpty());\nclientRequests.remove(key);\n\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\n\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\n\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\n\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");","code_context_10":"@Override\npublic KVMessage putKV(final int clientPort, final String key, final String value)\nthrows InvalidMessageException {\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n\n@Override\npublic KVMessage putKV(final int clientPort, final String key, final String value)\nthrows InvalidMessageException {\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");\n\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");\ndo {\n\/\/ logger.debug(\"Prune waiting\");\n} while (!clientRequests.get(key).isEmpty());\nclientRequests.remove(key);\nif (cache != null) {\ncache.remove(key);\n}\nFile file = new File(storageDirectory + key);\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n}\n};\n\nlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\nputStat = StatusType.DELETE_ERROR;\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\n\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\n\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.PUT_ERROR;\n}\n}\n\/\/ remove the top item from the list for this key\nremoveTopQueue(key);\nlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\ntry {\n\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");","code_context_20":"@Override\npublic KVMessage putKV(final int clientPort, final String key, final String value)\nthrows InvalidMessageException {\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\n@Override\npublic KVMessage putKV(final int clientPort, final String key, final String value)\nthrows InvalidMessageException {\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\n\n@Override\npublic KVMessage putKV(final int clientPort, final String key, final String value)\nthrows InvalidMessageException {\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\n\nlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\nKVMessage res;\nStatusType putStat;\n\/\/ TODO: Cleanup the clientRequests after the requests are completed\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\n\nclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\nNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\/\/ add thread to back of list for this key - add is thread safe\nint[] node = { clientPort, op.getVal() };\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n\nclientRequests.get(key).addToQueue(node);\nif (test) {\nlogger.info(clientPort + \"> !!!!===wait===!!!!\");\nwhile (wait)\n;\nlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n}\n\/\/ wait (spin) until threads turn and no one is reading\n\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");\ndo {\n\/\/ logger.debug(\"Prune waiting\");\n} while (!clientRequests.get(key).isEmpty());\nclientRequests.remove(key);\nif (cache != null) {\ncache.remove(key);\n}\nFile file = new File(storageDirectory + key);\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");\ndo {\n\/\/ logger.debug(\"Prune waiting\");\n} while (!clientRequests.get(key).isEmpty());\nclientRequests.remove(key);\nif (cache != null) {\ncache.remove(key);\n}\nFile file = new File(storageDirectory + key);\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n}\n};\nclientRequests.get(key).startPruning(pruneDelete);\n} else {\nlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\nputStat = StatusType.DELETE_ERROR;\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n\nif (cache != null) {\ncache.remove(key);\n}\nFile file = new File(storageDirectory + key);\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n}\n};\nclientRequests.get(key).startPruning(pruneDelete);\n} else {\nlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\nputStat = StatusType.DELETE_ERROR;\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n}\n};\nclientRequests.get(key).startPruning(pruneDelete);\n} else {\nlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\nputStat = StatusType.DELETE_ERROR;\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\n\nclientRequests.get(key).startPruning(pruneDelete);\n} else {\nlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\nputStat = StatusType.DELETE_ERROR;\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.PUT_ERROR;\n}\n}\n\n}\n} catch (Exception e) {\nlogger.info(clientPort + \"> Deletion exception ...\");\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.DELETE_ERROR;\n}\n} else {\n\/\/ Insert\/update the key\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.PUT_ERROR;\n}\n}\n\/\/ remove the top item from the list for this key\nremoveTopQueue(key);\nlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\ntry {\n\nlogger.info(clientPort + \"> Trying to insert\/update record\");\ntry {\nif (!inStorage(key)) {\n\/\/ Inserting a new key\nlogger.info(clientPort + \"> Going to insert record\");\nputStat = StatusType.PUT_SUCCESS;\n} else {\n\/\/ Updating a key\nlogger.info(clientPort + \"> Going to update record\");\nputStat = StatusType.PUT_UPDATE;\nif (clientRequests.get(key).isDeleted()) {\n\/\/ Stop the deletion\nclientRequests.get(key).stopPruning();\nclientRequests.get(key).setDeleted(false);\n}\n}\ninsertCache(key, value);\nFileWriter myWriter = new FileWriter(storageDirectory + key);\nmyWriter.write(value);\nmyWriter.close();\n\/\/ Sleep for a bit to let data take effect\n\/\/ Thread.sleep(1000);\n} catch (Exception e) {\nlogger.error(e);\nexceptionLogger(e);\nputStat = StatusType.PUT_ERROR;\n}\n}\n\/\/ remove the top item from the list for this key\nremoveTopQueue(key);\nlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\ntry {\nres = new KVMessage(key, value, putStat);\n} catch (InvalidMessageException ime) {\nthrow ime;\n}\nreturn res;\n}\n\n\/\/ work\nwhile (clientRequests.get(key).peek()[0] != clientPort)\n;\n\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\nlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\nif (value.equals(\"null\")) {\n\/\/ Delete the key\nlogger.info(clientPort + \"> Trying to delete record ...\");\nputStat = StatusType.DELETE_SUCCESS;\ntry {\n\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\/\/ operation cancels)\n\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\/\/ return key DNE\n\/\/ Otherwise, return the key\n\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\/\/ remove it from the clientRequests\n\/\/ Delete it from the cache as well!\n\/\/ remove the top item from the list for this key\nif (!inStorage(key)) {\nlogger.info(clientPort + \"> Not in storage ...\");\nputStat = StatusType.DELETE_ERROR;\n} else if (!clientRequests.get(key).isDeleted()) {\nlogger.info(clientPort + \"> Marked for deletion\");\nclientRequests.get(key).setDeleted(true);\nRunnable pruneDelete = new Runnable() {\n@Override\npublic void run() {\nlogger.info(clientPort + \"> Starting pruning thread\");\ndo {\n\/\/ logger.debug(\"Prune waiting\");\n} while (!clientRequests.get(key).isEmpty());\nclientRequests.remove(key);\nif (cache != null) {\ncache.remove(key);\n}\nFile file = new File(storageDirectory + key);\nfile.delete();\nlogger.info(clientPort + \"> \" + key + \" successfully pruned\");","label":[1,1,0,0]}
{"id":21001,"original_code":"public static void main(String[] args) {\n\t\ttry {\n\t\t\tif (args.length != 6) {\n\t\t\t\tlogger.error(\"Error! Invalid number of arguments!\");\n\t\t\t\tlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\n\t\t\t\tSystem.exit(1);\n\t\t\t} else {\n\t\t\t\tString name = args[0];\n\t\t\t\tint port = Integer.parseInt(args[1]);\n\t\t\t\tint zkPort = Integer.parseInt(args[2]);\n\t\t\t\tString ECSIP = args[3];\n\t\t\t\tboolean isLoadReplica = Boolean.parseBoolean(args[4]);\n\t\t\t\tString parentName = args[5];\n\t\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\t\t\t\tnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\t\t\t\t\/\/ No need to use the run method here since the contructor is supposed to\n\t\t\t\t\/\/ start the server on its own\n\t\t\t\t\/\/ TODO: Allow passing additional arguments from the command line:\n\t\t\t\tnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Error! Unable to initialize logger!\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\n\t\t\tSystem.out.println(\"Usage: Server <port>!\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","code":"public static void main(String[] args) {\n\t\ttry {\n\t\t\tif (args.length != 6) {\n\t\t\t\tlogger.error(\"Error! Invalid number of arguments!\");\n\t\t\t\tlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\n\t\t\t\tSystem.exit(1);\n\t\t\t} else {\n\t\t\t\tString name = args[0];\n\t\t\t\tint port = Integer.parseInt(args[1]);\n\t\t\t\tint zkPort = Integer.parseInt(args[2]);\n\t\t\t\tString ECSIP = args[3];\n\t\t\t\tboolean isLoadReplica = Boolean.parseBoolean(args[4]);\n\t\t\t\tString parentName = args[5];\n\t\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\t\t\t\tnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Error! Unable to initialize logger!\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\n\t\t\tSystem.out.println(\"Usage: Server <port>!\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","cleancode":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","comment":"\/** * @param args contains the program's input args (here for signature purposes) *\/\n\/\/ no need to use the run method here since the contructor is supposed to \/\/ start the server on its own \/\/ todo: allow passing additional arguments from the command line:","repo":"CAPIndustries\/capDB","code_context_2":"public static void main(String[] args) {\ntry {\nif (args.length != 6) {\nlogger.error(\"Error! Invalid number of arguments!\");\nlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\nSystem.exit(1);\n} else {\nString name = args[0];\nint port = Integer.parseInt(args[1]);\nint zkPort = Integer.parseInt(args[2]);\nString ECSIP = args[3];\nboolean isLoadReplica = Boolean.parseBoolean(args[4]);\nString parentName = args[5];\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}\n} catch (IOException e) {\nSystem.out.println(\"Error! Unable to initialize logger!\");\ne.printStackTrace();\nSystem.exit(1);\n} catch (NumberFormatException nfe) {\nSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\nSystem.out.println(\"Usage: Server <port>!\");\nSystem.exit(1);\n}\n}\n\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}","code_context_10":"public static void main(String[] args) {\ntry {\nif (args.length != 6) {\nlogger.error(\"Error! Invalid number of arguments!\");\nlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\nSystem.exit(1);\n} else {\nString name = args[0];\nint port = Integer.parseInt(args[1]);\nint zkPort = Integer.parseInt(args[2]);\nString ECSIP = args[3];\nboolean isLoadReplica = Boolean.parseBoolean(args[4]);\nString parentName = args[5];\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}\n} catch (IOException e) {\nSystem.out.println(\"Error! Unable to initialize logger!\");\ne.printStackTrace();\nSystem.exit(1);\n} catch (NumberFormatException nfe) {\nSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\nSystem.out.println(\"Usage: Server <port>!\");\nSystem.exit(1);\n}\n}\n\nSystem.exit(1);\n} else {\nString name = args[0];\nint port = Integer.parseInt(args[1]);\nint zkPort = Integer.parseInt(args[2]);\nString ECSIP = args[3];\nboolean isLoadReplica = Boolean.parseBoolean(args[4]);\nString parentName = args[5];\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}\n} catch (IOException e) {\nSystem.out.println(\"Error! Unable to initialize logger!\");\ne.printStackTrace();\nSystem.exit(1);\n} catch (NumberFormatException nfe) {\nSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\nSystem.out.println(\"Usage: Server <port>!\");\nSystem.exit(1);","code_context_20":"public static void main(String[] args) {\ntry {\nif (args.length != 6) {\nlogger.error(\"Error! Invalid number of arguments!\");\nlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\nSystem.exit(1);\n} else {\nString name = args[0];\nint port = Integer.parseInt(args[1]);\nint zkPort = Integer.parseInt(args[2]);\nString ECSIP = args[3];\nboolean isLoadReplica = Boolean.parseBoolean(args[4]);\nString parentName = args[5];\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}\n} catch (IOException e) {\nSystem.out.println(\"Error! Unable to initialize logger!\");\ne.printStackTrace();\nSystem.exit(1);\n} catch (NumberFormatException nfe) {\nSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\nSystem.out.println(\"Usage: Server <port>!\");\nSystem.exit(1);\n}\n}\n\npublic static void main(String[] args) {\ntry {\nif (args.length != 6) {\nlogger.error(\"Error! Invalid number of arguments!\");\nlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\nSystem.exit(1);\n} else {\nString name = args[0];\nint port = Integer.parseInt(args[1]);\nint zkPort = Integer.parseInt(args[2]);\nString ECSIP = args[3];\nboolean isLoadReplica = Boolean.parseBoolean(args[4]);\nString parentName = args[5];\nSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\nnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\/\/ No need to use the run method here since the contructor is supposed to\n\/\/ start the server on its own\n\/\/ TODO: Allow passing additional arguments from the command line:\nnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n}\n} catch (IOException e) {\nSystem.out.println(\"Error! Unable to initialize logger!\");\ne.printStackTrace();\nSystem.exit(1);\n} catch (NumberFormatException nfe) {\nSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\nSystem.out.println(\"Usage: Server <port>!\");\nSystem.exit(1);\n}\n}","label":[1,0,0,0]}
{"id":21046,"original_code":"@Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    \/\/ Inflate the layout for this fragment\n    llView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\n    llView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new StrokePL();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new GroupLayer();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        \/\/TODO This will need to change, for settings, etc.\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        List<Class> classes = new ArrayList<Class>();\n        try {\n          classes = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n        } catch (NoSuchMethodException e) {\n          e.printStackTrace();\n        } catch (IOException e) {\n          e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n          e.printStackTrace();\n        }\n        classes.remove(UACanvas.class);\n        ArrayList<String> classNames = new ArrayList<String>();\n        for (Class<?> clazz : classes) {\n          classNames.add(clazz.getName());\n        }\n        String[] layerTypes = new String[]{};\n        layerTypes = classNames.toArray(layerTypes);\n        final List<Class> fClasses = classes;\n        builder.setTitle(\"Pick a layer type\")\n                .setItems(layerTypes, new DialogInterface.OnClickListener() {\n                  public void onClick(DialogInterface dialog, int which) {\n                    try {\n                      Layer newLayer = (Layer)fClasses.get(which).newInstance();\n                      createLayer(((IDd<ID>)mTree).getId(), newLayer);\n                    } catch (java.lang.InstantiationException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    } catch (IllegalAccessException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    }\n                  }\n                });\n        builder.show();\n      }\n    });\n    updateView();\n    return llView;\n  }","code":"@Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n   \n    llView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\n    llView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new StrokePL();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new GroupLayer();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n       \n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        List<Class> classes = new ArrayList<Class>();\n        try {\n          classes = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n        } catch (NoSuchMethodException e) {\n          e.printStackTrace();\n        } catch (IOException e) {\n          e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n          e.printStackTrace();\n        }\n        classes.remove(UACanvas.class);\n        ArrayList<String> classNames = new ArrayList<String>();\n        for (Class<?> clazz : classes) {\n          classNames.add(clazz.getName());\n        }\n        String[] layerTypes = new String[]{};\n        layerTypes = classNames.toArray(layerTypes);\n        final List<Class> fClasses = classes;\n        builder.setTitle(\"Pick a layer type\")\n                .setItems(layerTypes, new DialogInterface.OnClickListener() {\n                  public void onClick(DialogInterface dialog, int which) {\n                    try {\n                      Layer newLayer = (Layer)fClasses.get(which).newInstance();\n                      createLayer(((IDd<ID>)mTree).getId(), newLayer);\n                    } catch (java.lang.InstantiationException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    } catch (IllegalAccessException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    }\n                  }\n                });\n        builder.show();\n      }\n    });\n    updateView();\n    return llView;\n  }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } classes.remove(uacanvas.class); arraylist<string> classnames = new arraylist<string>(); for (class<?> clazz : classes) { classnames.add(clazz.getname()); } string[] layertypes = new string[]{}; layertypes = classnames.toarray(layertypes); final list<class> fclasses = classes; builder.settitle(\"pick a layer type\") .setitems(layertypes, new dialoginterface.onclicklistener() { public void onclick(dialoginterface dialog, int which) { try { layer newlayer = (layer)fclasses.get(which).newinstance(); createlayer(((idd<id>)mtree).getid(), newlayer); } catch (java.lang.instantiationexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } catch (illegalaccessexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } } }); builder.show(); } }); updateview(); return llview; }","comment":"\/\/ inflate the layout for this fragment\n\/\/todo this will need to change, for settings, etc.","repo":"Erhannis\/UnstableArt","code_context_2":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\/\/ Inflate the layout for this fragment\nllView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\nllView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n\n@Override\npublic void onClick(View v) {\n\/\/TODO This will need to change, for settings, etc.\nAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\nList<Class> classes = new ArrayList<Class>();","code_context_10":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\/\/ Inflate the layout for this fragment\nllView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\nllView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new StrokePL();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n@Override\n\nllView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new GroupLayer();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO This will need to change, for settings, etc.\nAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\nList<Class> classes = new ArrayList<Class>();\ntry {\nclasses = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (IOException e) {\ne.printStackTrace();\n} catch (ClassNotFoundException e) {\ne.printStackTrace();","code_context_20":"@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\/\/ Inflate the layout for this fragment\nllView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\nllView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new StrokePL();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new GroupLayer();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO This will need to change, for settings, etc.\nAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\/\/ Inflate the layout for this fragment\nllView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\nllView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new StrokePL();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\nLayer newLayer = new GroupLayer();\ncreateLayer(((IDd<ID>)mTree).getId(), newLayer);\n}\n});\nllView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/TODO This will need to change, for settings, etc.\nAlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\nList<Class> classes = new ArrayList<Class>();\ntry {\nclasses = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (IOException e) {\ne.printStackTrace();\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\nclasses.remove(UACanvas.class);\nArrayList<String> classNames = new ArrayList<String>();\nfor (Class<?> clazz : classes) {\nclassNames.add(clazz.getName());\n}\nString[] layerTypes = new String[]{};\nlayerTypes = classNames.toArray(layerTypes);\nfinal List<Class> fClasses = classes;\nbuilder.setTitle(\"Pick a layer type\")","label":[1,0,0,0]}
{"id":21397,"original_code":"private mxGraphComponent createGraphComponent(mxGraph graph) {\n\t\tmxGraphComponent component = new mxGraphComponent(graph);\n\t\tcomponent.setAutoExtend(true);\n\t\tcomponent.setAntiAlias(true);\n\t\tcomponent.setTextAntiAlias(true);\n\t\tcomponent.setToolTips(true);\n\/\/\t\tcomponent.setImportEnabled(false);\n\t\tcomponent.setFoldingEnabled(true);\n\t\tcomponent.setConnectable(false);\n\t\tcomponent.setDragEnabled(false);\n\/\/\t\tcomponent.setKeepSelectionVisibleOnZoom(true);\n\/\/\t\tcomponent.getViewport().setBackground(Color.white);\n\t\t\/\/TODO setup\n\t\treturn component;\n\t}","code":"private mxGraphComponent createGraphComponent(mxGraph graph) {\n\t\tmxGraphComponent component = new mxGraphComponent(graph);\n\t\tcomponent.setAutoExtend(true);\n\t\tcomponent.setAntiAlias(true);\n\t\tcomponent.setTextAntiAlias(true);\n\t\tcomponent.setToolTips(true);\n\t\tcomponent.setFoldingEnabled(true);\n\t\tcomponent.setConnectable(false);\n\t\tcomponent.setDragEnabled(false);\n\t\n\t\treturn component;\n\t}","cleancode":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); return component; }","comment":"\/\/ component.setimportenabled(false);\n\/\/ component.setkeepselectionvisibleonzoom(true); \/\/ component.getviewport().setbackground(color.white); \/\/todo setup","repo":"ICARUS-tooling\/icarus2-modeling-framework","code_context_2":"component.setTextAntiAlias(true);\ncomponent.setToolTips(true);\n\/\/ component.setImportEnabled(false);\ncomponent.setFoldingEnabled(true);\ncomponent.setConnectable(false);\n\ncomponent.setConnectable(false);\ncomponent.setDragEnabled(false);\n\/\/ component.setKeepSelectionVisibleOnZoom(true);\n\/\/ component.getViewport().setBackground(Color.white);\n\/\/TODO setup\nreturn component;\n}","code_context_10":"private mxGraphComponent createGraphComponent(mxGraph graph) {\nmxGraphComponent component = new mxGraphComponent(graph);\ncomponent.setAutoExtend(true);\ncomponent.setAntiAlias(true);\ncomponent.setTextAntiAlias(true);\ncomponent.setToolTips(true);\n\/\/ component.setImportEnabled(false);\ncomponent.setFoldingEnabled(true);\ncomponent.setConnectable(false);\ncomponent.setDragEnabled(false);\n\/\/ component.setKeepSelectionVisibleOnZoom(true);\n\/\/ component.getViewport().setBackground(Color.white);\n\/\/TODO setup\nreturn component;\n}\n\nprivate mxGraphComponent createGraphComponent(mxGraph graph) {\nmxGraphComponent component = new mxGraphComponent(graph);\ncomponent.setAutoExtend(true);\ncomponent.setAntiAlias(true);\ncomponent.setTextAntiAlias(true);\ncomponent.setToolTips(true);\n\/\/ component.setImportEnabled(false);\ncomponent.setFoldingEnabled(true);\ncomponent.setConnectable(false);\ncomponent.setDragEnabled(false);\n\/\/ component.setKeepSelectionVisibleOnZoom(true);\n\/\/ component.getViewport().setBackground(Color.white);\n\/\/TODO setup\nreturn component;\n}","code_context_20":"private mxGraphComponent createGraphComponent(mxGraph graph) {\nmxGraphComponent component = new mxGraphComponent(graph);\ncomponent.setAutoExtend(true);\ncomponent.setAntiAlias(true);\ncomponent.setTextAntiAlias(true);\ncomponent.setToolTips(true);\n\/\/ component.setImportEnabled(false);\ncomponent.setFoldingEnabled(true);\ncomponent.setConnectable(false);\ncomponent.setDragEnabled(false);\n\/\/ component.setKeepSelectionVisibleOnZoom(true);\n\/\/ component.getViewport().setBackground(Color.white);\n\/\/TODO setup\nreturn component;\n}\n\nprivate mxGraphComponent createGraphComponent(mxGraph graph) {\nmxGraphComponent component = new mxGraphComponent(graph);\ncomponent.setAutoExtend(true);\ncomponent.setAntiAlias(true);\ncomponent.setTextAntiAlias(true);\ncomponent.setToolTips(true);\n\/\/ component.setImportEnabled(false);\ncomponent.setFoldingEnabled(true);\ncomponent.setConnectable(false);\ncomponent.setDragEnabled(false);\n\/\/ component.setKeepSelectionVisibleOnZoom(true);\n\/\/ component.getViewport().setBackground(Color.white);\n\/\/TODO setup\nreturn component;\n}","label":[0,1,0,0]}
{"id":13266,"original_code":"public int getAge() {\n        \/\/ TODO: put safe grabbing of age here\n        return 0;\n    }","code":"public int getAge() {\n       \n        return 0;\n    }","cleancode":"public int getage() { return 0; }","comment":"\/\/ todo: put safe grabbing of age here","repo":"210118-java-enterprise\/demos","code_context_2":"public int getAge() {\n\/\/ TODO: put safe grabbing of age here\nreturn 0;\n}","code_context_10":"public int getAge() {\n\/\/ TODO: put safe grabbing of age here\nreturn 0;\n}","code_context_20":"public int getAge() {\n\/\/ TODO: put safe grabbing of age here\nreturn 0;\n}","label":[0,1,0,0]}
{"id":13267,"original_code":"@InstanceName\n    public String getCaption() {\n        \/\/ todo rework when new instance name is ready\n        String pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\n        if (StringUtils.isBlank(pattern)) {\n            pattern =*\/ \"{1} [{0}]\";\n        \/*}*\/\n        MessageFormat fmt = new MessageFormat(pattern);\n        return StringUtils.trimToEmpty(fmt.format(new Object[]{\n                StringUtils.trimToEmpty(username),\n                StringUtils.trimToEmpty(name)\n        }));\n    }","code":"@InstanceName\n    public String getCaption() {\n       \n        String pattern  \"{1} [{0}]\";\n       \n        MessageFormat fmt = new MessageFormat(pattern);\n        return StringUtils.trimToEmpty(fmt.format(new Object[]{\n                StringUtils.trimToEmpty(username),\n                StringUtils.trimToEmpty(name)\n        }));\n    }","cleancode":"@instancename public string getcaption() { string pattern \"{1} [{0}]\"; messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","comment":"\/\/ todo rework when new instance name is ready\n\/* appcontext.getproperty(\"cuba.user.namepattern\"); if (stringutils.isblank(pattern)) { pattern =*\/\n\/*}*\/","repo":"Haulmont\/jmix-old","code_context_2":"@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\n\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\n\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{","code_context_10":"@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}\n\n@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}\n\n@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}","code_context_20":"@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}\n\n@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}\n\n@InstanceName\npublic String getCaption() {\n\/\/ todo rework when new instance name is ready\nString pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\nif (StringUtils.isBlank(pattern)) {\npattern =*\/ \"{1} [{0}]\";\n\/*}*\/\nMessageFormat fmt = new MessageFormat(pattern);\nreturn StringUtils.trimToEmpty(fmt.format(new Object[]{\nStringUtils.trimToEmpty(username),\nStringUtils.trimToEmpty(name)\n}));\n}","label":[1,0,0,0]}
{"id":13309,"original_code":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\n    SolrQuery query = new SolrQuery(queryString);\n    query.setTimeAllowed(queryTimeout);\n    query.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\n    query.setHighlight(false);\n    if (useDismax) {\n      query.set(\"defType\", \"dismax\");\n    }\n    \/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n    \/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n    \/\/without the \"date\" fields.\n    query.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\n    query.setRows(pageSize); \/\/ The number of results elements to return.\n    \/\/ request only fields that we need to display\n    query.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n        \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n        \"subject\", \"expression_of_concern\", \"retraction\");\n    query.addFacetField(\"subject_facet\");\n    query.addFacetField(\"author_facet\");\n    query.addFacetField(\"editor_facet\");\n    query.addFacetField(\"article_type_facet\");\n    query.addFacetField(\"affiliate_facet\");\n    query.set(\"facet.method\", \"fc\");\n    query.setFacetLimit(MAX_FACET_SIZE);\n    query.setFacetMinCount(MIN_FACET_COUNT);\n    \/\/ Add a filter to ensure that Solr never returns partial documents\n    query.addFilterQuery(createFilterFullDocuments());\n    return query;\n  }","code":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\n    SolrQuery query = new SolrQuery(queryString);\n    query.setTimeAllowed(queryTimeout);\n    query.setIncludeScore(true);\n    query.setHighlight(false);\n    if (useDismax) {\n      query.set(\"defType\", \"dismax\");\n    }\n   \n   \n   \n    query.setStart(startPage * pageSize);\n    query.setRows(pageSize);\n   \n    query.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n        \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n        \"subject\", \"expression_of_concern\", \"retraction\");\n    query.addFacetField(\"subject_facet\");\n    query.addFacetField(\"author_facet\");\n    query.addFacetField(\"editor_facet\");\n    query.addFacetField(\"article_type_facet\");\n    query.addFacetField(\"affiliate_facet\");\n    query.set(\"facet.method\", \"fc\");\n    query.setFacetLimit(MAX_FACET_SIZE);\n    query.setFacetMinCount(MIN_FACET_COUNT);\n   \n    query.addFilterQuery(createFilterFullDocuments());\n    return query;\n  }","cleancode":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } query.setstart(startpage * pagesize); query.setrows(pagesize); query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); query.addfilterquery(createfilterfulldocuments()); return query; }","comment":"\/\/ the relevance (of each results element) to the search terms.\n\/\/todo: put the \"options\" from the \"queryfield\" picklist into a config file. \/\/this list matches the \"options\" from the \"queryfield\" picklist on unformattedsearch.ftl, \/\/without the \"date\" fields.\n\/\/ which results element to return first in this batch.\n\/\/ the number of results elements to return.\n\/\/ request only fields that we need to display\n\/\/ add a filter to ensure that solr never returns partial documents","repo":"AndrewGuthua\/JournalSystem","code_context_2":"SolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\n\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\n\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;","code_context_10":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\n\nprivate SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\n\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\n\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\n\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\n\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}","code_context_20":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\n\nprivate SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}\n\nprivate SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}\n\nprivate SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}\n\nprivate SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\nSolrQuery query = new SolrQuery(queryString);\nquery.setTimeAllowed(queryTimeout);\nquery.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\nquery.setHighlight(false);\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}\n\nif (useDismax) {\nquery.set(\"defType\", \"dismax\");\n}\n\/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n\/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n\/\/without the \"date\" fields.\nquery.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\nquery.setRows(pageSize); \/\/ The number of results elements to return.\n\/\/ request only fields that we need to display\nquery.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n\"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n\"subject\", \"expression_of_concern\", \"retraction\");\nquery.addFacetField(\"subject_facet\");\nquery.addFacetField(\"author_facet\");\nquery.addFacetField(\"editor_facet\");\nquery.addFacetField(\"article_type_facet\");\nquery.addFacetField(\"affiliate_facet\");\nquery.set(\"facet.method\", \"fc\");\nquery.setFacetLimit(MAX_FACET_SIZE);\nquery.setFacetMinCount(MIN_FACET_COUNT);\n\/\/ Add a filter to ensure that Solr never returns partial documents\nquery.addFilterQuery(createFilterFullDocuments());\nreturn query;\n}","label":[1,0,0,0]}
{"id":13361,"original_code":"private String getTypeString(String _sTypeName, TypeClass _aTypeClass, boolean _bAsHeaderSourceCode){      \n        String sTypeString = \"\";\n        switch (_aTypeClass.getValue()){\n            case TypeClass.BOOLEAN_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbooleanTypeDescription();\n                break;\n            case TypeClass.BYTE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbyteTypeDescription();\n                break;\n            case TypeClass.CHAR_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getcharTypeDescription();                \n                break;\n            case TypeClass.DOUBLE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.FLOAT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getfloatTypeDescription();                \n                break;                \n            case TypeClass.HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.gethyperTypeDescription();                \n                break;                                \n            case TypeClass.LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getlongTypeDescription();                \n                break;                                \n            case TypeClass.SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getshortTypeDescription();                \n                break;                                \n            case TypeClass.STRING_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getstringTypeDescription(_bAsHeaderSourceCode);                \n                break;                                \n            case TypeClass.UNSIGNED_HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();                \n                break;                                \n            case TypeClass.UNSIGNED_LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();                \n                break;                \n            case TypeClass.UNSIGNED_SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.SEQUENCE_value:\n                \/\/TODO consider mulitdimensional Arrays\n                XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\n                if (xTypeDescription != null){\n                    sTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n                }\n                break;                \n            case TypeClass.ANY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\n                break;\n            case TypeClass.TYPE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);\n                break;\n            case TypeClass.ENUM_value:  \n            case TypeClass.STRUCT_value:\n            case TypeClass.INTERFACE_ATTRIBUTE_value:\n            case TypeClass.INTERFACE_METHOD_value:\n            case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(_sTypeName, _bAsHeaderSourceCode);\n                break;\n            default:                                                    \n        }\n        return sTypeString;\n    }","code":"private String getTypeString(String _sTypeName, TypeClass _aTypeClass, boolean _bAsHeaderSourceCode){      \n        String sTypeString = \"\";\n        switch (_aTypeClass.getValue()){\n            case TypeClass.BOOLEAN_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbooleanTypeDescription();\n                break;\n            case TypeClass.BYTE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbyteTypeDescription();\n                break;\n            case TypeClass.CHAR_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getcharTypeDescription();                \n                break;\n            case TypeClass.DOUBLE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.FLOAT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getfloatTypeDescription();                \n                break;                \n            case TypeClass.HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.gethyperTypeDescription();                \n                break;                                \n            case TypeClass.LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getlongTypeDescription();                \n                break;                                \n            case TypeClass.SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getshortTypeDescription();                \n                break;                                \n            case TypeClass.STRING_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getstringTypeDescription(_bAsHeaderSourceCode);                \n                break;                                \n            case TypeClass.UNSIGNED_HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();                \n                break;                                \n            case TypeClass.UNSIGNED_LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();                \n                break;                \n            case TypeClass.UNSIGNED_SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.SEQUENCE_value:\n               \n                XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\n                if (xTypeDescription != null){\n                    sTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n                }\n                break;                \n            case TypeClass.ANY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\n                break;\n            case TypeClass.TYPE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);\n                break;\n            case TypeClass.ENUM_value:  \n            case TypeClass.STRUCT_value:\n            case TypeClass.INTERFACE_ATTRIBUTE_value:\n            case TypeClass.INTERFACE_METHOD_value:\n            case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(_sTypeName, _bAsHeaderSourceCode);\n                break;\n            default:                                                    \n        }\n        return sTypeString;\n    }","cleancode":"private string gettypestring(string _stypename, typeclass _atypeclass, boolean _basheadersourcecode){ string stypestring = \"\"; switch (_atypeclass.getvalue()){ case typeclass.boolean_value: stypestring = m_xlanguagesourcecodegenerator.getbooleantypedescription(); break; case typeclass.byte_value: stypestring = m_xlanguagesourcecodegenerator.getbytetypedescription(); break; case typeclass.char_value: stypestring = m_xlanguagesourcecodegenerator.getchartypedescription(); break; case typeclass.double_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.float_value: stypestring = m_xlanguagesourcecodegenerator.getfloattypedescription(); break; case typeclass.hyper_value: stypestring = m_xlanguagesourcecodegenerator.gethypertypedescription(); break; case typeclass.long_value: stypestring = m_xlanguagesourcecodegenerator.getlongtypedescription(); break; case typeclass.short_value: stypestring = m_xlanguagesourcecodegenerator.getshorttypedescription(); break; case typeclass.string_value: stypestring = m_xlanguagesourcecodegenerator.getstringtypedescription(_basheadersourcecode); break; case typeclass.unsigned_hyper_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedhypertypedescription(); break; case typeclass.unsigned_long_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedlongtypedescription(); break; case typeclass.unsigned_short_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){ stypestring = gettypestring(xtypedescription.getname(), xtypedescription.gettypeclass(), _basheadersourcecode); } break; case typeclass.any_value: stypestring = m_xlanguagesourcecodegenerator.getanytypedescription(_basheadersourcecode); break; case typeclass.type_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(\"com.sun.star.uno.type\", _basheadersourcecode); break; case typeclass.enum_value: case typeclass.struct_value: case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(_stypename, _basheadersourcecode); break; default: } return stypestring; }","comment":"\/\/todo consider mulitdimensional arrays","repo":"Grosskopf\/openoffice","code_context_2":"break;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\nif (xTypeDescription != null){","code_context_10":"case TypeClass.UNSIGNED_HYPER_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();\nbreak;\ncase TypeClass.UNSIGNED_LONG_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();\nbreak;\ncase TypeClass.UNSIGNED_SHORT_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();\nbreak;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\nif (xTypeDescription != null){\nsTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n}\nbreak;\ncase TypeClass.ANY_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\nbreak;\ncase TypeClass.TYPE_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);","code_context_20":"break;\ncase TypeClass.LONG_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getlongTypeDescription();\nbreak;\ncase TypeClass.SHORT_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getshortTypeDescription();\nbreak;\ncase TypeClass.STRING_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getstringTypeDescription(_bAsHeaderSourceCode);\nbreak;\ncase TypeClass.UNSIGNED_HYPER_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();\nbreak;\ncase TypeClass.UNSIGNED_LONG_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();\nbreak;\ncase TypeClass.UNSIGNED_SHORT_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();\nbreak;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\nif (xTypeDescription != null){\nsTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n}\nbreak;\ncase TypeClass.ANY_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\nbreak;\ncase TypeClass.TYPE_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);\nbreak;\ncase TypeClass.ENUM_value:\ncase TypeClass.STRUCT_value:\ncase TypeClass.INTERFACE_ATTRIBUTE_value:\ncase TypeClass.INTERFACE_METHOD_value:\ncase TypeClass.INTERFACE_value:\ncase TypeClass.PROPERTY_value:\nsTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(_sTypeName, _bAsHeaderSourceCode);\nbreak;\ndefault:","label":[1,0,0,0]}
{"id":13362,"original_code":"private String getCentralVariableStemName(TypeClass _aTypeClass){\n            String sCentralVariableStemName = \"\";\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.SEQUENCE_value:\n                    \/\/TODO consider mulitdimensional Arrays\n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sCentralVariableStemName = SVARIABLENAME;\n                    break;\n                case TypeClass.STRUCT_value:\n                    sCentralVariableStemName = Introspector.getShortClassName(getTypeName());\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sCentralVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:            \n                    sCentralVariableStemName = SVARIABLENAME;\n            }                        \n            return sCentralVariableStemName;\n        }","code":"private String getCentralVariableStemName(TypeClass _aTypeClass){\n            String sCentralVariableStemName = \"\";\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.SEQUENCE_value:\n                   \n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sCentralVariableStemName = SVARIABLENAME;\n                    break;\n                case TypeClass.STRUCT_value:\n                    sCentralVariableStemName = Introspector.getShortClassName(getTypeName());\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sCentralVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:            \n                    sCentralVariableStemName = SVARIABLENAME;\n            }                        \n            return sCentralVariableStemName;\n        }","cleancode":"private string getcentralvariablestemname(typeclass _atypeclass){ string scentralvariablestemname = \"\"; int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ scentralvariablestemname = getcentralvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: scentralvariablestemname = svariablename; break; case typeclass.struct_value: scentralvariablestemname = introspector.getshortclassname(gettypename()); break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); scentralvariablestemname = getvariablenameforunoobject(sshortclassname); default: scentralvariablestemname = svariablename; } return scentralvariablestemname; }","comment":"\/\/todo consider mulitdimensional arrays","repo":"Grosskopf\/openoffice","code_context_2":"switch(nTypeClass){\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){","code_context_10":"private String getCentralVariableStemName(TypeClass _aTypeClass){\nString sCentralVariableStemName = \"\";\nint nTypeClass = _aTypeClass.getValue();\nswitch(nTypeClass){\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){\nsCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n}\nbreak;\ncase TypeClass.TYPE_value:\nsCentralVariableStemName = SVARIABLENAME;\nbreak;\ncase TypeClass.STRUCT_value:\nsCentralVariableStemName = Introspector.getShortClassName(getTypeName());","code_context_20":"private String getCentralVariableStemName(TypeClass _aTypeClass){\nString sCentralVariableStemName = \"\";\nint nTypeClass = _aTypeClass.getValue();\nswitch(nTypeClass){\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){\nsCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n}\nbreak;\ncase TypeClass.TYPE_value:\nsCentralVariableStemName = SVARIABLENAME;\nbreak;\ncase TypeClass.STRUCT_value:\nsCentralVariableStemName = Introspector.getShortClassName(getTypeName());\nbreak;\ncase TypeClass.INTERFACE_ATTRIBUTE_value:\ncase TypeClass.INTERFACE_METHOD_value:\ncase TypeClass.INTERFACE_value:\ncase TypeClass.PROPERTY_value:\nString sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\nsCentralVariableStemName = getVariableNameforUnoObject(sShortClassName);\ndefault:\nsCentralVariableStemName = SVARIABLENAME;\n}","label":[1,0,0,0]}
{"id":13363,"original_code":"public String getVariableStemName(TypeClass _aTypeClass){\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.BOOLEAN_value:\n                    sVariableStemName = \"b\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.DOUBLE_value:\n                case TypeClass.FLOAT_value:\n                    sVariableStemName = \"f\" + m_sCentralVariableStemName;\n                    break;                \n                case TypeClass.BYTE_value:\n                case TypeClass.HYPER_value:\n                case TypeClass.LONG_value:\n                case TypeClass.UNSIGNED_HYPER_value:\n                case TypeClass.UNSIGNED_LONG_value:\n                case TypeClass.UNSIGNED_SHORT_value:\n                case TypeClass.SHORT_value:\n                    sVariableStemName = \"n\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.CHAR_value:\n                case TypeClass.STRING_value:\n                    sVariableStemName = \"s\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.SEQUENCE_value:\n                    \/\/TODO consider mulitdimensional Arrays\n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.ANY_value:\n                    sVariableStemName = \"o\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.STRUCT_value:\n                case TypeClass.ENUM_value:  \n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n                case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:                                                    \n            }            \n            return sVariableStemName;\n        }","code":"public String getVariableStemName(TypeClass _aTypeClass){\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.BOOLEAN_value:\n                    sVariableStemName = \"b\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.DOUBLE_value:\n                case TypeClass.FLOAT_value:\n                    sVariableStemName = \"f\" + m_sCentralVariableStemName;\n                    break;                \n                case TypeClass.BYTE_value:\n                case TypeClass.HYPER_value:\n                case TypeClass.LONG_value:\n                case TypeClass.UNSIGNED_HYPER_value:\n                case TypeClass.UNSIGNED_LONG_value:\n                case TypeClass.UNSIGNED_SHORT_value:\n                case TypeClass.SHORT_value:\n                    sVariableStemName = \"n\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.CHAR_value:\n                case TypeClass.STRING_value:\n                    sVariableStemName = \"s\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.SEQUENCE_value:\n                   \n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.ANY_value:\n                    sVariableStemName = \"o\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.STRUCT_value:\n                case TypeClass.ENUM_value:  \n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n                case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:                                                    \n            }            \n            return sVariableStemName;\n        }","cleancode":"public string getvariablestemname(typeclass _atypeclass){ int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.boolean_value: svariablestemname = \"b\" + m_scentralvariablestemname; break; case typeclass.double_value: case typeclass.float_value: svariablestemname = \"f\" + m_scentralvariablestemname; break; case typeclass.byte_value: case typeclass.hyper_value: case typeclass.long_value: case typeclass.unsigned_hyper_value: case typeclass.unsigned_long_value: case typeclass.unsigned_short_value: case typeclass.short_value: svariablestemname = \"n\" + m_scentralvariablestemname; break; case typeclass.char_value: case typeclass.string_value: svariablestemname = \"s\" + m_scentralvariablestemname; break; case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ svariablestemname = getvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.any_value: svariablestemname = \"o\" + m_scentralvariablestemname; break; case typeclass.struct_value: case typeclass.enum_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); svariablestemname = getvariablenameforunoobject(sshortclassname); default: } return svariablestemname; }","comment":"\/\/todo consider mulitdimensional arrays","repo":"Grosskopf\/openoffice","code_context_2":"break;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){","code_context_10":"case TypeClass.UNSIGNED_LONG_value:\ncase TypeClass.UNSIGNED_SHORT_value:\ncase TypeClass.SHORT_value:\nsVariableStemName = \"n\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.CHAR_value:\ncase TypeClass.STRING_value:\nsVariableStemName = \"s\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){\nsVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n}\nbreak;\ncase TypeClass.TYPE_value:\nsVariableStemName = \"a\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.ANY_value:\nsVariableStemName = \"o\" + m_sCentralVariableStemName;","code_context_20":"sVariableStemName = \"b\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.DOUBLE_value:\ncase TypeClass.FLOAT_value:\nsVariableStemName = \"f\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.BYTE_value:\ncase TypeClass.HYPER_value:\ncase TypeClass.LONG_value:\ncase TypeClass.UNSIGNED_HYPER_value:\ncase TypeClass.UNSIGNED_LONG_value:\ncase TypeClass.UNSIGNED_SHORT_value:\ncase TypeClass.SHORT_value:\nsVariableStemName = \"n\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.CHAR_value:\ncase TypeClass.STRING_value:\nsVariableStemName = \"s\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.SEQUENCE_value:\n\/\/TODO consider mulitdimensional Arrays\nXTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\nif (xTypeDescription != null){\nsVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n}\nbreak;\ncase TypeClass.TYPE_value:\nsVariableStemName = \"a\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.ANY_value:\nsVariableStemName = \"o\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.STRUCT_value:\ncase TypeClass.ENUM_value:\nsVariableStemName = \"a\" + m_sCentralVariableStemName;\nbreak;\ncase TypeClass.INTERFACE_ATTRIBUTE_value:\ncase TypeClass.INTERFACE_METHOD_value:\ncase TypeClass.INTERFACE_value:\ncase TypeClass.PROPERTY_value:\nString sShortClassName = m_oIntrospector.getShortClassName(getTypeName());","label":[1,0,0,0]}
{"id":29971,"original_code":"public int getRuleStatusVec(int[] fillInArray) {\n        if (fillInArray != null && fillInArray.length>=1) {  \n            fillInArray[0] = 0;\n        }\n        return 1;\n    }","code":"public int getRuleStatusVec(int[] fillInArray) {\n        if (fillInArray != null && fillInArray.length>=1) {  \n            fillInArray[0] = 0;\n        }\n        return 1;\n    }","cleancode":"public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","comment":"\/** * get the status (tag) values from the break rule(s) that determined the most * recently returned break position. the values appear in the rule source * within brackets, {123}, for example. the default status value for rules * that do not explicitly provide one is zero. * <p> * todo: not supported for dictionary based break iterator. * * @param fillinarray an array to be filled in with the status values. * @return the number of rule status values from rules that determined * the most recent boundary returned by the break iterator. * in the event that the array is too small, the return value * is the total number of status values that were available, * not the reduced number that were actually returned. * @draft icu 3.0 * @provisional this api might change or be removed in a future release. *\/","repo":"HughP\/quickdic-dictionary","code_context_2":"public int getRuleStatusVec(int[] fillInArray) {\nif (fillInArray != null && fillInArray.length>=1) {\nfillInArray[0] = 0;\n}\nreturn 1;\n}","code_context_10":"public int getRuleStatusVec(int[] fillInArray) {\nif (fillInArray != null && fillInArray.length>=1) {\nfillInArray[0] = 0;\n}\nreturn 1;\n}","code_context_20":"public int getRuleStatusVec(int[] fillInArray) {\nif (fillInArray != null && fillInArray.length>=1) {\nfillInArray[0] = 0;\n}\nreturn 1;\n}","label":[1,0,0,0]}
{"id":30000,"original_code":"public void go() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"verilog\\\\out.log\"));\n\t\tString line;\n\t\tPattern p = Pattern.compile(\".+JAG RD REF=. OB=1 BLT=. GPU=. \\\\$(......).*\");\n\t\tlong lineNo = 0;\n\t\tint Xmin[] = new int[3];\n\t\tint Xmax[] = new int[3];\n\t\tint Ymin[] = new int[3];\n\t\tint Ymax[] = new int[3];\n\t\tlong slino[] = new long[3];\n\t\tlong elino[] = new long[3];\n\t\tfor(int k = 0; k < 3; k++) {\n\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t}\n\t\twhile( (line = br.readLine()) != null) {\n\t\t\tlineNo++;\n\t\t\tif (lineNo >= 10L * 1000L * 1000L)\n\t\t\t\tbreak;\n\t\t\tMatcher m = p.matcher(line);\n\t\t\tif (m.matches()) {\n\t\t\t\t\/\/ System.out.println(line);\n\t\t\t\tint addr = Integer.parseInt(m.group(1), 16);\n\t\t\t\tint index = -1;\n\t\t\t\tboolean wtf = false;\n\t\t\t\tif (addr == 0xeb40) {\n\t\t\t\t\t\/\/ OLP\n\t\t\t\t\t\/\/ System.out.print(\".\");\n\t\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (slino[k] != 0) {\n\t\t\t\t\t\t\t\/\/wtf = (Ymin[k] != Ymax[k]);\n\t\t\t\t\t\t\tSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k], \n\t\t\t\t\t\t\t\t\t(wtf ? \"WTF\" : \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\t\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t\t\t\t\tslino[k] = 0;\n\t\t\t\t\t\telino[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t\/*if (wtf)\n\t\t\t\t\tbreak;*\/\n\t\t\t\tif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t\taddr -= SCREEN1;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\taddr -= SCREEN2;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\n\t\t\t\t\tindex = 2;\n\t\t\t\t\taddr -= SCREEN3;\n\t\t\t\t}\n\t\t\t\tif (index < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\n\t\t\t\tint y = (addr >> 1) \/ WIDTH;\n\t\t\t\tint x = (addr >> 1) % WIDTH;\n\t\t\t\t\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\n\t\t\t\tif (slino[index] == 0)\n\t\t\t\t\tslino[index] = lineNo;\n\t\t\t\telino[index] = lineNo;\n\t\t\t\tif (Xmin[index] > x)\n\t\t\t\t\tXmin[index] = x;\n\t\t\t\tif (Xmax[index] < x)\n\t\t\t\t\tXmax[index] = x;\n\t\t\t\tif (Ymin[index] > y)\n\t\t\t\t\tYmin[index] = y;\n\t\t\t\tif (Ymax[index] < y)\n\t\t\t\t\tYmax[index] = y;\n\t\t\t}\n\t\t} \n\t\tbr.close();\n\t}","code":"public void go() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"verilog\\\\out.log\"));\n\t\tString line;\n\t\tPattern p = Pattern.compile(\".+JAG RD REF=. OB=1 BLT=. GPU=. \\\\$(......).*\");\n\t\tlong lineNo = 0;\n\t\tint Xmin[] = new int[3];\n\t\tint Xmax[] = new int[3];\n\t\tint Ymin[] = new int[3];\n\t\tint Ymax[] = new int[3];\n\t\tlong slino[] = new long[3];\n\t\tlong elino[] = new long[3];\n\t\tfor(int k = 0; k < 3; k++) {\n\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t}\n\t\twhile( (line = br.readLine()) != null) {\n\t\t\tlineNo++;\n\t\t\tif (lineNo >= 10L * 1000L * 1000L)\n\t\t\t\tbreak;\n\t\t\tMatcher m = p.matcher(line);\n\t\t\tif (m.matches()) {\n\t\t\t\n\t\t\t\tint addr = Integer.parseInt(m.group(1), 16);\n\t\t\t\tint index = -1;\n\t\t\t\tboolean wtf = false;\n\t\t\t\tif (addr == 0xeb40) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (slino[k] != 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k], \n\t\t\t\t\t\t\t\t\t(wtf ? \"WTF\" : \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\t\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t\t\t\t\tslino[k] = 0;\n\t\t\t\t\t\telino[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t\taddr -= SCREEN1;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\taddr -= SCREEN2;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\n\t\t\t\t\tindex = 2;\n\t\t\t\t\taddr -= SCREEN3;\n\t\t\t\t}\n\t\t\t\tif (index < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\n\t\t\t\tint y = (addr >> 1) \/ WIDTH;\n\t\t\t\tint x = (addr >> 1) % WIDTH;\n\t\t\t\n\t\t\t\tif (slino[index] == 0)\n\t\t\t\t\tslino[index] = lineNo;\n\t\t\t\telino[index] = lineNo;\n\t\t\t\tif (Xmin[index] > x)\n\t\t\t\t\tXmin[index] = x;\n\t\t\t\tif (Xmax[index] < x)\n\t\t\t\t\tXmax[index] = x;\n\t\t\t\tif (Ymin[index] > y)\n\t\t\t\t\tYmin[index] = y;\n\t\t\t\tif (Ymax[index] < y)\n\t\t\t\t\tYmax[index] = y;\n\t\t\t}\n\t\t} \n\t\tbr.close();\n\t}","cleancode":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { for(int k = 0; k < 3; k++) { if (slino[k] != 0) { system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","comment":"\/\/ system.out.println(line);\n\/\/ olp \/\/ system.out.print(\".\");\n\/\/wtf = (ymin[k] != ymax[k]);\n\/*if (wtf) break;*\/\n\/\/ system.out.format(\"%06x %04x\\n\", addr, val);\n\/\/ system.out.format(\"%d (%d,%d)\\n\", index, x, y);","repo":"ElectronAsh\/jag_sim","code_context_2":"Matcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\n\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\n\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;","code_context_10":"for(int k = 0; k < 3; k++) {\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n}\nwhile( (line = br.readLine()) != null) {\nlineNo++;\nif (lineNo >= 10L * 1000L * 1000L)\nbreak;\nMatcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n\nlineNo++;\nif (lineNo >= 10L * 1000L * 1000L)\nbreak;\nMatcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\n\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\naddr -= SCREEN3;\n}\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;\nelino[index] = lineNo;\nif (Xmin[index] > x)\nXmin[index] = x;\nif (Xmax[index] < x)\nXmax[index] = x;\n\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\naddr -= SCREEN3;\n}\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;\nelino[index] = lineNo;\nif (Xmin[index] > x)\nXmin[index] = x;\nif (Xmax[index] < x)\nXmax[index] = x;\nif (Ymin[index] > y)\nYmin[index] = y;\nif (Ymax[index] < y)","code_context_20":"BufferedReader br = new BufferedReader(new FileReader(\"verilog\\\\out.log\"));\nString line;\nPattern p = Pattern.compile(\".+JAG RD REF=. OB=1 BLT=. GPU=. \\\\$(......).*\");\nlong lineNo = 0;\nint Xmin[] = new int[3];\nint Xmax[] = new int[3];\nint Ymin[] = new int[3];\nint Ymax[] = new int[3];\nlong slino[] = new long[3];\nlong elino[] = new long[3];\nfor(int k = 0; k < 3; k++) {\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n}\nwhile( (line = br.readLine()) != null) {\nlineNo++;\nif (lineNo >= 10L * 1000L * 1000L)\nbreak;\nMatcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\n\nint Xmax[] = new int[3];\nint Ymin[] = new int[3];\nint Ymax[] = new int[3];\nlong slino[] = new long[3];\nlong elino[] = new long[3];\nfor(int k = 0; k < 3; k++) {\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n}\nwhile( (line = br.readLine()) != null) {\nlineNo++;\nif (lineNo >= 10L * 1000L * 1000L)\nbreak;\nMatcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\n\nlong elino[] = new long[3];\nfor(int k = 0; k < 3; k++) {\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n}\nwhile( (line = br.readLine()) != null) {\nlineNo++;\nif (lineNo >= 10L * 1000L * 1000L)\nbreak;\nMatcher m = p.matcher(line);\nif (m.matches()) {\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\n\n\/\/ System.out.println(line);\nint addr = Integer.parseInt(m.group(1), 16);\nint index = -1;\nboolean wtf = false;\nif (addr == 0xeb40) {\n\/\/ OLP\n\/\/ System.out.print(\".\");\nfor(int k = 0; k < 3; k++) {\nif (slino[k] != 0) {\n\/\/wtf = (Ymin[k] != Ymax[k]);\nSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k],\n(wtf ? \"WTF\" : \"\"));\n}\nXmin[k] = Ymin[k] = Integer.MAX_VALUE;\nXmax[k] = Ymax[k] = Integer.MIN_VALUE;\nslino[k] = 0;\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\naddr -= SCREEN3;\n}\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;\n\nelino[k] = 0;\n}\nSystem.out.println();\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\naddr -= SCREEN3;\n}\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;\nelino[index] = lineNo;\nif (Xmin[index] > x)\nXmin[index] = x;\nif (Xmax[index] < x)\nXmax[index] = x;\nif (Ymin[index] > y)\nYmin[index] = y;\nif (Ymax[index] < y)\nYmax[index] = y;\n}\n}\nbr.close();\n}\n\n}\n\/*if (wtf)\nbreak;*\/\nif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\nindex = 0;\naddr -= SCREEN1;\n}\nelse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\nindex = 1;\naddr -= SCREEN2;\n}\nelse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\nindex = 2;\naddr -= SCREEN3;\n}\nif (index < 0)\ncontinue;\n\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\nint y = (addr >> 1) \/ WIDTH;\nint x = (addr >> 1) % WIDTH;\n\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\nif (slino[index] == 0)\nslino[index] = lineNo;\nelino[index] = lineNo;\nif (Xmin[index] > x)\nXmin[index] = x;\nif (Xmax[index] < x)\nXmax[index] = x;\nif (Ymin[index] > y)\nYmin[index] = y;\nif (Ymax[index] < y)\nYmax[index] = y;\n}\n}\nbr.close();\n}","label":[0,0,0,0]}
{"id":21824,"original_code":"private void downloadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return;\n        }\n        int mediaId = fileInfo.getId();\n        getDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n                \/\/ @todo: replace with StringBuilder\n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        \/\/ result contains the local file URI if successful\n                        mediaFileDao.setLocalUri(mediaId, result.unwrap());\n                    });\n                } else {\n                    logger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","code":"private void downloadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return;\n        }\n        int mediaId = fileInfo.getId();\n        getDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n               \n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                       \n                        mediaFileDao.setLocalUri(mediaId, result.unwrap());\n                    });\n                } else {\n                    logger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","cleancode":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","comment":"\/\/ @todo: replace with stringbuilder\n\/\/ result contains the local file uri if successful","repo":"COMP30022-Russia\/Russia_Client","code_context_2":"getDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\n\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\n\/\/ result contains the local file URI if successful\nmediaFileDao.setLocalUri(mediaId, result.unwrap());\n});","code_context_10":"private void downloadMedia(MediaFileInfo fileInfo) {\nif (fileInfo == null) {\nreturn;\n}\nint mediaId = fileInfo.getId();\ngetDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\n\/\/ result contains the local file URI if successful\nmediaFileDao.setLocalUri(mediaId, result.unwrap());\n});\n} else {\nlogger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");\n\nif (fileInfo == null) {\nreturn;\n}\nint mediaId = fileInfo.getId();\ngetDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\n\/\/ result contains the local file URI if successful\nmediaFileDao.setLocalUri(mediaId, result.unwrap());\n});\n} else {\nlogger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");\n} else {\nlogger.warn(\"due to unknown error.\");\n}\n}","code_context_20":"private void downloadMedia(MediaFileInfo fileInfo) {\nif (fileInfo == null) {\nreturn;\n}\nint mediaId = fileInfo.getId();\ngetDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\n\/\/ result contains the local file URI if successful\nmediaFileDao.setLocalUri(mediaId, result.unwrap());\n});\n} else {\nlogger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");\n} else {\nlogger.warn(\"due to unknown error.\");\n}\n}\n}).exceptionally((e) -> {\nlogger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\ne.printStackTrace();\nreturn null;\n});\n}\n\nprivate void downloadMedia(MediaFileInfo fileInfo) {\nif (fileInfo == null) {\nreturn;\n}\nint mediaId = fileInfo.getId();\ngetDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\n\/\/ result contains the local file URI if successful\nmediaFileDao.setLocalUri(mediaId, result.unwrap());\n});\n} else {\nlogger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");\n} else {\nlogger.warn(\"due to unknown error.\");\n}\n}\n}).exceptionally((e) -> {\nlogger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\ne.printStackTrace();\nreturn null;\n});\n}","label":[1,0,0,0]}
{"id":21825,"original_code":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return CompletableFuture.completedFuture(null);\n        }\n        int mediaId = fileInfo.getId();\n        return getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n                \/\/ @todo: replace with StringBuilder\n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        mediaFileDao.insertOrUpdate(fileInfo);\n                        mediaFileDao.setRemoteAvailable(mediaId);\n                    });\n                } else {\n                    logger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"uploading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","code":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return CompletableFuture.completedFuture(null);\n        }\n        int mediaId = fileInfo.getId();\n        return getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n               \n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        mediaFileDao.insertOrUpdate(fileInfo);\n                        mediaFileDao.setRemoteAvailable(mediaId);\n                    });\n                } else {\n                    logger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"uploading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","cleancode":"private completablefuture<void> uploadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return completablefuture.completedfuture(null); } int mediaid = fileinfo.getid(); return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.insertorupdate(fileinfo); mediafiledao.setremoteavailable(mediaid); }); } else { logger.warn(\"uploading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"uploading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","comment":"\/\/ @todo: replace with stringbuilder","repo":"COMP30022-Russia\/Russia_Client","code_context_2":"return getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");","code_context_10":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\nif (fileInfo == null) {\nreturn CompletableFuture.completedFuture(null);\n}\nint mediaId = fileInfo.getId();\nreturn getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\nmediaFileDao.insertOrUpdate(fileInfo);\nmediaFileDao.setRemoteAvailable(mediaId);\n});\n} else {\nlogger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");","code_context_20":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\nif (fileInfo == null) {\nreturn CompletableFuture.completedFuture(null);\n}\nint mediaId = fileInfo.getId();\nreturn getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n.thenAcceptAsync((result) -> {\n\/\/ @todo: replace with StringBuilder\nif (result != null && result.isSuccessful()) {\nlogger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\nAsyncTask.execute(() -> {\nmediaFileDao.insertOrUpdate(fileInfo);\nmediaFileDao.setRemoteAvailable(mediaId);\n});\n} else {\nlogger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\nif (result.getErrorType() == ActionResult.NETWORK_ERROR) {\nlogger.warn(\"due to network error.\");\n} else {\nlogger.warn(\"due to unknown error.\");\n}\n}\n}).exceptionally((e) -> {\nlogger.error(\"uploading of media id=\" + mediaId + \" failed spectacularly:\");\ne.printStackTrace();\nreturn null;\n});\n}","label":[1,0,0,0]}
{"id":13695,"original_code":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n    \/\/ Create config for trajectory\n    \/*TrajectoryConfig config =\n      new TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n        \/\/ Add kinematics to ensure max speed is actually obeyed\n        .setKinematics(mecDriveTrain.getMecKinetimatics());\n    \/\/ An example trajectory to follow.  All units in meters.\n    Trajectory exampleTrajectory =\n      TrajectoryGenerator.generateTrajectory(\n        \/\/ Start at the origin facing the +X direction\n        new Pose2d(0, 0, new Rotation2d(0)),\n        \/\/ Pass through these two interior waypoints, making an 's' curve path\n        List.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n        \/\/ End 3 meters straight ahead of where we started, facing forward\n        new Pose2d(3, 0, new Rotation2d(0)),\n        config);*\/\n    ProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0., \n      new Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\n    thetaController.enableContinuousInput(-Math.PI, Math.PI);\n    thetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n    \/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\n    PPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\n      ppTrajectory,\n      RobotState::getPoseEstimate,\n      \/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n      \/\/and then use that in the mecDriveTrain.setSpeeds() method\n      \/\/mecDriveTrain.getMecFeedforward(),\n      RobotState.getMecKinematics(),\n      \/\/ Position contollers\n      new PIDController(Constants.kpMecPosXController, 0, 0),\n      new PIDController(Constants.kpMecPosYController, 0, 0),\n      thetaController,\n      \/\/ Needed for normalizing wheel speeds\n      \/\/Constants.maxMecSpeed,\n      \/\/ Velocity PID's\n      \/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\n      new PIDController(Constants.kpMecL2Velocity, 0, 0),\n      new PIDController(Constants.kpMecR1Velocity, 0, 0),\n      new PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n      \/\/mecDriveTrain::getCurrentWheelSpeeds,\n      mecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\n      mecDriveTrain\n    );\n    \/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n    \/*return new InstantCommand(() -> \n      mecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n      .andThen(mecanumControllerCommand);\n      \/\/.andThen(mecDriveTrain::stopDrive);*\/\n    return mecanumControllerCommand;\n  }","code":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n   \n   \n    ProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0., \n      new Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\n    thetaController.enableContinuousInput(-Math.PI, Math.PI);\n    thetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n   \n    PPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\n      ppTrajectory,\n      RobotState::getPoseEstimate,\n     \n     \n     \n      RobotState.getMecKinematics(),\n     \n      new PIDController(Constants.kpMecPosXController, 0, 0),\n      new PIDController(Constants.kpMecPosYController, 0, 0),\n      thetaController,\n     \n     \n     \n     \n     \n      mecDriveTrain::setSpeeds,\n      mecDriveTrain\n    );\n   \n   \n    return mecanumControllerCommand;\n  }","cleancode":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, robotstate.getmeckinematics(), new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, mecdrivetrain::setspeeds, mecdrivetrain ); return mecanumcontrollercommand; }","comment":"\/\/ create config for trajectory \/*trajectoryconfig config = new trajectoryconfig(constants.maxmecspeed,constants.maxmecacceleration) \/\/ add kinematics to ensure max speed is actually obeyed .setkinematics(mecdrivetrain.getmeckinetimatics()); \/\/ an example trajectory to follow. all units in meters. trajectory exampletrajectory = trajectorygenerator.generatetrajectory( \/\/ start at the origin facing the +x direction new pose2d(0, 0, new rotation2d(0)), \/\/ pass through these two interior waypoints, making an 's' curve path list.of(new translation2d(1, 1), new translation2d(2, -1)), \/\/ end 3 meters straight ahead of where we started, facing forward new pose2d(3, 0, new rotation2d(0)), config);*\/\n\/\/mecdrivetrain.setpose(pptrajectory.getinitialpose());\n\/\/todo go to wpilib source code for meccontrolcommand and see how they use this feedforward \/\/and then use that in the mecdrivetrain.setspeeds() method \/\/mecdrivetrain.getmecfeedforward(),\n\/\/ position contollers\n\/\/ needed for normalizing wheel speeds \/\/constants.maxmecspeed, \/\/ velocity pid's \/*new pidcontroller(constants.kpmecl1velocity, 0, 0), new pidcontroller(constants.kpmecl2velocity, 0, 0), new pidcontroller(constants.kpmecr1velocity, 0, 0), new pidcontroller(constants.kpmecr2velocity, 0, 0),*\/\n\/\/mecdrivetrain::getcurrentwheelspeeds,\n\/\/ consumer for the output motor voltages\n\/\/pathplannerstate initialstate = pptrajectory.getinitialstate(); \/*return new instantcommand(() -> mecdrivetrain.setpose(new pose2d(initialstate.posemeters.gettranslation(), initialstate.holonomicrotation))) .andthen(mecanumcontrollercommand); \/\/.andthen(mecdrivetrain::stopdrive);*\/","repo":"FRC6302\/2022Bot1","code_context_2":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n\/\/ Create config for trajectory\n\/*TrajectoryConfig config =\nnew TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n\/\/ Add kinematics to ensure max speed is actually obeyed\n.setKinematics(mecDriveTrain.getMecKinetimatics());\n\/\/ An example trajectory to follow. All units in meters.\nTrajectory exampleTrajectory =\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\n\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\n\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\n\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\n\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\n\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}","code_context_10":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n\/\/ Create config for trajectory\n\/*TrajectoryConfig config =\nnew TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n\/\/ Add kinematics to ensure max speed is actually obeyed\n.setKinematics(mecDriveTrain.getMecKinetimatics());\n\/\/ An example trajectory to follow. All units in meters.\nTrajectory exampleTrajectory =\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\n\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\n\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}\n\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}\n\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}","code_context_20":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n\/\/ Create config for trajectory\n\/*TrajectoryConfig config =\nnew TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n\/\/ Add kinematics to ensure max speed is actually obeyed\n.setKinematics(mecDriveTrain.getMecKinetimatics());\n\/\/ An example trajectory to follow. All units in meters.\nTrajectory exampleTrajectory =\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\n\npublic static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n\/\/ Create config for trajectory\n\/*TrajectoryConfig config =\nnew TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n\/\/ Add kinematics to ensure max speed is actually obeyed\n.setKinematics(mecDriveTrain.getMecKinetimatics());\n\/\/ An example trajectory to follow. All units in meters.\nTrajectory exampleTrajectory =\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\n\n\/\/ Add kinematics to ensure max speed is actually obeyed\n.setKinematics(mecDriveTrain.getMecKinetimatics());\n\/\/ An example trajectory to follow. All units in meters.\nTrajectory exampleTrajectory =\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\nTrajectoryGenerator.generateTrajectory(\n\/\/ Start at the origin facing the +X direction\nnew Pose2d(0, 0, new Rotation2d(0)),\n\/\/ Pass through these two interior waypoints, making an 's' curve path\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n\nList.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n\/\/ End 3 meters straight ahead of where we started, facing forward\nnew Pose2d(3, 0, new Rotation2d(0)),\nconfig);*\/\nProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0.,\nnew Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\nthetaController.enableContinuousInput(-Math.PI, Math.PI);\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}\n\nthetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}\n\n\/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\nPPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\nppTrajectory,\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}\n\nRobotState::getPoseEstimate,\n\/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n\/\/and then use that in the mecDriveTrain.setSpeeds() method\n\/\/mecDriveTrain.getMecFeedforward(),\nRobotState.getMecKinematics(),\n\/\/ Position contollers\nnew PIDController(Constants.kpMecPosXController, 0, 0),\nnew PIDController(Constants.kpMecPosYController, 0, 0),\nthetaController,\n\/\/ Needed for normalizing wheel speeds\n\/\/Constants.maxMecSpeed,\n\/\/ Velocity PID's\n\/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\nnew PIDController(Constants.kpMecL2Velocity, 0, 0),\nnew PIDController(Constants.kpMecR1Velocity, 0, 0),\nnew PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n\/\/mecDriveTrain::getCurrentWheelSpeeds,\nmecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\nmecDriveTrain\n);\n\/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n\/*return new InstantCommand(() ->\nmecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n.andThen(mecanumControllerCommand);\n\/\/.andThen(mecDriveTrain::stopDrive);*\/\nreturn mecanumControllerCommand;\n}","label":[1,0,0,0]}
{"id":14329,"original_code":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\n        File allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\n        if (allianceFile.exists()) {\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(allianceFile));\n                String line;\n                alliances = new Alliance[4];\n                while ((line = reader.readLine()) != null) {\n                    \/* Alliance info *\/\n                    String[] allianceInfo = line.split(\"\\\\|\");\n                    int division = Integer.parseInt(allianceInfo[0]);\n                    int allianceNumber = Integer.parseInt(allianceInfo[1]);\n                    int[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\n                    alliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n                }\n                reader.close();\n                \/* TODO - Make Upload Alliances so we can uncomment this\n                controller.btnUploadAlliances.setDisable(false);*\/\n                updateAllianceLabels(scores);\n                TOALogger.log(Level.INFO, \"Alliance import successful.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                controller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n            }\n        } else {\n            controller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n        }\n    }","code":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\n        File allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\n        if (allianceFile.exists()) {\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(allianceFile));\n                String line;\n                alliances = new Alliance[4];\n                while ((line = reader.readLine()) != null) {\n                   \n                    String[] allianceInfo = line.split(\"\\\\|\");\n                    int division = Integer.parseInt(allianceInfo[0]);\n                    int allianceNumber = Integer.parseInt(allianceInfo[1]);\n                    int[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\n                    alliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n                }\n                reader.close();\n               \n                updateAllianceLabels(scores);\n                TOALogger.log(Level.INFO, \"Alliance import successful.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                controller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n            }\n        } else {\n            controller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n        }\n    }","cleancode":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","comment":"\/* alliance info *\/\n\/* todo - make upload alliances so we can uncomment this controller.btnuploadalliances.setdisable(false);*\/","repo":"Agardner329\/TOA-DataSync","code_context_2":"alliances = new Alliance[4];\nwhile ((line = reader.readLine()) != null) {\n\/* Alliance info *\/\nString[] allianceInfo = line.split(\"\\\\|\");\nint division = Integer.parseInt(allianceInfo[0]);\n\n}\nreader.close();\n\/* TODO - Make Upload Alliances so we can uncomment this\ncontroller.btnUploadAlliances.setDisable(false);*\/\nupdateAllianceLabels(scores);\nTOALogger.log(Level.INFO, \"Alliance import successful.\");","code_context_10":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\nFile allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\nif (allianceFile.exists()) {\ntry {\nBufferedReader reader = new BufferedReader(new FileReader(allianceFile));\nString line;\nalliances = new Alliance[4];\nwhile ((line = reader.readLine()) != null) {\n\/* Alliance info *\/\nString[] allianceInfo = line.split(\"\\\\|\");\nint division = Integer.parseInt(allianceInfo[0]);\nint allianceNumber = Integer.parseInt(allianceInfo[1]);\nint[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\nalliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n}\nreader.close();\n\/* TODO - Make Upload Alliances so we can uncomment this\ncontroller.btnUploadAlliances.setDisable(false);*\/\nupdateAllianceLabels(scores);\n\nalliances = new Alliance[4];\nwhile ((line = reader.readLine()) != null) {\n\/* Alliance info *\/\nString[] allianceInfo = line.split(\"\\\\|\");\nint division = Integer.parseInt(allianceInfo[0]);\nint allianceNumber = Integer.parseInt(allianceInfo[1]);\nint[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\nalliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n}\nreader.close();\n\/* TODO - Make Upload Alliances so we can uncomment this\ncontroller.btnUploadAlliances.setDisable(false);*\/\nupdateAllianceLabels(scores);\nTOALogger.log(Level.INFO, \"Alliance import successful.\");\n} catch (Exception e) {\ne.printStackTrace();\ncontroller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n}\n} else {\ncontroller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n}\n}","code_context_20":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\nFile allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\nif (allianceFile.exists()) {\ntry {\nBufferedReader reader = new BufferedReader(new FileReader(allianceFile));\nString line;\nalliances = new Alliance[4];\nwhile ((line = reader.readLine()) != null) {\n\/* Alliance info *\/\nString[] allianceInfo = line.split(\"\\\\|\");\nint division = Integer.parseInt(allianceInfo[0]);\nint allianceNumber = Integer.parseInt(allianceInfo[1]);\nint[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\nalliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n}\nreader.close();\n\/* TODO - Make Upload Alliances so we can uncomment this\ncontroller.btnUploadAlliances.setDisable(false);*\/\nupdateAllianceLabels(scores);\nTOALogger.log(Level.INFO, \"Alliance import successful.\");\n} catch (Exception e) {\ne.printStackTrace();\ncontroller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n}\n} else {\ncontroller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n}\n}\n\npublic void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\nFile allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\nif (allianceFile.exists()) {\ntry {\nBufferedReader reader = new BufferedReader(new FileReader(allianceFile));\nString line;\nalliances = new Alliance[4];\nwhile ((line = reader.readLine()) != null) {\n\/* Alliance info *\/\nString[] allianceInfo = line.split(\"\\\\|\");\nint division = Integer.parseInt(allianceInfo[0]);\nint allianceNumber = Integer.parseInt(allianceInfo[1]);\nint[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\nalliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n}\nreader.close();\n\/* TODO - Make Upload Alliances so we can uncomment this\ncontroller.btnUploadAlliances.setDisable(false);*\/\nupdateAllianceLabels(scores);\nTOALogger.log(Level.INFO, \"Alliance import successful.\");\n} catch (Exception e) {\ne.printStackTrace();\ncontroller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n}\n} else {\ncontroller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n}\n}","label":[0,1,0,0]}
{"id":14380,"original_code":"public void testEmit() throws Exception {\n        eh.on(\"ok\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"ok\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.on(\"no\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"no\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.emit(\"ok\");\n        eh.emit(\"ok\", \"ok\");\n        eh.emit(\"ok\", \"no\");\n        eh.emit(\"no\");\n        eh.emit(\"no\", \"no\");\n        eh.emit(\"no\", \"ok\");\n        eh.emit(\"unknown\");\n        eh.emit(\"unknown\", \"ok\");\n        eh.emit(\"unknown\", \"no\");\n        fail(); \/\/ FIXME these tests are not correct\n    }","code":"public void testEmit() throws Exception {\n        eh.on(\"ok\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"ok\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.on(\"no\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"no\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.emit(\"ok\");\n        eh.emit(\"ok\", \"ok\");\n        eh.emit(\"ok\", \"no\");\n        eh.emit(\"no\");\n        eh.emit(\"no\", \"no\");\n        eh.emit(\"no\", \"ok\");\n        eh.emit(\"unknown\");\n        eh.emit(\"unknown\", \"ok\");\n        eh.emit(\"unknown\", \"no\");\n        fail();\n    }","cleancode":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); }","comment":"\/** * * todo figure out how to test this * * @throws exception *\/\n\/\/ fixme these tests are not correct","repo":"InstantWebP2P\/node-android","code_context_2":"public void testEmit() throws Exception {\neh.on(\"ok\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"ok\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.on(\"no\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"no\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.emit(\"ok\");\neh.emit(\"ok\", \"ok\");\neh.emit(\"ok\", \"no\");\neh.emit(\"no\");\neh.emit(\"no\", \"no\");\neh.emit(\"no\", \"ok\");\neh.emit(\"unknown\");\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}\n\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}","code_context_10":"public void testEmit() throws Exception {\neh.on(\"ok\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"ok\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.on(\"no\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"no\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.emit(\"ok\");\neh.emit(\"ok\", \"ok\");\neh.emit(\"ok\", \"no\");\neh.emit(\"no\");\neh.emit(\"no\", \"no\");\neh.emit(\"no\", \"ok\");\neh.emit(\"unknown\");\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}\n\n});\neh.emit(\"ok\");\neh.emit(\"ok\", \"ok\");\neh.emit(\"ok\", \"no\");\neh.emit(\"no\");\neh.emit(\"no\", \"no\");\neh.emit(\"no\", \"ok\");\neh.emit(\"unknown\");\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}","code_context_20":"public void testEmit() throws Exception {\neh.on(\"ok\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"ok\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.on(\"no\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"no\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.emit(\"ok\");\neh.emit(\"ok\", \"ok\");\neh.emit(\"ok\", \"no\");\neh.emit(\"no\");\neh.emit(\"no\", \"no\");\neh.emit(\"no\", \"ok\");\neh.emit(\"unknown\");\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}\n\n});\neh.on(\"no\", new EventEmitter.Listener() {\n@Override\npublic void onEvent(Object data) {\nString ss = (String) data;\nif (ss == \"no\")\nLog.d(TAG, \"pass@\" + ss);\nelse\nLog.d(TAG, \"fail@\" + ss);\n}\n});\neh.emit(\"ok\");\neh.emit(\"ok\", \"ok\");\neh.emit(\"ok\", \"no\");\neh.emit(\"no\");\neh.emit(\"no\", \"no\");\neh.emit(\"no\", \"ok\");\neh.emit(\"unknown\");\neh.emit(\"unknown\", \"ok\");\neh.emit(\"unknown\", \"no\");\nfail(); \/\/ FIXME these tests are not correct\n}","label":[0,0,0,1]}
{"id":14566,"original_code":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\n        if (tree instanceof MethodTree) {\n            var method = (MethodTree) tree;\n            var parameters = new StringJoiner(\", \");\n            for (var p : method.getParameters()) {\n                parameters.add(p.getType() + \" \" + p.getName());\n            }\n            item.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\n            if (!method.getThrows().isEmpty()) {\n                var exceptions = new StringJoiner(\", \");\n                for (var e : method.getThrows()) {\n                    exceptions.add(e.toString());\n                }\n                item.detail += \" throws \" + exceptions;\n            }\n            if (data.plusOverloads != 0) {\n                item.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n            }\n        }\n    }","code":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\n        if (tree instanceof MethodTree) {\n            var method = (MethodTree) tree;\n            var parameters = new StringJoiner(\", \");\n            for (var p : method.getParameters()) {\n                parameters.add(p.getType() + \" \" + p.getName());\n            }\n            item.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\n            if (!method.getThrows().isEmpty()) {\n                var exceptions = new StringJoiner(\", \");\n                for (var e : method.getThrows()) {\n                    exceptions.add(e.toString());\n                }\n                item.detail += \" throws \" + exceptions;\n            }\n            if (data.plusOverloads != 0) {\n                item.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n            }\n        }\n    }","cleancode":"private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","comment":"\/\/ todo consider showing actual source code instead of just types and names","repo":"80952556400\/java-language-server","code_context_2":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\nif (tree instanceof MethodTree) {\nvar method = (MethodTree) tree;\nvar parameters = new StringJoiner(\", \");\nfor (var p : method.getParameters()) {\nparameters.add(p.getType() + \" \" + p.getName());\n}\nitem.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\nif (!method.getThrows().isEmpty()) {\nvar exceptions = new StringJoiner(\", \");\nfor (var e : method.getThrows()) {\nexceptions.add(e.toString());\n}\nitem.detail += \" throws \" + exceptions;\n}\nif (data.plusOverloads != 0) {\nitem.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n}\n}\n}","code_context_10":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\nif (tree instanceof MethodTree) {\nvar method = (MethodTree) tree;\nvar parameters = new StringJoiner(\", \");\nfor (var p : method.getParameters()) {\nparameters.add(p.getType() + \" \" + p.getName());\n}\nitem.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\nif (!method.getThrows().isEmpty()) {\nvar exceptions = new StringJoiner(\", \");\nfor (var e : method.getThrows()) {\nexceptions.add(e.toString());\n}\nitem.detail += \" throws \" + exceptions;\n}\nif (data.plusOverloads != 0) {\nitem.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n}\n}\n}","code_context_20":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\nif (tree instanceof MethodTree) {\nvar method = (MethodTree) tree;\nvar parameters = new StringJoiner(\", \");\nfor (var p : method.getParameters()) {\nparameters.add(p.getType() + \" \" + p.getName());\n}\nitem.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\nif (!method.getThrows().isEmpty()) {\nvar exceptions = new StringJoiner(\", \");\nfor (var e : method.getThrows()) {\nexceptions.add(e.toString());\n}\nitem.detail += \" throws \" + exceptions;\n}\nif (data.plusOverloads != 0) {\nitem.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n}\n}\n}","label":[1,0,0,0]}
{"id":30960,"original_code":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\n\t\tHashMap<String, String> initialValues = new HashMap<String, String>();\n\t\tinitialValues.put(\"eventDate\", eventDate);\n\t\tinitialValues.put(\"scientificName\", scientificName);\n\t\tinitialValues.put(\"reproductive\", reproductiveState);\n\t\tinitialValues.put(\"country\", country);\n\t\tinitialValues.put(\"kingdom\", kingdom);\n\t\tinitialValues.put(\"latitude\", latitude);\n\t\tinitialValues.put(\"longitude\", longitude);\n\t\tinitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\t\t\/\/ TODO: fix to compare provided eventDate and reproductiveState with data from FNA\n\t    Vector<String> months = new Vector<String>();\n\t\tVector<String> foundFloweringTime = null;\n\t\tif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\n\t\t\tfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase()); \n\t\t}\n\t\tif(foundFloweringTime == null){\n\t\t\tsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\n\t\t\taddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\n\t\t\tcorrectedFloweringTime = null;\n\t\t}else{\n\t\t\tif(months==null || !months.containsAll(foundFloweringTime) || !foundFloweringTime.containsAll(months) ){\n\t\t\t\tsetCurationStatus(CurationComment.UNABLE_CURATED);\n\t\t\t\taddToComment(\"Provided event date and flowering state is inconsistent with known flowering times for species according to FNA.\");\n\t\t\t}else{\n\t\t\t\tsetCurationStatus(CurationComment.CORRECT);\n\t\t\t\taddToComment(\"The event date and flowering state is consistent with authoritative data from FNA\");\n\t\t\t\tcorrectedFloweringTime = months; \t\t\t\t\n\t\t\t}\n\t\t}\n\t}","code":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\n\t\tHashMap<String, String> initialValues = new HashMap<String, String>();\n\t\tinitialValues.put(\"eventDate\", eventDate);\n\t\tinitialValues.put(\"scientificName\", scientificName);\n\t\tinitialValues.put(\"reproductive\", reproductiveState);\n\t\tinitialValues.put(\"country\", country);\n\t\tinitialValues.put(\"kingdom\", kingdom);\n\t\tinitialValues.put(\"latitude\", latitude);\n\t\tinitialValues.put(\"longitude\", longitude);\n\t\tinitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\t\n\t    Vector<String> months = new Vector<String>();\n\t\tVector<String> foundFloweringTime = null;\n\t\tif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\n\t\t\tfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase()); \n\t\t}\n\t\tif(foundFloweringTime == null){\n\t\t\tsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\n\t\t\taddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\n\t\t\tcorrectedFloweringTime = null;\n\t\t}else{\n\t\t\tif(months==null || !months.containsAll(foundFloweringTime) || !foundFloweringTime.containsAll(months) ){\n\t\t\t\tsetCurationStatus(CurationComment.UNABLE_CURATED);\n\t\t\t\taddToComment(\"Provided event date and flowering state is inconsistent with known flowering times for species according to FNA.\");\n\t\t\t}else{\n\t\t\t\tsetCurationStatus(CurationComment.CORRECT);\n\t\t\t\taddToComment(\"The event date and flowering state is consistent with authoritative data from FNA\");\n\t\t\t\tcorrectedFloweringTime = months; \t\t\t\t\n\t\t\t}\n\t\t}\n\t}","cleancode":"public void validatefloweringtime(string scientificname, string eventdate, string reproductivestate, string country, string kingdom, string latitude, string longitude) { hashmap<string, string> initialvalues = new hashmap<string, string>(); initialvalues.put(\"eventdate\", eventdate); initialvalues.put(\"scientificname\", scientificname); initialvalues.put(\"reproductive\", reproductivestate); initialvalues.put(\"country\", country); initialvalues.put(\"kingdom\", kingdom); initialvalues.put(\"latitude\", latitude); initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null; if(authoritativefloweringtimemap != null && authoritativefloweringtimemap.containskey(scientificname.tolowercase())){ foundfloweringtime = authoritativefloweringtimemap.get(scientificname.tolowercase()); } if(foundfloweringtime == null){ setcurationstatus(curationcomment.unable_determine_validity); addtocomment(\"can't find the flowering time of the \"+scientificname+\" in the current available phenology data from fna.\"); correctedfloweringtime = null; }else{ if(months==null || !months.containsall(foundfloweringtime) || !foundfloweringtime.containsall(months) ){ setcurationstatus(curationcomment.unable_curated); addtocomment(\"provided event date and flowering state is inconsistent with known flowering times for species according to fna.\"); }else{ setcurationstatus(curationcomment.correct); addtocomment(\"the event date and flowering state is consistent with authoritative data from fna\"); correctedfloweringtime = months; } } }","comment":"\/\/ todo: fix to compare provided eventdate and reproductivestate with data from fna","repo":"FilteredPush\/FP-KurationServices","code_context_2":"initialValues.put(\"longitude\", longitude);\ninitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\/\/ TODO: fix to compare provided eventDate and reproductiveState with data from FNA\nVector<String> months = new Vector<String>();\nVector<String> foundFloweringTime = null;","code_context_10":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\nHashMap<String, String> initialValues = new HashMap<String, String>();\ninitialValues.put(\"eventDate\", eventDate);\ninitialValues.put(\"scientificName\", scientificName);\ninitialValues.put(\"reproductive\", reproductiveState);\ninitialValues.put(\"country\", country);\ninitialValues.put(\"kingdom\", kingdom);\ninitialValues.put(\"latitude\", latitude);\ninitialValues.put(\"longitude\", longitude);\ninitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\/\/ TODO: fix to compare provided eventDate and reproductiveState with data from FNA\nVector<String> months = new Vector<String>();\nVector<String> foundFloweringTime = null;\nif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\nfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase());\n}\nif(foundFloweringTime == null){\nsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\naddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\ncorrectedFloweringTime = null;\n}else{","code_context_20":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\nHashMap<String, String> initialValues = new HashMap<String, String>();\ninitialValues.put(\"eventDate\", eventDate);\ninitialValues.put(\"scientificName\", scientificName);\ninitialValues.put(\"reproductive\", reproductiveState);\ninitialValues.put(\"country\", country);\ninitialValues.put(\"kingdom\", kingdom);\ninitialValues.put(\"latitude\", latitude);\ninitialValues.put(\"longitude\", longitude);\ninitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\/\/ TODO: fix to compare provided eventDate and reproductiveState with data from FNA\nVector<String> months = new Vector<String>();\nVector<String> foundFloweringTime = null;\nif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\nfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase());\n}\nif(foundFloweringTime == null){\nsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\naddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\ncorrectedFloweringTime = null;\n}else{\nif(months==null || !months.containsAll(foundFloweringTime) || !foundFloweringTime.containsAll(months) ){\nsetCurationStatus(CurationComment.UNABLE_CURATED);\naddToComment(\"Provided event date and flowering state is inconsistent with known flowering times for species according to FNA.\");\n}else{\nsetCurationStatus(CurationComment.CORRECT);\naddToComment(\"The event date and flowering state is consistent with authoritative data from FNA\");\ncorrectedFloweringTime = months;\n}\n}\n}","label":[1,0,0,0]}
{"id":22911,"original_code":"private void pickRawContactDelta() {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n        }\n        for (int j = 0; j < mRawContactDeltas.size(); j++) {\n            final RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n            }\n            if (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\n            final AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\n            if (accountType == null) continue;\n            if (mRawContactIdToDisplayAlone > 0) {\n                \/\/ Look for the raw contact if specified.\n                if (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\n                    mCurrentRawContactDelta = rawContactDelta;\n                    return;\n                }\n            } else if (mPrimaryAccount != null\n                    && mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n                \/\/ Otherwise try to find the one that matches the default.\n                mCurrentRawContactDelta = rawContactDelta;\n                return;\n            } else if (accountType.areContactsWritable()){\n                \/\/ TODO: Find better raw contact delta\n                \/\/ Just select an arbitrary writable contact.\n                mCurrentRawContactDelta = rawContactDelta;\n            }\n        }\n    }","code":"private void pickRawContactDelta() {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n        }\n        for (int j = 0; j < mRawContactDeltas.size(); j++) {\n            final RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n            }\n            if (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\n            final AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\n            if (accountType == null) continue;\n            if (mRawContactIdToDisplayAlone > 0) {\n               \n                if (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\n                    mCurrentRawContactDelta = rawContactDelta;\n                    return;\n                }\n            } else if (mPrimaryAccount != null\n                    && mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n               \n                mCurrentRawContactDelta = rawContactDelta;\n                return;\n            } else if (accountType.areContactsWritable()){\n               \n               \n                mCurrentRawContactDelta = rawContactDelta;\n            }\n        }\n    }","cleancode":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ mcurrentrawcontactdelta = rawcontactdelta; } } }","comment":"\/\/ look for the raw contact if specified.\n\/\/ otherwise try to find the one that matches the default.\n\/\/ todo: find better raw contact delta \/\/ just select an arbitrary writable contact.","repo":"BrahmaOS\/brahmaos-packages-apps-Contacts","code_context_2":"if (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\n\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}","code_context_10":"}\nfor (int j = 0; j < mRawContactDeltas.size(); j++) {\nfinal RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n}\nif (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\nfinal AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\nif (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\nfinal AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\nif (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}\n}\n}\n\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}\n}\n}","code_context_20":"private void pickRawContactDelta() {\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n}\nfor (int j = 0; j < mRawContactDeltas.size(); j++) {\nfinal RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n}\nif (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\nfinal AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\nif (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}\n}\n}\n\nprivate void pickRawContactDelta() {\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n}\nfor (int j = 0; j < mRawContactDeltas.size(); j++) {\nfinal RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n}\nif (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\nfinal AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\nif (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}\n}\n}\n\nfor (int j = 0; j < mRawContactDeltas.size(); j++) {\nfinal RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\nif (Log.isLoggable(TAG, Log.VERBOSE)) {\nLog.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n}\nif (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\nfinal AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\nif (accountType == null) continue;\nif (mRawContactIdToDisplayAlone > 0) {\n\/\/ Look for the raw contact if specified.\nif (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n}\n} else if (mPrimaryAccount != null\n&& mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n\/\/ Otherwise try to find the one that matches the default.\nmCurrentRawContactDelta = rawContactDelta;\nreturn;\n} else if (accountType.areContactsWritable()){\n\/\/ TODO: Find better raw contact delta\n\/\/ Just select an arbitrary writable contact.\nmCurrentRawContactDelta = rawContactDelta;\n}\n}\n}","label":[1,0,0,0]}
{"id":22966,"original_code":"@Override\n        public void interruptionOccurred(int currentIteration, int numIterations) {\n            \/\/ FIXME: maybe skip writing the SOM at 0 iterations (0 mod x == 0 ...)\n            String filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\n            try {\n                SOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\n                        true, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n            } catch (IOException e) {\n                Logger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n                        \"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n            }\n        }","code":"@Override\n        public void interruptionOccurred(int currentIteration, int numIterations) {\n           \n            String filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\n            try {\n                SOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\n                        true, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n            } catch (IOException e) {\n                Logger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n                        \"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n            }\n        }","cleancode":"@override public void interruptionoccurred(int currentiteration, int numiterations) { string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try { somlibmapoutputter.writeweightvectorfile(growingsom.this, fileproperties.outputdirectory(), filename, true, \"$current_iteration=\" + currentiteration, \"$num_iterations=\" + numiterations); } catch (ioexception e) { logger.getlogger(\"at.tuwien.ifs.somtoolbox\").severe( \"could not open or write to output file \" + filename + \": \" + e.getmessage()); } }","comment":"\/\/ fixme: maybe skip writing the som at 0 iterations (0 mod x == 0 ...)","repo":"ChrisPrein\/TUW_SelfOrganizingSystems_WS2021","code_context_2":"@Override\npublic void interruptionOccurred(int currentIteration, int numIterations) {\n\/\/ FIXME: maybe skip writing the SOM at 0 iterations (0 mod x == 0 ...)\nString filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\ntry {","code_context_10":"@Override\npublic void interruptionOccurred(int currentIteration, int numIterations) {\n\/\/ FIXME: maybe skip writing the SOM at 0 iterations (0 mod x == 0 ...)\nString filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\ntry {\nSOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\ntrue, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n} catch (IOException e) {\nLogger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n\"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n}\n}","code_context_20":"@Override\npublic void interruptionOccurred(int currentIteration, int numIterations) {\n\/\/ FIXME: maybe skip writing the SOM at 0 iterations (0 mod x == 0 ...)\nString filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\ntry {\nSOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\ntrue, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n} catch (IOException e) {\nLogger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n\"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n}\n}","label":[0,0,1,0]}
{"id":23001,"original_code":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\t\t\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\n\t\tint radius = this.range;\n\t\tthis.world = world;\n\t\tthis.rand.setSeed(world.getSeed());\n\t\t\/\/used to randomize contribution of each coordinate to the cube seed\n\t\t\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\t\t\/\/so structures would generate symmetrically\n\t\tlong randX = this.rand.nextLong();\n\t\tlong randY = this.rand.nextLong();\n\t\tlong randZ = this.rand.nextLong();\n\t\tint cubeX = cubePos.getX();\n\t\tint cubeY = cubePos.getY();\n\t\tint cubeZ = cubePos.getZ();\n\t\t\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\n\t\tfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\n\t\t\tfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\n\t\t\t\tfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\n\t\t\t\t\tlong randX_mul = xOrigin*randX;\n\t\t\t\t\tlong randY_mul = yOrigin*randY;\n\t\t\t\t\tlong randZ_mul = zOrigin*randZ;\n\t\t\t\t\tthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\n\t\t\t\t\tthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","code":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\t\n\t\tint radius = this.range;\n\t\tthis.world = world;\n\t\tthis.rand.setSeed(world.getSeed());\n\t\n\t\n\t\n\t\tlong randX = this.rand.nextLong();\n\t\tlong randY = this.rand.nextLong();\n\t\tlong randZ = this.rand.nextLong();\n\t\tint cubeX = cubePos.getX();\n\t\tint cubeY = cubePos.getY();\n\t\tint cubeZ = cubePos.getZ();\n\t\n\t\tfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\n\t\t\tfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\n\t\t\t\tfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\n\t\t\t\t\tlong randX_mul = xOrigin*randX;\n\t\t\t\t\tlong randY_mul = yOrigin*randY;\n\t\t\t\t\tlong randZ_mul = zOrigin*randZ;\n\t\t\t\t\tthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\n\t\t\t\t\tthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","cleancode":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","comment":"\/** * generates structures in given cube. * * @param world the world that the structure is generated in * @param cube the block buffer to be filled with blocks (cube) * @param cubepos position of the cube to generate structures in *\/\n\/\/todo: maybe skip some of this stuff if the cube is empty? (would need to use hints)\n\/\/used to randomize contribution of each coordinate to the cube seed \/\/without these swapping x\/y\/z coordinates would result in the same seed \/\/so structures would generate symmetrically\n\/\/x\/y\/zorigin is location of the structure \"center\", and cubex\/y\/z is the currently generated cube","repo":"Cyclonit\/CubicChunks","code_context_2":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}\n}\n}\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\n\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\n\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {","code_context_10":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}\n}\n}\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\n\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}","code_context_20":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}\n}\n}\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}\n}\n}\n\npublic void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\nint radius = this.range;\nthis.world = world;\nthis.rand.setSeed(world.getSeed());\n\/\/used to randomize contribution of each coordinate to the cube seed\n\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\/\/so structures would generate symmetrically\nlong randX = this.rand.nextLong();\nlong randY = this.rand.nextLong();\nlong randZ = this.rand.nextLong();\nint cubeX = cubePos.getX();\nint cubeY = cubePos.getY();\nint cubeZ = cubePos.getZ();\n\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\nfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\nfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\nfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\nlong randX_mul = xOrigin*randX;\nlong randY_mul = yOrigin*randY;\nlong randZ_mul = zOrigin*randZ;\nthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\nthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n}\n}\n}\n}","label":[0,1,0,0]}
{"id":31498,"original_code":"public void testGetEnteredDate() {\n    System.out.println(\"testGetEnteredDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testGetEnteredDate() {\n    System.out.println(\"testGetEnteredDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of getentereddate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetEnteredDate() {\nSystem.out.println(\"testGetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31499,"original_code":"public void testSetEnteredDate() {\n    System.out.println(\"testSetEnteredDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testSetEnteredDate() {\n    System.out.println(\"testSetEnteredDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of setentereddate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetEnteredDate() {\nSystem.out.println(\"testSetEnteredDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31500,"original_code":"public void testGetModifiedDate() {\n    System.out.println(\"testGetModifiedDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testGetModifiedDate() {\n    System.out.println(\"testGetModifiedDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of getmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetModifiedDate() {\nSystem.out.println(\"testGetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31501,"original_code":"public void testSetModifiedDate() {\n    System.out.println(\"testSetModifiedDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testSetModifiedDate() {\n    System.out.println(\"testSetModifiedDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of setmodifieddate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetModifiedDate() {\nSystem.out.println(\"testSetModifiedDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,1,0,0]}
{"id":31502,"original_code":"public void testGetReleaseDate() {\n    System.out.println(\"testGetReleaseDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testGetReleaseDate() {\n    System.out.println(\"testGetReleaseDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of getreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetReleaseDate() {\nSystem.out.println(\"testGetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31503,"original_code":"public void testSetReleaseDate() {\n    System.out.println(\"testSetReleaseDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testSetReleaseDate() {\n    System.out.println(\"testSetReleaseDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of setreleasedate method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetReleaseDate() {\nSystem.out.println(\"testSetReleaseDate\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31504,"original_code":"public void testGetVisibleTo() {\n    System.out.println(\"testGetVisibleTo\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testGetVisibleTo() {\n    System.out.println(\"testGetVisibleTo\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of getvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testGetVisibleTo() {\nSystem.out.println(\"testGetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31505,"original_code":"public void testSetVisibleTo() {\n    System.out.println(\"testSetVisibleTo\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testSetVisibleTo() {\n    System.out.println(\"testSetVisibleTo\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of setvisibleto method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testSetVisibleTo() {\nSystem.out.println(\"testSetVisibleTo\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31506,"original_code":"public void testToString() {\n    System.out.println(\"testToString\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testToString() {\n    System.out.println(\"testToString\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testtostring() { system.out.println(\"testtostring\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of tostring method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testToString() {\nSystem.out.println(\"testToString\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":31507,"original_code":"public void testEquals() {\n    System.out.println(\"testEquals\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code":"public void testEquals() {\n    System.out.println(\"testEquals\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testequals() { system.out.println(\"testequals\"); fail(\"the test case is empty.\"); }","comment":"\/** * test of equals method, of class gov.nih.nci.camod.domain.availability. *\/\n\/\/ todo add your test code below by replacing the default call to fail.","repo":"CBIIT\/camod","code_context_2":"public void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_10":"public void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","code_context_20":"public void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}\n\npublic void testEquals() {\nSystem.out.println(\"testEquals\");\n\/\/ TODO add your test code below by replacing the default call to fail.\nfail(\"The test case is empty.\");\n}","label":[0,0,0,1]}
{"id":15312,"original_code":"private void initMenuItems() {\n        menuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                var fileChooser = new FileChooser();\n                var selected = fileChooser.showOpenDialog(null);\n                if (selected != null) {\n                    \/\/TODO: file was choosen;\n                    ifmlEngine.loadStory(selected);\n                }\n            }\n        });\n        menuItemFileRestart.setDisable(true);\n        menuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                \/\/TODO: Ask You are sure ?\n                ifmlEngine.restart();\n            }\n        });\n        menuItemFileSave.setDisable(true);\n        menuItemFileLoad.setDisable(true);\n        menuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                \/\/TODO: Add question: You are really want to exit.\n                Platform.exit();\n            }\n        });\n        menuItemLibraryCatalog.setDisable(true);\n        menuItemLibraryImport.setDisable(true);\n        menuItemSettingsCheat.setDisable(true);\n        menuItemSettingsSettings.setDisable(true);\n    }","code":"private void initMenuItems() {\n        menuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                var fileChooser = new FileChooser();\n                var selected = fileChooser.showOpenDialog(null);\n                if (selected != null) {\n                   \n                    ifmlEngine.loadStory(selected);\n                }\n            }\n        });\n        menuItemFileRestart.setDisable(true);\n        menuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n               \n                ifmlEngine.restart();\n            }\n        });\n        menuItemFileSave.setDisable(true);\n        menuItemFileLoad.setDisable(true);\n        menuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n               \n                Platform.exit();\n            }\n        });\n        menuItemLibraryCatalog.setDisable(true);\n        menuItemLibraryImport.setDisable(true);\n        menuItemSettingsCheat.setDisable(true);\n        menuItemSettingsSettings.setDisable(true);\n    }","cleancode":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","comment":"\/\/todo: file was choosen;\n\/\/todo: ask you are sure ?\n\/\/todo: add question: you are really want to exit.","repo":"IFML2\/ifml-player","code_context_2":"var selected = fileChooser.showOpenDialog(null);\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n}","code_context_10":"private void initMenuItems() {\nmenuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\nvar fileChooser = new FileChooser();\nvar selected = fileChooser.showOpenDialog(null);\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n}\n});\nmenuItemFileRestart.setDisable(true);\nmenuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n}\n});\nmenuItemFileRestart.setDisable(true);\nmenuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n});\nmenuItemFileSave.setDisable(true);\nmenuItemFileLoad.setDisable(true);\nmenuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n});\nmenuItemFileSave.setDisable(true);\nmenuItemFileLoad.setDisable(true);\nmenuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n}\n});\nmenuItemLibraryCatalog.setDisable(true);\nmenuItemLibraryImport.setDisable(true);\nmenuItemSettingsCheat.setDisable(true);\nmenuItemSettingsSettings.setDisable(true);\n}","code_context_20":"private void initMenuItems() {\nmenuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\nvar fileChooser = new FileChooser();\nvar selected = fileChooser.showOpenDialog(null);\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n}\n});\nmenuItemFileRestart.setDisable(true);\nmenuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n});\nmenuItemFileSave.setDisable(true);\nmenuItemFileLoad.setDisable(true);\nmenuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n}\n\nprivate void initMenuItems() {\nmenuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\nvar fileChooser = new FileChooser();\nvar selected = fileChooser.showOpenDialog(null);\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n}\n});\nmenuItemFileRestart.setDisable(true);\nmenuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n});\nmenuItemFileSave.setDisable(true);\nmenuItemFileLoad.setDisable(true);\nmenuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n}\n});\nmenuItemLibraryCatalog.setDisable(true);\nmenuItemLibraryImport.setDisable(true);\nmenuItemSettingsCheat.setDisable(true);\nmenuItemSettingsSettings.setDisable(true);\n}\n\nvar selected = fileChooser.showOpenDialog(null);\nif (selected != null) {\n\/\/TODO: file was choosen;\nifmlEngine.loadStory(selected);\n}\n}\n});\nmenuItemFileRestart.setDisable(true);\nmenuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Ask You are sure ?\nifmlEngine.restart();\n}\n});\nmenuItemFileSave.setDisable(true);\nmenuItemFileLoad.setDisable(true);\nmenuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n@Override\npublic void handle(ActionEvent event) {\n\/\/TODO: Add question: You are really want to exit.\nPlatform.exit();\n}\n});\nmenuItemLibraryCatalog.setDisable(true);\nmenuItemLibraryImport.setDisable(true);\nmenuItemSettingsCheat.setDisable(true);\nmenuItemSettingsSettings.setDisable(true);\n}","label":[0,1,0,0]}
{"id":15473,"original_code":"private static Path resolve(Path parent, String path) {\n        \/\/ Ensure directories exist\n        File directory = parent.toFile();\n        if (!directory.exists() && !directory.mkdirs()) {\n            \/\/ Failed to create directories... should probably let this crash\n            ScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\n                    directory.getAbsolutePath());\n        }\n        return parent.resolve(path);\n    }","code":"private static Path resolve(Path parent, String path) {\n       \n        File directory = parent.toFile();\n        if (!directory.exists() && !directory.mkdirs()) {\n           \n            ScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\n                    directory.getAbsolutePath());\n        }\n        return parent.resolve(path);\n    }","cleancode":"private static path resolve(path parent, string path) { file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","comment":"\/\/ ensure directories exist\n\/\/ failed to create directories... should probably let this crash","repo":"Cyborgmas\/ScalingHealth","code_context_2":"private static Path resolve(Path parent, String path) {\n\/\/ Ensure directories exist\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\/\/ Failed to create directories... should probably let this crash\nScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\ndirectory.getAbsolutePath());","code_context_10":"private static Path resolve(Path parent, String path) {\n\/\/ Ensure directories exist\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\/\/ Failed to create directories... should probably let this crash\nScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\ndirectory.getAbsolutePath());\n}\nreturn parent.resolve(path);\n}\n\nprivate static Path resolve(Path parent, String path) {\n\/\/ Ensure directories exist\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\/\/ Failed to create directories... should probably let this crash\nScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\ndirectory.getAbsolutePath());\n}\nreturn parent.resolve(path);\n}","code_context_20":"private static Path resolve(Path parent, String path) {\n\/\/ Ensure directories exist\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\/\/ Failed to create directories... should probably let this crash\nScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\ndirectory.getAbsolutePath());\n}\nreturn parent.resolve(path);\n}\n\nprivate static Path resolve(Path parent, String path) {\n\/\/ Ensure directories exist\nFile directory = parent.toFile();\nif (!directory.exists() && !directory.mkdirs()) {\n\/\/ Failed to create directories... should probably let this crash\nScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\ndirectory.getAbsolutePath());\n}\nreturn parent.resolve(path);\n}","label":[0,0,1,0]}
{"id":15483,"original_code":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        Constructor<?> ctor = clazz.getDeclaredConstructors()[0];\n        ctor.setAccessible(true);\n        Object instance = ctor.newInstance();\n        Method method = null;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method m : declaredMethods) {\n            if (m.getName().equals(\"apply\")) method = m;\n        }\n        assert method != null: \"Method 'apply' not found in annotation class\";\n        method.setAccessible(true);\n        Object result;\n        try {\n            result = method.invoke(instance, trees);\n        }   catch (InvocationTargetException e) {\n            \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n            \/\/ also flatten to avoid getting nested ITEs\n            RuntimeException exception = new RuntimeException(e.getTargetException().toString());\n            exception.setStackTrace(e.getStackTrace());\n            throw exception;\n        }\n        return result;\n    }","code":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        Constructor<?> ctor = clazz.getDeclaredConstructors()[0];\n        ctor.setAccessible(true);\n        Object instance = ctor.newInstance();\n        Method method = null;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method m : declaredMethods) {\n            if (m.getName().equals(\"apply\")) method = m;\n        }\n        assert method != null: \"Method 'apply' not found in annotation class\";\n        method.setAccessible(true);\n        Object result;\n        try {\n            result = method.invoke(instance, trees);\n        }   catch (InvocationTargetException e) {\n           \n           \n            RuntimeException exception = new RuntimeException(e.getTargetException().toString());\n            exception.setStackTrace(e.getStackTrace());\n            throw exception;\n        }\n        return result;\n    }","cleancode":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","comment":"\/\/ todo: set working dir\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible \/\/ also flatten to avoid getting nested ites","repo":"FogInTheFrog\/intellij-scala","code_context_2":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\nConstructor<?> ctor = clazz.getDeclaredConstructors()[0];\nctor.setAccessible(true);\nObject instance = ctor.newInstance();\nMethod method = null;\nMethod[] declaredMethods = clazz.getDeclaredMethods();\nfor (Method m : declaredMethods) {\nif (m.getName().equals(\"apply\")) method = m;\n}\nassert method != null: \"Method 'apply' not found in annotation class\";\nmethod.setAccessible(true);\nObject result;\ntry {\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());\nthrow exception;\n}\nreturn result;\n}\n\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());","code_context_10":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\nConstructor<?> ctor = clazz.getDeclaredConstructors()[0];\nctor.setAccessible(true);\nObject instance = ctor.newInstance();\nMethod method = null;\nMethod[] declaredMethods = clazz.getDeclaredMethods();\nfor (Method m : declaredMethods) {\nif (m.getName().equals(\"apply\")) method = m;\n}\nassert method != null: \"Method 'apply' not found in annotation class\";\nmethod.setAccessible(true);\nObject result;\ntry {\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());\nthrow exception;\n}\nreturn result;\n}\n\nMethod[] declaredMethods = clazz.getDeclaredMethods();\nfor (Method m : declaredMethods) {\nif (m.getName().equals(\"apply\")) method = m;\n}\nassert method != null: \"Method 'apply' not found in annotation class\";\nmethod.setAccessible(true);\nObject result;\ntry {\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());\nthrow exception;\n}\nreturn result;\n}","code_context_20":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\nConstructor<?> ctor = clazz.getDeclaredConstructors()[0];\nctor.setAccessible(true);\nObject instance = ctor.newInstance();\nMethod method = null;\nMethod[] declaredMethods = clazz.getDeclaredMethods();\nfor (Method m : declaredMethods) {\nif (m.getName().equals(\"apply\")) method = m;\n}\nassert method != null: \"Method 'apply' not found in annotation class\";\nmethod.setAccessible(true);\nObject result;\ntry {\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());\nthrow exception;\n}\nreturn result;\n}\n\nprivate static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\nConstructor<?> ctor = clazz.getDeclaredConstructors()[0];\nctor.setAccessible(true);\nObject instance = ctor.newInstance();\nMethod method = null;\nMethod[] declaredMethods = clazz.getDeclaredMethods();\nfor (Method m : declaredMethods) {\nif (m.getName().equals(\"apply\")) method = m;\n}\nassert method != null: \"Method 'apply' not found in annotation class\";\nmethod.setAccessible(true);\nObject result;\ntry {\nresult = method.invoke(instance, trees);\n} catch (InvocationTargetException e) {\n\/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n\/\/ also flatten to avoid getting nested ITEs\nRuntimeException exception = new RuntimeException(e.getTargetException().toString());\nexception.setStackTrace(e.getStackTrace());\nthrow exception;\n}\nreturn result;\n}","label":[0,1,0,0]}
{"id":23785,"original_code":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\n        try (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n            \/\/ TODO insert preface\n        } finally {\n            context.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n        }\n    }","code":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\n        try (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n           \n        } finally {\n            context.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n        }\n    }","cleancode":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph)); } }","comment":"\/\/ todo insert preface","repo":"FIT-Mobility\/dimo-tool-suite","code_context_2":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\ntry (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n\/\/ TODO insert preface\n} finally {\ncontext.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));","code_context_10":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\ntry (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n\/\/ TODO insert preface\n} finally {\ncontext.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n}\n}","code_context_20":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\ntry (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n\/\/ TODO insert preface\n} finally {\ncontext.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n}\n}","label":[0,1,0,0]}
{"id":15634,"original_code":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\n        exec.run(() -> {\n            try {\n                boolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n                \/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n                \/\/ what the local server version of it is.\n                String inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\n                APList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\n                String replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\n                String boostTarget = parent.getStr(NodeProp.BOOST);\n                \/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\n                HashSet<String> toUserNames = new HashSet<>();\n                boolean privateMessage = true;\n                if (forceSendToPublic) {\n                    privateMessage = false;\n                } else {\n                    if (ok(node.getAc())) {\n                        \/*\n                         * Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n                         *\/\n                        for (String accntId : node.getAc().keySet()) {\n                            if (PrincipalName.PUBLIC.s().equals(accntId)) {\n                                privateMessage = false;\n                            } else {\n                                SubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n                                \/\/ get username off this node and add to 'toUserNames'\n                                if (ok(accntNode)) {\n                                    toUserNames.add(accntNode.getStr(NodeProp.USER));\n                                }\n                            }\n                        }\n                    }\n                }\n                \/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\n                String fromUser = ThreadLocals.getSC().getUserName();\n                String fromActor = apUtil.makeActorUrlForUserName(fromUser);\n                String privateKey = apCrypto.getPrivateKey(ms, fromUser);\n                String objUrl = snUtil.getIdBasedUrl(node);\n                APObj message = null;\n                if (node.getType().equals(NodeType.ACCOUNT.s())) {\n                    \/\/ construct the Update-type wrapper around teh Person object, and send\n                    message = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\n                    log.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n                } else {\n                    \/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n                    \/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n                    \/\/ that right?)\n                    if (!StringUtils.isEmpty(boostTarget)) {\n                        ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n                        message =\n                                apFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n                    }\n                    \/\/ else send out as a note.\n                    else {\n                        message = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\n                                node.getContent(), objUrl, privateMessage, attachments);\n                    }\n                }\n                \/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n                \/\/ individually\n                HashSet<String> userInboxes = new HashSet<>();\n                \/\/ When posting a public message we send out to all unique sharedInboxes here\n                if (!privateMessage) {\n                    HashSet<String> sharedInboxes = new HashSet<>();\n                    \/\/ loads ONLY foreign user's inboxes into the two sets.\n                    getSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n                    \/\/ merge both sets of inboxes into allInboxes and send to them\n                    HashSet<String> allInboxes = new HashSet<>(userInboxes);\n                    allInboxes.addAll(sharedInboxes);\n                    apUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n                }\n                \/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n                \/\/ we just sent to those above.\n                if (toUserNames.size() > 0) {\n                    sendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n                }\n            } \/\/\n            catch (Exception e) {\n                log.error(\"sendNote failed\", e);\n                throw new RuntimeException(e);\n            }\n        });\n    }","code":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\n        exec.run(() -> {\n            try {\n                boolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n               \n               \n                String inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\n                APList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\n                String replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\n                String boostTarget = parent.getStr(NodeProp.BOOST);\n               \n                HashSet<String> toUserNames = new HashSet<>();\n                boolean privateMessage = true;\n                if (forceSendToPublic) {\n                    privateMessage = false;\n                } else {\n                    if (ok(node.getAc())) {\n                       \n                        for (String accntId : node.getAc().keySet()) {\n                            if (PrincipalName.PUBLIC.s().equals(accntId)) {\n                                privateMessage = false;\n                            } else {\n                                SubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n                               \n                                if (ok(accntNode)) {\n                                    toUserNames.add(accntNode.getStr(NodeProp.USER));\n                                }\n                            }\n                        }\n                    }\n                }\n               \n                String fromUser = ThreadLocals.getSC().getUserName();\n                String fromActor = apUtil.makeActorUrlForUserName(fromUser);\n                String privateKey = apCrypto.getPrivateKey(ms, fromUser);\n                String objUrl = snUtil.getIdBasedUrl(node);\n                APObj message = null;\n                if (node.getType().equals(NodeType.ACCOUNT.s())) {\n                   \n                    message = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\n                    log.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n                } else {\n                   \n                   \n                   \n                    if (!StringUtils.isEmpty(boostTarget)) {\n                        ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n                        message =\n                                apFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n                    }\n                   \n                    else {\n                        message = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\n                                node.getContent(), objUrl, privateMessage, attachments);\n                    }\n                }\n               \n               \n                HashSet<String> userInboxes = new HashSet<>();\n               \n                if (!privateMessage) {\n                    HashSet<String> sharedInboxes = new HashSet<>();\n                   \n                    getSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n                   \n                    HashSet<String> allInboxes = new HashSet<>(userInboxes);\n                    allInboxes.addAll(sharedInboxes);\n                    apUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n                }\n               \n               \n                if (toUserNames.size() > 0) {\n                    sendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n                }\n            }\n            catch (Exception e) {\n                log.error(\"sendNote failed\", e);\n                throw new RuntimeException(e);\n            }\n        });\n    }","cleancode":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } hashset<string> userinboxes = new hashset<>(); if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","comment":"\/* * when 'node' has been created under 'parent' (by the sessioncontext user) this will send a * notification to foreign servers. this call returns immediately and delegates the actuall * proccessing to a daemon thread. * * for concurrency reasons, note that we pass in the nodeid to this method rather than the node even * if we do have the node, because we want to make sure there's no concurrent access. * * important: this method only sends notifications to users who are in the 'acl' which means these * can only be users already imported into the system, however this is ok, because we will have * called savementionstonodeacl() right before calling this method so the 'acl' should completely * contain all the mentions that exist in the text of the message. * * todo-0: we should probably extract out of this method the actual construction of the 'message' * itself and then pass the message in as a parameter, and we'd be passing in without setting the * 'cc + to' properties on the message and then the message would have those added inside here * insead of building the entire message from scratch. *\/\n\/\/ get the inreplyto from the parent property (foreign node) or if not found generate one based on \/\/ what the local server version of it is.\n\/\/ tousernames will hold all usernames in the acl list (both local and foreign user names)\n\/* * lookup all usernames from the acl info, to add them all to 'tousernames' *\/\n\/\/ get username off this node and add to 'tousernames'\n\/\/ string apid = parent.getstringprop(nodeprop.act_pub_id.s());\n\/\/ construct the update-type wrapper around teh person object, and send\n\/\/ if this node has a boosttarget, we know it's an announce so we send out the announce \/\/ todo-0: we should probably rely on if there's an actpub type itself that's \"announce\" (we save \/\/ that right?)\n\/\/ else send out as a note.\n\/\/ for users that don't have a sharedinbox we collect their inboxes here to send to them \/\/ individually\n\/\/ when posting a public message we send out to all unique sharedinboxes here\n\/\/ loads only foreign user's inboxes into the two sets.\n\/\/ merge both sets of inboxes into allinboxes and send to them\n\/\/ post message to all foreign usernames found in 'tousernames', but skip all in userinboxes becasue \/\/ we just sent to those above.\n\/\/","repo":"Clay-Ferguson\/Quantizr","code_context_2":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\n\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\n\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\n\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\n\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\n\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\n\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\n\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\n\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;","code_context_10":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\n\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\n\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\n\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\n\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;","code_context_20":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\n\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n\/\/ get username off this node and add to 'toUserNames'\nif (ok(accntNode)) {\ntoUserNames.add(accntNode.getStr(NodeProp.USER));\n}\n}\n}\n}\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\n\n}\n\/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\nString fromUser = ThreadLocals.getSC().getUserName();\nString fromActor = apUtil.makeActorUrlForUserName(fromUser);\nString privateKey = apCrypto.getPrivateKey(ms, fromUser);\nString objUrl = snUtil.getIdBasedUrl(node);\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\n\nAPObj message = null;\nif (node.getType().equals(NodeType.ACCOUNT.s())) {\n\/\/ construct the Update-type wrapper around teh Person object, and send\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n\nmessage = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\nlog.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n} else {\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n\n\/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n\/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\n\/\/ that right?)\nif (!StringUtils.isEmpty(boostTarget)) {\nZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\nmessage =\napFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\n}\n\/\/ else send out as a note.\nelse {\nmessage = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\nnode.getContent(), objUrl, privateMessage, attachments);\n}\n}\n\/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n\/\/ individually\nHashSet<String> userInboxes = new HashSet<>();\n\/\/ When posting a public message we send out to all unique sharedInboxes here\nif (!privateMessage) {\nHashSet<String> sharedInboxes = new HashSet<>();\n\/\/ loads ONLY foreign user's inboxes into the two sets.\ngetSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n\/\/ merge both sets of inboxes into allInboxes and send to them\nHashSet<String> allInboxes = new HashSet<>(userInboxes);\nallInboxes.addAll(sharedInboxes);\napUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n}\n\/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n\/\/ we just sent to those above.\nif (toUserNames.size() > 0) {\nsendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n}\n} \/\/\ncatch (Exception e) {\nlog.error(\"sendNote failed\", e);\nthrow new RuntimeException(e);\n}\n});\n}\n\npublic void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\nexec.run(() -> {\ntry {\nboolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n\/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n\/\/ what the local server version of it is.\nString inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\nAPList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\nString replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\nString boostTarget = parent.getStr(NodeProp.BOOST);\n\/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\nHashSet<String> toUserNames = new HashSet<>();\nboolean privateMessage = true;\nif (forceSendToPublic) {\nprivateMessage = false;\n} else {\nif (ok(node.getAc())) {\n\/*\n* Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n*\/\nfor (String accntId : node.getAc().keySet()) {\nif (PrincipalName.PUBLIC.s().equals(accntId)) {\nprivateMessage = false;\n} else {\nSubNode accntNode = cachedGetAccntNodeById(ms, accntId);","label":[1,0,0,0]}
{"id":15732,"original_code":"@Override\n\tpublic ReactionToIncomingMessage processIncomingMessage(Object message) {\n\t\tif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\n\t\t\tV2GMessage v2gMessageReq = (V2GMessage) message;\n\t\t\tCableCheckReqType cableCheckReq = \n\t\t\t\t\t(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\t\t\t\/\/ TODO how to react to failure status of DCEVStatus of cableCheckReq?\n\t\t\t\/*\n\t\t\t * TODO we need a timeout mechanism here so that a response can be sent within 2s\n\t\t\t * the DCEVSEStatus should be generated according to already available values\n\t\t\t * (if EVSEProcessing == ONGOING, maybe because of EVSE_IsolationMonitoringActive,\n\t\t\t * within a certain timeout, then the status must be different)\n\t\t\t *\/\n\t\t\tsetEvseProcessingFinished(true);\n\t\t\tif (isEvseProcessingFinished()) {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\n\t\t\t\tcableCheckRes.setDCEVSEStatus(\n\t\t\t\t\t\t((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n\t\t\t\t\t\t);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n\t\t\t} else {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);\n\t\t\t}\n\t\t} else {\n\t\t\tsetMandatoryFieldsForFailedRes();\n\t\t}\n\t\treturn getSendMessage(cableCheckRes, V2GMessages.NONE);\n\t}","code":"@Override\n\tpublic ReactionToIncomingMessage processIncomingMessage(Object message) {\n\t\tif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\n\t\t\tV2GMessage v2gMessageReq = (V2GMessage) message;\n\t\t\tCableCheckReqType cableCheckReq = \n\t\t\t\t\t(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\t\t\n\t\t\n\t\t\tsetEvseProcessingFinished(true);\n\t\t\tif (isEvseProcessingFinished()) {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\n\t\t\t\tcableCheckRes.setDCEVSEStatus(\n\t\t\t\t\t\t((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n\t\t\t\t\t\t);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n\t\t\t} else {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);\n\t\t\t}\n\t\t} else {\n\t\t\tsetMandatoryFieldsForFailedRes();\n\t\t}\n\t\treturn getSendMessage(cableCheckRes, V2GMessages.NONE);\n\t}","cleancode":"@override public reactiontoincomingmessage processincomingmessage(object message) { if (isincomingmessagevalid(message, cablecheckreqtype.class, cablecheckres)) { v2gmessage v2gmessagereq = (v2gmessage) message; cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); setevseprocessingfinished(true); if (isevseprocessingfinished()) { cablecheckres.setevseprocessing(evseprocessingtype.finished); cablecheckres.setdcevsestatus( ((idcevsecontroller) getcommsessioncontext().getdcevsecontroller()).getdcevsestatus(evsenotificationtype.none) ); return getsendmessage(cablecheckres, v2gmessages.pre_charge_req); } else { cablecheckres.setevseprocessing(evseprocessingtype.ongoing); return getsendmessage(cablecheckres, v2gmessages.cable_check_req); } } else { setmandatoryfieldsforfailedres(); } return getsendmessage(cablecheckres, v2gmessages.none); }","comment":"\/\/ todo how to react to failure status of dcevstatus of cablecheckreq? \/* * todo we need a timeout mechanism here so that a response can be sent within 2s * the dcevsestatus should be generated according to already available values * (if evseprocessing == ongoing, maybe because of evse_isolationmonitoringactive, * within a certain timeout, then the status must be different) *\/","repo":"I2SE\/RISE-V2G","code_context_2":"CableCheckReqType cableCheckReq =\n(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\/\/ TODO how to react to failure status of DCEVStatus of cableCheckReq?\n\/*\n* TODO we need a timeout mechanism here so that a response can be sent within 2s\n* the DCEVSEStatus should be generated according to already available values\n* (if EVSEProcessing == ONGOING, maybe because of EVSE_IsolationMonitoringActive,\n* within a certain timeout, then the status must be different)\n*\/\nsetEvseProcessingFinished(true);\nif (isEvseProcessingFinished()) {","code_context_10":"@Override\npublic ReactionToIncomingMessage processIncomingMessage(Object message) {\nif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\nV2GMessage v2gMessageReq = (V2GMessage) message;\nCableCheckReqType cableCheckReq =\n(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\/\/ TODO how to react to failure status of DCEVStatus of cableCheckReq?\n\/*\n* TODO we need a timeout mechanism here so that a response can be sent within 2s\n* the DCEVSEStatus should be generated according to already available values\n* (if EVSEProcessing == ONGOING, maybe because of EVSE_IsolationMonitoringActive,\n* within a certain timeout, then the status must be different)\n*\/\nsetEvseProcessingFinished(true);\nif (isEvseProcessingFinished()) {\ncableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\ncableCheckRes.setDCEVSEStatus(\n((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n);\nreturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n} else {\ncableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\nreturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);","code_context_20":"@Override\npublic ReactionToIncomingMessage processIncomingMessage(Object message) {\nif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\nV2GMessage v2gMessageReq = (V2GMessage) message;\nCableCheckReqType cableCheckReq =\n(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\/\/ TODO how to react to failure status of DCEVStatus of cableCheckReq?\n\/*\n* TODO we need a timeout mechanism here so that a response can be sent within 2s\n* the DCEVSEStatus should be generated according to already available values\n* (if EVSEProcessing == ONGOING, maybe because of EVSE_IsolationMonitoringActive,\n* within a certain timeout, then the status must be different)\n*\/\nsetEvseProcessingFinished(true);\nif (isEvseProcessingFinished()) {\ncableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\ncableCheckRes.setDCEVSEStatus(\n((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n);\nreturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n} else {\ncableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\nreturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);\n}\n} else {\nsetMandatoryFieldsForFailedRes();\n}\nreturn getSendMessage(cableCheckRes, V2GMessages.NONE);\n}","label":[0,1,0,0]}
{"id":15882,"original_code":"public static void startActionFoo(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_FOO);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","code":"public static void startActionFoo(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_FOO);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","cleancode":"public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","comment":"\/** * starts this service to perform action foo with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method","repo":"CasterIO\/Bootstrap","code_context_2":"public static void startActionFoo(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_FOO);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","code_context_10":"public static void startActionFoo(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_FOO);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","code_context_20":"public static void startActionFoo(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_FOO);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","label":[0,1,0,0]}
{"id":15883,"original_code":"public static void startActionBaz(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_BAZ);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","code":"public static void startActionBaz(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_BAZ);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","cleancode":"public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","comment":"\/** * starts this service to perform action baz with the given parameters. if * the service is already performing a task this action will be queued. * * @see intentservice *\/ \/\/ todo: customize helper method","repo":"CasterIO\/Bootstrap","code_context_2":"public static void startActionBaz(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_BAZ);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","code_context_10":"public static void startActionBaz(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_BAZ);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","code_context_20":"public static void startActionBaz(Context context, String param1, String param2) {\nIntent intent = new Intent(context, MyIntentService.class);\nintent.setAction(ACTION_BAZ);\nintent.putExtra(EXTRA_PARAM1, param1);\nintent.putExtra(EXTRA_PARAM2, param2);\ncontext.startService(intent);\n}","label":[0,1,0,0]}
{"id":24133,"original_code":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\n\t\treturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n\t}","code":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\n\t\treturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n\t}","cleancode":"public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","comment":"\/\/ todo incorporate evolution!","repo":"DarwinSPL\/DarwinSPL","code_context_2":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\nreturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n}","code_context_10":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\nreturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n}","code_context_20":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\nreturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n}","label":[0,1,0,0]}
{"id":15951,"original_code":"public ExpressionStageOptions generateExpressionStageOptions() {\n\t\tList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\n\t\tExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\n\t\tList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\n\t\tList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\n\t\tint idCounter = 0;\n\t\tfor (String expressionStageString : allExpressionStagesRaw) {\n\t\t\tExpressionStage expressionStage = new ExpressionStage();\n\t\t\texpressionStage.setExpressionStageTitle(expressionStageString);\n\t\t\texpressionStage.setExpressionStageId(\"stage\" + idCounter);\n\t\t\texpressionStage.setExpressionStageNumericalId(idCounter);\n\t\t\tallExpressionStages.add(expressionStage);\n\t\t\tidCounter++;\n\t\t}\n\t\t\/\/ Add expressionStageList to returned object\n\t\texpressionStageOptions.setExpressionStageList(allExpressionStages);\n\t\t\/*\n\t\t * Add embryogenesis expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\n\t\tembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\t\tembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\n\t\tembryologyExpressionStageGroup.setGroupNumericalId(0);\n\t\tList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tembryologyExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\t\texpressionStageGroupList.add(embryologyExpressionStageGroup);\n\t\t\/*\n\t\t * Add development expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\n\t\tdevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\t\tdevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\n\t\tdevelopmentExpressionStageGroup.setGroupNumericalId(1);\n\t\tList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ larva stages\n\t\tfor (int i = 75; i <= 81; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(97));\n\t\tfor (int i = 49; i <= 54; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 38; i <= 41; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ TODO: Add the others\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(19));\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(44));\n\t\tdevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\n\t\texpressionStageGroupList.add(developmentExpressionStageGroup);\n\t\t\/*\n\t\t * Add tissue expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\n\t\ttissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\t\ttissueExpressionStageGroup.setGroupId(\"group\" + 2);\n\t\ttissueExpressionStageGroup.setGroupNumericalId(2);\n\t\tList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ A Mate stages\n\t\tfor (int i = 11; i <= 29; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 32; i <= 37; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 42; i <= 43; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 47; i <= 48; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\n\t\texpressionStageGroupList.add(tissueExpressionStageGroup);\n\t\t\/*\n\t\t * Add treatment expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\n\t\ttreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\n\t\ttreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\n\t\ttreatmentExpressionStageGroup.setGroupNumericalId(3);\n\t\tList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ larva stages\n\t\tfor (int i = 82; i <= 90; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\n\t\texpressionStageGroupList.add(treatmentExpressionStageGroup);\n\t\t\/*\n\t\t * Add cell-line expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\n\t\tcellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\n\t\tcellLineExpressionStageGroup.setGroupId(\"group\" + 4);\n\t\tcellLineExpressionStageGroup.setGroupNumericalId(4);\n\t\tList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 98; i <= 103; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ larva stages\n\t\tfor (int i = 68; i <= 74; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 91; i <= 96; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 45; i <= 46; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 30; i <= 31; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tcellLineExpressionStageList.add(allExpressionStages.get(55));\n\t\t\/\/ TODO: Add the others\n\t\tcellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\n\t\texpressionStageGroupList.add(cellLineExpressionStageGroup);\n\t\texpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\n\t\treturn expressionStageOptions;\n\t}","code":"public ExpressionStageOptions generateExpressionStageOptions() {\n\t\tList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\n\t\tExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\n\t\tList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\n\t\tList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\n\t\tint idCounter = 0;\n\t\tfor (String expressionStageString : allExpressionStagesRaw) {\n\t\t\tExpressionStage expressionStage = new ExpressionStage();\n\t\t\texpressionStage.setExpressionStageTitle(expressionStageString);\n\t\t\texpressionStage.setExpressionStageId(\"stage\" + idCounter);\n\t\t\texpressionStage.setExpressionStageNumericalId(idCounter);\n\t\t\tallExpressionStages.add(expressionStage);\n\t\t\tidCounter++;\n\t\t}\n\t\n\t\texpressionStageOptions.setExpressionStageList(allExpressionStages);\n\t\n\t\tExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\n\t\tembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\t\tembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\n\t\tembryologyExpressionStageGroup.setGroupNumericalId(0);\n\t\tList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tembryologyExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\t\texpressionStageGroupList.add(embryologyExpressionStageGroup);\n\t\n\t\tExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\n\t\tdevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\t\tdevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\n\t\tdevelopmentExpressionStageGroup.setGroupNumericalId(1);\n\t\tList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tfor (int i = 75; i <= 81; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(97));\n\t\tfor (int i = 49; i <= 54; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 38; i <= 41; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(19));\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(44));\n\t\tdevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\n\t\texpressionStageGroupList.add(developmentExpressionStageGroup);\n\t\n\t\tExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\n\t\ttissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\t\ttissueExpressionStageGroup.setGroupId(\"group\" + 2);\n\t\ttissueExpressionStageGroup.setGroupNumericalId(2);\n\t\tList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 11; i <= 29; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 32; i <= 37; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 42; i <= 43; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 47; i <= 48; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\n\t\texpressionStageGroupList.add(tissueExpressionStageGroup);\n\t\n\t\tExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\n\t\ttreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\n\t\ttreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\n\t\ttreatmentExpressionStageGroup.setGroupNumericalId(3);\n\t\tList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 82; i <= 90; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\n\t\texpressionStageGroupList.add(treatmentExpressionStageGroup);\n\t\n\t\tExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\n\t\tcellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\n\t\tcellLineExpressionStageGroup.setGroupId(\"group\" + 4);\n\t\tcellLineExpressionStageGroup.setGroupNumericalId(4);\n\t\tList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 98; i <= 103; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tfor (int i = 68; i <= 74; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 91; i <= 96; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 45; i <= 46; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 30; i <= 31; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tcellLineExpressionStageList.add(allExpressionStages.get(55));\n\t\n\t\tcellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\n\t\texpressionStageGroupList.add(cellLineExpressionStageGroup);\n\t\texpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\n\t\treturn expressionStageOptions;\n\t}","cleancode":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } expressionstageoptions.setexpressionstagelist(allexpressionstages); expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","comment":"\/* * todo: at a production level, accept an enum of species with predefined * groups, and map with corresponding options * * todo: cleaner way of adding titles and ids *\/\n\/\/ add expressionstagelist to returned object\n\/* * add embryogenesis expressionstagegroup *\/\n\/\/ add embryo stages\n\/* * add development expressionstagegroup *\/\n\/\/ add embryo stages\n\/\/ larva stages\n\/\/ todo: add the others\n\/* * add tissue expressionstagegroup *\/\n\/\/ a mate stages\n\/* * add treatment expressionstagegroup *\/\n\/\/ larva stages\n\/* * add cell-line expressionstagegroup *\/\n\/\/ add embryo stages\n\/\/ larva stages\n\/\/ todo: add the others","repo":"CodingBash\/fly-transcription-webapp","code_context_2":"public ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 47; i <= 48; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\ntissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\nexpressionStageGroupList.add(tissueExpressionStageGroup);\n\/*\n* Add treatment expressionStageGroup\n*\/\nExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\ntreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\ntreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\ntreatmentExpressionStageGroup.setGroupNumericalId(3);\nList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ larva stages\nfor (int i = 82; i <= 90; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 0; i <= 10; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\ntreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\nexpressionStageGroupList.add(treatmentExpressionStageGroup);\n\/*\n* Add cell-line expressionStageGroup\n*\/\nExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\ncellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\ncellLineExpressionStageGroup.setGroupId(\"group\" + 4);\ncellLineExpressionStageGroup.setGroupNumericalId(4);\nList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 98; i <= 103; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 68; i <= 74; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 91; i <= 96; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 45; i <= 46; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 30; i <= 31; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\ncellLineExpressionStageList.add(allExpressionStages.get(55));\n\/\/ TODO: Add the others\ncellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\nexpressionStageGroupList.add(cellLineExpressionStageGroup);\nexpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\nreturn expressionStageOptions;\n}\n\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));","code_context_10":"public ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 47; i <= 48; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\ntissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\nexpressionStageGroupList.add(tissueExpressionStageGroup);\n\/*\n* Add treatment expressionStageGroup\n*\/\nExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\ntreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\ntreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\ntreatmentExpressionStageGroup.setGroupNumericalId(3);\nList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ larva stages\nfor (int i = 82; i <= 90; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 0; i <= 10; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\ntreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\nexpressionStageGroupList.add(treatmentExpressionStageGroup);\n\/*\n* Add cell-line expressionStageGroup\n*\/\nExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\ncellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\ncellLineExpressionStageGroup.setGroupId(\"group\" + 4);\ncellLineExpressionStageGroup.setGroupNumericalId(4);\nList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 98; i <= 103; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 68; i <= 74; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 91; i <= 96; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 45; i <= 46; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 30; i <= 31; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\ncellLineExpressionStageList.add(allExpressionStages.get(55));\n\/\/ TODO: Add the others\ncellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\nexpressionStageGroupList.add(cellLineExpressionStageGroup);\nexpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\nreturn expressionStageOptions;\n}\n\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\n\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 47; i <= 48; i++) {\n\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);","code_context_20":"public ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 47; i <= 48; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\ntissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\nexpressionStageGroupList.add(tissueExpressionStageGroup);\n\/*\n* Add treatment expressionStageGroup\n*\/\nExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\ntreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\ntreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\ntreatmentExpressionStageGroup.setGroupNumericalId(3);\nList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ larva stages\nfor (int i = 82; i <= 90; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 0; i <= 10; i++) {\ntreatmentExpressionStageList.add(allExpressionStages.get(i));\n}\ntreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\nexpressionStageGroupList.add(treatmentExpressionStageGroup);\n\/*\n* Add cell-line expressionStageGroup\n*\/\nExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\ncellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\ncellLineExpressionStageGroup.setGroupId(\"group\" + 4);\ncellLineExpressionStageGroup.setGroupNumericalId(4);\nList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 98; i <= 103; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 68; i <= 74; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 91; i <= 96; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 45; i <= 46; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 30; i <= 31; i++) {\ncellLineExpressionStageList.add(allExpressionStages.get(i));\n}\ncellLineExpressionStageList.add(allExpressionStages.get(55));\n\/\/ TODO: Add the others\ncellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\nexpressionStageGroupList.add(cellLineExpressionStageGroup);\nexpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\nreturn expressionStageOptions;\n}\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 47; i <= 48; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\ntissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\nexpressionStageGroupList.add(tissueExpressionStageGroup);\n\/*\n* Add treatment expressionStageGroup\n*\/\nExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\ntreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\ntreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\npublic ExpressionStageOptions generateExpressionStageOptions() {\nList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\nExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\nList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\n\nList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\nint idCounter = 0;\nfor (String expressionStageString : allExpressionStagesRaw) {\nExpressionStage expressionStage = new ExpressionStage();\nexpressionStage.setExpressionStageTitle(expressionStageString);\nexpressionStage.setExpressionStageId(\"stage\" + idCounter);\nexpressionStage.setExpressionStageNumericalId(idCounter);\nallExpressionStages.add(expressionStage);\nidCounter++;\n}\n\/\/ Add expressionStageList to returned object\nexpressionStageOptions.setExpressionStageList(allExpressionStages);\n\/*\n* Add embryogenesis expressionStageGroup\n*\/\nExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\nembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\nembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\nembryologyExpressionStageGroup.setGroupNumericalId(0);\nList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\nembryologyExpressionStageList.add(allExpressionStages.get(i));\n}\nembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\nexpressionStageGroupList.add(embryologyExpressionStageGroup);\n\/*\n* Add development expressionStageGroup\n*\/\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\nExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\ndevelopmentExpressionStageGroup.setGroupTitle(\"development\");\ndevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\ndevelopmentExpressionStageGroup.setGroupNumericalId(1);\nList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ Add embryo stages\nfor (int i = 56; i <= 67; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ larva stages\nfor (int i = 75; i <= 81; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\ndevelopmentExpressionStageList.add(allExpressionStages.get(97));\nfor (int i = 49; i <= 54; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 38; i <= 41; i++) {\ndevelopmentExpressionStageList.add(allExpressionStages.get(i));\n}\n\/\/ TODO: Add the others\ndevelopmentExpressionStageList.add(allExpressionStages.get(19));\ndevelopmentExpressionStageList.add(allExpressionStages.get(44));\ndevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\nexpressionStageGroupList.add(developmentExpressionStageGroup);\n\/*\n* Add tissue expressionStageGroup\n*\/\nExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\ntissueExpressionStageGroup.setGroupTitle(\"tissue\");\ntissueExpressionStageGroup.setGroupId(\"group\" + 2);\ntissueExpressionStageGroup.setGroupNumericalId(2);\nList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\/\/ A Mate stages\nfor (int i = 11; i <= 29; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 32; i <= 37; i++) {\ntissueExpressionStageList.add(allExpressionStages.get(i));\n}\nfor (int i = 42; i <= 43; i++) {","label":[1,1,0,0]}
{"id":7837,"original_code":"public Image LoadImageAnim(String fileName, int frames) {\n        Image image = new Image();\n        int framesCount = 1;\n        if (SUPPORT_FILEFORMAT_GIF) {\n            if (rCore.IsFileExtension(fileName, \".gif\")) {\n                byte[] fileData = null;\n                try{\n                    BufferedImage tmpImg = ImageIO.read(new File(fileName));\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    ImageIO.write(tmpImg, rCore.GetFileExtension(fileName).substring(1), os);\n                    fileData = os.toByteArray();\n                } catch (IOException exception) {\n                    exception.printStackTrace();\n                }\n                if (fileData != null) {\n                    try (MemoryStack stack = MemoryStack.stackPush()) {\n                        IntBuffer widthBuffer = stack.mallocInt(1);\n                        IntBuffer heightBuffer = stack.mallocInt(1);\n                        IntBuffer compBuffer = stack.mallocInt(1);\n                        PointerBuffer delaysBuffer = null;\n                        IntBuffer framesBuffer = stack.mallocInt(1);\n                        framesBuffer.put(framesCount).flip();\n                        ByteBuffer fileDataBuffer = MemoryUtil.memAlloc(fileData.length);\n                        fileDataBuffer.put(fileData).flip();\n                        ByteBuffer imgBuffer = STBImage.stbi_load_gif_from_memory(fileDataBuffer, delaysBuffer,\n                                                                                  widthBuffer, heightBuffer, framesBuffer, compBuffer, 4);\n                        image.width = widthBuffer.get();\n                        image.height = heightBuffer.get();\n                        image.mipmaps = 1;\n                        image.format = RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;\n                        if (imgBuffer != null) {\n                            byte[] bytes = new byte[imgBuffer.capacity()];\n                            for (int i = 0; i < bytes.length; i++) {\n                                bytes[i] = imgBuffer.get();\n                            }\n                            image.setData(bytes);\n                        }\n                        fileData = null;\n                    }\n                }\n            }\n        }\n        else{\n            image = LoadImage(fileName);\n        }\n        \/\/ TODO: Support APNG animated images?\n        frames = framesCount;\n        return image;\n    }","code":"public Image LoadImageAnim(String fileName, int frames) {\n        Image image = new Image();\n        int framesCount = 1;\n        if (SUPPORT_FILEFORMAT_GIF) {\n            if (rCore.IsFileExtension(fileName, \".gif\")) {\n                byte[] fileData = null;\n                try{\n                    BufferedImage tmpImg = ImageIO.read(new File(fileName));\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    ImageIO.write(tmpImg, rCore.GetFileExtension(fileName).substring(1), os);\n                    fileData = os.toByteArray();\n                } catch (IOException exception) {\n                    exception.printStackTrace();\n                }\n                if (fileData != null) {\n                    try (MemoryStack stack = MemoryStack.stackPush()) {\n                        IntBuffer widthBuffer = stack.mallocInt(1);\n                        IntBuffer heightBuffer = stack.mallocInt(1);\n                        IntBuffer compBuffer = stack.mallocInt(1);\n                        PointerBuffer delaysBuffer = null;\n                        IntBuffer framesBuffer = stack.mallocInt(1);\n                        framesBuffer.put(framesCount).flip();\n                        ByteBuffer fileDataBuffer = MemoryUtil.memAlloc(fileData.length);\n                        fileDataBuffer.put(fileData).flip();\n                        ByteBuffer imgBuffer = STBImage.stbi_load_gif_from_memory(fileDataBuffer, delaysBuffer,\n                                                                                  widthBuffer, heightBuffer, framesBuffer, compBuffer, 4);\n                        image.width = widthBuffer.get();\n                        image.height = heightBuffer.get();\n                        image.mipmaps = 1;\n                        image.format = RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;\n                        if (imgBuffer != null) {\n                            byte[] bytes = new byte[imgBuffer.capacity()];\n                            for (int i = 0; i < bytes.length; i++) {\n                                bytes[i] = imgBuffer.get();\n                            }\n                            image.setData(bytes);\n                        }\n                        fileData = null;\n                    }\n                }\n            }\n        }\n        else{\n            image = LoadImage(fileName);\n        }\n       \n        frames = framesCount;\n        return image;\n    }","cleancode":"public image loadimageanim(string filename, int frames) { image image = new image(); int framescount = 1; if (support_fileformat_gif) { if (rcore.isfileextension(filename, \".gif\")) { byte[] filedata = null; try{ bufferedimage tmpimg = imageio.read(new file(filename)); bytearrayoutputstream os = new bytearrayoutputstream(); imageio.write(tmpimg, rcore.getfileextension(filename).substring(1), os); filedata = os.tobytearray(); } catch (ioexception exception) { exception.printstacktrace(); } if (filedata != null) { try (memorystack stack = memorystack.stackpush()) { intbuffer widthbuffer = stack.mallocint(1); intbuffer heightbuffer = stack.mallocint(1); intbuffer compbuffer = stack.mallocint(1); pointerbuffer delaysbuffer = null; intbuffer framesbuffer = stack.mallocint(1); framesbuffer.put(framescount).flip(); bytebuffer filedatabuffer = memoryutil.memalloc(filedata.length); filedatabuffer.put(filedata).flip(); bytebuffer imgbuffer = stbimage.stbi_load_gif_from_memory(filedatabuffer, delaysbuffer, widthbuffer, heightbuffer, framesbuffer, compbuffer, 4); image.width = widthbuffer.get(); image.height = heightbuffer.get(); image.mipmaps = 1; image.format = rl_pixelformat_uncompressed_r8g8b8a8; if (imgbuffer != null) { byte[] bytes = new byte[imgbuffer.capacity()]; for (int i = 0; i < bytes.length; i++) { bytes[i] = imgbuffer.get(); } image.setdata(bytes); } filedata = null; } } } } else{ image = loadimage(filename); } frames = framescount; return image; }","comment":"\/\/ todo: support apng animated images?","repo":"CreedVI\/Raylib-J","code_context_2":"image = LoadImage(fileName);\n}\n\/\/ TODO: Support APNG animated images?\nframes = framesCount;\nreturn image;","code_context_10":"image.setData(bytes);\n}\nfileData = null;\n}\n}\n}\n}\nelse{\nimage = LoadImage(fileName);\n}\n\/\/ TODO: Support APNG animated images?\nframes = framesCount;\nreturn image;\n}","code_context_20":"widthBuffer, heightBuffer, framesBuffer, compBuffer, 4);\nimage.width = widthBuffer.get();\nimage.height = heightBuffer.get();\nimage.mipmaps = 1;\nimage.format = RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;\nif (imgBuffer != null) {\nbyte[] bytes = new byte[imgBuffer.capacity()];\nfor (int i = 0; i < bytes.length; i++) {\nbytes[i] = imgBuffer.get();\n}\nimage.setData(bytes);\n}\nfileData = null;\n}\n}\n}\n}\nelse{\nimage = LoadImage(fileName);\n}\n\/\/ TODO: Support APNG animated images?\nframes = framesCount;\nreturn image;\n}","label":[0,1,0,0]}
{"id":7893,"original_code":"public static GetEntityResponse<EventInfo> toEvent(\n          final IcalCallback cb,\n          final BwCalendar cal,\n          final Icalendar ical,\n          final Component val,\n          final boolean mergeAttendees) {\n    final var resp = new GetEntityResponse<EventInfo>();\n    if (val == null) {\n      return Response.notOk(resp, failed, \"No component supplied\");\n    }\n    String currentPrincipal = null;\n    final BwPrincipal principal = cb.getPrincipal();\n    if (principal != null) {\n      currentPrincipal = principal.getPrincipalRef();\n    }\n    final Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\n    final int methodType = ical.getMethodType();\n    String attUri = null;\n    if (mergeAttendees) {\n      \/\/ We'll need this later.\n      attUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n    }\n    final String colPath;\n    if (cal == null) {\n      colPath = null;\n    } else {\n      colPath = cal.getPath();\n    }\n    try {\n      final PropertyList<Property> pl = val.getProperties();\n      boolean vpoll = false;\n      boolean event = false;\n      boolean task = false;\n      if (pl == null) {\n        \/\/ Empty component\n        return Response.notOk(resp, failed, \"Empty component\");\n      }\n      final int entityType;\n      if (val instanceof VEvent) {\n        entityType = IcalDefs.entityTypeEvent;\n        event = true;\n      } else if (val instanceof VToDo) {\n        entityType = IcalDefs.entityTypeTodo;\n        task = true;\n      } else if (val instanceof VJournal) {\n        entityType = IcalDefs.entityTypeJournal;\n      } else if (val instanceof VFreeBusy) {\n        entityType = IcalDefs.entityTypeFreeAndBusy;\n      } else if (val instanceof VAvailability) {\n        entityType = IcalDefs.entityTypeVavailability;\n      } else if (val instanceof Available) {\n        entityType = IcalDefs.entityTypeAvailable;\n      } else if (val instanceof VPoll) {\n        entityType = IcalDefs.entityTypeVpoll;\n        vpoll = true;\n      } else {\n        return Response.error(resp, \"org.bedework.invalid.component.type: \" +\n                val.getName());\n      }\n      \/\/ Get the guid from the component\n      String guid = null;\n      final Uid uidp = pl.getProperty(Property.UID);\n      if (uidp != null) {\n        testXparams(uidp, hasXparams);\n        guid = uidp.getValue();\n      }\n      if (guid == null) {\n        \/* XXX A guid is required - but are there devices out there without a\n         *       guid - and if so how do we handle it?\n         *\/\n        return Response.notOk(resp, failed, CalFacadeException.noGuid);\n      }\n      \/* See if we have a recurrence id *\/\n      BwDateTime ridObj = null;\n      String rid = null;\n      TimeZone ridTz = null;\n      final RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\n      if (ridp != null) {\n        testXparams(ridp, hasXparams);\n        ridObj = BwDateTime.makeBwDateTime(ridp);\n        if (ridObj.getRange() != null) {\n          \/* XXX What do I do with it? *\/\n          logger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n        }\n        rid = ridObj.getDate();\n      }\n      EventInfo masterEI = null;\n      EventInfo evinfo = null;\n      final BwEvent ev;\n      \/* If we have a recurrence id see if we already have the master (we should\n       * get a master + all its overrides).\n       *\n       * If so find the override and use the annnotation or if no override,\n       * make one.\n       *\n       * If no override retrieve the event, add it to our table and then locate the\n       * annotation.\n       *\n       * If there is no annotation, create one.\n       *\n       * It's possible we have been sent 'detached' instances of a recurring\n       * event. This may happen if we are invited to one or more instances of a\n       * meeting. In this case we try to retrieve the master and if it doesn't\n       * exist we manufacture one. We consider such an instance an update to\n       * that instance only and leave the others alone.\n       *\/\n      \/* We need this in a couple of places *\/\n      final DtStart dtStart = pl.getProperty(Property.DTSTART);\n      \/*\n      if (rid != null) {\n        \/\/ See if we have a new master event. If so create a proxy to that event.\n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI == null) {\n          masterEI = makeNewEvent(cb, chg, entityType, guid, cal);\n          BwEvent e = masterEI.getEvent();\n          \/\/ XXX This seems bogus\n          DtStart mdtStart;\n          String bogusDate = \"19980118T230000\";\n          if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + \"Z\");\n          } else if (dtStart.getTimeZone() == null) {\n            mdtStart = new DtStart(bogusDate);\n          } else {\n            mdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n          }\n          setDates(e, mdtStart, null, null, chg);\n          e.setRecurring(true);\n          e.addRdate(ridObj);\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n        }\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n        }\n      }\n      *\/\n      \/* If this is a recurrence instance see if we can find the master\n         We only need this because the master may follow the overrides.\n       *\/\n      if (rid != null) {\n        \/\/ See if we have a new master event. If so create a proxy to this event.\n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n        }\n      }\n      if ((evinfo == null) &&\n          (cal != null) &&\n          (cal.getCalType() != BwCalendar.calTypeInbox) &&\n          (cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n          (cal.getCalType() != BwCalendar.calTypeOutbox)) {\n        if (logger.debug()) {\n          logger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n        }\n        final GetEntitiesResponse<EventInfo> eisResp =\n                cb.getEvent(colPath, guid);\n        if (eisResp.isError()) {\n          return Response.fromResponse(resp, eisResp);\n        }\n        final var eis = eisResp.getEntities();\n        if (!Util.isEmpty(eis)) {\n          if (eis.size() > 1) {\n            \/\/ DORECUR - wrong again\n            return Response.notOk(resp, failed,\n                                  \"More than one event returned for guid.\");\n          }\n          evinfo = eis.iterator().next();\n        }\n        if (logger.debug()) {\n          if (evinfo != null) {\n            logger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n          } else {\n            logger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n          }\n        }\n        if (evinfo != null) {\n          if (rid != null) {\n            \/\/ We just retrieved it's master\n            masterEI = evinfo;\n            masterEI.setInstanceOnly(true);\n            evinfo = masterEI.findOverride(rid);\n            evinfo.recurrenceSeen = true;\n            ical.addComponent(masterEI);\n          } else if (methodType == ScheduleMethods.methodTypeCancel) {\n            \/\/ This should never have an rid for cancel of entire event.\n            evinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n          } else {\n            \/\/ Presumably sent an update for the entire event. No longer suppressed master\n            evinfo.getEvent().setSuppressed(false);\n          }\n        } else if (rid != null) {\n          \/* Manufacture a master for the instance *\/\n          masterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n          final BwEvent e = masterEI.getEvent();\n          \/\/ XXX This seems bogus\n          final DtStart mdtStart;\n          final String bogusDate = \"19980118\";\n          final String bogusTime = \"T230000\";\n          \/\/ Base dtstart on the recurrence id.\n          final boolean isDateType = ridObj.getDateType();\n          if (isDateType) {\n            mdtStart = new DtStart(new Date(bogusDate));\n          } else if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n          } else if (ridObj.getTzid() == null) {\n            mdtStart = new DtStart(bogusDate + bogusTime);\n          } else {\n            mdtStart = new DtStart(bogusDate + bogusTime,\n                                   Timezones.getTz(ridObj.getTzid()));\n          }\n          IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                            masterEI, mdtStart, null, null);\n          e.setRecurring(true);\n\/\/          e.addRdate(ridObj);\n          final var sum = (Summary)pl.getProperty(Property.SUMMARY);\n          e.setSummary(sum.getValue());\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n          masterEI.setInstanceOnly(rid != null);\n        }\n      }\n      if (evinfo == null) {\n        evinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n      } else if (evinfo.getEvent().getEntityType() != entityType) {\n        return Response.notOk(resp, failed,\n                              \"org.bedework.mismatched.entity.type: \" +\n                                      val);\n      }\n      final ChangeTable chg = evinfo.getChangeset(\n              cb.getPrincipal().getPrincipalRef());\n      if (rid != null) {\n        final String evrid = evinfo.getEvent().getRecurrenceId();\n        if ((evrid == null) || (!evrid.equals(rid))) {\n          logger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\n          chg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n        }\n        if (masterEI.getEvent().getSuppressed()) {\n          masterEI.getEvent().addRdate(ridObj);\n        }\n      }\n      ev = evinfo.getEvent();\n      ev.setScheduleMethod(methodType);\n      DtEnd dtEnd = null;\n      if (entityType == IcalDefs.entityTypeTodo) {\n        final Due due = pl.getProperty(Property.DUE);\n        if (due != null ) {\n          dtEnd = new DtEnd(due.getParameters(), due.getValue());\n        }\n      } else {\n        dtEnd = pl.getProperty(Property.DTEND);\n      }\n      final Duration duration = pl.getProperty(Property.DURATION);\n      IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                        evinfo, dtStart, dtEnd, duration);\n      for (final Property prop: pl) {\n        testXparams(prop, hasXparams);\n        \/\/debug(\"ical prop \" + prop.getClass().getName());\n        String pval = prop.getValue();\n        if ((pval != null) && (pval.length() == 0)) {\n          pval = null;\n        }\n        final PropertyInfoIndex pi;\n        if (prop instanceof XProperty) {\n          pi = PropertyInfoIndex.XPROP;\n        } else {\n          pi = PropertyInfoIndex.fromName(prop.getName());\n        }\n        if (pi == null) {\n          logger.debug(\"Unknown property with name \" + prop.getName() +\n                                \" class \" + prop.getClass() +\n                                \" and value \" + pval);\n          continue;\n        }\n        chg.present(pi);\n        switch (pi) {\n          case ACCEPT_RESPONSE:\n            \/* ------------------- Accept Response -------------------- *\/\n            String sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\n              ev.setPollAcceptResponse(sval);\n            }\n            break;\n          case ATTACH:\n            \/* ------------------- Attachment -------------------- *\/\n            chg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\n            break;\n          case ATTENDEE:\n            \/* ------------------- Attendee -------------------- *\/\n            if (methodType == ScheduleMethods.methodTypePublish) {\n              if (cb.getStrictness() == IcalCallback.conformanceStrict) {\n                return Response.notOk(resp, failed,\n                                      CalFacadeException.attendeesInPublish);\n              }\n              \/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n              \/\/  warn(\"Had attendees for PUBLISH\");\n              \/\/}\n            }\n            final Attendee attPr = (Attendee)prop;\n            if (evinfo.getNewEvent() || !mergeAttendees) {\n              chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n            } else {\n              final String pUri = cb.getCaladdr(attPr.getValue());\n              if (pUri.equals(attUri)) {\n                \/* Only update for our own attendee\n                 * We're doing a PUT and this must be the attendee updating their\n                 * partstat. We don't allow them to change other attendees\n                 * whatever the PUT content says.\n                 *\/\n                chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n              } else {\n                \/\/ Use the value we currently have\n                boolean found = false;\n                for (final BwAttendee att: ev.getAttendees()) {\n                  if (pUri.equals(att.getAttendeeUri())) {\n                    chg.addValue(pi, att.clone());\n                    found = true;\n                    break;\n                  }\n                }\n                if (!found) {\n                  \/\/ An added attendee\n                  final BwAttendee att = IcalUtil\n                          .getAttendee(cb, attPr);\n                  att.setPartstat(IcalDefs.partstatValNeedsAction);\n                  chg.addValue(pi, att);\n                }\n              }\n            }\n            break;\n          case BUSYTYPE:\n            final int ibt = BwEvent.fromBusyTypeString(pval);\n            if (chg.changed(pi,\n                            ev.getBusyType(),\n                            ibt)) {\n              ev.setBusyType(ibt);\n            }\n            break;\n          case CATEGORIES:\n            \/* ------------------- Categories -------------------- *\/\n            final Categories cats = (Categories)prop;\n            final TextList cl = cats.getCategories();\n            String lang = IcalUtil.getLang(cats);\n            if (cl != null) {\n              \/* Got some categories *\/\n              for (final String wd: cl) {\n                if (wd == null) {\n                  continue;\n                }\n                final BwString key = new BwString(lang, wd);\n                final var fcResp = cb.findCategory(key);\n                final BwCategory cat;\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isNotFound()) {\n                  cat = BwCategory.makeCategory();\n                  cat.setWord(key);\n                  cb.addCategory(cat);\n                } else {\n                  cat = fcResp.getEntity();\n                }\n                chg.addValue(pi, cat);\n              }\n            }\n            break;\n          case CLASS:\n            \/* ------------------- Class -------------------- *\/\n            if (chg.changed(pi, ev.getClassification(), pval)) {\n              ev.setClassification(pval);\n            }\n            break;\n          case COMMENT:\n            \/* ------------------- Comment -------------------- *\/\n            chg.addValue(pi,\n                         new BwString(null, pval));\n            break;\n          case COMPLETED:\n            \/* ------------------- Completed -------------------- *\/\n            if (chg.changed(pi, ev.getCompleted(), pval)) {\n              ev.setCompleted(pval);\n            }\n            break;\n          case CONCEPT:\n            \/* ------------------- Concept -------------------- *\/\n            final Concept c = (Concept)prop;\n            final String cval = c.getValue();\n            if (cval != null) {\n              \/* Got a concept *\/\n              chg.addValue(PropertyInfoIndex.XPROP,\n                           BwXproperty.makeIcalProperty(\"CONCEPT\",\n                                                        null,\n                                                        cval));\n            }\n            break;\n          case CONTACT:\n            \/* ------------------- Contact -------------------- *\/\n            final String altrep = getAltRepPar(prop);\n            lang = IcalUtil.getLang(prop);\n            final String uid = getUidPar(prop);\n            final BwString nm = new BwString(lang, pval);\n            BwContact contact = null;\n            if (uid != null) {\n              final var fcResp = cb.getContact(uid);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              final var fcResp = cb.findContact(nm);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              contact = BwContact.makeContact();\n              contact.setCn(nm);\n              contact.setLink(altrep);\n              cb.addContact(contact);\n            } else {\n              contact.setCn(nm);\n              contact.setLink(altrep);\n            }\n            chg.addValue(pi, contact);\n            break;\n          case CREATED:\n            \/* ------------------- Created -------------------- *\/\n            if (chg.changed(pi, ev.getCreated(), pval)) {\n              ev.setCreated(pval);\n            }\n            break;\n          case DESCRIPTION:\n            \/* ------------------- Description -------------------- *\/\n            if (chg.changed(pi, ev.getDescription(), pval)) {\n              ev.setDescription(pval);\n            }\n            break;\n          case DTEND:\n            \/* ------------------- DtEnd -------------------- *\/\n            break;\n          case DTSTAMP:\n            \/* ------------------- DtStamp -------------------- *\/\n            ev.setDtstamp(pval);\n            break;\n          case DTSTART:\n            \/* ------------------- DtStart -------------------- *\/\n            break;\n          case DUE:\n            \/* -------------------- Due ------------------------ *\/\n            break;\n          case DURATION:\n            \/* ------------------- Duration -------------------- *\/\n            break;\n          case EXDATE:\n            \/* ------------------- ExDate -------------------- *\/\n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case EXRULE:\n            \/* ------------------- ExRule -------------------- *\/\n            chg.addValue(pi, pval);\n            break;\n          case FREEBUSY:\n            \/* ------------------- freebusy -------------------- *\/\n            final FreeBusy fbusy = (FreeBusy)prop;\n            final PeriodList perpl = fbusy.getPeriods();\n            final Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\n            final int fbtype;\n            if (par == null) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY)) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY_TENTATIVE)) {\n              fbtype = BwFreeBusyComponent.typeBusyTentative;\n            } else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\n              fbtype = BwFreeBusyComponent.typeBusyUnavailable;\n            } else if (par.equals(FbType.FREE)) {\n              fbtype = BwFreeBusyComponent.typeFree;\n            } else {\n              if (logger.debug()) {\n                logger.debug(\"Unsupported parameter \" + par.getName());\n              }\n              return Response.notOk(resp, failed,\n                                    \"Unsupported parameter \" +\n                                            par.getName());\n            }\n            final BwFreeBusyComponent fbc = new BwFreeBusyComponent();\n            fbc.setType(fbtype);\n            for (final Period per : perpl) {\n              fbc.addPeriod(per);\n            }\n            ev.addFreeBusyPeriod(fbc);\n            break;\n          case GEO:\n            \/* ------------------- Geo -------------------- *\/\n            final Geo g = (Geo)prop;\n            final BwGeo geo = new BwGeo(g.getLatitude(),\n                                        g.getLongitude());\n            if (chg.changed(pi, ev.getGeo(), geo)) {\n              ev.setGeo(geo);\n            }\n            break;\n          case LAST_MODIFIED:\n            \/* ------------------- LastModified -------------------- *\/\n            if (chg.changed(pi, ev.getLastmod(), pval)) {\n              ev.setLastmod(pval);\n            }\n            break;\n          case LOCATION:\n            \/* ------------------- Location -------------------- *\/\n            BwLocation loc = null;\n            \/\/String uid = getUidPar(prop);\n            \/* At the moment Mozilla lightning is broken and this leads to all\n           * sorts of problems.\n            if (uid != null) {\n              loc = cb.getLocation(uid);\n            }\n           *\/\n            lang = IcalUtil.getLang(prop);\n            BwString addr = null;\n            if (pval != null) {\n              if (loc == null) {\n                addr = new BwString(lang, pval);\n                final var fcResp = cb.findLocation(addr);\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isOk()) {\n                  loc = fcResp.getEntity();\n                }\n              }\n              if (loc == null) {\n                loc = BwLocation.makeLocation();\n                loc.setAddress(addr);\n                cb.addLocation(loc);\n              }\n            }\n            final BwLocation evloc = ev.getLocation();\n            if (chg.changed(pi, evloc, loc)) {\n              \/\/ CHGTBL - this only shows that it's a different location object\n              ev.setLocation(loc);\n            } else if ((loc != null) && (evloc != null)) {\n              \/\/ See if the value is changed\n              final String evval = evloc.getAddress().getValue();\n              final String inval = loc.getAddress().getValue();\n              if (!evval.equals(inval)) {\n                chg.changed(pi, evval, inval);\n                evloc.getAddress().setValue(inval);\n              }\n            }\n            break;\n          case ORGANIZER:\n            \/* ------------------- Organizer -------------------- *\/\n            final BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\n            final BwOrganizer evorg = ev.getOrganizer();\n            final BwOrganizer evorgCopy;\n            if (evorg == null) {\n              evorgCopy = null;\n            } else {\n              evorgCopy = (BwOrganizer)evorg.clone();\n            }\n            if (chg.changed(pi, evorgCopy, org)) {\n              if (evorg == null) {\n                ev.setOrganizer(org);\n              } else {\n                evorg.update(org);\n              }\n            }\n            break;\n          case PERCENT_COMPLETE:\n            \/* ------------------- PercentComplete -------------------- *\/\n            Integer ival = ((PercentComplete)prop).getPercentage();\n            if (chg.changed(pi, ev.getPercentComplete(), ival)) {\n              ev.setPercentComplete(ival);\n            }\n            break;\n          case POLL_MODE:\n            \/* ------------------- Poll mode -------------------- *\/\n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollMode(), sval)) {\n              ev.setPollMode(sval);\n            }\n            break;\n          case POLL_PROPERTIES:\n            \/* ------------------- Poll properties ---------------- *\/\n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollProperties(), sval)) {\n              ev.setPollProperties(sval);\n            }\n            break;\n          case POLL_WINNER:\n            \/* ------------------- Poll winner -------------------- *\/\n            ival = ((PollWinner)prop).getPollwinner();\n            if (chg.changed(pi, ev.getPollWinner(), ival)) {\n              ev.setPollWinner(ival);\n            }\n            break;\n          case PRIORITY:\n            \/* ------------------- Priority -------------------- *\/\n            ival = ((Priority)prop).getLevel();\n            if (chg.changed(pi, ev.getPriority(), ival)) {\n              ev.setPriority(ival);\n            }\n            break;\n          case RDATE:\n            \/* ------------------- RDate -------------------- *\/\n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case RECURRENCE_ID:\n            \/* ------------------- RecurrenceID -------------------- *\/\n            \/\/ Done above\n            break;\n          case RELATED_TO:\n            \/* ------------------- RelatedTo -------------------- *\/\n            final RelatedTo irelto = (RelatedTo)prop;\n            final BwRelatedTo relto = new BwRelatedTo();\n            final String parval = IcalUtil.getParameterVal(irelto,\n                                                           \"RELTYPE\");\n            if (parval != null) {\n              relto.setRelType(parval);\n            }\n            relto.setValue(irelto.getValue());\n            if (chg.changed(pi, ev.getRelatedTo(), relto)) {\n              ev.setRelatedTo(relto);\n            }\n            break;\n          case REQUEST_STATUS:\n            \/* ------------------- RequestStatus -------------------- *\/\n            final BwRequestStatus rs = BwRequestStatus\n                    .fromRequestStatus((RequestStatus)prop);\n            chg.addValue(pi, rs);\n            break;\n          case RESOURCES:\n            \/* ------------------- Resources -------------------- *\/\n            final TextList rl = ((Resources)prop).getResources();\n            if (rl != null) {\n              \/* Got some resources *\/\n              lang = IcalUtil.getLang(prop);\n              for (final String s: rl) {\n                final BwString rsrc = new BwString(lang,\n                                                   s);\n                chg.addValue(pi, rsrc);\n              }\n            }\n            break;\n          case RRULE:\n            \/* ------------------- RRule -------------------- *\/\n            chg.addValue(pi, pval);\n            break;\n          case SEQUENCE:\n            \/* ------------------- Sequence -------------------- *\/\n            final int seq = ((Sequence)prop).getSequenceNo();\n            if (seq != ev.getSequence()) {\n              chg.changed(pi, ev.getSequence(), seq);\n              ev.setSequence(seq);\n            }\n            break;\n          case STATUS:\n            \/* ------------------- Status -------------------- *\/\n            if (chg.changed(pi, ev.getStatus(), pval)) {\n              ev.setStatus(pval);\n            }\n            break;\n          case SUMMARY:\n            \/* ------------------- Summary -------------------- *\/\n            if (chg.changed(pi, ev.getSummary(), pval)) {\n              ev.setSummary(pval);\n            }\n            break;\n          case TRANSP:\n            \/* ------------------- Transp -------------------- *\/\n            if (chg.changed(pi,\n                            ev.getPeruserTransparency(\n                                    cb.getPrincipal()\n                                            .getPrincipalRef()),\n                            pval)) {\n              final BwXproperty pu = ev.setPeruserTransparency(\n                      cb.getPrincipal().getPrincipalRef(),\n                      pval);\n              if (pu != null) {\n                chg.addValue(PropertyInfoIndex.XPROP, pu);\n              }\n            }\n            break;\n          case UID:\n            \/* ------------------- Uid -------------------- *\/\n            \/* We did this above *\/\n            break;\n          case URL:\n            \/* ------------------- Url -------------------- *\/\n            if (chg.changed(pi, ev.getLink(), pval)) {\n              ev.setLink(pval);\n            }\n            break;\n          case XPROP:\n            \/* ------------------------- x-property --------------------------- *\/\n            final String name = prop.getName();\n            if (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\n              if (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\n                              pval)) {\n                ev.setCost(pval);\n              }\n              break;\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\n              if (checkCategory(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\n              if (checkLocation(cb, chg, ev, prop)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\n              if (checkContact(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            \/* See if this is an x-category that can be\n               converted to a real category\n              *\/\n            final XProperty xp = (XProperty)prop;\n            chg.addValue(PropertyInfoIndex.XPROP,\n                         new BwXproperty(name,\n                                         xp.getParameters()\n                                                 .toString(),\n                                         pval));\n            break;\n          default:\n            if (logger.debug()) {\n              logger.debug(\"Unsupported property with index \" + pi +\n                                    \"; class \" + prop.getClass() +\n                                    \" and value \" + pval);\n            }\n        }\n      }\n      \/* =================== Process sub-components =============== *\/\n      final ComponentList<Component> subComps;\n      if (val instanceof ComponentContainer) {\n        subComps = ((ComponentContainer<Component>)val).getComponents();\n      } else {\n        subComps = null;\n      }\n      final Set<Integer> pids;\n      if (vpoll) {\n        pids = new TreeSet<>();\n        final BwEvent vp = evinfo.getEvent();\n        if (!Util.isEmpty(vp.getPollItems())) {\n          vp.clearPollItems();\n        }\n      } else {\n        pids = null;\n      }\n      if (!Util.isEmpty(subComps)) {\n        for (final var subComp: subComps) {\n          if (subComp instanceof Available) {\n            if (!(val instanceof VAvailability)) {\n              return Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n            }\n            final var avlResp = processAvailable(cb, cal,\n                                                 ical,\n                                                 (VAvailability)val,\n                                                 (Available)subComp,\n                                                 evinfo);\n            if (!avlResp.isOk()) {\n              return Response.fromResponse(resp, avlResp);\n            }\n            continue;\n          }\n          if (subComp instanceof Participant) {\n            if (vpoll) {\n              final var vresp = processVoter(cb,\n                                             (VPoll)val,\n                                             (Participant)subComp,\n                                             evinfo,\n                                             chg,\n                                             mergeAttendees);\n              if (!vresp.isOk()) {\n                return Response.fromResponse(resp, vresp);\n              }\n              continue;\n            }\n            logger.warn(\"Unimplemented Participant object\");\n            continue;\n          }\n          if (subComp instanceof VResource) {\n            logger.warn(\"Unimplemented VResource object\");\n            continue;\n          }\n          if (subComp instanceof VLocation) {\n            logger.warn(\"Unimplemented VLocation object\");\n            continue;\n          }\n          if (subComp instanceof VAlarm) {\n            final var aresp = VAlarmUtil.processAlarm(cb,\n                                                      val,\n                                                      (VAlarm)subComp,\n                                                      ev,\n                                                      currentPrincipal,\n                                                      chg);\n            if (!aresp.isOk()) {\n              return Response.fromResponse(resp, aresp);\n            }\n            continue;\n          }\n          if (vpoll && (event || task)) {\n            final var vresp = processCandidate((VPoll)val,\n                                               subComp,\n                                               evinfo,\n                                               pids,\n                                               chg);\n            if (!vresp.isOk()) {\n              return Response.fromResponse(resp, vresp);\n            }\n            continue;\n          }\n          logger.warn(\"Unimplemented Component object: \" + subComp);\n        }\n      }\n      \/* Fix up timestamps. *\/\n      if (ev.getCreated() == null) {\n        if (ev.getLastmod() != null) {\n          ev.setCreated(ev.getLastmod());\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n        } else {\n          ev.updateDtstamp();\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n          chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n        }\n      }\n      if (ev.getLastmod() == null) {\n        \/\/ created cannot be null now\n        ev.setLastmod(ev.getCreated());\n        chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n      }\n      processTimezones(ev, ical, chg);\n      \/* Remove any recipients and originator\n       *\/\n      if (ev.getRecipients() != null) {\n        ev.getRecipients().clear();\n      }\n      ev.setOriginator(null);\n      if (hasXparams.value) {\n        \/* Save a text copy of the entire event as an x-property *\/\n        final Component valCopy = val.copy();\n        \/* Remove potentially large values *\/\n        final Description desp = valCopy.getProperty(Property.DESCRIPTION);\n        if (desp != null) {\n          desp.setValue(null);\n        }\n        final Attach attachp = valCopy.getProperty(Property.ATTACH);\n        \/\/ Don't store the entire attachment - we just need the parameters.\n        if (attachp != null) {\n          final Value v = attachp.getParameter(Parameter.VALUE);\n          if (v != null) {\n            attachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n          }\n        }\n        chg.addValue(PropertyInfoIndex.XPROP,\n                     new BwXproperty(BwXproperty.bedeworkIcal,\n                                     null,\n                                     valCopy.toString()));\n      }\n      chg.processChanges(ev, true, false);\n      ev.setRecurring(ev.isRecurringEntity());\n      if (logger.debug()) {\n        logger.debug(chg.toString());\n        logger.debug(ev.toString());\n      }\n      if (masterEI != null) {\n        \/\/ Just return notfound as this event is on its override list\n        return Response.notFound(resp);\n      }\n      resp.setEntity(evinfo);\n      return resp;\n    } catch (final Throwable t) {\n      if (logger.debug()) {\n        logger.error(t);\n      }\n      return Response.error(resp, t);\n    }\n  }","code":"public static GetEntityResponse<EventInfo> toEvent(\n          final IcalCallback cb,\n          final BwCalendar cal,\n          final Icalendar ical,\n          final Component val,\n          final boolean mergeAttendees) {\n    final var resp = new GetEntityResponse<EventInfo>();\n    if (val == null) {\n      return Response.notOk(resp, failed, \"No component supplied\");\n    }\n    String currentPrincipal = null;\n    final BwPrincipal principal = cb.getPrincipal();\n    if (principal != null) {\n      currentPrincipal = principal.getPrincipalRef();\n    }\n    final Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\n    final int methodType = ical.getMethodType();\n    String attUri = null;\n    if (mergeAttendees) {\n     \n      attUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n    }\n    final String colPath;\n    if (cal == null) {\n      colPath = null;\n    } else {\n      colPath = cal.getPath();\n    }\n    try {\n      final PropertyList<Property> pl = val.getProperties();\n      boolean vpoll = false;\n      boolean event = false;\n      boolean task = false;\n      if (pl == null) {\n       \n        return Response.notOk(resp, failed, \"Empty component\");\n      }\n      final int entityType;\n      if (val instanceof VEvent) {\n        entityType = IcalDefs.entityTypeEvent;\n        event = true;\n      } else if (val instanceof VToDo) {\n        entityType = IcalDefs.entityTypeTodo;\n        task = true;\n      } else if (val instanceof VJournal) {\n        entityType = IcalDefs.entityTypeJournal;\n      } else if (val instanceof VFreeBusy) {\n        entityType = IcalDefs.entityTypeFreeAndBusy;\n      } else if (val instanceof VAvailability) {\n        entityType = IcalDefs.entityTypeVavailability;\n      } else if (val instanceof Available) {\n        entityType = IcalDefs.entityTypeAvailable;\n      } else if (val instanceof VPoll) {\n        entityType = IcalDefs.entityTypeVpoll;\n        vpoll = true;\n      } else {\n        return Response.error(resp, \"org.bedework.invalid.component.type: \" +\n                val.getName());\n      }\n     \n      String guid = null;\n      final Uid uidp = pl.getProperty(Property.UID);\n      if (uidp != null) {\n        testXparams(uidp, hasXparams);\n        guid = uidp.getValue();\n      }\n      if (guid == null) {\n       \n        return Response.notOk(resp, failed, CalFacadeException.noGuid);\n      }\n     \n      BwDateTime ridObj = null;\n      String rid = null;\n      TimeZone ridTz = null;\n      final RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\n      if (ridp != null) {\n        testXparams(ridp, hasXparams);\n        ridObj = BwDateTime.makeBwDateTime(ridp);\n        if (ridObj.getRange() != null) {\n         \n          logger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n        }\n        rid = ridObj.getDate();\n      }\n      EventInfo masterEI = null;\n      EventInfo evinfo = null;\n      final BwEvent ev;\n     \n     \n      final DtStart dtStart = pl.getProperty(Property.DTSTART);\n     \n     \n      if (rid != null) {\n       \n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n        }\n      }\n      if ((evinfo == null) &&\n          (cal != null) &&\n          (cal.getCalType() != BwCalendar.calTypeInbox) &&\n          (cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n          (cal.getCalType() != BwCalendar.calTypeOutbox)) {\n        if (logger.debug()) {\n          logger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n        }\n        final GetEntitiesResponse<EventInfo> eisResp =\n                cb.getEvent(colPath, guid);\n        if (eisResp.isError()) {\n          return Response.fromResponse(resp, eisResp);\n        }\n        final var eis = eisResp.getEntities();\n        if (!Util.isEmpty(eis)) {\n          if (eis.size() > 1) {\n           \n            return Response.notOk(resp, failed,\n                                  \"More than one event returned for guid.\");\n          }\n          evinfo = eis.iterator().next();\n        }\n        if (logger.debug()) {\n          if (evinfo != null) {\n            logger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n          } else {\n            logger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n          }\n        }\n        if (evinfo != null) {\n          if (rid != null) {\n           \n            masterEI = evinfo;\n            masterEI.setInstanceOnly(true);\n            evinfo = masterEI.findOverride(rid);\n            evinfo.recurrenceSeen = true;\n            ical.addComponent(masterEI);\n          } else if (methodType == ScheduleMethods.methodTypeCancel) {\n           \n            evinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n          } else {\n           \n            evinfo.getEvent().setSuppressed(false);\n          }\n        } else if (rid != null) {\n         \n          masterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n          final BwEvent e = masterEI.getEvent();\n         \n          final DtStart mdtStart;\n          final String bogusDate = \"19980118\";\n          final String bogusTime = \"T230000\";\n         \n          final boolean isDateType = ridObj.getDateType();\n          if (isDateType) {\n            mdtStart = new DtStart(new Date(bogusDate));\n          } else if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n          } else if (ridObj.getTzid() == null) {\n            mdtStart = new DtStart(bogusDate + bogusTime);\n          } else {\n            mdtStart = new DtStart(bogusDate + bogusTime,\n                                   Timezones.getTz(ridObj.getTzid()));\n          }\n          IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                            masterEI, mdtStart, null, null);\n          e.setRecurring(true);\n          final var sum = (Summary)pl.getProperty(Property.SUMMARY);\n          e.setSummary(sum.getValue());\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n          masterEI.setInstanceOnly(rid != null);\n        }\n      }\n      if (evinfo == null) {\n        evinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n      } else if (evinfo.getEvent().getEntityType() != entityType) {\n        return Response.notOk(resp, failed,\n                              \"org.bedework.mismatched.entity.type: \" +\n                                      val);\n      }\n      final ChangeTable chg = evinfo.getChangeset(\n              cb.getPrincipal().getPrincipalRef());\n      if (rid != null) {\n        final String evrid = evinfo.getEvent().getRecurrenceId();\n        if ((evrid == null) || (!evrid.equals(rid))) {\n          logger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\n          chg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid);\n        }\n        if (masterEI.getEvent().getSuppressed()) {\n          masterEI.getEvent().addRdate(ridObj);\n        }\n      }\n      ev = evinfo.getEvent();\n      ev.setScheduleMethod(methodType);\n      DtEnd dtEnd = null;\n      if (entityType == IcalDefs.entityTypeTodo) {\n        final Due due = pl.getProperty(Property.DUE);\n        if (due != null ) {\n          dtEnd = new DtEnd(due.getParameters(), due.getValue());\n        }\n      } else {\n        dtEnd = pl.getProperty(Property.DTEND);\n      }\n      final Duration duration = pl.getProperty(Property.DURATION);\n      IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                        evinfo, dtStart, dtEnd, duration);\n      for (final Property prop: pl) {\n        testXparams(prop, hasXparams);\n       \n        String pval = prop.getValue();\n        if ((pval != null) && (pval.length() == 0)) {\n          pval = null;\n        }\n        final PropertyInfoIndex pi;\n        if (prop instanceof XProperty) {\n          pi = PropertyInfoIndex.XPROP;\n        } else {\n          pi = PropertyInfoIndex.fromName(prop.getName());\n        }\n        if (pi == null) {\n          logger.debug(\"Unknown property with name \" + prop.getName() +\n                                \" class \" + prop.getClass() +\n                                \" and value \" + pval);\n          continue;\n        }\n        chg.present(pi);\n        switch (pi) {\n          case ACCEPT_RESPONSE:\n           \n            String sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\n              ev.setPollAcceptResponse(sval);\n            }\n            break;\n          case ATTACH:\n           \n            chg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\n            break;\n          case ATTENDEE:\n           \n            if (methodType == ScheduleMethods.methodTypePublish) {\n              if (cb.getStrictness() == IcalCallback.conformanceStrict) {\n                return Response.notOk(resp, failed,\n                                      CalFacadeException.attendeesInPublish);\n              }\n             \n             \n             \n            }\n            final Attendee attPr = (Attendee)prop;\n            if (evinfo.getNewEvent() || !mergeAttendees) {\n              chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n            } else {\n              final String pUri = cb.getCaladdr(attPr.getValue());\n              if (pUri.equals(attUri)) {\n               \n                chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n              } else {\n               \n                boolean found = false;\n                for (final BwAttendee att: ev.getAttendees()) {\n                  if (pUri.equals(att.getAttendeeUri())) {\n                    chg.addValue(pi, att.clone());\n                    found = true;\n                    break;\n                  }\n                }\n                if (!found) {\n                 \n                  final BwAttendee att = IcalUtil\n                          .getAttendee(cb, attPr);\n                  att.setPartstat(IcalDefs.partstatValNeedsAction);\n                  chg.addValue(pi, att);\n                }\n              }\n            }\n            break;\n          case BUSYTYPE:\n            final int ibt = BwEvent.fromBusyTypeString(pval);\n            if (chg.changed(pi,\n                            ev.getBusyType(),\n                            ibt)) {\n              ev.setBusyType(ibt);\n            }\n            break;\n          case CATEGORIES:\n           \n            final Categories cats = (Categories)prop;\n            final TextList cl = cats.getCategories();\n            String lang = IcalUtil.getLang(cats);\n            if (cl != null) {\n             \n              for (final String wd: cl) {\n                if (wd == null) {\n                  continue;\n                }\n                final BwString key = new BwString(lang, wd);\n                final var fcResp = cb.findCategory(key);\n                final BwCategory cat;\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isNotFound()) {\n                  cat = BwCategory.makeCategory();\n                  cat.setWord(key);\n                  cb.addCategory(cat);\n                } else {\n                  cat = fcResp.getEntity();\n                }\n                chg.addValue(pi, cat);\n              }\n            }\n            break;\n          case CLASS:\n           \n            if (chg.changed(pi, ev.getClassification(), pval)) {\n              ev.setClassification(pval);\n            }\n            break;\n          case COMMENT:\n           \n            chg.addValue(pi,\n                         new BwString(null, pval));\n            break;\n          case COMPLETED:\n           \n            if (chg.changed(pi, ev.getCompleted(), pval)) {\n              ev.setCompleted(pval);\n            }\n            break;\n          case CONCEPT:\n           \n            final Concept c = (Concept)prop;\n            final String cval = c.getValue();\n            if (cval != null) {\n             \n              chg.addValue(PropertyInfoIndex.XPROP,\n                           BwXproperty.makeIcalProperty(\"CONCEPT\",\n                                                        null,\n                                                        cval));\n            }\n            break;\n          case CONTACT:\n           \n            final String altrep = getAltRepPar(prop);\n            lang = IcalUtil.getLang(prop);\n            final String uid = getUidPar(prop);\n            final BwString nm = new BwString(lang, pval);\n            BwContact contact = null;\n            if (uid != null) {\n              final var fcResp = cb.getContact(uid);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              final var fcResp = cb.findContact(nm);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              contact = BwContact.makeContact();\n              contact.setCn(nm);\n              contact.setLink(altrep);\n              cb.addContact(contact);\n            } else {\n              contact.setCn(nm);\n              contact.setLink(altrep);\n            }\n            chg.addValue(pi, contact);\n            break;\n          case CREATED:\n           \n            if (chg.changed(pi, ev.getCreated(), pval)) {\n              ev.setCreated(pval);\n            }\n            break;\n          case DESCRIPTION:\n           \n            if (chg.changed(pi, ev.getDescription(), pval)) {\n              ev.setDescription(pval);\n            }\n            break;\n          case DTEND:\n           \n            break;\n          case DTSTAMP:\n           \n            ev.setDtstamp(pval);\n            break;\n          case DTSTART:\n           \n            break;\n          case DUE:\n           \n            break;\n          case DURATION:\n           \n            break;\n          case EXDATE:\n           \n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case EXRULE:\n           \n            chg.addValue(pi, pval);\n            break;\n          case FREEBUSY:\n           \n            final FreeBusy fbusy = (FreeBusy)prop;\n            final PeriodList perpl = fbusy.getPeriods();\n            final Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\n            final int fbtype;\n            if (par == null) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY)) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY_TENTATIVE)) {\n              fbtype = BwFreeBusyComponent.typeBusyTentative;\n            } else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\n              fbtype = BwFreeBusyComponent.typeBusyUnavailable;\n            } else if (par.equals(FbType.FREE)) {\n              fbtype = BwFreeBusyComponent.typeFree;\n            } else {\n              if (logger.debug()) {\n                logger.debug(\"Unsupported parameter \" + par.getName());\n              }\n              return Response.notOk(resp, failed,\n                                    \"Unsupported parameter \" +\n                                            par.getName());\n            }\n            final BwFreeBusyComponent fbc = new BwFreeBusyComponent();\n            fbc.setType(fbtype);\n            for (final Period per : perpl) {\n              fbc.addPeriod(per);\n            }\n            ev.addFreeBusyPeriod(fbc);\n            break;\n          case GEO:\n           \n            final Geo g = (Geo)prop;\n            final BwGeo geo = new BwGeo(g.getLatitude(),\n                                        g.getLongitude());\n            if (chg.changed(pi, ev.getGeo(), geo)) {\n              ev.setGeo(geo);\n            }\n            break;\n          case LAST_MODIFIED:\n           \n            if (chg.changed(pi, ev.getLastmod(), pval)) {\n              ev.setLastmod(pval);\n            }\n            break;\n          case LOCATION:\n           \n            BwLocation loc = null;\n           \n           \n            lang = IcalUtil.getLang(prop);\n            BwString addr = null;\n            if (pval != null) {\n              if (loc == null) {\n                addr = new BwString(lang, pval);\n                final var fcResp = cb.findLocation(addr);\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isOk()) {\n                  loc = fcResp.getEntity();\n                }\n              }\n              if (loc == null) {\n                loc = BwLocation.makeLocation();\n                loc.setAddress(addr);\n                cb.addLocation(loc);\n              }\n            }\n            final BwLocation evloc = ev.getLocation();\n            if (chg.changed(pi, evloc, loc)) {\n             \n              ev.setLocation(loc);\n            } else if ((loc != null) && (evloc != null)) {\n             \n              final String evval = evloc.getAddress().getValue();\n              final String inval = loc.getAddress().getValue();\n              if (!evval.equals(inval)) {\n                chg.changed(pi, evval, inval);\n                evloc.getAddress().setValue(inval);\n              }\n            }\n            break;\n          case ORGANIZER:\n           \n            final BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\n            final BwOrganizer evorg = ev.getOrganizer();\n            final BwOrganizer evorgCopy;\n            if (evorg == null) {\n              evorgCopy = null;\n            } else {\n              evorgCopy = (BwOrganizer)evorg.clone();\n            }\n            if (chg.changed(pi, evorgCopy, org)) {\n              if (evorg == null) {\n                ev.setOrganizer(org);\n              } else {\n                evorg.update(org);\n              }\n            }\n            break;\n          case PERCENT_COMPLETE:\n           \n            Integer ival = ((PercentComplete)prop).getPercentage();\n            if (chg.changed(pi, ev.getPercentComplete(), ival)) {\n              ev.setPercentComplete(ival);\n            }\n            break;\n          case POLL_MODE:\n           \n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollMode(), sval)) {\n              ev.setPollMode(sval);\n            }\n            break;\n          case POLL_PROPERTIES:\n           \n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollProperties(), sval)) {\n              ev.setPollProperties(sval);\n            }\n            break;\n          case POLL_WINNER:\n           \n            ival = ((PollWinner)prop).getPollwinner();\n            if (chg.changed(pi, ev.getPollWinner(), ival)) {\n              ev.setPollWinner(ival);\n            }\n            break;\n          case PRIORITY:\n           \n            ival = ((Priority)prop).getLevel();\n            if (chg.changed(pi, ev.getPriority(), ival)) {\n              ev.setPriority(ival);\n            }\n            break;\n          case RDATE:\n           \n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case RECURRENCE_ID:\n           \n           \n            break;\n          case RELATED_TO:\n           \n            final RelatedTo irelto = (RelatedTo)prop;\n            final BwRelatedTo relto = new BwRelatedTo();\n            final String parval = IcalUtil.getParameterVal(irelto,\n                                                           \"RELTYPE\");\n            if (parval != null) {\n              relto.setRelType(parval);\n            }\n            relto.setValue(irelto.getValue());\n            if (chg.changed(pi, ev.getRelatedTo(), relto)) {\n              ev.setRelatedTo(relto);\n            }\n            break;\n          case REQUEST_STATUS:\n           \n            final BwRequestStatus rs = BwRequestStatus\n                    .fromRequestStatus((RequestStatus)prop);\n            chg.addValue(pi, rs);\n            break;\n          case RESOURCES:\n           \n            final TextList rl = ((Resources)prop).getResources();\n            if (rl != null) {\n             \n              lang = IcalUtil.getLang(prop);\n              for (final String s: rl) {\n                final BwString rsrc = new BwString(lang,\n                                                   s);\n                chg.addValue(pi, rsrc);\n              }\n            }\n            break;\n          case RRULE:\n           \n            chg.addValue(pi, pval);\n            break;\n          case SEQUENCE:\n           \n            final int seq = ((Sequence)prop).getSequenceNo();\n            if (seq != ev.getSequence()) {\n              chg.changed(pi, ev.getSequence(), seq);\n              ev.setSequence(seq);\n            }\n            break;\n          case STATUS:\n           \n            if (chg.changed(pi, ev.getStatus(), pval)) {\n              ev.setStatus(pval);\n            }\n            break;\n          case SUMMARY:\n           \n            if (chg.changed(pi, ev.getSummary(), pval)) {\n              ev.setSummary(pval);\n            }\n            break;\n          case TRANSP:\n           \n            if (chg.changed(pi,\n                            ev.getPeruserTransparency(\n                                    cb.getPrincipal()\n                                            .getPrincipalRef()),\n                            pval)) {\n              final BwXproperty pu = ev.setPeruserTransparency(\n                      cb.getPrincipal().getPrincipalRef(),\n                      pval);\n              if (pu != null) {\n                chg.addValue(PropertyInfoIndex.XPROP, pu);\n              }\n            }\n            break;\n          case UID:\n           \n           \n            break;\n          case URL:\n           \n            if (chg.changed(pi, ev.getLink(), pval)) {\n              ev.setLink(pval);\n            }\n            break;\n          case XPROP:\n           \n            final String name = prop.getName();\n            if (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\n              if (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\n                              pval)) {\n                ev.setCost(pval);\n              }\n              break;\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\n              if (checkCategory(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\n              if (checkLocation(cb, chg, ev, prop)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\n              if (checkContact(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n           \n            final XProperty xp = (XProperty)prop;\n            chg.addValue(PropertyInfoIndex.XPROP,\n                         new BwXproperty(name,\n                                         xp.getParameters()\n                                                 .toString(),\n                                         pval));\n            break;\n          default:\n            if (logger.debug()) {\n              logger.debug(\"Unsupported property with index \" + pi +\n                                    \"; class \" + prop.getClass() +\n                                    \" and value \" + pval);\n            }\n        }\n      }\n     \n      final ComponentList<Component> subComps;\n      if (val instanceof ComponentContainer) {\n        subComps = ((ComponentContainer<Component>)val).getComponents();\n      } else {\n        subComps = null;\n      }\n      final Set<Integer> pids;\n      if (vpoll) {\n        pids = new TreeSet<>();\n        final BwEvent vp = evinfo.getEvent();\n        if (!Util.isEmpty(vp.getPollItems())) {\n          vp.clearPollItems();\n        }\n      } else {\n        pids = null;\n      }\n      if (!Util.isEmpty(subComps)) {\n        for (final var subComp: subComps) {\n          if (subComp instanceof Available) {\n            if (!(val instanceof VAvailability)) {\n              return Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n            }\n            final var avlResp = processAvailable(cb, cal,\n                                                 ical,\n                                                 (VAvailability)val,\n                                                 (Available)subComp,\n                                                 evinfo);\n            if (!avlResp.isOk()) {\n              return Response.fromResponse(resp, avlResp);\n            }\n            continue;\n          }\n          if (subComp instanceof Participant) {\n            if (vpoll) {\n              final var vresp = processVoter(cb,\n                                             (VPoll)val,\n                                             (Participant)subComp,\n                                             evinfo,\n                                             chg,\n                                             mergeAttendees);\n              if (!vresp.isOk()) {\n                return Response.fromResponse(resp, vresp);\n              }\n              continue;\n            }\n            logger.warn(\"Unimplemented Participant object\");\n            continue;\n          }\n          if (subComp instanceof VResource) {\n            logger.warn(\"Unimplemented VResource object\");\n            continue;\n          }\n          if (subComp instanceof VLocation) {\n            logger.warn(\"Unimplemented VLocation object\");\n            continue;\n          }\n          if (subComp instanceof VAlarm) {\n            final var aresp = VAlarmUtil.processAlarm(cb,\n                                                      val,\n                                                      (VAlarm)subComp,\n                                                      ev,\n                                                      currentPrincipal,\n                                                      chg);\n            if (!aresp.isOk()) {\n              return Response.fromResponse(resp, aresp);\n            }\n            continue;\n          }\n          if (vpoll && (event || task)) {\n            final var vresp = processCandidate((VPoll)val,\n                                               subComp,\n                                               evinfo,\n                                               pids,\n                                               chg);\n            if (!vresp.isOk()) {\n              return Response.fromResponse(resp, vresp);\n            }\n            continue;\n          }\n          logger.warn(\"Unimplemented Component object: \" + subComp);\n        }\n      }\n     \n      if (ev.getCreated() == null) {\n        if (ev.getLastmod() != null) {\n          ev.setCreated(ev.getLastmod());\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n        } else {\n          ev.updateDtstamp();\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n          chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n        }\n      }\n      if (ev.getLastmod() == null) {\n       \n        ev.setLastmod(ev.getCreated());\n        chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n      }\n      processTimezones(ev, ical, chg);\n     \n      if (ev.getRecipients() != null) {\n        ev.getRecipients().clear();\n      }\n      ev.setOriginator(null);\n      if (hasXparams.value) {\n       \n        final Component valCopy = val.copy();\n       \n        final Description desp = valCopy.getProperty(Property.DESCRIPTION);\n        if (desp != null) {\n          desp.setValue(null);\n        }\n        final Attach attachp = valCopy.getProperty(Property.ATTACH);\n       \n        if (attachp != null) {\n          final Value v = attachp.getParameter(Parameter.VALUE);\n          if (v != null) {\n            attachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n          }\n        }\n        chg.addValue(PropertyInfoIndex.XPROP,\n                     new BwXproperty(BwXproperty.bedeworkIcal,\n                                     null,\n                                     valCopy.toString()));\n      }\n      chg.processChanges(ev, true, false);\n      ev.setRecurring(ev.isRecurringEntity());\n      if (logger.debug()) {\n        logger.debug(chg.toString());\n        logger.debug(ev.toString());\n      }\n      if (masterEI != null) {\n       \n        return Response.notFound(resp);\n      }\n      resp.setEntity(evinfo);\n      return resp;\n    } catch (final Throwable t) {\n      if (logger.debug()) {\n        logger.error(t);\n      }\n      return Response.error(resp, t);\n    }\n  }","cleancode":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { return response.notok(resp, failed, calfacadeexception.noguid); } bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; final dtstart dtstart = pl.getproperty(property.dtstart); if (rid != null) { masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { evinfo.getevent().setsuppressed(false); } } else if (rid != null) { masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: chg.addvalue(pi, new bwstring(null, pval)); break; case completed: if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: break; case dtstamp: ev.setdtstamp(pval); break; case dtstart: break; case due: break; case duration: break; case exdate: chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: chg.addvalue(pi, pval); break; case freebusy: final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: bwlocation loc = null; lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: break; case related_to: final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: final textlist rl = ((resources)prop).getresources(); if (rl != null) { lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: chg.addvalue(pi, pval); break; case sequence: final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: break; case url: if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { final component valcopy = val.copy(); final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","comment":"\/** we are going to try to construct a bwevent object from a vevent. this * may represent a new event or an update to a pre-existing event. in any * case, the vevent probably has insufficient information to completely * reconstitute the event object so we'll get the uid first and retrieve * the event if it exists. * * <p>to put it another way we're doing a diff then update. * * <p>if it doesn't exist, we'll first fill in the appropriate fields, * (non-public, creator, created etc) then for both cases update the * remaining fields from the vevent. * * <p>recurring events present some challenges. if there is no recurrence * id the vevent represents the master entity which defines the recurrence * rules. if a recurrence id is present then the vevent represents a * recurrence instance override and we should not attempt to retrieve the * actual object but the referenced instance. * * <p>also, note that we sorted the components first so we get the master * before any instances. * * <p>if dtstart, rrule, exrule have changed (also rdate, exdate?) then any * existing overrides are unusable. we should delete all overrides and replace * with new ones. * * <p>for an update we have to keep track of which fields were present in * the vevent and set all absent fields to null in the bwevent. * * @param cb icalcallback object * @param cal needed so we can retrieve the event. * @param ical icalendar we are converting into. we check its events for * overrides. * @param val vevent object * @param mergeattendees true if we should only update our own attendee. * @return response with status and eventinfo object representing new entry or updated entry *\/\n\/\/ we'll need this later.\n\/\/ empty component\n\/\/ get the guid from the component\n\/* xxx a guid is required - but are there devices out there without a * guid - and if so how do we handle it? *\/\n\/* see if we have a recurrence id *\/\n\/* xxx what do i do with it? *\/\n\/* if we have a recurrence id see if we already have the master (we should * get a master + all its overrides). * * if so find the override and use the annnotation or if no override, * make one. * * if no override retrieve the event, add it to our table and then locate the * annotation. * * if there is no annotation, create one. * * it's possible we have been sent 'detached' instances of a recurring * event. this may happen if we are invited to one or more instances of a * meeting. in this case we try to retrieve the master and if it doesn't * exist we manufacture one. we consider such an instance an update to * that instance only and leave the others alone. *\/\n\/* we need this in a couple of places *\/\n\/* if (rid != null) { \/\/ see if we have a new master event. if so create a proxy to that event. masterei = findmaster(guid, ical.getcomponents()); if (masterei == null) { masterei = makenewevent(cb, chg, entitytype, guid, cal); bwevent e = masterei.getevent(); \/\/ xxx this seems bogus dtstart mdtstart; string bogusdate = \"19980118t230000\"; if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + \"z\"); } else if (dtstart.gettimezone() == null) { mdtstart = new dtstart(bogusdate); } else { mdtstart = new dtstart(bogusdate + \"z\", dtstart.gettimezone()); } setdates(e, mdtstart, null, null, chg); e.setrecurring(true); e.addrdate(ridobj); e.setsuppressed(true); ical.addcomponent(masterei); } if (masterei != null) { evinfo = masterei.findoverride(rid); } } *\/\n\/* if this is a recurrence instance see if we can find the master we only need this because the master may follow the overrides. *\/\n\/\/ see if we have a new master event. if so create a proxy to this event.\n\/\/ dorecur - wrong again\n\/\/ we just retrieved it's master\n\/\/ this should never have an rid for cancel of entire event.\n\/\/ presumably sent an update for the entire event. no longer suppressed master\n\/* manufacture a master for the instance *\/\n\/\/ xxx this seems bogus\n\/\/ base dtstart on the recurrence id.\n\/\/ e.addrdate(ridobj);\n\/\/ xxx spurious???\n\/\/debug(\"ical prop \" + prop.getclass().getname());\n\/* ------------------- accept response -------------------- *\/\n\/* ------------------- attachment -------------------- *\/\n\/* ------------------- attendee -------------------- *\/\n\/\/if (cb.getstrictness() == icalcallback.conformancewarn) { \/\/ warn(\"had attendees for publish\"); \/\/}\n\/* only update for our own attendee * we're doing a put and this must be the attendee updating their * partstat. we don't allow them to change other attendees * whatever the put content says. *\/\n\/\/ use the value we currently have\n\/\/ an added attendee\n\/* ------------------- categories -------------------- *\/\n\/* got some categories *\/\n\/* ------------------- class -------------------- *\/\n\/* ------------------- comment -------------------- *\/\n\/* ------------------- completed -------------------- *\/\n\/* ------------------- concept -------------------- *\/\n\/* got a concept *\/\n\/* ------------------- contact -------------------- *\/\n\/* ------------------- created -------------------- *\/\n\/* ------------------- description -------------------- *\/\n\/* ------------------- dtend -------------------- *\/\n\/* ------------------- dtstamp -------------------- *\/\n\/* ------------------- dtstart -------------------- *\/\n\/* -------------------- due ------------------------ *\/\n\/* ------------------- duration -------------------- *\/\n\/* ------------------- exdate -------------------- *\/\n\/* ------------------- exrule -------------------- *\/\n\/* ------------------- freebusy -------------------- *\/\n\/* ------------------- geo -------------------- *\/\n\/* ------------------- lastmodified -------------------- *\/\n\/* ------------------- location -------------------- *\/\n\/\/string uid = getuidpar(prop); \/* at the moment mozilla lightning is broken and this leads to all * sorts of problems. if (uid != null) { loc = cb.getlocation(uid); } *\/\n\/\/ chgtbl - this only shows that it's a different location object\n\/\/ see if the value is changed\n\/* ------------------- organizer -------------------- *\/\n\/* ------------------- percentcomplete -------------------- *\/\n\/* ------------------- poll mode -------------------- *\/\n\/* ------------------- poll properties ---------------- *\/\n\/* ------------------- poll winner -------------------- *\/\n\/* ------------------- priority -------------------- *\/\n\/* ------------------- rdate -------------------- *\/\n\/* ------------------- recurrenceid -------------------- *\/ \/\/ done above\n\/* ------------------- relatedto -------------------- *\/\n\/* ------------------- requeststatus -------------------- *\/\n\/* ------------------- resources -------------------- *\/\n\/* got some resources *\/\n\/* ------------------- rrule -------------------- *\/\n\/* ------------------- sequence -------------------- *\/\n\/* ------------------- status -------------------- *\/\n\/* ------------------- summary -------------------- *\/\n\/* ------------------- transp -------------------- *\/\n\/* ------------------- uid -------------------- *\/ \/* we did this above *\/\n\/* ------------------- url -------------------- *\/\n\/* ------------------------- x-property --------------------------- *\/\n\/* see if this is an x-category that can be converted to a real category *\/\n\/* =================== process sub-components =============== *\/\n\/* fix up timestamps. *\/\n\/\/ created cannot be null now\n\/* remove any recipients and originator *\/\n\/* save a text copy of the entire event as an x-property *\/\n\/* remove potentially large values *\/\n\/\/ don't store the entire attachment - we just need the parameters.\n\/\/ just return notfound as this event is on its override list","repo":"Bedework\/bw-calendar-convert","code_context_2":"public static GetEntityResponse<EventInfo> toEvent(\nfinal IcalCallback cb,\nfinal BwCalendar cal,\nfinal Icalendar ical,\nfinal Component val,\nfinal boolean mergeAttendees) {\nfinal var resp = new GetEntityResponse<EventInfo>();\nif (val == null) {\nreturn Response.notOk(resp, failed, \"No component supplied\");\n}\nString currentPrincipal = null;\nfinal BwPrincipal principal = cb.getPrincipal();\nif (principal != null) {\ncurrentPrincipal = principal.getPrincipalRef();\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\nentityType = IcalDefs.entityTypeJournal;\n} else if (val instanceof VFreeBusy) {\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\nevinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n} else if (evinfo.getEvent().getEntityType() != entityType) {\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\nif (due != null ) {\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\nfinal var fcResp = cb.findContact(nm);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\ncontact = BwContact.makeContact();\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\nlogger.debug(\"Unsupported parameter \" + par.getName());\n}\nreturn Response.notOk(resp, failed,\n\"Unsupported parameter \" +\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\nsubComps = null;\n}\nfinal Set<Integer> pids;\nif (vpoll) {\npids = new TreeSet<>();\nfinal BwEvent vp = evinfo.getEvent();\nif (!Util.isEmpty(vp.getPollItems())) {\nvp.clearPollItems();\n}\n} else {\npids = null;\n}\nif (!Util.isEmpty(subComps)) {\nfor (final var subComp: subComps) {\nif (subComp instanceof Available) {\nif (!(val instanceof VAvailability)) {\nreturn Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n}\nfinal var avlResp = processAvailable(cb, cal,\nical,\n(VAvailability)val,\n(Available)subComp,\nevinfo);\nif (!avlResp.isOk()) {\nreturn Response.fromResponse(resp, avlResp);\n}\ncontinue;\n}\nif (subComp instanceof Participant) {\nif (vpoll) {\nfinal var vresp = processVoter(cb,\n(VPoll)val,\n(Participant)subComp,\nevinfo,\nchg,\nmergeAttendees);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Participant object\");\ncontinue;\n}\nif (subComp instanceof VResource) {\nlogger.warn(\"Unimplemented VResource object\");\ncontinue;\n}\nif (subComp instanceof VLocation) {\nlogger.warn(\"Unimplemented VLocation object\");\ncontinue;\n}\nif (subComp instanceof VAlarm) {\nfinal var aresp = VAlarmUtil.processAlarm(cb,\nval,\n(VAlarm)subComp,\nev,\ncurrentPrincipal,\nchg);\nif (!aresp.isOk()) {\nreturn Response.fromResponse(resp, aresp);\n}\ncontinue;\n}\nif (vpoll && (event || task)) {\nfinal var vresp = processCandidate((VPoll)val,\nsubComp,\nevinfo,\npids,\nchg);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}\nresp.setEntity(evinfo);\nreturn resp;\n} catch (final Throwable t) {\nif (logger.debug()) {\nlogger.error(t);\n}\nreturn Response.error(resp, t);\n}\n}\n\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\n\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\n\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\n\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\n\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\n\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\n\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\n\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\n\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\n\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\n\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\n\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\n\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\n\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\n\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\n\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\n\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\n\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\n\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\n\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\n\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\n\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\n\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\n\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\n\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\n\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\n\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\n\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\n\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\n\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\n\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\n\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\n\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\n\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\n\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\n\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\n\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\n\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\n\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\n\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\n\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\n\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\n\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\n\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\n\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\n\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\n\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\n\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\n\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\n\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\n\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\n\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\n\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\n\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}","code_context_10":"public static GetEntityResponse<EventInfo> toEvent(\nfinal IcalCallback cb,\nfinal BwCalendar cal,\nfinal Icalendar ical,\nfinal Component val,\nfinal boolean mergeAttendees) {\nfinal var resp = new GetEntityResponse<EventInfo>();\nif (val == null) {\nreturn Response.notOk(resp, failed, \"No component supplied\");\n}\nString currentPrincipal = null;\nfinal BwPrincipal principal = cb.getPrincipal();\nif (principal != null) {\ncurrentPrincipal = principal.getPrincipalRef();\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\nentityType = IcalDefs.entityTypeJournal;\n} else if (val instanceof VFreeBusy) {\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\nevinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n} else if (evinfo.getEvent().getEntityType() != entityType) {\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\nif (due != null ) {\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\nfinal var fcResp = cb.findContact(nm);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\ncontact = BwContact.makeContact();\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\nlogger.debug(\"Unsupported parameter \" + par.getName());\n}\nreturn Response.notOk(resp, failed,\n\"Unsupported parameter \" +\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\nsubComps = null;\n}\nfinal Set<Integer> pids;\nif (vpoll) {\npids = new TreeSet<>();\nfinal BwEvent vp = evinfo.getEvent();\nif (!Util.isEmpty(vp.getPollItems())) {\nvp.clearPollItems();\n}\n} else {\npids = null;\n}\nif (!Util.isEmpty(subComps)) {\nfor (final var subComp: subComps) {\nif (subComp instanceof Available) {\nif (!(val instanceof VAvailability)) {\nreturn Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n}\nfinal var avlResp = processAvailable(cb, cal,\nical,\n(VAvailability)val,\n(Available)subComp,\nevinfo);\nif (!avlResp.isOk()) {\nreturn Response.fromResponse(resp, avlResp);\n}\ncontinue;\n}\nif (subComp instanceof Participant) {\nif (vpoll) {\nfinal var vresp = processVoter(cb,\n(VPoll)val,\n(Participant)subComp,\nevinfo,\nchg,\nmergeAttendees);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Participant object\");\ncontinue;\n}\nif (subComp instanceof VResource) {\nlogger.warn(\"Unimplemented VResource object\");\ncontinue;\n}\nif (subComp instanceof VLocation) {\nlogger.warn(\"Unimplemented VLocation object\");\ncontinue;\n}\nif (subComp instanceof VAlarm) {\nfinal var aresp = VAlarmUtil.processAlarm(cb,\nval,\n(VAlarm)subComp,\nev,\ncurrentPrincipal,\nchg);\nif (!aresp.isOk()) {\nreturn Response.fromResponse(resp, aresp);\n}\ncontinue;\n}\nif (vpoll && (event || task)) {\nfinal var vresp = processCandidate((VPoll)val,\nsubComp,\nevinfo,\npids,\nchg);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}\nresp.setEntity(evinfo);\nreturn resp;\n} catch (final Throwable t) {\nif (logger.debug()) {\nlogger.error(t);\n}\nreturn Response.error(resp, t);\n}\n}\n\n}\nString currentPrincipal = null;\nfinal BwPrincipal principal = cb.getPrincipal();\nif (principal != null) {\ncurrentPrincipal = principal.getPrincipalRef();\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\n\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\n\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\n\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\n\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\n\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\n\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\n\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\n\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\n\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\n\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\n\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\n\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\n\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\n\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\n\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\n\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\n\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\n\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\n\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\n\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\n\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\n\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\n\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\n\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\n\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\n\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\n\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\n\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\n\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\n\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\n\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\n\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\n\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\n\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\n\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\n\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\n\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\n\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\n\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\n\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\n\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\n\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\n\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\n\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\n\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\n\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\n\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\nsubComps = null;\n}\nfinal Set<Integer> pids;\nif (vpoll) {\npids = new TreeSet<>();\nfinal BwEvent vp = evinfo.getEvent();\n\npids,\nchg);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\n\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\n\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\n\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\n\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}\nresp.setEntity(evinfo);\nreturn resp;\n} catch (final Throwable t) {\nif (logger.debug()) {\nlogger.error(t);\n}\nreturn Response.error(resp, t);\n}","code_context_20":"public static GetEntityResponse<EventInfo> toEvent(\nfinal IcalCallback cb,\nfinal BwCalendar cal,\nfinal Icalendar ical,\nfinal Component val,\nfinal boolean mergeAttendees) {\nfinal var resp = new GetEntityResponse<EventInfo>();\nif (val == null) {\nreturn Response.notOk(resp, failed, \"No component supplied\");\n}\nString currentPrincipal = null;\nfinal BwPrincipal principal = cb.getPrincipal();\nif (principal != null) {\ncurrentPrincipal = principal.getPrincipalRef();\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\nentityType = IcalDefs.entityTypeJournal;\n} else if (val instanceof VFreeBusy) {\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\nevinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n} else if (evinfo.getEvent().getEntityType() != entityType) {\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\nif (due != null ) {\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\nfinal var fcResp = cb.findContact(nm);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\ncontact = BwContact.makeContact();\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\nlogger.debug(\"Unsupported parameter \" + par.getName());\n}\nreturn Response.notOk(resp, failed,\n\"Unsupported parameter \" +\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\nsubComps = null;\n}\nfinal Set<Integer> pids;\nif (vpoll) {\npids = new TreeSet<>();\nfinal BwEvent vp = evinfo.getEvent();\nif (!Util.isEmpty(vp.getPollItems())) {\nvp.clearPollItems();\n}\n} else {\npids = null;\n}\nif (!Util.isEmpty(subComps)) {\nfor (final var subComp: subComps) {\nif (subComp instanceof Available) {\nif (!(val instanceof VAvailability)) {\nreturn Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n}\nfinal var avlResp = processAvailable(cb, cal,\nical,\n(VAvailability)val,\n(Available)subComp,\nevinfo);\nif (!avlResp.isOk()) {\nreturn Response.fromResponse(resp, avlResp);\n}\ncontinue;\n}\nif (subComp instanceof Participant) {\nif (vpoll) {\nfinal var vresp = processVoter(cb,\n(VPoll)val,\n(Participant)subComp,\nevinfo,\nchg,\nmergeAttendees);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Participant object\");\ncontinue;\n}\nif (subComp instanceof VResource) {\nlogger.warn(\"Unimplemented VResource object\");\ncontinue;\n}\nif (subComp instanceof VLocation) {\nlogger.warn(\"Unimplemented VLocation object\");\ncontinue;\n}\nif (subComp instanceof VAlarm) {\nfinal var aresp = VAlarmUtil.processAlarm(cb,\nval,\n(VAlarm)subComp,\nev,\ncurrentPrincipal,\nchg);\nif (!aresp.isOk()) {\nreturn Response.fromResponse(resp, aresp);\n}\ncontinue;\n}\nif (vpoll && (event || task)) {\nfinal var vresp = processCandidate((VPoll)val,\nsubComp,\nevinfo,\npids,\nchg);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}\nresp.setEntity(evinfo);\nreturn resp;\n} catch (final Throwable t) {\nif (logger.debug()) {\nlogger.error(t);\n}\nreturn Response.error(resp, t);\n}\n}\n\npublic static GetEntityResponse<EventInfo> toEvent(\nfinal IcalCallback cb,\nfinal BwCalendar cal,\nfinal Icalendar ical,\nfinal Component val,\nfinal boolean mergeAttendees) {\nfinal var resp = new GetEntityResponse<EventInfo>();\nif (val == null) {\nreturn Response.notOk(resp, failed, \"No component supplied\");\n}\nString currentPrincipal = null;\nfinal BwPrincipal principal = cb.getPrincipal();\nif (principal != null) {\ncurrentPrincipal = principal.getPrincipalRef();\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\n\n}\nfinal Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\nfinal int methodType = ical.getMethodType();\nString attUri = null;\nif (mergeAttendees) {\n\/\/ We'll need this later.\nattUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n}\nfinal String colPath;\nif (cal == null) {\ncolPath = null;\n} else {\ncolPath = cal.getPath();\n}\ntry {\nfinal PropertyList<Property> pl = val.getProperties();\nboolean vpoll = false;\nboolean event = false;\nboolean task = false;\nif (pl == null) {\n\/\/ Empty component\nreturn Response.notOk(resp, failed, \"Empty component\");\n}\nfinal int entityType;\nif (val instanceof VEvent) {\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\nentityType = IcalDefs.entityTypeJournal;\n} else if (val instanceof VFreeBusy) {\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n\nentityType = IcalDefs.entityTypeEvent;\nevent = true;\n} else if (val instanceof VToDo) {\nentityType = IcalDefs.entityTypeTodo;\ntask = true;\n} else if (val instanceof VJournal) {\nentityType = IcalDefs.entityTypeJournal;\n} else if (val instanceof VFreeBusy) {\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\n\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\n\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\n\nentityType = IcalDefs.entityTypeFreeAndBusy;\n} else if (val instanceof VAvailability) {\nentityType = IcalDefs.entityTypeVavailability;\n} else if (val instanceof Available) {\nentityType = IcalDefs.entityTypeAvailable;\n} else if (val instanceof VPoll) {\nentityType = IcalDefs.entityTypeVpoll;\nvpoll = true;\n} else {\nreturn Response.error(resp, \"org.bedework.invalid.component.type: \" +\nval.getName());\n}\n\/\/ Get the guid from the component\nString guid = null;\nfinal Uid uidp = pl.getProperty(Property.UID);\nif (uidp != null) {\ntestXparams(uidp, hasXparams);\nguid = uidp.getValue();\n}\nif (guid == null) {\n\/* XXX A guid is required - but are there devices out there without a\n* guid - and if so how do we handle it?\n*\/\nreturn Response.notOk(resp, failed, CalFacadeException.noGuid);\n}\n\/* See if we have a recurrence id *\/\nBwDateTime ridObj = null;\nString rid = null;\nTimeZone ridTz = null;\nfinal RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\nif (ridp != null) {\ntestXparams(ridp, hasXparams);\nridObj = BwDateTime.makeBwDateTime(ridp);\nif (ridObj.getRange() != null) {\n\/* XXX What do I do with it? *\/\nlogger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n}\nrid = ridObj.getDate();\n}\nEventInfo masterEI = null;\nEventInfo evinfo = null;\nfinal BwEvent ev;\n\/* If we have a recurrence id see if we already have the master (we should\n* get a master + all its overrides).\n*\n* If so find the override and use the annnotation or if no override,\n* make one.\n*\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\/* If this is a recurrence instance see if we can find the master\nWe only need this because the master may follow the overrides.\n*\/\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to this event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\n\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\n}\n}\nif ((evinfo == null) &&\n(cal != null) &&\n(cal.getCalType() != BwCalendar.calTypeInbox) &&\n(cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n(cal.getCalType() != BwCalendar.calTypeOutbox)) {\nif (logger.debug()) {\nlogger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n}\nfinal GetEntitiesResponse<EventInfo> eisResp =\ncb.getEvent(colPath, guid);\nif (eisResp.isError()) {\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n\nreturn Response.fromResponse(resp, eisResp);\n}\nfinal var eis = eisResp.getEntities();\nif (!Util.isEmpty(eis)) {\nif (eis.size() > 1) {\n\/\/ DORECUR - wrong again\nreturn Response.notOk(resp, failed,\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\n\"More than one event returned for guid.\");\n}\nevinfo = eis.iterator().next();\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\n\n}\nif (logger.debug()) {\nif (evinfo != null) {\nlogger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\n\n} else {\nlogger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n}\n}\nif (evinfo != null) {\nif (rid != null) {\n\/\/ We just retrieved it's master\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\n\n* If no override retrieve the event, add it to our table and then locate the\n* annotation.\n*\n* If there is no annotation, create one.\n*\n* It's possible we have been sent 'detached' instances of a recurring\n* event. This may happen if we are invited to one or more instances of a\n* meeting. In this case we try to retrieve the master and if it doesn't\n* exist we manufacture one. We consider such an instance an update to\n* that instance only and leave the others alone.\n*\/\n\/* We need this in a couple of places *\/\nfinal DtStart dtStart = pl.getProperty(Property.DTSTART);\n\/*\nif (rid != null) {\n\/\/ See if we have a new master event. If so create a proxy to that event.\nmasterEI = findMaster(guid, ical.getComponents());\nif (masterEI == null) {\nmasterEI = makeNewEvent(cb, chg, entityType, guid, cal);\nBwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nDtStart mdtStart;\nString bogusDate = \"19980118T230000\";\nif (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + \"Z\");\n} else if (dtStart.getTimeZone() == null) {\nmdtStart = new DtStart(bogusDate);\n} else {\nmdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n}\nsetDates(e, mdtStart, null, null, chg);\ne.setRecurring(true);\ne.addRdate(ridObj);\ne.setSuppressed(true);\nical.addComponent(masterEI);\n}\nif (masterEI != null) {\nevinfo = masterEI.findOverride(rid);\n}\n}\n*\/\n\nmasterEI = evinfo;\nmasterEI.setInstanceOnly(true);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nical.addComponent(masterEI);\n} else if (methodType == ScheduleMethods.methodTypeCancel) {\n\/\/ This should never have an rid for cancel of entire event.\nevinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n} else {\n\/\/ Presumably sent an update for the entire event. No longer suppressed master\nevinfo.getEvent().setSuppressed(false);\n}\n} else if (rid != null) {\n\/* Manufacture a master for the instance *\/\nmasterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\n\nfinal BwEvent e = masterEI.getEvent();\n\/\/ XXX This seems bogus\nfinal DtStart mdtStart;\nfinal String bogusDate = \"19980118\";\nfinal String bogusTime = \"T230000\";\n\/\/ Base dtstart on the recurrence id.\nfinal boolean isDateType = ridObj.getDateType();\nif (isDateType) {\nmdtStart = new DtStart(new Date(bogusDate));\n} else if (dtStart.isUtc()) {\nmdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n} else if (ridObj.getTzid() == null) {\nmdtStart = new DtStart(bogusDate + bogusTime);\n} else {\nmdtStart = new DtStart(bogusDate + bogusTime,\nTimezones.getTz(ridObj.getTzid()));\n}\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nmasterEI, mdtStart, null, null);\ne.setRecurring(true);\n\/\/ e.addRdate(ridObj);\nfinal var sum = (Summary)pl.getProperty(Property.SUMMARY);\ne.setSummary(sum.getValue());\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\nevinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n} else if (evinfo.getEvent().getEntityType() != entityType) {\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\n\ne.setSuppressed(true);\nical.addComponent(masterEI);\nevinfo = masterEI.findOverride(rid);\nevinfo.recurrenceSeen = true;\nmasterEI.setInstanceOnly(rid != null);\n}\n}\nif (evinfo == null) {\nevinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n} else if (evinfo.getEvent().getEntityType() != entityType) {\nreturn Response.notOk(resp, failed,\n\"org.bedework.mismatched.entity.type: \" +\nval);\n}\nfinal ChangeTable chg = evinfo.getChangeset(\ncb.getPrincipal().getPrincipalRef());\nif (rid != null) {\nfinal String evrid = evinfo.getEvent().getRecurrenceId();\nif ((evrid == null) || (!evrid.equals(rid))) {\nlogger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\nchg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n}\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\nif (due != null ) {\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\n\nif (masterEI.getEvent().getSuppressed()) {\nmasterEI.getEvent().addRdate(ridObj);\n}\n}\nev = evinfo.getEvent();\nev.setScheduleMethod(methodType);\nDtEnd dtEnd = null;\nif (entityType == IcalDefs.entityTypeTodo) {\nfinal Due due = pl.getProperty(Property.DUE);\nif (due != null ) {\ndtEnd = new DtEnd(due.getParameters(), due.getValue());\n}\n} else {\ndtEnd = pl.getProperty(Property.DTEND);\n}\nfinal Duration duration = pl.getProperty(Property.DURATION);\nIcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\nevinfo, dtStart, dtEnd, duration);\nfor (final Property prop: pl) {\ntestXparams(prop, hasXparams);\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\n\n\/\/debug(\"ical prop \" + prop.getClass().getName());\nString pval = prop.getValue();\nif ((pval != null) && (pval.length() == 0)) {\npval = null;\n}\nfinal PropertyInfoIndex pi;\nif (prop instanceof XProperty) {\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\n\npi = PropertyInfoIndex.XPROP;\n} else {\npi = PropertyInfoIndex.fromName(prop.getName());\n}\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n\nif (pi == null) {\nlogger.debug(\"Unknown property with name \" + prop.getName() +\n\" class \" + prop.getClass() +\n\" and value \" + pval);\ncontinue;\n}\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\n\nchg.present(pi);\nswitch (pi) {\ncase ACCEPT_RESPONSE:\n\/* ------------------- Accept Response -------------------- *\/\nString sval = prop.getValue();\nif (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\nev.setPollAcceptResponse(sval);\n}\nbreak;\ncase ATTACH:\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\n\n\/* ------------------- Attachment -------------------- *\/\nchg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\nbreak;\ncase ATTENDEE:\n\/* ------------------- Attendee -------------------- *\/\nif (methodType == ScheduleMethods.methodTypePublish) {\nif (cb.getStrictness() == IcalCallback.conformanceStrict) {\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\n\nreturn Response.notOk(resp, failed,\nCalFacadeException.attendeesInPublish);\n}\n\/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n\/\/ warn(\"Had attendees for PUBLISH\");\n\/\/}\n}\nfinal Attendee attPr = (Attendee)prop;\nif (evinfo.getNewEvent() || !mergeAttendees) {\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\n\n} else {\nfinal String pUri = cb.getCaladdr(attPr.getValue());\nif (pUri.equals(attUri)) {\n\/* Only update for our own attendee\n* We're doing a PUT and this must be the attendee updating their\n* partstat. We don't allow them to change other attendees\n* whatever the PUT content says.\n*\/\nchg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n} else {\n\/\/ Use the value we currently have\nboolean found = false;\nfor (final BwAttendee att: ev.getAttendees()) {\nif (pUri.equals(att.getAttendeeUri())) {\nchg.addValue(pi, att.clone());\nfound = true;\nbreak;\n}\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\n\n}\nif (!found) {\n\/\/ An added attendee\nfinal BwAttendee att = IcalUtil\n.getAttendee(cb, attPr);\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\n\natt.setPartstat(IcalDefs.partstatValNeedsAction);\nchg.addValue(pi, att);\n}\n}\n}\nbreak;\ncase BUSYTYPE:\nfinal int ibt = BwEvent.fromBusyTypeString(pval);\nif (chg.changed(pi,\nev.getBusyType(),\nibt)) {\nev.setBusyType(ibt);\n}\nbreak;\ncase CATEGORIES:\n\/* ------------------- Categories -------------------- *\/\nfinal Categories cats = (Categories)prop;\nfinal TextList cl = cats.getCategories();\nString lang = IcalUtil.getLang(cats);\nif (cl != null) {\n\/* Got some categories *\/\nfor (final String wd: cl) {\nif (wd == null) {\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\n\ncontinue;\n}\nfinal BwString key = new BwString(lang, wd);\nfinal var fcResp = cb.findCategory(key);\nfinal BwCategory cat;\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isNotFound()) {\ncat = BwCategory.makeCategory();\ncat.setWord(key);\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\n\ncb.addCategory(cat);\n} else {\ncat = fcResp.getEntity();\n}\nchg.addValue(pi, cat);\n}\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\n\n}\nbreak;\ncase CLASS:\n\/* ------------------- Class -------------------- *\/\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\n\nif (chg.changed(pi, ev.getClassification(), pval)) {\nev.setClassification(pval);\n}\nbreak;\ncase COMMENT:\n\/* ------------------- Comment -------------------- *\/\nchg.addValue(pi,\nnew BwString(null, pval));\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n\nbreak;\ncase COMPLETED:\n\/* ------------------- Completed -------------------- *\/\nif (chg.changed(pi, ev.getCompleted(), pval)) {\nev.setCompleted(pval);\n}\nbreak;\ncase CONCEPT:\n\/* ------------------- Concept -------------------- *\/\nfinal Concept c = (Concept)prop;\nfinal String cval = c.getValue();\nif (cval != null) {\n\/* Got a concept *\/\nchg.addValue(PropertyInfoIndex.XPROP,\nBwXproperty.makeIcalProperty(\"CONCEPT\",\nnull,\ncval));\n}\nbreak;\ncase CONTACT:\n\/* ------------------- Contact -------------------- *\/\nfinal String altrep = getAltRepPar(prop);\nlang = IcalUtil.getLang(prop);\nfinal String uid = getUidPar(prop);\nfinal BwString nm = new BwString(lang, pval);\nBwContact contact = null;\nif (uid != null) {\nfinal var fcResp = cb.getContact(uid);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\nfinal var fcResp = cb.findContact(nm);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\n\nfinal var fcResp = cb.findContact(nm);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\ncontact = fcResp.getEntity();\n}\n}\nif (contact == null) {\ncontact = BwContact.makeContact();\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\n\n}\n}\nif (contact == null) {\ncontact = BwContact.makeContact();\ncontact.setCn(nm);\ncontact.setLink(altrep);\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\n\ncb.addContact(contact);\n} else {\ncontact.setCn(nm);\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\ncontact.setLink(altrep);\n}\nchg.addValue(pi, contact);\nbreak;\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\n\ncase CREATED:\n\/* ------------------- Created -------------------- *\/\nif (chg.changed(pi, ev.getCreated(), pval)) {\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\n\nev.setCreated(pval);\n}\nbreak;\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\n\ncase DESCRIPTION:\n\/* ------------------- Description -------------------- *\/\nif (chg.changed(pi, ev.getDescription(), pval)) {\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n\nev.setDescription(pval);\n}\nbreak;\ncase DTEND:\n\/* ------------------- DtEnd -------------------- *\/\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\n\nbreak;\ncase DTSTAMP:\n\/* ------------------- DtStamp -------------------- *\/\nev.setDtstamp(pval);\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\n\nbreak;\ncase DTSTART:\n\/* ------------------- DtStart -------------------- *\/\nbreak;\ncase DUE:\n\/* -------------------- Due ------------------------ *\/\nbreak;\ncase DURATION:\n\/* ------------------- Duration -------------------- *\/\nbreak;\ncase EXDATE:\n\/* ------------------- ExDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase EXRULE:\n\/* ------------------- ExRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase FREEBUSY:\n\/* ------------------- freebusy -------------------- *\/\nfinal FreeBusy fbusy = (FreeBusy)prop;\nfinal PeriodList perpl = fbusy.getPeriods();\nfinal Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\nfinal int fbtype;\nif (par == null) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY)) {\nfbtype = BwFreeBusyComponent.typeBusy;\n} else if (par.equals(FbType.BUSY_TENTATIVE)) {\nfbtype = BwFreeBusyComponent.typeBusyTentative;\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\nlogger.debug(\"Unsupported parameter \" + par.getName());\n}\nreturn Response.notOk(resp, failed,\n\"Unsupported parameter \" +\n\n} else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\nfbtype = BwFreeBusyComponent.typeBusyUnavailable;\n} else if (par.equals(FbType.FREE)) {\nfbtype = BwFreeBusyComponent.typeFree;\n} else {\nif (logger.debug()) {\nlogger.debug(\"Unsupported parameter \" + par.getName());\n}\nreturn Response.notOk(resp, failed,\n\"Unsupported parameter \" +\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\n\n\"Unsupported parameter \" +\npar.getName());\n}\nfinal BwFreeBusyComponent fbc = new BwFreeBusyComponent();\nfbc.setType(fbtype);\nfor (final Period per : perpl) {\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\n\nfbc.addPeriod(per);\n}\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n\nev.addFreeBusyPeriod(fbc);\nbreak;\ncase GEO:\n\/* ------------------- Geo -------------------- *\/\nfinal Geo g = (Geo)prop;\nfinal BwGeo geo = new BwGeo(g.getLatitude(),\ng.getLongitude());\nif (chg.changed(pi, ev.getGeo(), geo)) {\nev.setGeo(geo);\n}\nbreak;\ncase LAST_MODIFIED:\n\/* ------------------- LastModified -------------------- *\/\nif (chg.changed(pi, ev.getLastmod(), pval)) {\nev.setLastmod(pval);\n}\nbreak;\ncase LOCATION:\n\/* ------------------- Location -------------------- *\/\nBwLocation loc = null;\n\/\/String uid = getUidPar(prop);\n\/* At the moment Mozilla lightning is broken and this leads to all\n* sorts of problems.\nif (uid != null) {\nloc = cb.getLocation(uid);\n}\n*\/\nlang = IcalUtil.getLang(prop);\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\n\nBwString addr = null;\nif (pval != null) {\nif (loc == null) {\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n\naddr = new BwString(lang, pval);\nfinal var fcResp = cb.findLocation(addr);\nif (fcResp.isError()) {\nreturn Response.fromResponse(resp, fcResp);\n}\nif (fcResp.isOk()) {\nloc = fcResp.getEntity();\n}\n}\nif (loc == null) {\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\n\nloc = BwLocation.makeLocation();\nloc.setAddress(addr);\ncb.addLocation(loc);\n}\n}\nfinal BwLocation evloc = ev.getLocation();\nif (chg.changed(pi, evloc, loc)) {\n\/\/ CHGTBL - this only shows that it's a different location object\nev.setLocation(loc);\n} else if ((loc != null) && (evloc != null)) {\n\/\/ See if the value is changed\nfinal String evval = evloc.getAddress().getValue();\nfinal String inval = loc.getAddress().getValue();\nif (!evval.equals(inval)) {\nchg.changed(pi, evval, inval);\nevloc.getAddress().setValue(inval);\n}\n}\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\n\nbreak;\ncase ORGANIZER:\n\/* ------------------- Organizer -------------------- *\/\nfinal BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\nfinal BwOrganizer evorg = ev.getOrganizer();\nfinal BwOrganizer evorgCopy;\nif (evorg == null) {\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\nevorgCopy = null;\n} else {\nevorgCopy = (BwOrganizer)evorg.clone();\n}\nif (chg.changed(pi, evorgCopy, org)) {\nif (evorg == null) {\nev.setOrganizer(org);\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\n} else {\nevorg.update(org);\n}\n}\nbreak;\ncase PERCENT_COMPLETE:\n\/* ------------------- PercentComplete -------------------- *\/\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\nInteger ival = ((PercentComplete)prop).getPercentage();\nif (chg.changed(pi, ev.getPercentComplete(), ival)) {\nev.setPercentComplete(ival);\n}\nbreak;\ncase POLL_MODE:\n\/* ------------------- Poll mode -------------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\n\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollMode(), sval)) {\nev.setPollMode(sval);\n}\nbreak;\ncase POLL_PROPERTIES:\n\/* ------------------- Poll properties ---------------- *\/\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\n\nsval = prop.getValue();\nif (chg.changed(pi, ev.getPollProperties(), sval)) {\nev.setPollProperties(sval);\n}\nbreak;\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\n\ncase POLL_WINNER:\n\/* ------------------- Poll winner -------------------- *\/\nival = ((PollWinner)prop).getPollwinner();\nif (chg.changed(pi, ev.getPollWinner(), ival)) {\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\n\nev.setPollWinner(ival);\n}\nbreak;\ncase PRIORITY:\n\/* ------------------- Priority -------------------- *\/\nival = ((Priority)prop).getLevel();\nif (chg.changed(pi, ev.getPriority(), ival)) {\nev.setPriority(ival);\n}\nbreak;\ncase RDATE:\n\/* ------------------- RDate -------------------- *\/\nchg.addValues(pi,\nIcalUtil.makeDateTimes((DateListProperty)prop));\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\n\nbreak;\ncase RECURRENCE_ID:\n\/* ------------------- RecurrenceID -------------------- *\/\n\/\/ Done above\nbreak;\ncase RELATED_TO:\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\n\n\/* ------------------- RelatedTo -------------------- *\/\nfinal RelatedTo irelto = (RelatedTo)prop;\nfinal BwRelatedTo relto = new BwRelatedTo();\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\n\nfinal String parval = IcalUtil.getParameterVal(irelto,\n\"RELTYPE\");\nif (parval != null) {\nrelto.setRelType(parval);\n}\nrelto.setValue(irelto.getValue());\nif (chg.changed(pi, ev.getRelatedTo(), relto)) {\nev.setRelatedTo(relto);\n}\nbreak;\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\n\ncase REQUEST_STATUS:\n\/* ------------------- RequestStatus -------------------- *\/\nfinal BwRequestStatus rs = BwRequestStatus\n.fromRequestStatus((RequestStatus)prop);\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n\nchg.addValue(pi, rs);\nbreak;\ncase RESOURCES:\n\/* ------------------- Resources -------------------- *\/\nfinal TextList rl = ((Resources)prop).getResources();\nif (rl != null) {\n\/* Got some resources *\/\nlang = IcalUtil.getLang(prop);\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\n\nfor (final String s: rl) {\nfinal BwString rsrc = new BwString(lang,\ns);\nchg.addValue(pi, rsrc);\n}\n}\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\n\nbreak;\ncase RRULE:\n\/* ------------------- RRule -------------------- *\/\nchg.addValue(pi, pval);\nbreak;\ncase SEQUENCE:\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\n\/* ------------------- Sequence -------------------- *\/\nfinal int seq = ((Sequence)prop).getSequenceNo();\nif (seq != ev.getSequence()) {\nchg.changed(pi, ev.getSequence(), seq);\nev.setSequence(seq);\n}\nbreak;\ncase STATUS:\n\/* ------------------- Status -------------------- *\/\nif (chg.changed(pi, ev.getStatus(), pval)) {\nev.setStatus(pval);\n}\nbreak;\ncase SUMMARY:\n\/* ------------------- Summary -------------------- *\/\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\n\nif (chg.changed(pi, ev.getSummary(), pval)) {\nev.setSummary(pval);\n}\nbreak;\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n\ncase TRANSP:\n\/* ------------------- Transp -------------------- *\/\nif (chg.changed(pi,\nev.getPeruserTransparency(\ncb.getPrincipal()\n.getPrincipalRef()),\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\n\npval)) {\nfinal BwXproperty pu = ev.setPeruserTransparency(\ncb.getPrincipal().getPrincipalRef(),\npval);\nif (pu != null) {\nchg.addValue(PropertyInfoIndex.XPROP, pu);\n}\n}\nbreak;\ncase UID:\n\/* ------------------- Uid -------------------- *\/\n\/* We did this above *\/\nbreak;\ncase URL:\n\/* ------------------- Url -------------------- *\/\nif (chg.changed(pi, ev.getLink(), pval)) {\nev.setLink(pval);\n}\nbreak;\ncase XPROP:\n\/* ------------------------- x-property --------------------------- *\/\nfinal String name = prop.getName();\nif (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\nif (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\n\npval)) {\nev.setCost(pval);\n}\nbreak;\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\nif (checkCategory(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\nif (checkLocation(cb, chg, ev, prop)) {\nbreak;\n}\n}\nif (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\nif (checkContact(cb, chg, ev, null, pval)) {\nbreak;\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\n\n}\n}\n\/* See if this is an x-category that can be\nconverted to a real category\n*\/\nfinal XProperty xp = (XProperty)prop;\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(name,\nxp.getParameters()\n.toString(),\npval));\nbreak;\ndefault:\nif (logger.debug()) {\nlogger.debug(\"Unsupported property with index \" + pi +\n\"; class \" + prop.getClass() +\n\" and value \" + pval);\n}\n}\n}\n\/* =================== Process sub-components =============== *\/\nfinal ComponentList<Component> subComps;\nif (val instanceof ComponentContainer) {\nsubComps = ((ComponentContainer<Component>)val).getComponents();\n} else {\nsubComps = null;\n}\nfinal Set<Integer> pids;\nif (vpoll) {\npids = new TreeSet<>();\nfinal BwEvent vp = evinfo.getEvent();\nif (!Util.isEmpty(vp.getPollItems())) {\nvp.clearPollItems();\n}\n} else {\npids = null;\n}\nif (!Util.isEmpty(subComps)) {\nfor (final var subComp: subComps) {\nif (subComp instanceof Available) {\nif (!(val instanceof VAvailability)) {\n\nchg);\nif (!aresp.isOk()) {\nreturn Response.fromResponse(resp, aresp);\n}\ncontinue;\n}\nif (vpoll && (event || task)) {\nfinal var vresp = processCandidate((VPoll)val,\nsubComp,\nevinfo,\npids,\nchg);\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n\nif (!vresp.isOk()) {\nreturn Response.fromResponse(resp, vresp);\n}\ncontinue;\n}\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\n\nlogger.warn(\"Unimplemented Component object: \" + subComp);\n}\n}\n\/* Fix up timestamps. *\/\nif (ev.getCreated() == null) {\nif (ev.getLastmod() != null) {\nev.setCreated(ev.getLastmod());\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\n\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n} else {\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\n\nev.updateDtstamp();\nchg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\n}\nif (ev.getLastmod() == null) {\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\n\n\/\/ created cannot be null now\nev.setLastmod(ev.getCreated());\nchg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n}\nprocessTimezones(ev, ical, chg);\n\/* Remove any recipients and originator\n*\/\nif (ev.getRecipients() != null) {\nev.getRecipients().clear();\n}\nev.setOriginator(null);\nif (hasXparams.value) {\n\/* Save a text copy of the entire event as an x-property *\/\nfinal Component valCopy = val.copy();\n\/* Remove potentially large values *\/\nfinal Description desp = valCopy.getProperty(Property.DESCRIPTION);\nif (desp != null) {\ndesp.setValue(null);\n}\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n\nfinal Attach attachp = valCopy.getProperty(Property.ATTACH);\n\/\/ Don't store the entire attachment - we just need the parameters.\nif (attachp != null) {\nfinal Value v = attachp.getParameter(Parameter.VALUE);\nif (v != null) {\nattachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n}\n}\nchg.addValue(PropertyInfoIndex.XPROP,\nnew BwXproperty(BwXproperty.bedeworkIcal,\nnull,\nvalCopy.toString()));\n}\nchg.processChanges(ev, true, false);\nev.setRecurring(ev.isRecurringEntity());\nif (logger.debug()) {\nlogger.debug(chg.toString());\nlogger.debug(ev.toString());\n}\nif (masterEI != null) {\n\/\/ Just return notfound as this event is on its override list\nreturn Response.notFound(resp);\n}\nresp.setEntity(evinfo);\nreturn resp;\n} catch (final Throwable t) {\nif (logger.debug()) {\nlogger.error(t);\n}\nreturn Response.error(resp, t);\n}\n}","label":[1,0,1,0]}
{"id":7967,"original_code":"@GET\n  @Produces(MediaType.APPLICATION_JSON)\n  \/\/ FIXME Uncomment when overrides can be handled\n  \/\/ @OutSchema(\"wdk.users.get-by-id\")\n  public JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\n    UserBundle userBundle = getUserBundle(Access.PUBLIC);\n    List<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n        .getAccountDB().getUserPropertyNames();\n    return formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\n        getFlag(includePreferences), propDefs);\n  }","code":"@GET\n  @Produces(MediaType.APPLICATION_JSON)\n \n \n  public JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\n    UserBundle userBundle = getUserBundle(Access.PUBLIC);\n    List<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n        .getAccountDB().getUserPropertyNames();\n    return formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\n        getFlag(includePreferences), propDefs);\n  }","cleancode":"@get @produces(mediatype.application_json) public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public); list<userpropertyname> propdefs = getwdkmodel().getmodelconfig() .getaccountdb().getuserpropertynames(); return formatuser(userbundle.gettargetuser(), userbundle.issessionuser(), getflag(includepreferences), propdefs); }","comment":"\/\/ fixme uncomment when overrides can be handled \/\/ @outschema(\"wdk.users.get-by-id\")","repo":"EuPathDB-Infra\/WDK","code_context_2":"@GET\n@Produces(MediaType.APPLICATION_JSON)\n\/\/ FIXME Uncomment when overrides can be handled\n\/\/ @OutSchema(\"wdk.users.get-by-id\")\npublic JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\nUserBundle userBundle = getUserBundle(Access.PUBLIC);","code_context_10":"@GET\n@Produces(MediaType.APPLICATION_JSON)\n\/\/ FIXME Uncomment when overrides can be handled\n\/\/ @OutSchema(\"wdk.users.get-by-id\")\npublic JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\nUserBundle userBundle = getUserBundle(Access.PUBLIC);\nList<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n.getAccountDB().getUserPropertyNames();\nreturn formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\ngetFlag(includePreferences), propDefs);\n}","code_context_20":"@GET\n@Produces(MediaType.APPLICATION_JSON)\n\/\/ FIXME Uncomment when overrides can be handled\n\/\/ @OutSchema(\"wdk.users.get-by-id\")\npublic JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\nUserBundle userBundle = getUserBundle(Access.PUBLIC);\nList<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n.getAccountDB().getUserPropertyNames();\nreturn formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\ngetFlag(includePreferences), propDefs);\n}","label":[1,0,0,0]}
{"id":24418,"original_code":"public static void useDropper(PlayerEntity player, Object tank, int button) {\n            ItemStack stack = player.inventory.getItemStack();\n            if (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\n                return;\n            }\n            if (!stack.isEmpty()) {\n                FluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\n                if (tank instanceof IChemicalTank) {\n                    IChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\n                    if (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n                        \/\/It is actually a gas tank\n                        IChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\n                        Optional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                        if (capability.isPresent()) {\n                            IGasHandler gasHandlerItem = capability.get();\n                            if (gasHandlerItem.getGasTankCount() > 0) {\n                                \/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\n                                GasStack storedGas = gasHandlerItem.getGasInTank(0);\n                                if (!storedGas.isTypeEqual(gasTank.getStack())) {\n                                    return;\n                                }\n                                if (button == 0) { \/\/Insert gas into dropper\n                                    if (!storedFluid.isEmpty() || gasTank.isEmpty()) {\n                                        return;\n                                    }\n                                    GasStack gasInTank = gasTank.getStack();\n                                    GasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\n                                    int remainder = simulatedRemainder.getAmount();\n                                    int amount = gasInTank.getAmount();\n                                    if (remainder < amount) {\n                                        \/\/We are able to fit at least some of the gas from our tank into the item\n                                        GasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\n                                        if (!extractedGas.isEmpty()) {\n                                            \/\/If we were able to actually extract it from our tank, then insert it into the item\n                                            if (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n                                                \/\/TODO: Print warning\/error\n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 1) { \/\/Extract gas from dropper\n                                    if (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n                                        \/\/If the dropper has fluid or the tank interacting with is already full of gas\n                                        return;\n                                    }\n                                    GasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n                                    int gasInItemAmount = storedGas.getAmount();\n                                    int remainder = simulatedRemainder.getAmount();\n                                    if (remainder < gasInItemAmount) {\n                                        GasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\n                                        if (!extractedGas.isEmpty()) {\n                                            \/\/If we were able to actually extract it from the item, then insert it into our gas tank\n                                            if (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                                \/\/TODO: Print warning\/error\n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 2) { \/\/Dump the tank\n                                    gasTank.setEmpty();\n                                }\n                            }\n                        } else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n                            \/\/It is actually an infusion tank\n                            IChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n                            \/\/TODO: Implement at some point\n                        }\n                    }\n                    \/\/TODO: Handle other chemical tanks like maybe infusion tanks\n                } else if (tank instanceof IExtendedFluidTank) {\n                    IExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\n                    if (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n                        return;\n                    }\n                    GasStack storedGas = GasStack.EMPTY;\n                    Optional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                    if (gasCapability.isPresent()) {\n                        IGasHandler gasHandlerItem = gasCapability.get();\n                        if (gasHandlerItem.getGasTankCount() > 0) {\n                            storedGas = gasHandlerItem.getGasInTank(0);\n                        }\n                    }\n                    if (button == 2) { \/\/Dump the tank\n                        fluidTank.setEmpty();\n                    }\n                    Optional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\n                    if (!capability.isPresent()) {\n                        \/\/If something went wrong and we don't have a fluid handler on our tank, then fail\n                        return;\n                    }\n                    IFluidHandlerItem fluidHandlerItem = capability.get();\n                    if (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n                        \/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n                        \/\/If it isn't one of our fluid handlers fail\n                        return;\n                    }\n                    IExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\n                    if (itemFluidTank == null) {\n                        \/\/If something went wrong and we don't have a fluid tank fail\n                        return;\n                    }\n                    if (button == 0) { \/\/Insert fluid into dropper\n                        if (!storedGas.isEmpty() || fluidTank.isEmpty()) {\n                            return;\n                        }\n                        FluidStack fluidInTank = fluidTank.getFluid();\n                        FluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\n                        int remainder = simulatedRemainder.getAmount();\n                        int amount = fluidInTank.getAmount();\n                        if (remainder < amount) {\n                            \/\/We are able to fit at least some of the fluid from our tank into the item\n                            FluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!extractedFluid.isEmpty()) {\n                                \/\/If we were able to actually extract it from our tank, then insert it into the item\n                                if (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n                                    \/\/TODO: Print warning\/error\n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    } else if (button == 1) { \/\/Extract fluid from dropper\n                        if (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\n                            return;\n                        }\n                        FluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\n                        int fluidInItemAmount = storedFluid.getAmount();\n                        int remainder = simulatedRemainder.getAmount();\n                        if (remainder < fluidInItemAmount) {\n                            FluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!drainedGas.isEmpty()) {\n                                \/\/If we were able to actually extract it from the item, then insert it into our gas tank\n                                if (!fluidTank.insert(drainedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                    \/\/TODO: Print warning\/error\n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    }\n                }\n            }\n        }","code":"public static void useDropper(PlayerEntity player, Object tank, int button) {\n            ItemStack stack = player.inventory.getItemStack();\n            if (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\n                return;\n            }\n            if (!stack.isEmpty()) {\n                FluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\n                if (tank instanceof IChemicalTank) {\n                    IChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\n                    if (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n                       \n                        IChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\n                        Optional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                        if (capability.isPresent()) {\n                            IGasHandler gasHandlerItem = capability.get();\n                            if (gasHandlerItem.getGasTankCount() > 0) {\n                               \n                                GasStack storedGas = gasHandlerItem.getGasInTank(0);\n                                if (!storedGas.isTypeEqual(gasTank.getStack())) {\n                                    return;\n                                }\n                                if (button == 0) {\n                                    if (!storedFluid.isEmpty() || gasTank.isEmpty()) {\n                                        return;\n                                    }\n                                    GasStack gasInTank = gasTank.getStack();\n                                    GasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\n                                    int remainder = simulatedRemainder.getAmount();\n                                    int amount = gasInTank.getAmount();\n                                    if (remainder < amount) {\n                                       \n                                        GasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\n                                        if (!extractedGas.isEmpty()) {\n                                           \n                                            if (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n                                               \n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 1) {\n                                    if (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n                                       \n                                        return;\n                                    }\n                                    GasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n                                    int gasInItemAmount = storedGas.getAmount();\n                                    int remainder = simulatedRemainder.getAmount();\n                                    if (remainder < gasInItemAmount) {\n                                        GasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\n                                        if (!extractedGas.isEmpty()) {\n                                           \n                                            if (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                               \n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 2) {\n                                    gasTank.setEmpty();\n                                }\n                            }\n                        } else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n                           \n                            IChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n                           \n                        }\n                    }\n                   \n                } else if (tank instanceof IExtendedFluidTank) {\n                    IExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\n                    if (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n                        return;\n                    }\n                    GasStack storedGas = GasStack.EMPTY;\n                    Optional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                    if (gasCapability.isPresent()) {\n                        IGasHandler gasHandlerItem = gasCapability.get();\n                        if (gasHandlerItem.getGasTankCount() > 0) {\n                            storedGas = gasHandlerItem.getGasInTank(0);\n                        }\n                    }\n                    if (button == 2) {\n                        fluidTank.setEmpty();\n                    }\n                    Optional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\n                    if (!capability.isPresent()) {\n                       \n                        return;\n                    }\n                    IFluidHandlerItem fluidHandlerItem = capability.get();\n                    if (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n                       \n                       \n                        return;\n                    }\n                    IExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\n                    if (itemFluidTank == null) {\n                       \n                        return;\n                    }\n                    if (button == 0) {\n                        if (!storedGas.isEmpty() || fluidTank.isEmpty()) {\n                            return;\n                        }\n                        FluidStack fluidInTank = fluidTank.getFluid();\n                        FluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\n                        int remainder = simulatedRemainder.getAmount();\n                        int amount = fluidInTank.getAmount();\n                        if (remainder < amount) {\n                           \n                            FluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!extractedFluid.isEmpty()) {\n                               \n                                if (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n                                   \n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    } else if (button == 1) {\n                        if (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\n                            return;\n                        }\n                        FluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\n                        int fluidInItemAmount = storedFluid.getAmount();\n                        int remainder = simulatedRemainder.getAmount();\n                        if (remainder < fluidInItemAmount) {\n                            FluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!drainedGas.isEmpty()) {\n                               \n                                if (!fluidTank.insert(drainedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                   \n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    }\n                }\n            }\n        }","cleancode":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { if (!storedfluid.isempty() || gastank.getneeded() == 0) { return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; } } } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { return; } if (button == 0) { if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","comment":"\/\/it is actually a gas tank\n\/\/validate something didn't go terribly wrong and we actually do have the tank we expect to have\n\/\/insert gas into dropper\n\/\/we are able to fit at least some of the gas from our tank into the item\n\/\/if we were able to actually extract it from our tank, then insert it into the item\n\/\/todo: print warning\/error\n\/\/extract gas from dropper\n\/\/if the dropper has fluid or the tank interacting with is already full of gas\n\/\/if we were able to actually extract it from the item, then insert it into our gas tank\n\/\/todo: print warning\/error\n\/\/dump the tank\n\/\/it is actually an infusion tank\n\/\/todo: implement at some point\n\/\/todo: handle other chemical tanks like maybe infusion tanks\n\/\/dump the tank\n\/\/if something went wrong and we don't have a fluid handler on our tank, then fail\n\/\/todo: decide if we want to support someone replacing our fluid handler with another? \/\/if it isn't one of our fluid handlers fail\n\/\/if something went wrong and we don't have a fluid tank fail\n\/\/insert fluid into dropper\n\/\/we are able to fit at least some of the fluid from our tank into the item\n\/\/if we were able to actually extract it from our tank, then insert it into the item\n\/\/todo: print warning\/error\n\/\/extract fluid from dropper\n\/\/if we were able to actually extract it from the item, then insert it into our gas tank\n\/\/todo: print warning\/error","repo":"Chiefwright\/Mekanism","code_context_2":"IChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\n\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\n\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\n\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\n\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\n\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\n\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\n\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\nif (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\nreturn;\n\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);","code_context_10":"public static void useDropper(PlayerEntity player, Object tank, int button) {\nItemStack stack = player.inventory.getItemStack();\nif (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\nreturn;\n}\nif (!stack.isEmpty()) {\nFluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\nif (tank instanceof IChemicalTank) {\nIChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\n\nFluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\nif (tank instanceof IChemicalTank) {\nIChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\n\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\n\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\n\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\n\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\n\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\n\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\nif (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\nreturn;\n}\nFluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\nint fluidInItemAmount = storedFluid.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < fluidInItemAmount) {\nFluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!drainedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\n\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);","code_context_20":"public static void useDropper(PlayerEntity player, Object tank, int button) {\nItemStack stack = player.inventory.getItemStack();\nif (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\nreturn;\n}\nif (!stack.isEmpty()) {\nFluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\nif (tank instanceof IChemicalTank) {\nIChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\n\npublic static void useDropper(PlayerEntity player, Object tank, int button) {\nItemStack stack = player.inventory.getItemStack();\nif (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\nreturn;\n}\nif (!stack.isEmpty()) {\nFluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\nif (tank instanceof IChemicalTank) {\nIChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n\nItemStack stack = player.inventory.getItemStack();\nif (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\nreturn;\n}\nif (!stack.isEmpty()) {\nFluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\nif (tank instanceof IChemicalTank) {\nIChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\nif (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\n\/\/It is actually a gas tank\nIChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\nOptional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\n\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\n\nreturn;\n}\nGasStack storedGas = GasStack.EMPTY;\nOptional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\nif (gasCapability.isPresent()) {\nIGasHandler gasHandlerItem = gasCapability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\n\nif (gasHandlerItem.getGasTankCount() > 0) {\nstoredGas = gasHandlerItem.getGasInTank(0);\n}\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n\n}\nif (button == 2) { \/\/Dump the tank\nfluidTank.setEmpty();\n}\nOptional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\nif (!capability.isPresent()) {\n\/\/If something went wrong and we don't have a fluid handler on our tank, then fail\nreturn;\n}\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\nif (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\n\nIFluidHandlerItem fluidHandlerItem = capability.get();\nif (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n\/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n\/\/If it isn't one of our fluid handlers fail\nreturn;\n}\nIExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\nif (itemFluidTank == null) {\n\/\/If something went wrong and we don't have a fluid tank fail\nreturn;\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\nif (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\nreturn;\n}\nFluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\nint fluidInItemAmount = storedFluid.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < fluidInItemAmount) {\nFluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!drainedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\n\nif (capability.isPresent()) {\nIGasHandler gasHandlerItem = capability.get();\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n\n}\nif (button == 0) { \/\/Insert fluid into dropper\nif (!storedGas.isEmpty() || fluidTank.isEmpty()) {\nreturn;\n}\nFluidStack fluidInTank = fluidTank.getFluid();\nFluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\nint remainder = simulatedRemainder.getAmount();\nint amount = fluidInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the fluid from our tank into the item\nFluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!extractedFluid.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract fluid from dropper\nif (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\nreturn;\n}\nFluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\nint fluidInItemAmount = storedFluid.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < fluidInItemAmount) {\nFluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\nif (!drainedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!fluidTank.insert(drainedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n}\n}\n}\n}\n\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 2) { \/\/Dump the tank\ngasTank.setEmpty();\n}\n}\n} else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n\/\/It is actually an infusion tank\nIChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n\/\/TODO: Implement at some point\n}\n}\n\/\/TODO: Handle other chemical tanks like maybe infusion tanks\n} else if (tank instanceof IExtendedFluidTank) {\nIExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\nif (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n\nif (gasHandlerItem.getGasTankCount() > 0) {\n\/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\nGasStack storedGas = gasHandlerItem.getGasInTank(0);\nif (!storedGas.isTypeEqual(gasTank.getStack())) {\nreturn;\n}\nif (button == 0) { \/\/Insert gas into dropper\nif (!storedFluid.isEmpty() || gasTank.isEmpty()) {\nreturn;\n}\nGasStack gasInTank = gasTank.getStack();\nGasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\nint remainder = simulatedRemainder.getAmount();\nint amount = gasInTank.getAmount();\nif (remainder < amount) {\n\/\/We are able to fit at least some of the gas from our tank into the item\nGasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from our tank, then insert it into the item\nif (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n}\n}\n} else if (button == 1) { \/\/Extract gas from dropper\nif (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n\/\/If the dropper has fluid or the tank interacting with is already full of gas\nreturn;\n}\nGasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\nint gasInItemAmount = storedGas.getAmount();\nint remainder = simulatedRemainder.getAmount();\nif (remainder < gasInItemAmount) {\nGasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\nif (!extractedGas.isEmpty()) {\n\/\/If we were able to actually extract it from the item, then insert it into our gas tank\nif (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n\/\/TODO: Print warning\/error\n}\n((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);","label":[0,1,0,0]}

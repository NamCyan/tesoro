{"id":24576,"original_code":"private void addEntriesToMainManifest(Manifest manifest) {\n    Attributes attrs = manifest.getMainAttributes();\n    \/\/ If a manifest doesn't have a version, the other attributes won't get written out.  Lame.\n    attrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\n    for (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\n      attrs.put(entry.getKey(), entry.getValue());\n    }\n  }","code_wo_comment":"private void addEntriesToMainManifest(Manifest manifest) {\n    Attributes attrs = manifest.getMainAttributes();\n   \n    attrs.put(Attributes.Name.MANIFEST_VERSION, new Date().toString());\n    for (Map.Entry<Attributes.Name, String> entry : this.manifestEntries.entrySet()) {\n      attrs.put(entry.getKey(), entry.getValue());\n    }\n  }","cleancode":"private void addentriestomainmanifest(manifest manifest) { attributes attrs = manifest.getmainattributes(); attrs.put(attributes.name.manifest_version, new date().tostring()); for (map.entry<attributes.name, string> entry : this.manifestentries.entryset()) { attrs.put(entry.getkey(), entry.getvalue()); } }","repo":"DavidWhitlock\/PortlandStateJava","label":[0,0,1,0]}
{"id":32849,"original_code":"private boolean isTelLenthLegal(String tel) {\n        \/\/TODO: Replace this with your own logic\n        return tel.length() == 11;\n    }","code_wo_comment":"private boolean isTelLenthLegal(String tel) {\n       \n        return tel.length() == 11;\n    }","cleancode":"private boolean istellenthlegal(string tel) { return tel.length() == 11; }","repo":"Asucanc\/FishMail","label":[0,1,0,0]}
{"id":32850,"original_code":"private boolean isEmailValid(String email) {\n        \/\/TODO: Replace this with your own logic\n        return email.contains(\"@\")&&email.contains(\".\");\n    }","code_wo_comment":"private boolean isEmailValid(String email) {\n       \n        return email.contains(\"@\")&&email.contains(\".\");\n    }","cleancode":"private boolean isemailvalid(string email) { return email.contains(\"@\")&&email.contains(\".\"); }","repo":"Asucanc\/FishMail","label":[0,1,0,0]}
{"id":85,"original_code":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\n    if (moduleInfo.getIsBlocked()) {\n      return this;\n    }\n    \/\/ TODO(zachh): Support post-dial digits; consider using DialerPhoneNumber.\n    \/\/ Do not set PhoneAccountHandle so that regular PreCall logic will be used. The account used to\n    \/\/ place or receive the call should be ignored for voice calls.\n    CallIntentBuilder callIntentBuilder =\n        new CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n            .setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\n    modules.add(IntentModule.newCallModule(context, callIntentBuilder));\n    return this;\n  }","code_wo_comment":"public HistoryItemActionModulesBuilder addModuleForVoiceCall() {\n    if (moduleInfo.getIsBlocked()) {\n      return this;\n    }\n   \n   \n   \n    CallIntentBuilder callIntentBuilder =\n        new CallIntentBuilder(moduleInfo.getNormalizedNumber(), getCallInitiationType())\n            .setAllowAssistedDial(moduleInfo.getCanSupportAssistedDialing());\n    modules.add(IntentModule.newCallModule(context, callIntentBuilder));\n    return this;\n  }","cleancode":"public historyitemactionmodulesbuilder addmoduleforvoicecall() { if (moduleinfo.getisblocked()) { return this; } callintentbuilder callintentbuilder = new callintentbuilder(moduleinfo.getnormalizednumber(), getcallinitiationtype()) .setallowassisteddial(moduleinfo.getcansupportassisteddialing()); modules.add(intentmodule.newcallmodule(context, callintentbuilder)); return this; }","repo":"DerpGang\/packages_apps_Dialer","label":[0,1,0,0]}
{"id":16486,"original_code":"public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\n\t\tif(args.length != 4) {\n\t\t\tSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\tint k = Integer.valueOf(args[2]) ;\n\t\tint dim = Integer.valueOf(args[3]) ;\n\t\tJob init_job = Job.getInstance() ;\n\t\tConfiguration init_conf = init_job.getConfiguration();\n\t\tinit_conf.set(\"kmeans.k\", args[2]);\n\t\tinit_conf.set(\"kmeans.dim\", args[3]);\n\t\tinit_job.setJarByClass(KMean.class);\n\t\tinit_job.setJobName(\"clustered kmeans\");\n\t\tinit_job.setMapperClass(KMeanInitMapper.class);\n\t\tinit_job.setReducerClass(KMeanInitReducer.class);\n\t\tinit_job.setOutputKeyClass(IntWritable.class);\n\t\tinit_job.setOutputValueClass(Text.class);\n\t\tFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\t\t\/\/TODO check rewrite in future\n\t\tFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\n\t\tinit_job.waitForCompletion(true);\n\t\tdouble[][] old_centroids = new double[k][dim] ;\n\t\tint fi = 1 ;\n\t\tlong t1 =  System.currentTimeMillis() ;\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"start iteration\") ;\n\t\t\tJob kmean_cluster_jb = Job.getInstance() ;\n\t\t\tConfiguration conf = kmean_cluster_jb.getConfiguration() ;\n\t\t\tconf.set(\"kmeans.k\", args[2]);\n\t\t\tconf.set(\"kmeans.dim\", args[3]);\n\t\t\tkmean_cluster_jb.setJarByClass(KMean.class);\n\t\t\tkmean_cluster_jb.setJobName(\"clustered kmeans\");\n\t\t\tkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\n\t\t\tkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\n\t\t\tkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\n\t\t\tkmean_cluster_jb.setOutputValueClass(Text.class);\n\t\t\t\/\/ TODO check rewrite in future\n\t\t\tString uri =  args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\n\t\t\tConfiguration temp_conf = new Configuration();\n\t\t\tFileSystem fs = FileSystem.get(URI.create(uri), temp_conf); \n\t\t\tPath input_path = new Path(uri);\n\t\t\tFSDataInputStream input_stream = fs.open(input_path);\n\t\t\tBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\n\t\t\tdouble total_dis = 0 ;\n\t\t\tdouble[][] new_centroids = new double[k][dim] ;\n\t\t\tfor(int i = 0 ; i < k ; i++) {\t\n\t\t\t\tString line = input_buffer.readLine() ;\n\t\t\t\tif(line == null) {\n\t\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\t\tnew_centroids[i][j] = Double.valueOf(old_centroids[i][j]) ;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\t\n\t\t\t\tint key = Integer.valueOf(line.split(\"\\t\")[0]) ;\n\t\t\t\tString[] new_centroid = line.split(\"\\t\")[1].split(\",\") ;\n\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\tnew_centroids[key][j] = Double.valueOf(new_centroid[j]) ;\n\t\t\t\t\ttotal_dis += Math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ;\n\t\t\t\t}\n\t\t\t\tconf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]);\n\t\t\t}\n\t\t\tdouble threshold = Math.pow(0.001 ,2) * k * dim  ;\n\t\t\tif(total_dis < threshold)\n\t\t\t\tbreak ;\n\t\t\tFileInputFormat.addInputPath(kmean_cluster_jb, new Path(args[0]));\n\t\t\t\/\/TODO check rewrite in future\n\t\t\tFileOutputFormat.setOutputPath(kmean_cluster_jb, new Path(args[1] + \"_m_\" + Integer.toString(fi)));\n\t\t\tkmean_cluster_jb.waitForCompletion(true);\n\t\t\told_centroids = new_centroids;\n\t\t\tfi++ ;\n\t\t}\n\t\tlong t2 =  System.currentTimeMillis() ;\n\t\tSystem.out.println(\"\\n Time token by un-parallel is : \" + (t2-t1) + \"ms\");\n\t}","code_wo_comment":"public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException {\n\t\tif(args.length != 4) {\n\t\t\tSystem.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ;\n\t\t\tSystem.exit(-1);\n\t\t}\n\t\tint k = Integer.valueOf(args[2]) ;\n\t\tint dim = Integer.valueOf(args[3]) ;\n\t\tJob init_job = Job.getInstance() ;\n\t\tConfiguration init_conf = init_job.getConfiguration();\n\t\tinit_conf.set(\"kmeans.k\", args[2]);\n\t\tinit_conf.set(\"kmeans.dim\", args[3]);\n\t\tinit_job.setJarByClass(KMean.class);\n\t\tinit_job.setJobName(\"clustered kmeans\");\n\t\tinit_job.setMapperClass(KMeanInitMapper.class);\n\t\tinit_job.setReducerClass(KMeanInitReducer.class);\n\t\tinit_job.setOutputKeyClass(IntWritable.class);\n\t\tinit_job.setOutputValueClass(Text.class);\n\t\tFileInputFormat.addInputPath(init_job, new Path(args[0]));\n\t\n\t\tFileOutputFormat.setOutputPath(init_job, new Path(args[1] + \"_m_\" + Integer.toString(0)));\n\t\tinit_job.waitForCompletion(true);\n\t\tdouble[][] old_centroids = new double[k][dim] ;\n\t\tint fi = 1 ;\n\t\tlong t1 =  System.currentTimeMillis() ;\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"start iteration\") ;\n\t\t\tJob kmean_cluster_jb = Job.getInstance() ;\n\t\t\tConfiguration conf = kmean_cluster_jb.getConfiguration() ;\n\t\t\tconf.set(\"kmeans.k\", args[2]);\n\t\t\tconf.set(\"kmeans.dim\", args[3]);\n\t\t\tkmean_cluster_jb.setJarByClass(KMean.class);\n\t\t\tkmean_cluster_jb.setJobName(\"clustered kmeans\");\n\t\t\tkmean_cluster_jb.setMapperClass(KMeanIterationMapper.class);\n\t\t\tkmean_cluster_jb.setReducerClass(KMeanIterationReducer.class);\n\t\t\tkmean_cluster_jb.setOutputKeyClass(IntWritable.class);\n\t\t\tkmean_cluster_jb.setOutputValueClass(Text.class);\n\t\t\n\t\t\tString uri =  args[1] + \"_m_\" + Integer.toString(fi-1) + \"\/part-r-00000\";\n\t\t\tConfiguration temp_conf = new Configuration();\n\t\t\tFileSystem fs = FileSystem.get(URI.create(uri), temp_conf); \n\t\t\tPath input_path = new Path(uri);\n\t\t\tFSDataInputStream input_stream = fs.open(input_path);\n\t\t\tBufferedReader input_buffer = new BufferedReader(new InputStreamReader(input_stream));\n\t\t\tdouble total_dis = 0 ;\n\t\t\tdouble[][] new_centroids = new double[k][dim] ;\n\t\t\tfor(int i = 0 ; i < k ; i++) {\t\n\t\t\t\tString line = input_buffer.readLine() ;\n\t\t\t\tif(line == null) {\n\t\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\t\tnew_centroids[i][j] = Double.valueOf(old_centroids[i][j]) ;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue ;\n\t\t\t\t}\t\n\t\t\t\tint key = Integer.valueOf(line.split(\"\\t\")[0]) ;\n\t\t\t\tString[] new_centroid = line.split(\"\\t\")[1].split(\",\") ;\n\t\t\t\tfor(int j = 0 ; j < dim ; j++) {\n\t\t\t\t\tnew_centroids[key][j] = Double.valueOf(new_centroid[j]) ;\n\t\t\t\t\ttotal_dis += Math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ;\n\t\t\t\t}\n\t\t\t\tconf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]);\n\t\t\t}\n\t\t\tdouble threshold = Math.pow(0.001 ,2) * k * dim  ;\n\t\t\tif(total_dis < threshold)\n\t\t\t\tbreak ;\n\t\t\tFileInputFormat.addInputPath(kmean_cluster_jb, new Path(args[0]));\n\t\t\n\t\t\tFileOutputFormat.setOutputPath(kmean_cluster_jb, new Path(args[1] + \"_m_\" + Integer.toString(fi)));\n\t\t\tkmean_cluster_jb.waitForCompletion(true);\n\t\t\told_centroids = new_centroids;\n\t\t\tfi++ ;\n\t\t}\n\t\tlong t2 =  System.currentTimeMillis() ;\n\t\tSystem.out.println(\"\\n Time token by un-parallel is : \" + (t2-t1) + \"ms\");\n\t}","cleancode":"public static void main(string[] args) throws ioexception, classnotfoundexception, interruptedexception { if(args.length != 4) { system.out.print(\"args should be 2 : <inputpath> <outpath> <number of centroids> <dimensions> .\") ; system.exit(-1); } int k = integer.valueof(args[2]) ; int dim = integer.valueof(args[3]) ; job init_job = job.getinstance() ; configuration init_conf = init_job.getconfiguration(); init_conf.set(\"kmeans.k\", args[2]); init_conf.set(\"kmeans.dim\", args[3]); init_job.setjarbyclass(kmean.class); init_job.setjobname(\"clustered kmeans\"); init_job.setmapperclass(kmeaninitmapper.class); init_job.setreducerclass(kmeaninitreducer.class); init_job.setoutputkeyclass(intwritable.class); init_job.setoutputvalueclass(text.class); fileinputformat.addinputpath(init_job, new path(args[0])); fileoutputformat.setoutputpath(init_job, new path(args[1] + \"_m_\" + integer.tostring(0))); init_job.waitforcompletion(true); double[][] old_centroids = new double[k][dim] ; int fi = 1 ; long t1 = system.currenttimemillis() ; while(true) { system.out.print(\"start iteration\") ; job kmean_cluster_jb = job.getinstance() ; configuration conf = kmean_cluster_jb.getconfiguration() ; conf.set(\"kmeans.k\", args[2]); conf.set(\"kmeans.dim\", args[3]); kmean_cluster_jb.setjarbyclass(kmean.class); kmean_cluster_jb.setjobname(\"clustered kmeans\"); kmean_cluster_jb.setmapperclass(kmeaniterationmapper.class); kmean_cluster_jb.setreducerclass(kmeaniterationreducer.class); kmean_cluster_jb.setoutputkeyclass(intwritable.class); kmean_cluster_jb.setoutputvalueclass(text.class); string uri = args[1] + \"_m_\" + integer.tostring(fi-1) + \"\/part-r-00000\"; configuration temp_conf = new configuration(); filesystem fs = filesystem.get(uri.create(uri), temp_conf); path input_path = new path(uri); fsdatainputstream input_stream = fs.open(input_path); bufferedreader input_buffer = new bufferedreader(new inputstreamreader(input_stream)); double total_dis = 0 ; double[][] new_centroids = new double[k][dim] ; for(int i = 0 ; i < k ; i++) { string line = input_buffer.readline() ; if(line == null) { for(int j = 0 ; j < dim ; j++) { new_centroids[i][j] = double.valueof(old_centroids[i][j]) ; } continue ; } int key = integer.valueof(line.split(\"\\t\")[0]) ; string[] new_centroid = line.split(\"\\t\")[1].split(\",\") ; for(int j = 0 ; j < dim ; j++) { new_centroids[key][j] = double.valueof(new_centroid[j]) ; total_dis += math.pow(new_centroids[key][j] - old_centroids[key][j], 2) ; } conf.set(\"kmeans.centroid\" + key, line.split(\"\\t\")[1]); } double threshold = math.pow(0.001 ,2) * k * dim ; if(total_dis < threshold) break ; fileinputformat.addinputpath(kmean_cluster_jb, new path(args[0])); fileoutputformat.setoutputpath(kmean_cluster_jb, new path(args[1] + \"_m_\" + integer.tostring(fi))); kmean_cluster_jb.waitforcompletion(true); old_centroids = new_centroids; fi++ ; } long t2 = system.currenttimemillis() ; system.out.println(\"\\n time token by un-parallel is : \" + (t2-t1) + \"ms\"); }","repo":"AmrHendy\/K-Means","label":[0,1,0,0]}
{"id":32941,"original_code":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n        \/\/ this can probably work on contentValues_\n        String paramFullPath = item.getFullPath();\n        for ( XTCEContainerContentEntry entry : contentList_ ) {\n            if ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n                 ( entry.getEntryType() != FieldType.ARGUMENT  ) ) {\n                continue;\n            }\n            XTCEContainerEntryValue valueObj = entry.getValue();\n            if ( entry.getValue() == null ) {\n                continue;\n            }\n            if ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\n                if ( valueObj.getOperator().equals( \"==\" ) == true ) { \/\/ NOI18N\n                    try {\n                        return Long.parseLong( valueObj.getCalibratedValue() );\n                    } catch ( NumberFormatException ex ) {\n                        warnings_.add(\n                            XTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) + \/\/ NOI18N\n                            \" \" + \/\/ NOI18N\n                            item.getName() +\n                            \" (\" + \/\/ NOI18N\n                            XTCEFunctions.getText( \"general_value\" ) + \/\/ NOI18N\n                            \" '\" + \/\/ NOI18N\n                            valueObj.getCalibratedValue() +\n                            \"')\" ); \/\/ NOI18N\n                        return 1;\n                    }\n                }\n                warnings_.add(\n                    XTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) + \/\/ NOI18N\n                    \" \" + \/\/ NOI18N\n                    item.getName() +\n                    \", \" + \/\/ NOI18N\n                    XTCEFunctions.getText( \"xml_dynamic_count_assume1\" ) ); \/\/ NOI18N\n                return 1;\n            }\n        }\n        return 1;\n    }","code_wo_comment":"protected long dynamicCountFromUserValue( XTCENamedObject item, String form ) {\n       \n        String paramFullPath = item.getFullPath();\n        for ( XTCEContainerContentEntry entry : contentList_ ) {\n            if ( ( entry.getEntryType() != FieldType.PARAMETER ) &&\n                 ( entry.getEntryType() != FieldType.ARGUMENT  ) ) {\n                continue;\n            }\n            XTCEContainerEntryValue valueObj = entry.getValue();\n            if ( entry.getValue() == null ) {\n                continue;\n            }\n            if ( entry.getItemFullPath().equals( paramFullPath ) == true ) {\n                if ( valueObj.getOperator().equals( \"==\" ) == true ) {\n                    try {\n                        return Long.parseLong( valueObj.getCalibratedValue() );\n                    } catch ( NumberFormatException ex ) {\n                        warnings_.add(\n                            XTCEFunctions.getText( \"xml_dynamic_count_numeric_error\" ) +\n                            \" \" +\n                            item.getName() +\n                            \" (\" +\n                            XTCEFunctions.getText( \"general_value\" ) +\n                            \" '\" +\n                            valueObj.getCalibratedValue() +\n                            \"')\" );\n                        return 1;\n                    }\n                }\n                warnings_.add(\n                    XTCEFunctions.getText( \"xml_dynamic_count_missing_error\" ) +\n                    \" \" +\n                    item.getName() +\n                    \", \" +\n                    XTCEFunctions.getText( \"xml_dynamic_count_assume1\" ) );\n                return 1;\n            }\n        }\n        return 1;\n    }","cleancode":"protected long dynamiccountfromuservalue( xtcenamedobject item, string form ) { string paramfullpath = item.getfullpath(); for ( xtcecontainercontententry entry : contentlist_ ) { if ( ( entry.getentrytype() != fieldtype.parameter ) && ( entry.getentrytype() != fieldtype.argument ) ) { continue; } xtcecontainerentryvalue valueobj = entry.getvalue(); if ( entry.getvalue() == null ) { continue; } if ( entry.getitemfullpath().equals( paramfullpath ) == true ) { if ( valueobj.getoperator().equals( \"==\" ) == true ) { try { return long.parselong( valueobj.getcalibratedvalue() ); } catch ( numberformatexception ex ) { warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_numeric_error\" ) + \" \" + item.getname() + \" (\" + xtcefunctions.gettext( \"general_value\" ) + \" '\" + valueobj.getcalibratedvalue() + \"')\" ); return 1; } } warnings_.add( xtcefunctions.gettext( \"xml_dynamic_count_missing_error\" ) + \" \" + item.getname() + \", \" + xtcefunctions.gettext( \"xml_dynamic_count_assume1\" ) ); return 1; } } return 1; }","repo":"CesarCoelho\/xtcetools","label":[1,0,0,0]}
{"id":32983,"original_code":"private static void registerFluids(BlockRegistry blockRegistry) {\n        \/\/ TODO Adjust properties\n        Fluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n                        .setTemperature(1000).setViscosity(200);\n        if(!(FluidRegistry.isFluidRegistered(steam))) { \/\/ Soft registration\n            FluidRegistry.registerFluid(steam);\n            FluidRegistry.addBucketForFluid(steam);\n        }\n        blockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\n        Fluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n                        .setGaseous(true).setDensity(-100);\n        FluidRegistry.registerFluid(sulphur_dioxide);\n        FluidRegistry.addBucketForFluid(sulphur_dioxide);\n        blockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\n                Material.WATER, SARBlocks.damageSourceGas, 2));\n        Fluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\n        FluidRegistry.registerFluid(sulphuric_acid);\n        FluidRegistry.addBucketForFluid(sulphuric_acid);\n        blockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\n                Material.WATER, SARBlocks.damageSourceAcid, 4));\n        \/\/ TODO TE compat?\n        Fluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n                        .setGaseous(true);\n        FluidRegistry.registerFluid(liquid_glowstone);\n        FluidRegistry.addBucketForFluid(liquid_glowstone);\n        blockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\n                Material.LAVA));\n        Fluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public String getLocalizedName(FluidStack stack) {\n                return I18n.translateToLocal(\n                        PotionUtils.getPotionTypeFromNBT(stack.tag).getNamePrefixed(\"potion.effect.\"));\n            }\n            @Override\n            public int getColor(FluidStack stack) {\n                return PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromTag(stack.tag));\n            }\n        };\n        FluidRegistry.registerFluid(potion);\n        FluidRegistry.addBucketForFluid(potion);\n        FluidRegistry\n                .registerFluid(new Fluid(\"slime\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                        new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\")) {\n                    @Override\n                    public int getColor() {\n                        return Color.GREEN.getRGB();\n                    }\n                });\n    }","code_wo_comment":"private static void registerFluids(BlockRegistry blockRegistry) {\n       \n        Fluid steam = new Fluid(\"steam\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/steam_flow\")).setGaseous(true)\n                        .setTemperature(1000).setViscosity(200);\n        if(!(FluidRegistry.isFluidRegistered(steam))) {\n            FluidRegistry.registerFluid(steam);\n            FluidRegistry.addBucketForFluid(steam);\n        }\n        blockRegistry.register(new BlockSARFluid(\"steam\", FluidRegistry.getFluid(\"steam\"), Material.LAVA));\n        Fluid sulphur_dioxide = new Fluid(\"sulphur_dioxide\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphur_dioxide_flow\")).setViscosity(250)\n                        .setGaseous(true).setDensity(-100);\n        FluidRegistry.registerFluid(sulphur_dioxide);\n        FluidRegistry.addBucketForFluid(sulphur_dioxide);\n        blockRegistry.register(new BlockDamagingFluid(\"sulphur_dioxide\", FluidRegistry.getFluid(\"sulphur_dioxide\"),\n                Material.WATER, SARBlocks.damageSourceGas, 2));\n        Fluid sulphuric_acid = new Fluid(\"sulphuric_acid\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/sulphuric_acid_flow\")).setViscosity(500);\n        FluidRegistry.registerFluid(sulphuric_acid);\n        FluidRegistry.addBucketForFluid(sulphuric_acid);\n        blockRegistry.register(new BlockAcidFluid(\"sulphuric_acid\", FluidRegistry.getFluid(\"sulphuric_acid\"),\n                Material.WATER, SARBlocks.damageSourceAcid, 4));\n       \n        Fluid liquid_glowstone = new Fluid(\"liquid_glowstone\",\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/liquid_glowstone_flow\")).setViscosity(2000)\n                        .setGaseous(true);\n        FluidRegistry.registerFluid(liquid_glowstone);\n        FluidRegistry.addBucketForFluid(liquid_glowstone);\n        blockRegistry.register(new BlockLiquidGlowstone(\"liquid_glowstone\", FluidRegistry.getFluid(\"liquid_glowstone\"),\n                Material.LAVA));\n        Fluid potion = new Fluid(\"potion\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution_flowing\")) {\n            @SuppressWarnings(\"deprecation\")\n            @Override\n            public String getLocalizedName(FluidStack stack) {\n                return I18n.translateToLocal(\n                        PotionUtils.getPotionTypeFromNBT(stack.tag).getNamePrefixed(\"potion.effect.\"));\n            }\n            @Override\n            public int getColor(FluidStack stack) {\n                return PotionUtils.getPotionColorFromEffectList(PotionUtils.getEffectsFromTag(stack.tag));\n            }\n        };\n        FluidRegistry.registerFluid(potion);\n        FluidRegistry.addBucketForFluid(potion);\n        FluidRegistry\n                .registerFluid(new Fluid(\"slime\", new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\"),\n                        new ResourceLocation(SteamAgeRevolution.MODID, \"fluids\/solution\")) {\n                    @Override\n                    public int getColor() {\n                        return Color.GREEN.getRGB();\n                    }\n                });\n    }","cleancode":"private static void registerfluids(blockregistry blockregistry) { fluid steam = new fluid(\"steam\", new resourcelocation(steamagerevolution.modid, \"fluids\/steam\"), new resourcelocation(steamagerevolution.modid, \"fluids\/steam_flow\")).setgaseous(true) .settemperature(1000).setviscosity(200); if(!(fluidregistry.isfluidregistered(steam))) { fluidregistry.registerfluid(steam); fluidregistry.addbucketforfluid(steam); } blockregistry.register(new blocksarfluid(\"steam\", fluidregistry.getfluid(\"steam\"), material.lava)); fluid sulphur_dioxide = new fluid(\"sulphur_dioxide\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphur_dioxide_flow\")).setviscosity(250) .setgaseous(true).setdensity(-100); fluidregistry.registerfluid(sulphur_dioxide); fluidregistry.addbucketforfluid(sulphur_dioxide); blockregistry.register(new blockdamagingfluid(\"sulphur_dioxide\", fluidregistry.getfluid(\"sulphur_dioxide\"), material.water, sarblocks.damagesourcegas, 2)); fluid sulphuric_acid = new fluid(\"sulphuric_acid\", new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid\"), new resourcelocation(steamagerevolution.modid, \"fluids\/sulphuric_acid_flow\")).setviscosity(500); fluidregistry.registerfluid(sulphuric_acid); fluidregistry.addbucketforfluid(sulphuric_acid); blockregistry.register(new blockacidfluid(\"sulphuric_acid\", fluidregistry.getfluid(\"sulphuric_acid\"), material.water, sarblocks.damagesourceacid, 4)); fluid liquid_glowstone = new fluid(\"liquid_glowstone\", new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone\"), new resourcelocation(steamagerevolution.modid, \"fluids\/liquid_glowstone_flow\")).setviscosity(2000) .setgaseous(true); fluidregistry.registerfluid(liquid_glowstone); fluidregistry.addbucketforfluid(liquid_glowstone); blockregistry.register(new blockliquidglowstone(\"liquid_glowstone\", fluidregistry.getfluid(\"liquid_glowstone\"), material.lava)); fluid potion = new fluid(\"potion\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution_flowing\")) { @suppresswarnings(\"deprecation\") @override public string getlocalizedname(fluidstack stack) { return i18n.translatetolocal( potionutils.getpotiontypefromnbt(stack.tag).getnameprefixed(\"potion.effect.\")); } @override public int getcolor(fluidstack stack) { return potionutils.getpotioncolorfromeffectlist(potionutils.geteffectsfromtag(stack.tag)); } }; fluidregistry.registerfluid(potion); fluidregistry.addbucketforfluid(potion); fluidregistry .registerfluid(new fluid(\"slime\", new resourcelocation(steamagerevolution.modid, \"fluids\/solution\"), new resourcelocation(steamagerevolution.modid, \"fluids\/solution\")) { @override public int getcolor() { return color.green.getrgb(); } }); }","repo":"BrassGoggledCoders\/SteamAgeRevolution","label":[1,1,0,0]}
{"id":33071,"original_code":"@Test void testUnquotedBuiltInFunctionNames() {\n    \/\/ TODO: Once Oracle is an officially supported dialect, this test\n    \/\/ should be moved to OracleValidatorTest.java.\n    final Sql oracle = sql(\"?\")\n        .withUnquotedCasing(Casing.TO_UPPER)\n        .withCaseSensitive(true);\n    \/\/ Built-in functions are always case-insensitive.\n    oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\n    oracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\n    oracle.sql(\"select current_time from dept\").ok();\n    oracle.sql(\"select Current_Time from dept\").ok();\n    oracle.sql(\"select CURRENT_TIME from dept\").ok();\n    oracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n  }","code_wo_comment":"@Test void testUnquotedBuiltInFunctionNames() {\n   \n   \n    final Sql oracle = sql(\"?\")\n        .withUnquotedCasing(Casing.TO_UPPER)\n        .withCaseSensitive(true);\n   \n    oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok();\n    oracle.sql(\"select COUNT(*), FLOOR(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt(*), FlOOr(2.5) from dept\").ok();\n    oracle.sql(\"select cOuNt (*), FlOOr (2.5) from dept\").ok();\n    oracle.sql(\"select current_time from dept\").ok();\n    oracle.sql(\"select Current_Time from dept\").ok();\n    oracle.sql(\"select CURRENT_TIME from dept\").ok();\n    oracle.sql(\"select \\\"count\\\"(*) from dept\").ok();\n  }","cleancode":"@test void testunquotedbuiltinfunctionnames() { final sql oracle = sql(\"?\") .withunquotedcasing(casing.to_upper) .withcasesensitive(true); oracle.sql(\"select count(*), sum(deptno), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count(*), floor(2.5) from dept\").ok(); oracle.sql(\"select count (*), floor (2.5) from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select current_time from dept\").ok(); oracle.sql(\"select \\\"count\\\"(*) from dept\").ok(); }","repo":"AndrewPochapsky\/calcite","label":[0,0,0,1]}
{"id":8635,"original_code":"private void tryConnectToIPv6() throws Exception {\n            Collection<Inet6Address> possibleInetAddresses = AddressUtil\n                    .getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\n            Level level = silent ? Level.FINEST : Level.INFO;\n            \/\/TODO: collection.toString() will likely not produce any useful output!\n            if (logger.isLoggable(level)) {\n                logger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n            }\n            boolean connected = false;\n            Exception error = null;\n            int configuredTimeoutMillis =\n                    ioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\n            int timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n                    ? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\n            for (Inet6Address inetAddress : possibleInetAddresses) {\n                try {\n                    tryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\n                    connected = true;\n                    break;\n                } catch (Exception e) {\n                    error = e;\n                }\n            }\n            if (!connected && error != null) {\n                \/\/ could not connect any of addresses\n                throw error;\n            }\n        }","code_wo_comment":"private void tryConnectToIPv6() throws Exception {\n            Collection<Inet6Address> possibleInetAddresses = AddressUtil\n                    .getPossibleInetAddressesFor((Inet6Address) address.getInetAddress());\n            Level level = silent ? Level.FINEST : Level.INFO;\n           \n            if (logger.isLoggable(level)) {\n                logger.log(level, \"Trying to connect possible IPv6 addresses: \" + possibleInetAddresses);\n            }\n            boolean connected = false;\n            Exception error = null;\n            int configuredTimeoutMillis =\n                    ioService.getSocketConnectTimeoutSeconds(endpointManager.getEndpointQualifier()) * MILLIS_PER_SECOND;\n            int timeoutMillis = configuredTimeoutMillis > 0 && configuredTimeoutMillis < Integer.MAX_VALUE\n                    ? configuredTimeoutMillis : DEFAULT_IPV6_SOCKET_CONNECT_TIMEOUT_SECONDS * MILLIS_PER_SECOND;\n            for (Inet6Address inetAddress : possibleInetAddresses) {\n                try {\n                    tryToConnect(new InetSocketAddress(inetAddress, address.getPort()), timeoutMillis);\n                    connected = true;\n                    break;\n                } catch (Exception e) {\n                    error = e;\n                }\n            }\n            if (!connected && error != null) {\n               \n                throw error;\n            }\n        }","cleancode":"private void tryconnecttoipv6() throws exception { collection<inet6address> possibleinetaddresses = addressutil .getpossibleinetaddressesfor((inet6address) address.getinetaddress()); level level = silent ? level.finest : level.info; if (logger.isloggable(level)) { logger.log(level, \"trying to connect possible ipv6 addresses: \" + possibleinetaddresses); } boolean connected = false; exception error = null; int configuredtimeoutmillis = ioservice.getsocketconnecttimeoutseconds(endpointmanager.getendpointqualifier()) * millis_per_second; int timeoutmillis = configuredtimeoutmillis > 0 && configuredtimeoutmillis < integer.max_value ? configuredtimeoutmillis : default_ipv6_socket_connect_timeout_seconds * millis_per_second; for (inet6address inetaddress : possibleinetaddresses) { try { trytoconnect(new inetsocketaddress(inetaddress, address.getport()), timeoutmillis); connected = true; break; } catch (exception e) { error = e; } } if (!connected && error != null) { throw error; } }","repo":"HugeOrangeDev\/hazelcast","label":[0,0,1,0]}
{"id":33242,"original_code":"public @NotNull FramedPacket retrieve() {\n        if (!PacketUtils.CACHED_PACKET) {\n            \/\/ TODO: Using a local buffer may be possible\n            return PacketUtils.allocateTrimmedPacket(packet());\n        }\n        SoftReference<FramedPacket> ref;\n        FramedPacket cache;\n        if (updated == 0 ||\n                ((ref = packet) == null ||\n                        (cache = ref.get()) == null)) {\n            cache = PacketUtils.allocateTrimmedPacket(packet());\n            this.packet = new SoftReference<>(cache);\n            UPDATER.compareAndSet(this, 0, 1);\n        }\n        return cache;\n    }","code_wo_comment":"public @NotNull FramedPacket retrieve() {\n        if (!PacketUtils.CACHED_PACKET) {\n           \n            return PacketUtils.allocateTrimmedPacket(packet());\n        }\n        SoftReference<FramedPacket> ref;\n        FramedPacket cache;\n        if (updated == 0 ||\n                ((ref = packet) == null ||\n                        (cache = ref.get()) == null)) {\n            cache = PacketUtils.allocateTrimmedPacket(packet());\n            this.packet = new SoftReference<>(cache);\n            UPDATER.compareAndSet(this, 0, 1);\n        }\n        return cache;\n    }","cleancode":"public @notnull framedpacket retrieve() { if (!packetutils.cached_packet) { return packetutils.allocatetrimmedpacket(packet()); } softreference<framedpacket> ref; framedpacket cache; if (updated == 0 || ((ref = packet) == null || (cache = ref.get()) == null)) { cache = packetutils.allocatetrimmedpacket(packet()); this.packet = new softreference<>(cache); updater.compareandset(this, 0, 1); } return cache; }","repo":"Avinesia-Union\/Minestom","label":[1,0,0,0]}
{"id":25149,"original_code":"@Override\n    @JRubyMethod(name = \"===\")\n    public RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n        \/\/ maybe we could handle java.lang === java.lang.reflect as well ?\n        return context.runtime.newBoolean(obj == this || isInstance(obj));\n    }","code_wo_comment":"@Override\n    @JRubyMethod(name = \"===\")\n    public RubyBoolean op_eqq(ThreadContext context, IRubyObject obj) {\n       \n        return context.runtime.newBoolean(obj == this || isInstance(obj));\n    }","cleancode":"@override @jrubymethod(name = \"===\") public rubyboolean op_eqq(threadcontext context, irubyobject obj) { return context.runtime.newboolean(obj == this || isinstance(obj)); }","repo":"DJRickyB\/jruby","label":[1,0,0,0]}
{"id":25166,"original_code":"@Test\n  public void testCEV() {\n    int timeSteps = 200;\/\/ TODO why is this working with so few steps?\n    int priceSteps = 100;\n    double lowerMoneyness = 0.3; \/\/ Not working well for ITM calls\n    double upperMoneyness = 3.0;\n    double volTol = 5e-3;\n    boolean print = false; \/\/ set to false before pushing\n    TESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n  }","code_wo_comment":"@Test\n  public void testCEV() {\n    int timeSteps = 200\n    int priceSteps = 100;\n    double lowerMoneyness = 0.3;\n    double upperMoneyness = 3.0;\n    double volTol = 5e-3;\n    boolean print = false;\n    TESTER.testCEV(SOLVER, timeSteps, priceSteps, lowerMoneyness, upperMoneyness, volTol, print);\n  }","cleancode":"@test public void testcev() { int timesteps = 200 int pricesteps = 100; double lowermoneyness = 0.3; double uppermoneyness = 3.0; double voltol = 5e-3; boolean print = false; tester.testcev(solver, timesteps, pricesteps, lowermoneyness, uppermoneyness, voltol, print); }","repo":"Incapture\/OG-Platform","label":[1,0,1,0]}
{"id":8849,"original_code":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\n\treturn performCalculationSX(srcX, srcY, 2, strategy); \/\/ TODO optimized algorhytm's.\n    }","code_wo_comment":"private static boolean performCalculationS2(int srcX, int srcY, RouteStrategy strategy) {\n\treturn performCalculationSX(srcX, srcY, 2, strategy);\n    }","cleancode":"private static boolean performcalculations2(int srcx, int srcy, routestrategy strategy) { return performcalculationsx(srcx, srcy, 2, strategy); }","repo":"CSS-Lletya\/open633","label":[1,0,0,0]}
{"id":25271,"original_code":"public void addQualifNoDip() throws IOException {\n        if (isValidIndCursus(QualifNonDiplomante.class, true)) {\n            \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n            pojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n            \/\/TODO: Fix this !!\n\/\/\t\t\t\torg.esupportail.commons.utils.strings.StringUtils\n\/\/\t\t\t\t\t.htmlToText(pojoQualif.getCursus().getComment()));\n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n                \/\/ajout en base\n                addOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n                \/\/Ajout dans l'individu courant\n                getCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n            }\n            pojoQualif.addCursus();\n            Collections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","code_wo_comment":"public void addQualifNoDip() throws IOException {\n        if (isValidIndCursus(QualifNonDiplomante.class, true)) {\n                      pojoQualif.getCursus().setComment(pojoQualif.getCursus().getComment());\n           \n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n               \n                addOneCursus(getCurrentInd().getIndividu(), pojoQualif.getCursus());\n               \n                getCurrentInd().getIndividu().getCursus().add(pojoQualif.getCursus());\n            }\n            pojoQualif.addCursus();\n            Collections.sort(pojoQualif.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","cleancode":"public void addqualifnodip() throws ioexception { if (isvalidindcursus(qualifnondiplomante.class, true)) { pojoqualif.getcursus().setcomment(pojoqualif.getcursus().getcomment()); if (actionenum.getwhataction().equals(actionenum.update_action)) { addonecursus(getcurrentind().getindividu(), pojoqualif.getcursus()); getcurrentind().getindividu().getcursus().add(pojoqualif.getcursus()); } pojoqualif.addcursus(); collections.sort(pojoqualif.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi","label":[0,0,1,0]}
{"id":25270,"original_code":"public void addCursusPro() throws IOException {\n        if (isValidIndCursus(CursusPro.class, true)) {\n            \/\/ on transforme le commentaire pour corriger les caract\u00e8res sp\u00e9ciaux\n            indCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n            \/\/TODO: Fix this !!\n\/\/\t\t\t\torg.esupportail.commons.utils.strings.StringUtils\n\/\/\t\t\t\t\t.htmlToText(indCursusPojo.getCursus().getComment()));\n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n                \/\/ajout en base\n                addOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n                \/\/Ajout dans l'individu courant\n                getCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n            }\n            indCursusPojo.addCursus();\n            Collections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","code_wo_comment":"public void addCursusPro() throws IOException {\n        if (isValidIndCursus(CursusPro.class, true)) {\n                      indCursusPojo.getCursus().setComment(indCursusPojo.getCursus().getComment());\n           \n            if (actionEnum.getWhatAction().equals(ActionEnum.UPDATE_ACTION)) {\n               \n                addOneCursus(getCurrentInd().getIndividu(), indCursusPojo.getCursus());\n               \n                getCurrentInd().getIndividu().getCursus().add(indCursusPojo.getCursus());\n            }\n            indCursusPojo.addCursus();\n            Collections.sort(indCursusPojo.getCursusList(), new ComparatorString(IndCursus.class));\n        }\n    }","cleancode":"public void addcursuspro() throws ioexception { if (isvalidindcursus(cursuspro.class, true)) { indcursuspojo.getcursus().setcomment(indcursuspojo.getcursus().getcomment()); if (actionenum.getwhataction().equals(actionenum.update_action)) { addonecursus(getcurrentind().getindividu(), indcursuspojo.getcursus()); getcurrentind().getindividu().getcursus().add(indcursuspojo.getcursus()); } indcursuspojo.addcursus(); collections.sort(indcursuspojo.getcursuslist(), new comparatorstring(indcursus.class)); } }","repo":"EsupPortail\/esup-opi","label":[0,0,1,0]}
{"id":17130,"original_code":"@Override\n    public void updateTask()\n    {\n        double distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\n        boolean canSeeTarget = true; \/\/this.host.getEntitySenses().canSee(this.attackTarget);\n        if (canSeeTarget)\n        {\n            ++this.targetTimeLost;\n        }\n        else\n        {\n            this.targetTimeLost = 0;\n        }\n        if (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n        {\n            this.host.getNavigator().clearPathEntity();\n        }\n        else\n        {\n            this.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n        }\n        this.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\n        float f;\n        if (--this.rangedAttackTime == 0)\n        {\n            if (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n            {\n                return;\n            }\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            \/\/ TODO replace this.rangedAttackEntityHost.attackEntityWithRangedAttack(thost.getAttackTarget(), f);\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n        else if (this.rangedAttackTime < 0)\n        {\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n    }","code_wo_comment":"@Override\n    public void updateTask()\n    {\n        double distanceFromTarget = this.host.getDistanceSq(host.getAttackTarget().posX, host.getAttackTarget().boundingBox.minY, host.getAttackTarget().posZ);\n        boolean canSeeTarget = true;\n        if (canSeeTarget)\n        {\n            ++this.targetTimeLost;\n        }\n        else\n        {\n            this.targetTimeLost = 0;\n        }\n        if (distanceFromTarget <= (double) this.followDistance && this.targetTimeLost >= 20)\n        {\n            this.host.getNavigator().clearPathEntity();\n        }\n        else\n        {\n            this.host.getNavigator().tryMoveToEntityLiving(host.getAttackTarget(), this.entityMoveSpeed);\n        }\n        this.host.getLookHelper().setLookPositionWithEntity(host.getAttackTarget(), 30.0F, 30.0F);\n        float f;\n        if (--this.rangedAttackTime == 0)\n        {\n            if (distanceFromTarget > (double) this.followDistance || !canSeeTarget)\n            {\n                return;\n            }\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n           \n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n        else if (this.rangedAttackTime < 0)\n        {\n            f = MathHelper.sqrt_double(distanceFromTarget) \/ this.attackRange;\n            this.rangedAttackTime = MathHelper.floor_float(f * (float) (this.maxRangedAttackTime - this.minRangedAttackTime) + (float) this.minRangedAttackTime);\n        }\n    }","cleancode":"@override public void updatetask() { double distancefromtarget = this.host.getdistancesq(host.getattacktarget().posx, host.getattacktarget().boundingbox.miny, host.getattacktarget().posz); boolean canseetarget = true; if (canseetarget) { ++this.targettimelost; } else { this.targettimelost = 0; } if (distancefromtarget <= (double) this.followdistance && this.targettimelost >= 20) { this.host.getnavigator().clearpathentity(); } else { this.host.getnavigator().trymovetoentityliving(host.getattacktarget(), this.entitymovespeed); } this.host.getlookhelper().setlookpositionwithentity(host.getattacktarget(), 30.0f, 30.0f); float f; if (--this.rangedattacktime == 0) { if (distancefromtarget > (double) this.followdistance || !canseetarget) { return; } f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } else if (this.rangedattacktime < 0) { f = mathhelper.sqrt_double(distancefromtarget) \/ this.attackrange; this.rangedattacktime = mathhelper.floor_float(f * (float) (this.maxrangedattacktime - this.minrangedattacktime) + (float) this.minrangedattacktime); } }","repo":"DarkGuardsman\/Artillects","label":[1,0,0,0]}
{"id":17208,"original_code":"protected void runOperations(String directoryPath, UseCase useCase) throws IOException {\n    log.info(System.lineSeparator() +\n      \"================================================\" + System.lineSeparator() +\n      \"     ____     ____________________     ____\" + System.lineSeparator() +\n      \"    \/    \\\\   \/  __|__    __|   _  \\\\   \/    \\\\\" + System.lineSeparator() +\n      \"   \/  \/\\\\  \\\\  \\\\  \\\\    |  |  |  |\/  \/  \/  \/\\\\  \\\\\" + System.lineSeparator() +\n      \"  \/  \/__\\\\  \\\\__\\\\  \\\\   |  |  |  |\\\\  \\\\ \/  \/__\\\\  \\\\\" + System.lineSeparator() +\n      \" \/__\/    \\\\__\\\\____\/   |__|  |__| \\\\__\\\\__\/    \\\\__\\\\\" + System.lineSeparator() +\n      \"================================================\");\n    log.info(\"Starting Astra run for directory: \" + directoryPath);\n    AtomicLong currentFileIndex = new AtomicLong();\n    AtomicLong currentPercentage = new AtomicLong();\n    log.info(\"Counting files (this may take a few seconds)\");\n    Instant startTime = Instant.now();\n    List<Path> javaFilesInDirectory;\n    try (Stream<Path> walk = Files.walk(Paths.get(directoryPath))) {\n      javaFilesInDirectory = walk\n          .filter(f -> f.toFile().isFile())\n          .filter(f -> f.getFileName().toString().endsWith(\"java\"))\n          .collect(Collectors.toList());\n    }\n    log.info(javaFilesInDirectory.size() + \" .java files in directory to review\");\n    log.info(\"Applying prefilters to files in directory\");\n    Predicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\n    List<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n        .filter(f -> prefilteringPredicate.test(f.toString()))\n        .collect(Collectors.toList());\n    log.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\n    final Set<? extends ASTOperation> operations = useCase.getOperations();\n    final String[] sources = useCase.getSources();\n    final String[] classPath = useCase.getClassPath();\n    for (Path f : filteredJavaFiles) {\n      \/\/ TODO AstUtils.getClassFilesForSource(f.toString()); - attempt to get only relevant classpaths for a given source file?\n      \/\/ TODO Naively we can multi-thread here (i.e. per file) but simple testing indicated that this slowed us down.\n      applyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\n      long newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\n      if (newPercentage != currentPercentage.get()) {\n        currentPercentage.set(newPercentage);\n        logProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n      }\n    }\n    log.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n  }","code_wo_comment":"protected void runOperations(String directoryPath, UseCase useCase) throws IOException {\n    log.info(System.lineSeparator() +\n      \"================================================\" + System.lineSeparator() +\n      \"     ____     ____________________     ____\" + System.lineSeparator() +\n      \"    \/    \\\\   \/  __|__    __|   _  \\\\   \/    \\\\\" + System.lineSeparator() +\n      \"   \/  \/\\\\  \\\\  \\\\  \\\\    |  |  |  |\/  \/  \/  \/\\\\  \\\\\" + System.lineSeparator() +\n      \"  \/  \/__\\\\  \\\\__\\\\  \\\\   |  |  |  |\\\\  \\\\ \/  \/__\\\\  \\\\\" + System.lineSeparator() +\n      \" \/__\/    \\\\__\\\\____\/   |__|  |__| \\\\__\\\\__\/    \\\\__\\\\\" + System.lineSeparator() +\n      \"================================================\");\n    log.info(\"Starting Astra run for directory: \" + directoryPath);\n    AtomicLong currentFileIndex = new AtomicLong();\n    AtomicLong currentPercentage = new AtomicLong();\n    log.info(\"Counting files (this may take a few seconds)\");\n    Instant startTime = Instant.now();\n    List<Path> javaFilesInDirectory;\n    try (Stream<Path> walk = Files.walk(Paths.get(directoryPath))) {\n      javaFilesInDirectory = walk\n          .filter(f -> f.toFile().isFile())\n          .filter(f -> f.getFileName().toString().endsWith(\"java\"))\n          .collect(Collectors.toList());\n    }\n    log.info(javaFilesInDirectory.size() + \" .java files in directory to review\");\n    log.info(\"Applying prefilters to files in directory\");\n    Predicate<String> prefilteringPredicate = useCase.getPrefilteringPredicate();\n    List<Path> filteredJavaFiles = javaFilesInDirectory.stream()\n        .filter(f -> prefilteringPredicate.test(f.toString()))\n        .collect(Collectors.toList());\n    log.info(filteredJavaFiles.size() + \" files remain after prefiltering\");\n    final Set<? extends ASTOperation> operations = useCase.getOperations();\n    final String[] sources = useCase.getSources();\n    final String[] classPath = useCase.getClassPath();\n    for (Path f : filteredJavaFiles) {\n     \n     \n      applyOperationsAndSave(new File(f.toString()), operations, sources, classPath);\n      long newPercentage = currentFileIndex.incrementAndGet() * 100 \/ filteredJavaFiles.size();\n      if (newPercentage != currentPercentage.get()) {\n        currentPercentage.set(newPercentage);\n        logProgress(currentFileIndex.get(), currentPercentage.get(), startTime, filteredJavaFiles.size());\n      }\n    }\n    log.info(getPrintableDuration(Duration.between(startTime, Instant.now())));\n  }","cleancode":"protected void runoperations(string directorypath, usecase usecase) throws ioexception { log.info(system.lineseparator() + \"================================================\" + system.lineseparator() + \" ____ ____________________ ____\" + system.lineseparator() + \" \/ \\\\ \/ __|__ __| _ \\\\ \/ \\\\\" + system.lineseparator() + \" \/ \/\\\\ \\\\ \\\\ \\\\ | | | |\/ \/ \/ \/\\\\ \\\\\" + system.lineseparator() + \" \/ \/__\\\\ \\\\__\\\\ \\\\ | | | |\\\\ \\\\ \/ \/__\\\\ \\\\\" + system.lineseparator() + \" \/__\/ \\\\__\\\\____\/ |__| |__| \\\\__\\\\__\/ \\\\__\\\\\" + system.lineseparator() + \"================================================\"); log.info(\"starting astra run for directory: \" + directorypath); atomiclong currentfileindex = new atomiclong(); atomiclong currentpercentage = new atomiclong(); log.info(\"counting files (this may take a few seconds)\"); instant starttime = instant.now(); list<path> javafilesindirectory; try (stream<path> walk = files.walk(paths.get(directorypath))) { javafilesindirectory = walk .filter(f -> f.tofile().isfile()) .filter(f -> f.getfilename().tostring().endswith(\"java\")) .collect(collectors.tolist()); } log.info(javafilesindirectory.size() + \" .java files in directory to review\"); log.info(\"applying prefilters to files in directory\"); predicate<string> prefilteringpredicate = usecase.getprefilteringpredicate(); list<path> filteredjavafiles = javafilesindirectory.stream() .filter(f -> prefilteringpredicate.test(f.tostring())) .collect(collectors.tolist()); log.info(filteredjavafiles.size() + \" files remain after prefiltering\"); final set<? extends astoperation> operations = usecase.getoperations(); final string[] sources = usecase.getsources(); final string[] classpath = usecase.getclasspath(); for (path f : filteredjavafiles) { applyoperationsandsave(new file(f.tostring()), operations, sources, classpath); long newpercentage = currentfileindex.incrementandget() * 100 \/ filteredjavafiles.size(); if (newpercentage != currentpercentage.get()) { currentpercentage.set(newpercentage); logprogress(currentfileindex.get(), currentpercentage.get(), starttime, filteredjavafiles.size()); } } log.info(getprintableduration(duration.between(starttime, instant.now()))); }","repo":"Arraying\/astra","label":[1,0,0,0]}
{"id":25405,"original_code":"public static FragmentHostManager get(View view) {\n        try {\n            return Dependency.get(FragmentService.class).getFragmentHostManager(view);\n        } catch (ClassCastException e) {\n            \/\/ TODO: Some auto handling here?\n            throw e;\n        }\n    }","code_wo_comment":"public static FragmentHostManager get(View view) {\n        try {\n            return Dependency.get(FragmentService.class).getFragmentHostManager(view);\n        } catch (ClassCastException e) {\n           \n            throw e;\n        }\n    }","cleancode":"public static fragmenthostmanager get(view view) { try { return dependency.get(fragmentservice.class).getfragmenthostmanager(view); } catch (classcastexception e) { throw e; } }","repo":"FrankKwok\/Oreo","label":[0,1,0,0]}
{"id":25463,"original_code":"public static void getText(Node node, StringBuilder sb) {\n\t\tNodeList children = node.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeType() == Node.TEXT_NODE) {\n\t\t\t\tsb.append(' '); \/\/ BUG: this is a hack\n\t\t\t\tsb.append(child.getNodeValue().trim());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tgetText(child, sb);\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"public static void getText(Node node, StringBuilder sb) {\n\t\tNodeList children = node.getChildNodes();\n\t\tfor (int i = 0; i < children.getLength(); i++) {\n\t\t\tNode child = children.item(i);\n\t\t\tif (child.getNodeType() == Node.TEXT_NODE) {\n\t\t\t\tsb.append(' ');\n\t\t\t\tsb.append(child.getNodeValue().trim());\n\t\t\t} else if (child.getNodeType() == Node.ELEMENT_NODE) {\n\t\t\t\tgetText(child, sb);\n\t\t\t}\n\t\t}\n\t}","cleancode":"public static void gettext(node node, stringbuilder sb) { nodelist children = node.getchildnodes(); for (int i = 0; i < children.getlength(); i++) { node child = children.item(i); if (child.getnodetype() == node.text_node) { sb.append(' '); sb.append(child.getnodevalue().trim()); } else if (child.getnodetype() == node.element_node) { gettext(child, sb); } } }","repo":"GoVivaceInc\/SpeechPlugin","label":[0,0,1,0]}
{"id":9271,"original_code":"private static String encodeComponent(String s, Charset charset) {\n        \/\/ TODO: Optimize me.\n        try {\n            return URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n        } catch (UnsupportedEncodingException ignored) {\n            throw new UnsupportedCharsetException(charset.name());\n        }\n    }","code_wo_comment":"private static String encodeComponent(String s, Charset charset) {\n       \n        try {\n            return URLEncoder.encode(s, charset.name()).replace(\"+\", \"%20\");\n        } catch (UnsupportedEncodingException ignored) {\n            throw new UnsupportedCharsetException(charset.name());\n        }\n    }","cleancode":"private static string encodecomponent(string s, charset charset) { try { return urlencoder.encode(s, charset.name()).replace(\"+\", \"%20\"); } catch (unsupportedencodingexception ignored) { throw new unsupportedcharsetexception(charset.name()); } }","repo":"AIPaaS\/sky-walking","label":[1,0,0,0]}
{"id":25701,"original_code":"@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.queue_list, container, false);\n        \/\/Instantiate Firebase objects\n        mDatabase = FirebaseDatabase.getInstance(); \/\/instance of Firebase object(i.e. database root object)\n        mDepositQueueReference = mDatabase.getReference(\"depositQueue\"); \/\/reference to depositQueue child object in root object\n        \/\/Instantiate other variables\n        queueListView = rootView.findViewById(R.id.list);\n        loadingIndicator = rootView.findViewById(R.id.loading_indicator);\n        final List<Payment> paymentsList = new ArrayList<Payment>();\n        postAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\n        queueListView.setAdapter(postAdapter);\n        \/**Delete this post adapter when you finish*\/\n\/\/        postAdapter.add(new Payment(\"James Blunt\", \"0149603509\", \"4500\", \"WAEC\", \"07033513241\", \"igwenus619@gmail.com\"));\n        \/\/Add ChildEventListener, so that changes made in the database are reflected\n        mChildEventListener = new ChildEventListener() {\n            @Override\n            public void onChildAdded(DataSnapshot dataSnapshot, String s) {\n                if (dataSnapshot.exists()) {\n                    loadingIndicator.setVisibility(View.GONE);\n                    Payment payment = dataSnapshot.getValue(Payment.class);\n                    \/**Uncomment this when you've finished*\/\n                    postAdapter.add(payment); \/\/here, you could use queueListView.add() too\n                }\n            }\n            @Override\n            public void onChildChanged(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onChildRemoved(DataSnapshot dataSnapshot) {\n            }\n            @Override\n            public void onChildMoved(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onCancelled(DatabaseError databaseError) {\n                Log.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n            }\n        };\n        mDepositQueueReference.addChildEventListener(mChildEventListener);\n        queueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                Payment payment = paymentsList.get(position);\n                Intent intent = new Intent(getActivity(), ConfirmDetailsActivity.class);\n                intent.putExtra(\"pushID\", payment.getPushID());\n                intent.putExtra(\"accountName\", payment.getAccountName());\n                intent.putExtra(\"accountNumber\", payment.getAccountNumber());\n                intent.putExtra(\"depositAmount\", payment.getDepositAmount());\n                intent.putExtra(\"depositorName\", payment.getDepositorName());\n                intent.putExtra(\"depositorPhoneNumber\", payment.getDepositorPhoneNumber());\n                intent.putExtra(\"depositorEmail\", payment.getDepositorEmail());\n                Log.e(TAG, \"Phone Number\" + payment.depositorPhoneNumber);\n                startActivity(intent);\n            }\n        });\n        return rootView;\n    }","code_wo_comment":"@Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        View rootView = inflater.inflate(R.layout.queue_list, container, false);\n       \n        mDatabase = FirebaseDatabase.getInstance();\n        mDepositQueueReference = mDatabase.getReference(\"depositQueue\");\n       \n        queueListView = rootView.findViewById(R.id.list);\n        loadingIndicator = rootView.findViewById(R.id.loading_indicator);\n        final List<Payment> paymentsList = new ArrayList<Payment>();\n        postAdapter = new QueueAdapter(getActivity(), R.layout.queue_view, paymentsList);\n        queueListView.setAdapter(postAdapter);\n       \n       \n        mChildEventListener = new ChildEventListener() {\n            @Override\n            public void onChildAdded(DataSnapshot dataSnapshot, String s) {\n                if (dataSnapshot.exists()) {\n                    loadingIndicator.setVisibility(View.GONE);\n                    Payment payment = dataSnapshot.getValue(Payment.class);\n                   \n                    postAdapter.add(payment);\n                }\n            }\n            @Override\n            public void onChildChanged(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onChildRemoved(DataSnapshot dataSnapshot) {\n            }\n            @Override\n            public void onChildMoved(DataSnapshot dataSnapshot, String s) {\n            }\n            @Override\n            public void onCancelled(DatabaseError databaseError) {\n                Log.e(TAG, \"postComments:onCancelled\", databaseError.toException());\n            }\n        };\n        mDepositQueueReference.addChildEventListener(mChildEventListener);\n        queueListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                Payment payment = paymentsList.get(position);\n                Intent intent = new Intent(getActivity(), ConfirmDetailsActivity.class);\n                intent.putExtra(\"pushID\", payment.getPushID());\n                intent.putExtra(\"accountName\", payment.getAccountName());\n                intent.putExtra(\"accountNumber\", payment.getAccountNumber());\n                intent.putExtra(\"depositAmount\", payment.getDepositAmount());\n                intent.putExtra(\"depositorName\", payment.getDepositorName());\n                intent.putExtra(\"depositorPhoneNumber\", payment.getDepositorPhoneNumber());\n                intent.putExtra(\"depositorEmail\", payment.getDepositorEmail());\n                Log.e(TAG, \"Phone Number\" + payment.depositorPhoneNumber);\n                startActivity(intent);\n            }\n        });\n        return rootView;\n    }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { view rootview = inflater.inflate(r.layout.queue_list, container, false); mdatabase = firebasedatabase.getinstance(); mdepositqueuereference = mdatabase.getreference(\"depositqueue\"); queuelistview = rootview.findviewbyid(r.id.list); loadingindicator = rootview.findviewbyid(r.id.loading_indicator); final list<payment> paymentslist = new arraylist<payment>(); postadapter = new queueadapter(getactivity(), r.layout.queue_view, paymentslist); queuelistview.setadapter(postadapter); mchildeventlistener = new childeventlistener() { @override public void onchildadded(datasnapshot datasnapshot, string s) { if (datasnapshot.exists()) { loadingindicator.setvisibility(view.gone); payment payment = datasnapshot.getvalue(payment.class); postadapter.add(payment); } } @override public void onchildchanged(datasnapshot datasnapshot, string s) { } @override public void onchildremoved(datasnapshot datasnapshot) { } @override public void onchildmoved(datasnapshot datasnapshot, string s) { } @override public void oncancelled(databaseerror databaseerror) { log.e(tag, \"postcomments:oncancelled\", databaseerror.toexception()); } }; mdepositqueuereference.addchildeventlistener(mchildeventlistener); queuelistview.setonitemclicklistener(new adapterview.onitemclicklistener() { @override public void onitemclick(adapterview<?> parent, view view, int position, long id) { payment payment = paymentslist.get(position); intent intent = new intent(getactivity(), confirmdetailsactivity.class); intent.putextra(\"pushid\", payment.getpushid()); intent.putextra(\"accountname\", payment.getaccountname()); intent.putextra(\"accountnumber\", payment.getaccountnumber()); intent.putextra(\"depositamount\", payment.getdepositamount()); intent.putextra(\"depositorname\", payment.getdepositorname()); intent.putextra(\"depositorphonenumber\", payment.getdepositorphonenumber()); intent.putextra(\"depositoremail\", payment.getdepositoremail()); log.e(tag, \"phone number\" + payment.depositorphonenumber); startactivity(intent); } }); return rootview; }","repo":"HemlockBane\/cashier-demo","label":[0,0,0,0]}
{"id":25731,"original_code":"public static void symbols(PrintWriter out,\n\t\t\tboolean emit_non_terms, boolean sym_interface)\n\t{\n\t\tterminal term;\n\t\tnon_terminal nt;\n\t\tString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\n\t\tlong start_time = System.currentTimeMillis();\n\t\t\/* top of file *\/\n\t\tout.println();\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println(\"\/\/ The following code was generated by \" + version.title_str);\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println();\n\t\temit_package(out);\n\t\t\/* class header *\/\n\t\tout.println(\"\/** CUP generated \" + class_or_interface +\n\t\t\t\t\" containing symbol constants. *\/\");\n\t\tout.println(\"public \" + class_or_interface + \" \" +\n\t\t\t\tsymbol_const_class_name + \" {\");\n\t\tout.println(\"  \/* terminals *\/\");\n\t\t\/* walk over the terminals *\/\/* later might sort these *\/\n\t\tfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n\t\t{\n\t\t\tterm = (terminal) e.nextElement();\n\t\t\t\/* output a constant decl for the terminal *\/\n\t\t\tout.println(\"  public static final int \" + term.name() + \" = \" +\n\t\t\t\t\tterm.index() + \";\");\n\t\t}\n\t\t\/* Emit names of terminals *\/\n\t\tout.println(\"  public static final String[] terminalNames = new String[] {\");\n\t\tfor (int i = 0; i < terminal.number(); i++) {\n\t\t\tout.print(\"  \\\"\");\n\t\t\tout.print(terminal.find(i).name());\n\t\t\tout.print(\"\\\"\");\n\t\t\tif (i < terminal.number() - 1) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println(\"  };\");\n\t\t\/* do the non terminals if they want them (parser doesn't need them) *\/\n\t\tif (emit_non_terms)\n\t\t{\n\t\t\tout.println();\n\t\t\tout.println(\"  \/* non terminals *\/\");\n\t\t\t\/* walk over the non terminals *\/\/* later might sort these *\/\n\t\t\tfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tnt = (non_terminal) e.nextElement();\n\t\t\t\t\/\/ ****\n\t\t\t\t\/\/ TUM Comment: here we could add a typesafe enumeration\n\t\t\t\t\/\/ ****\n\t\t\t\t\/* output a constant decl for the terminal *\/\n\t\t\t\tout.println(\"  static final int \" + nt.name() + \" = \" +\n\t\t\t\t\t\tnt.index() + \";\");\n\t\t\t}\n\t\t}\n\t\t\/* end of class *\/\n\t\tout.println(\"}\");\n\t\tout.println();\n\t\tsymbols_time = System.currentTimeMillis() - start_time;\n\t}","code_wo_comment":"public static void symbols(PrintWriter out,\n\t\t\tboolean emit_non_terms, boolean sym_interface)\n\t{\n\t\tterminal term;\n\t\tnon_terminal nt;\n\t\tString class_or_interface = (sym_interface) ? \"interface\" : \"class\";\n\t\tlong start_time = System.currentTimeMillis();\n\t\n\t\tout.println();\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println(\"\/\/ The following code was generated by \" + version.title_str);\n\t\tout.println(\"\/\/----------------------------------------------------\");\n\t\tout.println();\n\t\temit_package(out);\n\t\n\t\tout.println(\"\/** CUP generated \" + class_or_interface +\n\t\t\t\t\" containing symbol constants. *\/\");\n\t\tout.println(\"public \" + class_or_interface + \" \" +\n\t\t\t\tsymbol_const_class_name + \" {\");\n\t\tout.println(\"  \/* terminals *\/\");\n\t\n\t\tfor (Enumeration e = terminal.all(); e.hasMoreElements();)\n\t\t{\n\t\t\tterm = (terminal) e.nextElement();\n\t\t\n\t\t\tout.println(\"  public static final int \" + term.name() + \" = \" +\n\t\t\t\t\tterm.index() + \";\");\n\t\t}\n\t\n\t\tout.println(\"  public static final String[] terminalNames = new String[] {\");\n\t\tfor (int i = 0; i < terminal.number(); i++) {\n\t\t\tout.print(\"  \\\"\");\n\t\t\tout.print(terminal.find(i).name());\n\t\t\tout.print(\"\\\"\");\n\t\t\tif (i < terminal.number() - 1) {\n\t\t\t\tout.print(\",\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println(\"  };\");\n\t\n\t\tif (emit_non_terms)\n\t\t{\n\t\t\tout.println();\n\t\t\tout.println(\"  \/* non terminals *\/\");\n\t\t\n\t\t\tfor (Enumeration e = non_terminal.all(); e.hasMoreElements();)\n\t\t\t{\n\t\t\t\tnt = (non_terminal) e.nextElement();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tout.println(\"  static final int \" + nt.name() + \" = \" +\n\t\t\t\t\t\tnt.index() + \";\");\n\t\t\t}\n\t\t}\n\t\n\t\tout.println(\"}\");\n\t\tout.println();\n\t\tsymbols_time = System.currentTimeMillis() - start_time;\n\t}","cleancode":"public static void symbols(printwriter out, boolean emit_non_terms, boolean sym_interface) { terminal term; non_terminal nt; string class_or_interface = (sym_interface) ? \"interface\" : \"class\"; long start_time = system.currenttimemillis(); out.println(); out.println(\"\/\/----------------------------------------------------\"); out.println(\"\/\/ the following code was generated by \" + version.title_str); out.println(\"\/\/----------------------------------------------------\"); out.println(); emit_package(out); out.println(\"\/** cup generated \" + class_or_interface + \" containing symbol constants. *\/\"); out.println(\"public \" + class_or_interface + \" \" + symbol_const_class_name + \" {\"); out.println(\" \/* terminals *\/\"); for (enumeration e = terminal.all(); e.hasmoreelements();) { term = (terminal) e.nextelement(); out.println(\" public static final int \" + term.name() + \" = \" + term.index() + \";\"); } out.println(\" public static final string[] terminalnames = new string[] {\"); for (int i = 0; i < terminal.number(); i++) { out.print(\" \\\"\"); out.print(terminal.find(i).name()); out.print(\"\\\"\"); if (i < terminal.number() - 1) { out.print(\",\"); } out.println(); } out.println(\" };\"); if (emit_non_terms) { out.println(); out.println(\" \/* non terminals *\/\"); for (enumeration e = non_terminal.all(); e.hasmoreelements();) { nt = (non_terminal) e.nextelement(); out.println(\" static final int \" + nt.name() + \" = \" + nt.index() + \";\"); } } out.println(\"}\"); out.println(); symbols_time = system.currenttimemillis() - start_time; }","repo":"AsaiKen\/phpscan","label":[0,0,0,0]}
{"id":9378,"original_code":"private void transferData(RawPacket[] pkts)\n    {\n        for (int i = 0; i < pkts.length; i++)\n        {\n            RawPacket pkt = pkts[i];\n            pkts[i] = null;\n            if (pkt != null)\n            {\n                if (pkt.isInvalid())\n                {\n                    \/*\n                     * Return pkt to the pool because it is invalid and,\n                     * consequently, will not be made available to reading.\n                     *\/\n                    poolRawPacket(pkt);\n                }\n                else\n                {\n                    RawPacket oldPkt;\n                    synchronized (pktSyncRoot)\n                    {\n                        oldPkt = this.pkt;\n                        this.pkt = pkt;\n                    }\n                    if (oldPkt != null)\n                    {\n                        \/*\n                         * Return oldPkt to the pool because it was made\n                         * available to reading and it was not read.\n                         *\/\n                        poolRawPacket(oldPkt);\n                    }\n                    if (transferHandler != null && !closed)\n                    {\n                        try\n                        {\n                            transferHandler.transferData(this);\n                        }\n                        catch (Throwable t)\n                        {\n                            \/\/ XXX We cannot allow transferHandler to kill us.\n                            if (t instanceof InterruptedException)\n                            {\n                                Thread.currentThread().interrupt();\n                            }\n                            else if (t instanceof ThreadDeath)\n                            {\n                                throw (ThreadDeath) t;\n                            }\n                            else\n                            {\n                                logger.warn(\n                                    \"An RTP packet may have not been fully\"\n                                        + \" handled.\",\n                                    t);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"private void transferData(RawPacket[] pkts)\n    {\n        for (int i = 0; i < pkts.length; i++)\n        {\n            RawPacket pkt = pkts[i];\n            pkts[i] = null;\n            if (pkt != null)\n            {\n                if (pkt.isInvalid())\n                {\n                   \n                    poolRawPacket(pkt);\n                }\n                else\n                {\n                    RawPacket oldPkt;\n                    synchronized (pktSyncRoot)\n                    {\n                        oldPkt = this.pkt;\n                        this.pkt = pkt;\n                    }\n                    if (oldPkt != null)\n                    {\n                       \n                        poolRawPacket(oldPkt);\n                    }\n                    if (transferHandler != null && !closed)\n                    {\n                        try\n                        {\n                            transferHandler.transferData(this);\n                        }\n                        catch (Throwable t)\n                        {\n                           \n                            if (t instanceof InterruptedException)\n                            {\n                                Thread.currentThread().interrupt();\n                            }\n                            else if (t instanceof ThreadDeath)\n                            {\n                                throw (ThreadDeath) t;\n                            }\n                            else\n                            {\n                                logger.warn(\n                                    \"An RTP packet may have not been fully\"\n                                        + \" handled.\",\n                                    t);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void transferdata(rawpacket[] pkts) { for (int i = 0; i < pkts.length; i++) { rawpacket pkt = pkts[i]; pkts[i] = null; if (pkt != null) { if (pkt.isinvalid()) { poolrawpacket(pkt); } else { rawpacket oldpkt; synchronized (pktsyncroot) { oldpkt = this.pkt; this.pkt = pkt; } if (oldpkt != null) { poolrawpacket(oldpkt); } if (transferhandler != null && !closed) { try { transferhandler.transferdata(this); } catch (throwable t) { if (t instanceof interruptedexception) { thread.currentthread().interrupt(); } else if (t instanceof threaddeath) { throw (threaddeath) t; } else { logger.warn( \"an rtp packet may have not been fully\" + \" handled.\", t); } } } } } } }","repo":"GNUDimarik\/libjitsi","label":[1,0,0,0]}
{"id":34098,"original_code":"@Override\n    public void runOpMode() {\n        telemetry.addData(\"Status\", \"Initialized\");\n        telemetry.update();\n        left_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\n        right_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\n        front_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\n        front_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\n        Shooter = hardwareMap.dcMotor.get(\"Shooter\");\n        Conveyor = hardwareMap.dcMotor.get(\"Conveyor\");\n        clow_moter = hardwareMap.dcMotor.get(\"clow moter\");\n        Claw = hardwareMap.servo.get(\"Claw\");\n        touchfront = hardwareMap.touchSensor.get(\"touchfront\");\n        touch2 = hardwareMap.touchSensor.get(\"touch2\");\n        \/\/ values is a reference to the hsvValues array.\n        float[] hsvValues = new float[3];\n        final float values[] = hsvValues;\n        \/\/ bPrevState and bCurrState keep track of the previous and current state of the button\n        boolean bPrevState = false;\n        boolean bCurrState = false;\n        String mode=\"\";\n        Claw.setPosition(0);\n        right_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\n        right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        clow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        initVuforia();\n        initTfod();\n        \/**\n         * Activate TensorFlow Object Detection before we wait for the start command.\n         * Do it here so that the Camera Stream window will have the TensorFlow annotations visible.\n         **\/\n        if (tfod != null) {\n            tfod.activate();\n            \/\/ The TensorFlow software will scale the input images from the camera to a lower resolution.\n            \/\/ This can result in lower detection accuracy at longer distances (> 55cm or 22\").\n            \/\/ If your target is at distance greater than 50 cm (20\") you can adjust the magnification value\n            \/\/ to artificially zoom in to the center of image.  For best results, the \"aspectRatio\" argument\n            \/\/ should be set to the value of the images used to create the TensorFlow Object Detection model\n            \/\/ (typically 1.78 or 16\/9).\n            \/\/ Uncomment the following line if you want to adjust the magnification and\/or the aspect ratio of the input images.\n            \/\/tfod.setZoom(2.5, 1.78);\n        }\n        \/** Wait for the game to begin *\/\n        telemetry.addData(\">\", \"Press Play to start op mode\");\n        telemetry.update();\n        waitForStart();\n        if (opModeIsActive()) {\n            halt();\n            sleep(1000);\n            turnRight(0.5);\n            haltSequence(450);\n            goForward(.5);\n            haltSequence(150);\n            turnLeft(.5);\n            haltSequence(450);\n            goForward(0.4);\n            sleep(450);\n            halt();\n            sleep(1000);\n            telemetry.addData(\"Status\", \"Started\");\n            telemetry.update();\n            if (tfod != null) {\n                \/\/ getUpdatedRecognitions() will return null if no new information is available since\n                \/\/ the last time that call was made.\n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    if (updatedRecognitions.size() == 0) {\n                        mode = \"A\";\n                    }\n                    \/\/ step through the list of recognitions and display boundary info.\n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                        if (recognition.getLabel() ==\"Quad\"){\n                            mode = \"C\";\n                        } else {\n                            mode = \"B\";\n                        }\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getLeft(), recognition.getTop());\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getRight(), recognition.getBottom());\n                    }\n                    \/\/telemetry.addData(String.format(\"Mode (%s)\", mode), \"\");\n                    telemetry.update();\n                    sleep(2000);\n                }\n            }\n        }\n        \/\/ go somewhere based on mode\n            if (mode == \"A\") {\n                doModeA();\n            } else if (mode == \"B\") {\n                doModeB();\n            } else if (mode == \"C\") {\n                doModeC();\n            } else {\n                \/\/ not sure what to do here\n            }\n        if (tfod != null) {\n             tfod.shutdown();\n        }\n    }","code_wo_comment":"@Override\n    public void runOpMode() {\n        telemetry.addData(\"Status\", \"Initialized\");\n        telemetry.update();\n        left_mtr = hardwareMap.dcMotor.get(\"left_mtr\");\n        right_mtr = hardwareMap.dcMotor.get(\"right_mtr\");\n        front_left_mtr = hardwareMap.dcMotor.get(\"front_left_mtr\");\n        front_right_mtr = hardwareMap.dcMotor.get(\"front_right_mtr\");\n        Shooter = hardwareMap.dcMotor.get(\"Shooter\");\n        Conveyor = hardwareMap.dcMotor.get(\"Conveyor\");\n        clow_moter = hardwareMap.dcMotor.get(\"clow moter\");\n        Claw = hardwareMap.servo.get(\"Claw\");\n        touchfront = hardwareMap.touchSensor.get(\"touchfront\");\n        touch2 = hardwareMap.touchSensor.get(\"touch2\");\n       \n        float[] hsvValues = new float[3];\n        final float values[] = hsvValues;\n       \n        boolean bPrevState = false;\n        boolean bCurrState = false;\n        String mode=\"\";\n        Claw.setPosition(0);\n        right_mtr.setDirection(DcMotorSimple.Direction.REVERSE);\n        right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_right_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        front_left_mtr.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        clow_moter.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_right_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        front_left_mtr.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        initVuforia();\n        initTfod();\n       \n        if (tfod != null) {\n            tfod.activate();\n           \n           \n           \n           \n           \n           \n           \n           \n        }\n       \n        telemetry.addData(\">\", \"Press Play to start op mode\");\n        telemetry.update();\n        waitForStart();\n        if (opModeIsActive()) {\n            halt();\n            sleep(1000);\n            turnRight(0.5);\n            haltSequence(450);\n            goForward(.5);\n            haltSequence(150);\n            turnLeft(.5);\n            haltSequence(450);\n            goForward(0.4);\n            sleep(450);\n            halt();\n            sleep(1000);\n            telemetry.addData(\"Status\", \"Started\");\n            telemetry.update();\n            if (tfod != null) {\n               \n               \n                List<Recognition> updatedRecognitions = tfod.getUpdatedRecognitions();\n                if (updatedRecognitions != null) {\n                    telemetry.addData(\"# Object Detected\", updatedRecognitions.size());\n                    if (updatedRecognitions.size() == 0) {\n                        mode = \"A\";\n                    }\n                   \n                    int i = 0;\n                    for (Recognition recognition : updatedRecognitions) {\n                        telemetry.addData(String.format(\"label (%d)\", i), recognition.getLabel());\n                        if (recognition.getLabel() ==\"Quad\"){\n                            mode = \"C\";\n                        } else {\n                            mode = \"B\";\n                        }\n                        telemetry.addData(String.format(\"  left,top (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getLeft(), recognition.getTop());\n                        telemetry.addData(String.format(\"  right,bottom (%d)\", i), \"%.03f , %.03f\",\n                                recognition.getRight(), recognition.getBottom());\n                    }\n                   \n                    telemetry.update();\n                    sleep(2000);\n                }\n            }\n        }\n       \n            if (mode == \"A\") {\n                doModeA();\n            } else if (mode == \"B\") {\n                doModeB();\n            } else if (mode == \"C\") {\n                doModeC();\n            } else {\n               \n            }\n        if (tfod != null) {\n             tfod.shutdown();\n        }\n    }","cleancode":"@override public void runopmode() { telemetry.adddata(\"status\", \"initialized\"); telemetry.update(); left_mtr = hardwaremap.dcmotor.get(\"left_mtr\"); right_mtr = hardwaremap.dcmotor.get(\"right_mtr\"); front_left_mtr = hardwaremap.dcmotor.get(\"front_left_mtr\"); front_right_mtr = hardwaremap.dcmotor.get(\"front_right_mtr\"); shooter = hardwaremap.dcmotor.get(\"shooter\"); conveyor = hardwaremap.dcmotor.get(\"conveyor\"); clow_moter = hardwaremap.dcmotor.get(\"clow moter\"); claw = hardwaremap.servo.get(\"claw\"); touchfront = hardwaremap.touchsensor.get(\"touchfront\"); touch2 = hardwaremap.touchsensor.get(\"touch2\"); float[] hsvvalues = new float[3]; final float values[] = hsvvalues; boolean bprevstate = false; boolean bcurrstate = false; string mode=\"\"; claw.setposition(0); right_mtr.setdirection(dcmotorsimple.direction.reverse); right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_right_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); front_left_mtr.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); clow_moter.setzeropowerbehavior(dcmotor.zeropowerbehavior.brake); right_mtr.setmode(dcmotor.runmode.run_without_encoder); left_mtr.setmode(dcmotor.runmode.run_without_encoder); front_right_mtr.setmode(dcmotor.runmode.run_without_encoder); front_left_mtr.setmode(dcmotor.runmode.run_without_encoder); initvuforia(); inittfod(); if (tfod != null) { tfod.activate(); } telemetry.adddata(\">\", \"press play to start op mode\"); telemetry.update(); waitforstart(); if (opmodeisactive()) { halt(); sleep(1000); turnright(0.5); haltsequence(450); goforward(.5); haltsequence(150); turnleft(.5); haltsequence(450); goforward(0.4); sleep(450); halt(); sleep(1000); telemetry.adddata(\"status\", \"started\"); telemetry.update(); if (tfod != null) { list<recognition> updatedrecognitions = tfod.getupdatedrecognitions(); if (updatedrecognitions != null) { telemetry.adddata(\"# object detected\", updatedrecognitions.size()); if (updatedrecognitions.size() == 0) { mode = \"a\"; } int i = 0; for (recognition recognition : updatedrecognitions) { telemetry.adddata(string.format(\"label (%d)\", i), recognition.getlabel()); if (recognition.getlabel() ==\"quad\"){ mode = \"c\"; } else { mode = \"b\"; } telemetry.adddata(string.format(\" left,top (%d)\", i), \"%.03f , %.03f\", recognition.getleft(), recognition.gettop()); telemetry.adddata(string.format(\" right,bottom (%d)\", i), \"%.03f , %.03f\", recognition.getright(), recognition.getbottom()); } telemetry.update(); sleep(2000); } } } if (mode == \"a\") { domodea(); } else if (mode == \"b\") { domodeb(); } else if (mode == \"c\") { domodec(); } else { } if (tfod != null) { tfod.shutdown(); } }","repo":"FTC16694\/FtcRobotController","label":[1,1,0,0]}
{"id":9539,"original_code":"private void filter() {\n                String text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\n                if (text.length() == 0) {\n                    rowSorter.setRowFilter(null);\n                }\n                else {\n                \t\/\/TODO escape special characters\n                    rowSorter.setRowFilter(RowFilter.regexFilter(text));\n                }\n                if (rowSorter.getViewRowCount() == 0) {\n            \t\tingredientMappingLogPanel.removeAll();\n            \t\tingredientMappingResultPanel.removeAll();\n            \t\tmainFrame.getFrame().repaint();\n                }\n                if (ingredientsTable.getRowCount() > 0) {\n            \t\tListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\n            \t\tselectionModel.setSelectionInterval(0, 0);\n                }\n             }","code_wo_comment":"private void filter() {\n                String text = DrugMappingStringUtilities.safeToUpperCase(searchField.getText());\n                if (text.length() == 0) {\n                    rowSorter.setRowFilter(null);\n                }\n                else {\n                \n                    rowSorter.setRowFilter(RowFilter.regexFilter(text));\n                }\n                if (rowSorter.getViewRowCount() == 0) {\n            \t\tingredientMappingLogPanel.removeAll();\n            \t\tingredientMappingResultPanel.removeAll();\n            \t\tmainFrame.getFrame().repaint();\n                }\n                if (ingredientsTable.getRowCount() > 0) {\n            \t\tListSelectionModel selectionModel = ingredientsTable.getSelectionModel();\n            \t\tselectionModel.setSelectionInterval(0, 0);\n                }\n             }","cleancode":"private void filter() { string text = drugmappingstringutilities.safetouppercase(searchfield.gettext()); if (text.length() == 0) { rowsorter.setrowfilter(null); } else { rowsorter.setrowfilter(rowfilter.regexfilter(text)); } if (rowsorter.getviewrowcount() == 0) { ingredientmappinglogpanel.removeall(); ingredientmappingresultpanel.removeall(); mainframe.getframe().repaint(); } if (ingredientstable.getrowcount() > 0) { listselectionmodel selectionmodel = ingredientstable.getselectionmodel(); selectionmodel.setselectioninterval(0, 0); } }","repo":"EHDEN\/DrugMapping","label":[0,1,0,0]}
{"id":9553,"original_code":"public void move(double inches, double power) {\n        robotInstance.drivetrain.povDrive(power, 0);\n    }","code_wo_comment":"public void move(double inches, double power) {\n        robotInstance.drivetrain.povDrive(power, 0);\n    }","cleancode":"public void move(double inches, double power) { robotinstance.drivetrain.povdrive(power, 0); }","repo":"Centennial-FTC-Robotics\/Omnitech2021-22","label":[0,1,0,0]}
{"id":17777,"original_code":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n        \/\/ NOTE: alert must be (re-)created everytime, otherwise the following HACK doesn't work!\n        Alert alert = new Alert(AlertType.NONE);\n        alert.setAlertType(type);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(text);\n        \/\/ HACK: since it is not possible to set the owner of an javafx alert to\n        \/\/       a swing frame, we use the following approach to set the modality!\n        ((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n        \/\/ if no button was pressed, the dialog got canceled (ESC, close)\n        return alert.showAndWait().orElse(ButtonType.CANCEL);\n    }","code_wo_comment":"public static ButtonType showAlert(AlertType type, String title, String text, boolean onTop) {\n       \n        Alert alert = new Alert(AlertType.NONE);\n        alert.setAlertType(type);\n        alert.setTitle(title);\n        alert.setHeaderText(null);\n        alert.setContentText(text);\n       \n       \n        ((Stage) alert.getDialogPane().getScene().getWindow()).setAlwaysOnTop(onTop);\n       \n        return alert.showAndWait().orElse(ButtonType.CANCEL);\n    }","cleancode":"public static buttontype showalert(alerttype type, string title, string text, boolean ontop) { alert alert = new alert(alerttype.none); alert.setalerttype(type); alert.settitle(title); alert.setheadertext(null); alert.setcontenttext(text); ((stage) alert.getdialogpane().getscene().getwindow()).setalwaysontop(ontop); return alert.showandwait().orelse(buttontype.cancel); }","repo":"BerlinUnited\/NaoTH","label":[1,0,0,0]}
{"id":25987,"original_code":"@Override\n    public QueryProfileVariant clone() {\n        if (frozen) return this;\n       try {\n           QueryProfileVariant clone = (QueryProfileVariant)super.clone();\n           if (this.inherited != null)\n               clone.inherited = new ArrayList<>(this.inherited); \/\/ TODO: Deep clone is more correct, but probably does not matter in practice\n           clone.values = CopyOnWriteContent.deepClone(this.values);\n           return clone;\n       }\n       catch (CloneNotSupportedException e) {\n           throw new RuntimeException(e);\n       }\n    }","code_wo_comment":"@Override\n    public QueryProfileVariant clone() {\n        if (frozen) return this;\n       try {\n           QueryProfileVariant clone = (QueryProfileVariant)super.clone();\n           if (this.inherited != null)\n               clone.inherited = new ArrayList<>(this.inherited);\n           clone.values = CopyOnWriteContent.deepClone(this.values);\n           return clone;\n       }\n       catch (CloneNotSupportedException e) {\n           throw new RuntimeException(e);\n       }\n    }","cleancode":"@override public queryprofilevariant clone() { if (frozen) return this; try { queryprofilevariant clone = (queryprofilevariant)super.clone(); if (this.inherited != null) clone.inherited = new arraylist<>(this.inherited); clone.values = copyonwritecontent.deepclone(this.values); return clone; } catch (clonenotsupportedexception e) { throw new runtimeexception(e); } }","repo":"Anlon-Burke\/vespa","label":[1,0,0,0]}
{"id":9614,"original_code":"void loadUi(EmpSeries series) {\n        this.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\n        RecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\n        episodesCarousel.setAdapter(this.episodesCarouselAdapter);\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\n        episodesCarousel.setLayoutManager(layoutManager);\n        if(series.episodes == null) {\n            \/\/ TODO: get programs for a specific series && seasonID\n        }\n    }","code_wo_comment":"void loadUi(EmpSeries series) {\n        this.episodesCarouselAdapter = new EpisodesCarouselAdapter(this, series);\n        RecyclerView episodesCarousel = (RecyclerView) findViewById(R.id.carousel_series_items);\n        episodesCarousel.setAdapter(this.episodesCarouselAdapter);\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\n        episodesCarousel.setLayoutManager(layoutManager);\n        if(series.episodes == null) {\n           \n        }\n    }","cleancode":"void loadui(empseries series) { this.episodescarouseladapter = new episodescarouseladapter(this, series); recyclerview episodescarousel = (recyclerview) findviewbyid(r.id.carousel_series_items); episodescarousel.setadapter(this.episodescarouseladapter); linearlayoutmanager layoutmanager = new linearlayoutmanager(this, linearlayoutmanager.horizontal, false); episodescarousel.setlayoutmanager(layoutmanager); if(series.episodes == null) { } }","repo":"EricssonBroadcastServices\/AndroidClientReferenceApp","label":[0,1,0,0]}
{"id":17865,"original_code":"@Test(expected = AmazonClientException.class)\n    public void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\n        mockServer.setResponseFileName(\"sessionResponseExpired\");\n        mockServer.setAvailableSecurityCredentials(\"test-credentials\");\n        InstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\n        Thread.sleep(1000);\n        \/\/Hacky assert but we know that this mockServer will create an exception that will be logged, if there's no log entry\n        \/\/then there's no exception, which means that getCredentials didn't get called on the fetcher\n        assertThat(loggedEvents(), is(empty()));\n        credentialsProvider.getCredentials();\n    }","code_wo_comment":"@Test(expected = AmazonClientException.class)\n    public void canBeConfiguredToOnlyRefreshCredentialsAfterFirstCallToGetCredentials() throws InterruptedException {\n        mockServer.setResponseFileName(\"sessionResponseExpired\");\n        mockServer.setAvailableSecurityCredentials(\"test-credentials\");\n        InstanceProfileCredentialsProvider credentialsProvider = InstanceProfileCredentialsProvider.createAsyncRefreshingProvider(false);\n        Thread.sleep(1000);\n       \n       \n        assertThat(loggedEvents(), is(empty()));\n        credentialsProvider.getCredentials();\n    }","cleancode":"@test(expected = amazonclientexception.class) public void canbeconfiguredtoonlyrefreshcredentialsafterfirstcalltogetcredentials() throws interruptedexception { mockserver.setresponsefilename(\"sessionresponseexpired\"); mockserver.setavailablesecuritycredentials(\"test-credentials\"); instanceprofilecredentialsprovider credentialsprovider = instanceprofilecredentialsprovider.createasyncrefreshingprovider(false); thread.sleep(1000); assertthat(loggedevents(), is(empty())); credentialsprovider.getcredentials(); }","repo":"IBM\/ibm-cos-sdk-java","label":[1,0,0,0]}
{"id":17941,"original_code":"@Override\n    public ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\n        Request.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\n        List<CalendarModel> calendarModels = new ArrayList<>();\n        try (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\n            ResponseBody body = graphResponse.body();\n            if (body == null) {\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n            }\n            String graphBody = new String(body.bytes());\n            Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n            \/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n            \/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\n            if (rawCalendars == null) {\n                return new ExportResult<>(ExportResult.ResultType.END);\n            }\n            for (Map<String, Object> rawCalendar : rawCalendars) {\n                TransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\n                if (result.hasProblems()) {\n                    \/\/ discard\n                    \/\/ FIXME log problem\n                    continue;\n                }\n                calendarModels.add(result.getTransformed());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  \/\/ FIXME log error\n            return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n        }\n        List<CalendarEventModel> calendarEventModels = new ArrayList<>();\n        for (CalendarModel calendarModel : calendarModels) {\n            String id = calendarModel.getId();\n            Request.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\n            try (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\n                ResponseBody body = graphResponse.body();\n                if (body == null) {\n                    return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n                }\n                String graphBody = new String(body.bytes());\n                Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n                \/\/ TODO String nextLink = (String) graphMap.get(ODATA_NEXT);\n                \/\/ TODO ContinuationData continuationData = nextLink == null ? null : new ContinuationData(new GraphPagination(nextLink));\n                @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\n                if (rawEvents == null) {\n                    return new ExportResult<>(ExportResult.ResultType.END);\n                }\n                for (Map<String, Object> rawEvent : rawEvents) {\n                    Map<String, String> properties = new HashMap<>();\n                    properties.put(CALENDAR_ID, id);\n                    TransformResult<CalendarEventModel> result = transformerService.transform(CalendarEventModel.class, rawEvent, properties);\n                    if (result.hasProblems()) {\n                        \/\/ discard\n                        \/\/ FIXME log problem\n                        continue;\n                    }\n                    calendarEventModels.add(result.getTransformed());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();  \/\/ FIXME log error\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: \" + e.getMessage());\n            }\n        }\n        CalendarContainerResource resource = new CalendarContainerResource(calendarModels, calendarEventModels);\n        return new ExportResult<>(ExportResult.ResultType.END, resource, null);\n    }","code_wo_comment":"@Override\n    public ExportResult<CalendarContainerResource> export(TokenAuthData authData) {\n        Request.Builder calendarsBuilder = getBuilder(baseUrl + CALENDARS_URL, authData);\n        List<CalendarModel> calendarModels = new ArrayList<>();\n        try (Response graphResponse = client.newCall(calendarsBuilder.build()).execute()) {\n            ResponseBody body = graphResponse.body();\n            if (body == null) {\n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: response body was null\");\n            }\n            String graphBody = new String(body.bytes());\n            Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n           \n           \n            @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawCalendars = (List<Map<String, Object>>) graphMap.get(\"value\");\n            if (rawCalendars == null) {\n                return new ExportResult<>(ExportResult.ResultType.END);\n            }\n            for (Map<String, Object> rawCalendar : rawCalendars) {\n                TransformResult<CalendarModel> result = transformerService.transform(CalendarModel.class, rawCalendar);\n                if (result.hasProblems()) {\n                   \n                   \n                    continue;\n                }\n                calendarModels.add(result.getTransformed());\n            }\n        } catch (IOException e) {\n            e.printStackTrace(); \n            return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: \" + e.getMessage());\n        }\n        List<CalendarEventModel> calendarEventModels = new ArrayList<>();\n        for (CalendarModel calendarModel : calendarModels) {\n            String id = calendarModel.getId();\n            Request.Builder eventsBuilder = getBuilder(calculateEventsUrl(id), authData);\n            try (Response graphResponse = client.newCall(eventsBuilder.build()).execute()) {\n                ResponseBody body = graphResponse.body();\n                if (body == null) {\n                    return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving calendar: response body was null\");\n                }\n                String graphBody = new String(body.bytes());\n                Map graphMap = objectMapper.reader().forType(Map.class).readValue(graphBody);\n               \n               \n                @SuppressWarnings(\"unchecked\") List<Map<String, Object>> rawEvents = (List<Map<String, Object>>) graphMap.get(\"value\");\n                if (rawEvents == null) {\n                    return new ExportResult<>(ExportResult.ResultType.END);\n                }\n                for (Map<String, Object> rawEvent : rawEvents) {\n                    Map<String, String> properties = new HashMap<>();\n                    properties.put(CALENDAR_ID, id);\n                    TransformResult<CalendarEventModel> result = transformerService.transform(CalendarEventModel.class, rawEvent, properties);\n                    if (result.hasProblems()) {\n                       \n                       \n                        continue;\n                    }\n                    calendarEventModels.add(result.getTransformed());\n                }\n            } catch (IOException e) {\n                e.printStackTrace(); \n                return new ExportResult<>(ExportResult.ResultType.ERROR, \"Error retrieving contacts: \" + e.getMessage());\n            }\n        }\n        CalendarContainerResource resource = new CalendarContainerResource(calendarModels, calendarEventModels);\n        return new ExportResult<>(ExportResult.ResultType.END, resource, null);\n    }","cleancode":"@override public exportresult<calendarcontainerresource> export(tokenauthdata authdata) { request.builder calendarsbuilder = getbuilder(baseurl + calendars_url, authdata); list<calendarmodel> calendarmodels = new arraylist<>(); try (response graphresponse = client.newcall(calendarsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); @suppresswarnings(\"unchecked\") list<map<string, object>> rawcalendars = (list<map<string, object>>) graphmap.get(\"value\"); if (rawcalendars == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawcalendar : rawcalendars) { transformresult<calendarmodel> result = transformerservice.transform(calendarmodel.class, rawcalendar); if (result.hasproblems()) { continue; } calendarmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: \" + e.getmessage()); } list<calendareventmodel> calendareventmodels = new arraylist<>(); for (calendarmodel calendarmodel : calendarmodels) { string id = calendarmodel.getid(); request.builder eventsbuilder = getbuilder(calculateeventsurl(id), authdata); try (response graphresponse = client.newcall(eventsbuilder.build()).execute()) { responsebody body = graphresponse.body(); if (body == null) { return new exportresult<>(exportresult.resulttype.error, \"error retrieving calendar: response body was null\"); } string graphbody = new string(body.bytes()); map graphmap = objectmapper.reader().fortype(map.class).readvalue(graphbody); @suppresswarnings(\"unchecked\") list<map<string, object>> rawevents = (list<map<string, object>>) graphmap.get(\"value\"); if (rawevents == null) { return new exportresult<>(exportresult.resulttype.end); } for (map<string, object> rawevent : rawevents) { map<string, string> properties = new hashmap<>(); properties.put(calendar_id, id); transformresult<calendareventmodel> result = transformerservice.transform(calendareventmodel.class, rawevent, properties); if (result.hasproblems()) { continue; } calendareventmodels.add(result.gettransformed()); } } catch (ioexception e) { e.printstacktrace(); return new exportresult<>(exportresult.resulttype.error, \"error retrieving contacts: \" + e.getmessage()); } } calendarcontainerresource resource = new calendarcontainerresource(calendarmodels, calendareventmodels); return new exportresult<>(exportresult.resulttype.end, resource, null); }","repo":"29e7e280-0d1c-4bba-98fe-f7cd3ca7500a\/data-transfer-project","label":[0,0,1,0]}
{"id":9775,"original_code":"public static void main(String[] args) {\n\t\tFile dir = new File(\".\");\n\t\tArrays.stream(dir.listFiles()).forEach(file -> {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\t\/\/ Ouch, my fingers hurt! All this typing!\n\t\t});\n\t\t\/\/ TODO use Unchecked.consumer from JOOL library\n\t\t\/\/ SOLUTION(\n\t\tArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\n\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t}));\n\t\t\/\/ SOLUTION)\n\t}","code_wo_comment":"public static void main(String[] args) {\n\t\tFile dir = new File(\".\");\n\t\tArrays.stream(dir.listFiles()).forEach(file -> {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\n\t\t});\n\t\n\t\n\t\tArrays.stream(dir.listFiles()).forEach(Unchecked.consumer(file -> {\n\t\t\tSystem.out.println(file.getCanonicalPath());\n\t\t}));\n\t\n\t}","cleancode":"public static void main(string[] args) { file dir = new file(\".\"); arrays.stream(dir.listfiles()).foreach(file -> { try { system.out.println(file.getcanonicalpath()); } catch (ioexception e) { throw new runtimeexception(e); } }); arrays.stream(dir.listfiles()).foreach(unchecked.consumer(file -> { system.out.println(file.getcanonicalpath()); })); }","repo":"AdrianaDinca\/training","label":[0,0,0,0]}
{"id":1657,"original_code":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (replaceWith == null) {\n\t\t\treplaceWith = \"\";\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tresult.append(origStr.substring(0, index));\n\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\tresult.append(findThis);\n\t\t\t} else {\n\t\t\t\tresult.append(replaceWith);\n\t\t\t}\n\t\t\t\/\/ TODO :: improve speed by not calling substring but keeping track of start!\n\t\t\torigStr = origStr.substring(index + findThis.length());\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","code_wo_comment":"public static String replaceAllIfNotInsideTag(String origStr, String findThis, String replaceWith) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (replaceWith == null) {\n\t\t\treplaceWith = \"\";\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tresult.append(origStr.substring(0, index));\n\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\tresult.append(findThis);\n\t\t\t} else {\n\t\t\t\tresult.append(replaceWith);\n\t\t\t}\n\t\t\n\t\t\torigStr = origStr.substring(index + findThis.length());\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","cleancode":"public static string replaceallifnotinsidetag(string origstr, string findthis, string replacewith) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if (replacewith == null) { replacewith = \"\"; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { result.append(origstr.substring(0, index)); if ((index > 0) && origstr.charat(index - 1) == '>') { result.append(findthis); } else { result.append(replacewith); } origstr = origstr.substring(index + findthis.length()); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","repo":"ASofterSpace\/Toolbox-Java","label":[1,0,0,0]}
{"id":1659,"original_code":"private static String addAfterLinesContainingEx(String origStr, String findThis, String addThat,\n\t\tString eolMarker, boolean notInsideTag) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((addThat == null) || \"\".equals(addThat)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((eolMarker == null) || \"\".equals(eolMarker)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (\"\".equals(findThis)) {\n\t\t\treturn replaceAll(origStr, \"\\n\", \"\\n\" + addThat) + \"\\n\" + addThat;\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tif (notInsideTag) {\n\t\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\t\tindex = origStr.indexOf(findThis, index + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint eol = origStr.indexOf(eolMarker, index);\n\t\t\tif (eol < 0) {\n\t\t\t\tresult.append(origStr);\n\t\t\t\tresult.append(eolMarker);\n\t\t\t\torigStr = \"\";\n\t\t\t} else {\n\t\t\t\tresult.append(origStr.substring(0, eol + eolMarker.length()));\n\t\t\t\t\/\/ TODO :: improve speed by not calling substring but keeping track of start!\n\t\t\t\torigStr = origStr.substring(eol + eolMarker.length());\n\t\t\t}\n\t\t\tresult.append(addThat);\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","code_wo_comment":"private static String addAfterLinesContainingEx(String origStr, String findThis, String addThat,\n\t\tString eolMarker, boolean notInsideTag) {\n\t\tif (origStr == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (findThis == null) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((addThat == null) || \"\".equals(addThat)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif ((eolMarker == null) || \"\".equals(eolMarker)) {\n\t\t\treturn origStr;\n\t\t}\n\t\tif (\"\".equals(findThis)) {\n\t\t\treturn replaceAll(origStr, \"\\n\", \"\\n\" + addThat) + \"\\n\" + addThat;\n\t\t}\n\t\tStringBuilder result = new StringBuilder();\n\t\tint index = origStr.indexOf(findThis);\n\t\twhile (index >= 0) {\n\t\t\tif (notInsideTag) {\n\t\t\t\tif ((index > 0) && origStr.charAt(index - 1) == '>') {\n\t\t\t\t\tindex = origStr.indexOf(findThis, index + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint eol = origStr.indexOf(eolMarker, index);\n\t\t\tif (eol < 0) {\n\t\t\t\tresult.append(origStr);\n\t\t\t\tresult.append(eolMarker);\n\t\t\t\torigStr = \"\";\n\t\t\t} else {\n\t\t\t\tresult.append(origStr.substring(0, eol + eolMarker.length()));\n\t\t\t\n\t\t\t\torigStr = origStr.substring(eol + eolMarker.length());\n\t\t\t}\n\t\t\tresult.append(addThat);\n\t\t\tindex = origStr.indexOf(findThis);\n\t\t}\n\t\tresult.append(origStr);\n\t\treturn result.toString();\n\t}","cleancode":"private static string addafterlinescontainingex(string origstr, string findthis, string addthat, string eolmarker, boolean notinsidetag) { if (origstr == null) { return null; } if (findthis == null) { return origstr; } if ((addthat == null) || \"\".equals(addthat)) { return origstr; } if ((eolmarker == null) || \"\".equals(eolmarker)) { return origstr; } if (\"\".equals(findthis)) { return replaceall(origstr, \"\\n\", \"\\n\" + addthat) + \"\\n\" + addthat; } stringbuilder result = new stringbuilder(); int index = origstr.indexof(findthis); while (index >= 0) { if (notinsidetag) { if ((index > 0) && origstr.charat(index - 1) == '>') { index = origstr.indexof(findthis, index + 1); continue; } } int eol = origstr.indexof(eolmarker, index); if (eol < 0) { result.append(origstr); result.append(eolmarker); origstr = \"\"; } else { result.append(origstr.substring(0, eol + eolmarker.length())); origstr = origstr.substring(eol + eolmarker.length()); } result.append(addthat); index = origstr.indexof(findthis); } result.append(origstr); return result.tostring(); }","repo":"ASofterSpace\/Toolbox-Java","label":[1,0,0,0]}
{"id":9929,"original_code":"@Nullable\n  public String getPartitionColumn() {\n    return _partitionColumn;\n  }","code_wo_comment":"@Nullable\n  public String getPartitionColumn() {\n    return _partitionColumn;\n  }","cleancode":"@nullable public string getpartitioncolumn() { return _partitioncolumn; }","repo":"HoraceChoi95\/incubator-pinot","label":[0,1,0,0]}
{"id":10010,"original_code":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n    \/\/ We will be trying twice to find the right GeoPolygon, using alternate siding choices for the first polygon\n    \/\/ side.  While this looks like it might be 2x as expensive as it could be, there's really no other choice I can\n    \/\/ find.\n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n    \/\/ We don't know if this is the correct siding choice.  We will only know as we build the complex polygon.\n    \/\/ So we need to be prepared to try both possibilities.\n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n      \/\/ The testPoint was within the shape.  Was that intended?\n      if (testPointInside) {\n        \/\/ Yes: build it for real\n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n      \/\/ No: do the complement and return that.\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n      \/\/ The testPoint was outside the shape.  Was that intended?\n      if (!testPointInside) {\n        \/\/ Yes: return what we just built\n        return rval;\n      }\n      \/\/ No: return the complement\n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }","code_wo_comment":"static GeoPolygon generateGeoPolygon(final PlanetModel planetModel,\n    final List<GeoPoint> filteredPointList,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint, \n    final boolean testPointInside) {\n   \n   \n   \n    final SidedPlane initialPlane = new SidedPlane(testPoint, filteredPointList.get(0), filteredPointList.get(1));\n   \n   \n    GeoCompositePolygon rval = new GeoCompositePolygon(planetModel);\n    MutableBoolean seenConcave = new MutableBoolean();\n    if (buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, testPoint) == false) {\n     \n      if (testPointInside) {\n       \n        rval = new GeoCompositePolygon(planetModel);\n        seenConcave = new MutableBoolean();\n        buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, initialPlane, holes, null);\n        return rval;\n      }\n     \n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    } else {\n     \n      if (!testPointInside) {\n       \n        return rval;\n      }\n     \n      rval = new GeoCompositePolygon(planetModel);\n      seenConcave = new MutableBoolean();\n      buildPolygonShape(rval, seenConcave, planetModel, filteredPointList, new BitSet(), 0, 1, new SidedPlane(initialPlane), holes, null);\n      return rval;\n    }\n  }","cleancode":"static geopolygon generategeopolygon(final planetmodel planetmodel, final list<geopoint> filteredpointlist, final list<geopolygon> holes, final geopoint testpoint, final boolean testpointinside) { final sidedplane initialplane = new sidedplane(testpoint, filteredpointlist.get(0), filteredpointlist.get(1)); geocompositepolygon rval = new geocompositepolygon(planetmodel); mutableboolean seenconcave = new mutableboolean(); if (buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, testpoint) == false) { if (testpointinside) { rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, initialplane, holes, null); return rval; } rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } else { if (!testpointinside) { return rval; } rval = new geocompositepolygon(planetmodel); seenconcave = new mutableboolean(); buildpolygonshape(rval, seenconcave, planetmodel, filteredpointlist, new bitset(), 0, 1, new sidedplane(initialplane), holes, null); return rval; } }","repo":"AliGhaff\/testLucene","label":[1,0,0,0]}
{"id":10073,"original_code":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\n            throws ParseException {\n        \/\/ Note that that this could be a double byte character\n        \/\/ set - bug report by Masafumi Watanabe\n        computeContentLength(content);\n        if ((!computeContentLength)) {\n            if ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n                    || this.contentLengthHeader.getContentLength() < givenLength) {\n                throw new ParseException(\"Invalid content length \"\n                        + this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n            }\n        }\n        messageContent = null;\n        messageContentBytes = content;\n        messageContentObject = null;\n    }","code_wo_comment":"public void setMessageContent(byte[] content, boolean strict, boolean computeContentLength, int givenLength)\n            throws ParseException {\n       \n       \n        computeContentLength(content);\n        if ((!computeContentLength)) {\n            if ((!strict && this.contentLengthHeader.getContentLength() != givenLength)\n                    || this.contentLengthHeader.getContentLength() < givenLength) {\n                throw new ParseException(\"Invalid content length \"\n                        + this.contentLengthHeader.getContentLength() + \" \/ \" + givenLength, 0);\n            }\n        }\n        messageContent = null;\n        messageContentBytes = content;\n        messageContentObject = null;\n    }","cleancode":"public void setmessagecontent(byte[] content, boolean strict, boolean computecontentlength, int givenlength) throws parseexception { computecontentlength(content); if ((!computecontentlength)) { if ((!strict && this.contentlengthheader.getcontentlength() != givenlength) || this.contentlengthheader.getcontentlength() < givenlength) { throw new parseexception(\"invalid content length \" + this.contentlengthheader.getcontentlength() + \" \/ \" + givenlength, 0); } } messagecontent = null; messagecontentbytes = content; messagecontentobject = null; }","repo":"E-C-Group\/jsip","label":[0,0,1,0]}
{"id":2275,"original_code":"void doJob() {\n\t\t\/\/mRenderThread = new RenderThread(getResources(), surface, v);\n\t\t\/\/init\n\t\tfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\n\t\tSurfaceTexture surface = tv.getSurfaceTexture();\n\t\tTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\n\t\tView view = getWindow().getDecorView();\n\t\trt.init(surface);\n\t\trt.begin();\n\t\tint[] buf = new int[1];\n\t\tglGenTextures(1, buf, 0);\n\t\tint texName = buf[0];\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\t\tFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n\t\t\t\t* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\n\t\ttriangleVertices.put(mTriangleVerticesData).position(0);\n\t\tint program = buildProgram(sSimpleVS, sBasicFS \/*sSimpleFS*\/);\n\t\tint attribPosition = glGetAttribLocation(program, \"position\");\n\t\tcheckGlError();\n\t\tint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\n\t\tcheckGlError();\n\t\tint uniformTexture = glGetUniformLocation(program, \"texture\");\n\t\tcheckGlError();\n\t    int textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\n\t\tcheckGlError();\n\t\tSurfaceTexture tex = new SurfaceTexture(texName);\/\/TODO: wait for onFrameAvailable() ??\n\t\tHwUiRender render = HwUiRender.create(this);\n\t\trender.setSurface(tex);\n\t\t\/\/draw\n\t\tfor(int i=0;i<1;++i) {\n\t\tlong startTime = System.currentTimeMillis();\n\t\trender.drawToSurface(view);\n\t\trt.begin();\/\/TODO: replace on check & makecurrent\n\t\ttex.updateTexImage();\n\t\tfloat[] texTransform = new float[16];\n\t\ttex.getTransformMatrix(texTransform);\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tcheckGlError();\n\t\tglUseProgram(program);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribPosition);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribTexCoords);\n\t\tcheckGlError();\n\t\tglUniform1i(uniformTexture, 0);\n\t\tglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\n\t\tglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\n\t\tglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\t\trt.end();\n\t\tmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n\t\t}\n\t\trender.setSurface(null);\n\t\t\/\/rt.cleanup();\n\t}","code_wo_comment":"void doJob() {\n\t\n\t\n\t\tfinal TextureView tv = (TextureView) findViewById(R.id.textureView1);\n\t\tSurfaceTexture surface = tv.getSurfaceTexture();\n\t\tTexSurfaceRenderTarget rt = new TexSurfaceRenderTarget();\n\t\tView view = getWindow().getDecorView();\n\t\trt.init(surface);\n\t\trt.begin();\n\t\tint[] buf = new int[1];\n\t\tglGenTextures(1, buf, 0);\n\t\tint texName = buf[0];\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\t\tFloatBuffer triangleVertices = ByteBuffer.allocateDirect(mTriangleVerticesData.length\n\t\t\t\t* FLOAT_SIZE_BYTES).order(ByteOrder.nativeOrder()).asFloatBuffer();\n\t\ttriangleVertices.put(mTriangleVerticesData).position(0);\n\t\tint program = buildProgram(sSimpleVS, sBasicFS);\n\t\tint attribPosition = glGetAttribLocation(program, \"position\");\n\t\tcheckGlError();\n\t\tint attribTexCoords = glGetAttribLocation(program, \"texCoords\");\n\t\tcheckGlError();\n\t\tint uniformTexture = glGetUniformLocation(program, \"texture\");\n\t\tcheckGlError();\n\t    int textureTranformHandle = glGetUniformLocation(program, \"textureTransform\");\n\t\tcheckGlError();\n\t\tSurfaceTexture tex = new SurfaceTexture(texName)\n\t\tHwUiRender render = HwUiRender.create(this);\n\t\trender.setSurface(tex);\n\t\n\t\tfor(int i=0;i<1;++i) {\n\t\tlong startTime = System.currentTimeMillis();\n\t\trender.drawToSurface(view);\n\t\trt.begin()\n\t\ttex.updateTexImage();\n\t\tfloat[] texTransform = new float[16];\n\t\ttex.getTransformMatrix(texTransform);\n\t\tglBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES , texName);\n\t\tcheckGlError();\n\t\tglUseProgram(program);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribPosition);\n\t\tcheckGlError();\n\t\tglEnableVertexAttribArray(attribTexCoords);\n\t\tcheckGlError();\n\t\tglUniform1i(uniformTexture, 0);\n\t\tglUniformMatrix4fv(textureTranformHandle, 1, false, texTransform, 0);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);\n\t\tglVertexAttribPointer(attribPosition, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tcheckGlError();\n\t\ttriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);\n\t\tglVertexAttribPointer(attribTexCoords, 3, GL_FLOAT, false,\n\t\t\t\tTRIANGLE_VERTICES_DATA_STRIDE_BYTES, triangleVertices);\n\t\tglDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n\t\trt.end();\n\t\tmToggleButton.setText(\"\" + (System.currentTimeMillis() - startTime));\n\t\t}\n\t\trender.setSurface(null);\n\t\n\t}","cleancode":"void dojob() { final textureview tv = (textureview) findviewbyid(r.id.textureview1); surfacetexture surface = tv.getsurfacetexture(); texsurfacerendertarget rt = new texsurfacerendertarget(); view view = getwindow().getdecorview(); rt.init(surface); rt.begin(); int[] buf = new int[1]; glgentextures(1, buf, 0); int texname = buf[0]; glbindtexture(gles11ext.gl_texture_external_oes , texname); gltexparameterf(gl_texture_2d, gl_texture_min_filter, gl_nearest); gltexparameterf(gl_texture_2d, gl_texture_mag_filter, gl_linear); gltexparameteri(gl_texture_2d, gl_texture_wrap_s, gl_repeat); gltexparameteri(gl_texture_2d, gl_texture_wrap_t, gl_repeat); floatbuffer trianglevertices = bytebuffer.allocatedirect(mtriangleverticesdata.length * float_size_bytes).order(byteorder.nativeorder()).asfloatbuffer(); trianglevertices.put(mtriangleverticesdata).position(0); int program = buildprogram(ssimplevs, sbasicfs); int attribposition = glgetattriblocation(program, \"position\"); checkglerror(); int attribtexcoords = glgetattriblocation(program, \"texcoords\"); checkglerror(); int uniformtexture = glgetuniformlocation(program, \"texture\"); checkglerror(); int texturetranformhandle = glgetuniformlocation(program, \"texturetransform\"); checkglerror(); surfacetexture tex = new surfacetexture(texname) hwuirender render = hwuirender.create(this); render.setsurface(tex); for(int i=0;i<1;++i) { long starttime = system.currenttimemillis(); render.drawtosurface(view); rt.begin() tex.updateteximage(); float[] textransform = new float[16]; tex.gettransformmatrix(textransform); glbindtexture(gles11ext.gl_texture_external_oes , texname); checkglerror(); gluseprogram(program); checkglerror(); glenablevertexattribarray(attribposition); checkglerror(); glenablevertexattribarray(attribtexcoords); checkglerror(); gluniform1i(uniformtexture, 0); gluniformmatrix4fv(texturetranformhandle, 1, false, textransform, 0); checkglerror(); trianglevertices.position(triangle_vertices_data_pos_offset); glvertexattribpointer(attribposition, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); checkglerror(); trianglevertices.position(triangle_vertices_data_uv_offset); glvertexattribpointer(attribtexcoords, 3, gl_float, false, triangle_vertices_data_stride_bytes, trianglevertices); gldrawarrays(gl_triangle_strip, 0, 4); rt.end(); mtogglebutton.settext(\"\" + (system.currenttimemillis() - starttime)); } render.setsurface(null); }","repo":"ChGen\/AndroidGpuGraphicsTest","label":[0,1,0,0]}
{"id":18664,"original_code":"@Test\n    public void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\n        Event event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\n                tag(\"description\", Variant.ofString(\"This is the annotation\")).\n                tag(\"tags\", Variant.ofVector(Vector.ofContainers(\n                        Container.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\n                        Container.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\n                build();\n        Properties properties = new Properties();\n        properties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\n        EventToJsonFormatter formatter = new EventToJsonFormatter(properties);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        DocumentWriter.writeTo(stream, formatter.format(event));\n        assertEquals(\"{\" +\n                        \"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n                        \"\\\"environment\\\":\\\"staging\\\",\" +\n                        \"\\\"project\\\":\\\"test\\\",\" +\n                        \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n                        \"\\\"description\\\":\\\"This is the annotation\\\"\" +\n                        \"}\",\n                stream.toString(StandardCharsets.UTF_8.name())\n        );\n    }","code_wo_comment":"@Test\n    public void shouldAddNullSubprojectIfProjectIsDefined() throws IOException {\n        Event event = EventBuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\").\n                tag(\"description\", Variant.ofString(\"This is the annotation\")).\n                tag(\"tags\", Variant.ofVector(Vector.ofContainers(\n                        Container.builder().tag(\"key\", Variant.ofString(\"environment\")).tag(\"value\", Variant.ofString(\"staging\")).build(),\n                        Container.builder().tag(\"key\", Variant.ofString(\"project\")).tag(\"value\", Variant.ofString(\"test\")).build()))).\n                build();\n        Properties properties = new Properties();\n        properties.setProperty(\"file\", \"resource:\/\/annotation-event.mapping\");\n        EventToJsonFormatter formatter = new EventToJsonFormatter(properties);\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        DocumentWriter.writeTo(stream, formatter.format(event));\n        assertEquals(\"{\" +\n                        \"\\\"@timestamp\\\":\\\"1970-01-01T00:00:00.000000000Z\\\",\" +\n                        \"\\\"environment\\\":\\\"staging\\\",\" +\n                        \"\\\"project\\\":\\\"test\\\",\" +\n                        \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" +\n                        \"\\\"description\\\":\\\"This is the annotation\\\"\" +\n                        \"}\",\n                stream.toString(StandardCharsets.UTF_8.name())\n        );\n    }","cleancode":"@test public void shouldaddnullsubprojectifprojectisdefined() throws ioexception { event event = eventbuilder.create(0, \"11203800-63fd-11e8-83e2-3a587d902000\"). tag(\"description\", variant.ofstring(\"this is the annotation\")). tag(\"tags\", variant.ofvector(vector.ofcontainers( container.builder().tag(\"key\", variant.ofstring(\"environment\")).tag(\"value\", variant.ofstring(\"staging\")).build(), container.builder().tag(\"key\", variant.ofstring(\"project\")).tag(\"value\", variant.ofstring(\"test\")).build()))). build(); properties properties = new properties(); properties.setproperty(\"file\", \"resource:\/\/annotation-event.mapping\"); eventtojsonformatter formatter = new eventtojsonformatter(properties); bytearrayoutputstream stream = new bytearrayoutputstream(); documentwriter.writeto(stream, formatter.format(event)); assertequals(\"{\" + \"\\\"@timestamp\\\":\\\"1970-01-01t00:00:00.000000000z\\\",\" + \"\\\"environment\\\":\\\"staging\\\",\" + \"\\\"project\\\":\\\"test\\\",\" + \"\\\"tags\\\":\\\"environment=staging,project=test,subproject=null\\\",\" + \"\\\"description\\\":\\\"this is the annotation\\\"\" + \"}\", stream.tostring(standardcharsets.utf_8.name()) ); }","repo":"InHavk\/hercules","label":[1,0,0,0]}
{"id":18794,"original_code":"@Test\n        public void test() {\n                ChatDirector chatDirector = new ChatDirector(new File(\n                                this.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\n                assertTrue(chatDirector.load());\n                \/\/ Checking Chain metrics\n                assertTrue(chatDirector.getChains().size() == 5);\n                assertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\n                assertNotNull(chatDirector.getChains().get(\"loading-test\"));\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\"));\n                assertNotNull(chatDirector.getChains().get(\"echo-test\"));\n                assertNotNull(chatDirector.getChains().get(\"halt-test\"));\n                assertNotNull(chatDirector.getChains().get(\"reload-test\"));\n                \/\/ Checking Per Chain metrics\n                assertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\n                assertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\n                assertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\n                assertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n                \/\/ Checking Each item in chain\n                IItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"%CURRENT%\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(5);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"raw string\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(6);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(7);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(8);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(2);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(3);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the third value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"hello!\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<, but before that it was >%LAST%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\n                assertTrue(item instanceof ReloadItem);\n                \/\/ TODO: Preform a check for reload?\n        }","code_wo_comment":"@Test\n        public void test() {\n                ChatDirector chatDirector = new ChatDirector(new File(\n                                this.getClass().getClassLoader().getResource(\"modules\/common\/config.yml\").getFile()));\n                assertTrue(chatDirector.load());\n               \n                assertTrue(chatDirector.getChains().size() == 5);\n                assertTrue(chatDirector.getChains().containsKey(\"loading-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"breaking-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"echo-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"halt-test\"));\n                assertTrue(chatDirector.getChains().containsKey(\"reload-test\"));\n                assertNotNull(chatDirector.getChains().get(\"loading-test\"));\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\"));\n                assertNotNull(chatDirector.getChains().get(\"echo-test\"));\n                assertNotNull(chatDirector.getChains().get(\"halt-test\"));\n                assertNotNull(chatDirector.getChains().get(\"reload-test\"));\n               \n                assertNotNull(chatDirector.getChains().get(\"loading-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"breaking-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"echo-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"halt-test\").getItems());\n                assertNotNull(chatDirector.getChains().get(\"reload-test\").getItems());\n                assertTrue(chatDirector.getChains().get(\"loading-test\").getItems().size() == 9);\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").getItems().size() == 4);\n                assertTrue(chatDirector.getChains().get(\"echo-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"halt-test\").getItems().size() == 3);\n                assertTrue(chatDirector.getChains().get(\"reload-test\").getItems().size() == 1);\n                assertTrue(chatDirector.getChains().get(\"loading-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"breaking-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"echo-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"halt-test\").isValid());\n                assertTrue(chatDirector.getChains().get(\"reload-test\").isValid());\n               \n                IItem item = chatDirector.getChains().get(\"loading-test\").getItems().get(0);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(1);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(2);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(3);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(4);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"%CURRENT%\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(5);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"raw string\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(6);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(7);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"loading-test\").getItems().get(8);\n                assertTrue(item instanceof ReloadItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(2);\n                assertTrue(item instanceof BreakItem);\n                item = chatDirector.getChains().get(\"breaking-test\").getItems().get(3);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the third value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"hello!\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(1);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"echo-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This was >%CURRENT%<, but before that it was >%LAST%<\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(0);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the first value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(1);\n                assertTrue(item instanceof HaltItem);\n                item = chatDirector.getChains().get(\"halt-test\").getItems().get(2);\n                assertTrue(item instanceof EchoItem);\n                assertEquals(\"This is the second value\", ((EchoItem) item).format);\n                item = chatDirector.getChains().get(\"reload-test\").getItems().get(0);\n                assertTrue(item instanceof ReloadItem);\n               \n        }","cleancode":"@test public void test() { chatdirector chatdirector = new chatdirector(new file( this.getclass().getclassloader().getresource(\"modules\/common\/config.yml\").getfile())); asserttrue(chatdirector.load()); asserttrue(chatdirector.getchains().size() == 5); asserttrue(chatdirector.getchains().containskey(\"loading-test\")); asserttrue(chatdirector.getchains().containskey(\"breaking-test\")); asserttrue(chatdirector.getchains().containskey(\"echo-test\")); asserttrue(chatdirector.getchains().containskey(\"halt-test\")); asserttrue(chatdirector.getchains().containskey(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\")); assertnotnull(chatdirector.getchains().get(\"breaking-test\")); assertnotnull(chatdirector.getchains().get(\"echo-test\")); assertnotnull(chatdirector.getchains().get(\"halt-test\")); assertnotnull(chatdirector.getchains().get(\"reload-test\")); assertnotnull(chatdirector.getchains().get(\"loading-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"breaking-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"echo-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"halt-test\").getitems()); assertnotnull(chatdirector.getchains().get(\"reload-test\").getitems()); asserttrue(chatdirector.getchains().get(\"loading-test\").getitems().size() == 9); asserttrue(chatdirector.getchains().get(\"breaking-test\").getitems().size() == 4); asserttrue(chatdirector.getchains().get(\"echo-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"halt-test\").getitems().size() == 3); asserttrue(chatdirector.getchains().get(\"reload-test\").getitems().size() == 1); asserttrue(chatdirector.getchains().get(\"loading-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"breaking-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"echo-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"halt-test\").isvalid()); asserttrue(chatdirector.getchains().get(\"reload-test\").isvalid()); iitem item = chatdirector.getchains().get(\"loading-test\").getitems().get(0); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(1); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(2); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(3); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(4); asserttrue(item instanceof echoitem); assertequals(\"%current%\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(5); asserttrue(item instanceof echoitem); assertequals(\"raw string\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(6); asserttrue(item instanceof echoitem); assertequals(\"\", ((echoitem) item).format); item = chatdirector.getchains().get(\"loading-test\").getitems().get(7); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"loading-test\").getitems().get(8); asserttrue(item instanceof reloaditem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(2); asserttrue(item instanceof breakitem); item = chatdirector.getchains().get(\"breaking-test\").getitems().get(3); asserttrue(item instanceof echoitem); assertequals(\"this is the third value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"hello!\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(1); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"echo-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this was >%current%<, but before that it was >%last%<\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(0); asserttrue(item instanceof echoitem); assertequals(\"this is the first value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"halt-test\").getitems().get(1); asserttrue(item instanceof haltitem); item = chatdirector.getchains().get(\"halt-test\").getitems().get(2); asserttrue(item instanceof echoitem); assertequals(\"this is the second value\", ((echoitem) item).format); item = chatdirector.getchains().get(\"reload-test\").getitems().get(0); asserttrue(item instanceof reloaditem); }","repo":"AtomicPulsee\/ChatDirector","label":[1,0,0,0]}
{"id":18795,"original_code":"@Override\n    public void initialize(URL location, ResourceBundle resources) {\n        \/\/ load the quiz\n        for (Question question : quiz.questions) {\n            questionsList.getItems().add(question.title);\n        }\n        populateView();\n        questionTextField.setOnKeyReleased(e -> {\n            questionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\n            quiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\n            saved = false;\n        });\n        newAnswerButton.setOnMouseClicked(e -> {\n            quiz.questions.get(currentQuestionIndex).options.add(new Option(\"\"));\n            addAnswer(questionsTilePane.getChildren().size());\n            saved = false;\n        });\n        rightAnswerComboBox.setOnAction(e -> {\n            if (rightAnswerComboBox.getItems().size() > 0) {\n                currentQuestion.answer = rightAnswerComboBox.getSelectionModel().getSelectedIndex();\n            }\n            saved = false;\n        });\n        questionsList.setOnMouseClicked(e -> {\n            int selectedIndex = questionsList.getSelectionModel().getSelectedIndex();\n            if (selectedIndex < quiz.questions.size() && selectedIndex >= 0) {\n                currentQuestionIndex = selectedIndex;\n                currentQuestion = quiz.questions.get(selectedIndex);\n            }\n            populateView();\n            saved = false;\n        });\n        newQuestionButton.setOnAction(e -> {\n            newQuestion();\n            questionsList.getItems().add(\"\");\n            currentQuestion = this.quiz.questions.get(currentQuestionIndex);\n            populateView();\n            saved = false;\n        });\n        deleteQuestionButton.setOnAction(e -> removeQuestion());\n        quizOptionsButton.setOnAction(e -> {\n            Stage stage = new Stage();\n            Window win = new Window(window.getApp(), stage, \"Settings for '\" + quiz.name + \"'\");\n            win.openView(new QuizSettingsPopupControl(quiz));\n            saved = false;\n        });\n        maxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\n            if (e.getCharacter().matches(\"[\\\\D]\")) {\n                e.consume();\n            }\n        });\n        maxPointsTextInput.setOnKeyReleased(e -> {\n            if (!maxPointsTextInput.getText().isEmpty()) {\n                currentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n            } else {\n                currentQuestion.maxReward = 50; \/\/ TODO un hardcode this\n            }\n            saved = false;\n        });\n        FileMenu.getItems().get(2).setOnAction(e -> {\n            if (!saved) {\n                askForSave();\n                closeApp = false;\n            } else {\n                window.openView(new ChooseQuizScreenControl(true));\n            }\n        });\n        FileMenu.getItems().get(0).setOnAction(e -> InitSave());\n        FileMenu.getItems().get(1).setOnAction(e -> {\n            openSaveDialog();\n        });\n        window.getStage().setOnCloseRequest(e -> {\n            if (!saved) {\n                e.consume();\n                askForSave();\n                closeApp = true;\n            }\n        });\n    }","code_wo_comment":"@Override\n    public void initialize(URL location, ResourceBundle resources) {\n       \n        for (Question question : quiz.questions) {\n            questionsList.getItems().add(question.title);\n        }\n        populateView();\n        questionTextField.setOnKeyReleased(e -> {\n            questionsList.getItems().set(currentQuestionIndex, questionTextField.getText());\n            quiz.questions.get(currentQuestionIndex).title = questionTextField.getText();\n            saved = false;\n        });\n        newAnswerButton.setOnMouseClicked(e -> {\n            quiz.questions.get(currentQuestionIndex).options.add(new Option(\"\"));\n            addAnswer(questionsTilePane.getChildren().size());\n            saved = false;\n        });\n        rightAnswerComboBox.setOnAction(e -> {\n            if (rightAnswerComboBox.getItems().size() > 0) {\n                currentQuestion.answer = rightAnswerComboBox.getSelectionModel().getSelectedIndex();\n            }\n            saved = false;\n        });\n        questionsList.setOnMouseClicked(e -> {\n            int selectedIndex = questionsList.getSelectionModel().getSelectedIndex();\n            if (selectedIndex < quiz.questions.size() && selectedIndex >= 0) {\n                currentQuestionIndex = selectedIndex;\n                currentQuestion = quiz.questions.get(selectedIndex);\n            }\n            populateView();\n            saved = false;\n        });\n        newQuestionButton.setOnAction(e -> {\n            newQuestion();\n            questionsList.getItems().add(\"\");\n            currentQuestion = this.quiz.questions.get(currentQuestionIndex);\n            populateView();\n            saved = false;\n        });\n        deleteQuestionButton.setOnAction(e -> removeQuestion());\n        quizOptionsButton.setOnAction(e -> {\n            Stage stage = new Stage();\n            Window win = new Window(window.getApp(), stage, \"Settings for '\" + quiz.name + \"'\");\n            win.openView(new QuizSettingsPopupControl(quiz));\n            saved = false;\n        });\n        maxPointsTextInput.addEventFilter(KeyEvent.KEY_TYPED, e -> {\n            if (e.getCharacter().matches(\"[\\\\D]\")) {\n                e.consume();\n            }\n        });\n        maxPointsTextInput.setOnKeyReleased(e -> {\n            if (!maxPointsTextInput.getText().isEmpty()) {\n                currentQuestion.maxReward = Integer.parseInt(maxPointsTextInput.getText());\n            } else {\n                currentQuestion.maxReward = 50;\n            }\n            saved = false;\n        });\n        FileMenu.getItems().get(2).setOnAction(e -> {\n            if (!saved) {\n                askForSave();\n                closeApp = false;\n            } else {\n                window.openView(new ChooseQuizScreenControl(true));\n            }\n        });\n        FileMenu.getItems().get(0).setOnAction(e -> InitSave());\n        FileMenu.getItems().get(1).setOnAction(e -> {\n            openSaveDialog();\n        });\n        window.getStage().setOnCloseRequest(e -> {\n            if (!saved) {\n                e.consume();\n                askForSave();\n                closeApp = true;\n            }\n        });\n    }","cleancode":"@override public void initialize(url location, resourcebundle resources) { for (question question : quiz.questions) { questionslist.getitems().add(question.title); } populateview(); questiontextfield.setonkeyreleased(e -> { questionslist.getitems().set(currentquestionindex, questiontextfield.gettext()); quiz.questions.get(currentquestionindex).title = questiontextfield.gettext(); saved = false; }); newanswerbutton.setonmouseclicked(e -> { quiz.questions.get(currentquestionindex).options.add(new option(\"\")); addanswer(questionstilepane.getchildren().size()); saved = false; }); rightanswercombobox.setonaction(e -> { if (rightanswercombobox.getitems().size() > 0) { currentquestion.answer = rightanswercombobox.getselectionmodel().getselectedindex(); } saved = false; }); questionslist.setonmouseclicked(e -> { int selectedindex = questionslist.getselectionmodel().getselectedindex(); if (selectedindex < quiz.questions.size() && selectedindex >= 0) { currentquestionindex = selectedindex; currentquestion = quiz.questions.get(selectedindex); } populateview(); saved = false; }); newquestionbutton.setonaction(e -> { newquestion(); questionslist.getitems().add(\"\"); currentquestion = this.quiz.questions.get(currentquestionindex); populateview(); saved = false; }); deletequestionbutton.setonaction(e -> removequestion()); quizoptionsbutton.setonaction(e -> { stage stage = new stage(); window win = new window(window.getapp(), stage, \"settings for '\" + quiz.name + \"'\"); win.openview(new quizsettingspopupcontrol(quiz)); saved = false; }); maxpointstextinput.addeventfilter(keyevent.key_typed, e -> { if (e.getcharacter().matches(\"[\\\\d]\")) { e.consume(); } }); maxpointstextinput.setonkeyreleased(e -> { if (!maxpointstextinput.gettext().isempty()) { currentquestion.maxreward = integer.parseint(maxpointstextinput.gettext()); } else { currentquestion.maxreward = 50; } saved = false; }); filemenu.getitems().get(2).setonaction(e -> { if (!saved) { askforsave(); closeapp = false; } else { window.openview(new choosequizscreencontrol(true)); } }); filemenu.getitems().get(0).setonaction(e -> initsave()); filemenu.getitems().get(1).setonaction(e -> { opensavedialog(); }); window.getstage().setoncloserequest(e -> { if (!saved) { e.consume(); askforsave(); closeapp = true; } }); }","repo":"ExodiusStudios\/quizzibles","label":[1,0,0,0]}
{"id":10647,"original_code":"public void testBuildMalformedDocumentWithUnpairedSurrogate() \n      throws IOException {\n        String doc = \"<doc>A\\uD800A<\/doc>\";\n        try {\n            builder.build(doc, \"http:\/\/www.example.com\");   \n            fail(\"Allowed malformed doc\");\n        }\n        catch (ParsingException success) {\n            assertNotNull(success.getMessage());\n            assertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n        }\n    }","code_wo_comment":"public void testBuildMalformedDocumentWithUnpairedSurrogate() \n      throws IOException {\n        String doc = \"<doc>A\\uD800A<\/doc>\";\n        try {\n            builder.build(doc, \"http:\/\/www.example.com\");   \n            fail(\"Allowed malformed doc\");\n        }\n        catch (ParsingException success) {\n            assertNotNull(success.getMessage());\n            assertEquals(\"http:\/\/www.example.com\/\", success.getURI());\n        }\n    }","cleancode":"public void testbuildmalformeddocumentwithunpairedsurrogate() throws ioexception { string doc = \"<doc>a\\ud800a<\/doc>\"; try { builder.build(doc, \"http:\/\/www.example.com\"); fail(\"allowed malformed doc\"); } catch (parsingexception success) { assertnotnull(success.getmessage()); assertequals(\"http:\/\/www.example.com\/\", success.geturi()); } }","repo":"Evegen55\/TIJ4_code","label":[1,0,0,0]}
{"id":2472,"original_code":"@Override\n        protected Config getConfig() {\n            Config c = new Config();\n            c.caption = \"custom tile listener\";\n            c.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n            \/\/TODO: Implement this in the future\n            \/\/c.secureSettingName = Settings.Secure.ENABLED_CUSTOM_TILE_LISTENERS;\n            c.bindPermission =\n                    cyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n            \/\/TODO: Implement this in the future\n            \/\/c.settingsAction = Settings.ACTION_CUSTOM_TILE_LISTENER_SETTINGS;\n            c.clientLabel = R.string.custom_tile_listener_binding_label;\n            return c;\n        }","code_wo_comment":"@Override\n        protected Config getConfig() {\n            Config c = new Config();\n            c.caption = \"custom tile listener\";\n            c.serviceInterface = CustomTileListenerService.SERVICE_INTERFACE;\n           \n           \n            c.bindPermission =\n                    cyanogenmod.platform.Manifest.permission.BIND_CUSTOM_TILE_LISTENER_SERVICE;\n           \n           \n            c.clientLabel = R.string.custom_tile_listener_binding_label;\n            return c;\n        }","cleancode":"@override protected config getconfig() { config c = new config(); c.caption = \"custom tile listener\"; c.serviceinterface = customtilelistenerservice.service_interface; c.bindpermission = cyanogenmod.platform.manifest.permission.bind_custom_tile_listener_service; c.clientlabel = r.string.custom_tile_listener_binding_label; return c; }","repo":"Ant-OS\/android_vendor_cmsdk","label":[0,1,0,0]}
{"id":18884,"original_code":"@Override\n\tpublic void offer(HttpContent chunk) {\n\t\tif (this.channel.isClosed())\n\t\t\treturn;\t\t\/\/ TODO somehow connect the cancel back to netsession \n\t\tif (chunk.content().readableBytes() > this.max) {\n\t\t\tthis.channel.abort();\t\t\/\/ TODO somehow connect the cancel back to netsession\n\t\t\treturn;\n\t\t}\n\t\tByteBuf bb = chunk.content();\n\t\tbb.retain();\t\t\/\/ we will use it in upcoming send\n\t\tSystem.out.println(\"ref count a: \" + bb.refCnt());\n\t\tStreamMessage b = new StreamMessage(\"Block\", bb);\n\t\tb.setField(\"Sequence\", this.seq);\n\t\tOperationResult or = this.channel.send(b);\n\t\t\/\/ bb should now be back to 1\n\t\tSystem.out.println(\"ref count b: \" + bb.refCnt());\n\t\tif (or.hasErrors()) {\n\t\t\tthis.channel.close();\n\t\t\treturn;\n\t\t}\n\t\tthis.seq++;\n\t\t\/\/ TODO track progress if possible\n\t\t\/\/ final only if not canceled\n\t\tif (chunk instanceof LastHttpContent)\n\t\t\tthis.channel.send(MessageUtil.streamFinal());\n\t}","code_wo_comment":"@Override\n\tpublic void offer(HttpContent chunk) {\n\t\tif (this.channel.isClosed())\n\t\t\treturn;\t\n\t\tif (chunk.content().readableBytes() > this.max) {\n\t\t\tthis.channel.abort();\t\n\t\t\treturn;\n\t\t}\n\t\tByteBuf bb = chunk.content();\n\t\tbb.retain();\t\n\t\tSystem.out.println(\"ref count a: \" + bb.refCnt());\n\t\tStreamMessage b = new StreamMessage(\"Block\", bb);\n\t\tb.setField(\"Sequence\", this.seq);\n\t\tOperationResult or = this.channel.send(b);\n\t\n\t\tSystem.out.println(\"ref count b: \" + bb.refCnt());\n\t\tif (or.hasErrors()) {\n\t\t\tthis.channel.close();\n\t\t\treturn;\n\t\t}\n\t\tthis.seq++;\n\t\n\t\n\t\tif (chunk instanceof LastHttpContent)\n\t\t\tthis.channel.send(MessageUtil.streamFinal());\n\t}","cleancode":"@override public void offer(httpcontent chunk) { if (this.channel.isclosed()) return; if (chunk.content().readablebytes() > this.max) { this.channel.abort(); return; } bytebuf bb = chunk.content(); bb.retain(); system.out.println(\"ref count a: \" + bb.refcnt()); streammessage b = new streammessage(\"block\", bb); b.setfield(\"sequence\", this.seq); operationresult or = this.channel.send(b); system.out.println(\"ref count b: \" + bb.refcnt()); if (or.haserrors()) { this.channel.close(); return; } this.seq++; if (chunk instanceof lasthttpcontent) this.channel.send(messageutil.streamfinal()); }","repo":"Gadreel\/divconq","label":[1,1,0,0]}
{"id":10828,"original_code":"private Printer escapeCharacter(char c) {\n    if (c == '\"') {\n      return backslashChar(c);\n    }\n    switch (c) {\n      case '\\\\':\n        return backslashChar('\\\\');\n      case '\\r':\n        return backslashChar('r');\n      case '\\n':\n        return backslashChar('n');\n      case '\\t':\n        return backslashChar('t');\n      default:\n        if (c < 32) {\n          \/\/ TODO(bazel-team): support \\x escapes\n          return this.append(String.format(\"\\\\x%02x\", (int) c));\n        }\n        return this.append(c); \/\/ no need to support UTF-8\n    }\n  }","code_wo_comment":"private Printer escapeCharacter(char c) {\n    if (c == '\"') {\n      return backslashChar(c);\n    }\n    switch (c) {\n      case '\\\\':\n        return backslashChar('\\\\');\n      case '\\r':\n        return backslashChar('r');\n      case '\\n':\n        return backslashChar('n');\n      case '\\t':\n        return backslashChar('t');\n      default:\n        if (c < 32) {\n         \n          return this.append(String.format(\"\\\\x%02x\", (int) c));\n        }\n        return this.append(c);\n    }\n  }","cleancode":"private printer escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); } }","repo":"AyuMol758\/bazel","label":[0,1,0,0]}
{"id":10844,"original_code":"@Override\n    public void meet(Projection node) throws RuntimeException {\n        super.meet(node);\n        ProjectionElemList list = node.getProjectionElemList();\n        String set = null;\n        StringBuilder projList = new StringBuilder();\n        boolean first = true;\n        \/\/TODO: we do not support projections from multiple pig statements yet\n        for (String name : list.getTargetNames()) {\n            set = varToSet.get(name);  \/\/TODO: overwrite\n            if (set == null) {\n                throw new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n            }\n            if (!first) {\n                projList.append(\",\");\n            }\n            first = false;\n            projList.append(name);\n        }\n        if (set == null)\n            throw new IllegalArgumentException(\"\"); \/\/TODO: Fill this\n        \/\/SUBORG = FOREACH SUBORG_L GENERATE dept, univ;\n        pigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n    }","code_wo_comment":"@Override\n    public void meet(Projection node) throws RuntimeException {\n        super.meet(node);\n        ProjectionElemList list = node.getProjectionElemList();\n        String set = null;\n        StringBuilder projList = new StringBuilder();\n        boolean first = true;\n       \n        for (String name : list.getTargetNames()) {\n            set = varToSet.get(name); \n            if (set == null) {\n                throw new IllegalArgumentException(\"Have not found any pig logic for name[\" + name + \"]\");\n            }\n            if (!first) {\n                projList.append(\",\");\n            }\n            first = false;\n            projList.append(name);\n        }\n        if (set == null)\n            throw new IllegalArgumentException(\"\");\n       \n        pigScriptBuilder.append(\"PROJ = FOREACH \").append(set).append(\" GENERATE \").append(projList.toString()).append(\";\\n\");\n    }","cleancode":"@override public void meet(projection node) throws runtimeexception { super.meet(node); projectionelemlist list = node.getprojectionelemlist(); string set = null; stringbuilder projlist = new stringbuilder(); boolean first = true; for (string name : list.gettargetnames()) { set = vartoset.get(name); if (set == null) { throw new illegalargumentexception(\"have not found any pig logic for name[\" + name + \"]\"); } if (!first) { projlist.append(\",\"); } first = false; projlist.append(name); } if (set == null) throw new illegalargumentexception(\"\"); pigscriptbuilder.append(\"proj = foreach \").append(set).append(\" generate \").append(projlist.tostring()).append(\";\\n\"); }","repo":"DLotts\/incubator-rya","label":[1,1,0,0]}
{"id":2684,"original_code":"public List<JsonMessage> processDatasets(List<String> datasetIncludeList,\n                                             List<String> datasetExcludeList,\n                                             List<String> tableExcludeList,\n                                             String dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\n        List<String> tablesIncludeList = new ArrayList<>();\n        for (String dataset : datasetIncludeList) {\n            try {\n                if (!datasetExcludeList.contains(dataset)) {\n                    List<String> tokens = Utils.tokenize(dataset, \".\", true);\n                    String projectId = tokens.get(0);\n                    String datasetId = tokens.get(1);\n                    String datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n                \/*\n                 TODO: Support tagging in multiple locations\n                 to support all locations:\n                 1- Taxonomies\/PolicyTags have to be created in each required location\n                 2- Update the Tagger Cloud Function to read one mapping per location\n                 For now, we don't submit tasks for tables in other locations than the PolicyTag location\n                 *\/\n                    if (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\n                        logger.logWarnWithTracker(runId,\n                                String.format(\n                                        \"Ignoring dataset %s in location %s. Only location %s is configured\",\n                                        dataset,\n                                        datasetLocation,\n                                        dataRegionId)\n                        );\n                        continue;\n                    }\n                    \/\/ get all tables that have DLP findings\n                    List<String> datasetTables = scanner.listChildren(projectId, datasetId);\n                    tablesIncludeList.addAll(datasetTables);\n                    if (datasetTables.isEmpty()) {\n                        String msg = String.format(\n                                \"No Tables found under dataset '%s'\",\n                                dataset);\n                        logger.logWarnWithTracker(runId, msg);\n                    } else {\n                        logger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n                    }\n                }\n            } catch (Exception exception) {\n                \/\/ log and continue\n                logger.logFailedDispatcherEntityId(runId, dataset, exception);\n            }\n        }\n        return processTables(tablesIncludeList, tableExcludeList);\n    }","code_wo_comment":"public List<JsonMessage> processDatasets(List<String> datasetIncludeList,\n                                             List<String> datasetExcludeList,\n                                             List<String> tableExcludeList,\n                                             String dataRegionId) throws IOException, InterruptedException, NonRetryableApplicationException {\n        List<String> tablesIncludeList = new ArrayList<>();\n        for (String dataset : datasetIncludeList) {\n            try {\n                if (!datasetExcludeList.contains(dataset)) {\n                    List<String> tokens = Utils.tokenize(dataset, \".\", true);\n                    String projectId = tokens.get(0);\n                    String datasetId = tokens.get(1);\n                    String datasetLocation = bqService.getDatasetLocation(projectId, datasetId);\n               \n                    if (!datasetLocation.toLowerCase().equals(dataRegionId.toLowerCase())) {\n                        logger.logWarnWithTracker(runId,\n                                String.format(\n                                        \"Ignoring dataset %s in location %s. Only location %s is configured\",\n                                        dataset,\n                                        datasetLocation,\n                                        dataRegionId)\n                        );\n                        continue;\n                    }\n                   \n                    List<String> datasetTables = scanner.listChildren(projectId, datasetId);\n                    tablesIncludeList.addAll(datasetTables);\n                    if (datasetTables.isEmpty()) {\n                        String msg = String.format(\n                                \"No Tables found under dataset '%s'\",\n                                dataset);\n                        logger.logWarnWithTracker(runId, msg);\n                    } else {\n                        logger.logInfoWithTracker(runId, String.format(\"Tables found in dataset %s : %s\", dataset, datasetTables));\n                    }\n                }\n            } catch (Exception exception) {\n               \n                logger.logFailedDispatcherEntityId(runId, dataset, exception);\n            }\n        }\n        return processTables(tablesIncludeList, tableExcludeList);\n    }","cleancode":"public list<jsonmessage> processdatasets(list<string> datasetincludelist, list<string> datasetexcludelist, list<string> tableexcludelist, string dataregionid) throws ioexception, interruptedexception, nonretryableapplicationexception { list<string> tablesincludelist = new arraylist<>(); for (string dataset : datasetincludelist) { try { if (!datasetexcludelist.contains(dataset)) { list<string> tokens = utils.tokenize(dataset, \".\", true); string projectid = tokens.get(0); string datasetid = tokens.get(1); string datasetlocation = bqservice.getdatasetlocation(projectid, datasetid); if (!datasetlocation.tolowercase().equals(dataregionid.tolowercase())) { logger.logwarnwithtracker(runid, string.format( \"ignoring dataset %s in location %s. only location %s is configured\", dataset, datasetlocation, dataregionid) ); continue; } list<string> datasettables = scanner.listchildren(projectid, datasetid); tablesincludelist.addall(datasettables); if (datasettables.isempty()) { string msg = string.format( \"no tables found under dataset '%s'\", dataset); logger.logwarnwithtracker(runid, msg); } else { logger.loginfowithtracker(runid, string.format(\"tables found in dataset %s : %s\", dataset, datasettables)); } } } catch (exception exception) { logger.logfaileddispatcherentityid(runid, dataset, exception); } } return processtables(tablesincludelist, tableexcludelist); }","repo":"GoogleCloudPlatform\/bq-pii-classifier","label":[0,1,0,0]}
{"id":10989,"original_code":"@Override \/\/using this override to place getAnnualReport and gameShouldEnd inside displayView while loop.\n    public void displayView() {\n        boolean keepGoing = true;\n        while (keepGoing == true) {\n            \/\/check to see if the game should end and if so, display a message and return to Main Menu \n            \/\/TODO Implement try catch.\n            \/\/TODO when fully implemented, this will contain mortality rate variable from annual report \n            \/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n            \/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n            \/\/display the annual report above the GameMenuView\n            liveTheYear();\n            getAnnualReport();\n            if (GameControl.gameShouldEnd(0)) {\n                \/\/TODO when fully implemented, this will contain mortality rate variable from annual report \n                this.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\n                return;\n            } else if (GameControl.gameMatures(1)) {\n                \/\/TODO when fully implemented, this will contain currentYear variable from annual report.\n                \/\/TODO create end of game report showing total game statistics. Use Annual Report format but bring in stats from every year.\n                this.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\n                return;\n            }\n            \/\/ get message that should be displayed\n            \/\/ only print if it is non-null\n            String message = getMessage();\n            if (message != null) {\n                this.console.println(getMessage());\n            }\n            String[] inputs = getInputs();\n            keepGoing = doAction(inputs);\n        }\n    }","code_wo_comment":"@Override     public void displayView() {\n        boolean keepGoing = true;\n        while (keepGoing == true) {\n           \n           \n           \n           \n           \n           \n            liveTheYear();\n            getAnnualReport();\n            if (GameControl.gameShouldEnd(0)) {\n               \n                this.console.println(\"More than 50% of your population died, therefore this game is over. Repent and try again.\");\n                return;\n            } else if (GameControl.gameMatures(1)) {\n               \n               \n                this.console.println(\"Ten glorious years have passed, therefore this game is over. Congratulations on a successful game!\");\n                return;\n            }\n           \n           \n            String message = getMessage();\n            if (message != null) {\n                this.console.println(getMessage());\n            }\n            String[] inputs = getInputs();\n            keepGoing = doAction(inputs);\n        }\n    }","cleancode":"@override public void displayview() { boolean keepgoing = true; while (keepgoing == true) { livetheyear(); getannualreport(); if (gamecontrol.gameshouldend(0)) { this.console.println(\"more than 50% of your population died, therefore this game is over. repent and try again.\"); return; } else if (gamecontrol.gamematures(1)) { this.console.println(\"ten glorious years have passed, therefore this game is over. congratulations on a successful game!\"); return; } string message = getmessage(); if (message != null) { this.console.println(getmessage()); } string[] inputs = getinputs(); keepgoing = doaction(inputs); } }","repo":"Hsia-Esther\/CityOfAaronGroup1","label":[0,1,0,0]}
{"id":2869,"original_code":"public void updatePosLog(double x, double y, double heading) { \/\/ Reference positions by doing point# * 3 + (0 for\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ x, 1 for y, 2 for heading)\n\t\tposLog.add(x);\n\t\tposLog.add(y);\n\t\tposLog.add(heading);\n\t}","code_wo_comment":"public void updatePosLog(double x, double y, double heading) { \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tposLog.add(x);\n\t\tposLog.add(y);\n\t\tposLog.add(heading);\n\t}","cleancode":"public void updateposlog(double x, double y, double heading) { poslog.add(x); poslog.add(y); poslog.add(heading); }","repo":"AutonomousCarProject\/Steering","label":[1,0,0,0]}
{"id":11109,"original_code":"@Override\n\tprotected void configure() {\n\t\tinstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\t\t\/\/ make sure app is embedded in a correct DIV\n\t\tbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\t\t\/\/ Main Application must bind generic Presenter and custom View !!\n\t\tbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\t\t\/\/ bind app-specific pages\n\t\t\/\/ TODO - implement pages\n\t\tbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\n\t\tbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\t\t\/\/ pre-defined places\n\t\tbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\n\t\tbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\t\tbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\t\t\/\/ generic pages\n\t\tbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\n\t\tbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\n\t\tbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\n\t\tbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n\t}","code_wo_comment":"@Override\n\tprotected void configure() {\n\t\tinstall(new DefaultModule.Builder().placeManager(PerunPlaceManager.class).build());\n\t\n\t\tbind(RootPresenter.class).to(PerunRootPresenter.class).asEagerSingleton();\n\t\n\t\tbindPresenter(PerunCabinetPresenter.class, PerunCabinetPresenter.MyView.class, PerunCabinetView.class, PerunCabinetPresenter.MyProxy.class);\n\t\n\t\n\t\tbindPresenter(PublicationsPresenter.class, PublicationsPresenter.MyView.class, PublicationsView.class, PublicationsPresenter.MyProxy.class);\n\t\tbindPresenter(NewPublicationPresenter.class, NewPublicationPresenter.MyView.class, NewPublicationView.class, NewPublicationPresenter.MyProxy.class);\n\t\n\t\tbindConstant().annotatedWith(DefaultPlace.class).to(PerunCabinetPlaceTokens.PUBLICATIONS);\n\t\tbindConstant().annotatedWith(ErrorPlace.class).to(PerunCabinetPlaceTokens.NOT_FOUND);\n\t\tbindConstant().annotatedWith(UnauthorizedPlace.class).to(PerunCabinetPlaceTokens.UNAUTHORIZED);\n\t\n\t\tbindPresenter(NotAuthorizedPresenter.class, NotAuthorizedPresenter.MyView.class, NotAuthorizedView.class, NotAuthorizedPresenter.MyProxy.class);\n\t\tbindPresenter(NotFoundPresenter.class, NotFoundPresenter.MyView.class, NotFoundView.class, NotFoundPresenter.MyProxy.class);\n\t\tbindPresenter(LogoutPresenter.class, LogoutPresenter.MyView.class, LogoutView.class, LogoutPresenter.MyProxy.class);\n\t\tbindPresenter(NotUserPresenter.class, NotUserPresenter.MyView.class, NotUserView.class, NotUserPresenter.MyProxy.class);\n\t}","cleancode":"@override protected void configure() { install(new defaultmodule.builder().placemanager(perunplacemanager.class).build()); bind(rootpresenter.class).to(perunrootpresenter.class).aseagersingleton(); bindpresenter(peruncabinetpresenter.class, peruncabinetpresenter.myview.class, peruncabinetview.class, peruncabinetpresenter.myproxy.class); bindpresenter(publicationspresenter.class, publicationspresenter.myview.class, publicationsview.class, publicationspresenter.myproxy.class); bindpresenter(newpublicationpresenter.class, newpublicationpresenter.myview.class, newpublicationview.class, newpublicationpresenter.myproxy.class); bindconstant().annotatedwith(defaultplace.class).to(peruncabinetplacetokens.publications); bindconstant().annotatedwith(errorplace.class).to(peruncabinetplacetokens.not_found); bindconstant().annotatedwith(unauthorizedplace.class).to(peruncabinetplacetokens.unauthorized); bindpresenter(notauthorizedpresenter.class, notauthorizedpresenter.myview.class, notauthorizedview.class, notauthorizedpresenter.myproxy.class); bindpresenter(notfoundpresenter.class, notfoundpresenter.myview.class, notfoundview.class, notfoundpresenter.myproxy.class); bindpresenter(logoutpresenter.class, logoutpresenter.myview.class, logoutview.class, logoutpresenter.myproxy.class); bindpresenter(notuserpresenter.class, notuserpresenter.myview.class, notuserview.class, notuserpresenter.myproxy.class); }","repo":"Gaeldrin\/perun-wui","label":[0,1,0,0]}
{"id":3131,"original_code":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\n        try (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\n            String checkpointName = export(processKey, checkpointId, checkpointArchive.path());\n            if (checkpointName == null) {\n                return null;\n            }\n            try (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\n                IOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n                \/\/ TODO: only for v1 runtime\n                String eventName = readCheckpointEventName(extractedDir.path());\n                stateManager.tx(tx -> {\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\n                    stateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n                });\n                Map<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\n                if (out.isEmpty()) {\n                    queueDao.removeMeta(processKey, \"out\");\n                } else {\n                    queueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n                }\n                return CheckpointInfo.of(checkpointName, eventName);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n        }\n    }","code_wo_comment":"public CheckpointInfo restoreCheckpoint(ProcessKey processKey, UUID checkpointId) {\n        try (TemporaryPath checkpointArchive = IOUtils.tempFile(\"checkpoint\", \".zip\")) {\n            String checkpointName = export(processKey, checkpointId, checkpointArchive.path());\n            if (checkpointName == null) {\n                return null;\n            }\n            try (TemporaryPath extractedDir = IOUtils.tempDir(\"unzipped-checkpoint\")) {\n                IOUtils.unzip(checkpointArchive.path(), extractedDir.path());\n               \n                String eventName = readCheckpointEventName(extractedDir.path());\n                stateManager.tx(tx -> {\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.CONCORD_SYSTEM_DIR_NAME);\n                    stateManager.deleteDirectory(tx, processKey, Constants.Files.JOB_ATTACHMENTS_DIR_NAME);\n                    stateManager.importPath(tx, processKey, null, extractedDir.path(), (p, attrs) -> true);\n                });\n                Map<String, Object> out = OutVariablesUtils.read(extractedDir.path().resolve(Constants.Files.JOB_ATTACHMENTS_DIR_NAME));\n                if (out.isEmpty()) {\n                    queueDao.removeMeta(processKey, \"out\");\n                } else {\n                    queueDao.updateMeta(processKey, Collections.singletonMap(\"out\", out));\n                }\n                return CheckpointInfo.of(checkpointName, eventName);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Restore checkpoint '\" + checkpointId + \"' error\", e);\n        }\n    }","cleancode":"public checkpointinfo restorecheckpoint(processkey processkey, uuid checkpointid) { try (temporarypath checkpointarchive = ioutils.tempfile(\"checkpoint\", \".zip\")) { string checkpointname = export(processkey, checkpointid, checkpointarchive.path()); if (checkpointname == null) { return null; } try (temporarypath extracteddir = ioutils.tempdir(\"unzipped-checkpoint\")) { ioutils.unzip(checkpointarchive.path(), extracteddir.path()); string eventname = readcheckpointeventname(extracteddir.path()); statemanager.tx(tx -> { statemanager.deletedirectory(tx, processkey, constants.files.concord_system_dir_name); statemanager.deletedirectory(tx, processkey, constants.files.job_attachments_dir_name); statemanager.importpath(tx, processkey, null, extracteddir.path(), (p, attrs) -> true); }); map<string, object> out = outvariablesutils.read(extracteddir.path().resolve(constants.files.job_attachments_dir_name)); if (out.isempty()) { queuedao.removemeta(processkey, \"out\"); } else { queuedao.updatemeta(processkey, collections.singletonmap(\"out\", out)); } return checkpointinfo.of(checkpointname, eventname); } } catch (exception e) { throw new runtimeexception(\"restore checkpoint '\" + checkpointid + \"' error\", e); } }","repo":"700software\/concord","label":[1,0,0,0]}
{"id":19591,"original_code":"protected List createEmptyList() {\n        return new BackedList(this, contentList(), 0);\n    }","code_wo_comment":"protected List createEmptyList() {\n        return new BackedList(this, contentList(), 0);\n    }","cleancode":"protected list createemptylist() { return new backedlist(this, contentlist(), 0); }","repo":"Gravitational-Field\/Dive-In-Java","label":[0,0,0,0]}
{"id":3223,"original_code":"protected void initFromRaFile() throws IOException {\n\t\t\/\/ Central directory structure \/ central file header signature\n\t\tint censig = raFile.readInt( fileOffset );\n\t\tif( censig!=CENSIG ) {\n\t\t\tthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n\t\t} else if( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"found censigOffset=\" + fileOffset );\n\t\t}\n\t\tshort flag = raFile.readShort( fileOffset + 8 );\n\t\tthis.isEncrypted = (flag&1)>0;\n\t\tthis.fileNameLength = raFile.readShort( fileOffset + 28 );\n\t\tbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\n\t\tthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"fileName = \" + this.fileName );\n\t\t}\n\t\tthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\n\t\tthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\n\t\tthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\tLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\n\t\t\tLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n\t\t}\n\t\t\/\/ TODO - check, why we have to use the local header instead of the CDS sometimes...\n\t\tif( this.isEncrypted ) {\n\t\t\tbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\n\t\t\tif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\n\t\t\t\tthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\n\t\t\t\tthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\n\t\t\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\t\t\tLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\t\t\tLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n\t\t\t\t}\n\t\t\t\tif( 0==extraFieldLength ) {\n\t\t\t\t\tthrow new ZipException(\"extra field is of length 0 - this is probably not a WinZip AES encrypted entry\");\n\t\t\t\t}\n\t\t\t\tefhid = raFile.readByteArray( extraFieldOffset, 2);\n\t\t\t\tif( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) {\n\t\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t}\n\t\t\tif( this.isAesEncrypted ) {\n\t\t\t\tthis.actualCompressionMethod = raFile.readShort( getExtraFieldOffset() + 9 );\n\t\t\t\tthis.localHeaderSize = 30 + getExtraFieldLength() + getFileNameLength();\n\t\t\t}\n\t\t}\n\t\tthis.compressedSize = raFile.readInt( fileOffset + 20 );\n\t\tthis.uncompressedSize = raFile.readInt( fileOffset + 24 );\n\t}","code_wo_comment":"protected void initFromRaFile() throws IOException {\n\t\n\t\tint censig = raFile.readInt( fileOffset );\n\t\tif( censig!=CENSIG ) {\n\t\t\tthrow new ZipException(\"expected CENSIC not found in central directory (at end of zip file)\");\n\t\t} else if( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"found censigOffset=\" + fileOffset );\n\t\t}\n\t\tshort flag = raFile.readShort( fileOffset + 8 );\n\t\tthis.isEncrypted = (flag&1)>0;\n\t\tthis.fileNameLength = raFile.readShort( fileOffset + 28 );\n\t\tbyte[] fileNameBytes = raFile.readByteArray( fileOffset + 46, fileNameLength );\n\t\tthis.fileName = new String( fileNameBytes, AesZipFileDecrypter.charset );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"fileName = \" + this.fileName );\n\t\t}\n\t\tthis.extraFieldOffset = this.fileOffset + 46 + this.fileNameLength;\n\t\tthis.extraFieldLength = raFile.readShort( fileOffset + 30 );\n\t\tthis.localHeaderOffset = raFile.readInt( fileOffset + 28 + 14 );\n\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\tLOG.fine( \"CDS - extraFieldOffset =\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\tLOG.fine( \"CDS - extraFieldLength =\" + this.extraFieldLength );\n\t\t\tLOG.fine( \"CDS - localHeaderOffset=\" + Long.toHexString(this.localHeaderOffset) );\n\t\t}\n\t\n\t\tif( this.isEncrypted ) {\n\t\t\tbyte[] efhid = raFile.readByteArray( this.extraFieldOffset, 2 );\n\t\t\tif( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) {\n\t\t\t\tthis.extraFieldOffset = localHeaderOffset+30+fileNameLength;\n\t\t\t\tthis.extraFieldLength = raFile.readShort( localHeaderOffset+28 );\n\t\t\t\tif( LOG.isLoggable(Level.FINE) ) {\n\t\t\t\t\tLOG.fine( \"local header - extraFieldOffset=\" + Long.toHexString(this.extraFieldOffset) );\n\t\t\t\t\tLOG.fine( \"local header - extraFieldLength=\" + Long.toHexString(this.extraFieldLength) );\n\t\t\t\t}\n\t\t\t\tif( 0==extraFieldLength ) {\n\t\t\t\t\tthrow new ZipException(\"extra field is of length 0 - this is probably not a WinZip AES encrypted entry\");\n\t\t\t\t}\n\t\t\t\tefhid = raFile.readByteArray( extraFieldOffset, 2);\n\t\t\t\tif( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) {\n\t\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.isAesEncrypted = true;\n\t\t\t}\n\t\t\tif( this.isAesEncrypted ) {\n\t\t\t\tthis.actualCompressionMethod = raFile.readShort( getExtraFieldOffset() + 9 );\n\t\t\t\tthis.localHeaderSize = 30 + getExtraFieldLength() + getFileNameLength();\n\t\t\t}\n\t\t}\n\t\tthis.compressedSize = raFile.readInt( fileOffset + 20 );\n\t\tthis.uncompressedSize = raFile.readInt( fileOffset + 24 );\n\t}","cleancode":"protected void initfromrafile() throws ioexception { int censig = rafile.readint( fileoffset ); if( censig!=censig ) { throw new zipexception(\"expected censic not found in central directory (at end of zip file)\"); } else if( log.isloggable(level.fine) ) { log.fine( \"found censigoffset=\" + fileoffset ); } short flag = rafile.readshort( fileoffset + 8 ); this.isencrypted = (flag&1)>0; this.filenamelength = rafile.readshort( fileoffset + 28 ); byte[] filenamebytes = rafile.readbytearray( fileoffset + 46, filenamelength ); this.filename = new string( filenamebytes, aeszipfiledecrypter.charset ); if( log.isloggable(level.fine) ) { log.fine( \"filename = \" + this.filename ); } this.extrafieldoffset = this.fileoffset + 46 + this.filenamelength; this.extrafieldlength = rafile.readshort( fileoffset + 30 ); this.localheaderoffset = rafile.readint( fileoffset + 28 + 14 ); if( log.isloggable(level.fine) ) { log.fine( \"cds - extrafieldoffset =\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"cds - extrafieldlength =\" + this.extrafieldlength ); log.fine( \"cds - localheaderoffset=\" + long.tohexstring(this.localheaderoffset) ); } if( this.isencrypted ) { byte[] efhid = rafile.readbytearray( this.extrafieldoffset, 2 ); if( efhid[0]!=0x01 || efhid[1]!=(byte)0x99 ) { this.extrafieldoffset = localheaderoffset+30+filenamelength; this.extrafieldlength = rafile.readshort( localheaderoffset+28 ); if( log.isloggable(level.fine) ) { log.fine( \"local header - extrafieldoffset=\" + long.tohexstring(this.extrafieldoffset) ); log.fine( \"local header - extrafieldlength=\" + long.tohexstring(this.extrafieldlength) ); } if( 0==extrafieldlength ) { throw new zipexception(\"extra field is of length 0 - this is probably not a winzip aes encrypted entry\"); } efhid = rafile.readbytearray( extrafieldoffset, 2); if( efhid[0]==0x01 && efhid[1]==(byte)0x99 ) { this.isaesencrypted = true; } } else { this.isaesencrypted = true; } if( this.isaesencrypted ) { this.actualcompressionmethod = rafile.readshort( getextrafieldoffset() + 9 ); this.localheadersize = 30 + getextrafieldlength() + getfilenamelength(); } } this.compressedsize = rafile.readint( fileoffset + 20 ); this.uncompressedsize = rafile.readint( fileoffset + 24 ); }","repo":"CATION-M\/X-moe","label":[1,0,0,0]}
{"id":3224,"original_code":"public short getCryptoHeaderLength() {\n\t\t\/\/ TODO support 128+192 byte keys reduces the salt byte size to 8+2 or 12+2\n\t\treturn 18;\n\t}","code_wo_comment":"public short getCryptoHeaderLength() {\n\t\n\t\treturn 18;\n\t}","cleancode":"public short getcryptoheaderlength() { return 18; }","repo":"CATION-M\/X-moe","label":[0,1,0,0]}
{"id":11510,"original_code":"@Override\n    public Set< Justification > computeJustifications() {\n        Set< Set< OWLAxiom > > justifications = null;\n        try {\n            justifications = explainAxiom( axiom_ );\n        }\n        catch ( OWLException e ) {\n            throw new RuntimeException( e );\n        }\n        \/\/ We represent justifications as instances of a custom class outside of this function, which requires transitioning\n        \/\/ This is done in order to hide usage of the OWLAPI in code that does not need to rely directly on it.\n        Set< Justification > return_justifications = new TreeSet< Justification > (); \/\/ order is important for hitting set computation -> use TreeSet!\n\/* \/\/TODO Use this if printing is not desired\n        for ( Set< OWLAxiom > justification : justifications ) {\n            \/\/ JAVA 8:\n            \/\/ justification.removeIf( ( OWLAxiom a ) -> { return a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) } );\n            \/\/\n            \/\/ JAVA < 8 (there is probably a better way even then):\n            for ( Iterator< OWLAxiom > it = justification.iterator(); it.hasNext(); ) {\n                OWLAxiom a = it.next();\n                if ( a.isOfType( AxiomType.TBoxAndRBoxAxiomTypes ) ) {\n                    it.remove();\n                }\n            }\n            return_justifications.add( new Justification( justification ) );\n        }\n*\/\n        for ( Set< OWLAxiom > justification : justifications ) {\n            return_justifications.add( new Justification( justification ) );\n        }\n        \/\/if ( SparqlUpdater.verbose_level > 0 ) {\n            \/\/Justification.print( return_justifications, axiom_ );\n        \/\/}\n        \/\/ We only consider ABox axioms for deletion. Therefore, we remove TBox and RBox assertions.\n        \/\/ TODO if printing is not desired, this loop can be combined with the one above and the method used here can be removed within the Justification class.\n        for ( Justification justification : return_justifications ) {\n            justification.removeTBoxAndRBoxAxioms();\n        }\n        return return_justifications;\n    }","code_wo_comment":"@Override\n    public Set< Justification > computeJustifications() {\n        Set< Set< OWLAxiom > > justifications = null;\n        try {\n            justifications = explainAxiom( axiom_ );\n        }\n        catch ( OWLException e ) {\n            throw new RuntimeException( e );\n        }\n       \n       \n        Set< Justification > return_justifications = new TreeSet< Justification > ();\n        for ( Set< OWLAxiom > justification : justifications ) {\n            return_justifications.add( new Justification( justification ) );\n        }\n       \n           \n       \n       \n       \n        for ( Justification justification : return_justifications ) {\n            justification.removeTBoxAndRBoxAxioms();\n        }\n        return return_justifications;\n    }","cleancode":"@override public set< justification > computejustifications() { set< set< owlaxiom > > justifications = null; try { justifications = explainaxiom( axiom_ ); } catch ( owlexception e ) { throw new runtimeexception( e ); } set< justification > return_justifications = new treeset< justification > (); for ( set< owlaxiom > justification : justifications ) { return_justifications.add( new justification( justification ) ); } for ( justification justification : return_justifications ) { justification.removetboxandrboxaxioms(); } return return_justifications; }","repo":"Institute-Web-Science-and-Technologies\/SparqlUpdater","label":[1,0,0,0]}
{"id":19708,"original_code":"public boolean canKick(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanKick) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code_wo_comment":"public boolean canKick(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanKick) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public boolean cankick(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocankick) { return true; } return false; }","repo":"CoderMMK\/RSPS","label":[0,0,0,1]}
{"id":19709,"original_code":"public boolean canBan(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanBan) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code_wo_comment":"public boolean canBan(String name) {\n\t\tif (isFounder(name)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (getRank(name) >= whoCanBan) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public boolean canban(string name) { if (isfounder(name)) { return true; } if (getrank(name) >= whocanban) { return true; } return false; }","repo":"CoderMMK\/RSPS","label":[0,0,0,1]}
{"id":3404,"original_code":"public void GetLiveTvProgramsAsync(ProgramQuery query, final Response<ItemsResult> response)\n    {\n        if (query == null)\n        {\n            throw new IllegalArgumentException(\"query\");\n        }\n        QueryStringDictionary dict = new QueryStringDictionary ();\n        String isoDateFormat = \"o\";\n        if (query.getMaxEndDate() != null)\n        {\n            dict.Add(\"MaxEndDate\", getIsoString(query.getMaxEndDate()));\n        }\n        if (query.getMaxStartDate() != null)\n        {\n            dict.Add(\"MaxStartDate\", getIsoString(query.getMaxStartDate()));\n        }\n        if (query.getMinEndDate() != null)\n        {\n            dict.Add(\"MinEndDate\", getIsoString(query.getMinEndDate()));\n        }\n        if (query.getMinStartDate() != null)\n        {\n            dict.Add(\"MinStartDate\", getIsoString(query.getMinStartDate()));\n        }\n        if (!query.getEnableTotalRecordCount())\n        {\n            dict.Add(\"EnableTotalRecordCount\", \"false\");\n        }\n        dict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\n        dict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\n        dict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\n        dict.AddIfNotNull(\"Fields\", query.getFields());\n        dict.AddIfNotNull(\"SortBy\", query.getSortBy());\n        dict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\n        if (query.getChannelIds() != null)\n        {\n            dict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n        }\n        \/\/ TODO: This endpoint supports POST if the query String is too long\n        String url = GetApiUrl(\"LiveTv\/Programs\", dict);\n        url = AddDataFormat(url);\n        Send(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n    }","code_wo_comment":"public void GetLiveTvProgramsAsync(ProgramQuery query, final Response<ItemsResult> response)\n    {\n        if (query == null)\n        {\n            throw new IllegalArgumentException(\"query\");\n        }\n        QueryStringDictionary dict = new QueryStringDictionary ();\n        String isoDateFormat = \"o\";\n        if (query.getMaxEndDate() != null)\n        {\n            dict.Add(\"MaxEndDate\", getIsoString(query.getMaxEndDate()));\n        }\n        if (query.getMaxStartDate() != null)\n        {\n            dict.Add(\"MaxStartDate\", getIsoString(query.getMaxStartDate()));\n        }\n        if (query.getMinEndDate() != null)\n        {\n            dict.Add(\"MinEndDate\", getIsoString(query.getMinEndDate()));\n        }\n        if (query.getMinStartDate() != null)\n        {\n            dict.Add(\"MinStartDate\", getIsoString(query.getMinStartDate()));\n        }\n        if (!query.getEnableTotalRecordCount())\n        {\n            dict.Add(\"EnableTotalRecordCount\", \"false\");\n        }\n        dict.AddIfNotNull(\"EnableImages\", query.getEnableImages());\n        dict.AddIfNotNull(\"ImageTypeLimit\", query.getImageTypeLimit());\n        dict.AddIfNotNull(\"EnableImageTypes\", query.getEnableImageTypes());\n        dict.AddIfNotNull(\"Fields\", query.getFields());\n        dict.AddIfNotNull(\"SortBy\", query.getSortBy());\n        dict.AddIfNotNullOrEmpty(\"UserId\", query.getUserId());\n        if (query.getChannelIds() != null)\n        {\n            dict.Add(\"ChannelIds\", tangible.DotNetToJavaStringHelper.join(\",\", query.getChannelIds()));\n        }\n       \n        String url = GetApiUrl(\"LiveTv\/Programs\", dict);\n        url = AddDataFormat(url);\n        Send(url, \"GET\", new SerializedResponse<>(response, jsonSerializer, ItemsResult.class));\n    }","cleancode":"public void getlivetvprogramsasync(programquery query, final response<itemsresult> response) { if (query == null) { throw new illegalargumentexception(\"query\"); } querystringdictionary dict = new querystringdictionary (); string isodateformat = \"o\"; if (query.getmaxenddate() != null) { dict.add(\"maxenddate\", getisostring(query.getmaxenddate())); } if (query.getmaxstartdate() != null) { dict.add(\"maxstartdate\", getisostring(query.getmaxstartdate())); } if (query.getminenddate() != null) { dict.add(\"minenddate\", getisostring(query.getminenddate())); } if (query.getminstartdate() != null) { dict.add(\"minstartdate\", getisostring(query.getminstartdate())); } if (!query.getenabletotalrecordcount()) { dict.add(\"enabletotalrecordcount\", \"false\"); } dict.addifnotnull(\"enableimages\", query.getenableimages()); dict.addifnotnull(\"imagetypelimit\", query.getimagetypelimit()); dict.addifnotnull(\"enableimagetypes\", query.getenableimagetypes()); dict.addifnotnull(\"fields\", query.getfields()); dict.addifnotnull(\"sortby\", query.getsortby()); dict.addifnotnullorempty(\"userid\", query.getuserid()); if (query.getchannelids() != null) { dict.add(\"channelids\", tangible.dotnettojavastringhelper.join(\",\", query.getchannelids())); } string url = getapiurl(\"livetv\/programs\", dict); url = adddataformat(url); send(url, \"get\", new serializedresponse<>(response, jsonserializer, itemsresult.class)); }","repo":"AndreasGB\/jellyfin-apiclient-java","label":[0,1,0,0]}
{"id":19828,"original_code":"@Test\n\tpublic void testPositionConstructor() {\n\t\tposition = new Position(rowInRange, cellInRange);\n\t\t\/\/ I know tests need to be independent but not sure how else to do this\n\t\tassertEquals(rowInRange, position.getRow());\n\t\tassertEquals(cellInRange, position.getCell());\n\t}","code_wo_comment":"@Test\n\tpublic void testPositionConstructor() {\n\t\tposition = new Position(rowInRange, cellInRange);\n\t\n\t\tassertEquals(rowInRange, position.getRow());\n\t\tassertEquals(cellInRange, position.getCell());\n\t}","cleancode":"@test public void testpositionconstructor() { position = new position(rowinrange, cellinrange); assertequals(rowinrange, position.getrow()); assertequals(cellinrange, position.getcell()); }","repo":"DaniloSosa98\/SE-WebCheckers","label":[1,0,0,0]}
{"id":11711,"original_code":"@GET\n  @Path(\"{connectorId}\/contents\")\n  public Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\n    Connector connector = getConnector(connectorId);\n    InputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\n    if (content == null) {\n      return JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n    }\n    \/\/ nre: TODO: Why not guess by extension?\n    try {\n      return JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n              .header(\"Content-Type\", type.getMimeType())\n              .build();\n    } finally {\n      IoUtil.closeSilently(content);\n    }\n  }","code_wo_comment":"@GET\n  @Path(\"{connectorId}\/contents\")\n  public Response getTypedContent(@PathParam(\"connectorId\") long connectorId, @QueryParam(\"nodeId\") String nodeId, @QueryParam(\"type\") ConnectorNodeType type) {\n    Connector connector = getConnector(connectorId);\n    InputStream content = connector.getContent(new ConnectorNode(nodeId, null, type));\n    if (content == null) {\n      return JaxRsUtil.createResponse().status(Response.Status.NOT_FOUND).build();\n    }\n   \n    try {\n      return JaxRsUtil.createResponse().status(Status.OK).entity(IoUtil.readInputStream(content, connectorId + \"-\" + nodeId + \"-content-stream\"))\n              .header(\"Content-Type\", type.getMimeType())\n              .build();\n    } finally {\n      IoUtil.closeSilently(content);\n    }\n  }","cleancode":"@get @path(\"{connectorid}\/contents\") public response gettypedcontent(@pathparam(\"connectorid\") long connectorid, @queryparam(\"nodeid\") string nodeid, @queryparam(\"type\") connectornodetype type) { connector connector = getconnector(connectorid); inputstream content = connector.getcontent(new connectornode(nodeid, null, type)); if (content == null) { return jaxrsutil.createresponse().status(response.status.not_found).build(); } try { return jaxrsutil.createresponse().status(status.ok).entity(ioutil.readinputstream(content, connectorid + \"-\" + nodeid + \"-content-stream\")) .header(\"content-type\", type.getmimetype()) .build(); } finally { ioutil.closesilently(content); } }","repo":"1and1\/camunda-bpm-platform","label":[1,0,0,0]}
{"id":3528,"original_code":"private Complex getFeederLoadVA(String sourceBusId) {\n\t\tBus3Phase sourceBus = (Bus3Phase) this.net.getBus(sourceBusId);\n\t\tComplex3x1 vabc_1 = sourceBus.get3PhaseVotlages();\n\t\tComplex3x1 currInj3Phase = new Complex3x1();\n\t\tfor(Branch bra: sourceBus.getConnectedPhysicalBranchList()){\n\t\t\tif(bra.isActive()){\n\t\t\t\tBranch3Phase acLine = (Branch3Phase) bra;\n\t\t\t\tComplex3x1 Isource = null;\n\t\t\t\tif(bra.getFromBus().getId().equals(sourceBus.getId())){\n\t\t\t\t\tBus3Phase toBus = (Bus3Phase) bra.getToBus();\n\t\t\t\t\tComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Yft = acLine.getYftabc();\n\t\t\t\t\tComplex3x3 Yff = acLine.getYffabc();\n\t\t\t\t\tIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\n\t\t\t\t\tComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Ytf = acLine.getYtfabc();\n\t\t\t\t\tComplex3x3 Ytt = acLine.getYttabc();\n\t\t\t\t\tIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/TODO this needs to be updated if actual values are used in the distribution system\n\t\tdouble distVABase = this.net.getBaseMva()*1.0E6;\n\t\tBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus; \n\t\t\/\/ from distribution to transmission\n\t\tComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\n\t\treturn totalPower.multiply(-1.0);\n\t}","code_wo_comment":"private Complex getFeederLoadVA(String sourceBusId) {\n\t\tBus3Phase sourceBus = (Bus3Phase) this.net.getBus(sourceBusId);\n\t\tComplex3x1 vabc_1 = sourceBus.get3PhaseVotlages();\n\t\tComplex3x1 currInj3Phase = new Complex3x1();\n\t\tfor(Branch bra: sourceBus.getConnectedPhysicalBranchList()){\n\t\t\tif(bra.isActive()){\n\t\t\t\tBranch3Phase acLine = (Branch3Phase) bra;\n\t\t\t\tComplex3x1 Isource = null;\n\t\t\t\tif(bra.getFromBus().getId().equals(sourceBus.getId())){\n\t\t\t\t\tBus3Phase toBus = (Bus3Phase) bra.getToBus();\n\t\t\t\t\tComplex3x1 vabc_2 = toBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Yft = acLine.getYftabc();\n\t\t\t\t\tComplex3x3 Yff = acLine.getYffabc();\n\t\t\t\t\tIsource = Yff.multiply(vabc_1).add(Yft.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource );\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tBus3Phase fromBus = (Bus3Phase) bra.getFromBus();\n\t\t\t\t\tComplex3x1 vabc_2 = fromBus.get3PhaseVotlages();\n\t\t\t\t\tComplex3x3 Ytf = acLine.getYtfabc();\n\t\t\t\t\tComplex3x3 Ytt = acLine.getYttabc();\n\t\t\t\t\tIsource = Ytt.multiply(vabc_1).add(Ytf.multiply(vabc_2));\n\t\t\t\t\tcurrInj3Phase = currInj3Phase.subtract(Isource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tdouble distVABase = this.net.getBaseMva()*1.0E6;\n\t\tBus3Phase sourceBus3Ph = (Bus3Phase) sourceBus; \n\t\n\t\tComplex totalPower = sourceBus3Ph.get3PhaseVotlages().dotProduct(currInj3Phase.conjugate()).divide(3.0).multiply(distVABase);\n\t\treturn totalPower.multiply(-1.0);\n\t}","cleancode":"private complex getfeederloadva(string sourcebusid) { bus3phase sourcebus = (bus3phase) this.net.getbus(sourcebusid); complex3x1 vabc_1 = sourcebus.get3phasevotlages(); complex3x1 currinj3phase = new complex3x1(); for(branch bra: sourcebus.getconnectedphysicalbranchlist()){ if(bra.isactive()){ branch3phase acline = (branch3phase) bra; complex3x1 isource = null; if(bra.getfrombus().getid().equals(sourcebus.getid())){ bus3phase tobus = (bus3phase) bra.gettobus(); complex3x1 vabc_2 = tobus.get3phasevotlages(); complex3x3 yft = acline.getyftabc(); complex3x3 yff = acline.getyffabc(); isource = yff.multiply(vabc_1).add(yft.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource ); } else{ bus3phase frombus = (bus3phase) bra.getfrombus(); complex3x1 vabc_2 = frombus.get3phasevotlages(); complex3x3 ytf = acline.getytfabc(); complex3x3 ytt = acline.getyttabc(); isource = ytt.multiply(vabc_1).add(ytf.multiply(vabc_2)); currinj3phase = currinj3phase.subtract(isource); } } } double distvabase = this.net.getbasemva()*1.0e6; bus3phase sourcebus3ph = (bus3phase) sourcebus; complex totalpower = sourcebus3ph.get3phasevotlages().dotproduct(currinj3phase.conjugate()).divide(3.0).multiply(distvabase); return totalpower.multiply(-1.0); }","repo":"GMLC-TDC\/Use-Cases","label":[1,0,0,0]}
{"id":11856,"original_code":"@Override\n   public <K> void executeTask(\n           final AdvancedCacheLoader.KeyFilter<K> filter,\n           final ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n   ) throws InterruptedException{\n      if (filter == null)\n         throw new IllegalArgumentException(\"No filter specified\");\n      if (action == null)\n         throw new IllegalArgumentException(\"No action specified\");\n      ParallelIterableMap<Object, InternalCacheEntry> map =\n              (ParallelIterableMap<Object, InternalCacheEntry>) entries;\n       map.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n           @Override\n           public void apply(Object o, InternalCacheEntry internalCacheEntry) {\n           }\n\/\/         @Override\n\/\/         public void apply(Object key, OffHeapInternalCacheEntry value) {\n\/\/            if (filter.shouldLoadKey((K)key)) {\n\/\/               action.apply((K)key, value);\n\/\/            }\n\/\/         }\n      });\n      \/\/TODO figure out the way how to do interruption better (during iteration)\n      if(Thread.currentThread().isInterrupted()){\n         throw new InterruptedException();\n      }\n   }","code_wo_comment":"@Override\n   public <K> void executeTask(\n           final AdvancedCacheLoader.KeyFilter<K> filter,\n           final ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry> action\n   ) throws InterruptedException{\n      if (filter == null)\n         throw new IllegalArgumentException(\"No filter specified\");\n      if (action == null)\n         throw new IllegalArgumentException(\"No action specified\");\n      ParallelIterableMap<Object, InternalCacheEntry> map =\n              (ParallelIterableMap<Object, InternalCacheEntry>) entries;\n       map.forEach(512, new ParallelIterableMap.KeyValueAction<Object, InternalCacheEntry>() {\n           @Override\n           public void apply(Object o, InternalCacheEntry internalCacheEntry) {\n           }\n      });\n     \n      if(Thread.currentThread().isInterrupted()){\n         throw new InterruptedException();\n      }\n   }","cleancode":"@override public <k> void executetask( final advancedcacheloader.keyfilter<k> filter, final paralleliterablemap.keyvalueaction<object, internalcacheentry> action ) throws interruptedexception{ if (filter == null) throw new illegalargumentexception(\"no filter specified\"); if (action == null) throw new illegalargumentexception(\"no action specified\"); paralleliterablemap<object, internalcacheentry> map = (paralleliterablemap<object, internalcacheentry>) entries; map.foreach(512, new paralleliterablemap.keyvalueaction<object, internalcacheentry>() { @override public void apply(object o, internalcacheentry internalcacheentry) { } }); if(thread.currentthread().isinterrupted()){ throw new interruptedexception(); } }","repo":"Cotton-Ben\/infinispan","label":[1,0,0,0]}
{"id":11891,"original_code":"@Override\n    public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n      Iterator<Integer> indexItr = order.iterator();\n      V result = initResult();\n      for (Future<K> future : futures) {\n        \/\/ TODO: the max time this can take is actually N * timeout. Consider fixing this.\n        result = aggregate(future.get(timeout, unit), indexItr, result);\n      }\n      return result;\n    }","code_wo_comment":"@Override\n    public final V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n      Iterator<Integer> indexItr = order.iterator();\n      V result = initResult();\n      for (Future<K> future : futures) {\n       \n        result = aggregate(future.get(timeout, unit), indexItr, result);\n      }\n      return result;\n    }","cleancode":"@override public final v get(long timeout, timeunit unit) throws interruptedexception, executionexception, timeoutexception { iterator<integer> indexitr = order.iterator(); v result = initresult(); for (future<k> future : futures) { result = aggregate(future.get(timeout, unit), indexitr, result); } return result; }","repo":"CyberFlameGO\/appengine-java-standard","label":[1,0,0,0]}
{"id":11905,"original_code":"private void processCommands(GuildMessageReceivedEvent event, GuildData guildData, String trigger, String[] args, boolean isMention) {\n        ICommandMain cmd = CascadeBot.INS.getCommandManager().getCommand(trigger, event.getAuthor(), guildData);\n        if (cmd != null) {\n            if (cmd.getModule().isPublicModule() &&\n                    !guildData.isModuleEnabled(cmd.getModule())) {\n                if (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\n                    EmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\n                    builder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\n                    builder.setTimestamp(Instant.now());\n                    builder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\n                    Messaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n                }\n                \/\/ TODO: Modlog?\n                return;\n            }\n            CommandContext context = new CommandContext(\n                    event.getJDA(),\n                    event.getChannel(),\n                    event.getMessage(),\n                    event.getGuild(),\n                    guildData,\n                    args,\n                    event.getMember(),\n                    trigger,\n                    isMention\n            );\n            if (args.length >= 1) {\n                if (processSubCommands(cmd, args, context)) {\n                    return;\n                }\n            }\n            dispatchCommand(cmd, context);\n        }\n    }","code_wo_comment":"private void processCommands(GuildMessageReceivedEvent event, GuildData guildData, String trigger, String[] args, boolean isMention) {\n        ICommandMain cmd = CascadeBot.INS.getCommandManager().getCommand(trigger, event.getAuthor(), guildData);\n        if (cmd != null) {\n            if (cmd.getModule().isPublicModule() &&\n                    !guildData.isModuleEnabled(cmd.getModule())) {\n                if (guildData.getSettings().willDisplayModuleErrors() || Environment.isDevelopment()) {\n                    EmbedBuilder builder = MessagingObjects.getClearThreadLocalEmbedBuilder();\n                    builder.setDescription(String.format(\"The module `%s` for command `%s` is disabled!\", cmd.getModule().toString(), trigger));\n                    builder.setTimestamp(Instant.now());\n                    builder.setFooter(\"Requested by \" + event.getAuthor().getAsTag(), event.getAuthor().getEffectiveAvatarUrl());\n                    Messaging.sendDangerMessage(event.getChannel(), builder, guildData.getSettings().useEmbedForMessages());\n                }\n               \n                return;\n            }\n            CommandContext context = new CommandContext(\n                    event.getJDA(),\n                    event.getChannel(),\n                    event.getMessage(),\n                    event.getGuild(),\n                    guildData,\n                    args,\n                    event.getMember(),\n                    trigger,\n                    isMention\n            );\n            if (args.length >= 1) {\n                if (processSubCommands(cmd, args, context)) {\n                    return;\n                }\n            }\n            dispatchCommand(cmd, context);\n        }\n    }","cleancode":"private void processcommands(guildmessagereceivedevent event, guilddata guilddata, string trigger, string[] args, boolean ismention) { icommandmain cmd = cascadebot.ins.getcommandmanager().getcommand(trigger, event.getauthor(), guilddata); if (cmd != null) { if (cmd.getmodule().ispublicmodule() && !guilddata.ismoduleenabled(cmd.getmodule())) { if (guilddata.getsettings().willdisplaymoduleerrors() || environment.isdevelopment()) { embedbuilder builder = messagingobjects.getclearthreadlocalembedbuilder(); builder.setdescription(string.format(\"the module `%s` for command `%s` is disabled!\", cmd.getmodule().tostring(), trigger)); builder.settimestamp(instant.now()); builder.setfooter(\"requested by \" + event.getauthor().getastag(), event.getauthor().geteffectiveavatarurl()); messaging.senddangermessage(event.getchannel(), builder, guilddata.getsettings().useembedformessages()); } return; } commandcontext context = new commandcontext( event.getjda(), event.getchannel(), event.getmessage(), event.getguild(), guilddata, args, event.getmember(), trigger, ismention ); if (args.length >= 1) { if (processsubcommands(cmd, args, context)) { return; } } dispatchcommand(cmd, context); } }","repo":"Ikinon\/CascadeBot","label":[0,1,0,0]}
{"id":3730,"original_code":"@Override\n        public MutableList<T> clone()\n        {\n            return new FastList<T>(this);\n        }","code_wo_comment":"@Override\n        public MutableList<T> clone()\n        {\n            return new FastList<T>(this);\n        }","cleancode":"@override public mutablelist<t> clone() { return new fastlist<t>(this); }","repo":"DiegoEliasCosta\/gs-collections","label":[1,0,0,0]}
{"id":3764,"original_code":"@PostMapping(\"{id}\/bloqueio\")\n    public ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\n        String ip = request.getRemoteAddr();\n        String userAgent = request.getHeader(HttpHeaders.USER_AGENT);\n        Optional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\n        if(possivelProposta.isEmpty()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\n            return ResponseEntity.notFound().build();\n        }\n        Proposta proposta = possivelProposta.get();\n        if(proposta.estaBloqueado()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\n            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n        }\n        if(!notificarLegado(id)){\n            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n                    .body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n        }\n        proposta.bloquear(ip, userAgent);\n        propostaRepository.save(proposta);\n        logger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\n        return ResponseEntity.ok().build();\n    }","code_wo_comment":"@PostMapping(\"{id}\/bloqueio\")\n    public ResponseEntity<?> bloquear(HttpServletRequest request, @PathVariable String id){\n        String ip = request.getRemoteAddr();\n        String userAgent = request.getHeader(HttpHeaders.USER_AGENT);\n        Optional<Proposta> possivelProposta = propostaRepository.findByNumeroCartao(id);\n        if(possivelProposta.isEmpty()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id);\n            return ResponseEntity.notFound().build();\n        }\n        Proposta proposta = possivelProposta.get();\n        if(proposta.estaBloqueado()){\n            logger.info(\"Tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id);\n            return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build();\n        }\n        if(!notificarLegado(id)){\n            return ResponseEntity.status(HttpStatus.BAD_GATEWAY)\n                    .body(Map.of(\"message\", \"N\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\"));\n        }\n        proposta.bloquear(ip, userAgent);\n        propostaRepository.save(proposta);\n        logger.info(\"Cart\u00e3o: {} bloqueado com sucesso\", id);\n        return ResponseEntity.ok().build();\n    }","cleancode":"@postmapping(\"{id}\/bloqueio\") public responseentity<?> bloquear(httpservletrequest request, @pathvariable string id){ string ip = request.getremoteaddr(); string useragent = request.getheader(httpheaders.user_agent); optional<proposta> possivelproposta = propostarepository.findbynumerocartao(id); if(possivelproposta.isempty()){ logger.info(\"tentativa de bloqueio, cartao: {} n\u00e3o encontrado\", id); return responseentity.notfound().build(); } proposta proposta = possivelproposta.get(); if(proposta.establoqueado()){ logger.info(\"tentativa de bloqueio, cartao: {} j\u00e1 bloqueado\", id); return responseentity.status(httpstatus.unprocessable_entity).build(); } if(!notificarlegado(id)){ return responseentity.status(httpstatus.bad_gateway) .body(map.of(\"message\", \"n\u00e3o foi possivel concluir a a\u00e7\u00e3o, tente mais tarde\")); } proposta.bloquear(ip, useragent); propostarepository.save(proposta); logger.info(\"cart\u00e3o: {} bloqueado com sucesso\", id); return responseentity.ok().build(); }","repo":"EDUMATT3\/orange-talents-06-template-proposta","label":[1,0,0,0]}
{"id":20267,"original_code":"@Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.send_to_this_address_action: {\n                if (onSendToAddressClickListener != null) {\n                    onSendToAddressClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.add_custom_token_action: {\n                if (onAddCustonTokenClickListener != null) {\n                    onAddCustonTokenClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.watch_account_action: {\n                if (onWatchWalletClickListener != null) {\n                    onWatchWalletClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.open_in_etherscan_action: {\n                if (onOpenInEtherscanClickListener != null) {\n                    onOpenInEtherscanClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.close_action: {\n                if (onCloseActionListener != null) {\n                    onCloseActionListener.onClick(view);\n                }\n                break;\n            }\n        }\n    }","code_wo_comment":"@Override\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.send_to_this_address_action: {\n                if (onSendToAddressClickListener != null) {\n                    onSendToAddressClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.add_custom_token_action: {\n                if (onAddCustonTokenClickListener != null) {\n                    onAddCustonTokenClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.watch_account_action: {\n                if (onWatchWalletClickListener != null) {\n                    onWatchWalletClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.open_in_etherscan_action: {\n                if (onOpenInEtherscanClickListener != null) {\n                    onOpenInEtherscanClickListener.onClick(view);\n                }\n                break;\n            }\n            case R.id.close_action: {\n                if (onCloseActionListener != null) {\n                    onCloseActionListener.onClick(view);\n                }\n                break;\n            }\n        }\n    }","cleancode":"@override public void onclick(view view) { switch (view.getid()) { case r.id.send_to_this_address_action: { if (onsendtoaddressclicklistener != null) { onsendtoaddressclicklistener.onclick(view); } break; } case r.id.add_custom_token_action: { if (onaddcustontokenclicklistener != null) { onaddcustontokenclicklistener.onclick(view); } break; } case r.id.watch_account_action: { if (onwatchwalletclicklistener != null) { onwatchwalletclicklistener.onclick(view); } break; } case r.id.open_in_etherscan_action: { if (onopeninetherscanclicklistener != null) { onopeninetherscanclicklistener.onclick(view); } break; } case r.id.close_action: { if (oncloseactionlistener != null) { oncloseactionlistener.onclick(view); } break; } } }","repo":"HTSUPK\/alpha-wallet-android","label":[1,0,0,0]}
{"id":20270,"original_code":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\n\t\tif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\n\t\t\tthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n\t\t}\n\t\tURI source = extractParameterAsUri(req, \"source\");\n\t\tURI target = extractParameterAsUri(req, \"target\");\n\t\t\/\/ Spec: 'The receiver MUST reject the request if the source URL is the same as the target URL.'\n\t\tif (source.equals(target)) {\n\t\t\tthrow new BadRequestException(\"Source and target URL must not be identical.\");\n\t\t}\n\t\t\/\/ TODO: allow configuration of allowed target URI hosts.\n\t\tLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\t\t\/\/ TODO: perform check async\n\t\t\/*\n\t\t * Spec:\n\t\t * 'If the receiver is going to use the Webmention in some way, (displaying it as a comment on a post,\n\t\t * incrementing a \"like\" counter, notifying the author of a post), then it MUST perform an HTTP GET request\n\t\t * on source [...] to confirm that it actually mentions the target.\n\t\t *\/\n\t\ttry {\n\t\t\tif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\t\t\t\tLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget);\n\t\t\t} else {\n\t\t\t\tthrow new BadRequestException(\"Source does not contain link to target URL.\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t\/\/ In theory I\/O failures cold also be issues on our side (e.g. trusted CAs being wrong), but\n\t\t\t\/\/ differentiating between those and issues on the source URIs side (e.g. 404s) seems hard.\n\t\t\tthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n\t\t} catch (VerificationService.UnsupportedContentTypeException e) {\n\t\t\tthrow new BadRequestException(\n\t\t\t\t\"Verification of source URL failed due to no supported content type being served.\",\n\t\t\t\te);\n\t\t}\n\t\thandleSubmission(source, target);\n\t}","code_wo_comment":"private void processRequest(@NotNull HttpServletRequest req) throws BadRequestException {\n\t\tif (!EXPECTED_CONTENT_TYPE.isSameMimeType(ContentType.parse(req.getContentType()))) {\n\t\t\tthrow new BadRequestException(\"Content type must be '%s'.\".formatted(EXPECTED_CONTENT_TYPE.getMimeType()));\n\t\t}\n\t\tURI source = extractParameterAsUri(req, \"source\");\n\t\tURI target = extractParameterAsUri(req, \"target\");\n\t\n\t\tif (source.equals(target)) {\n\t\t\tthrow new BadRequestException(\"Source and target URL must not be identical.\");\n\t\t}\n\t\n\t\tLOGGER.debug(\"Received webmention submission request with source='{}' and target='{}'.\", source, target);\n\t\n\t\n\t\ttry {\n\t\t\tif (verificationService.isSubmissionValid(httpClient, source, target)) {\n\t\t\t\tLOGGER.debug(\"Webmention submission request with source='{}' and target='{}' passed verification.\",\n\t\t\t\t\tsource,\n\t\t\t\t\ttarget);\n\t\t\t} else {\n\t\t\t\tthrow new BadRequestException(\"Source does not contain link to target URL.\");\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\n\t\t\n\t\t\tthrow new BadRequestException(\"Verification of source URL could not be performed.\", e);\n\t\t} catch (VerificationService.UnsupportedContentTypeException e) {\n\t\t\tthrow new BadRequestException(\n\t\t\t\t\"Verification of source URL failed due to no supported content type being served.\",\n\t\t\t\te);\n\t\t}\n\t\thandleSubmission(source, target);\n\t}","cleancode":"private void processrequest(@notnull httpservletrequest req) throws badrequestexception { if (!expected_content_type.issamemimetype(contenttype.parse(req.getcontenttype()))) { throw new badrequestexception(\"content type must be '%s'.\".formatted(expected_content_type.getmimetype())); } uri source = extractparameterasuri(req, \"source\"); uri target = extractparameterasuri(req, \"target\"); if (source.equals(target)) { throw new badrequestexception(\"source and target url must not be identical.\"); } logger.debug(\"received webmention submission request with source='{}' and target='{}'.\", source, target); try { if (verificationservice.issubmissionvalid(httpclient, source, target)) { logger.debug(\"webmention submission request with source='{}' and target='{}' passed verification.\", source, target); } else { throw new badrequestexception(\"source does not contain link to target url.\"); } } catch (ioexception e) { throw new badrequestexception(\"verification of source url could not be performed.\", e); } catch (verificationservice.unsupportedcontenttypeexception e) { throw new badrequestexception( \"verification of source url failed due to no supported content type being served.\", e); } handlesubmission(source, target); }","repo":"FelixRilling\/webmention4j","label":[1,1,0,0]}
{"id":20319,"original_code":"@BeforeEach\n    public void setUp() throws Exception {\n        \/\/ Hack our RouteBuilder into the context. Bean definition \/ ComponentScan doesn't work for RouteBuilders.\n        if (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\n            camelContext.addRoutes(ccrsAdapter);\n        }\n        if (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\n            camelContext.addRoutes(ccrsClient);\n        }\n    }","code_wo_comment":"@BeforeEach\n    public void setUp() throws Exception {\n       \n        if (camelContext.getRoute(CamelCustomerRatingServiceAdapter.URI) == null) {\n            camelContext.addRoutes(ccrsAdapter);\n        }\n        if (camelContext.getRoute(CamelCustomerRatingServiceClient.URI) == null) {\n            camelContext.addRoutes(ccrsClient);\n        }\n    }","cleancode":"@beforeeach public void setup() throws exception { if (camelcontext.getroute(camelcustomerratingserviceadapter.uri) == null) { camelcontext.addroutes(ccrsadapter); } if (camelcontext.getroute(camelcustomerratingserviceclient.uri) == null) { camelcontext.addroutes(ccrsclient); } }","repo":"BertKoor\/camelCase","label":[0,0,1,0]}
{"id":20732,"original_code":"public static void exportTaskgraph() {\n        final TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\n        final FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\n        int result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\n        if (result == TFileChooser.APPROVE_OPTION) {\n            Thread thread = new Thread() {\n                public void run() {\n                    TrianaProgressBar pb = null;\n                    String filename = \"\";\n                    try {\n                        \/\/ Bug fix for not picking up file name text.\n                        if (fc.getUI() instanceof BasicFileChooserUI) {\n                            filename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n                        }\n                        pb = new TrianaProgressBar(\"exporting: \" + filename, false);\n                        chooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n                    } catch (IOException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } catch (TaskGraphException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } finally {\n                        if (pb != null) {\n                            pb.disposeProgressBar();\n                        }\n                    }\n                }\n            };\n            thread.setName(\"Export Task Graph\");\n            thread.setPriority(Thread.NORM_PRIORITY);\n            thread.start();\n        }\n    }","code_wo_comment":"public static void exportTaskgraph() {\n        final TFileChooser fc = new TFileChooser(EXPORT_TASKGRAPH_DIR);\n        final FileImportExportDecorator chooser = new FileImportExportDecorator(fc);\n        int result = chooser.showExportDialog(GUIEnv.getApplicationFrame());\n        if (result == TFileChooser.APPROVE_OPTION) {\n            Thread thread = new Thread() {\n                public void run() {\n                    TrianaProgressBar pb = null;\n                    String filename = \"\";\n                    try {\n                       \n                        if (fc.getUI() instanceof BasicFileChooserUI) {\n                            filename = ((BasicFileChooserUI) fc.getUI()).getFileName();\n                        }\n                        pb = new TrianaProgressBar(\"exporting: \" + filename, false);\n                        chooser.exportWorkflow(GUIEnv.getApplicationFrame().getSelectedTaskGraphPanel().getTaskGraph());\n                    } catch (IOException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } catch (TaskGraphException e) {\n                        ErrorDialog.show(\"Error Exporting TaskGraph\", e.getMessage());\n                        e.printStackTrace();\n                    } finally {\n                        if (pb != null) {\n                            pb.disposeProgressBar();\n                        }\n                    }\n                }\n            };\n            thread.setName(\"Export Task Graph\");\n            thread.setPriority(Thread.NORM_PRIORITY);\n            thread.start();\n        }\n    }","cleancode":"public static void exporttaskgraph() { final tfilechooser fc = new tfilechooser(export_taskgraph_dir); final fileimportexportdecorator chooser = new fileimportexportdecorator(fc); int result = chooser.showexportdialog(guienv.getapplicationframe()); if (result == tfilechooser.approve_option) { thread thread = new thread() { public void run() { trianaprogressbar pb = null; string filename = \"\"; try { if (fc.getui() instanceof basicfilechooserui) { filename = ((basicfilechooserui) fc.getui()).getfilename(); } pb = new trianaprogressbar(\"exporting: \" + filename, false); chooser.exportworkflow(guienv.getapplicationframe().getselectedtaskgraphpanel().gettaskgraph()); } catch (ioexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } catch (taskgraphexception e) { errordialog.show(\"error exporting taskgraph\", e.getmessage()); e.printstacktrace(); } finally { if (pb != null) { pb.disposeprogressbar(); } } } }; thread.setname(\"export task graph\"); thread.setpriority(thread.norm_priority); thread.start(); } }","repo":"CSCSI\/Triana","label":[0,0,1,0]}
{"id":20999,"original_code":"@Override\n\tpublic KVMessage putKV(final int clientPort, final String key, final String value)\n\t\t\tthrows InvalidMessageException {\n\t\tlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\n\t\tKVMessage res;\n\t\tStatusType putStat;\n\t\t\/\/ TODO: Cleanup the clientRequests after the requests are completed\n\t\tclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\n\t\tNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\t\t\/\/ add thread to back of list for this key - add is thread safe\n\t\tint[] node = { clientPort, op.getVal() };\n\t\tclientRequests.get(key).addToQueue(node);\n\t\tif (test) {\n\t\t\tlogger.info(clientPort + \"> !!!!===wait===!!!!\");\n\t\t\twhile (wait)\n\t\t\t\t;\n\t\t\tlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n\t\t}\n\t\t\/\/ wait (spin) until threads turn and no one is reading\n\t\t\/\/ TODO: If a key gets deleted, I think clientRequests.get(key) would no longer\n\t\t\/\/ work\n\t\twhile (clientRequests.get(key).peek()[0] != clientPort)\n\t\t\t;\n\t\t\/\/ while (clientRequests.get(key).peek()[0] != clientPort ||\n\t\t\/\/ clientRequests.get(key).availablePermits() != MAX_READS);\n\t\tlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\n\t\tif (value.equals(\"null\")) {\n\t\t\t\/\/ Delete the key\n\t\t\tlogger.info(clientPort + \"> Trying to delete record ...\");\n\t\t\tputStat = StatusType.DELETE_SUCCESS;\n\t\t\ttry {\n\t\t\t\t\/\/ TODO: Mark it as deleted then loop to see if anybody is reading\/writing to it\n\t\t\t\t\/\/ If a write is after, keep the row by unmarking it as deleted (since the\n\t\t\t\t\/\/ operation cancels)\n\t\t\t\t\/\/ If a read is after, check the deleted flag, if its deleted, make sure to\n\t\t\t\t\/\/ return key DNE\n\t\t\t\t\/\/ Otherwise, return the key\n\t\t\t\t\/\/ If at any point the queue is empty, and the row is marked as deleted, THEN\n\t\t\t\t\/\/ remove it from the clientRequests\n\t\t\t\t\/\/ Delete it from the cache as well!\n\t\t\t\t\/\/ remove the top item from the list for this key\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\tlogger.info(clientPort + \"> Not in storage ...\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t} else if (!clientRequests.get(key).isDeleted()) {\n\t\t\t\t\tlogger.info(clientPort + \"> Marked for deletion\");\n\t\t\t\t\tclientRequests.get(key).setDeleted(true);\n\t\t\t\t\tRunnable pruneDelete = new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> Starting pruning thread\");\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\/\/ logger.debug(\"Prune waiting\");\n\t\t\t\t\t\t\t} while (!clientRequests.get(key).isEmpty());\n\t\t\t\t\t\t\tclientRequests.remove(key);\n\t\t\t\t\t\t\tif (cache != null) {\n\t\t\t\t\t\t\t\tcache.remove(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFile file = new File(storageDirectory + key);\n\t\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tclientRequests.get(key).startPruning(pruneDelete);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.info(clientPort + \"> Deletion exception ...\");\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/ Insert\/update the key\n\t\t\tlogger.info(clientPort + \"> Trying to insert\/update record\");\n\t\t\ttry {\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\t\/\/ Inserting a new key\n\t\t\t\t\tlogger.info(clientPort + \"> Going to insert record\");\n\t\t\t\t\tputStat = StatusType.PUT_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ Updating a key\n\t\t\t\t\tlogger.info(clientPort + \"> Going to update record\");\n\t\t\t\t\tputStat = StatusType.PUT_UPDATE;\n\t\t\t\t\tif (clientRequests.get(key).isDeleted()) {\n\t\t\t\t\t\t\/\/ Stop the deletion\n\t\t\t\t\t\tclientRequests.get(key).stopPruning();\n\t\t\t\t\t\tclientRequests.get(key).setDeleted(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinsertCache(key, value);\n\t\t\t\tFileWriter myWriter = new FileWriter(storageDirectory + key);\n\t\t\t\tmyWriter.write(value);\n\t\t\t\tmyWriter.close();\n\t\t\t\t\/\/ Sleep for a bit to let data take effect\n\t\t\t\t\/\/ Thread.sleep(1000);\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.PUT_ERROR;\n\t\t\t}\n\t\t}\n\t\t\/\/ remove the top item from the list for this key\n\t\tremoveTopQueue(key);\n\t\tlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\n\t\ttry {\n\t\t\tres = new KVMessage(key, value, putStat);\n\t\t} catch (InvalidMessageException ime) {\n\t\t\tthrow ime;\n\t\t}\n\t\treturn res;\n\t}","code_wo_comment":"@Override\n\tpublic KVMessage putKV(final int clientPort, final String key, final String value)\n\t\t\tthrows InvalidMessageException {\n\t\tlogger.info(clientPort + \"> PUT for key=\" + key + \" value=\" + value);\n\t\tKVMessage res;\n\t\tStatusType putStat;\n\t\n\t\tclientRequests.putIfAbsent(key, new ConcurrentNode(MAX_READS));\n\t\tNodeOperation op = value.equals(\"null\") ? NodeOperation.DELETE : NodeOperation.WRITE;\n\t\n\t\tint[] node = { clientPort, op.getVal() };\n\t\tclientRequests.get(key).addToQueue(node);\n\t\tif (test) {\n\t\t\tlogger.info(clientPort + \"> !!!!===wait===!!!!\");\n\t\t\twhile (wait)\n\t\t\t\t;\n\t\t\tlogger.info(clientPort + \"> !!!!===DONE WAITING===!!!!\");\n\t\t}\n\t\n\t\n\t\n\t\twhile (clientRequests.get(key).peek()[0] != clientPort)\n\t\t\t;\n\t\n\t\n\t\tlogger.info(clientPort + \"> !!!!===Finished spinning===!!!!\");\n\t\tif (value.equals(\"null\")) {\n\t\t\n\t\t\tlogger.info(clientPort + \"> Trying to delete record ...\");\n\t\t\tputStat = StatusType.DELETE_SUCCESS;\n\t\t\ttry {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\tlogger.info(clientPort + \"> Not in storage ...\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t} else if (!clientRequests.get(key).isDeleted()) {\n\t\t\t\t\tlogger.info(clientPort + \"> Marked for deletion\");\n\t\t\t\t\tclientRequests.get(key).setDeleted(true);\n\t\t\t\t\tRunnable pruneDelete = new Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> Starting pruning thread\");\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} while (!clientRequests.get(key).isEmpty());\n\t\t\t\t\t\t\tclientRequests.remove(key);\n\t\t\t\t\t\t\tif (cache != null) {\n\t\t\t\t\t\t\t\tcache.remove(key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tFile file = new File(storageDirectory + key);\n\t\t\t\t\t\t\tfile.delete();\n\t\t\t\t\t\t\tlogger.info(clientPort + \"> \" + key + \" successfully pruned\");\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tclientRequests.get(key).startPruning(pruneDelete);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(clientPort + \"> Key does not exist - marked for deletion!\");\n\t\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.info(clientPort + \"> Deletion exception ...\");\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.DELETE_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\n\t\t\tlogger.info(clientPort + \"> Trying to insert\/update record\");\n\t\t\ttry {\n\t\t\t\tif (!inStorage(key)) {\n\t\t\t\t\n\t\t\t\t\tlogger.info(clientPort + \"> Going to insert record\");\n\t\t\t\t\tputStat = StatusType.PUT_SUCCESS;\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\tlogger.info(clientPort + \"> Going to update record\");\n\t\t\t\t\tputStat = StatusType.PUT_UPDATE;\n\t\t\t\t\tif (clientRequests.get(key).isDeleted()) {\n\t\t\t\t\t\n\t\t\t\t\t\tclientRequests.get(key).stopPruning();\n\t\t\t\t\t\tclientRequests.get(key).setDeleted(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinsertCache(key, value);\n\t\t\t\tFileWriter myWriter = new FileWriter(storageDirectory + key);\n\t\t\t\tmyWriter.write(value);\n\t\t\t\tmyWriter.close();\n\t\t\t\n\t\t\t\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(e);\n\t\t\t\texceptionLogger(e);\n\t\t\t\tputStat = StatusType.PUT_ERROR;\n\t\t\t}\n\t\t}\n\t\n\t\tremoveTopQueue(key);\n\t\tlogger.info(clientPort + \"> !!!!===Removing from queue===!!!!\");\n\t\ttry {\n\t\t\tres = new KVMessage(key, value, putStat);\n\t\t} catch (InvalidMessageException ime) {\n\t\t\tthrow ime;\n\t\t}\n\t\treturn res;\n\t}","cleancode":"@override public kvmessage putkv(final int clientport, final string key, final string value) throws invalidmessageexception { logger.info(clientport + \"> put for key=\" + key + \" value=\" + value); kvmessage res; statustype putstat; clientrequests.putifabsent(key, new concurrentnode(max_reads)); nodeoperation op = value.equals(\"null\") ? nodeoperation.delete : nodeoperation.write; int[] node = { clientport, op.getval() }; clientrequests.get(key).addtoqueue(node); if (test) { logger.info(clientport + \"> !!!!===wait===!!!!\"); while (wait) ; logger.info(clientport + \"> !!!!===done waiting===!!!!\"); } while (clientrequests.get(key).peek()[0] != clientport) ; logger.info(clientport + \"> !!!!===finished spinning===!!!!\"); if (value.equals(\"null\")) { logger.info(clientport + \"> trying to delete record ...\"); putstat = statustype.delete_success; try { if (!instorage(key)) { logger.info(clientport + \"> not in storage ...\"); putstat = statustype.delete_error; } else if (!clientrequests.get(key).isdeleted()) { logger.info(clientport + \"> marked for deletion\"); clientrequests.get(key).setdeleted(true); runnable prunedelete = new runnable() { @override public void run() { logger.info(clientport + \"> starting pruning thread\"); do { } while (!clientrequests.get(key).isempty()); clientrequests.remove(key); if (cache != null) { cache.remove(key); } file file = new file(storagedirectory + key); file.delete(); logger.info(clientport + \"> \" + key + \" successfully pruned\"); } }; clientrequests.get(key).startpruning(prunedelete); } else { logger.info(clientport + \"> key does not exist - marked for deletion!\"); putstat = statustype.delete_error; } } catch (exception e) { logger.info(clientport + \"> deletion exception ...\"); logger.error(e); exceptionlogger(e); putstat = statustype.delete_error; } } else { logger.info(clientport + \"> trying to insert\/update record\"); try { if (!instorage(key)) { logger.info(clientport + \"> going to insert record\"); putstat = statustype.put_success; } else { logger.info(clientport + \"> going to update record\"); putstat = statustype.put_update; if (clientrequests.get(key).isdeleted()) { clientrequests.get(key).stoppruning(); clientrequests.get(key).setdeleted(false); } } insertcache(key, value); filewriter mywriter = new filewriter(storagedirectory + key); mywriter.write(value); mywriter.close(); } catch (exception e) { logger.error(e); exceptionlogger(e); putstat = statustype.put_error; } } removetopqueue(key); logger.info(clientport + \"> !!!!===removing from queue===!!!!\"); try { res = new kvmessage(key, value, putstat); } catch (invalidmessageexception ime) { throw ime; } return res; }","repo":"CAPIndustries\/capDB","label":[1,1,0,0]}
{"id":21001,"original_code":"public static void main(String[] args) {\n\t\ttry {\n\t\t\tif (args.length != 6) {\n\t\t\t\tlogger.error(\"Error! Invalid number of arguments!\");\n\t\t\t\tlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\n\t\t\t\tSystem.exit(1);\n\t\t\t} else {\n\t\t\t\tString name = args[0];\n\t\t\t\tint port = Integer.parseInt(args[1]);\n\t\t\t\tint zkPort = Integer.parseInt(args[2]);\n\t\t\t\tString ECSIP = args[3];\n\t\t\t\tboolean isLoadReplica = Boolean.parseBoolean(args[4]);\n\t\t\t\tString parentName = args[5];\n\t\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\t\t\t\tnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\t\t\t\t\/\/ No need to use the run method here since the contructor is supposed to\n\t\t\t\t\/\/ start the server on its own\n\t\t\t\t\/\/ TODO: Allow passing additional arguments from the command line:\n\t\t\t\tnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Error! Unable to initialize logger!\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\n\t\t\tSystem.out.println(\"Usage: Server <port>!\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","code_wo_comment":"public static void main(String[] args) {\n\t\ttry {\n\t\t\tif (args.length != 6) {\n\t\t\t\tlogger.error(\"Error! Invalid number of arguments!\");\n\t\t\t\tlogger.error(\"Usage: Server <name> <port> <ZooKeeper Port> <ECS IP> <isLoadReplica> <parentName>!\");\n\t\t\t\tSystem.exit(1);\n\t\t\t} else {\n\t\t\t\tString name = args[0];\n\t\t\t\tint port = Integer.parseInt(args[1]);\n\t\t\t\tint zkPort = Integer.parseInt(args[2]);\n\t\t\t\tString ECSIP = args[3];\n\t\t\t\tboolean isLoadReplica = Boolean.parseBoolean(args[4]);\n\t\t\t\tString parentName = args[5];\n\t\t\t\tSimpleDateFormat fmt = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\");\n\t\t\t\tnew LogSetup(\"logs\/\" + name + \"_\" + fmt.format(new Date()) + \".log\", Level.ALL, true);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tnew KVServer(START_CACHE_SIZE, START_CACHE_STRATEGY, name, port, zkPort, ECSIP, isLoadReplica, parentName);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tSystem.out.println(\"Error! Unable to initialize logger!\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t} catch (NumberFormatException nfe) {\n\t\t\tSystem.out.println(\"Error! Invalid argument <port>! Not a number!\");\n\t\t\tSystem.out.println(\"Usage: Server <port>!\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t}","cleancode":"public static void main(string[] args) { try { if (args.length != 6) { logger.error(\"error! invalid number of arguments!\"); logger.error(\"usage: server <name> <port> <zookeeper port> <ecs ip> <isloadreplica> <parentname>!\"); system.exit(1); } else { string name = args[0]; int port = integer.parseint(args[1]); int zkport = integer.parseint(args[2]); string ecsip = args[3]; boolean isloadreplica = boolean.parseboolean(args[4]); string parentname = args[5]; simpledateformat fmt = new simpledateformat(\"yyyy-mm-dd-hh-mm-ss\"); new logsetup(\"logs\/\" + name + \"_\" + fmt.format(new date()) + \".log\", level.all, true); new kvserver(start_cache_size, start_cache_strategy, name, port, zkport, ecsip, isloadreplica, parentname); } } catch (ioexception e) { system.out.println(\"error! unable to initialize logger!\"); e.printstacktrace(); system.exit(1); } catch (numberformatexception nfe) { system.out.println(\"error! invalid argument <port>! not a number!\"); system.out.println(\"usage: server <port>!\"); system.exit(1); } }","repo":"CAPIndustries\/capDB","label":[1,0,0,0]}
{"id":21046,"original_code":"@Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n    \/\/ Inflate the layout for this fragment\n    llView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\n    llView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new StrokePL();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new GroupLayer();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        \/\/TODO This will need to change, for settings, etc.\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        List<Class> classes = new ArrayList<Class>();\n        try {\n          classes = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n        } catch (NoSuchMethodException e) {\n          e.printStackTrace();\n        } catch (IOException e) {\n          e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n          e.printStackTrace();\n        }\n        classes.remove(UACanvas.class);\n        ArrayList<String> classNames = new ArrayList<String>();\n        for (Class<?> clazz : classes) {\n          classNames.add(clazz.getName());\n        }\n        String[] layerTypes = new String[]{};\n        layerTypes = classNames.toArray(layerTypes);\n        final List<Class> fClasses = classes;\n        builder.setTitle(\"Pick a layer type\")\n                .setItems(layerTypes, new DialogInterface.OnClickListener() {\n                  public void onClick(DialogInterface dialog, int which) {\n                    try {\n                      Layer newLayer = (Layer)fClasses.get(which).newInstance();\n                      createLayer(((IDd<ID>)mTree).getId(), newLayer);\n                    } catch (java.lang.InstantiationException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    } catch (IllegalAccessException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    }\n                  }\n                });\n        builder.show();\n      }\n    });\n    updateView();\n    return llView;\n  }","code_wo_comment":"@Override\n  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n   \n    llView = (LinearLayout)inflater.inflate(R.layout.fragment_layers, container, false);\n    llView.findViewById(R.id.btnAddStrokeLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new StrokePL();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddGroupLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n        Layer newLayer = new GroupLayer();\n        createLayer(((IDd<ID>)mTree).getId(), newLayer);\n      }\n    });\n    llView.findViewById(R.id.btnAddOtherLayer).setOnClickListener(new View.OnClickListener() {\n      @Override\n      public void onClick(View v) {\n       \n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n        List<Class> classes = new ArrayList<Class>();\n        try {\n          classes = ClassScanner.getConcreteDescendants(getContext(), Layer.class, null);\n        } catch (NoSuchMethodException e) {\n          e.printStackTrace();\n        } catch (IOException e) {\n          e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n          e.printStackTrace();\n        }\n        classes.remove(UACanvas.class);\n        ArrayList<String> classNames = new ArrayList<String>();\n        for (Class<?> clazz : classes) {\n          classNames.add(clazz.getName());\n        }\n        String[] layerTypes = new String[]{};\n        layerTypes = classNames.toArray(layerTypes);\n        final List<Class> fClasses = classes;\n        builder.setTitle(\"Pick a layer type\")\n                .setItems(layerTypes, new DialogInterface.OnClickListener() {\n                  public void onClick(DialogInterface dialog, int which) {\n                    try {\n                      Layer newLayer = (Layer)fClasses.get(which).newInstance();\n                      createLayer(((IDd<ID>)mTree).getId(), newLayer);\n                    } catch (java.lang.InstantiationException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    } catch (IllegalAccessException e) {\n                      e.printStackTrace();\n                      showToast(\"Error creating layer:\\n\" + e.getMessage());\n                    }\n                  }\n                });\n        builder.show();\n      }\n    });\n    updateView();\n    return llView;\n  }","cleancode":"@override public view oncreateview(layoutinflater inflater, viewgroup container, bundle savedinstancestate) { llview = (linearlayout)inflater.inflate(r.layout.fragment_layers, container, false); llview.findviewbyid(r.id.btnaddstrokelayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new strokepl(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddgrouplayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { layer newlayer = new grouplayer(); createlayer(((idd<id>)mtree).getid(), newlayer); } }); llview.findviewbyid(r.id.btnaddotherlayer).setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { alertdialog.builder builder = new alertdialog.builder(getactivity()); list<class> classes = new arraylist<class>(); try { classes = classscanner.getconcretedescendants(getcontext(), layer.class, null); } catch (nosuchmethodexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } catch (classnotfoundexception e) { e.printstacktrace(); } classes.remove(uacanvas.class); arraylist<string> classnames = new arraylist<string>(); for (class<?> clazz : classes) { classnames.add(clazz.getname()); } string[] layertypes = new string[]{}; layertypes = classnames.toarray(layertypes); final list<class> fclasses = classes; builder.settitle(\"pick a layer type\") .setitems(layertypes, new dialoginterface.onclicklistener() { public void onclick(dialoginterface dialog, int which) { try { layer newlayer = (layer)fclasses.get(which).newinstance(); createlayer(((idd<id>)mtree).getid(), newlayer); } catch (java.lang.instantiationexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } catch (illegalaccessexception e) { e.printstacktrace(); showtoast(\"error creating layer:\\n\" + e.getmessage()); } } }); builder.show(); } }); updateview(); return llview; }","repo":"Erhannis\/UnstableArt","label":[1,0,0,0]}
{"id":21397,"original_code":"private mxGraphComponent createGraphComponent(mxGraph graph) {\n\t\tmxGraphComponent component = new mxGraphComponent(graph);\n\t\tcomponent.setAutoExtend(true);\n\t\tcomponent.setAntiAlias(true);\n\t\tcomponent.setTextAntiAlias(true);\n\t\tcomponent.setToolTips(true);\n\/\/\t\tcomponent.setImportEnabled(false);\n\t\tcomponent.setFoldingEnabled(true);\n\t\tcomponent.setConnectable(false);\n\t\tcomponent.setDragEnabled(false);\n\/\/\t\tcomponent.setKeepSelectionVisibleOnZoom(true);\n\/\/\t\tcomponent.getViewport().setBackground(Color.white);\n\t\t\/\/TODO setup\n\t\treturn component;\n\t}","code_wo_comment":"private mxGraphComponent createGraphComponent(mxGraph graph) {\n\t\tmxGraphComponent component = new mxGraphComponent(graph);\n\t\tcomponent.setAutoExtend(true);\n\t\tcomponent.setAntiAlias(true);\n\t\tcomponent.setTextAntiAlias(true);\n\t\tcomponent.setToolTips(true);\n\t\tcomponent.setFoldingEnabled(true);\n\t\tcomponent.setConnectable(false);\n\t\tcomponent.setDragEnabled(false);\n\t\n\t\treturn component;\n\t}","cleancode":"private mxgraphcomponent creategraphcomponent(mxgraph graph) { mxgraphcomponent component = new mxgraphcomponent(graph); component.setautoextend(true); component.setantialias(true); component.settextantialias(true); component.settooltips(true); component.setfoldingenabled(true); component.setconnectable(false); component.setdragenabled(false); return component; }","repo":"ICARUS-tooling\/icarus2-modeling-framework","label":[0,1,0,0]}
{"id":13266,"original_code":"public int getAge() {\n        \/\/ TODO: put safe grabbing of age here\n        return 0;\n    }","code_wo_comment":"public int getAge() {\n       \n        return 0;\n    }","cleancode":"public int getage() { return 0; }","repo":"210118-java-enterprise\/demos","label":[0,1,0,0]}
{"id":13267,"original_code":"@InstanceName\n    public String getCaption() {\n        \/\/ todo rework when new instance name is ready\n        String pattern =\/* AppContext.getProperty(\"cuba.user.namePattern\");\n        if (StringUtils.isBlank(pattern)) {\n            pattern =*\/ \"{1} [{0}]\";\n        \/*}*\/\n        MessageFormat fmt = new MessageFormat(pattern);\n        return StringUtils.trimToEmpty(fmt.format(new Object[]{\n                StringUtils.trimToEmpty(username),\n                StringUtils.trimToEmpty(name)\n        }));\n    }","code_wo_comment":"@InstanceName\n    public String getCaption() {\n       \n        String pattern  \"{1} [{0}]\";\n       \n        MessageFormat fmt = new MessageFormat(pattern);\n        return StringUtils.trimToEmpty(fmt.format(new Object[]{\n                StringUtils.trimToEmpty(username),\n                StringUtils.trimToEmpty(name)\n        }));\n    }","cleancode":"@instancename public string getcaption() { string pattern \"{1} [{0}]\"; messageformat fmt = new messageformat(pattern); return stringutils.trimtoempty(fmt.format(new object[]{ stringutils.trimtoempty(username), stringutils.trimtoempty(name) })); }","repo":"Haulmont\/jmix-old","label":[1,0,0,0]}
{"id":13309,"original_code":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\n    SolrQuery query = new SolrQuery(queryString);\n    query.setTimeAllowed(queryTimeout);\n    query.setIncludeScore(true); \/\/ The relevance (of each results element) to the search terms.\n    query.setHighlight(false);\n    if (useDismax) {\n      query.set(\"defType\", \"dismax\");\n    }\n    \/\/TODO: Put The \"options\" from the \"queryField\" picklist into a config file.\n    \/\/This list matches the \"options\" from the \"queryField\" picklist on unformattedSearch.ftl,\n    \/\/without the \"date\" fields.\n    query.setStart(startPage * pageSize); \/\/ Which results element to return first in this batch.\n    query.setRows(pageSize); \/\/ The number of results elements to return.\n    \/\/ request only fields that we need to display\n    query.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n        \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n        \"subject\", \"expression_of_concern\", \"retraction\");\n    query.addFacetField(\"subject_facet\");\n    query.addFacetField(\"author_facet\");\n    query.addFacetField(\"editor_facet\");\n    query.addFacetField(\"article_type_facet\");\n    query.addFacetField(\"affiliate_facet\");\n    query.set(\"facet.method\", \"fc\");\n    query.setFacetLimit(MAX_FACET_SIZE);\n    query.setFacetMinCount(MIN_FACET_COUNT);\n    \/\/ Add a filter to ensure that Solr never returns partial documents\n    query.addFilterQuery(createFilterFullDocuments());\n    return query;\n  }","code_wo_comment":"private SolrQuery createQuery(String queryString, int startPage, int pageSize, boolean useDismax) {\n    SolrQuery query = new SolrQuery(queryString);\n    query.setTimeAllowed(queryTimeout);\n    query.setIncludeScore(true);\n    query.setHighlight(false);\n    if (useDismax) {\n      query.set(\"defType\", \"dismax\");\n    }\n   \n   \n   \n    query.setStart(startPage * pageSize);\n    query.setRows(pageSize);\n   \n    query.setFields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\",\n        \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\",\n        \"subject\", \"expression_of_concern\", \"retraction\");\n    query.addFacetField(\"subject_facet\");\n    query.addFacetField(\"author_facet\");\n    query.addFacetField(\"editor_facet\");\n    query.addFacetField(\"article_type_facet\");\n    query.addFacetField(\"affiliate_facet\");\n    query.set(\"facet.method\", \"fc\");\n    query.setFacetLimit(MAX_FACET_SIZE);\n    query.setFacetMinCount(MIN_FACET_COUNT);\n   \n    query.addFilterQuery(createFilterFullDocuments());\n    return query;\n  }","cleancode":"private solrquery createquery(string querystring, int startpage, int pagesize, boolean usedismax) { solrquery query = new solrquery(querystring); query.settimeallowed(querytimeout); query.setincludescore(true); query.sethighlight(false); if (usedismax) { query.set(\"deftype\", \"dismax\"); } query.setstart(startpage * pagesize); query.setrows(pagesize); query.setfields(\"id\", \"score\", \"title_display\", \"publication_date\", \"eissn\", \"journal\", \"article_type\", \"author_display\", \"abstract\", \"abstract_primary_display\", \"striking_image\", \"figure_table_caption\", \"subject\", \"expression_of_concern\", \"retraction\"); query.addfacetfield(\"subject_facet\"); query.addfacetfield(\"author_facet\"); query.addfacetfield(\"editor_facet\"); query.addfacetfield(\"article_type_facet\"); query.addfacetfield(\"affiliate_facet\"); query.set(\"facet.method\", \"fc\"); query.setfacetlimit(max_facet_size); query.setfacetmincount(min_facet_count); query.addfilterquery(createfilterfulldocuments()); return query; }","repo":"AndrewGuthua\/JournalSystem","label":[1,0,0,0]}
{"id":13361,"original_code":"private String getTypeString(String _sTypeName, TypeClass _aTypeClass, boolean _bAsHeaderSourceCode){      \n        String sTypeString = \"\";\n        switch (_aTypeClass.getValue()){\n            case TypeClass.BOOLEAN_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbooleanTypeDescription();\n                break;\n            case TypeClass.BYTE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbyteTypeDescription();\n                break;\n            case TypeClass.CHAR_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getcharTypeDescription();                \n                break;\n            case TypeClass.DOUBLE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.FLOAT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getfloatTypeDescription();                \n                break;                \n            case TypeClass.HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.gethyperTypeDescription();                \n                break;                                \n            case TypeClass.LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getlongTypeDescription();                \n                break;                                \n            case TypeClass.SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getshortTypeDescription();                \n                break;                                \n            case TypeClass.STRING_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getstringTypeDescription(_bAsHeaderSourceCode);                \n                break;                                \n            case TypeClass.UNSIGNED_HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();                \n                break;                                \n            case TypeClass.UNSIGNED_LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();                \n                break;                \n            case TypeClass.UNSIGNED_SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.SEQUENCE_value:\n                \/\/TODO consider mulitdimensional Arrays\n                XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\n                if (xTypeDescription != null){\n                    sTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n                }\n                break;                \n            case TypeClass.ANY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\n                break;\n            case TypeClass.TYPE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);\n                break;\n            case TypeClass.ENUM_value:  \n            case TypeClass.STRUCT_value:\n            case TypeClass.INTERFACE_ATTRIBUTE_value:\n            case TypeClass.INTERFACE_METHOD_value:\n            case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(_sTypeName, _bAsHeaderSourceCode);\n                break;\n            default:                                                    \n        }\n        return sTypeString;\n    }","code_wo_comment":"private String getTypeString(String _sTypeName, TypeClass _aTypeClass, boolean _bAsHeaderSourceCode){      \n        String sTypeString = \"\";\n        switch (_aTypeClass.getValue()){\n            case TypeClass.BOOLEAN_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbooleanTypeDescription();\n                break;\n            case TypeClass.BYTE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getbyteTypeDescription();\n                break;\n            case TypeClass.CHAR_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getcharTypeDescription();                \n                break;\n            case TypeClass.DOUBLE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.FLOAT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getfloatTypeDescription();                \n                break;                \n            case TypeClass.HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.gethyperTypeDescription();                \n                break;                                \n            case TypeClass.LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getlongTypeDescription();                \n                break;                                \n            case TypeClass.SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getshortTypeDescription();                \n                break;                                \n            case TypeClass.STRING_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getstringTypeDescription(_bAsHeaderSourceCode);                \n                break;                                \n            case TypeClass.UNSIGNED_HYPER_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedhyperTypeDescription();                \n                break;                                \n            case TypeClass.UNSIGNED_LONG_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getunsignedlongTypeDescription();                \n                break;                \n            case TypeClass.UNSIGNED_SHORT_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getdoubleTypeDescription();                \n                break;                \n            case TypeClass.SEQUENCE_value:\n               \n                XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(_sTypeName);\n                if (xTypeDescription != null){\n                    sTypeString = getTypeString(xTypeDescription.getName(), xTypeDescription.getTypeClass(), _bAsHeaderSourceCode);\n                }\n                break;                \n            case TypeClass.ANY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getanyTypeDescription(_bAsHeaderSourceCode);\n                break;\n            case TypeClass.TYPE_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(\"com.sun.star.uno.Type\", _bAsHeaderSourceCode);\n                break;\n            case TypeClass.ENUM_value:  \n            case TypeClass.STRUCT_value:\n            case TypeClass.INTERFACE_ATTRIBUTE_value:\n            case TypeClass.INTERFACE_METHOD_value:\n            case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                sTypeString = m_xLanguageSourceCodeGenerator.getObjectTypeDescription(_sTypeName, _bAsHeaderSourceCode);\n                break;\n            default:                                                    \n        }\n        return sTypeString;\n    }","cleancode":"private string gettypestring(string _stypename, typeclass _atypeclass, boolean _basheadersourcecode){ string stypestring = \"\"; switch (_atypeclass.getvalue()){ case typeclass.boolean_value: stypestring = m_xlanguagesourcecodegenerator.getbooleantypedescription(); break; case typeclass.byte_value: stypestring = m_xlanguagesourcecodegenerator.getbytetypedescription(); break; case typeclass.char_value: stypestring = m_xlanguagesourcecodegenerator.getchartypedescription(); break; case typeclass.double_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.float_value: stypestring = m_xlanguagesourcecodegenerator.getfloattypedescription(); break; case typeclass.hyper_value: stypestring = m_xlanguagesourcecodegenerator.gethypertypedescription(); break; case typeclass.long_value: stypestring = m_xlanguagesourcecodegenerator.getlongtypedescription(); break; case typeclass.short_value: stypestring = m_xlanguagesourcecodegenerator.getshorttypedescription(); break; case typeclass.string_value: stypestring = m_xlanguagesourcecodegenerator.getstringtypedescription(_basheadersourcecode); break; case typeclass.unsigned_hyper_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedhypertypedescription(); break; case typeclass.unsigned_long_value: stypestring = m_xlanguagesourcecodegenerator.getunsignedlongtypedescription(); break; case typeclass.unsigned_short_value: stypestring = m_xlanguagesourcecodegenerator.getdoubletypedescription(); break; case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(_stypename); if (xtypedescription != null){ stypestring = gettypestring(xtypedescription.getname(), xtypedescription.gettypeclass(), _basheadersourcecode); } break; case typeclass.any_value: stypestring = m_xlanguagesourcecodegenerator.getanytypedescription(_basheadersourcecode); break; case typeclass.type_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(\"com.sun.star.uno.type\", _basheadersourcecode); break; case typeclass.enum_value: case typeclass.struct_value: case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: stypestring = m_xlanguagesourcecodegenerator.getobjecttypedescription(_stypename, _basheadersourcecode); break; default: } return stypestring; }","repo":"Grosskopf\/openoffice","label":[1,0,0,0]}
{"id":13362,"original_code":"private String getCentralVariableStemName(TypeClass _aTypeClass){\n            String sCentralVariableStemName = \"\";\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.SEQUENCE_value:\n                    \/\/TODO consider mulitdimensional Arrays\n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sCentralVariableStemName = SVARIABLENAME;\n                    break;\n                case TypeClass.STRUCT_value:\n                    sCentralVariableStemName = Introspector.getShortClassName(getTypeName());\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sCentralVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:            \n                    sCentralVariableStemName = SVARIABLENAME;\n            }                        \n            return sCentralVariableStemName;\n        }","code_wo_comment":"private String getCentralVariableStemName(TypeClass _aTypeClass){\n            String sCentralVariableStemName = \"\";\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.SEQUENCE_value:\n                   \n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sCentralVariableStemName = getCentralVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sCentralVariableStemName = SVARIABLENAME;\n                    break;\n                case TypeClass.STRUCT_value:\n                    sCentralVariableStemName = Introspector.getShortClassName(getTypeName());\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n            case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sCentralVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:            \n                    sCentralVariableStemName = SVARIABLENAME;\n            }                        \n            return sCentralVariableStemName;\n        }","cleancode":"private string getcentralvariablestemname(typeclass _atypeclass){ string scentralvariablestemname = \"\"; int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ scentralvariablestemname = getcentralvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: scentralvariablestemname = svariablename; break; case typeclass.struct_value: scentralvariablestemname = introspector.getshortclassname(gettypename()); break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); scentralvariablestemname = getvariablenameforunoobject(sshortclassname); default: scentralvariablestemname = svariablename; } return scentralvariablestemname; }","repo":"Grosskopf\/openoffice","label":[1,0,0,0]}
{"id":13363,"original_code":"public String getVariableStemName(TypeClass _aTypeClass){\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.BOOLEAN_value:\n                    sVariableStemName = \"b\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.DOUBLE_value:\n                case TypeClass.FLOAT_value:\n                    sVariableStemName = \"f\" + m_sCentralVariableStemName;\n                    break;                \n                case TypeClass.BYTE_value:\n                case TypeClass.HYPER_value:\n                case TypeClass.LONG_value:\n                case TypeClass.UNSIGNED_HYPER_value:\n                case TypeClass.UNSIGNED_LONG_value:\n                case TypeClass.UNSIGNED_SHORT_value:\n                case TypeClass.SHORT_value:\n                    sVariableStemName = \"n\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.CHAR_value:\n                case TypeClass.STRING_value:\n                    sVariableStemName = \"s\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.SEQUENCE_value:\n                    \/\/TODO consider mulitdimensional Arrays\n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.ANY_value:\n                    sVariableStemName = \"o\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.STRUCT_value:\n                case TypeClass.ENUM_value:  \n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n                case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:                                                    \n            }            \n            return sVariableStemName;\n        }","code_wo_comment":"public String getVariableStemName(TypeClass _aTypeClass){\n            int nTypeClass = _aTypeClass.getValue();\n            switch(nTypeClass){\n                case TypeClass.BOOLEAN_value:\n                    sVariableStemName = \"b\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.DOUBLE_value:\n                case TypeClass.FLOAT_value:\n                    sVariableStemName = \"f\" + m_sCentralVariableStemName;\n                    break;                \n                case TypeClass.BYTE_value:\n                case TypeClass.HYPER_value:\n                case TypeClass.LONG_value:\n                case TypeClass.UNSIGNED_HYPER_value:\n                case TypeClass.UNSIGNED_LONG_value:\n                case TypeClass.UNSIGNED_SHORT_value:\n                case TypeClass.SHORT_value:\n                    sVariableStemName = \"n\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.CHAR_value:\n                case TypeClass.STRING_value:\n                    sVariableStemName = \"s\" + m_sCentralVariableStemName;\n                    break;                                \n                case TypeClass.SEQUENCE_value:\n                   \n                    XTypeDescription xTypeDescription = Introspector.getIntrospector().getReferencedType(getTypeName());\n                    if (xTypeDescription != null){\n                        sVariableStemName = getVariableStemName(xTypeDescription.getTypeClass());\n                    }\n                    break;                \n                case TypeClass.TYPE_value:\n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.ANY_value:\n                    sVariableStemName = \"o\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.STRUCT_value:\n                case TypeClass.ENUM_value:  \n                    sVariableStemName = \"a\" + m_sCentralVariableStemName;\n                    break;\n                case TypeClass.INTERFACE_ATTRIBUTE_value:\n                case TypeClass.INTERFACE_METHOD_value:\n                case TypeClass.INTERFACE_value:\n                case TypeClass.PROPERTY_value:\n                    String sShortClassName = m_oIntrospector.getShortClassName(getTypeName());\n                    sVariableStemName = getVariableNameforUnoObject(sShortClassName);\n                default:                                                    \n            }            \n            return sVariableStemName;\n        }","cleancode":"public string getvariablestemname(typeclass _atypeclass){ int ntypeclass = _atypeclass.getvalue(); switch(ntypeclass){ case typeclass.boolean_value: svariablestemname = \"b\" + m_scentralvariablestemname; break; case typeclass.double_value: case typeclass.float_value: svariablestemname = \"f\" + m_scentralvariablestemname; break; case typeclass.byte_value: case typeclass.hyper_value: case typeclass.long_value: case typeclass.unsigned_hyper_value: case typeclass.unsigned_long_value: case typeclass.unsigned_short_value: case typeclass.short_value: svariablestemname = \"n\" + m_scentralvariablestemname; break; case typeclass.char_value: case typeclass.string_value: svariablestemname = \"s\" + m_scentralvariablestemname; break; case typeclass.sequence_value: xtypedescription xtypedescription = introspector.getintrospector().getreferencedtype(gettypename()); if (xtypedescription != null){ svariablestemname = getvariablestemname(xtypedescription.gettypeclass()); } break; case typeclass.type_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.any_value: svariablestemname = \"o\" + m_scentralvariablestemname; break; case typeclass.struct_value: case typeclass.enum_value: svariablestemname = \"a\" + m_scentralvariablestemname; break; case typeclass.interface_attribute_value: case typeclass.interface_method_value: case typeclass.interface_value: case typeclass.property_value: string sshortclassname = m_ointrospector.getshortclassname(gettypename()); svariablestemname = getvariablenameforunoobject(sshortclassname); default: } return svariablestemname; }","repo":"Grosskopf\/openoffice","label":[1,0,0,0]}
{"id":29971,"original_code":"public int getRuleStatusVec(int[] fillInArray) {\n        if (fillInArray != null && fillInArray.length>=1) {  \n            fillInArray[0] = 0;\n        }\n        return 1;\n    }","code_wo_comment":"public int getRuleStatusVec(int[] fillInArray) {\n        if (fillInArray != null && fillInArray.length>=1) {  \n            fillInArray[0] = 0;\n        }\n        return 1;\n    }","cleancode":"public int getrulestatusvec(int[] fillinarray) { if (fillinarray != null && fillinarray.length>=1) { fillinarray[0] = 0; } return 1; }","repo":"HughP\/quickdic-dictionary","label":[1,0,0,0]}
{"id":30000,"original_code":"public void go() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"verilog\\\\out.log\"));\n\t\tString line;\n\t\tPattern p = Pattern.compile(\".+JAG RD REF=. OB=1 BLT=. GPU=. \\\\$(......).*\");\n\t\tlong lineNo = 0;\n\t\tint Xmin[] = new int[3];\n\t\tint Xmax[] = new int[3];\n\t\tint Ymin[] = new int[3];\n\t\tint Ymax[] = new int[3];\n\t\tlong slino[] = new long[3];\n\t\tlong elino[] = new long[3];\n\t\tfor(int k = 0; k < 3; k++) {\n\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t}\n\t\twhile( (line = br.readLine()) != null) {\n\t\t\tlineNo++;\n\t\t\tif (lineNo >= 10L * 1000L * 1000L)\n\t\t\t\tbreak;\n\t\t\tMatcher m = p.matcher(line);\n\t\t\tif (m.matches()) {\n\t\t\t\t\/\/ System.out.println(line);\n\t\t\t\tint addr = Integer.parseInt(m.group(1), 16);\n\t\t\t\tint index = -1;\n\t\t\t\tboolean wtf = false;\n\t\t\t\tif (addr == 0xeb40) {\n\t\t\t\t\t\/\/ OLP\n\t\t\t\t\t\/\/ System.out.print(\".\");\n\t\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (slino[k] != 0) {\n\t\t\t\t\t\t\t\/\/wtf = (Ymin[k] != Ymax[k]);\n\t\t\t\t\t\t\tSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k], \n\t\t\t\t\t\t\t\t\t(wtf ? \"WTF\" : \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\t\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t\t\t\t\tslino[k] = 0;\n\t\t\t\t\t\telino[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\t\/*if (wtf)\n\t\t\t\t\tbreak;*\/\n\t\t\t\tif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t\taddr -= SCREEN1;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\taddr -= SCREEN2;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\n\t\t\t\t\tindex = 2;\n\t\t\t\t\taddr -= SCREEN3;\n\t\t\t\t}\n\t\t\t\tif (index < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\/\/ System.out.format(\"%06x %04x\\n\", addr, val);\n\t\t\t\tint y = (addr >> 1) \/ WIDTH;\n\t\t\t\tint x = (addr >> 1) % WIDTH;\n\t\t\t\t\/\/ System.out.format(\"%d (%d,%d)\\n\", index, x, y);\n\t\t\t\tif (slino[index] == 0)\n\t\t\t\t\tslino[index] = lineNo;\n\t\t\t\telino[index] = lineNo;\n\t\t\t\tif (Xmin[index] > x)\n\t\t\t\t\tXmin[index] = x;\n\t\t\t\tif (Xmax[index] < x)\n\t\t\t\t\tXmax[index] = x;\n\t\t\t\tif (Ymin[index] > y)\n\t\t\t\t\tYmin[index] = y;\n\t\t\t\tif (Ymax[index] < y)\n\t\t\t\t\tYmax[index] = y;\n\t\t\t}\n\t\t} \n\t\tbr.close();\n\t}","code_wo_comment":"public void go() throws Exception {\n\t\tBufferedReader br = new BufferedReader(new FileReader(\"verilog\\\\out.log\"));\n\t\tString line;\n\t\tPattern p = Pattern.compile(\".+JAG RD REF=. OB=1 BLT=. GPU=. \\\\$(......).*\");\n\t\tlong lineNo = 0;\n\t\tint Xmin[] = new int[3];\n\t\tint Xmax[] = new int[3];\n\t\tint Ymin[] = new int[3];\n\t\tint Ymax[] = new int[3];\n\t\tlong slino[] = new long[3];\n\t\tlong elino[] = new long[3];\n\t\tfor(int k = 0; k < 3; k++) {\n\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t}\n\t\twhile( (line = br.readLine()) != null) {\n\t\t\tlineNo++;\n\t\t\tif (lineNo >= 10L * 1000L * 1000L)\n\t\t\t\tbreak;\n\t\t\tMatcher m = p.matcher(line);\n\t\t\tif (m.matches()) {\n\t\t\t\n\t\t\t\tint addr = Integer.parseInt(m.group(1), 16);\n\t\t\t\tint index = -1;\n\t\t\t\tboolean wtf = false;\n\t\t\t\tif (addr == 0xeb40) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tfor(int k = 0; k < 3; k++) {\n\t\t\t\t\t\tif (slino[k] != 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tSystem.out.format(\"%-9d %-9d S%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), Xmin[k], Ymin[k], Xmax[k], Ymax[k], \n\t\t\t\t\t\t\t\t\t(wtf ? \"WTF\" : \"\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tXmin[k] = Ymin[k] = Integer.MAX_VALUE;\n\t\t\t\t\t\tXmax[k] = Ymax[k] = Integer.MIN_VALUE;\n\t\t\t\t\t\tslino[k] = 0;\n\t\t\t\t\t\telino[k] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (addr >= SCREEN1 && addr < SCREEN1 + SCREENSIZE) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t\taddr -= SCREEN1;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN2 && addr < SCREEN2 + SCREENSIZE) {\n\t\t\t\t\tindex = 1;\n\t\t\t\t\taddr -= SCREEN2;\n\t\t\t\t}\n\t\t\t\telse if (addr >= SCREEN3 && addr < SCREEN3 + SCREENSIZE) {\n\t\t\t\t\tindex = 2;\n\t\t\t\t\taddr -= SCREEN3;\n\t\t\t\t}\n\t\t\t\tif (index < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\n\t\t\t\tint y = (addr >> 1) \/ WIDTH;\n\t\t\t\tint x = (addr >> 1) % WIDTH;\n\t\t\t\n\t\t\t\tif (slino[index] == 0)\n\t\t\t\t\tslino[index] = lineNo;\n\t\t\t\telino[index] = lineNo;\n\t\t\t\tif (Xmin[index] > x)\n\t\t\t\t\tXmin[index] = x;\n\t\t\t\tif (Xmax[index] < x)\n\t\t\t\t\tXmax[index] = x;\n\t\t\t\tif (Ymin[index] > y)\n\t\t\t\t\tYmin[index] = y;\n\t\t\t\tif (Ymax[index] < y)\n\t\t\t\t\tYmax[index] = y;\n\t\t\t}\n\t\t} \n\t\tbr.close();\n\t}","cleancode":"public void go() throws exception { bufferedreader br = new bufferedreader(new filereader(\"verilog\\\\out.log\")); string line; pattern p = pattern.compile(\".+jag rd ref=. ob=1 blt=. gpu=. \\\\$(......).*\"); long lineno = 0; int xmin[] = new int[3]; int xmax[] = new int[3]; int ymin[] = new int[3]; int ymax[] = new int[3]; long slino[] = new long[3]; long elino[] = new long[3]; for(int k = 0; k < 3; k++) { xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; } while( (line = br.readline()) != null) { lineno++; if (lineno >= 10l * 1000l * 1000l) break; matcher m = p.matcher(line); if (m.matches()) { int addr = integer.parseint(m.group(1), 16); int index = -1; boolean wtf = false; if (addr == 0xeb40) { for(int k = 0; k < 3; k++) { if (slino[k] != 0) { system.out.format(\"%-9d %-9d s%d (%d,%d) -> (%d,%d) %s \", slino[k], elino[k], (k+1), xmin[k], ymin[k], xmax[k], ymax[k], (wtf ? \"wtf\" : \"\")); } xmin[k] = ymin[k] = integer.max_value; xmax[k] = ymax[k] = integer.min_value; slino[k] = 0; elino[k] = 0; } system.out.println(); } if (addr >= screen1 && addr < screen1 + screensize) { index = 0; addr -= screen1; } else if (addr >= screen2 && addr < screen2 + screensize) { index = 1; addr -= screen2; } else if (addr >= screen3 && addr < screen3 + screensize) { index = 2; addr -= screen3; } if (index < 0) continue; int y = (addr >> 1) \/ width; int x = (addr >> 1) % width; if (slino[index] == 0) slino[index] = lineno; elino[index] = lineno; if (xmin[index] > x) xmin[index] = x; if (xmax[index] < x) xmax[index] = x; if (ymin[index] > y) ymin[index] = y; if (ymax[index] < y) ymax[index] = y; } } br.close(); }","repo":"ElectronAsh\/jag_sim","label":[0,0,0,0]}
{"id":21824,"original_code":"private void downloadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return;\n        }\n        int mediaId = fileInfo.getId();\n        getDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n                \/\/ @todo: replace with StringBuilder\n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        \/\/ result contains the local file URI if successful\n                        mediaFileDao.setLocalUri(mediaId, result.unwrap());\n                    });\n                } else {\n                    logger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","code_wo_comment":"private void downloadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return;\n        }\n        int mediaId = fileInfo.getId();\n        getDelegate(fileInfo.getType()).onDownloadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n               \n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"downloading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                       \n                        mediaFileDao.setLocalUri(mediaId, result.unwrap());\n                    });\n                } else {\n                    logger.warn(\"downloading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"downloading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","cleancode":"private void downloadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return; } int mediaid = fileinfo.getid(); getdelegate(fileinfo.gettype()).ondownloadmedia(fileinfo) .thenacceptasync((result) -> { if (result != null && result.issuccessful()) { logger.info(\"downloading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.setlocaluri(mediaid, result.unwrap()); }); } else { logger.warn(\"downloading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"downloading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","repo":"COMP30022-Russia\/Russia_Client","label":[1,0,0,0]}
{"id":21825,"original_code":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return CompletableFuture.completedFuture(null);\n        }\n        int mediaId = fileInfo.getId();\n        return getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n                \/\/ @todo: replace with StringBuilder\n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        mediaFileDao.insertOrUpdate(fileInfo);\n                        mediaFileDao.setRemoteAvailable(mediaId);\n                    });\n                } else {\n                    logger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"uploading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","code_wo_comment":"private CompletableFuture<Void> uploadMedia(MediaFileInfo fileInfo) {\n        if (fileInfo == null) {\n            return CompletableFuture.completedFuture(null);\n        }\n        int mediaId = fileInfo.getId();\n        return getDelegate(fileInfo.getType()).onUploadMedia(fileInfo)\n            .thenAcceptAsync((result) -> {\n               \n                if (result != null && result.isSuccessful()) {\n                    logger.info(\"uploading of media id=\" + mediaId + \" succeeded.\");\n                    AsyncTask.execute(() -> {\n                        mediaFileDao.insertOrUpdate(fileInfo);\n                        mediaFileDao.setRemoteAvailable(mediaId);\n                    });\n                } else {\n                    logger.warn(\"uploading of media id=\" + mediaId + \" failed.\");\n                    if (result.getErrorType() == ActionResult.NETWORK_ERROR) {\n                        logger.warn(\"due to network error.\");\n                    } else {\n                        logger.warn(\"due to unknown error.\");\n                    }\n                }\n            }).exceptionally((e) -> {\n                logger.error(\"uploading of media id=\" + mediaId + \" failed spectacularly:\");\n                e.printStackTrace();\n                return null;\n            });\n    }","cleancode":"private completablefuture<void> uploadmedia(mediafileinfo fileinfo) { if (fileinfo == null) { return completablefuture.completedfuture(null); } int mediaid = fileinfo.getid(); return getdelegate(fileinfo.gettype()).onuploadmedia(fileinfo) .thenacceptasync((result) -> { if (result != null && result.issuccessful()) { logger.info(\"uploading of media id=\" + mediaid + \" succeeded.\"); asynctask.execute(() -> { mediafiledao.insertorupdate(fileinfo); mediafiledao.setremoteavailable(mediaid); }); } else { logger.warn(\"uploading of media id=\" + mediaid + \" failed.\"); if (result.geterrortype() == actionresult.network_error) { logger.warn(\"due to network error.\"); } else { logger.warn(\"due to unknown error.\"); } } }).exceptionally((e) -> { logger.error(\"uploading of media id=\" + mediaid + \" failed spectacularly:\"); e.printstacktrace(); return null; }); }","repo":"COMP30022-Russia\/Russia_Client","label":[1,0,0,0]}
{"id":13695,"original_code":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n    \/\/ Create config for trajectory\n    \/*TrajectoryConfig config =\n      new TrajectoryConfig(Constants.maxMecSpeed,Constants.maxMecAcceleration)\n        \/\/ Add kinematics to ensure max speed is actually obeyed\n        .setKinematics(mecDriveTrain.getMecKinetimatics());\n    \/\/ An example trajectory to follow.  All units in meters.\n    Trajectory exampleTrajectory =\n      TrajectoryGenerator.generateTrajectory(\n        \/\/ Start at the origin facing the +X direction\n        new Pose2d(0, 0, new Rotation2d(0)),\n        \/\/ Pass through these two interior waypoints, making an 's' curve path\n        List.of(new Translation2d(1, 1), new Translation2d(2, -1)),\n        \/\/ End 3 meters straight ahead of where we started, facing forward\n        new Pose2d(3, 0, new Rotation2d(0)),\n        config);*\/\n    ProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0., \n      new Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\n    thetaController.enableContinuousInput(-Math.PI, Math.PI);\n    thetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n    \/\/mecDriveTrain.setPose(ppTrajectory.getInitialPose());\n    PPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\n      ppTrajectory,\n      RobotState::getPoseEstimate,\n      \/\/TODO go to WPILIB source code for mecControlCommand and see how they use this feedforward\n      \/\/and then use that in the mecDriveTrain.setSpeeds() method\n      \/\/mecDriveTrain.getMecFeedforward(),\n      RobotState.getMecKinematics(),\n      \/\/ Position contollers\n      new PIDController(Constants.kpMecPosXController, 0, 0),\n      new PIDController(Constants.kpMecPosYController, 0, 0),\n      thetaController,\n      \/\/ Needed for normalizing wheel speeds\n      \/\/Constants.maxMecSpeed,\n      \/\/ Velocity PID's\n      \/*new PIDController(Constants.kpMecL1Velocity, 0, 0),\n      new PIDController(Constants.kpMecL2Velocity, 0, 0),\n      new PIDController(Constants.kpMecR1Velocity, 0, 0),\n      new PIDController(Constants.kpMecR2Velocity, 0, 0),*\/\n      \/\/mecDriveTrain::getCurrentWheelSpeeds,\n      mecDriveTrain::setSpeeds, \/\/ Consumer for the output motor voltages\n      mecDriveTrain\n    );\n    \/\/PathPlannerState initialState = ppTrajectory.getInitialState();\n    \/*return new InstantCommand(() -> \n      mecDriveTrain.setPose(new Pose2d(initialState.poseMeters.getTranslation(), initialState.holonomicRotation)))\n      .andThen(mecanumControllerCommand);\n      \/\/.andThen(mecDriveTrain::stopDrive);*\/\n    return mecanumControllerCommand;\n  }","code_wo_comment":"public static Command getMecControllerCommand(PathPlannerTrajectory ppTrajectory, MecDriveTrain mecDriveTrain) {\n   \n   \n    ProfiledPIDController thetaController = new ProfiledPIDController(Constants.kpMecThetaController, 0., 0., \n      new Constraints(Constants.maxMecRotationVelocity, Constants.maxMecRotationAccel));\n    thetaController.enableContinuousInput(-Math.PI, Math.PI);\n    thetaController.reset(RobotState.getPoseEstimate().getRotation().getRadians());\n   \n    PPMecanumControllerCommand mecanumControllerCommand = new PPMecanumControllerCommand(\n      ppTrajectory,\n      RobotState::getPoseEstimate,\n     \n     \n     \n      RobotState.getMecKinematics(),\n     \n      new PIDController(Constants.kpMecPosXController, 0, 0),\n      new PIDController(Constants.kpMecPosYController, 0, 0),\n      thetaController,\n     \n     \n     \n     \n     \n      mecDriveTrain::setSpeeds,\n      mecDriveTrain\n    );\n   \n   \n    return mecanumControllerCommand;\n  }","cleancode":"public static command getmeccontrollercommand(pathplannertrajectory pptrajectory, mecdrivetrain mecdrivetrain) { profiledpidcontroller thetacontroller = new profiledpidcontroller(constants.kpmecthetacontroller, 0., 0., new constraints(constants.maxmecrotationvelocity, constants.maxmecrotationaccel)); thetacontroller.enablecontinuousinput(-math.pi, math.pi); thetacontroller.reset(robotstate.getposeestimate().getrotation().getradians()); ppmecanumcontrollercommand mecanumcontrollercommand = new ppmecanumcontrollercommand( pptrajectory, robotstate::getposeestimate, robotstate.getmeckinematics(), new pidcontroller(constants.kpmecposxcontroller, 0, 0), new pidcontroller(constants.kpmecposycontroller, 0, 0), thetacontroller, mecdrivetrain::setspeeds, mecdrivetrain ); return mecanumcontrollercommand; }","repo":"FRC6302\/2022Bot1","label":[1,0,0,0]}
{"id":14329,"original_code":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\n        File allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\n        if (allianceFile.exists()) {\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(allianceFile));\n                String line;\n                alliances = new Alliance[4];\n                while ((line = reader.readLine()) != null) {\n                    \/* Alliance info *\/\n                    String[] allianceInfo = line.split(\"\\\\|\");\n                    int division = Integer.parseInt(allianceInfo[0]);\n                    int allianceNumber = Integer.parseInt(allianceInfo[1]);\n                    int[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\n                    alliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n                }\n                reader.close();\n                \/* TODO - Make Upload Alliances so we can uncomment this\n                controller.btnUploadAlliances.setDisable(false);*\/\n                updateAllianceLabels(scores);\n                TOALogger.log(Level.INFO, \"Alliance import successful.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                controller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n            }\n        } else {\n            controller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n        }\n    }","code_wo_comment":"public void importAlliancesScoring(HashMap<MatchGeneral, MatchDetailRelicJSON> scores){\n        File allianceFile = new File(Config.SCORING_DIR + File.separator + \"alliances.txt\");\n        if (allianceFile.exists()) {\n            try {\n                BufferedReader reader = new BufferedReader(new FileReader(allianceFile));\n                String line;\n                alliances = new Alliance[4];\n                while ((line = reader.readLine()) != null) {\n                   \n                    String[] allianceInfo = line.split(\"\\\\|\");\n                    int division = Integer.parseInt(allianceInfo[0]);\n                    int allianceNumber = Integer.parseInt(allianceInfo[1]);\n                    int[] allianceNumbers = {Integer.parseInt(allianceInfo[3]), Integer.parseInt(allianceInfo[4]), Integer.parseInt(allianceInfo[5])};\n                    alliances[allianceNumber-1] = new Alliance(division, allianceNumber, allianceNumbers);\n                }\n                reader.close();\n               \n                updateAllianceLabels(scores);\n                TOALogger.log(Level.INFO, \"Alliance import successful.\");\n            } catch (Exception e) {\n                e.printStackTrace();\n                controller.sendError(\"Could not open file. \" + e.getLocalizedMessage());\n            }\n        } else {\n            controller.sendError(\"Could not locate alliances.txt from the Scoring System. Did you generate an elimination bracket?\");\n        }\n    }","cleancode":"public void importalliancesscoring(hashmap<matchgeneral, matchdetailrelicjson> scores){ file alliancefile = new file(config.scoring_dir + file.separator + \"alliances.txt\"); if (alliancefile.exists()) { try { bufferedreader reader = new bufferedreader(new filereader(alliancefile)); string line; alliances = new alliance[4]; while ((line = reader.readline()) != null) { string[] allianceinfo = line.split(\"\\\\|\"); int division = integer.parseint(allianceinfo[0]); int alliancenumber = integer.parseint(allianceinfo[1]); int[] alliancenumbers = {integer.parseint(allianceinfo[3]), integer.parseint(allianceinfo[4]), integer.parseint(allianceinfo[5])}; alliances[alliancenumber-1] = new alliance(division, alliancenumber, alliancenumbers); } reader.close(); updatealliancelabels(scores); toalogger.log(level.info, \"alliance import successful.\"); } catch (exception e) { e.printstacktrace(); controller.senderror(\"could not open file. \" + e.getlocalizedmessage()); } } else { controller.senderror(\"could not locate alliances.txt from the scoring system. did you generate an elimination bracket?\"); } }","repo":"Agardner329\/TOA-DataSync","label":[0,1,0,0]}
{"id":14380,"original_code":"public void testEmit() throws Exception {\n        eh.on(\"ok\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"ok\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.on(\"no\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"no\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.emit(\"ok\");\n        eh.emit(\"ok\", \"ok\");\n        eh.emit(\"ok\", \"no\");\n        eh.emit(\"no\");\n        eh.emit(\"no\", \"no\");\n        eh.emit(\"no\", \"ok\");\n        eh.emit(\"unknown\");\n        eh.emit(\"unknown\", \"ok\");\n        eh.emit(\"unknown\", \"no\");\n        fail(); \/\/ FIXME these tests are not correct\n    }","code_wo_comment":"public void testEmit() throws Exception {\n        eh.on(\"ok\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"ok\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.on(\"no\", new EventEmitter.Listener() {\n            @Override\n            public void onEvent(Object data) {\n                String ss = (String) data;\n                if (ss == \"no\")\n                    Log.d(TAG, \"pass@\" + ss);\n                else\n                    Log.d(TAG, \"fail@\" + ss);\n            }\n        });\n        eh.emit(\"ok\");\n        eh.emit(\"ok\", \"ok\");\n        eh.emit(\"ok\", \"no\");\n        eh.emit(\"no\");\n        eh.emit(\"no\", \"no\");\n        eh.emit(\"no\", \"ok\");\n        eh.emit(\"unknown\");\n        eh.emit(\"unknown\", \"ok\");\n        eh.emit(\"unknown\", \"no\");\n        fail();\n    }","cleancode":"public void testemit() throws exception { eh.on(\"ok\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"ok\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.on(\"no\", new eventemitter.listener() { @override public void onevent(object data) { string ss = (string) data; if (ss == \"no\") log.d(tag, \"pass@\" + ss); else log.d(tag, \"fail@\" + ss); } }); eh.emit(\"ok\"); eh.emit(\"ok\", \"ok\"); eh.emit(\"ok\", \"no\"); eh.emit(\"no\"); eh.emit(\"no\", \"no\"); eh.emit(\"no\", \"ok\"); eh.emit(\"unknown\"); eh.emit(\"unknown\", \"ok\"); eh.emit(\"unknown\", \"no\"); fail(); }","repo":"InstantWebP2P\/node-android","label":[0,0,0,1]}
{"id":14566,"original_code":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\n        if (tree instanceof MethodTree) {\n            var method = (MethodTree) tree;\n            var parameters = new StringJoiner(\", \");\n            for (var p : method.getParameters()) {\n                parameters.add(p.getType() + \" \" + p.getName());\n            }\n            item.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\n            if (!method.getThrows().isEmpty()) {\n                var exceptions = new StringJoiner(\", \");\n                for (var e : method.getThrows()) {\n                    exceptions.add(e.toString());\n                }\n                item.detail += \" throws \" + exceptions;\n            }\n            if (data.plusOverloads != 0) {\n                item.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n            }\n        }\n    }","code_wo_comment":"private void resolveDetail(CompletionItem item, CompletionData data, Tree tree) {\n        if (tree instanceof MethodTree) {\n            var method = (MethodTree) tree;\n            var parameters = new StringJoiner(\", \");\n            for (var p : method.getParameters()) {\n                parameters.add(p.getType() + \" \" + p.getName());\n            }\n            item.detail = method.getReturnType() + \" \" + method.getName() + \"(\" + parameters + \")\";\n            if (!method.getThrows().isEmpty()) {\n                var exceptions = new StringJoiner(\", \");\n                for (var e : method.getThrows()) {\n                    exceptions.add(e.toString());\n                }\n                item.detail += \" throws \" + exceptions;\n            }\n            if (data.plusOverloads != 0) {\n                item.detail += \" (+\" + data.plusOverloads + \" overloads)\";\n            }\n        }\n    }","cleancode":"private void resolvedetail(completionitem item, completiondata data, tree tree) { if (tree instanceof methodtree) { var method = (methodtree) tree; var parameters = new stringjoiner(\", \"); for (var p : method.getparameters()) { parameters.add(p.gettype() + \" \" + p.getname()); } item.detail = method.getreturntype() + \" \" + method.getname() + \"(\" + parameters + \")\"; if (!method.getthrows().isempty()) { var exceptions = new stringjoiner(\", \"); for (var e : method.getthrows()) { exceptions.add(e.tostring()); } item.detail += \" throws \" + exceptions; } if (data.plusoverloads != 0) { item.detail += \" (+\" + data.plusoverloads + \" overloads)\"; } } }","repo":"80952556400\/java-language-server","label":[1,0,0,0]}
{"id":30960,"original_code":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\n\t\tHashMap<String, String> initialValues = new HashMap<String, String>();\n\t\tinitialValues.put(\"eventDate\", eventDate);\n\t\tinitialValues.put(\"scientificName\", scientificName);\n\t\tinitialValues.put(\"reproductive\", reproductiveState);\n\t\tinitialValues.put(\"country\", country);\n\t\tinitialValues.put(\"kingdom\", kingdom);\n\t\tinitialValues.put(\"latitude\", latitude);\n\t\tinitialValues.put(\"longitude\", longitude);\n\t\tinitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\t\t\/\/ TODO: fix to compare provided eventDate and reproductiveState with data from FNA\n\t    Vector<String> months = new Vector<String>();\n\t\tVector<String> foundFloweringTime = null;\n\t\tif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\n\t\t\tfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase()); \n\t\t}\n\t\tif(foundFloweringTime == null){\n\t\t\tsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\n\t\t\taddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\n\t\t\tcorrectedFloweringTime = null;\n\t\t}else{\n\t\t\tif(months==null || !months.containsAll(foundFloweringTime) || !foundFloweringTime.containsAll(months) ){\n\t\t\t\tsetCurationStatus(CurationComment.UNABLE_CURATED);\n\t\t\t\taddToComment(\"Provided event date and flowering state is inconsistent with known flowering times for species according to FNA.\");\n\t\t\t}else{\n\t\t\t\tsetCurationStatus(CurationComment.CORRECT);\n\t\t\t\taddToComment(\"The event date and flowering state is consistent with authoritative data from FNA\");\n\t\t\t\tcorrectedFloweringTime = months; \t\t\t\t\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"public void validateFloweringTime(String scientificName, String eventDate, String reproductiveState, String country, String kingdom, String latitude, String longitude) {\n\t\tHashMap<String, String> initialValues = new HashMap<String, String>();\n\t\tinitialValues.put(\"eventDate\", eventDate);\n\t\tinitialValues.put(\"scientificName\", scientificName);\n\t\tinitialValues.put(\"reproductive\", reproductiveState);\n\t\tinitialValues.put(\"country\", country);\n\t\tinitialValues.put(\"kingdom\", kingdom);\n\t\tinitialValues.put(\"latitude\", latitude);\n\t\tinitialValues.put(\"longitude\", longitude);\n\t\tinitDate(new CurationStep(\"Validate Collecting Event Date: check dwc:eventDate against reproductive state. \", initialValues));\n\t\n\t    Vector<String> months = new Vector<String>();\n\t\tVector<String> foundFloweringTime = null;\n\t\tif(authoritativeFloweringTimeMap != null && authoritativeFloweringTimeMap.containsKey(scientificName.toLowerCase())){\n\t\t\tfoundFloweringTime = authoritativeFloweringTimeMap.get(scientificName.toLowerCase()); \n\t\t}\n\t\tif(foundFloweringTime == null){\n\t\t\tsetCurationStatus(CurationComment.UNABLE_DETERMINE_VALIDITY);\n\t\t\taddToComment(\"Can't find the flowering time of the \"+scientificName+\" in the current available phenology data from FNA.\");\n\t\t\tcorrectedFloweringTime = null;\n\t\t}else{\n\t\t\tif(months==null || !months.containsAll(foundFloweringTime) || !foundFloweringTime.containsAll(months) ){\n\t\t\t\tsetCurationStatus(CurationComment.UNABLE_CURATED);\n\t\t\t\taddToComment(\"Provided event date and flowering state is inconsistent with known flowering times for species according to FNA.\");\n\t\t\t}else{\n\t\t\t\tsetCurationStatus(CurationComment.CORRECT);\n\t\t\t\taddToComment(\"The event date and flowering state is consistent with authoritative data from FNA\");\n\t\t\t\tcorrectedFloweringTime = months; \t\t\t\t\n\t\t\t}\n\t\t}\n\t}","cleancode":"public void validatefloweringtime(string scientificname, string eventdate, string reproductivestate, string country, string kingdom, string latitude, string longitude) { hashmap<string, string> initialvalues = new hashmap<string, string>(); initialvalues.put(\"eventdate\", eventdate); initialvalues.put(\"scientificname\", scientificname); initialvalues.put(\"reproductive\", reproductivestate); initialvalues.put(\"country\", country); initialvalues.put(\"kingdom\", kingdom); initialvalues.put(\"latitude\", latitude); initialvalues.put(\"longitude\", longitude); initdate(new curationstep(\"validate collecting event date: check dwc:eventdate against reproductive state. \", initialvalues)); vector<string> months = new vector<string>(); vector<string> foundfloweringtime = null; if(authoritativefloweringtimemap != null && authoritativefloweringtimemap.containskey(scientificname.tolowercase())){ foundfloweringtime = authoritativefloweringtimemap.get(scientificname.tolowercase()); } if(foundfloweringtime == null){ setcurationstatus(curationcomment.unable_determine_validity); addtocomment(\"can't find the flowering time of the \"+scientificname+\" in the current available phenology data from fna.\"); correctedfloweringtime = null; }else{ if(months==null || !months.containsall(foundfloweringtime) || !foundfloweringtime.containsall(months) ){ setcurationstatus(curationcomment.unable_curated); addtocomment(\"provided event date and flowering state is inconsistent with known flowering times for species according to fna.\"); }else{ setcurationstatus(curationcomment.correct); addtocomment(\"the event date and flowering state is consistent with authoritative data from fna\"); correctedfloweringtime = months; } } }","repo":"FilteredPush\/FP-KurationServices","label":[1,0,0,0]}
{"id":22911,"original_code":"private void pickRawContactDelta() {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n        }\n        for (int j = 0; j < mRawContactDeltas.size(); j++) {\n            final RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n            }\n            if (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\n            final AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\n            if (accountType == null) continue;\n            if (mRawContactIdToDisplayAlone > 0) {\n                \/\/ Look for the raw contact if specified.\n                if (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\n                    mCurrentRawContactDelta = rawContactDelta;\n                    return;\n                }\n            } else if (mPrimaryAccount != null\n                    && mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n                \/\/ Otherwise try to find the one that matches the default.\n                mCurrentRawContactDelta = rawContactDelta;\n                return;\n            } else if (accountType.areContactsWritable()){\n                \/\/ TODO: Find better raw contact delta\n                \/\/ Just select an arbitrary writable contact.\n                mCurrentRawContactDelta = rawContactDelta;\n            }\n        }\n    }","code_wo_comment":"private void pickRawContactDelta() {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"parse: \" + mRawContactDeltas.size() + \" rawContactDelta(s)\");\n        }\n        for (int j = 0; j < mRawContactDeltas.size(); j++) {\n            final RawContactDelta rawContactDelta = mRawContactDeltas.get(j);\n            if (Log.isLoggable(TAG, Log.VERBOSE)) {\n                Log.v(TAG, \"parse: \" + j + \" rawContactDelta\" + rawContactDelta);\n            }\n            if (rawContactDelta == null || !rawContactDelta.isVisible()) continue;\n            final AccountType accountType = rawContactDelta.getAccountType(mAccountTypeManager);\n            if (accountType == null) continue;\n            if (mRawContactIdToDisplayAlone > 0) {\n               \n                if (rawContactDelta.getRawContactId().equals(mRawContactIdToDisplayAlone)) {\n                    mCurrentRawContactDelta = rawContactDelta;\n                    return;\n                }\n            } else if (mPrimaryAccount != null\n                    && mPrimaryAccount.equals(rawContactDelta.getAccountWithDataSet())) {\n               \n                mCurrentRawContactDelta = rawContactDelta;\n                return;\n            } else if (accountType.areContactsWritable()){\n               \n               \n                mCurrentRawContactDelta = rawContactDelta;\n            }\n        }\n    }","cleancode":"private void pickrawcontactdelta() { if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + mrawcontactdeltas.size() + \" rawcontactdelta(s)\"); } for (int j = 0; j < mrawcontactdeltas.size(); j++) { final rawcontactdelta rawcontactdelta = mrawcontactdeltas.get(j); if (log.isloggable(tag, log.verbose)) { log.v(tag, \"parse: \" + j + \" rawcontactdelta\" + rawcontactdelta); } if (rawcontactdelta == null || !rawcontactdelta.isvisible()) continue; final accounttype accounttype = rawcontactdelta.getaccounttype(maccounttypemanager); if (accounttype == null) continue; if (mrawcontactidtodisplayalone > 0) { if (rawcontactdelta.getrawcontactid().equals(mrawcontactidtodisplayalone)) { mcurrentrawcontactdelta = rawcontactdelta; return; } } else if (mprimaryaccount != null && mprimaryaccount.equals(rawcontactdelta.getaccountwithdataset())) { mcurrentrawcontactdelta = rawcontactdelta; return; } else if (accounttype.arecontactswritable()){ mcurrentrawcontactdelta = rawcontactdelta; } } }","repo":"BrahmaOS\/brahmaos-packages-apps-Contacts","label":[1,0,0,0]}
{"id":22966,"original_code":"@Override\n        public void interruptionOccurred(int currentIteration, int numIterations) {\n            \/\/ FIXME: maybe skip writing the SOM at 0 iterations (0 mod x == 0 ...)\n            String filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\n            try {\n                SOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\n                        true, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n            } catch (IOException e) {\n                Logger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n                        \"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n            }\n        }","code_wo_comment":"@Override\n        public void interruptionOccurred(int currentIteration, int numIterations) {\n           \n            String filename = fileProperties.namePrefix(false) + \"_\" + currentIteration;\n            try {\n                SOMLibMapOutputter.writeWeightVectorFile(GrowingSOM.this, fileProperties.outputDirectory(), filename,\n                        true, \"$CURRENT_ITERATION=\" + currentIteration, \"$NUM_ITERATIONS=\" + numIterations);\n            } catch (IOException e) {\n                Logger.getLogger(\"at.tuwien.ifs.somtoolbox\").severe(\n                        \"Could not open or write to output file \" + filename + \": \" + e.getMessage());\n            }\n        }","cleancode":"@override public void interruptionoccurred(int currentiteration, int numiterations) { string filename = fileproperties.nameprefix(false) + \"_\" + currentiteration; try { somlibmapoutputter.writeweightvectorfile(growingsom.this, fileproperties.outputdirectory(), filename, true, \"$current_iteration=\" + currentiteration, \"$num_iterations=\" + numiterations); } catch (ioexception e) { logger.getlogger(\"at.tuwien.ifs.somtoolbox\").severe( \"could not open or write to output file \" + filename + \": \" + e.getmessage()); } }","repo":"ChrisPrein\/TUW_SelfOrganizingSystems_WS2021","label":[0,0,1,0]}
{"id":23001,"original_code":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\t\t\/\/TODO: maybe skip some of this stuff if the cube is empty? (would need to use hints)\n\t\tint radius = this.range;\n\t\tthis.world = world;\n\t\tthis.rand.setSeed(world.getSeed());\n\t\t\/\/used to randomize contribution of each coordinate to the cube seed\n\t\t\/\/without these swapping x\/y\/z coordinates would result in the same seed\n\t\t\/\/so structures would generate symmetrically\n\t\tlong randX = this.rand.nextLong();\n\t\tlong randY = this.rand.nextLong();\n\t\tlong randZ = this.rand.nextLong();\n\t\tint cubeX = cubePos.getX();\n\t\tint cubeY = cubePos.getY();\n\t\tint cubeZ = cubePos.getZ();\n\t\t\/\/x\/y\/zOrigin is location of the structure \"center\", and cubeX\/Y\/Z is the currently generated cube\n\t\tfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\n\t\t\tfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\n\t\t\t\tfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\n\t\t\t\t\tlong randX_mul = xOrigin*randX;\n\t\t\t\t\tlong randY_mul = yOrigin*randY;\n\t\t\t\t\tlong randZ_mul = zOrigin*randZ;\n\t\t\t\t\tthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\n\t\t\t\t\tthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"public void generate(ICubicWorld world, ICubePrimer cube, CubePos cubePos) {\n\t\n\t\tint radius = this.range;\n\t\tthis.world = world;\n\t\tthis.rand.setSeed(world.getSeed());\n\t\n\t\n\t\n\t\tlong randX = this.rand.nextLong();\n\t\tlong randY = this.rand.nextLong();\n\t\tlong randZ = this.rand.nextLong();\n\t\tint cubeX = cubePos.getX();\n\t\tint cubeY = cubePos.getY();\n\t\tint cubeZ = cubePos.getZ();\n\t\n\t\tfor (int xOrigin = cubeX - radius; xOrigin <= cubeX + radius; ++xOrigin) {\n\t\t\tfor (int yOrigin = cubeY - radius; yOrigin <= cubeY + radius; ++yOrigin) {\n\t\t\t\tfor (int zOrigin = cubeZ - radius; zOrigin <= cubeZ + radius; ++zOrigin) {\n\t\t\t\t\tlong randX_mul = xOrigin*randX;\n\t\t\t\t\tlong randY_mul = yOrigin*randY;\n\t\t\t\t\tlong randZ_mul = zOrigin*randZ;\n\t\t\t\t\tthis.rand.setSeed(randX_mul ^ randY_mul ^ randZ_mul ^ world.getSeed());\n\t\t\t\t\tthis.generate(world, cube, xOrigin, yOrigin, zOrigin, cubePos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","cleancode":"public void generate(icubicworld world, icubeprimer cube, cubepos cubepos) { int radius = this.range; this.world = world; this.rand.setseed(world.getseed()); long randx = this.rand.nextlong(); long randy = this.rand.nextlong(); long randz = this.rand.nextlong(); int cubex = cubepos.getx(); int cubey = cubepos.gety(); int cubez = cubepos.getz(); for (int xorigin = cubex - radius; xorigin <= cubex + radius; ++xorigin) { for (int yorigin = cubey - radius; yorigin <= cubey + radius; ++yorigin) { for (int zorigin = cubez - radius; zorigin <= cubez + radius; ++zorigin) { long randx_mul = xorigin*randx; long randy_mul = yorigin*randy; long randz_mul = zorigin*randz; this.rand.setseed(randx_mul ^ randy_mul ^ randz_mul ^ world.getseed()); this.generate(world, cube, xorigin, yorigin, zorigin, cubepos); } } } }","repo":"Cyclonit\/CubicChunks","label":[0,1,0,0]}
{"id":31498,"original_code":"public void testGetEnteredDate() {\n    System.out.println(\"testGetEnteredDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testGetEnteredDate() {\n    System.out.println(\"testGetEnteredDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetentereddate() { system.out.println(\"testgetentereddate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31499,"original_code":"public void testSetEnteredDate() {\n    System.out.println(\"testSetEnteredDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testSetEnteredDate() {\n    System.out.println(\"testSetEnteredDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetentereddate() { system.out.println(\"testsetentereddate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31500,"original_code":"public void testGetModifiedDate() {\n    System.out.println(\"testGetModifiedDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testGetModifiedDate() {\n    System.out.println(\"testGetModifiedDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetmodifieddate() { system.out.println(\"testgetmodifieddate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31501,"original_code":"public void testSetModifiedDate() {\n    System.out.println(\"testSetModifiedDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testSetModifiedDate() {\n    System.out.println(\"testSetModifiedDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetmodifieddate() { system.out.println(\"testsetmodifieddate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,1,0,0]}
{"id":31502,"original_code":"public void testGetReleaseDate() {\n    System.out.println(\"testGetReleaseDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testGetReleaseDate() {\n    System.out.println(\"testGetReleaseDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetreleasedate() { system.out.println(\"testgetreleasedate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31503,"original_code":"public void testSetReleaseDate() {\n    System.out.println(\"testSetReleaseDate\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testSetReleaseDate() {\n    System.out.println(\"testSetReleaseDate\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetreleasedate() { system.out.println(\"testsetreleasedate\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31504,"original_code":"public void testGetVisibleTo() {\n    System.out.println(\"testGetVisibleTo\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testGetVisibleTo() {\n    System.out.println(\"testGetVisibleTo\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testgetvisibleto() { system.out.println(\"testgetvisibleto\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31505,"original_code":"public void testSetVisibleTo() {\n    System.out.println(\"testSetVisibleTo\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testSetVisibleTo() {\n    System.out.println(\"testSetVisibleTo\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testsetvisibleto() { system.out.println(\"testsetvisibleto\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31506,"original_code":"public void testToString() {\n    System.out.println(\"testToString\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testToString() {\n    System.out.println(\"testToString\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testtostring() { system.out.println(\"testtostring\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":31507,"original_code":"public void testEquals() {\n    System.out.println(\"testEquals\");\n    \/\/ TODO add your test code below by replacing the default call to fail.\n    fail(\"The test case is empty.\");\n  }","code_wo_comment":"public void testEquals() {\n    System.out.println(\"testEquals\");\n   \n    fail(\"The test case is empty.\");\n  }","cleancode":"public void testequals() { system.out.println(\"testequals\"); fail(\"the test case is empty.\"); }","repo":"CBIIT\/camod","label":[0,0,0,1]}
{"id":15312,"original_code":"private void initMenuItems() {\n        menuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                var fileChooser = new FileChooser();\n                var selected = fileChooser.showOpenDialog(null);\n                if (selected != null) {\n                    \/\/TODO: file was choosen;\n                    ifmlEngine.loadStory(selected);\n                }\n            }\n        });\n        menuItemFileRestart.setDisable(true);\n        menuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                \/\/TODO: Ask You are sure ?\n                ifmlEngine.restart();\n            }\n        });\n        menuItemFileSave.setDisable(true);\n        menuItemFileLoad.setDisable(true);\n        menuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                \/\/TODO: Add question: You are really want to exit.\n                Platform.exit();\n            }\n        });\n        menuItemLibraryCatalog.setDisable(true);\n        menuItemLibraryImport.setDisable(true);\n        menuItemSettingsCheat.setDisable(true);\n        menuItemSettingsSettings.setDisable(true);\n    }","code_wo_comment":"private void initMenuItems() {\n        menuItemFileOpen.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n                var fileChooser = new FileChooser();\n                var selected = fileChooser.showOpenDialog(null);\n                if (selected != null) {\n                   \n                    ifmlEngine.loadStory(selected);\n                }\n            }\n        });\n        menuItemFileRestart.setDisable(true);\n        menuItemFileRestart.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n               \n                ifmlEngine.restart();\n            }\n        });\n        menuItemFileSave.setDisable(true);\n        menuItemFileLoad.setDisable(true);\n        menuItemFileExit.setOnAction(new EventHandler<ActionEvent>() {\n            @Override\n            public void handle(ActionEvent event) {\n               \n                Platform.exit();\n            }\n        });\n        menuItemLibraryCatalog.setDisable(true);\n        menuItemLibraryImport.setDisable(true);\n        menuItemSettingsCheat.setDisable(true);\n        menuItemSettingsSettings.setDisable(true);\n    }","cleancode":"private void initmenuitems() { menuitemfileopen.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { var filechooser = new filechooser(); var selected = filechooser.showopendialog(null); if (selected != null) { ifmlengine.loadstory(selected); } } }); menuitemfilerestart.setdisable(true); menuitemfilerestart.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { ifmlengine.restart(); } }); menuitemfilesave.setdisable(true); menuitemfileload.setdisable(true); menuitemfileexit.setonaction(new eventhandler<actionevent>() { @override public void handle(actionevent event) { platform.exit(); } }); menuitemlibrarycatalog.setdisable(true); menuitemlibraryimport.setdisable(true); menuitemsettingscheat.setdisable(true); menuitemsettingssettings.setdisable(true); }","repo":"IFML2\/ifml-player","label":[0,1,0,0]}
{"id":15473,"original_code":"private static Path resolve(Path parent, String path) {\n        \/\/ Ensure directories exist\n        File directory = parent.toFile();\n        if (!directory.exists() && !directory.mkdirs()) {\n            \/\/ Failed to create directories... should probably let this crash\n            ScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\n                    directory.getAbsolutePath());\n        }\n        return parent.resolve(path);\n    }","code_wo_comment":"private static Path resolve(Path parent, String path) {\n       \n        File directory = parent.toFile();\n        if (!directory.exists() && !directory.mkdirs()) {\n           \n            ScalingHealth.LOGGER.error(\"Failed to create config directory '{}'. This won't end well...\",\n                    directory.getAbsolutePath());\n        }\n        return parent.resolve(path);\n    }","cleancode":"private static path resolve(path parent, string path) { file directory = parent.tofile(); if (!directory.exists() && !directory.mkdirs()) { scalinghealth.logger.error(\"failed to create config directory '{}'. this won't end well...\", directory.getabsolutepath()); } return parent.resolve(path); }","repo":"Cyborgmas\/ScalingHealth","label":[0,0,1,0]}
{"id":15483,"original_code":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        Constructor<?> ctor = clazz.getDeclaredConstructors()[0];\n        ctor.setAccessible(true);\n        Object instance = ctor.newInstance();\n        Method method = null;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method m : declaredMethods) {\n            if (m.getName().equals(\"apply\")) method = m;\n        }\n        assert method != null: \"Method 'apply' not found in annotation class\";\n        method.setAccessible(true);\n        Object result;\n        try {\n            result = method.invoke(instance, trees);\n        }   catch (InvocationTargetException e) {\n            \/\/ we can't even pass exceptions without re-wraping them since classes on the invoking side are incompatible\n            \/\/ also flatten to avoid getting nested ITEs\n            RuntimeException exception = new RuntimeException(e.getTargetException().toString());\n            exception.setStackTrace(e.getStackTrace());\n            throw exception;\n        }\n        return result;\n    }","code_wo_comment":"private static Object invokeAnnotation(Class<?> clazz, Object[] trees) throws InstantiationException, IllegalAccessException, InvocationTargetException {\n        Constructor<?> ctor = clazz.getDeclaredConstructors()[0];\n        ctor.setAccessible(true);\n        Object instance = ctor.newInstance();\n        Method method = null;\n        Method[] declaredMethods = clazz.getDeclaredMethods();\n        for (Method m : declaredMethods) {\n            if (m.getName().equals(\"apply\")) method = m;\n        }\n        assert method != null: \"Method 'apply' not found in annotation class\";\n        method.setAccessible(true);\n        Object result;\n        try {\n            result = method.invoke(instance, trees);\n        }   catch (InvocationTargetException e) {\n           \n           \n            RuntimeException exception = new RuntimeException(e.getTargetException().toString());\n            exception.setStackTrace(e.getStackTrace());\n            throw exception;\n        }\n        return result;\n    }","cleancode":"private static object invokeannotation(class<?> clazz, object[] trees) throws instantiationexception, illegalaccessexception, invocationtargetexception { constructor<?> ctor = clazz.getdeclaredconstructors()[0]; ctor.setaccessible(true); object instance = ctor.newinstance(); method method = null; method[] declaredmethods = clazz.getdeclaredmethods(); for (method m : declaredmethods) { if (m.getname().equals(\"apply\")) method = m; } assert method != null: \"method 'apply' not found in annotation class\"; method.setaccessible(true); object result; try { result = method.invoke(instance, trees); } catch (invocationtargetexception e) { runtimeexception exception = new runtimeexception(e.gettargetexception().tostring()); exception.setstacktrace(e.getstacktrace()); throw exception; } return result; }","repo":"FogInTheFrog\/intellij-scala","label":[0,1,0,0]}
{"id":23785,"original_code":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\n        try (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n            \/\/ TODO insert preface\n        } finally {\n            context.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n        }\n    }","code_wo_comment":"private static void replaceParagraphWithPreface(final Context context, final XWPFParagraph paragraph) {\n        try (final CursorHelper cursorHelper = context.newCursorHelper(paragraph)) {\n           \n        } finally {\n            context.getDocument().removeBodyElement(context.getDocument().getPosOfParagraph(paragraph));\n        }\n    }","cleancode":"private static void replaceparagraphwithpreface(final context context, final xwpfparagraph paragraph) { try (final cursorhelper cursorhelper = context.newcursorhelper(paragraph)) { } finally { context.getdocument().removebodyelement(context.getdocument().getposofparagraph(paragraph)); } }","repo":"FIT-Mobility\/dimo-tool-suite","label":[0,1,0,0]}
{"id":15634,"original_code":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\n        exec.run(() -> {\n            try {\n                boolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n                \/\/ Get the inReplyTo from the parent property (foreign node) or if not found generate one based on\n                \/\/ what the local server version of it is.\n                String inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\n                APList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\n                String replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\n                String boostTarget = parent.getStr(NodeProp.BOOST);\n                \/\/ toUserNames will hold ALL usernames in the ACL list (both local and foreign user names)\n                HashSet<String> toUserNames = new HashSet<>();\n                boolean privateMessage = true;\n                if (forceSendToPublic) {\n                    privateMessage = false;\n                } else {\n                    if (ok(node.getAc())) {\n                        \/*\n                         * Lookup all userNames from the ACL info, to add them all to 'toUserNames'\n                         *\/\n                        for (String accntId : node.getAc().keySet()) {\n                            if (PrincipalName.PUBLIC.s().equals(accntId)) {\n                                privateMessage = false;\n                            } else {\n                                SubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n                                \/\/ get username off this node and add to 'toUserNames'\n                                if (ok(accntNode)) {\n                                    toUserNames.add(accntNode.getStr(NodeProp.USER));\n                                }\n                            }\n                        }\n                    }\n                }\n                \/\/ String apId = parent.getStringProp(NodeProp.ACT_PUB_ID.s());\n                String fromUser = ThreadLocals.getSC().getUserName();\n                String fromActor = apUtil.makeActorUrlForUserName(fromUser);\n                String privateKey = apCrypto.getPrivateKey(ms, fromUser);\n                String objUrl = snUtil.getIdBasedUrl(node);\n                APObj message = null;\n                if (node.getType().equals(NodeType.ACCOUNT.s())) {\n                    \/\/ construct the Update-type wrapper around teh Person object, and send\n                    message = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\n                    log.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n                } else {\n                    \/\/ if this node has a boostTarget, we know it's an Announce so we send out the announce\n                    \/\/ todo-0: we should probably rely on if there's an ActPub TYPE itself that's \"Announce\" (we save\n                    \/\/ that right?)\n                    if (!StringUtils.isEmpty(boostTarget)) {\n                        ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n                        message =\n                                apFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n                    }\n                    \/\/ else send out as a note.\n                    else {\n                        message = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\n                                node.getContent(), objUrl, privateMessage, attachments);\n                    }\n                }\n                \/\/ for users that don't have a sharedInbox we collect their inboxes here to send to them\n                \/\/ individually\n                HashSet<String> userInboxes = new HashSet<>();\n                \/\/ When posting a public message we send out to all unique sharedInboxes here\n                if (!privateMessage) {\n                    HashSet<String> sharedInboxes = new HashSet<>();\n                    \/\/ loads ONLY foreign user's inboxes into the two sets.\n                    getSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n                    \/\/ merge both sets of inboxes into allInboxes and send to them\n                    HashSet<String> allInboxes = new HashSet<>(userInboxes);\n                    allInboxes.addAll(sharedInboxes);\n                    apUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n                }\n                \/\/ Post message to all foreign usernames found in 'toUserNames', but skip all in userInboxes becasue\n                \/\/ we just sent to those above.\n                if (toUserNames.size() > 0) {\n                    sendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n                }\n            } \/\/\n            catch (Exception e) {\n                log.error(\"sendNote failed\", e);\n                throw new RuntimeException(e);\n            }\n        });\n    }","code_wo_comment":"public void sendObjOutbound(MongoSession ms, SubNode parent, SubNode node, boolean forceSendToPublic) {\n        exec.run(() -> {\n            try {\n                boolean isAccnt = NodeType.ACCOUNT.s().equals(node.getType());\n               \n               \n                String inReplyTo = !isAccnt ? apUtil.buildUrlForReplyTo(ms, parent) : null;\n                APList attachments = !isAccnt ? apub.createAttachmentsList(node) : null;\n                String replyToType = parent.getStr(NodeProp.ACT_PUB_OBJ_TYPE);\n                String boostTarget = parent.getStr(NodeProp.BOOST);\n               \n                HashSet<String> toUserNames = new HashSet<>();\n                boolean privateMessage = true;\n                if (forceSendToPublic) {\n                    privateMessage = false;\n                } else {\n                    if (ok(node.getAc())) {\n                       \n                        for (String accntId : node.getAc().keySet()) {\n                            if (PrincipalName.PUBLIC.s().equals(accntId)) {\n                                privateMessage = false;\n                            } else {\n                                SubNode accntNode = cachedGetAccntNodeById(ms, accntId);\n                               \n                                if (ok(accntNode)) {\n                                    toUserNames.add(accntNode.getStr(NodeProp.USER));\n                                }\n                            }\n                        }\n                    }\n                }\n               \n                String fromUser = ThreadLocals.getSC().getUserName();\n                String fromActor = apUtil.makeActorUrlForUserName(fromUser);\n                String privateKey = apCrypto.getPrivateKey(ms, fromUser);\n                String objUrl = snUtil.getIdBasedUrl(node);\n                APObj message = null;\n                if (node.getType().equals(NodeType.ACCOUNT.s())) {\n                   \n                    message = apFactory.newUpdateForPerson(fromUser, toUserNames, fromActor, privateMessage, node);\n                    log.debug(\"Sending updated Person outbound: \" + XString.prettyPrint(message));\n                } else {\n                   \n                   \n                   \n                    if (!StringUtils.isEmpty(boostTarget)) {\n                        ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);\n                        message =\n                                apFactory.newAnnounce(fromUser, fromActor, objUrl, toUserNames, boostTarget, now, privateMessage);\n                    }\n                   \n                    else {\n                        message = apFactory.newCreateForNote(fromUser, toUserNames, fromActor, inReplyTo, replyToType,\n                                node.getContent(), objUrl, privateMessage, attachments);\n                    }\n                }\n               \n               \n                HashSet<String> userInboxes = new HashSet<>();\n               \n                if (!privateMessage) {\n                    HashSet<String> sharedInboxes = new HashSet<>();\n                   \n                    getSharedInboxesOfFollowers(fromUser, sharedInboxes, userInboxes);\n                   \n                    HashSet<String> allInboxes = new HashSet<>(userInboxes);\n                    allInboxes.addAll(sharedInboxes);\n                    apUtil.securePostEx(allInboxes, fromActor, privateKey, fromActor, message, APConst.MTYPE_LD_JSON_PROF);\n                }\n               \n               \n                if (toUserNames.size() > 0) {\n                    sendMessageToUsers(ms, toUserNames, fromUser, message, privateMessage, userInboxes);\n                }\n            }\n            catch (Exception e) {\n                log.error(\"sendNote failed\", e);\n                throw new RuntimeException(e);\n            }\n        });\n    }","cleancode":"public void sendobjoutbound(mongosession ms, subnode parent, subnode node, boolean forcesendtopublic) { exec.run(() -> { try { boolean isaccnt = nodetype.account.s().equals(node.gettype()); string inreplyto = !isaccnt ? aputil.buildurlforreplyto(ms, parent) : null; aplist attachments = !isaccnt ? apub.createattachmentslist(node) : null; string replytotype = parent.getstr(nodeprop.act_pub_obj_type); string boosttarget = parent.getstr(nodeprop.boost); hashset<string> tousernames = new hashset<>(); boolean privatemessage = true; if (forcesendtopublic) { privatemessage = false; } else { if (ok(node.getac())) { for (string accntid : node.getac().keyset()) { if (principalname.public.s().equals(accntid)) { privatemessage = false; } else { subnode accntnode = cachedgetaccntnodebyid(ms, accntid); if (ok(accntnode)) { tousernames.add(accntnode.getstr(nodeprop.user)); } } } } } string fromuser = threadlocals.getsc().getusername(); string fromactor = aputil.makeactorurlforusername(fromuser); string privatekey = apcrypto.getprivatekey(ms, fromuser); string objurl = snutil.getidbasedurl(node); apobj message = null; if (node.gettype().equals(nodetype.account.s())) { message = apfactory.newupdateforperson(fromuser, tousernames, fromactor, privatemessage, node); log.debug(\"sending updated person outbound: \" + xstring.prettyprint(message)); } else { if (!stringutils.isempty(boosttarget)) { zoneddatetime now = zoneddatetime.now(zoneoffset.utc); message = apfactory.newannounce(fromuser, fromactor, objurl, tousernames, boosttarget, now, privatemessage); } else { message = apfactory.newcreatefornote(fromuser, tousernames, fromactor, inreplyto, replytotype, node.getcontent(), objurl, privatemessage, attachments); } } hashset<string> userinboxes = new hashset<>(); if (!privatemessage) { hashset<string> sharedinboxes = new hashset<>(); getsharedinboxesoffollowers(fromuser, sharedinboxes, userinboxes); hashset<string> allinboxes = new hashset<>(userinboxes); allinboxes.addall(sharedinboxes); aputil.securepostex(allinboxes, fromactor, privatekey, fromactor, message, apconst.mtype_ld_json_prof); } if (tousernames.size() > 0) { sendmessagetousers(ms, tousernames, fromuser, message, privatemessage, userinboxes); } } catch (exception e) { log.error(\"sendnote failed\", e); throw new runtimeexception(e); } }); }","repo":"Clay-Ferguson\/Quantizr","label":[1,0,0,0]}
{"id":15732,"original_code":"@Override\n\tpublic ReactionToIncomingMessage processIncomingMessage(Object message) {\n\t\tif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\n\t\t\tV2GMessage v2gMessageReq = (V2GMessage) message;\n\t\t\tCableCheckReqType cableCheckReq = \n\t\t\t\t\t(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\t\t\t\/\/ TODO how to react to failure status of DCEVStatus of cableCheckReq?\n\t\t\t\/*\n\t\t\t * TODO we need a timeout mechanism here so that a response can be sent within 2s\n\t\t\t * the DCEVSEStatus should be generated according to already available values\n\t\t\t * (if EVSEProcessing == ONGOING, maybe because of EVSE_IsolationMonitoringActive,\n\t\t\t * within a certain timeout, then the status must be different)\n\t\t\t *\/\n\t\t\tsetEvseProcessingFinished(true);\n\t\t\tif (isEvseProcessingFinished()) {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\n\t\t\t\tcableCheckRes.setDCEVSEStatus(\n\t\t\t\t\t\t((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n\t\t\t\t\t\t);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n\t\t\t} else {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);\n\t\t\t}\n\t\t} else {\n\t\t\tsetMandatoryFieldsForFailedRes();\n\t\t}\n\t\treturn getSendMessage(cableCheckRes, V2GMessages.NONE);\n\t}","code_wo_comment":"@Override\n\tpublic ReactionToIncomingMessage processIncomingMessage(Object message) {\n\t\tif (isIncomingMessageValid(message, CableCheckReqType.class, cableCheckRes)) {\n\t\t\tV2GMessage v2gMessageReq = (V2GMessage) message;\n\t\t\tCableCheckReqType cableCheckReq = \n\t\t\t\t\t(CableCheckReqType) v2gMessageReq.getBody().getBodyElement().getValue();\n\t\t\n\t\t\n\t\t\tsetEvseProcessingFinished(true);\n\t\t\tif (isEvseProcessingFinished()) {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.FINISHED);\n\t\t\t\tcableCheckRes.setDCEVSEStatus(\n\t\t\t\t\t\t((IDCEVSEController) getCommSessionContext().getDCEvseController()).getDCEVSEStatus(EVSENotificationType.NONE)\n\t\t\t\t\t\t);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.PRE_CHARGE_REQ);\n\t\t\t} else {\n\t\t\t\tcableCheckRes.setEVSEProcessing(EVSEProcessingType.ONGOING);\n\t\t\t\treturn getSendMessage(cableCheckRes, V2GMessages.CABLE_CHECK_REQ);\n\t\t\t}\n\t\t} else {\n\t\t\tsetMandatoryFieldsForFailedRes();\n\t\t}\n\t\treturn getSendMessage(cableCheckRes, V2GMessages.NONE);\n\t}","cleancode":"@override public reactiontoincomingmessage processincomingmessage(object message) { if (isincomingmessagevalid(message, cablecheckreqtype.class, cablecheckres)) { v2gmessage v2gmessagereq = (v2gmessage) message; cablecheckreqtype cablecheckreq = (cablecheckreqtype) v2gmessagereq.getbody().getbodyelement().getvalue(); setevseprocessingfinished(true); if (isevseprocessingfinished()) { cablecheckres.setevseprocessing(evseprocessingtype.finished); cablecheckres.setdcevsestatus( ((idcevsecontroller) getcommsessioncontext().getdcevsecontroller()).getdcevsestatus(evsenotificationtype.none) ); return getsendmessage(cablecheckres, v2gmessages.pre_charge_req); } else { cablecheckres.setevseprocessing(evseprocessingtype.ongoing); return getsendmessage(cablecheckres, v2gmessages.cable_check_req); } } else { setmandatoryfieldsforfailedres(); } return getsendmessage(cablecheckres, v2gmessages.none); }","repo":"I2SE\/RISE-V2G","label":[0,1,0,0]}
{"id":15882,"original_code":"public static void startActionFoo(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_FOO);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","code_wo_comment":"public static void startActionFoo(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_FOO);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","cleancode":"public static void startactionfoo(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_foo); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","repo":"CasterIO\/Bootstrap","label":[0,1,0,0]}
{"id":15883,"original_code":"public static void startActionBaz(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_BAZ);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","code_wo_comment":"public static void startActionBaz(Context context, String param1, String param2) {\n        Intent intent = new Intent(context, MyIntentService.class);\n        intent.setAction(ACTION_BAZ);\n        intent.putExtra(EXTRA_PARAM1, param1);\n        intent.putExtra(EXTRA_PARAM2, param2);\n        context.startService(intent);\n    }","cleancode":"public static void startactionbaz(context context, string param1, string param2) { intent intent = new intent(context, myintentservice.class); intent.setaction(action_baz); intent.putextra(extra_param1, param1); intent.putextra(extra_param2, param2); context.startservice(intent); }","repo":"CasterIO\/Bootstrap","label":[0,1,0,0]}
{"id":24133,"original_code":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\n\t\treturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n\t}","code_wo_comment":"public String deResolve(eu.hyvar.feature.HyFeatureAttribute element, eu.hyvar.context.contextValidity.HyAttributeValidityFormula container, EReference reference) {\n\t\treturn HyFeatureResolverUtil.deresolveFeatureAttribute(element, new Date());\n\t}","cleancode":"public string deresolve(eu.hyvar.feature.hyfeatureattribute element, eu.hyvar.context.contextvalidity.hyattributevalidityformula container, ereference reference) { return hyfeatureresolverutil.deresolvefeatureattribute(element, new date()); }","repo":"DarwinSPL\/DarwinSPL","label":[0,1,0,0]}
{"id":15951,"original_code":"public ExpressionStageOptions generateExpressionStageOptions() {\n\t\tList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\n\t\tExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\n\t\tList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\n\t\tList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\n\t\tint idCounter = 0;\n\t\tfor (String expressionStageString : allExpressionStagesRaw) {\n\t\t\tExpressionStage expressionStage = new ExpressionStage();\n\t\t\texpressionStage.setExpressionStageTitle(expressionStageString);\n\t\t\texpressionStage.setExpressionStageId(\"stage\" + idCounter);\n\t\t\texpressionStage.setExpressionStageNumericalId(idCounter);\n\t\t\tallExpressionStages.add(expressionStage);\n\t\t\tidCounter++;\n\t\t}\n\t\t\/\/ Add expressionStageList to returned object\n\t\texpressionStageOptions.setExpressionStageList(allExpressionStages);\n\t\t\/*\n\t\t * Add embryogenesis expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\n\t\tembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\t\tembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\n\t\tembryologyExpressionStageGroup.setGroupNumericalId(0);\n\t\tList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tembryologyExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\t\texpressionStageGroupList.add(embryologyExpressionStageGroup);\n\t\t\/*\n\t\t * Add development expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\n\t\tdevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\t\tdevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\n\t\tdevelopmentExpressionStageGroup.setGroupNumericalId(1);\n\t\tList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ larva stages\n\t\tfor (int i = 75; i <= 81; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(97));\n\t\tfor (int i = 49; i <= 54; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 38; i <= 41; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ TODO: Add the others\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(19));\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(44));\n\t\tdevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\n\t\texpressionStageGroupList.add(developmentExpressionStageGroup);\n\t\t\/*\n\t\t * Add tissue expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\n\t\ttissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\t\ttissueExpressionStageGroup.setGroupId(\"group\" + 2);\n\t\ttissueExpressionStageGroup.setGroupNumericalId(2);\n\t\tList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ A Mate stages\n\t\tfor (int i = 11; i <= 29; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 32; i <= 37; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 42; i <= 43; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 47; i <= 48; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\n\t\texpressionStageGroupList.add(tissueExpressionStageGroup);\n\t\t\/*\n\t\t * Add treatment expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\n\t\ttreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\n\t\ttreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\n\t\ttreatmentExpressionStageGroup.setGroupNumericalId(3);\n\t\tList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ larva stages\n\t\tfor (int i = 82; i <= 90; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\n\t\texpressionStageGroupList.add(treatmentExpressionStageGroup);\n\t\t\/*\n\t\t * Add cell-line expressionStageGroup\n\t\t *\/\n\t\tExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\n\t\tcellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\n\t\tcellLineExpressionStageGroup.setGroupId(\"group\" + 4);\n\t\tcellLineExpressionStageGroup.setGroupNumericalId(4);\n\t\tList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\t\t\/\/ Add embryo stages\n\t\tfor (int i = 98; i <= 103; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\t\/\/ larva stages\n\t\tfor (int i = 68; i <= 74; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 91; i <= 96; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 45; i <= 46; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 30; i <= 31; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tcellLineExpressionStageList.add(allExpressionStages.get(55));\n\t\t\/\/ TODO: Add the others\n\t\tcellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\n\t\texpressionStageGroupList.add(cellLineExpressionStageGroup);\n\t\texpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\n\t\treturn expressionStageOptions;\n\t}","code_wo_comment":"public ExpressionStageOptions generateExpressionStageOptions() {\n\t\tList<String> allExpressionStagesRaw = retrieveExpressionStages.getDmelanogasterExpressionStages();\n\t\tExpressionStageOptions expressionStageOptions = new ExpressionStageOptions();\n\t\tList<ExpressionStageGroup> expressionStageGroupList = new LinkedList<ExpressionStageGroup>();\n\t\tList<ExpressionStage> allExpressionStages = new ArrayList<ExpressionStage>(allExpressionStagesRaw.size());\n\t\tint idCounter = 0;\n\t\tfor (String expressionStageString : allExpressionStagesRaw) {\n\t\t\tExpressionStage expressionStage = new ExpressionStage();\n\t\t\texpressionStage.setExpressionStageTitle(expressionStageString);\n\t\t\texpressionStage.setExpressionStageId(\"stage\" + idCounter);\n\t\t\texpressionStage.setExpressionStageNumericalId(idCounter);\n\t\t\tallExpressionStages.add(expressionStage);\n\t\t\tidCounter++;\n\t\t}\n\t\n\t\texpressionStageOptions.setExpressionStageList(allExpressionStages);\n\t\n\t\tExpressionStageGroup embryologyExpressionStageGroup = new ExpressionStageGroup();\n\t\tembryologyExpressionStageGroup.setGroupTitle(\"embryogenesis\");\n\t\tembryologyExpressionStageGroup.setGroupId(\"group\" + 0);\n\t\tembryologyExpressionStageGroup.setGroupNumericalId(0);\n\t\tList<ExpressionStage> embryologyExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tembryologyExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tembryologyExpressionStageGroup.setExpressionStageList(embryologyExpressionStageList);\n\t\texpressionStageGroupList.add(embryologyExpressionStageGroup);\n\t\n\t\tExpressionStageGroup developmentExpressionStageGroup = new ExpressionStageGroup();\n\t\tdevelopmentExpressionStageGroup.setGroupTitle(\"development\");\n\t\tdevelopmentExpressionStageGroup.setGroupId(\"group\" + 1);\n\t\tdevelopmentExpressionStageGroup.setGroupNumericalId(1);\n\t\tList<ExpressionStage> developmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 56; i <= 67; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tfor (int i = 75; i <= 81; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(97));\n\t\tfor (int i = 49; i <= 54; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 38; i <= 41; i++) {\n\t\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(19));\n\t\tdevelopmentExpressionStageList.add(allExpressionStages.get(44));\n\t\tdevelopmentExpressionStageGroup.setExpressionStageList(developmentExpressionStageList);\n\t\texpressionStageGroupList.add(developmentExpressionStageGroup);\n\t\n\t\tExpressionStageGroup tissueExpressionStageGroup = new ExpressionStageGroup();\n\t\ttissueExpressionStageGroup.setGroupTitle(\"tissue\");\n\t\ttissueExpressionStageGroup.setGroupId(\"group\" + 2);\n\t\ttissueExpressionStageGroup.setGroupNumericalId(2);\n\t\tList<ExpressionStage> tissueExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 11; i <= 29; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 32; i <= 37; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 42; i <= 43; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 47; i <= 48; i++) {\n\t\t\ttissueExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttissueExpressionStageGroup.setExpressionStageList(tissueExpressionStageList);\n\t\texpressionStageGroupList.add(tissueExpressionStageGroup);\n\t\n\t\tExpressionStageGroup treatmentExpressionStageGroup = new ExpressionStageGroup();\n\t\ttreatmentExpressionStageGroup.setGroupTitle(\"treatment\");\n\t\ttreatmentExpressionStageGroup.setGroupId(\"group\" + 3);\n\t\ttreatmentExpressionStageGroup.setGroupNumericalId(3);\n\t\tList<ExpressionStage> treatmentExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 82; i <= 90; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 0; i <= 10; i++) {\n\t\t\ttreatmentExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\ttreatmentExpressionStageGroup.setExpressionStageList(treatmentExpressionStageList);\n\t\texpressionStageGroupList.add(treatmentExpressionStageGroup);\n\t\n\t\tExpressionStageGroup cellLineExpressionStageGroup = new ExpressionStageGroup();\n\t\tcellLineExpressionStageGroup.setGroupTitle(\"cell-line\");\n\t\tcellLineExpressionStageGroup.setGroupId(\"group\" + 4);\n\t\tcellLineExpressionStageGroup.setGroupNumericalId(4);\n\t\tList<ExpressionStage> cellLineExpressionStageList = new LinkedList<ExpressionStage>();\n\t\n\t\tfor (int i = 98; i <= 103; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\n\t\tfor (int i = 68; i <= 74; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 91; i <= 96; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 45; i <= 46; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tfor (int i = 30; i <= 31; i++) {\n\t\t\tcellLineExpressionStageList.add(allExpressionStages.get(i));\n\t\t}\n\t\tcellLineExpressionStageList.add(allExpressionStages.get(55));\n\t\n\t\tcellLineExpressionStageGroup.setExpressionStageList(cellLineExpressionStageList);\n\t\texpressionStageGroupList.add(cellLineExpressionStageGroup);\n\t\texpressionStageOptions.setExpressionStageGroupList(expressionStageGroupList);\n\t\treturn expressionStageOptions;\n\t}","cleancode":"public expressionstageoptions generateexpressionstageoptions() { list<string> allexpressionstagesraw = retrieveexpressionstages.getdmelanogasterexpressionstages(); expressionstageoptions expressionstageoptions = new expressionstageoptions(); list<expressionstagegroup> expressionstagegrouplist = new linkedlist<expressionstagegroup>(); list<expressionstage> allexpressionstages = new arraylist<expressionstage>(allexpressionstagesraw.size()); int idcounter = 0; for (string expressionstagestring : allexpressionstagesraw) { expressionstage expressionstage = new expressionstage(); expressionstage.setexpressionstagetitle(expressionstagestring); expressionstage.setexpressionstageid(\"stage\" + idcounter); expressionstage.setexpressionstagenumericalid(idcounter); allexpressionstages.add(expressionstage); idcounter++; } expressionstageoptions.setexpressionstagelist(allexpressionstages); expressionstagegroup embryologyexpressionstagegroup = new expressionstagegroup(); embryologyexpressionstagegroup.setgrouptitle(\"embryogenesis\"); embryologyexpressionstagegroup.setgroupid(\"group\" + 0); embryologyexpressionstagegroup.setgroupnumericalid(0); list<expressionstage> embryologyexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 56; i <= 67; i++) { embryologyexpressionstagelist.add(allexpressionstages.get(i)); } embryologyexpressionstagegroup.setexpressionstagelist(embryologyexpressionstagelist); expressionstagegrouplist.add(embryologyexpressionstagegroup); expressionstagegroup developmentexpressionstagegroup = new expressionstagegroup(); developmentexpressionstagegroup.setgrouptitle(\"development\"); developmentexpressionstagegroup.setgroupid(\"group\" + 1); developmentexpressionstagegroup.setgroupnumericalid(1); list<expressionstage> developmentexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 56; i <= 67; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 75; i <= 81; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(97)); for (int i = 49; i <= 54; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 38; i <= 41; i++) { developmentexpressionstagelist.add(allexpressionstages.get(i)); } developmentexpressionstagelist.add(allexpressionstages.get(19)); developmentexpressionstagelist.add(allexpressionstages.get(44)); developmentexpressionstagegroup.setexpressionstagelist(developmentexpressionstagelist); expressionstagegrouplist.add(developmentexpressionstagegroup); expressionstagegroup tissueexpressionstagegroup = new expressionstagegroup(); tissueexpressionstagegroup.setgrouptitle(\"tissue\"); tissueexpressionstagegroup.setgroupid(\"group\" + 2); tissueexpressionstagegroup.setgroupnumericalid(2); list<expressionstage> tissueexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 11; i <= 29; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 32; i <= 37; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 42; i <= 43; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 47; i <= 48; i++) { tissueexpressionstagelist.add(allexpressionstages.get(i)); } tissueexpressionstagegroup.setexpressionstagelist(tissueexpressionstagelist); expressionstagegrouplist.add(tissueexpressionstagegroup); expressionstagegroup treatmentexpressionstagegroup = new expressionstagegroup(); treatmentexpressionstagegroup.setgrouptitle(\"treatment\"); treatmentexpressionstagegroup.setgroupid(\"group\" + 3); treatmentexpressionstagegroup.setgroupnumericalid(3); list<expressionstage> treatmentexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 82; i <= 90; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 0; i <= 10; i++) { treatmentexpressionstagelist.add(allexpressionstages.get(i)); } treatmentexpressionstagegroup.setexpressionstagelist(treatmentexpressionstagelist); expressionstagegrouplist.add(treatmentexpressionstagegroup); expressionstagegroup celllineexpressionstagegroup = new expressionstagegroup(); celllineexpressionstagegroup.setgrouptitle(\"cell-line\"); celllineexpressionstagegroup.setgroupid(\"group\" + 4); celllineexpressionstagegroup.setgroupnumericalid(4); list<expressionstage> celllineexpressionstagelist = new linkedlist<expressionstage>(); for (int i = 98; i <= 103; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 68; i <= 74; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 91; i <= 96; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 45; i <= 46; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } for (int i = 30; i <= 31; i++) { celllineexpressionstagelist.add(allexpressionstages.get(i)); } celllineexpressionstagelist.add(allexpressionstages.get(55)); celllineexpressionstagegroup.setexpressionstagelist(celllineexpressionstagelist); expressionstagegrouplist.add(celllineexpressionstagegroup); expressionstageoptions.setexpressionstagegrouplist(expressionstagegrouplist); return expressionstageoptions; }","repo":"CodingBash\/fly-transcription-webapp","label":[1,1,0,0]}
{"id":7837,"original_code":"public Image LoadImageAnim(String fileName, int frames) {\n        Image image = new Image();\n        int framesCount = 1;\n        if (SUPPORT_FILEFORMAT_GIF) {\n            if (rCore.IsFileExtension(fileName, \".gif\")) {\n                byte[] fileData = null;\n                try{\n                    BufferedImage tmpImg = ImageIO.read(new File(fileName));\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    ImageIO.write(tmpImg, rCore.GetFileExtension(fileName).substring(1), os);\n                    fileData = os.toByteArray();\n                } catch (IOException exception) {\n                    exception.printStackTrace();\n                }\n                if (fileData != null) {\n                    try (MemoryStack stack = MemoryStack.stackPush()) {\n                        IntBuffer widthBuffer = stack.mallocInt(1);\n                        IntBuffer heightBuffer = stack.mallocInt(1);\n                        IntBuffer compBuffer = stack.mallocInt(1);\n                        PointerBuffer delaysBuffer = null;\n                        IntBuffer framesBuffer = stack.mallocInt(1);\n                        framesBuffer.put(framesCount).flip();\n                        ByteBuffer fileDataBuffer = MemoryUtil.memAlloc(fileData.length);\n                        fileDataBuffer.put(fileData).flip();\n                        ByteBuffer imgBuffer = STBImage.stbi_load_gif_from_memory(fileDataBuffer, delaysBuffer,\n                                                                                  widthBuffer, heightBuffer, framesBuffer, compBuffer, 4);\n                        image.width = widthBuffer.get();\n                        image.height = heightBuffer.get();\n                        image.mipmaps = 1;\n                        image.format = RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;\n                        if (imgBuffer != null) {\n                            byte[] bytes = new byte[imgBuffer.capacity()];\n                            for (int i = 0; i < bytes.length; i++) {\n                                bytes[i] = imgBuffer.get();\n                            }\n                            image.setData(bytes);\n                        }\n                        fileData = null;\n                    }\n                }\n            }\n        }\n        else{\n            image = LoadImage(fileName);\n        }\n        \/\/ TODO: Support APNG animated images?\n        frames = framesCount;\n        return image;\n    }","code_wo_comment":"public Image LoadImageAnim(String fileName, int frames) {\n        Image image = new Image();\n        int framesCount = 1;\n        if (SUPPORT_FILEFORMAT_GIF) {\n            if (rCore.IsFileExtension(fileName, \".gif\")) {\n                byte[] fileData = null;\n                try{\n                    BufferedImage tmpImg = ImageIO.read(new File(fileName));\n                    ByteArrayOutputStream os = new ByteArrayOutputStream();\n                    ImageIO.write(tmpImg, rCore.GetFileExtension(fileName).substring(1), os);\n                    fileData = os.toByteArray();\n                } catch (IOException exception) {\n                    exception.printStackTrace();\n                }\n                if (fileData != null) {\n                    try (MemoryStack stack = MemoryStack.stackPush()) {\n                        IntBuffer widthBuffer = stack.mallocInt(1);\n                        IntBuffer heightBuffer = stack.mallocInt(1);\n                        IntBuffer compBuffer = stack.mallocInt(1);\n                        PointerBuffer delaysBuffer = null;\n                        IntBuffer framesBuffer = stack.mallocInt(1);\n                        framesBuffer.put(framesCount).flip();\n                        ByteBuffer fileDataBuffer = MemoryUtil.memAlloc(fileData.length);\n                        fileDataBuffer.put(fileData).flip();\n                        ByteBuffer imgBuffer = STBImage.stbi_load_gif_from_memory(fileDataBuffer, delaysBuffer,\n                                                                                  widthBuffer, heightBuffer, framesBuffer, compBuffer, 4);\n                        image.width = widthBuffer.get();\n                        image.height = heightBuffer.get();\n                        image.mipmaps = 1;\n                        image.format = RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;\n                        if (imgBuffer != null) {\n                            byte[] bytes = new byte[imgBuffer.capacity()];\n                            for (int i = 0; i < bytes.length; i++) {\n                                bytes[i] = imgBuffer.get();\n                            }\n                            image.setData(bytes);\n                        }\n                        fileData = null;\n                    }\n                }\n            }\n        }\n        else{\n            image = LoadImage(fileName);\n        }\n       \n        frames = framesCount;\n        return image;\n    }","cleancode":"public image loadimageanim(string filename, int frames) { image image = new image(); int framescount = 1; if (support_fileformat_gif) { if (rcore.isfileextension(filename, \".gif\")) { byte[] filedata = null; try{ bufferedimage tmpimg = imageio.read(new file(filename)); bytearrayoutputstream os = new bytearrayoutputstream(); imageio.write(tmpimg, rcore.getfileextension(filename).substring(1), os); filedata = os.tobytearray(); } catch (ioexception exception) { exception.printstacktrace(); } if (filedata != null) { try (memorystack stack = memorystack.stackpush()) { intbuffer widthbuffer = stack.mallocint(1); intbuffer heightbuffer = stack.mallocint(1); intbuffer compbuffer = stack.mallocint(1); pointerbuffer delaysbuffer = null; intbuffer framesbuffer = stack.mallocint(1); framesbuffer.put(framescount).flip(); bytebuffer filedatabuffer = memoryutil.memalloc(filedata.length); filedatabuffer.put(filedata).flip(); bytebuffer imgbuffer = stbimage.stbi_load_gif_from_memory(filedatabuffer, delaysbuffer, widthbuffer, heightbuffer, framesbuffer, compbuffer, 4); image.width = widthbuffer.get(); image.height = heightbuffer.get(); image.mipmaps = 1; image.format = rl_pixelformat_uncompressed_r8g8b8a8; if (imgbuffer != null) { byte[] bytes = new byte[imgbuffer.capacity()]; for (int i = 0; i < bytes.length; i++) { bytes[i] = imgbuffer.get(); } image.setdata(bytes); } filedata = null; } } } } else{ image = loadimage(filename); } frames = framescount; return image; }","repo":"CreedVI\/Raylib-J","label":[0,1,0,0]}
{"id":7893,"original_code":"public static GetEntityResponse<EventInfo> toEvent(\n          final IcalCallback cb,\n          final BwCalendar cal,\n          final Icalendar ical,\n          final Component val,\n          final boolean mergeAttendees) {\n    final var resp = new GetEntityResponse<EventInfo>();\n    if (val == null) {\n      return Response.notOk(resp, failed, \"No component supplied\");\n    }\n    String currentPrincipal = null;\n    final BwPrincipal principal = cb.getPrincipal();\n    if (principal != null) {\n      currentPrincipal = principal.getPrincipalRef();\n    }\n    final Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\n    final int methodType = ical.getMethodType();\n    String attUri = null;\n    if (mergeAttendees) {\n      \/\/ We'll need this later.\n      attUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n    }\n    final String colPath;\n    if (cal == null) {\n      colPath = null;\n    } else {\n      colPath = cal.getPath();\n    }\n    try {\n      final PropertyList<Property> pl = val.getProperties();\n      boolean vpoll = false;\n      boolean event = false;\n      boolean task = false;\n      if (pl == null) {\n        \/\/ Empty component\n        return Response.notOk(resp, failed, \"Empty component\");\n      }\n      final int entityType;\n      if (val instanceof VEvent) {\n        entityType = IcalDefs.entityTypeEvent;\n        event = true;\n      } else if (val instanceof VToDo) {\n        entityType = IcalDefs.entityTypeTodo;\n        task = true;\n      } else if (val instanceof VJournal) {\n        entityType = IcalDefs.entityTypeJournal;\n      } else if (val instanceof VFreeBusy) {\n        entityType = IcalDefs.entityTypeFreeAndBusy;\n      } else if (val instanceof VAvailability) {\n        entityType = IcalDefs.entityTypeVavailability;\n      } else if (val instanceof Available) {\n        entityType = IcalDefs.entityTypeAvailable;\n      } else if (val instanceof VPoll) {\n        entityType = IcalDefs.entityTypeVpoll;\n        vpoll = true;\n      } else {\n        return Response.error(resp, \"org.bedework.invalid.component.type: \" +\n                val.getName());\n      }\n      \/\/ Get the guid from the component\n      String guid = null;\n      final Uid uidp = pl.getProperty(Property.UID);\n      if (uidp != null) {\n        testXparams(uidp, hasXparams);\n        guid = uidp.getValue();\n      }\n      if (guid == null) {\n        \/* XXX A guid is required - but are there devices out there without a\n         *       guid - and if so how do we handle it?\n         *\/\n        return Response.notOk(resp, failed, CalFacadeException.noGuid);\n      }\n      \/* See if we have a recurrence id *\/\n      BwDateTime ridObj = null;\n      String rid = null;\n      TimeZone ridTz = null;\n      final RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\n      if (ridp != null) {\n        testXparams(ridp, hasXparams);\n        ridObj = BwDateTime.makeBwDateTime(ridp);\n        if (ridObj.getRange() != null) {\n          \/* XXX What do I do with it? *\/\n          logger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n        }\n        rid = ridObj.getDate();\n      }\n      EventInfo masterEI = null;\n      EventInfo evinfo = null;\n      final BwEvent ev;\n      \/* If we have a recurrence id see if we already have the master (we should\n       * get a master + all its overrides).\n       *\n       * If so find the override and use the annnotation or if no override,\n       * make one.\n       *\n       * If no override retrieve the event, add it to our table and then locate the\n       * annotation.\n       *\n       * If there is no annotation, create one.\n       *\n       * It's possible we have been sent 'detached' instances of a recurring\n       * event. This may happen if we are invited to one or more instances of a\n       * meeting. In this case we try to retrieve the master and if it doesn't\n       * exist we manufacture one. We consider such an instance an update to\n       * that instance only and leave the others alone.\n       *\/\n      \/* We need this in a couple of places *\/\n      final DtStart dtStart = pl.getProperty(Property.DTSTART);\n      \/*\n      if (rid != null) {\n        \/\/ See if we have a new master event. If so create a proxy to that event.\n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI == null) {\n          masterEI = makeNewEvent(cb, chg, entityType, guid, cal);\n          BwEvent e = masterEI.getEvent();\n          \/\/ XXX This seems bogus\n          DtStart mdtStart;\n          String bogusDate = \"19980118T230000\";\n          if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + \"Z\");\n          } else if (dtStart.getTimeZone() == null) {\n            mdtStart = new DtStart(bogusDate);\n          } else {\n            mdtStart = new DtStart(bogusDate + \"Z\", dtStart.getTimeZone());\n          }\n          setDates(e, mdtStart, null, null, chg);\n          e.setRecurring(true);\n          e.addRdate(ridObj);\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n        }\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n        }\n      }\n      *\/\n      \/* If this is a recurrence instance see if we can find the master\n         We only need this because the master may follow the overrides.\n       *\/\n      if (rid != null) {\n        \/\/ See if we have a new master event. If so create a proxy to this event.\n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n        }\n      }\n      if ((evinfo == null) &&\n          (cal != null) &&\n          (cal.getCalType() != BwCalendar.calTypeInbox) &&\n          (cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n          (cal.getCalType() != BwCalendar.calTypeOutbox)) {\n        if (logger.debug()) {\n          logger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n        }\n        final GetEntitiesResponse<EventInfo> eisResp =\n                cb.getEvent(colPath, guid);\n        if (eisResp.isError()) {\n          return Response.fromResponse(resp, eisResp);\n        }\n        final var eis = eisResp.getEntities();\n        if (!Util.isEmpty(eis)) {\n          if (eis.size() > 1) {\n            \/\/ DORECUR - wrong again\n            return Response.notOk(resp, failed,\n                                  \"More than one event returned for guid.\");\n          }\n          evinfo = eis.iterator().next();\n        }\n        if (logger.debug()) {\n          if (evinfo != null) {\n            logger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n          } else {\n            logger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n          }\n        }\n        if (evinfo != null) {\n          if (rid != null) {\n            \/\/ We just retrieved it's master\n            masterEI = evinfo;\n            masterEI.setInstanceOnly(true);\n            evinfo = masterEI.findOverride(rid);\n            evinfo.recurrenceSeen = true;\n            ical.addComponent(masterEI);\n          } else if (methodType == ScheduleMethods.methodTypeCancel) {\n            \/\/ This should never have an rid for cancel of entire event.\n            evinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n          } else {\n            \/\/ Presumably sent an update for the entire event. No longer suppressed master\n            evinfo.getEvent().setSuppressed(false);\n          }\n        } else if (rid != null) {\n          \/* Manufacture a master for the instance *\/\n          masterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n          final BwEvent e = masterEI.getEvent();\n          \/\/ XXX This seems bogus\n          final DtStart mdtStart;\n          final String bogusDate = \"19980118\";\n          final String bogusTime = \"T230000\";\n          \/\/ Base dtstart on the recurrence id.\n          final boolean isDateType = ridObj.getDateType();\n          if (isDateType) {\n            mdtStart = new DtStart(new Date(bogusDate));\n          } else if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n          } else if (ridObj.getTzid() == null) {\n            mdtStart = new DtStart(bogusDate + bogusTime);\n          } else {\n            mdtStart = new DtStart(bogusDate + bogusTime,\n                                   Timezones.getTz(ridObj.getTzid()));\n          }\n          IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                            masterEI, mdtStart, null, null);\n          e.setRecurring(true);\n\/\/          e.addRdate(ridObj);\n          final var sum = (Summary)pl.getProperty(Property.SUMMARY);\n          e.setSummary(sum.getValue());\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n          masterEI.setInstanceOnly(rid != null);\n        }\n      }\n      if (evinfo == null) {\n        evinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n      } else if (evinfo.getEvent().getEntityType() != entityType) {\n        return Response.notOk(resp, failed,\n                              \"org.bedework.mismatched.entity.type: \" +\n                                      val);\n      }\n      final ChangeTable chg = evinfo.getChangeset(\n              cb.getPrincipal().getPrincipalRef());\n      if (rid != null) {\n        final String evrid = evinfo.getEvent().getRecurrenceId();\n        if ((evrid == null) || (!evrid.equals(rid))) {\n          logger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\n          chg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid); \/\/ XXX spurious???\n        }\n        if (masterEI.getEvent().getSuppressed()) {\n          masterEI.getEvent().addRdate(ridObj);\n        }\n      }\n      ev = evinfo.getEvent();\n      ev.setScheduleMethod(methodType);\n      DtEnd dtEnd = null;\n      if (entityType == IcalDefs.entityTypeTodo) {\n        final Due due = pl.getProperty(Property.DUE);\n        if (due != null ) {\n          dtEnd = new DtEnd(due.getParameters(), due.getValue());\n        }\n      } else {\n        dtEnd = pl.getProperty(Property.DTEND);\n      }\n      final Duration duration = pl.getProperty(Property.DURATION);\n      IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                        evinfo, dtStart, dtEnd, duration);\n      for (final Property prop: pl) {\n        testXparams(prop, hasXparams);\n        \/\/debug(\"ical prop \" + prop.getClass().getName());\n        String pval = prop.getValue();\n        if ((pval != null) && (pval.length() == 0)) {\n          pval = null;\n        }\n        final PropertyInfoIndex pi;\n        if (prop instanceof XProperty) {\n          pi = PropertyInfoIndex.XPROP;\n        } else {\n          pi = PropertyInfoIndex.fromName(prop.getName());\n        }\n        if (pi == null) {\n          logger.debug(\"Unknown property with name \" + prop.getName() +\n                                \" class \" + prop.getClass() +\n                                \" and value \" + pval);\n          continue;\n        }\n        chg.present(pi);\n        switch (pi) {\n          case ACCEPT_RESPONSE:\n            \/* ------------------- Accept Response -------------------- *\/\n            String sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\n              ev.setPollAcceptResponse(sval);\n            }\n            break;\n          case ATTACH:\n            \/* ------------------- Attachment -------------------- *\/\n            chg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\n            break;\n          case ATTENDEE:\n            \/* ------------------- Attendee -------------------- *\/\n            if (methodType == ScheduleMethods.methodTypePublish) {\n              if (cb.getStrictness() == IcalCallback.conformanceStrict) {\n                return Response.notOk(resp, failed,\n                                      CalFacadeException.attendeesInPublish);\n              }\n              \/\/if (cb.getStrictness() == IcalCallback.conformanceWarn) {\n              \/\/  warn(\"Had attendees for PUBLISH\");\n              \/\/}\n            }\n            final Attendee attPr = (Attendee)prop;\n            if (evinfo.getNewEvent() || !mergeAttendees) {\n              chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n            } else {\n              final String pUri = cb.getCaladdr(attPr.getValue());\n              if (pUri.equals(attUri)) {\n                \/* Only update for our own attendee\n                 * We're doing a PUT and this must be the attendee updating their\n                 * partstat. We don't allow them to change other attendees\n                 * whatever the PUT content says.\n                 *\/\n                chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n              } else {\n                \/\/ Use the value we currently have\n                boolean found = false;\n                for (final BwAttendee att: ev.getAttendees()) {\n                  if (pUri.equals(att.getAttendeeUri())) {\n                    chg.addValue(pi, att.clone());\n                    found = true;\n                    break;\n                  }\n                }\n                if (!found) {\n                  \/\/ An added attendee\n                  final BwAttendee att = IcalUtil\n                          .getAttendee(cb, attPr);\n                  att.setPartstat(IcalDefs.partstatValNeedsAction);\n                  chg.addValue(pi, att);\n                }\n              }\n            }\n            break;\n          case BUSYTYPE:\n            final int ibt = BwEvent.fromBusyTypeString(pval);\n            if (chg.changed(pi,\n                            ev.getBusyType(),\n                            ibt)) {\n              ev.setBusyType(ibt);\n            }\n            break;\n          case CATEGORIES:\n            \/* ------------------- Categories -------------------- *\/\n            final Categories cats = (Categories)prop;\n            final TextList cl = cats.getCategories();\n            String lang = IcalUtil.getLang(cats);\n            if (cl != null) {\n              \/* Got some categories *\/\n              for (final String wd: cl) {\n                if (wd == null) {\n                  continue;\n                }\n                final BwString key = new BwString(lang, wd);\n                final var fcResp = cb.findCategory(key);\n                final BwCategory cat;\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isNotFound()) {\n                  cat = BwCategory.makeCategory();\n                  cat.setWord(key);\n                  cb.addCategory(cat);\n                } else {\n                  cat = fcResp.getEntity();\n                }\n                chg.addValue(pi, cat);\n              }\n            }\n            break;\n          case CLASS:\n            \/* ------------------- Class -------------------- *\/\n            if (chg.changed(pi, ev.getClassification(), pval)) {\n              ev.setClassification(pval);\n            }\n            break;\n          case COMMENT:\n            \/* ------------------- Comment -------------------- *\/\n            chg.addValue(pi,\n                         new BwString(null, pval));\n            break;\n          case COMPLETED:\n            \/* ------------------- Completed -------------------- *\/\n            if (chg.changed(pi, ev.getCompleted(), pval)) {\n              ev.setCompleted(pval);\n            }\n            break;\n          case CONCEPT:\n            \/* ------------------- Concept -------------------- *\/\n            final Concept c = (Concept)prop;\n            final String cval = c.getValue();\n            if (cval != null) {\n              \/* Got a concept *\/\n              chg.addValue(PropertyInfoIndex.XPROP,\n                           BwXproperty.makeIcalProperty(\"CONCEPT\",\n                                                        null,\n                                                        cval));\n            }\n            break;\n          case CONTACT:\n            \/* ------------------- Contact -------------------- *\/\n            final String altrep = getAltRepPar(prop);\n            lang = IcalUtil.getLang(prop);\n            final String uid = getUidPar(prop);\n            final BwString nm = new BwString(lang, pval);\n            BwContact contact = null;\n            if (uid != null) {\n              final var fcResp = cb.getContact(uid);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              final var fcResp = cb.findContact(nm);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              contact = BwContact.makeContact();\n              contact.setCn(nm);\n              contact.setLink(altrep);\n              cb.addContact(contact);\n            } else {\n              contact.setCn(nm);\n              contact.setLink(altrep);\n            }\n            chg.addValue(pi, contact);\n            break;\n          case CREATED:\n            \/* ------------------- Created -------------------- *\/\n            if (chg.changed(pi, ev.getCreated(), pval)) {\n              ev.setCreated(pval);\n            }\n            break;\n          case DESCRIPTION:\n            \/* ------------------- Description -------------------- *\/\n            if (chg.changed(pi, ev.getDescription(), pval)) {\n              ev.setDescription(pval);\n            }\n            break;\n          case DTEND:\n            \/* ------------------- DtEnd -------------------- *\/\n            break;\n          case DTSTAMP:\n            \/* ------------------- DtStamp -------------------- *\/\n            ev.setDtstamp(pval);\n            break;\n          case DTSTART:\n            \/* ------------------- DtStart -------------------- *\/\n            break;\n          case DUE:\n            \/* -------------------- Due ------------------------ *\/\n            break;\n          case DURATION:\n            \/* ------------------- Duration -------------------- *\/\n            break;\n          case EXDATE:\n            \/* ------------------- ExDate -------------------- *\/\n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case EXRULE:\n            \/* ------------------- ExRule -------------------- *\/\n            chg.addValue(pi, pval);\n            break;\n          case FREEBUSY:\n            \/* ------------------- freebusy -------------------- *\/\n            final FreeBusy fbusy = (FreeBusy)prop;\n            final PeriodList perpl = fbusy.getPeriods();\n            final Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\n            final int fbtype;\n            if (par == null) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY)) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY_TENTATIVE)) {\n              fbtype = BwFreeBusyComponent.typeBusyTentative;\n            } else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\n              fbtype = BwFreeBusyComponent.typeBusyUnavailable;\n            } else if (par.equals(FbType.FREE)) {\n              fbtype = BwFreeBusyComponent.typeFree;\n            } else {\n              if (logger.debug()) {\n                logger.debug(\"Unsupported parameter \" + par.getName());\n              }\n              return Response.notOk(resp, failed,\n                                    \"Unsupported parameter \" +\n                                            par.getName());\n            }\n            final BwFreeBusyComponent fbc = new BwFreeBusyComponent();\n            fbc.setType(fbtype);\n            for (final Period per : perpl) {\n              fbc.addPeriod(per);\n            }\n            ev.addFreeBusyPeriod(fbc);\n            break;\n          case GEO:\n            \/* ------------------- Geo -------------------- *\/\n            final Geo g = (Geo)prop;\n            final BwGeo geo = new BwGeo(g.getLatitude(),\n                                        g.getLongitude());\n            if (chg.changed(pi, ev.getGeo(), geo)) {\n              ev.setGeo(geo);\n            }\n            break;\n          case LAST_MODIFIED:\n            \/* ------------------- LastModified -------------------- *\/\n            if (chg.changed(pi, ev.getLastmod(), pval)) {\n              ev.setLastmod(pval);\n            }\n            break;\n          case LOCATION:\n            \/* ------------------- Location -------------------- *\/\n            BwLocation loc = null;\n            \/\/String uid = getUidPar(prop);\n            \/* At the moment Mozilla lightning is broken and this leads to all\n           * sorts of problems.\n            if (uid != null) {\n              loc = cb.getLocation(uid);\n            }\n           *\/\n            lang = IcalUtil.getLang(prop);\n            BwString addr = null;\n            if (pval != null) {\n              if (loc == null) {\n                addr = new BwString(lang, pval);\n                final var fcResp = cb.findLocation(addr);\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isOk()) {\n                  loc = fcResp.getEntity();\n                }\n              }\n              if (loc == null) {\n                loc = BwLocation.makeLocation();\n                loc.setAddress(addr);\n                cb.addLocation(loc);\n              }\n            }\n            final BwLocation evloc = ev.getLocation();\n            if (chg.changed(pi, evloc, loc)) {\n              \/\/ CHGTBL - this only shows that it's a different location object\n              ev.setLocation(loc);\n            } else if ((loc != null) && (evloc != null)) {\n              \/\/ See if the value is changed\n              final String evval = evloc.getAddress().getValue();\n              final String inval = loc.getAddress().getValue();\n              if (!evval.equals(inval)) {\n                chg.changed(pi, evval, inval);\n                evloc.getAddress().setValue(inval);\n              }\n            }\n            break;\n          case ORGANIZER:\n            \/* ------------------- Organizer -------------------- *\/\n            final BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\n            final BwOrganizer evorg = ev.getOrganizer();\n            final BwOrganizer evorgCopy;\n            if (evorg == null) {\n              evorgCopy = null;\n            } else {\n              evorgCopy = (BwOrganizer)evorg.clone();\n            }\n            if (chg.changed(pi, evorgCopy, org)) {\n              if (evorg == null) {\n                ev.setOrganizer(org);\n              } else {\n                evorg.update(org);\n              }\n            }\n            break;\n          case PERCENT_COMPLETE:\n            \/* ------------------- PercentComplete -------------------- *\/\n            Integer ival = ((PercentComplete)prop).getPercentage();\n            if (chg.changed(pi, ev.getPercentComplete(), ival)) {\n              ev.setPercentComplete(ival);\n            }\n            break;\n          case POLL_MODE:\n            \/* ------------------- Poll mode -------------------- *\/\n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollMode(), sval)) {\n              ev.setPollMode(sval);\n            }\n            break;\n          case POLL_PROPERTIES:\n            \/* ------------------- Poll properties ---------------- *\/\n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollProperties(), sval)) {\n              ev.setPollProperties(sval);\n            }\n            break;\n          case POLL_WINNER:\n            \/* ------------------- Poll winner -------------------- *\/\n            ival = ((PollWinner)prop).getPollwinner();\n            if (chg.changed(pi, ev.getPollWinner(), ival)) {\n              ev.setPollWinner(ival);\n            }\n            break;\n          case PRIORITY:\n            \/* ------------------- Priority -------------------- *\/\n            ival = ((Priority)prop).getLevel();\n            if (chg.changed(pi, ev.getPriority(), ival)) {\n              ev.setPriority(ival);\n            }\n            break;\n          case RDATE:\n            \/* ------------------- RDate -------------------- *\/\n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case RECURRENCE_ID:\n            \/* ------------------- RecurrenceID -------------------- *\/\n            \/\/ Done above\n            break;\n          case RELATED_TO:\n            \/* ------------------- RelatedTo -------------------- *\/\n            final RelatedTo irelto = (RelatedTo)prop;\n            final BwRelatedTo relto = new BwRelatedTo();\n            final String parval = IcalUtil.getParameterVal(irelto,\n                                                           \"RELTYPE\");\n            if (parval != null) {\n              relto.setRelType(parval);\n            }\n            relto.setValue(irelto.getValue());\n            if (chg.changed(pi, ev.getRelatedTo(), relto)) {\n              ev.setRelatedTo(relto);\n            }\n            break;\n          case REQUEST_STATUS:\n            \/* ------------------- RequestStatus -------------------- *\/\n            final BwRequestStatus rs = BwRequestStatus\n                    .fromRequestStatus((RequestStatus)prop);\n            chg.addValue(pi, rs);\n            break;\n          case RESOURCES:\n            \/* ------------------- Resources -------------------- *\/\n            final TextList rl = ((Resources)prop).getResources();\n            if (rl != null) {\n              \/* Got some resources *\/\n              lang = IcalUtil.getLang(prop);\n              for (final String s: rl) {\n                final BwString rsrc = new BwString(lang,\n                                                   s);\n                chg.addValue(pi, rsrc);\n              }\n            }\n            break;\n          case RRULE:\n            \/* ------------------- RRule -------------------- *\/\n            chg.addValue(pi, pval);\n            break;\n          case SEQUENCE:\n            \/* ------------------- Sequence -------------------- *\/\n            final int seq = ((Sequence)prop).getSequenceNo();\n            if (seq != ev.getSequence()) {\n              chg.changed(pi, ev.getSequence(), seq);\n              ev.setSequence(seq);\n            }\n            break;\n          case STATUS:\n            \/* ------------------- Status -------------------- *\/\n            if (chg.changed(pi, ev.getStatus(), pval)) {\n              ev.setStatus(pval);\n            }\n            break;\n          case SUMMARY:\n            \/* ------------------- Summary -------------------- *\/\n            if (chg.changed(pi, ev.getSummary(), pval)) {\n              ev.setSummary(pval);\n            }\n            break;\n          case TRANSP:\n            \/* ------------------- Transp -------------------- *\/\n            if (chg.changed(pi,\n                            ev.getPeruserTransparency(\n                                    cb.getPrincipal()\n                                            .getPrincipalRef()),\n                            pval)) {\n              final BwXproperty pu = ev.setPeruserTransparency(\n                      cb.getPrincipal().getPrincipalRef(),\n                      pval);\n              if (pu != null) {\n                chg.addValue(PropertyInfoIndex.XPROP, pu);\n              }\n            }\n            break;\n          case UID:\n            \/* ------------------- Uid -------------------- *\/\n            \/* We did this above *\/\n            break;\n          case URL:\n            \/* ------------------- Url -------------------- *\/\n            if (chg.changed(pi, ev.getLink(), pval)) {\n              ev.setLink(pval);\n            }\n            break;\n          case XPROP:\n            \/* ------------------------- x-property --------------------------- *\/\n            final String name = prop.getName();\n            if (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\n              if (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\n                              pval)) {\n                ev.setCost(pval);\n              }\n              break;\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\n              if (checkCategory(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\n              if (checkLocation(cb, chg, ev, prop)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\n              if (checkContact(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            \/* See if this is an x-category that can be\n               converted to a real category\n              *\/\n            final XProperty xp = (XProperty)prop;\n            chg.addValue(PropertyInfoIndex.XPROP,\n                         new BwXproperty(name,\n                                         xp.getParameters()\n                                                 .toString(),\n                                         pval));\n            break;\n          default:\n            if (logger.debug()) {\n              logger.debug(\"Unsupported property with index \" + pi +\n                                    \"; class \" + prop.getClass() +\n                                    \" and value \" + pval);\n            }\n        }\n      }\n      \/* =================== Process sub-components =============== *\/\n      final ComponentList<Component> subComps;\n      if (val instanceof ComponentContainer) {\n        subComps = ((ComponentContainer<Component>)val).getComponents();\n      } else {\n        subComps = null;\n      }\n      final Set<Integer> pids;\n      if (vpoll) {\n        pids = new TreeSet<>();\n        final BwEvent vp = evinfo.getEvent();\n        if (!Util.isEmpty(vp.getPollItems())) {\n          vp.clearPollItems();\n        }\n      } else {\n        pids = null;\n      }\n      if (!Util.isEmpty(subComps)) {\n        for (final var subComp: subComps) {\n          if (subComp instanceof Available) {\n            if (!(val instanceof VAvailability)) {\n              return Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n            }\n            final var avlResp = processAvailable(cb, cal,\n                                                 ical,\n                                                 (VAvailability)val,\n                                                 (Available)subComp,\n                                                 evinfo);\n            if (!avlResp.isOk()) {\n              return Response.fromResponse(resp, avlResp);\n            }\n            continue;\n          }\n          if (subComp instanceof Participant) {\n            if (vpoll) {\n              final var vresp = processVoter(cb,\n                                             (VPoll)val,\n                                             (Participant)subComp,\n                                             evinfo,\n                                             chg,\n                                             mergeAttendees);\n              if (!vresp.isOk()) {\n                return Response.fromResponse(resp, vresp);\n              }\n              continue;\n            }\n            logger.warn(\"Unimplemented Participant object\");\n            continue;\n          }\n          if (subComp instanceof VResource) {\n            logger.warn(\"Unimplemented VResource object\");\n            continue;\n          }\n          if (subComp instanceof VLocation) {\n            logger.warn(\"Unimplemented VLocation object\");\n            continue;\n          }\n          if (subComp instanceof VAlarm) {\n            final var aresp = VAlarmUtil.processAlarm(cb,\n                                                      val,\n                                                      (VAlarm)subComp,\n                                                      ev,\n                                                      currentPrincipal,\n                                                      chg);\n            if (!aresp.isOk()) {\n              return Response.fromResponse(resp, aresp);\n            }\n            continue;\n          }\n          if (vpoll && (event || task)) {\n            final var vresp = processCandidate((VPoll)val,\n                                               subComp,\n                                               evinfo,\n                                               pids,\n                                               chg);\n            if (!vresp.isOk()) {\n              return Response.fromResponse(resp, vresp);\n            }\n            continue;\n          }\n          logger.warn(\"Unimplemented Component object: \" + subComp);\n        }\n      }\n      \/* Fix up timestamps. *\/\n      if (ev.getCreated() == null) {\n        if (ev.getLastmod() != null) {\n          ev.setCreated(ev.getLastmod());\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n        } else {\n          ev.updateDtstamp();\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n          chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n        }\n      }\n      if (ev.getLastmod() == null) {\n        \/\/ created cannot be null now\n        ev.setLastmod(ev.getCreated());\n        chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n      }\n      processTimezones(ev, ical, chg);\n      \/* Remove any recipients and originator\n       *\/\n      if (ev.getRecipients() != null) {\n        ev.getRecipients().clear();\n      }\n      ev.setOriginator(null);\n      if (hasXparams.value) {\n        \/* Save a text copy of the entire event as an x-property *\/\n        final Component valCopy = val.copy();\n        \/* Remove potentially large values *\/\n        final Description desp = valCopy.getProperty(Property.DESCRIPTION);\n        if (desp != null) {\n          desp.setValue(null);\n        }\n        final Attach attachp = valCopy.getProperty(Property.ATTACH);\n        \/\/ Don't store the entire attachment - we just need the parameters.\n        if (attachp != null) {\n          final Value v = attachp.getParameter(Parameter.VALUE);\n          if (v != null) {\n            attachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n          }\n        }\n        chg.addValue(PropertyInfoIndex.XPROP,\n                     new BwXproperty(BwXproperty.bedeworkIcal,\n                                     null,\n                                     valCopy.toString()));\n      }\n      chg.processChanges(ev, true, false);\n      ev.setRecurring(ev.isRecurringEntity());\n      if (logger.debug()) {\n        logger.debug(chg.toString());\n        logger.debug(ev.toString());\n      }\n      if (masterEI != null) {\n        \/\/ Just return notfound as this event is on its override list\n        return Response.notFound(resp);\n      }\n      resp.setEntity(evinfo);\n      return resp;\n    } catch (final Throwable t) {\n      if (logger.debug()) {\n        logger.error(t);\n      }\n      return Response.error(resp, t);\n    }\n  }","code_wo_comment":"public static GetEntityResponse<EventInfo> toEvent(\n          final IcalCallback cb,\n          final BwCalendar cal,\n          final Icalendar ical,\n          final Component val,\n          final boolean mergeAttendees) {\n    final var resp = new GetEntityResponse<EventInfo>();\n    if (val == null) {\n      return Response.notOk(resp, failed, \"No component supplied\");\n    }\n    String currentPrincipal = null;\n    final BwPrincipal principal = cb.getPrincipal();\n    if (principal != null) {\n      currentPrincipal = principal.getPrincipalRef();\n    }\n    final Holder<Boolean> hasXparams = new Holder<>(Boolean.FALSE);\n    final int methodType = ical.getMethodType();\n    String attUri = null;\n    if (mergeAttendees) {\n     \n      attUri = cb.getCaladdr(cb.getPrincipal().getPrincipalRef());\n    }\n    final String colPath;\n    if (cal == null) {\n      colPath = null;\n    } else {\n      colPath = cal.getPath();\n    }\n    try {\n      final PropertyList<Property> pl = val.getProperties();\n      boolean vpoll = false;\n      boolean event = false;\n      boolean task = false;\n      if (pl == null) {\n       \n        return Response.notOk(resp, failed, \"Empty component\");\n      }\n      final int entityType;\n      if (val instanceof VEvent) {\n        entityType = IcalDefs.entityTypeEvent;\n        event = true;\n      } else if (val instanceof VToDo) {\n        entityType = IcalDefs.entityTypeTodo;\n        task = true;\n      } else if (val instanceof VJournal) {\n        entityType = IcalDefs.entityTypeJournal;\n      } else if (val instanceof VFreeBusy) {\n        entityType = IcalDefs.entityTypeFreeAndBusy;\n      } else if (val instanceof VAvailability) {\n        entityType = IcalDefs.entityTypeVavailability;\n      } else if (val instanceof Available) {\n        entityType = IcalDefs.entityTypeAvailable;\n      } else if (val instanceof VPoll) {\n        entityType = IcalDefs.entityTypeVpoll;\n        vpoll = true;\n      } else {\n        return Response.error(resp, \"org.bedework.invalid.component.type: \" +\n                val.getName());\n      }\n     \n      String guid = null;\n      final Uid uidp = pl.getProperty(Property.UID);\n      if (uidp != null) {\n        testXparams(uidp, hasXparams);\n        guid = uidp.getValue();\n      }\n      if (guid == null) {\n       \n        return Response.notOk(resp, failed, CalFacadeException.noGuid);\n      }\n     \n      BwDateTime ridObj = null;\n      String rid = null;\n      TimeZone ridTz = null;\n      final RecurrenceId ridp = pl.getProperty(Property.RECURRENCE_ID);\n      if (ridp != null) {\n        testXparams(ridp, hasXparams);\n        ridObj = BwDateTime.makeBwDateTime(ridp);\n        if (ridObj.getRange() != null) {\n         \n          logger.warn(\"TRANS-TO_EVENT: Got a recurrence id range\");\n        }\n        rid = ridObj.getDate();\n      }\n      EventInfo masterEI = null;\n      EventInfo evinfo = null;\n      final BwEvent ev;\n     \n     \n      final DtStart dtStart = pl.getProperty(Property.DTSTART);\n     \n     \n      if (rid != null) {\n       \n        masterEI = findMaster(guid, ical.getComponents());\n        if (masterEI != null) {\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n        }\n      }\n      if ((evinfo == null) &&\n          (cal != null) &&\n          (cal.getCalType() != BwCalendar.calTypeInbox) &&\n          (cal.getCalType() != BwCalendar.calTypePendingInbox) &&\n          (cal.getCalType() != BwCalendar.calTypeOutbox)) {\n        if (logger.debug()) {\n          logger.debug(\"TRANS-TO_EVENT: try to fetch event with guid=\" + guid);\n        }\n        final GetEntitiesResponse<EventInfo> eisResp =\n                cb.getEvent(colPath, guid);\n        if (eisResp.isError()) {\n          return Response.fromResponse(resp, eisResp);\n        }\n        final var eis = eisResp.getEntities();\n        if (!Util.isEmpty(eis)) {\n          if (eis.size() > 1) {\n           \n            return Response.notOk(resp, failed,\n                                  \"More than one event returned for guid.\");\n          }\n          evinfo = eis.iterator().next();\n        }\n        if (logger.debug()) {\n          if (evinfo != null) {\n            logger.debug(\"TRANS-TO_EVENT: fetched event with guid\");\n          } else {\n            logger.debug(\"TRANS-TO_EVENT: did not find event with guid\");\n          }\n        }\n        if (evinfo != null) {\n          if (rid != null) {\n           \n            masterEI = evinfo;\n            masterEI.setInstanceOnly(true);\n            evinfo = masterEI.findOverride(rid);\n            evinfo.recurrenceSeen = true;\n            ical.addComponent(masterEI);\n          } else if (methodType == ScheduleMethods.methodTypeCancel) {\n           \n            evinfo.setInstanceOnly(evinfo.getEvent().getSuppressed());\n          } else {\n           \n            evinfo.getEvent().setSuppressed(false);\n          }\n        } else if (rid != null) {\n         \n          masterEI = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n          final BwEvent e = masterEI.getEvent();\n         \n          final DtStart mdtStart;\n          final String bogusDate = \"19980118\";\n          final String bogusTime = \"T230000\";\n         \n          final boolean isDateType = ridObj.getDateType();\n          if (isDateType) {\n            mdtStart = new DtStart(new Date(bogusDate));\n          } else if (dtStart.isUtc()) {\n            mdtStart = new DtStart(bogusDate + bogusTime + \"Z\");\n          } else if (ridObj.getTzid() == null) {\n            mdtStart = new DtStart(bogusDate + bogusTime);\n          } else {\n            mdtStart = new DtStart(bogusDate + bogusTime,\n                                   Timezones.getTz(ridObj.getTzid()));\n          }\n          IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                            masterEI, mdtStart, null, null);\n          e.setRecurring(true);\n          final var sum = (Summary)pl.getProperty(Property.SUMMARY);\n          e.setSummary(sum.getValue());\n          e.setSuppressed(true);\n          ical.addComponent(masterEI);\n          evinfo = masterEI.findOverride(rid);\n          evinfo.recurrenceSeen = true;\n          masterEI.setInstanceOnly(rid != null);\n        }\n      }\n      if (evinfo == null) {\n        evinfo = CnvUtil.makeNewEvent(cb, entityType, guid, colPath);\n      } else if (evinfo.getEvent().getEntityType() != entityType) {\n        return Response.notOk(resp, failed,\n                              \"org.bedework.mismatched.entity.type: \" +\n                                      val);\n      }\n      final ChangeTable chg = evinfo.getChangeset(\n              cb.getPrincipal().getPrincipalRef());\n      if (rid != null) {\n        final String evrid = evinfo.getEvent().getRecurrenceId();\n        if ((evrid == null) || (!evrid.equals(rid))) {\n          logger. warn(\"Mismatched rid ev=\" + evrid + \" expected \" + rid);\n          chg.changed(PropertyInfoIndex.RECURRENCE_ID, evrid, rid);\n        }\n        if (masterEI.getEvent().getSuppressed()) {\n          masterEI.getEvent().addRdate(ridObj);\n        }\n      }\n      ev = evinfo.getEvent();\n      ev.setScheduleMethod(methodType);\n      DtEnd dtEnd = null;\n      if (entityType == IcalDefs.entityTypeTodo) {\n        final Due due = pl.getProperty(Property.DUE);\n        if (due != null ) {\n          dtEnd = new DtEnd(due.getParameters(), due.getValue());\n        }\n      } else {\n        dtEnd = pl.getProperty(Property.DTEND);\n      }\n      final Duration duration = pl.getProperty(Property.DURATION);\n      IcalUtil.setDates(cb.getPrincipal().getPrincipalRef(),\n                        evinfo, dtStart, dtEnd, duration);\n      for (final Property prop: pl) {\n        testXparams(prop, hasXparams);\n       \n        String pval = prop.getValue();\n        if ((pval != null) && (pval.length() == 0)) {\n          pval = null;\n        }\n        final PropertyInfoIndex pi;\n        if (prop instanceof XProperty) {\n          pi = PropertyInfoIndex.XPROP;\n        } else {\n          pi = PropertyInfoIndex.fromName(prop.getName());\n        }\n        if (pi == null) {\n          logger.debug(\"Unknown property with name \" + prop.getName() +\n                                \" class \" + prop.getClass() +\n                                \" and value \" + pval);\n          continue;\n        }\n        chg.present(pi);\n        switch (pi) {\n          case ACCEPT_RESPONSE:\n           \n            String sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollAcceptResponse(), sval)) {\n              ev.setPollAcceptResponse(sval);\n            }\n            break;\n          case ATTACH:\n           \n            chg.addValue(pi, IcalUtil.getAttachment((Attach)prop));\n            break;\n          case ATTENDEE:\n           \n            if (methodType == ScheduleMethods.methodTypePublish) {\n              if (cb.getStrictness() == IcalCallback.conformanceStrict) {\n                return Response.notOk(resp, failed,\n                                      CalFacadeException.attendeesInPublish);\n              }\n             \n             \n             \n            }\n            final Attendee attPr = (Attendee)prop;\n            if (evinfo.getNewEvent() || !mergeAttendees) {\n              chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n            } else {\n              final String pUri = cb.getCaladdr(attPr.getValue());\n              if (pUri.equals(attUri)) {\n               \n                chg.addValue(pi, IcalUtil.getAttendee(cb, attPr));\n              } else {\n               \n                boolean found = false;\n                for (final BwAttendee att: ev.getAttendees()) {\n                  if (pUri.equals(att.getAttendeeUri())) {\n                    chg.addValue(pi, att.clone());\n                    found = true;\n                    break;\n                  }\n                }\n                if (!found) {\n                 \n                  final BwAttendee att = IcalUtil\n                          .getAttendee(cb, attPr);\n                  att.setPartstat(IcalDefs.partstatValNeedsAction);\n                  chg.addValue(pi, att);\n                }\n              }\n            }\n            break;\n          case BUSYTYPE:\n            final int ibt = BwEvent.fromBusyTypeString(pval);\n            if (chg.changed(pi,\n                            ev.getBusyType(),\n                            ibt)) {\n              ev.setBusyType(ibt);\n            }\n            break;\n          case CATEGORIES:\n           \n            final Categories cats = (Categories)prop;\n            final TextList cl = cats.getCategories();\n            String lang = IcalUtil.getLang(cats);\n            if (cl != null) {\n             \n              for (final String wd: cl) {\n                if (wd == null) {\n                  continue;\n                }\n                final BwString key = new BwString(lang, wd);\n                final var fcResp = cb.findCategory(key);\n                final BwCategory cat;\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isNotFound()) {\n                  cat = BwCategory.makeCategory();\n                  cat.setWord(key);\n                  cb.addCategory(cat);\n                } else {\n                  cat = fcResp.getEntity();\n                }\n                chg.addValue(pi, cat);\n              }\n            }\n            break;\n          case CLASS:\n           \n            if (chg.changed(pi, ev.getClassification(), pval)) {\n              ev.setClassification(pval);\n            }\n            break;\n          case COMMENT:\n           \n            chg.addValue(pi,\n                         new BwString(null, pval));\n            break;\n          case COMPLETED:\n           \n            if (chg.changed(pi, ev.getCompleted(), pval)) {\n              ev.setCompleted(pval);\n            }\n            break;\n          case CONCEPT:\n           \n            final Concept c = (Concept)prop;\n            final String cval = c.getValue();\n            if (cval != null) {\n             \n              chg.addValue(PropertyInfoIndex.XPROP,\n                           BwXproperty.makeIcalProperty(\"CONCEPT\",\n                                                        null,\n                                                        cval));\n            }\n            break;\n          case CONTACT:\n           \n            final String altrep = getAltRepPar(prop);\n            lang = IcalUtil.getLang(prop);\n            final String uid = getUidPar(prop);\n            final BwString nm = new BwString(lang, pval);\n            BwContact contact = null;\n            if (uid != null) {\n              final var fcResp = cb.getContact(uid);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              final var fcResp = cb.findContact(nm);\n              if (fcResp.isError()) {\n                return Response.fromResponse(resp, fcResp);\n              }\n              if (fcResp.isOk()) {\n                contact = fcResp.getEntity();\n              }\n            }\n            if (contact == null) {\n              contact = BwContact.makeContact();\n              contact.setCn(nm);\n              contact.setLink(altrep);\n              cb.addContact(contact);\n            } else {\n              contact.setCn(nm);\n              contact.setLink(altrep);\n            }\n            chg.addValue(pi, contact);\n            break;\n          case CREATED:\n           \n            if (chg.changed(pi, ev.getCreated(), pval)) {\n              ev.setCreated(pval);\n            }\n            break;\n          case DESCRIPTION:\n           \n            if (chg.changed(pi, ev.getDescription(), pval)) {\n              ev.setDescription(pval);\n            }\n            break;\n          case DTEND:\n           \n            break;\n          case DTSTAMP:\n           \n            ev.setDtstamp(pval);\n            break;\n          case DTSTART:\n           \n            break;\n          case DUE:\n           \n            break;\n          case DURATION:\n           \n            break;\n          case EXDATE:\n           \n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case EXRULE:\n           \n            chg.addValue(pi, pval);\n            break;\n          case FREEBUSY:\n           \n            final FreeBusy fbusy = (FreeBusy)prop;\n            final PeriodList perpl = fbusy.getPeriods();\n            final Parameter par = IcalUtil.getParameter(fbusy, \"FBTYPE\");\n            final int fbtype;\n            if (par == null) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY)) {\n              fbtype = BwFreeBusyComponent.typeBusy;\n            } else if (par.equals(FbType.BUSY_TENTATIVE)) {\n              fbtype = BwFreeBusyComponent.typeBusyTentative;\n            } else if (par.equals(FbType.BUSY_UNAVAILABLE)) {\n              fbtype = BwFreeBusyComponent.typeBusyUnavailable;\n            } else if (par.equals(FbType.FREE)) {\n              fbtype = BwFreeBusyComponent.typeFree;\n            } else {\n              if (logger.debug()) {\n                logger.debug(\"Unsupported parameter \" + par.getName());\n              }\n              return Response.notOk(resp, failed,\n                                    \"Unsupported parameter \" +\n                                            par.getName());\n            }\n            final BwFreeBusyComponent fbc = new BwFreeBusyComponent();\n            fbc.setType(fbtype);\n            for (final Period per : perpl) {\n              fbc.addPeriod(per);\n            }\n            ev.addFreeBusyPeriod(fbc);\n            break;\n          case GEO:\n           \n            final Geo g = (Geo)prop;\n            final BwGeo geo = new BwGeo(g.getLatitude(),\n                                        g.getLongitude());\n            if (chg.changed(pi, ev.getGeo(), geo)) {\n              ev.setGeo(geo);\n            }\n            break;\n          case LAST_MODIFIED:\n           \n            if (chg.changed(pi, ev.getLastmod(), pval)) {\n              ev.setLastmod(pval);\n            }\n            break;\n          case LOCATION:\n           \n            BwLocation loc = null;\n           \n           \n            lang = IcalUtil.getLang(prop);\n            BwString addr = null;\n            if (pval != null) {\n              if (loc == null) {\n                addr = new BwString(lang, pval);\n                final var fcResp = cb.findLocation(addr);\n                if (fcResp.isError()) {\n                  return Response.fromResponse(resp, fcResp);\n                }\n                if (fcResp.isOk()) {\n                  loc = fcResp.getEntity();\n                }\n              }\n              if (loc == null) {\n                loc = BwLocation.makeLocation();\n                loc.setAddress(addr);\n                cb.addLocation(loc);\n              }\n            }\n            final BwLocation evloc = ev.getLocation();\n            if (chg.changed(pi, evloc, loc)) {\n             \n              ev.setLocation(loc);\n            } else if ((loc != null) && (evloc != null)) {\n             \n              final String evval = evloc.getAddress().getValue();\n              final String inval = loc.getAddress().getValue();\n              if (!evval.equals(inval)) {\n                chg.changed(pi, evval, inval);\n                evloc.getAddress().setValue(inval);\n              }\n            }\n            break;\n          case ORGANIZER:\n           \n            final BwOrganizer org = IcalUtil.getOrganizer(cb, (Organizer)prop);\n            final BwOrganizer evorg = ev.getOrganizer();\n            final BwOrganizer evorgCopy;\n            if (evorg == null) {\n              evorgCopy = null;\n            } else {\n              evorgCopy = (BwOrganizer)evorg.clone();\n            }\n            if (chg.changed(pi, evorgCopy, org)) {\n              if (evorg == null) {\n                ev.setOrganizer(org);\n              } else {\n                evorg.update(org);\n              }\n            }\n            break;\n          case PERCENT_COMPLETE:\n           \n            Integer ival = ((PercentComplete)prop).getPercentage();\n            if (chg.changed(pi, ev.getPercentComplete(), ival)) {\n              ev.setPercentComplete(ival);\n            }\n            break;\n          case POLL_MODE:\n           \n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollMode(), sval)) {\n              ev.setPollMode(sval);\n            }\n            break;\n          case POLL_PROPERTIES:\n           \n            sval = prop.getValue();\n            if (chg.changed(pi, ev.getPollProperties(), sval)) {\n              ev.setPollProperties(sval);\n            }\n            break;\n          case POLL_WINNER:\n           \n            ival = ((PollWinner)prop).getPollwinner();\n            if (chg.changed(pi, ev.getPollWinner(), ival)) {\n              ev.setPollWinner(ival);\n            }\n            break;\n          case PRIORITY:\n           \n            ival = ((Priority)prop).getLevel();\n            if (chg.changed(pi, ev.getPriority(), ival)) {\n              ev.setPriority(ival);\n            }\n            break;\n          case RDATE:\n           \n            chg.addValues(pi,\n                          IcalUtil.makeDateTimes((DateListProperty)prop));\n            break;\n          case RECURRENCE_ID:\n           \n           \n            break;\n          case RELATED_TO:\n           \n            final RelatedTo irelto = (RelatedTo)prop;\n            final BwRelatedTo relto = new BwRelatedTo();\n            final String parval = IcalUtil.getParameterVal(irelto,\n                                                           \"RELTYPE\");\n            if (parval != null) {\n              relto.setRelType(parval);\n            }\n            relto.setValue(irelto.getValue());\n            if (chg.changed(pi, ev.getRelatedTo(), relto)) {\n              ev.setRelatedTo(relto);\n            }\n            break;\n          case REQUEST_STATUS:\n           \n            final BwRequestStatus rs = BwRequestStatus\n                    .fromRequestStatus((RequestStatus)prop);\n            chg.addValue(pi, rs);\n            break;\n          case RESOURCES:\n           \n            final TextList rl = ((Resources)prop).getResources();\n            if (rl != null) {\n             \n              lang = IcalUtil.getLang(prop);\n              for (final String s: rl) {\n                final BwString rsrc = new BwString(lang,\n                                                   s);\n                chg.addValue(pi, rsrc);\n              }\n            }\n            break;\n          case RRULE:\n           \n            chg.addValue(pi, pval);\n            break;\n          case SEQUENCE:\n           \n            final int seq = ((Sequence)prop).getSequenceNo();\n            if (seq != ev.getSequence()) {\n              chg.changed(pi, ev.getSequence(), seq);\n              ev.setSequence(seq);\n            }\n            break;\n          case STATUS:\n           \n            if (chg.changed(pi, ev.getStatus(), pval)) {\n              ev.setStatus(pval);\n            }\n            break;\n          case SUMMARY:\n           \n            if (chg.changed(pi, ev.getSummary(), pval)) {\n              ev.setSummary(pval);\n            }\n            break;\n          case TRANSP:\n           \n            if (chg.changed(pi,\n                            ev.getPeruserTransparency(\n                                    cb.getPrincipal()\n                                            .getPrincipalRef()),\n                            pval)) {\n              final BwXproperty pu = ev.setPeruserTransparency(\n                      cb.getPrincipal().getPrincipalRef(),\n                      pval);\n              if (pu != null) {\n                chg.addValue(PropertyInfoIndex.XPROP, pu);\n              }\n            }\n            break;\n          case UID:\n           \n           \n            break;\n          case URL:\n           \n            if (chg.changed(pi, ev.getLink(), pval)) {\n              ev.setLink(pval);\n            }\n            break;\n          case XPROP:\n           \n            final String name = prop.getName();\n            if (name.equalsIgnoreCase(BwXproperty.bedeworkCost)) {\n              if (chg.changed(PropertyInfoIndex.COST, ev.getCost(),\n                              pval)) {\n                ev.setCost(pval);\n              }\n              break;\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkCategories)) {\n              if (checkCategory(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkLocation)) {\n              if (checkLocation(cb, chg, ev, prop)) {\n                break;\n              }\n            }\n            if (name.equalsIgnoreCase(BwXproperty.xBedeworkContact)) {\n              if (checkContact(cb, chg, ev, null, pval)) {\n                break;\n              }\n            }\n           \n            final XProperty xp = (XProperty)prop;\n            chg.addValue(PropertyInfoIndex.XPROP,\n                         new BwXproperty(name,\n                                         xp.getParameters()\n                                                 .toString(),\n                                         pval));\n            break;\n          default:\n            if (logger.debug()) {\n              logger.debug(\"Unsupported property with index \" + pi +\n                                    \"; class \" + prop.getClass() +\n                                    \" and value \" + pval);\n            }\n        }\n      }\n     \n      final ComponentList<Component> subComps;\n      if (val instanceof ComponentContainer) {\n        subComps = ((ComponentContainer<Component>)val).getComponents();\n      } else {\n        subComps = null;\n      }\n      final Set<Integer> pids;\n      if (vpoll) {\n        pids = new TreeSet<>();\n        final BwEvent vp = evinfo.getEvent();\n        if (!Util.isEmpty(vp.getPollItems())) {\n          vp.clearPollItems();\n        }\n      } else {\n        pids = null;\n      }\n      if (!Util.isEmpty(subComps)) {\n        for (final var subComp: subComps) {\n          if (subComp instanceof Available) {\n            if (!(val instanceof VAvailability)) {\n              return Response.error(resp, \"AVAILABLE only valid in VAVAILABLE\");\n            }\n            final var avlResp = processAvailable(cb, cal,\n                                                 ical,\n                                                 (VAvailability)val,\n                                                 (Available)subComp,\n                                                 evinfo);\n            if (!avlResp.isOk()) {\n              return Response.fromResponse(resp, avlResp);\n            }\n            continue;\n          }\n          if (subComp instanceof Participant) {\n            if (vpoll) {\n              final var vresp = processVoter(cb,\n                                             (VPoll)val,\n                                             (Participant)subComp,\n                                             evinfo,\n                                             chg,\n                                             mergeAttendees);\n              if (!vresp.isOk()) {\n                return Response.fromResponse(resp, vresp);\n              }\n              continue;\n            }\n            logger.warn(\"Unimplemented Participant object\");\n            continue;\n          }\n          if (subComp instanceof VResource) {\n            logger.warn(\"Unimplemented VResource object\");\n            continue;\n          }\n          if (subComp instanceof VLocation) {\n            logger.warn(\"Unimplemented VLocation object\");\n            continue;\n          }\n          if (subComp instanceof VAlarm) {\n            final var aresp = VAlarmUtil.processAlarm(cb,\n                                                      val,\n                                                      (VAlarm)subComp,\n                                                      ev,\n                                                      currentPrincipal,\n                                                      chg);\n            if (!aresp.isOk()) {\n              return Response.fromResponse(resp, aresp);\n            }\n            continue;\n          }\n          if (vpoll && (event || task)) {\n            final var vresp = processCandidate((VPoll)val,\n                                               subComp,\n                                               evinfo,\n                                               pids,\n                                               chg);\n            if (!vresp.isOk()) {\n              return Response.fromResponse(resp, vresp);\n            }\n            continue;\n          }\n          logger.warn(\"Unimplemented Component object: \" + subComp);\n        }\n      }\n     \n      if (ev.getCreated() == null) {\n        if (ev.getLastmod() != null) {\n          ev.setCreated(ev.getLastmod());\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n        } else {\n          ev.updateDtstamp();\n          chg.changed(PropertyInfoIndex.CREATED, null, ev.getCreated());\n          chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n        }\n      }\n      if (ev.getLastmod() == null) {\n       \n        ev.setLastmod(ev.getCreated());\n        chg.changed(PropertyInfoIndex.LAST_MODIFIED, null, ev.getLastmod());\n      }\n      processTimezones(ev, ical, chg);\n     \n      if (ev.getRecipients() != null) {\n        ev.getRecipients().clear();\n      }\n      ev.setOriginator(null);\n      if (hasXparams.value) {\n       \n        final Component valCopy = val.copy();\n       \n        final Description desp = valCopy.getProperty(Property.DESCRIPTION);\n        if (desp != null) {\n          desp.setValue(null);\n        }\n        final Attach attachp = valCopy.getProperty(Property.ATTACH);\n       \n        if (attachp != null) {\n          final Value v = attachp.getParameter(Parameter.VALUE);\n          if (v != null) {\n            attachp.setValue(String.valueOf(attachp.getValue().hashCode()));\n          }\n        }\n        chg.addValue(PropertyInfoIndex.XPROP,\n                     new BwXproperty(BwXproperty.bedeworkIcal,\n                                     null,\n                                     valCopy.toString()));\n      }\n      chg.processChanges(ev, true, false);\n      ev.setRecurring(ev.isRecurringEntity());\n      if (logger.debug()) {\n        logger.debug(chg.toString());\n        logger.debug(ev.toString());\n      }\n      if (masterEI != null) {\n       \n        return Response.notFound(resp);\n      }\n      resp.setEntity(evinfo);\n      return resp;\n    } catch (final Throwable t) {\n      if (logger.debug()) {\n        logger.error(t);\n      }\n      return Response.error(resp, t);\n    }\n  }","cleancode":"public static getentityresponse<eventinfo> toevent( final icalcallback cb, final bwcalendar cal, final icalendar ical, final component val, final boolean mergeattendees) { final var resp = new getentityresponse<eventinfo>(); if (val == null) { return response.notok(resp, failed, \"no component supplied\"); } string currentprincipal = null; final bwprincipal principal = cb.getprincipal(); if (principal != null) { currentprincipal = principal.getprincipalref(); } final holder<boolean> hasxparams = new holder<>(boolean.false); final int methodtype = ical.getmethodtype(); string atturi = null; if (mergeattendees) { atturi = cb.getcaladdr(cb.getprincipal().getprincipalref()); } final string colpath; if (cal == null) { colpath = null; } else { colpath = cal.getpath(); } try { final propertylist<property> pl = val.getproperties(); boolean vpoll = false; boolean event = false; boolean task = false; if (pl == null) { return response.notok(resp, failed, \"empty component\"); } final int entitytype; if (val instanceof vevent) { entitytype = icaldefs.entitytypeevent; event = true; } else if (val instanceof vtodo) { entitytype = icaldefs.entitytypetodo; task = true; } else if (val instanceof vjournal) { entitytype = icaldefs.entitytypejournal; } else if (val instanceof vfreebusy) { entitytype = icaldefs.entitytypefreeandbusy; } else if (val instanceof vavailability) { entitytype = icaldefs.entitytypevavailability; } else if (val instanceof available) { entitytype = icaldefs.entitytypeavailable; } else if (val instanceof vpoll) { entitytype = icaldefs.entitytypevpoll; vpoll = true; } else { return response.error(resp, \"org.bedework.invalid.component.type: \" + val.getname()); } string guid = null; final uid uidp = pl.getproperty(property.uid); if (uidp != null) { testxparams(uidp, hasxparams); guid = uidp.getvalue(); } if (guid == null) { return response.notok(resp, failed, calfacadeexception.noguid); } bwdatetime ridobj = null; string rid = null; timezone ridtz = null; final recurrenceid ridp = pl.getproperty(property.recurrence_id); if (ridp != null) { testxparams(ridp, hasxparams); ridobj = bwdatetime.makebwdatetime(ridp); if (ridobj.getrange() != null) { logger.warn(\"trans-to_event: got a recurrence id range\"); } rid = ridobj.getdate(); } eventinfo masterei = null; eventinfo evinfo = null; final bwevent ev; final dtstart dtstart = pl.getproperty(property.dtstart); if (rid != null) { masterei = findmaster(guid, ical.getcomponents()); if (masterei != null) { evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; } } if ((evinfo == null) && (cal != null) && (cal.getcaltype() != bwcalendar.caltypeinbox) && (cal.getcaltype() != bwcalendar.caltypependinginbox) && (cal.getcaltype() != bwcalendar.caltypeoutbox)) { if (logger.debug()) { logger.debug(\"trans-to_event: try to fetch event with guid=\" + guid); } final getentitiesresponse<eventinfo> eisresp = cb.getevent(colpath, guid); if (eisresp.iserror()) { return response.fromresponse(resp, eisresp); } final var eis = eisresp.getentities(); if (!util.isempty(eis)) { if (eis.size() > 1) { return response.notok(resp, failed, \"more than one event returned for guid.\"); } evinfo = eis.iterator().next(); } if (logger.debug()) { if (evinfo != null) { logger.debug(\"trans-to_event: fetched event with guid\"); } else { logger.debug(\"trans-to_event: did not find event with guid\"); } } if (evinfo != null) { if (rid != null) { masterei = evinfo; masterei.setinstanceonly(true); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; ical.addcomponent(masterei); } else if (methodtype == schedulemethods.methodtypecancel) { evinfo.setinstanceonly(evinfo.getevent().getsuppressed()); } else { evinfo.getevent().setsuppressed(false); } } else if (rid != null) { masterei = cnvutil.makenewevent(cb, entitytype, guid, colpath); final bwevent e = masterei.getevent(); final dtstart mdtstart; final string bogusdate = \"19980118\"; final string bogustime = \"t230000\"; final boolean isdatetype = ridobj.getdatetype(); if (isdatetype) { mdtstart = new dtstart(new date(bogusdate)); } else if (dtstart.isutc()) { mdtstart = new dtstart(bogusdate + bogustime + \"z\"); } else if (ridobj.gettzid() == null) { mdtstart = new dtstart(bogusdate + bogustime); } else { mdtstart = new dtstart(bogusdate + bogustime, timezones.gettz(ridobj.gettzid())); } icalutil.setdates(cb.getprincipal().getprincipalref(), masterei, mdtstart, null, null); e.setrecurring(true); final var sum = (summary)pl.getproperty(property.summary); e.setsummary(sum.getvalue()); e.setsuppressed(true); ical.addcomponent(masterei); evinfo = masterei.findoverride(rid); evinfo.recurrenceseen = true; masterei.setinstanceonly(rid != null); } } if (evinfo == null) { evinfo = cnvutil.makenewevent(cb, entitytype, guid, colpath); } else if (evinfo.getevent().getentitytype() != entitytype) { return response.notok(resp, failed, \"org.bedework.mismatched.entity.type: \" + val); } final changetable chg = evinfo.getchangeset( cb.getprincipal().getprincipalref()); if (rid != null) { final string evrid = evinfo.getevent().getrecurrenceid(); if ((evrid == null) || (!evrid.equals(rid))) { logger. warn(\"mismatched rid ev=\" + evrid + \" expected \" + rid); chg.changed(propertyinfoindex.recurrence_id, evrid, rid); } if (masterei.getevent().getsuppressed()) { masterei.getevent().addrdate(ridobj); } } ev = evinfo.getevent(); ev.setschedulemethod(methodtype); dtend dtend = null; if (entitytype == icaldefs.entitytypetodo) { final due due = pl.getproperty(property.due); if (due != null ) { dtend = new dtend(due.getparameters(), due.getvalue()); } } else { dtend = pl.getproperty(property.dtend); } final duration duration = pl.getproperty(property.duration); icalutil.setdates(cb.getprincipal().getprincipalref(), evinfo, dtstart, dtend, duration); for (final property prop: pl) { testxparams(prop, hasxparams); string pval = prop.getvalue(); if ((pval != null) && (pval.length() == 0)) { pval = null; } final propertyinfoindex pi; if (prop instanceof xproperty) { pi = propertyinfoindex.xprop; } else { pi = propertyinfoindex.fromname(prop.getname()); } if (pi == null) { logger.debug(\"unknown property with name \" + prop.getname() + \" class \" + prop.getclass() + \" and value \" + pval); continue; } chg.present(pi); switch (pi) { case accept_response: string sval = prop.getvalue(); if (chg.changed(pi, ev.getpollacceptresponse(), sval)) { ev.setpollacceptresponse(sval); } break; case attach: chg.addvalue(pi, icalutil.getattachment((attach)prop)); break; case attendee: if (methodtype == schedulemethods.methodtypepublish) { if (cb.getstrictness() == icalcallback.conformancestrict) { return response.notok(resp, failed, calfacadeexception.attendeesinpublish); } } final attendee attpr = (attendee)prop; if (evinfo.getnewevent() || !mergeattendees) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { final string puri = cb.getcaladdr(attpr.getvalue()); if (puri.equals(atturi)) { chg.addvalue(pi, icalutil.getattendee(cb, attpr)); } else { boolean found = false; for (final bwattendee att: ev.getattendees()) { if (puri.equals(att.getattendeeuri())) { chg.addvalue(pi, att.clone()); found = true; break; } } if (!found) { final bwattendee att = icalutil .getattendee(cb, attpr); att.setpartstat(icaldefs.partstatvalneedsaction); chg.addvalue(pi, att); } } } break; case busytype: final int ibt = bwevent.frombusytypestring(pval); if (chg.changed(pi, ev.getbusytype(), ibt)) { ev.setbusytype(ibt); } break; case categories: final categories cats = (categories)prop; final textlist cl = cats.getcategories(); string lang = icalutil.getlang(cats); if (cl != null) { for (final string wd: cl) { if (wd == null) { continue; } final bwstring key = new bwstring(lang, wd); final var fcresp = cb.findcategory(key); final bwcategory cat; if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isnotfound()) { cat = bwcategory.makecategory(); cat.setword(key); cb.addcategory(cat); } else { cat = fcresp.getentity(); } chg.addvalue(pi, cat); } } break; case class: if (chg.changed(pi, ev.getclassification(), pval)) { ev.setclassification(pval); } break; case comment: chg.addvalue(pi, new bwstring(null, pval)); break; case completed: if (chg.changed(pi, ev.getcompleted(), pval)) { ev.setcompleted(pval); } break; case concept: final concept c = (concept)prop; final string cval = c.getvalue(); if (cval != null) { chg.addvalue(propertyinfoindex.xprop, bwxproperty.makeicalproperty(\"concept\", null, cval)); } break; case contact: final string altrep = getaltreppar(prop); lang = icalutil.getlang(prop); final string uid = getuidpar(prop); final bwstring nm = new bwstring(lang, pval); bwcontact contact = null; if (uid != null) { final var fcresp = cb.getcontact(uid); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { final var fcresp = cb.findcontact(nm); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { contact = fcresp.getentity(); } } if (contact == null) { contact = bwcontact.makecontact(); contact.setcn(nm); contact.setlink(altrep); cb.addcontact(contact); } else { contact.setcn(nm); contact.setlink(altrep); } chg.addvalue(pi, contact); break; case created: if (chg.changed(pi, ev.getcreated(), pval)) { ev.setcreated(pval); } break; case description: if (chg.changed(pi, ev.getdescription(), pval)) { ev.setdescription(pval); } break; case dtend: break; case dtstamp: ev.setdtstamp(pval); break; case dtstart: break; case due: break; case duration: break; case exdate: chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case exrule: chg.addvalue(pi, pval); break; case freebusy: final freebusy fbusy = (freebusy)prop; final periodlist perpl = fbusy.getperiods(); final parameter par = icalutil.getparameter(fbusy, \"fbtype\"); final int fbtype; if (par == null) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy)) { fbtype = bwfreebusycomponent.typebusy; } else if (par.equals(fbtype.busy_tentative)) { fbtype = bwfreebusycomponent.typebusytentative; } else if (par.equals(fbtype.busy_unavailable)) { fbtype = bwfreebusycomponent.typebusyunavailable; } else if (par.equals(fbtype.free)) { fbtype = bwfreebusycomponent.typefree; } else { if (logger.debug()) { logger.debug(\"unsupported parameter \" + par.getname()); } return response.notok(resp, failed, \"unsupported parameter \" + par.getname()); } final bwfreebusycomponent fbc = new bwfreebusycomponent(); fbc.settype(fbtype); for (final period per : perpl) { fbc.addperiod(per); } ev.addfreebusyperiod(fbc); break; case geo: final geo g = (geo)prop; final bwgeo geo = new bwgeo(g.getlatitude(), g.getlongitude()); if (chg.changed(pi, ev.getgeo(), geo)) { ev.setgeo(geo); } break; case last_modified: if (chg.changed(pi, ev.getlastmod(), pval)) { ev.setlastmod(pval); } break; case location: bwlocation loc = null; lang = icalutil.getlang(prop); bwstring addr = null; if (pval != null) { if (loc == null) { addr = new bwstring(lang, pval); final var fcresp = cb.findlocation(addr); if (fcresp.iserror()) { return response.fromresponse(resp, fcresp); } if (fcresp.isok()) { loc = fcresp.getentity(); } } if (loc == null) { loc = bwlocation.makelocation(); loc.setaddress(addr); cb.addlocation(loc); } } final bwlocation evloc = ev.getlocation(); if (chg.changed(pi, evloc, loc)) { ev.setlocation(loc); } else if ((loc != null) && (evloc != null)) { final string evval = evloc.getaddress().getvalue(); final string inval = loc.getaddress().getvalue(); if (!evval.equals(inval)) { chg.changed(pi, evval, inval); evloc.getaddress().setvalue(inval); } } break; case organizer: final bworganizer org = icalutil.getorganizer(cb, (organizer)prop); final bworganizer evorg = ev.getorganizer(); final bworganizer evorgcopy; if (evorg == null) { evorgcopy = null; } else { evorgcopy = (bworganizer)evorg.clone(); } if (chg.changed(pi, evorgcopy, org)) { if (evorg == null) { ev.setorganizer(org); } else { evorg.update(org); } } break; case percent_complete: integer ival = ((percentcomplete)prop).getpercentage(); if (chg.changed(pi, ev.getpercentcomplete(), ival)) { ev.setpercentcomplete(ival); } break; case poll_mode: sval = prop.getvalue(); if (chg.changed(pi, ev.getpollmode(), sval)) { ev.setpollmode(sval); } break; case poll_properties: sval = prop.getvalue(); if (chg.changed(pi, ev.getpollproperties(), sval)) { ev.setpollproperties(sval); } break; case poll_winner: ival = ((pollwinner)prop).getpollwinner(); if (chg.changed(pi, ev.getpollwinner(), ival)) { ev.setpollwinner(ival); } break; case priority: ival = ((priority)prop).getlevel(); if (chg.changed(pi, ev.getpriority(), ival)) { ev.setpriority(ival); } break; case rdate: chg.addvalues(pi, icalutil.makedatetimes((datelistproperty)prop)); break; case recurrence_id: break; case related_to: final relatedto irelto = (relatedto)prop; final bwrelatedto relto = new bwrelatedto(); final string parval = icalutil.getparameterval(irelto, \"reltype\"); if (parval != null) { relto.setreltype(parval); } relto.setvalue(irelto.getvalue()); if (chg.changed(pi, ev.getrelatedto(), relto)) { ev.setrelatedto(relto); } break; case request_status: final bwrequeststatus rs = bwrequeststatus .fromrequeststatus((requeststatus)prop); chg.addvalue(pi, rs); break; case resources: final textlist rl = ((resources)prop).getresources(); if (rl != null) { lang = icalutil.getlang(prop); for (final string s: rl) { final bwstring rsrc = new bwstring(lang, s); chg.addvalue(pi, rsrc); } } break; case rrule: chg.addvalue(pi, pval); break; case sequence: final int seq = ((sequence)prop).getsequenceno(); if (seq != ev.getsequence()) { chg.changed(pi, ev.getsequence(), seq); ev.setsequence(seq); } break; case status: if (chg.changed(pi, ev.getstatus(), pval)) { ev.setstatus(pval); } break; case summary: if (chg.changed(pi, ev.getsummary(), pval)) { ev.setsummary(pval); } break; case transp: if (chg.changed(pi, ev.getperusertransparency( cb.getprincipal() .getprincipalref()), pval)) { final bwxproperty pu = ev.setperusertransparency( cb.getprincipal().getprincipalref(), pval); if (pu != null) { chg.addvalue(propertyinfoindex.xprop, pu); } } break; case uid: break; case url: if (chg.changed(pi, ev.getlink(), pval)) { ev.setlink(pval); } break; case xprop: final string name = prop.getname(); if (name.equalsignorecase(bwxproperty.bedeworkcost)) { if (chg.changed(propertyinfoindex.cost, ev.getcost(), pval)) { ev.setcost(pval); } break; } if (name.equalsignorecase(bwxproperty.xbedeworkcategories)) { if (checkcategory(cb, chg, ev, null, pval)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworklocation)) { if (checklocation(cb, chg, ev, prop)) { break; } } if (name.equalsignorecase(bwxproperty.xbedeworkcontact)) { if (checkcontact(cb, chg, ev, null, pval)) { break; } } final xproperty xp = (xproperty)prop; chg.addvalue(propertyinfoindex.xprop, new bwxproperty(name, xp.getparameters() .tostring(), pval)); break; default: if (logger.debug()) { logger.debug(\"unsupported property with index \" + pi + \"; class \" + prop.getclass() + \" and value \" + pval); } } } final componentlist<component> subcomps; if (val instanceof componentcontainer) { subcomps = ((componentcontainer<component>)val).getcomponents(); } else { subcomps = null; } final set<integer> pids; if (vpoll) { pids = new treeset<>(); final bwevent vp = evinfo.getevent(); if (!util.isempty(vp.getpollitems())) { vp.clearpollitems(); } } else { pids = null; } if (!util.isempty(subcomps)) { for (final var subcomp: subcomps) { if (subcomp instanceof available) { if (!(val instanceof vavailability)) { return response.error(resp, \"available only valid in vavailable\"); } final var avlresp = processavailable(cb, cal, ical, (vavailability)val, (available)subcomp, evinfo); if (!avlresp.isok()) { return response.fromresponse(resp, avlresp); } continue; } if (subcomp instanceof participant) { if (vpoll) { final var vresp = processvoter(cb, (vpoll)val, (participant)subcomp, evinfo, chg, mergeattendees); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented participant object\"); continue; } if (subcomp instanceof vresource) { logger.warn(\"unimplemented vresource object\"); continue; } if (subcomp instanceof vlocation) { logger.warn(\"unimplemented vlocation object\"); continue; } if (subcomp instanceof valarm) { final var aresp = valarmutil.processalarm(cb, val, (valarm)subcomp, ev, currentprincipal, chg); if (!aresp.isok()) { return response.fromresponse(resp, aresp); } continue; } if (vpoll && (event || task)) { final var vresp = processcandidate((vpoll)val, subcomp, evinfo, pids, chg); if (!vresp.isok()) { return response.fromresponse(resp, vresp); } continue; } logger.warn(\"unimplemented component object: \" + subcomp); } } if (ev.getcreated() == null) { if (ev.getlastmod() != null) { ev.setcreated(ev.getlastmod()); chg.changed(propertyinfoindex.created, null, ev.getcreated()); } else { ev.updatedtstamp(); chg.changed(propertyinfoindex.created, null, ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } } if (ev.getlastmod() == null) { ev.setlastmod(ev.getcreated()); chg.changed(propertyinfoindex.last_modified, null, ev.getlastmod()); } processtimezones(ev, ical, chg); if (ev.getrecipients() != null) { ev.getrecipients().clear(); } ev.setoriginator(null); if (hasxparams.value) { final component valcopy = val.copy(); final description desp = valcopy.getproperty(property.description); if (desp != null) { desp.setvalue(null); } final attach attachp = valcopy.getproperty(property.attach); if (attachp != null) { final value v = attachp.getparameter(parameter.value); if (v != null) { attachp.setvalue(string.valueof(attachp.getvalue().hashcode())); } } chg.addvalue(propertyinfoindex.xprop, new bwxproperty(bwxproperty.bedeworkical, null, valcopy.tostring())); } chg.processchanges(ev, true, false); ev.setrecurring(ev.isrecurringentity()); if (logger.debug()) { logger.debug(chg.tostring()); logger.debug(ev.tostring()); } if (masterei != null) { return response.notfound(resp); } resp.setentity(evinfo); return resp; } catch (final throwable t) { if (logger.debug()) { logger.error(t); } return response.error(resp, t); } }","repo":"Bedework\/bw-calendar-convert","label":[1,0,1,0]}
{"id":7967,"original_code":"@GET\n  @Produces(MediaType.APPLICATION_JSON)\n  \/\/ FIXME Uncomment when overrides can be handled\n  \/\/ @OutSchema(\"wdk.users.get-by-id\")\n  public JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\n    UserBundle userBundle = getUserBundle(Access.PUBLIC);\n    List<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n        .getAccountDB().getUserPropertyNames();\n    return formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\n        getFlag(includePreferences), propDefs);\n  }","code_wo_comment":"@GET\n  @Produces(MediaType.APPLICATION_JSON)\n \n \n  public JSONObject getById(@QueryParam(\"includePreferences\") Boolean includePreferences) throws WdkModelException {\n    UserBundle userBundle = getUserBundle(Access.PUBLIC);\n    List<UserPropertyName> propDefs = getWdkModel().getModelConfig()\n        .getAccountDB().getUserPropertyNames();\n    return formatUser(userBundle.getTargetUser(), userBundle.isSessionUser(),\n        getFlag(includePreferences), propDefs);\n  }","cleancode":"@get @produces(mediatype.application_json) public jsonobject getbyid(@queryparam(\"includepreferences\") boolean includepreferences) throws wdkmodelexception { userbundle userbundle = getuserbundle(access.public); list<userpropertyname> propdefs = getwdkmodel().getmodelconfig() .getaccountdb().getuserpropertynames(); return formatuser(userbundle.gettargetuser(), userbundle.issessionuser(), getflag(includepreferences), propdefs); }","repo":"EuPathDB-Infra\/WDK","label":[1,0,0,0]}
{"id":24418,"original_code":"public static void useDropper(PlayerEntity player, Object tank, int button) {\n            ItemStack stack = player.inventory.getItemStack();\n            if (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\n                return;\n            }\n            if (!stack.isEmpty()) {\n                FluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\n                if (tank instanceof IChemicalTank) {\n                    IChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\n                    if (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n                        \/\/It is actually a gas tank\n                        IChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\n                        Optional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                        if (capability.isPresent()) {\n                            IGasHandler gasHandlerItem = capability.get();\n                            if (gasHandlerItem.getGasTankCount() > 0) {\n                                \/\/Validate something didn't go terribly wrong and we actually do have the tank we expect to have\n                                GasStack storedGas = gasHandlerItem.getGasInTank(0);\n                                if (!storedGas.isTypeEqual(gasTank.getStack())) {\n                                    return;\n                                }\n                                if (button == 0) { \/\/Insert gas into dropper\n                                    if (!storedFluid.isEmpty() || gasTank.isEmpty()) {\n                                        return;\n                                    }\n                                    GasStack gasInTank = gasTank.getStack();\n                                    GasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\n                                    int remainder = simulatedRemainder.getAmount();\n                                    int amount = gasInTank.getAmount();\n                                    if (remainder < amount) {\n                                        \/\/We are able to fit at least some of the gas from our tank into the item\n                                        GasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\n                                        if (!extractedGas.isEmpty()) {\n                                            \/\/If we were able to actually extract it from our tank, then insert it into the item\n                                            if (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n                                                \/\/TODO: Print warning\/error\n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 1) { \/\/Extract gas from dropper\n                                    if (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n                                        \/\/If the dropper has fluid or the tank interacting with is already full of gas\n                                        return;\n                                    }\n                                    GasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n                                    int gasInItemAmount = storedGas.getAmount();\n                                    int remainder = simulatedRemainder.getAmount();\n                                    if (remainder < gasInItemAmount) {\n                                        GasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\n                                        if (!extractedGas.isEmpty()) {\n                                            \/\/If we were able to actually extract it from the item, then insert it into our gas tank\n                                            if (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                                \/\/TODO: Print warning\/error\n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 2) { \/\/Dump the tank\n                                    gasTank.setEmpty();\n                                }\n                            }\n                        } else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n                            \/\/It is actually an infusion tank\n                            IChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n                            \/\/TODO: Implement at some point\n                        }\n                    }\n                    \/\/TODO: Handle other chemical tanks like maybe infusion tanks\n                } else if (tank instanceof IExtendedFluidTank) {\n                    IExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\n                    if (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n                        return;\n                    }\n                    GasStack storedGas = GasStack.EMPTY;\n                    Optional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                    if (gasCapability.isPresent()) {\n                        IGasHandler gasHandlerItem = gasCapability.get();\n                        if (gasHandlerItem.getGasTankCount() > 0) {\n                            storedGas = gasHandlerItem.getGasInTank(0);\n                        }\n                    }\n                    if (button == 2) { \/\/Dump the tank\n                        fluidTank.setEmpty();\n                    }\n                    Optional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\n                    if (!capability.isPresent()) {\n                        \/\/If something went wrong and we don't have a fluid handler on our tank, then fail\n                        return;\n                    }\n                    IFluidHandlerItem fluidHandlerItem = capability.get();\n                    if (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n                        \/\/TODO: Decide if we want to support someone replacing our fluid handler with another?\n                        \/\/If it isn't one of our fluid handlers fail\n                        return;\n                    }\n                    IExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\n                    if (itemFluidTank == null) {\n                        \/\/If something went wrong and we don't have a fluid tank fail\n                        return;\n                    }\n                    if (button == 0) { \/\/Insert fluid into dropper\n                        if (!storedGas.isEmpty() || fluidTank.isEmpty()) {\n                            return;\n                        }\n                        FluidStack fluidInTank = fluidTank.getFluid();\n                        FluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\n                        int remainder = simulatedRemainder.getAmount();\n                        int amount = fluidInTank.getAmount();\n                        if (remainder < amount) {\n                            \/\/We are able to fit at least some of the fluid from our tank into the item\n                            FluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!extractedFluid.isEmpty()) {\n                                \/\/If we were able to actually extract it from our tank, then insert it into the item\n                                if (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n                                    \/\/TODO: Print warning\/error\n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    } else if (button == 1) { \/\/Extract fluid from dropper\n                        if (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\n                            return;\n                        }\n                        FluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\n                        int fluidInItemAmount = storedFluid.getAmount();\n                        int remainder = simulatedRemainder.getAmount();\n                        if (remainder < fluidInItemAmount) {\n                            FluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!drainedGas.isEmpty()) {\n                                \/\/If we were able to actually extract it from the item, then insert it into our gas tank\n                                if (!fluidTank.insert(drainedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                    \/\/TODO: Print warning\/error\n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    }\n                }\n            }\n        }","code_wo_comment":"public static void useDropper(PlayerEntity player, Object tank, int button) {\n            ItemStack stack = player.inventory.getItemStack();\n            if (stack.isEmpty() || !(stack.getItem() instanceof ItemGaugeDropper)) {\n                return;\n            }\n            if (!stack.isEmpty()) {\n                FluidStack storedFluid = StorageUtils.getStoredFluidFromNBT(stack);\n                if (tank instanceof IChemicalTank) {\n                    IChemicalTank<?, ?> chemicalTank = (IChemicalTank<?, ?>) tank;\n                    if (chemicalTank.getEmptyStack() == GasStack.EMPTY) {\n                       \n                        IChemicalTank<Gas, GasStack> gasTank = (IChemicalTank<Gas, GasStack>) chemicalTank;\n                        Optional<IGasHandler> capability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                        if (capability.isPresent()) {\n                            IGasHandler gasHandlerItem = capability.get();\n                            if (gasHandlerItem.getGasTankCount() > 0) {\n                               \n                                GasStack storedGas = gasHandlerItem.getGasInTank(0);\n                                if (!storedGas.isTypeEqual(gasTank.getStack())) {\n                                    return;\n                                }\n                                if (button == 0) {\n                                    if (!storedFluid.isEmpty() || gasTank.isEmpty()) {\n                                        return;\n                                    }\n                                    GasStack gasInTank = gasTank.getStack();\n                                    GasStack simulatedRemainder = gasHandlerItem.insertGas(gasInTank, Action.SIMULATE);\n                                    int remainder = simulatedRemainder.getAmount();\n                                    int amount = gasInTank.getAmount();\n                                    if (remainder < amount) {\n                                       \n                                        GasStack extractedGas = gasTank.extract(amount - remainder, Action.EXECUTE, AutomationType.INTERNAL);\n                                        if (!extractedGas.isEmpty()) {\n                                           \n                                            if (!gasHandlerItem.insertGas(extractedGas, Action.EXECUTE).isEmpty()) {\n                                               \n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 1) {\n                                    if (!storedFluid.isEmpty() || gasTank.getNeeded() == 0) {\n                                       \n                                        return;\n                                    }\n                                    GasStack simulatedRemainder = gasTank.insert(storedGas, Action.SIMULATE, AutomationType.INTERNAL);\n                                    int gasInItemAmount = storedGas.getAmount();\n                                    int remainder = simulatedRemainder.getAmount();\n                                    if (remainder < gasInItemAmount) {\n                                        GasStack extractedGas = gasHandlerItem.extractGas(0, gasInItemAmount - remainder, Action.EXECUTE);\n                                        if (!extractedGas.isEmpty()) {\n                                           \n                                            if (!gasTank.insert(extractedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                               \n                                            }\n                                            ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                                        }\n                                    }\n                                } else if (button == 2) {\n                                    gasTank.setEmpty();\n                                }\n                            }\n                        } else if (chemicalTank.getEmptyStack() == InfusionStack.EMPTY) {\n                           \n                            IChemicalTank<InfuseType, InfusionStack> infusionTank = (IChemicalTank<InfuseType, InfusionStack>) chemicalTank;\n                           \n                        }\n                    }\n                   \n                } else if (tank instanceof IExtendedFluidTank) {\n                    IExtendedFluidTank fluidTank = (IExtendedFluidTank) tank;\n                    if (!storedFluid.isEmpty() && !fluidTank.isEmpty() && !storedFluid.isFluidEqual(fluidTank.getFluid())) {\n                        return;\n                    }\n                    GasStack storedGas = GasStack.EMPTY;\n                    Optional<IGasHandler> gasCapability = MekanismUtils.toOptional(stack.getCapability(Capabilities.GAS_HANDLER_CAPABILITY));\n                    if (gasCapability.isPresent()) {\n                        IGasHandler gasHandlerItem = gasCapability.get();\n                        if (gasHandlerItem.getGasTankCount() > 0) {\n                            storedGas = gasHandlerItem.getGasInTank(0);\n                        }\n                    }\n                    if (button == 2) {\n                        fluidTank.setEmpty();\n                    }\n                    Optional<IFluidHandlerItem> capability = MekanismUtils.toOptional(FluidUtil.getFluidHandler(stack));\n                    if (!capability.isPresent()) {\n                       \n                        return;\n                    }\n                    IFluidHandlerItem fluidHandlerItem = capability.get();\n                    if (!(fluidHandlerItem instanceof IMekanismFluidHandler)) {\n                       \n                       \n                        return;\n                    }\n                    IExtendedFluidTank itemFluidTank = ((IMekanismFluidHandler) fluidHandlerItem).getFluidTank(0, null);\n                    if (itemFluidTank == null) {\n                       \n                        return;\n                    }\n                    if (button == 0) {\n                        if (!storedGas.isEmpty() || fluidTank.isEmpty()) {\n                            return;\n                        }\n                        FluidStack fluidInTank = fluidTank.getFluid();\n                        FluidStack simulatedRemainder = itemFluidTank.insert(fluidInTank, Action.SIMULATE, AutomationType.MANUAL);\n                        int remainder = simulatedRemainder.getAmount();\n                        int amount = fluidInTank.getAmount();\n                        if (remainder < amount) {\n                           \n                            FluidStack extractedFluid = fluidTank.extract(amount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!extractedFluid.isEmpty()) {\n                               \n                                if (!itemFluidTank.insert(extractedFluid, Action.EXECUTE, AutomationType.MANUAL).isEmpty()) {\n                                   \n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    } else if (button == 1) {\n                        if (!storedGas.isEmpty() || fluidTank.getNeeded() == 0) {\n                            return;\n                        }\n                        FluidStack simulatedRemainder = fluidTank.insert(storedFluid, Action.SIMULATE, AutomationType.MANUAL);\n                        int fluidInItemAmount = storedFluid.getAmount();\n                        int remainder = simulatedRemainder.getAmount();\n                        if (remainder < fluidInItemAmount) {\n                            FluidStack drainedGas = itemFluidTank.extract(fluidInItemAmount - remainder, Action.EXECUTE, AutomationType.MANUAL);\n                            if (!drainedGas.isEmpty()) {\n                               \n                                if (!fluidTank.insert(drainedGas, Action.EXECUTE, AutomationType.INTERNAL).isEmpty()) {\n                                   \n                                }\n                                ((ServerPlayerEntity) player).sendContainerToPlayer(player.openContainer);\n                            }\n                        }\n                    }\n                }\n            }\n        }","cleancode":"public static void usedropper(playerentity player, object tank, int button) { itemstack stack = player.inventory.getitemstack(); if (stack.isempty() || !(stack.getitem() instanceof itemgaugedropper)) { return; } if (!stack.isempty()) { fluidstack storedfluid = storageutils.getstoredfluidfromnbt(stack); if (tank instanceof ichemicaltank) { ichemicaltank<?, ?> chemicaltank = (ichemicaltank<?, ?>) tank; if (chemicaltank.getemptystack() == gasstack.empty) { ichemicaltank<gas, gasstack> gastank = (ichemicaltank<gas, gasstack>) chemicaltank; optional<igashandler> capability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (capability.ispresent()) { igashandler gashandleritem = capability.get(); if (gashandleritem.getgastankcount() > 0) { gasstack storedgas = gashandleritem.getgasintank(0); if (!storedgas.istypeequal(gastank.getstack())) { return; } if (button == 0) { if (!storedfluid.isempty() || gastank.isempty()) { return; } gasstack gasintank = gastank.getstack(); gasstack simulatedremainder = gashandleritem.insertgas(gasintank, action.simulate); int remainder = simulatedremainder.getamount(); int amount = gasintank.getamount(); if (remainder < amount) { gasstack extractedgas = gastank.extract(amount - remainder, action.execute, automationtype.internal); if (!extractedgas.isempty()) { if (!gashandleritem.insertgas(extractedgas, action.execute).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { if (!storedfluid.isempty() || gastank.getneeded() == 0) { return; } gasstack simulatedremainder = gastank.insert(storedgas, action.simulate, automationtype.internal); int gasinitemamount = storedgas.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < gasinitemamount) { gasstack extractedgas = gashandleritem.extractgas(0, gasinitemamount - remainder, action.execute); if (!extractedgas.isempty()) { if (!gastank.insert(extractedgas, action.execute, automationtype.internal).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 2) { gastank.setempty(); } } } else if (chemicaltank.getemptystack() == infusionstack.empty) { ichemicaltank<infusetype, infusionstack> infusiontank = (ichemicaltank<infusetype, infusionstack>) chemicaltank; } } } else if (tank instanceof iextendedfluidtank) { iextendedfluidtank fluidtank = (iextendedfluidtank) tank; if (!storedfluid.isempty() && !fluidtank.isempty() && !storedfluid.isfluidequal(fluidtank.getfluid())) { return; } gasstack storedgas = gasstack.empty; optional<igashandler> gascapability = mekanismutils.tooptional(stack.getcapability(capabilities.gas_handler_capability)); if (gascapability.ispresent()) { igashandler gashandleritem = gascapability.get(); if (gashandleritem.getgastankcount() > 0) { storedgas = gashandleritem.getgasintank(0); } } if (button == 2) { fluidtank.setempty(); } optional<ifluidhandleritem> capability = mekanismutils.tooptional(fluidutil.getfluidhandler(stack)); if (!capability.ispresent()) { return; } ifluidhandleritem fluidhandleritem = capability.get(); if (!(fluidhandleritem instanceof imekanismfluidhandler)) { return; } iextendedfluidtank itemfluidtank = ((imekanismfluidhandler) fluidhandleritem).getfluidtank(0, null); if (itemfluidtank == null) { return; } if (button == 0) { if (!storedgas.isempty() || fluidtank.isempty()) { return; } fluidstack fluidintank = fluidtank.getfluid(); fluidstack simulatedremainder = itemfluidtank.insert(fluidintank, action.simulate, automationtype.manual); int remainder = simulatedremainder.getamount(); int amount = fluidintank.getamount(); if (remainder < amount) { fluidstack extractedfluid = fluidtank.extract(amount - remainder, action.execute, automationtype.manual); if (!extractedfluid.isempty()) { if (!itemfluidtank.insert(extractedfluid, action.execute, automationtype.manual).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } else if (button == 1) { if (!storedgas.isempty() || fluidtank.getneeded() == 0) { return; } fluidstack simulatedremainder = fluidtank.insert(storedfluid, action.simulate, automationtype.manual); int fluidinitemamount = storedfluid.getamount(); int remainder = simulatedremainder.getamount(); if (remainder < fluidinitemamount) { fluidstack drainedgas = itemfluidtank.extract(fluidinitemamount - remainder, action.execute, automationtype.manual); if (!drainedgas.isempty()) { if (!fluidtank.insert(drainedgas, action.execute, automationtype.internal).isempty()) { } ((serverplayerentity) player).sendcontainertoplayer(player.opencontainer); } } } } } }","repo":"Chiefwright\/Mekanism","label":[0,1,0,0]}

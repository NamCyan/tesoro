{"id":28,"original_code":"@Override\n    public void process(JCas jCas) throws AnalysisEngineProcessException {\n        long startTime = System.currentTimeMillis();\n        FeatureExtractor fe = new NYTEntitySalienceFeatureExtractor();\n        List<EntityInstance> entityInstances;\n        try {\n            entityInstances = fe.getEntityInstances(jCas, TrainingSettings.FeatureExtractor.ENTITY_SALIENCE);\n            final int featureVectorSize = FeatureSetFactory.createFeatureSet(TrainingSettings.FeatureExtractor.ENTITY_SALIENCE).getFeatureVectorSize();\n            \/\/TODO: For each model create separate implementation.\n            RandomForestClassificationModel rfm = (RandomForestClassificationModel)trainingModel.stages()[2];\n            for(EntityInstance ei : entityInstances) {\n                Vector vei = FeatureValueInstanceUtils.convertToSparkMLVector(ei, featureVectorSize);\n                double label = rfm.predict(vei);\n                Vector probabilities = rfm.predictProbability(vei);\n                double salience = probabilities.toArray()[1];\n                SalientEntity salientEntity = new SalientEntity(jCas, 0, 0);\n                salientEntity.setLabel(label);\n                salientEntity.setID(ei.getEntityId());\n                salientEntity.setSalience(salience);\n                salientEntity.addToIndexes();\n            }\n            long endTime = System.currentTimeMillis() - startTime;\n            logger.debug(\"Annotating salient entities finished in {}ms.\", endTime);\n        } catch (Exception e) {\n            throw new AnalysisEngineProcessException(e);\n        }\n    }","code_wo_comment":"@Override\n    public void process(JCas jCas) throws AnalysisEngineProcessException {\n        long startTime = System.currentTimeMillis();\n        FeatureExtractor fe = new NYTEntitySalienceFeatureExtractor();\n        List<EntityInstance> entityInstances;\n        try {\n            entityInstances = fe.getEntityInstances(jCas, TrainingSettings.FeatureExtractor.ENTITY_SALIENCE);\n            final int featureVectorSize = FeatureSetFactory.createFeatureSet(TrainingSettings.FeatureExtractor.ENTITY_SALIENCE).getFeatureVectorSize();\n           \n            RandomForestClassificationModel rfm = (RandomForestClassificationModel)trainingModel.stages()[2];\n            for(EntityInstance ei : entityInstances) {\n                Vector vei = FeatureValueInstanceUtils.convertToSparkMLVector(ei, featureVectorSize);\n                double label = rfm.predict(vei);\n                Vector probabilities = rfm.predictProbability(vei);\n                double salience = probabilities.toArray()[1];\n                SalientEntity salientEntity = new SalientEntity(jCas, 0, 0);\n                salientEntity.setLabel(label);\n                salientEntity.setID(ei.getEntityId());\n                salientEntity.setSalience(salience);\n                salientEntity.addToIndexes();\n            }\n            long endTime = System.currentTimeMillis() - startTime;\n            logger.debug(\"Annotating salient entities finished in {}ms.\", endTime);\n        } catch (Exception e) {\n            throw new AnalysisEngineProcessException(e);\n        }\n    }","cleancode":"@override public void process(jcas jcas) throws analysisengineprocessexception { long starttime = system.currenttimemillis(); featureextractor fe = new nytentitysaliencefeatureextractor(); list<entityinstance> entityinstances; try { entityinstances = fe.getentityinstances(jcas, trainingsettings.featureextractor.entity_salience); final int featurevectorsize = featuresetfactory.createfeatureset(trainingsettings.featureextractor.entity_salience).getfeaturevectorsize(); randomforestclassificationmodel rfm = (randomforestclassificationmodel)trainingmodel.stages()[2]; for(entityinstance ei : entityinstances) { vector vei = featurevalueinstanceutils.converttosparkmlvector(ei, featurevectorsize); double label = rfm.predict(vei); vector probabilities = rfm.predictprobability(vei); double salience = probabilities.toarray()[1]; saliententity saliententity = new saliententity(jcas, 0, 0); saliententity.setlabel(label); saliententity.setid(ei.getentityid()); saliententity.setsalience(salience); saliententity.addtoindexes(); } long endtime = system.currenttimemillis() - starttime; logger.debug(\"annotating salient entities finished in {}ms.\", endtime); } catch (exception e) { throw new analysisengineprocessexception(e); } }","repo":"dmilcevski\/ambiverse-nlu","label":[0,1,0,0]}
{"id":32,"original_code":"private void generateArttribute() {\n\t\tString temp = \"\";\n\t\tfor (String s : connectedElements)\n\t\t\ttemp = temp + s + \" \";\n\t\t\/\/ TODO: check here, may be necessary to remove the last space.\n\t\tlinkingResourceElement.setAttribute(\n\t\t\t\t\"connectedResourceContainers_LinkingResource\", temp);\n\t}","code_wo_comment":"private void generateArttribute() {\n\t\tString temp = \"\";\n\t\tfor (String s : connectedElements)\n\t\t\ttemp = temp + s + \" \";\n\t\n\t\tlinkingResourceElement.setAttribute(\n\t\t\t\t\"connectedResourceContainers_LinkingResource\", temp);\n\t}","cleancode":"private void generatearttribute() { string temp = \"\"; for (string s : connectedelements) temp = temp + s + \" \"; linkingresourceelement.setattribute( \"connectedresourcecontainers_linkingresource\", temp); }","repo":"deib-polimi\/modaclouds-space4cloud","label":[1,0,0,0]}
{"id":100,"original_code":"@Override\n\tpublic boolean hasRole(final PrincipalCollection principal, final String roleIdentifier) {\n\t\t\/\/ TODO Auto-generated method stub\n\t\t\/\/ return super.hasRole(principal, roleIdentifier);\n\t\tfor (final Object p : principal.fromRealm(REALM_NAME)) {\n\t\t\tif (p instanceof GenericPrincipal) {\n\t\t\t\tfinal GenericPrincipal gp = (GenericPrincipal) p;\n\t\t\t\tfor (final String r : gp.getRoles()) {\n\t\t\t\t\tif (r.equals(roleIdentifier)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","code_wo_comment":"@Override\n\tpublic boolean hasRole(final PrincipalCollection principal, final String roleIdentifier) {\n\t\n\t\n\t\tfor (final Object p : principal.fromRealm(REALM_NAME)) {\n\t\t\tif (p instanceof GenericPrincipal) {\n\t\t\t\tfinal GenericPrincipal gp = (GenericPrincipal) p;\n\t\t\t\tfor (final String r : gp.getRoles()) {\n\t\t\t\t\tif (r.equals(roleIdentifier)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","cleancode":"@override public boolean hasrole(final principalcollection principal, final string roleidentifier) { for (final object p : principal.fromrealm(realm_name)) { if (p instanceof genericprincipal) { final genericprincipal gp = (genericprincipal) p; for (final string r : gp.getroles()) { if (r.equals(roleidentifier)) { return true; } } } } return false; }","repo":"danieljue\/graphene","label":[1,0,0,0]}
{"id":8408,"original_code":"private synchronized static void initializeImplClasses() {\n        log.trace(\"exec\");\n        \/\/ TODO load all expected impl classes, allowing fail fast rather than waiting for user to hit a certain use case\n    }","code_wo_comment":"private synchronized static void initializeImplClasses() {\n        log.trace(\"exec\");\n       \n    }","cleancode":"private synchronized static void initializeimplclasses() { log.trace(\"exec\"); }","repo":"esasiela\/hc-log4tri","label":[0,1,0,0]}
{"id":8468,"original_code":"private ProgressTracker createProgressTracker() {\n    ReadOperation readOperation;\n    RemoteGrpcPortWriteOperation grpcWriteOperation;\n    RegisterAndProcessBundleOperation bundleProcessOperation;\n    try {\n      readOperation = getReadOperation();\n    } catch (Exception exn) {\n      readOperation = null;\n      LOG.info(\"Unable to get read operation.\", exn);\n      return new NullProgressTracker();\n    }\n    \/\/ If there is a exactly one of each of RemoteGrpcPortWriteOperation and\n    \/\/ RegisterAndProcessBundleOperation we know they have the right topology.\n    try {\n      grpcWriteOperation =\n          Iterables.getOnlyElement(\n              Iterables.filter(operations, RemoteGrpcPortWriteOperation.class));\n      bundleProcessOperation =\n          Iterables.getOnlyElement(\n              Iterables.filter(operations, RegisterAndProcessBundleOperation.class));\n    } catch (IllegalArgumentException | NoSuchElementException exn) {\n      \/\/ TODO: Handle more than one sdk worker processing a single bundle.\n      grpcWriteOperation = null;\n      bundleProcessOperation = null;\n      LOG.debug(\"Does not have exactly one grpcWRite and bundleProcess operation.\", exn);\n    }\n    if (grpcWriteOperation != null && bundleProcessOperation != null) {\n      return new SingularProcessBundleProgressTracker(\n          readOperation, grpcWriteOperation, bundleProcessOperation);\n    } else {\n      return new ReadOperationProgressTracker(readOperation);\n    }\n  }","code_wo_comment":"private ProgressTracker createProgressTracker() {\n    ReadOperation readOperation;\n    RemoteGrpcPortWriteOperation grpcWriteOperation;\n    RegisterAndProcessBundleOperation bundleProcessOperation;\n    try {\n      readOperation = getReadOperation();\n    } catch (Exception exn) {\n      readOperation = null;\n      LOG.info(\"Unable to get read operation.\", exn);\n      return new NullProgressTracker();\n    }\n   \n   \n    try {\n      grpcWriteOperation =\n          Iterables.getOnlyElement(\n              Iterables.filter(operations, RemoteGrpcPortWriteOperation.class));\n      bundleProcessOperation =\n          Iterables.getOnlyElement(\n              Iterables.filter(operations, RegisterAndProcessBundleOperation.class));\n    } catch (IllegalArgumentException | NoSuchElementException exn) {\n     \n      grpcWriteOperation = null;\n      bundleProcessOperation = null;\n      LOG.debug(\"Does not have exactly one grpcWRite and bundleProcess operation.\", exn);\n    }\n    if (grpcWriteOperation != null && bundleProcessOperation != null) {\n      return new SingularProcessBundleProgressTracker(\n          readOperation, grpcWriteOperation, bundleProcessOperation);\n    } else {\n      return new ReadOperationProgressTracker(readOperation);\n    }\n  }","cleancode":"private progresstracker createprogresstracker() { readoperation readoperation; remotegrpcportwriteoperation grpcwriteoperation; registerandprocessbundleoperation bundleprocessoperation; try { readoperation = getreadoperation(); } catch (exception exn) { readoperation = null; log.info(\"unable to get read operation.\", exn); return new nullprogresstracker(); } try { grpcwriteoperation = iterables.getonlyelement( iterables.filter(operations, remotegrpcportwriteoperation.class)); bundleprocessoperation = iterables.getonlyelement( iterables.filter(operations, registerandprocessbundleoperation.class)); } catch (illegalargumentexception | nosuchelementexception exn) { grpcwriteoperation = null; bundleprocessoperation = null; log.debug(\"does not have exactly one grpcwrite and bundleprocess operation.\", exn); } if (grpcwriteoperation != null && bundleprocessoperation != null) { return new singularprocessbundleprogresstracker( readoperation, grpcwriteoperation, bundleprocessoperation); } else { return new readoperationprogresstracker(readoperation); } }","repo":"elwinarens\/beam","label":[0,1,0,0]}
{"id":16671,"original_code":"@Override\n    public void execute() {\n        double y = -Constants.joystick.getY();\n        double z = Constants.joystick.getZ();\n        \/\/TODO - Could we also check if the elevator is up and limit speed?\n        if(y < Constants.REVERSE_MAX_SPEED) {\n            y = Constants.REVERSE_MAX_SPEED;\n        }\n        if(z < Constants.LEFT_MAX_SPEED ) {\n            z = Constants.LEFT_MAX_SPEED;\n        } else if(z > Constants.RIGHT_MAX_SPEED){\n            z = Constants.RIGHT_MAX_SPEED;\n        }\n        driveSubsystem.getDiffDrive().arcadeDrive(y, z);\n    }","code_wo_comment":"@Override\n    public void execute() {\n        double y = -Constants.joystick.getY();\n        double z = Constants.joystick.getZ();\n       \n        if(y < Constants.REVERSE_MAX_SPEED) {\n            y = Constants.REVERSE_MAX_SPEED;\n        }\n        if(z < Constants.LEFT_MAX_SPEED ) {\n            z = Constants.LEFT_MAX_SPEED;\n        } else if(z > Constants.RIGHT_MAX_SPEED){\n            z = Constants.RIGHT_MAX_SPEED;\n        }\n        driveSubsystem.getDiffDrive().arcadeDrive(y, z);\n    }","cleancode":"@override public void execute() { double y = -constants.joystick.gety(); double z = constants.joystick.getz(); if(y < constants.reverse_max_speed) { y = constants.reverse_max_speed; } if(z < constants.left_max_speed ) { z = constants.left_max_speed; } else if(z > constants.right_max_speed){ z = constants.right_max_speed; } drivesubsystem.getdiffdrive().arcadedrive(y, z); }","repo":"frc5826\/2022-production","label":[0,1,0,0]}
{"id":8547,"original_code":"private void deleteInternal(List<FileInfo> itemsToDelete, List<FileInfo> bucketsToDelete)\n      throws IOException {\n    \/\/ TODO(user): We might need to separate out children into separate batches from parents to\n    \/\/ avoid deleting a parent before somehow failing to delete a child.\n    \/\/ Delete children before their parents.\n    \/\/\n    \/\/ Note: we modify the input list, which is ok for current usage.\n    \/\/ We should make a copy in case that changes in future.\n    itemsToDelete.sort(FILE_INFO_PATH_COMPARATOR.reversed());\n    if (!itemsToDelete.isEmpty()) {\n      List<StorageResourceId> objectsToDelete = new ArrayList<>(itemsToDelete.size());\n      for (FileInfo fileInfo : itemsToDelete) {\n        \/\/ TODO(b\/110833109): populate generation ID in StorageResourceId when listing infos?\n        objectsToDelete.add(\n            new StorageResourceId(\n                fileInfo.getItemInfo().getBucketName(),\n                fileInfo.getItemInfo().getObjectName(),\n                fileInfo.getItemInfo().getContentGeneration()));\n      }\n      gcs.deleteObjects(objectsToDelete);\n    }\n    if (!bucketsToDelete.isEmpty()) {\n      List<String> bucketNames = new ArrayList<>(bucketsToDelete.size());\n      for (FileInfo bucketInfo : bucketsToDelete) {\n        bucketNames.add(bucketInfo.getItemInfo().getResourceId().getBucketName());\n      }\n      if (options.isBucketDeleteEnabled()) {\n        gcs.deleteBuckets(bucketNames);\n      } else {\n        logger.atInfo().log(\n            \"Skipping deletion of buckets because enableBucketDelete is false: %s\", bucketNames);\n      }\n    }\n  }","code_wo_comment":"private void deleteInternal(List<FileInfo> itemsToDelete, List<FileInfo> bucketsToDelete)\n      throws IOException {\n   \n   \n   \n   \n   \n   \n    itemsToDelete.sort(FILE_INFO_PATH_COMPARATOR.reversed());\n    if (!itemsToDelete.isEmpty()) {\n      List<StorageResourceId> objectsToDelete = new ArrayList<>(itemsToDelete.size());\n      for (FileInfo fileInfo : itemsToDelete) {\n       \n        objectsToDelete.add(\n            new StorageResourceId(\n                fileInfo.getItemInfo().getBucketName(),\n                fileInfo.getItemInfo().getObjectName(),\n                fileInfo.getItemInfo().getContentGeneration()));\n      }\n      gcs.deleteObjects(objectsToDelete);\n    }\n    if (!bucketsToDelete.isEmpty()) {\n      List<String> bucketNames = new ArrayList<>(bucketsToDelete.size());\n      for (FileInfo bucketInfo : bucketsToDelete) {\n        bucketNames.add(bucketInfo.getItemInfo().getResourceId().getBucketName());\n      }\n      if (options.isBucketDeleteEnabled()) {\n        gcs.deleteBuckets(bucketNames);\n      } else {\n        logger.atInfo().log(\n            \"Skipping deletion of buckets because enableBucketDelete is false: %s\", bucketNames);\n      }\n    }\n  }","cleancode":"private void deleteinternal(list<fileinfo> itemstodelete, list<fileinfo> bucketstodelete) throws ioexception { itemstodelete.sort(file_info_path_comparator.reversed()); if (!itemstodelete.isempty()) { list<storageresourceid> objectstodelete = new arraylist<>(itemstodelete.size()); for (fileinfo fileinfo : itemstodelete) { objectstodelete.add( new storageresourceid( fileinfo.getiteminfo().getbucketname(), fileinfo.getiteminfo().getobjectname(), fileinfo.getiteminfo().getcontentgeneration())); } gcs.deleteobjects(objectstodelete); } if (!bucketstodelete.isempty()) { list<string> bucketnames = new arraylist<>(bucketstodelete.size()); for (fileinfo bucketinfo : bucketstodelete) { bucketnames.add(bucketinfo.getiteminfo().getresourceid().getbucketname()); } if (options.isbucketdeleteenabled()) { gcs.deletebuckets(bucketnames); } else { logger.atinfo().log( \"skipping deletion of buckets because enablebucketdelete is false: %s\", bucketnames); } } }","repo":"danielxjd\/hadoop-connectors","label":[1,1,0,0]}
{"id":16844,"original_code":"public void testEmpty() throws IOException {\n        final MappedFieldType ft = new NumberFieldMapper.NumberFieldType(\"field\", NumberType.LONG);\n        testCase(\n            stats(\"_name\").field(ft.name()),\n            iw -> {},\n            stats -> {\n                assertEquals(0d, stats.getCount(), 0);\n                assertEquals(0d, stats.getSum(), 0);\n                assertEquals(Float.NaN, stats.getAvg(), 0);\n                assertEquals(Double.POSITIVE_INFINITY, stats.getMin(), 0);\n                assertEquals(Double.NEGATIVE_INFINITY, stats.getMax(), 0);\n                assertFalse(AggregationInspectionHelper.hasValue(stats));\n            },\n            singleton(ft)\n        );\n    }","code_wo_comment":"public void testEmpty() throws IOException {\n        final MappedFieldType ft = new NumberFieldMapper.NumberFieldType(\"field\", NumberType.LONG);\n        testCase(\n            stats(\"_name\").field(ft.name()),\n            iw -> {},\n            stats -> {\n                assertEquals(0d, stats.getCount(), 0);\n                assertEquals(0d, stats.getSum(), 0);\n                assertEquals(Float.NaN, stats.getAvg(), 0);\n                assertEquals(Double.POSITIVE_INFINITY, stats.getMin(), 0);\n                assertEquals(Double.NEGATIVE_INFINITY, stats.getMax(), 0);\n                assertFalse(AggregationInspectionHelper.hasValue(stats));\n            },\n            singleton(ft)\n        );\n    }","cleancode":"public void testempty() throws ioexception { final mappedfieldtype ft = new numberfieldmapper.numberfieldtype(\"field\", numbertype.long); testcase( stats(\"_name\").field(ft.name()), iw -> {}, stats -> { assertequals(0d, stats.getcount(), 0); assertequals(0d, stats.getsum(), 0); assertequals(float.nan, stats.getavg(), 0); assertequals(double.positive_infinity, stats.getmin(), 0); assertequals(double.negative_infinity, stats.getmax(), 0); assertfalse(aggregationinspectionhelper.hasvalue(stats)); }, singleton(ft) ); }","repo":"dial-workable\/elasticsearch","label":[0,0,0,1]}
{"id":521,"original_code":"public void testEvilGroovyScripts() throws Exception {\n        int nodes = randomIntBetween(1, 3);\n        Settings nodeSettings = Settings.builder()\n                .put(\"script.inline\", true)\n                .put(\"script.indexed\", true)\n                .build();\n        internalCluster().startNodesAsync(nodes, nodeSettings).get();\n        client().admin().cluster().prepareHealth().setWaitForNodes(nodes + \"\").get();\n        client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"foo\", 5, \"bar\", \"baz\").setRefresh(true).get();\n        \/\/ Plain test\n        assertSuccess(\"\");\n        \/\/ numeric field access\n        assertSuccess(\"def foo = doc['foo'].value; if (foo == null) { return 5; }\");\n        \/\/ string field access\n        assertSuccess(\"def bar = doc['bar'].value; if (bar == null) { return 5; }\");\n        \/\/ List\n        assertSuccess(\"def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)\");\n        \/\/ Ranges\n        assertSuccess(\"def range = 1..doc['foo'].value; def v = range.get(0)\");\n        \/\/ Maps\n        assertSuccess(\"def v = doc['foo'].value; def m = [:]; m.put(\\\"value\\\", v)\");\n        \/\/ Times\n        assertSuccess(\"def t = Instant.now().getMillis()\");\n        \/\/ GroovyCollections\n        assertSuccess(\"def n = [1,2,3]; GroovyCollections.max(n)\");\n        \/\/ Fail cases:\n        \/\/ AccessControlException[access denied (\"java.io.FilePermission\" \"<<ALL FILES>>\" \"execute\")]\n        assertFailure(\"pr = Runtime.getRuntime().exec(\\\"touch \/tmp\/gotcha\\\"); pr.waitFor()\");\n        \/\/ AccessControlException[access denied (\"java.lang.RuntimePermission\" \"accessClassInPackage.sun.reflect\")]\n        assertFailure(\"d = new DateTime(); d.getClass().getDeclaredMethod(\\\"year\\\").setAccessible(true)\");\n        assertFailure(\"d = new DateTime(); d.\\\"${'get' + 'Class'}\\\"().\" +\n                        \"\\\"${'getDeclared' + 'Method'}\\\"(\\\"year\\\").\\\"${'set' + 'Accessible'}\\\"(false)\");\n        assertFailure(\"Class.forName(\\\"org.joda.time.DateTime\\\").getDeclaredMethod(\\\"year\\\").setAccessible(true)\");\n        \/\/ AccessControlException[access denied (\"groovy.security.GroovyCodeSourcePermission\" \"\/groovy\/shell\")]\n        assertFailure(\"Eval.me('2 + 2')\");\n        assertFailure(\"Eval.x(5, 'x + 2')\");\n        \/\/ AccessControlException[access denied (\"java.lang.RuntimePermission\" \"accessDeclaredMembers\")]\n        assertFailure(\"d = new Date(); java.lang.reflect.Field f = Date.class.getDeclaredField(\\\"fastTime\\\");\" +\n                \" f.setAccessible(true); f.get(\\\"fastTime\\\")\");\n        \/\/ AccessControlException[access denied (\"java.io.FilePermission\" \"<<ALL FILES>>\" \"execute\")]\n        assertFailure(\"def methodName = 'ex'; Runtime.\\\"${'get' + 'Runtime'}\\\"().\\\"${methodName}ec\\\"(\\\"touch \/tmp\/gotcha2\\\")\");\n        \/\/ AccessControlException[access denied (\"java.lang.RuntimePermission\" \"modifyThreadGroup\")]\n        assertFailure(\"t = new Thread({ println 3 });\");\n        \/\/ test a directory we normally have access to, but the groovy script does not.\n        Path dir = createTempDir();\n        \/\/ TODO: figure out the necessary escaping for windows paths here :)\n        if (!Constants.WINDOWS) {\n            \/\/ access denied (\"java.io.FilePermission\" \"...\/tempDir-00N\" \"read\")\n            assertFailure(\"new File(\\\"\" + dir + \"\\\").exists()\");\n        }\n    }","code_wo_comment":"public void testEvilGroovyScripts() throws Exception {\n        int nodes = randomIntBetween(1, 3);\n        Settings nodeSettings = Settings.builder()\n                .put(\"script.inline\", true)\n                .put(\"script.indexed\", true)\n                .build();\n        internalCluster().startNodesAsync(nodes, nodeSettings).get();\n        client().admin().cluster().prepareHealth().setWaitForNodes(nodes + \"\").get();\n        client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"foo\", 5, \"bar\", \"baz\").setRefresh(true).get();\n       \n        assertSuccess(\"\");\n       \n        assertSuccess(\"def foo = doc['foo'].value; if (foo == null) { return 5; }\");\n       \n        assertSuccess(\"def bar = doc['bar'].value; if (bar == null) { return 5; }\");\n       \n        assertSuccess(\"def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)\");\n       \n        assertSuccess(\"def range = 1..doc['foo'].value; def v = range.get(0)\");\n       \n        assertSuccess(\"def v = doc['foo'].value; def m = [:]; m.put(\\\"value\\\", v)\");\n       \n        assertSuccess(\"def t = Instant.now().getMillis()\");\n       \n        assertSuccess(\"def n = [1,2,3]; GroovyCollections.max(n)\");\n       \n       \n        assertFailure(\"pr = Runtime.getRuntime().exec(\\\"touch \/tmp\/gotcha\\\"); pr.waitFor()\");\n       \n        assertFailure(\"d = new DateTime(); d.getClass().getDeclaredMethod(\\\"year\\\").setAccessible(true)\");\n        assertFailure(\"d = new DateTime(); d.\\\"${'get' + 'Class'}\\\"().\" +\n                        \"\\\"${'getDeclared' + 'Method'}\\\"(\\\"year\\\").\\\"${'set' + 'Accessible'}\\\"(false)\");\n        assertFailure(\"Class.forName(\\\"org.joda.time.DateTime\\\").getDeclaredMethod(\\\"year\\\").setAccessible(true)\");\n       \n        assertFailure(\"Eval.me('2 + 2')\");\n        assertFailure(\"Eval.x(5, 'x + 2')\");\n       \n        assertFailure(\"d = new Date(); java.lang.reflect.Field f = Date.class.getDeclaredField(\\\"fastTime\\\");\" +\n                \" f.setAccessible(true); f.get(\\\"fastTime\\\")\");\n       \n        assertFailure(\"def methodName = 'ex'; Runtime.\\\"${'get' + 'Runtime'}\\\"().\\\"${methodName}ec\\\"(\\\"touch \/tmp\/gotcha2\\\")\");\n       \n        assertFailure(\"t = new Thread({ println 3 });\");\n       \n        Path dir = createTempDir();\n       \n        if (!Constants.WINDOWS) {\n           \n            assertFailure(\"new File(\\\"\" + dir + \"\\\").exists()\");\n        }\n    }","cleancode":"public void testevilgroovyscripts() throws exception { int nodes = randomintbetween(1, 3); settings nodesettings = settings.builder() .put(\"script.inline\", true) .put(\"script.indexed\", true) .build(); internalcluster().startnodesasync(nodes, nodesettings).get(); client().admin().cluster().preparehealth().setwaitfornodes(nodes + \"\").get(); client().prepareindex(\"test\", \"doc\", \"1\").setsource(\"foo\", 5, \"bar\", \"baz\").setrefresh(true).get(); assertsuccess(\"\"); assertsuccess(\"def foo = doc['foo'].value; if (foo == null) { return 5; }\"); assertsuccess(\"def bar = doc['bar'].value; if (bar == null) { return 5; }\"); assertsuccess(\"def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)\"); assertsuccess(\"def range = 1..doc['foo'].value; def v = range.get(0)\"); assertsuccess(\"def v = doc['foo'].value; def m = [:]; m.put(\\\"value\\\", v)\"); assertsuccess(\"def t = instant.now().getmillis()\"); assertsuccess(\"def n = [1,2,3]; groovycollections.max(n)\"); assertfailure(\"pr = runtime.getruntime().exec(\\\"touch \/tmp\/gotcha\\\"); pr.waitfor()\"); assertfailure(\"d = new datetime(); d.getclass().getdeclaredmethod(\\\"year\\\").setaccessible(true)\"); assertfailure(\"d = new datetime(); d.\\\"${'get' + 'class'}\\\"().\" + \"\\\"${'getdeclared' + 'method'}\\\"(\\\"year\\\").\\\"${'set' + 'accessible'}\\\"(false)\"); assertfailure(\"class.forname(\\\"org.joda.time.datetime\\\").getdeclaredmethod(\\\"year\\\").setaccessible(true)\"); assertfailure(\"eval.me('2 + 2')\"); assertfailure(\"eval.x(5, 'x + 2')\"); assertfailure(\"d = new date(); java.lang.reflect.field f = date.class.getdeclaredfield(\\\"fasttime\\\");\" + \" f.setaccessible(true); f.get(\\\"fasttime\\\")\"); assertfailure(\"def methodname = 'ex'; runtime.\\\"${'get' + 'runtime'}\\\"().\\\"${methodname}ec\\\"(\\\"touch \/tmp\/gotcha2\\\")\"); assertfailure(\"t = new thread({ println 3 });\"); path dir = createtempdir(); if (!constants.windows) { assertfailure(\"new file(\\\"\" + dir + \"\\\").exists()\"); } }","repo":"drewr\/elasticsearch","label":[1,0,0,0]}
{"id":33296,"original_code":"private byte[] md5(String data)\n    {\n        try {\n            return this.getMd5Digest().digest(data.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            \/* This really shouldn't happen *\/\n            throw new RuntimeException(e);\n        }\n    }","code_wo_comment":"private byte[] md5(String data)\n    {\n        try {\n            return this.getMd5Digest().digest(data.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n           \n            throw new RuntimeException(e);\n        }\n    }","cleancode":"private byte[] md5(string data) { try { return this.getmd5digest().digest(data.getbytes(\"utf-8\")); } catch (unsupportedencodingexception e) { throw new runtimeexception(e); } }","repo":"dontdrinkandroot\/cache.java","label":[1,0,0,0]}
{"id":574,"original_code":"@Before\n    public void setUp() throws IOException {\n        event = TestUtils.parse(\"\/s3-event.put.json\", S3Event.class);\n        \/\/ TODO: customize your mock logic for s3 client\n        ObjectMetadata objectMetadata = new ObjectMetadata();\n        objectMetadata.setContentType(CONTENT_TYPE);\n        when(s3Object.getObjectMetadata()).thenReturn(objectMetadata);\n        when(s3Client.getObject(getObjectRequest.capture())).thenReturn(s3Object);\n    }","code_wo_comment":"@Before\n    public void setUp() throws IOException {\n        event = TestUtils.parse(\"\/s3-event.put.json\", S3Event.class);\n       \n        ObjectMetadata objectMetadata = new ObjectMetadata();\n        objectMetadata.setContentType(CONTENT_TYPE);\n        when(s3Object.getObjectMetadata()).thenReturn(objectMetadata);\n        when(s3Client.getObject(getObjectRequest.capture())).thenReturn(s3Object);\n    }","cleancode":"@before public void setup() throws ioexception { event = testutils.parse(\"\/s3-event.put.json\", s3event.class); objectmetadata objectmetadata = new objectmetadata(); objectmetadata.setcontenttype(content_type); when(s3object.getobjectmetadata()).thenreturn(objectmetadata); when(s3client.getobject(getobjectrequest.capture())).thenreturn(s3object); }","repo":"cpsloSecondScreen\/SecondScreen","label":[1,0,0,0]}
{"id":16997,"original_code":"protected void processEmbeddedMember(List<AbstractMemberMetaData> mmds, AbstractClassMetaData embCmd, ClassLoaderResolver clr, EmbeddedMetaData embmd, boolean ownerNested)\n    {\n        TypeManager typeMgr = storeMgr.getNucleusContext().getTypeManager();\n        MetaDataManager mmgr = storeMgr.getMetaDataManager();\n        NamingFactory namingFactory = storeMgr.getNamingFactory();\n        AbstractMemberMetaData lastMmd = mmds.get(mmds.size()-1);\n        \/\/ Go through all members of the embedded type\n        int[] memberPositions = embCmd.getAllMemberPositions();\n        for (int i=0;i<memberPositions.length;i++)\n        {\n            AbstractMemberMetaData mmd = embCmd.getMetaDataForManagedMemberAtAbsolutePosition(memberPositions[i]);\n            if (mmd.getPersistenceModifier() != FieldPersistenceModifier.PERSISTENT)\n            {\n                \/\/ Don't need column if not persistent\n                continue;\n            }\n            if (mmds.size() == 1 && embmd != null && embmd.getOwnerMember() != null && embmd.getOwnerMember().equals(mmd.getName()))\n            {\n                \/\/ Special case of this being a link back to the owner. TODO Repeat this for nested and their owners\n                continue;\n            }\n            AbstractMemberMetaData embmdMmd = null;\n            if (embmd != null)\n            {\n                AbstractMemberMetaData[] embmdMmds = embmd.getMemberMetaData();\n                if (embmdMmds != null)\n                {\n                    for (AbstractMemberMetaData thisMmd : embmdMmds)\n                    {\n                        if (thisMmd.getName().equals(mmd.getName()))\n                        {\n                            embmdMmd = thisMmd;\n                            break;\n                        }\n                    }\n                }\n            }\n            RelationType relationType = mmd.getRelationType(clr);\n            if (relationType != RelationType.NONE && MetaDataUtils.getInstance().isMemberEmbedded(mmgr, clr, mmd, relationType, lastMmd))\n            {\n                if (RelationType.isRelationSingleValued(relationType))\n                {\n                    \/\/ Nested embedded PC, so recurse\n                    boolean nested = false;\n                    if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_PC_NESTED))\n                    {\n                        nested = !storeMgr.getNucleusContext().getConfiguration().getBooleanProperty(PropertyNames.PROPERTY_METADATA_EMBEDDED_PC_FLAT);\n                        String nestedStr = mmd.getValueForExtension(\"nested\");\n                        if (nestedStr != null && nestedStr.equalsIgnoreCase(\"\" + !nested))\n                        {\n                            nested = !nested;\n                        }\n                    }\n                    List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                    embMmds.add(mmd);\n                    if (nested)\n                    {\n                        \/\/ Embedded object stored as nested under this in the owner table (where the datastore supports that)\n                        \/\/ Add column for the owner of the embedded object, typically for the column name only\n                        ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                        String colName = namingFactory.getColumnName(embMmds, 0);\n                        ColumnImpl col = addEmbeddedColumn(colName, null);\n                        col.setNested(true);\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                        {\n                            col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                        {\n                            col.setPosition(colmds[0].getPosition());\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(colmds[0].getJdbcType());\n                        }\n                        MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                        col.setMemberColumnMapping(mapping);\n                        if (schemaVerifier != null)\n                        {\n                            schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                        }\n                        mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                        \/\/ TODO Create mapping for the related info under the above column\n                    }\n                    \/\/ Recurse through the embedded member\n                    processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, nested);\n                }\n                else\n                {\n                    if (mmd.hasCollection())\n                    {\n                        \/\/ Nested embedded collection, so recurse\n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_COLLECTION_NESTED))\n                        {\n                            List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                            embMmds.add(mmd);\n                            \/\/ Add column for the collection (since the store needs a name to reference it by)\n                            ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, null);\n                            col.setNested(true);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                            \/\/ TODO Create mapping for the related info under the above column\n                            \/\/ Recurse through the embedded collection element\n                            processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getCollection().getElementType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, true);\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded collection. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                    else if (mmd.hasMap())\n                    {\n                        \/\/ Nested embedded map, so recurse\n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_MAP_NESTED))\n                        {\n                            \/\/ TODO Support nested embedded map key\/value\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded map. Not yet supported so ignoring\");\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded map. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                    else if (mmd.hasArray())\n                    {\n                        \/\/ Nested embedded array, so recurse\n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_ARRAY_NESTED))\n                        {\n                            List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                            embMmds.add(mmd);\n                            \/\/ Add column for the array (since the store needs a name to reference it by) TODO Extract this block out and reuse it\n                            ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, null);\n                            col.setNested(true);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                            \/\/ TODO Create mapping for the related info under the above column\n                            \/\/ Recurse through the embedded array element\n                            processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getArray().getElementType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, true);\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded array. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                embMmds.add(mmd);\n                ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                if (relationType != RelationType.NONE)\n                {\n                    \/\/ 1-1\/N-1 stored as single column with persistable-id\n                    \/\/ 1-N\/M-N stored as single column with collection<persistable-id>\n                    \/\/ Create column for basic type\n                    String colName = namingFactory.getColumnName(embMmds, 0);\n                    ColumnImpl col = addEmbeddedColumn(colName, null);\n                    col.setNested(ownerNested);\n                    if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                    {\n                        col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                    }\n                    else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                    {\n                        col.setPosition(colmds[0].getPosition());\n                    }\n                    if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                    {\n                        col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                    }\n                    else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                    {\n                        col.setJdbcType(colmds[0].getJdbcType());\n                    }\n                    MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                    col.setMemberColumnMapping(mapping);\n                    if (schemaVerifier != null)\n                    {\n                        schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                    }\n                    mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                }\n                else\n                {\n                    TypeConverter typeConv = getTypeConverterForMember(mmd, colmds, typeMgr); \/\/ TODO Pass in embedded colmds if they have jdbcType info?\n                    if (typeConv != null)\n                    {\n                        \/\/ Create column(s) for this type using a TypeConverter\n                        if (typeConv instanceof MultiColumnConverter)\n                        {\n                            Class[] colJavaTypes = ((MultiColumnConverter)typeConv).getDatastoreColumnTypes();\n                            Column[] cols = new Column[colJavaTypes.length];\n                            for (int j=0;j<colJavaTypes.length;j++)\n                            {\n                                String colName = namingFactory.getColumnName(embMmds, j);\n                                ColumnImpl col = addEmbeddedColumn(colName, typeConv);\n                                col.setNested(ownerNested);\n                                if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == colJavaTypes.length && embmdMmd.getColumnMetaData()[j].getPosition() != null)\n                                {\n                                    col.setPosition(embmdMmd.getColumnMetaData()[j].getPosition());\n                                }\n                                else if (colmds != null && colmds.length == colJavaTypes.length && colmds[j].getPosition() != null)\n                                {\n                                    col.setPosition(colmds[j].getPosition());\n                                }\n                                if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == colJavaTypes.length && embmdMmd.getColumnMetaData()[j].getJdbcType() != null)\n                                {\n                                    col.setJdbcType(embmdMmd.getColumnMetaData()[j].getJdbcType());\n                                }\n                                else if (colmds != null && colmds.length == colJavaTypes.length && colmds[j].getJdbcType() != null)\n                                {\n                                    col.setJdbcType(colmds[j].getJdbcType());\n                                }\n                                cols[j] = col;\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, cols, typeConv);\n                            for (int j=0;j<colJavaTypes.length;j++)\n                            {\n                                ((ColumnImpl)cols[j]).setMemberColumnMapping(mapping);\n                            }\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                        }\n                        else\n                        {\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, typeConv);\n                            col.setNested(ownerNested);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            mapping.setTypeConverter(typeConv);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                        }\n                    }\n                    else\n                    {\n                        \/\/ Create column for basic type\n                        String colName = namingFactory.getColumnName(embMmds, 0);\n                        ColumnImpl col = addEmbeddedColumn(colName, null);\n                        col.setNested(ownerNested);\n                        AbstractMemberMetaData theMmd = embMmds.get(0);\n                        if (theMmd.isPrimaryKey())\n                        {\n                            col.setPrimaryKey();\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                        {\n                            col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                        {\n                            col.setPosition(colmds[0].getPosition());\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(colmds[0].getJdbcType());\n                        }\n                        MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                        col.setMemberColumnMapping(mapping);\n                        if (schemaVerifier != null)\n                        {\n                            schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                        }\n                        mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"protected void processEmbeddedMember(List<AbstractMemberMetaData> mmds, AbstractClassMetaData embCmd, ClassLoaderResolver clr, EmbeddedMetaData embmd, boolean ownerNested)\n    {\n        TypeManager typeMgr = storeMgr.getNucleusContext().getTypeManager();\n        MetaDataManager mmgr = storeMgr.getMetaDataManager();\n        NamingFactory namingFactory = storeMgr.getNamingFactory();\n        AbstractMemberMetaData lastMmd = mmds.get(mmds.size()-1);\n       \n        int[] memberPositions = embCmd.getAllMemberPositions();\n        for (int i=0;i<memberPositions.length;i++)\n        {\n            AbstractMemberMetaData mmd = embCmd.getMetaDataForManagedMemberAtAbsolutePosition(memberPositions[i]);\n            if (mmd.getPersistenceModifier() != FieldPersistenceModifier.PERSISTENT)\n            {\n               \n                continue;\n            }\n            if (mmds.size() == 1 && embmd != null && embmd.getOwnerMember() != null && embmd.getOwnerMember().equals(mmd.getName()))\n            {\n               \n                continue;\n            }\n            AbstractMemberMetaData embmdMmd = null;\n            if (embmd != null)\n            {\n                AbstractMemberMetaData[] embmdMmds = embmd.getMemberMetaData();\n                if (embmdMmds != null)\n                {\n                    for (AbstractMemberMetaData thisMmd : embmdMmds)\n                    {\n                        if (thisMmd.getName().equals(mmd.getName()))\n                        {\n                            embmdMmd = thisMmd;\n                            break;\n                        }\n                    }\n                }\n            }\n            RelationType relationType = mmd.getRelationType(clr);\n            if (relationType != RelationType.NONE && MetaDataUtils.getInstance().isMemberEmbedded(mmgr, clr, mmd, relationType, lastMmd))\n            {\n                if (RelationType.isRelationSingleValued(relationType))\n                {\n                   \n                    boolean nested = false;\n                    if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_PC_NESTED))\n                    {\n                        nested = !storeMgr.getNucleusContext().getConfiguration().getBooleanProperty(PropertyNames.PROPERTY_METADATA_EMBEDDED_PC_FLAT);\n                        String nestedStr = mmd.getValueForExtension(\"nested\");\n                        if (nestedStr != null && nestedStr.equalsIgnoreCase(\"\" + !nested))\n                        {\n                            nested = !nested;\n                        }\n                    }\n                    List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                    embMmds.add(mmd);\n                    if (nested)\n                    {\n                       \n                       \n                        ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                        String colName = namingFactory.getColumnName(embMmds, 0);\n                        ColumnImpl col = addEmbeddedColumn(colName, null);\n                        col.setNested(true);\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                        {\n                            col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                        {\n                            col.setPosition(colmds[0].getPosition());\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(colmds[0].getJdbcType());\n                        }\n                        MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                        col.setMemberColumnMapping(mapping);\n                        if (schemaVerifier != null)\n                        {\n                            schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                        }\n                        mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                       \n                    }\n                   \n                    processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, nested);\n                }\n                else\n                {\n                    if (mmd.hasCollection())\n                    {\n                       \n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_COLLECTION_NESTED))\n                        {\n                            List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                            embMmds.add(mmd);\n                           \n                            ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, null);\n                            col.setNested(true);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                           \n                           \n                            processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getCollection().getElementType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, true);\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded collection. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                    else if (mmd.hasMap())\n                    {\n                       \n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_MAP_NESTED))\n                        {\n                           \n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded map. Not yet supported so ignoring\");\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded map. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                    else if (mmd.hasArray())\n                    {\n                       \n                        if (storeMgr.getSupportedOptions().contains(StoreManager.OPTION_ORM_EMBEDDED_ARRAY_NESTED))\n                        {\n                            List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                            embMmds.add(mmd);\n                           \n                            ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, null);\n                            col.setNested(true);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                           \n                           \n                            processEmbeddedMember(embMmds, mmgr.getMetaDataForClass(mmd.getArray().getElementType(), clr), clr, embmdMmd != null ? embmdMmd.getEmbeddedMetaData() : null, true);\n                        }\n                        else\n                        {\n                            NucleusLogger.DATASTORE_SCHEMA.warn(\"Member \" + mmd.getFullFieldName() + \" is a (nested) embedded array. Not supported for this datastore so ignoring\");\n                            continue;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                List<AbstractMemberMetaData> embMmds = new ArrayList<AbstractMemberMetaData>(mmds);\n                embMmds.add(mmd);\n                ColumnMetaData[] colmds = mmd.getColumnMetaData();\n                if (relationType != RelationType.NONE)\n                {\n                   \n                   \n                   \n                    String colName = namingFactory.getColumnName(embMmds, 0);\n                    ColumnImpl col = addEmbeddedColumn(colName, null);\n                    col.setNested(ownerNested);\n                    if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                    {\n                        col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                    }\n                    else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                    {\n                        col.setPosition(colmds[0].getPosition());\n                    }\n                    if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                    {\n                        col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                    }\n                    else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                    {\n                        col.setJdbcType(colmds[0].getJdbcType());\n                    }\n                    MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                    col.setMemberColumnMapping(mapping);\n                    if (schemaVerifier != null)\n                    {\n                        schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                    }\n                    mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                }\n                else\n                {\n                    TypeConverter typeConv = getTypeConverterForMember(mmd, colmds, typeMgr);\n                    if (typeConv != null)\n                    {\n                       \n                        if (typeConv instanceof MultiColumnConverter)\n                        {\n                            Class[] colJavaTypes = ((MultiColumnConverter)typeConv).getDatastoreColumnTypes();\n                            Column[] cols = new Column[colJavaTypes.length];\n                            for (int j=0;j<colJavaTypes.length;j++)\n                            {\n                                String colName = namingFactory.getColumnName(embMmds, j);\n                                ColumnImpl col = addEmbeddedColumn(colName, typeConv);\n                                col.setNested(ownerNested);\n                                if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == colJavaTypes.length && embmdMmd.getColumnMetaData()[j].getPosition() != null)\n                                {\n                                    col.setPosition(embmdMmd.getColumnMetaData()[j].getPosition());\n                                }\n                                else if (colmds != null && colmds.length == colJavaTypes.length && colmds[j].getPosition() != null)\n                                {\n                                    col.setPosition(colmds[j].getPosition());\n                                }\n                                if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == colJavaTypes.length && embmdMmd.getColumnMetaData()[j].getJdbcType() != null)\n                                {\n                                    col.setJdbcType(embmdMmd.getColumnMetaData()[j].getJdbcType());\n                                }\n                                else if (colmds != null && colmds.length == colJavaTypes.length && colmds[j].getJdbcType() != null)\n                                {\n                                    col.setJdbcType(colmds[j].getJdbcType());\n                                }\n                                cols[j] = col;\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, cols, typeConv);\n                            for (int j=0;j<colJavaTypes.length;j++)\n                            {\n                                ((ColumnImpl)cols[j]).setMemberColumnMapping(mapping);\n                            }\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                        }\n                        else\n                        {\n                            String colName = namingFactory.getColumnName(embMmds, 0);\n                            ColumnImpl col = addEmbeddedColumn(colName, typeConv);\n                            col.setNested(ownerNested);\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                            {\n                                col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                            {\n                                col.setPosition(colmds[0].getPosition());\n                            }\n                            if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                            }\n                            else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                            {\n                                col.setJdbcType(colmds[0].getJdbcType());\n                            }\n                            MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                            col.setMemberColumnMapping(mapping);\n                            mapping.setTypeConverter(typeConv);\n                            if (schemaVerifier != null)\n                            {\n                                schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                            }\n                            mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                        }\n                    }\n                    else\n                    {\n                       \n                        String colName = namingFactory.getColumnName(embMmds, 0);\n                        ColumnImpl col = addEmbeddedColumn(colName, null);\n                        col.setNested(ownerNested);\n                        AbstractMemberMetaData theMmd = embMmds.get(0);\n                        if (theMmd.isPrimaryKey())\n                        {\n                            col.setPrimaryKey();\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getPosition() != null)\n                        {\n                            col.setPosition(embmdMmd.getColumnMetaData()[0].getPosition());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getPosition() != null)\n                        {\n                            col.setPosition(colmds[0].getPosition());\n                        }\n                        if (embmdMmd != null && embmdMmd.getColumnMetaData() != null && embmdMmd.getColumnMetaData().length == 1 && embmdMmd.getColumnMetaData()[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(embmdMmd.getColumnMetaData()[0].getJdbcType());\n                        }\n                        else if (colmds != null && colmds.length == 1 && colmds[0].getJdbcType() != null)\n                        {\n                            col.setJdbcType(colmds[0].getJdbcType());\n                        }\n                        MemberColumnMapping mapping = new MemberColumnMappingImpl(mmd, col);\n                        col.setMemberColumnMapping(mapping);\n                        if (schemaVerifier != null)\n                        {\n                            schemaVerifier.attributeEmbeddedMember(mapping, embMmds);\n                        }\n                        mappingByEmbeddedMember.put(getEmbeddedMemberNavigatedPath(embMmds), mapping);\n                    }\n                }\n            }\n        }\n    }","cleancode":"protected void processembeddedmember(list<abstractmembermetadata> mmds, abstractclassmetadata embcmd, classloaderresolver clr, embeddedmetadata embmd, boolean ownernested) { typemanager typemgr = storemgr.getnucleuscontext().gettypemanager(); metadatamanager mmgr = storemgr.getmetadatamanager(); namingfactory namingfactory = storemgr.getnamingfactory(); abstractmembermetadata lastmmd = mmds.get(mmds.size()-1); int[] memberpositions = embcmd.getallmemberpositions(); for (int i=0;i<memberpositions.length;i++) { abstractmembermetadata mmd = embcmd.getmetadataformanagedmemberatabsoluteposition(memberpositions[i]); if (mmd.getpersistencemodifier() != fieldpersistencemodifier.persistent) { continue; } if (mmds.size() == 1 && embmd != null && embmd.getownermember() != null && embmd.getownermember().equals(mmd.getname())) { continue; } abstractmembermetadata embmdmmd = null; if (embmd != null) { abstractmembermetadata[] embmdmmds = embmd.getmembermetadata(); if (embmdmmds != null) { for (abstractmembermetadata thismmd : embmdmmds) { if (thismmd.getname().equals(mmd.getname())) { embmdmmd = thismmd; break; } } } } relationtype relationtype = mmd.getrelationtype(clr); if (relationtype != relationtype.none && metadatautils.getinstance().ismemberembedded(mmgr, clr, mmd, relationtype, lastmmd)) { if (relationtype.isrelationsinglevalued(relationtype)) { boolean nested = false; if (storemgr.getsupportedoptions().contains(storemanager.option_orm_embedded_pc_nested)) { nested = !storemgr.getnucleuscontext().getconfiguration().getbooleanproperty(propertynames.property_metadata_embedded_pc_flat); string nestedstr = mmd.getvalueforextension(\"nested\"); if (nestedstr != null && nestedstr.equalsignorecase(\"\" + !nested)) { nested = !nested; } } list<abstractmembermetadata> embmmds = new arraylist<abstractmembermetadata>(mmds); embmmds.add(mmd); if (nested) { columnmetadata[] colmds = mmd.getcolumnmetadata(); string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, null); col.setnested(true); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); } processembeddedmember(embmmds, mmgr.getmetadataforclass(mmd.gettype(), clr), clr, embmdmmd != null ? embmdmmd.getembeddedmetadata() : null, nested); } else { if (mmd.hascollection()) { if (storemgr.getsupportedoptions().contains(storemanager.option_orm_embedded_collection_nested)) { list<abstractmembermetadata> embmmds = new arraylist<abstractmembermetadata>(mmds); embmmds.add(mmd); columnmetadata[] colmds = mmd.getcolumnmetadata(); string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, null); col.setnested(true); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); processembeddedmember(embmmds, mmgr.getmetadataforclass(mmd.getcollection().getelementtype(), clr), clr, embmdmmd != null ? embmdmmd.getembeddedmetadata() : null, true); } else { nucleuslogger.datastore_schema.warn(\"member \" + mmd.getfullfieldname() + \" is a (nested) embedded collection. not supported for this datastore so ignoring\"); continue; } } else if (mmd.hasmap()) { if (storemgr.getsupportedoptions().contains(storemanager.option_orm_embedded_map_nested)) { nucleuslogger.datastore_schema.warn(\"member \" + mmd.getfullfieldname() + \" is a (nested) embedded map. not yet supported so ignoring\"); } else { nucleuslogger.datastore_schema.warn(\"member \" + mmd.getfullfieldname() + \" is a (nested) embedded map. not supported for this datastore so ignoring\"); continue; } } else if (mmd.hasarray()) { if (storemgr.getsupportedoptions().contains(storemanager.option_orm_embedded_array_nested)) { list<abstractmembermetadata> embmmds = new arraylist<abstractmembermetadata>(mmds); embmmds.add(mmd); columnmetadata[] colmds = mmd.getcolumnmetadata(); string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, null); col.setnested(true); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); processembeddedmember(embmmds, mmgr.getmetadataforclass(mmd.getarray().getelementtype(), clr), clr, embmdmmd != null ? embmdmmd.getembeddedmetadata() : null, true); } else { nucleuslogger.datastore_schema.warn(\"member \" + mmd.getfullfieldname() + \" is a (nested) embedded array. not supported for this datastore so ignoring\"); continue; } } } } else { list<abstractmembermetadata> embmmds = new arraylist<abstractmembermetadata>(mmds); embmmds.add(mmd); columnmetadata[] colmds = mmd.getcolumnmetadata(); if (relationtype != relationtype.none) { string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, null); col.setnested(ownernested); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); } else { typeconverter typeconv = gettypeconverterformember(mmd, colmds, typemgr); if (typeconv != null) { if (typeconv instanceof multicolumnconverter) { class[] coljavatypes = ((multicolumnconverter)typeconv).getdatastorecolumntypes(); column[] cols = new column[coljavatypes.length]; for (int j=0;j<coljavatypes.length;j++) { string colname = namingfactory.getcolumnname(embmmds, j); columnimpl col = addembeddedcolumn(colname, typeconv); col.setnested(ownernested); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == coljavatypes.length && embmdmmd.getcolumnmetadata()[j].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[j].getposition()); } else if (colmds != null && colmds.length == coljavatypes.length && colmds[j].getposition() != null) { col.setposition(colmds[j].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == coljavatypes.length && embmdmmd.getcolumnmetadata()[j].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[j].getjdbctype()); } else if (colmds != null && colmds.length == coljavatypes.length && colmds[j].getjdbctype() != null) { col.setjdbctype(colmds[j].getjdbctype()); } cols[j] = col; } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, cols, typeconv); for (int j=0;j<coljavatypes.length;j++) { ((columnimpl)cols[j]).setmembercolumnmapping(mapping); } if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); } else { string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, typeconv); col.setnested(ownernested); if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); mapping.settypeconverter(typeconv); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); } } else { string colname = namingfactory.getcolumnname(embmmds, 0); columnimpl col = addembeddedcolumn(colname, null); col.setnested(ownernested); abstractmembermetadata themmd = embmmds.get(0); if (themmd.isprimarykey()) { col.setprimarykey(); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getposition() != null) { col.setposition(embmdmmd.getcolumnmetadata()[0].getposition()); } else if (colmds != null && colmds.length == 1 && colmds[0].getposition() != null) { col.setposition(colmds[0].getposition()); } if (embmdmmd != null && embmdmmd.getcolumnmetadata() != null && embmdmmd.getcolumnmetadata().length == 1 && embmdmmd.getcolumnmetadata()[0].getjdbctype() != null) { col.setjdbctype(embmdmmd.getcolumnmetadata()[0].getjdbctype()); } else if (colmds != null && colmds.length == 1 && colmds[0].getjdbctype() != null) { col.setjdbctype(colmds[0].getjdbctype()); } membercolumnmapping mapping = new membercolumnmappingimpl(mmd, col); col.setmembercolumnmapping(mapping); if (schemaverifier != null) { schemaverifier.attributeembeddedmember(mapping, embmmds); } mappingbyembeddedmember.put(getembeddedmembernavigatedpath(embmmds), mapping); } } } } }","repo":"dcheung2\/datanucleus-core","label":[1,1,0,0]}
{"id":17020,"original_code":"String probeGemHomeForTesting() {\n        return this.gemHome;\n    }","code_wo_comment":"String probeGemHomeForTesting() {\n        return this.gemHome;\n    }","cleancode":"string probegemhomefortesting() { return this.gemhome; }","repo":"dmikurube\/embulk","label":[0,1,0,0]}
{"id":8997,"original_code":"protected void visit(final RuleDescr descr) {\n        \/\/ This is the NAME of the rule, not a reference to it!!\n        String ruleName = getPackagePrefix() + descr.getName();\n        addResource(ruleName,\n                    ResourceType.RULE);\n        \/\/ This is, on other hand, is a reference to the parent rule (because it's used in inheritance)\n        String parentRuleName = descr.getParentName();\n        if (parentRuleName != null) {\n            addResourceReference(parentRuleName,\n                                 ResourceType.RULE);\n        }\n        for (AttributeDescr d : descr.getAttributes().values()) {\n            visit(d);\n        }\n        visit(descr.getLhs());\n        visitConsequence(descr.getConsequence()); \/\/ need compilation for this..\n        for (String namedConsequence : descr.getNamedConsequences().keySet()) {\n            \/\/ TODO\n            \/\/ ? addResourceReference(namedConsequence, PartType.NAMED_CONSEQUENCE);\n        }\n        visitAnnos(descr);\n    }","code_wo_comment":"protected void visit(final RuleDescr descr) {\n       \n        String ruleName = getPackagePrefix() + descr.getName();\n        addResource(ruleName,\n                    ResourceType.RULE);\n       \n        String parentRuleName = descr.getParentName();\n        if (parentRuleName != null) {\n            addResourceReference(parentRuleName,\n                                 ResourceType.RULE);\n        }\n        for (AttributeDescr d : descr.getAttributes().values()) {\n            visit(d);\n        }\n        visit(descr.getLhs());\n        visitConsequence(descr.getConsequence());\n        for (String namedConsequence : descr.getNamedConsequences().keySet()) {\n           \n           \n        }\n        visitAnnos(descr);\n    }","cleancode":"protected void visit(final ruledescr descr) { string rulename = getpackageprefix() + descr.getname(); addresource(rulename, resourcetype.rule); string parentrulename = descr.getparentname(); if (parentrulename != null) { addresourcereference(parentrulename, resourcetype.rule); } for (attributedescr d : descr.getattributes().values()) { visit(d); } visit(descr.getlhs()); visitconsequence(descr.getconsequence()); for (string namedconsequence : descr.getnamedconsequences().keyset()) { } visitannos(descr); }","repo":"etirelli\/kie-wb-common","label":[0,0,0,0]}
{"id":832,"original_code":"public Raster getRaster(int xOffset, int yOffset, int w, int h) {\n            ColorModel cm = getColorModel();\n            if (raster == null) createRaster();\n            \/\/ TODO: eventually use caching here\n            WritableRaster childRaster = cm.createCompatibleWritableRaster(w, h);\n            Rectangle2D childRect = new Rectangle2D.Double(xOffset, yOffset, w, h);\n            if (!childRect.intersects(deviceBounds)) {\n                \/\/ usually doesn't happen ...\n                return childRaster;\n            }\n            Rectangle2D destRect = new Rectangle2D.Double();\n            Rectangle2D.intersect(childRect, deviceBounds, destRect);\n            int dx = (int)(destRect.getX()-deviceBounds.getX());\n            int dy = (int)(destRect.getY()-deviceBounds.getY());\n            int dw = (int)destRect.getWidth();\n            int dh = (int)destRect.getHeight();\n            Object data = raster.getDataElements(dx, dy, dw, dh, null);\n            dx = (int)(destRect.getX()-childRect.getX());\n            dy = (int)(destRect.getY()-childRect.getY());\n            childRaster.setDataElements(dx, dy, dw, dh, data);\n            return childRaster;\n        }","code_wo_comment":"public Raster getRaster(int xOffset, int yOffset, int w, int h) {\n            ColorModel cm = getColorModel();\n            if (raster == null) createRaster();\n           \n            WritableRaster childRaster = cm.createCompatibleWritableRaster(w, h);\n            Rectangle2D childRect = new Rectangle2D.Double(xOffset, yOffset, w, h);\n            if (!childRect.intersects(deviceBounds)) {\n               \n                return childRaster;\n            }\n            Rectangle2D destRect = new Rectangle2D.Double();\n            Rectangle2D.intersect(childRect, deviceBounds, destRect);\n            int dx = (int)(destRect.getX()-deviceBounds.getX());\n            int dy = (int)(destRect.getY()-deviceBounds.getY());\n            int dw = (int)destRect.getWidth();\n            int dh = (int)destRect.getHeight();\n            Object data = raster.getDataElements(dx, dy, dw, dh, null);\n            dx = (int)(destRect.getX()-childRect.getX());\n            dy = (int)(destRect.getY()-childRect.getY());\n            childRaster.setDataElements(dx, dy, dw, dh, data);\n            return childRaster;\n        }","cleancode":"public raster getraster(int xoffset, int yoffset, int w, int h) { colormodel cm = getcolormodel(); if (raster == null) createraster(); writableraster childraster = cm.createcompatiblewritableraster(w, h); rectangle2d childrect = new rectangle2d.double(xoffset, yoffset, w, h); if (!childrect.intersects(devicebounds)) { return childraster; } rectangle2d destrect = new rectangle2d.double(); rectangle2d.intersect(childrect, devicebounds, destrect); int dx = (int)(destrect.getx()-devicebounds.getx()); int dy = (int)(destrect.gety()-devicebounds.gety()); int dw = (int)destrect.getwidth(); int dh = (int)destrect.getheight(); object data = raster.getdataelements(dx, dy, dw, dh, null); dx = (int)(destrect.getx()-childrect.getx()); dy = (int)(destrect.gety()-childrect.gety()); childraster.setdataelements(dx, dy, dw, dh, data); return childraster; }","repo":"fomich-artem\/poi","label":[1,0,0,0]}
{"id":17336,"original_code":"@Test(expected = TaskExecutionException.class)\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n    \/\/ ToDo: Need to rewrite.\n    public void Should_throwWhenAnotherTaskIsBeingExecuted()\n            throws Exception {\n        thread.execute(() -> {\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                thread.interrupt();\n            }\n        });\n        thread.execute(mock(ITask.class));\n    }","code_wo_comment":"@Test(expected = TaskExecutionException.class)\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n   \n    public void Should_throwWhenAnotherTaskIsBeingExecuted()\n            throws Exception {\n        thread.execute(() -> {\n            try {\n                Thread.sleep(200);\n            } catch (InterruptedException e) {\n                thread.interrupt();\n            }\n        });\n        thread.execute(mock(ITask.class));\n    }","cleancode":"@test(expected = taskexecutionexception.class) @ignore(\"test execution is depending on server technical characteristics.\") public void should_throwwhenanothertaskisbeingexecuted() throws exception { thread.execute(() -> { try { thread.sleep(200); } catch (interruptedexception e) { thread.interrupt(); } }); thread.execute(mock(itask.class)); }","repo":"d-protsenko\/smartactors-core","label":[0,1,0,0]}
{"id":17337,"original_code":"@Test(expected = TaskExecutionException.class)\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n    \/\/ ToDo: Need to rewrite.\n    public void Should_throwWhenThreadIsNotAlive()\n            throws Exception {\n        ITask taskMock = mock(ITask.class);\n        thread.interrupt();\n        thread.execute(taskMock);\n        fail();\n    }","code_wo_comment":"@Test(expected = TaskExecutionException.class)\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n   \n    public void Should_throwWhenThreadIsNotAlive()\n            throws Exception {\n        ITask taskMock = mock(ITask.class);\n        thread.interrupt();\n        thread.execute(taskMock);\n        fail();\n    }","cleancode":"@test(expected = taskexecutionexception.class) @ignore(\"test execution is depending on server technical characteristics.\") public void should_throwwhenthreadisnotalive() throws exception { itask taskmock = mock(itask.class); thread.interrupt(); thread.execute(taskmock); fail(); }","repo":"d-protsenko\/smartactors-core","label":[0,1,0,0]}
{"id":17338,"original_code":"@Test\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n    \/\/ ToDo: Need to rewrite.\n    public void Should_ignoreExceptionsFromTask()\n            throws Exception {\n        ITask taskMock1 = mock(ITask.class), taskMock2 = mock(ITask.class);\n        doThrow(new TaskExecutionException(\"Whoops!\")).when(taskMock1).execute();\n        thread.execute(taskMock1);\n        verify(taskMock1, timeout(100)).execute();\n        Thread.sleep(200);\n        thread.execute(taskMock2);\n        verify(taskMock2, timeout(100)).execute();    }","code_wo_comment":"@Test\n    @Ignore(\"Test execution is depending on server technical characteristics.\")\n   \n    public void Should_ignoreExceptionsFromTask()\n            throws Exception {\n        ITask taskMock1 = mock(ITask.class), taskMock2 = mock(ITask.class);\n        doThrow(new TaskExecutionException(\"Whoops!\")).when(taskMock1).execute();\n        thread.execute(taskMock1);\n        verify(taskMock1, timeout(100)).execute();\n        Thread.sleep(200);\n        thread.execute(taskMock2);\n        verify(taskMock2, timeout(100)).execute();    }","cleancode":"@test @ignore(\"test execution is depending on server technical characteristics.\") public void should_ignoreexceptionsfromtask() throws exception { itask taskmock1 = mock(itask.class), taskmock2 = mock(itask.class); dothrow(new taskexecutionexception(\"whoops!\")).when(taskmock1).execute(); thread.execute(taskmock1); verify(taskmock1, timeout(100)).execute(); thread.sleep(200); thread.execute(taskmock2); verify(taskmock2, timeout(100)).execute(); }","repo":"d-protsenko\/smartactors-core","label":[0,1,0,0]}
{"id":25637,"original_code":"@Override\n    double getTurnInput(HumanInput humanInput) {\n        \/\/ TODO: Maybe sine curve is more appropriate for turning?\n        \/\/ Pass the raw turn value through an input curve, then apply the turn sensitivity.\n        return Util.applyInputCurve(humanInput.getGamePad().rs().getHorizontal(), .75, 3) * turnSensitivity;\n    }","code_wo_comment":"@Override\n    double getTurnInput(HumanInput humanInput) {\n       \n       \n        return Util.applyInputCurve(humanInput.getGamePad().rs().getHorizontal(), .75, 3) * turnSensitivity;\n    }","cleancode":"@override double getturninput(humaninput humaninput) { return util.applyinputcurve(humaninput.getgamepad().rs().gethorizontal(), .75, 3) * turnsensitivity; }","repo":"first-1251\/exp-drive","label":[1,0,0,0]}
{"id":17495,"original_code":"public ReloadableType getSuperRtype() {\n\t\tif (superRtype != null) {\n\t\t\treturn superRtype;\n\t\t}\n\t\tif (superclazz == null) {\n\t\t\t\/\/ Not filled in yet? Why is this code different to the interface case?\n\t\t\tString name = this.getSlashedSupertypeName();\n\t\t\tif (name == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tReloadableType rtype = typeRegistry.getReloadableSuperType(name);\n\t\t\t\tsuperRtype = rtype;\n\t\t\t\treturn superRtype;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tClassLoader superClassLoader = superclazz.getClassLoader();\n\t\t\tTypeRegistry superTypeRegistry = TypeRegistry.getTypeRegistryFor(superClassLoader);\n\t\t\tsuperRtype = superTypeRegistry.getReloadableType(superclazz);\n\t\t\treturn superRtype;\n\t\t}\n\t}","code_wo_comment":"public ReloadableType getSuperRtype() {\n\t\tif (superRtype != null) {\n\t\t\treturn superRtype;\n\t\t}\n\t\tif (superclazz == null) {\n\t\t\n\t\t\tString name = this.getSlashedSupertypeName();\n\t\t\tif (name == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tReloadableType rtype = typeRegistry.getReloadableSuperType(name);\n\t\t\t\tsuperRtype = rtype;\n\t\t\t\treturn superRtype;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tClassLoader superClassLoader = superclazz.getClassLoader();\n\t\t\tTypeRegistry superTypeRegistry = TypeRegistry.getTypeRegistryFor(superClassLoader);\n\t\t\tsuperRtype = superTypeRegistry.getReloadableType(superclazz);\n\t\t\treturn superRtype;\n\t\t}\n\t}","cleancode":"public reloadabletype getsuperrtype() { if (superrtype != null) { return superrtype; } if (superclazz == null) { string name = this.getslashedsupertypename(); if (name == null) { return null; } else { reloadabletype rtype = typeregistry.getreloadablesupertype(name); superrtype = rtype; return superrtype; } } else { classloader superclassloader = superclazz.getclassloader(); typeregistry supertyperegistry = typeregistry.gettyperegistryfor(superclassloader); superrtype = supertyperegistry.getreloadabletype(superclazz); return superrtype; } }","repo":"crudolf\/spring-loaded","label":[1,0,0,0]}
{"id":33952,"original_code":"public boolean waitForExpectedReplicaMap(final long timeoutMs, YBTable table,\n                                            Map<String, List<List<Integer>>> replicaMapExpected) {\n    Condition replicaMapCondition = new ReplicaMapCondition(table, replicaMapExpected, timeoutMs);\n    return waitForCondition(replicaMapCondition, timeoutMs);\n  }","code_wo_comment":"public boolean waitForExpectedReplicaMap(final long timeoutMs, YBTable table,\n                                            Map<String, List<List<Integer>>> replicaMapExpected) {\n    Condition replicaMapCondition = new ReplicaMapCondition(table, replicaMapExpected, timeoutMs);\n    return waitForCondition(replicaMapCondition, timeoutMs);\n  }","cleancode":"public boolean waitforexpectedreplicamap(final long timeoutms, ybtable table, map<string, list<list<integer>>> replicamapexpected) { condition replicamapcondition = new replicamapcondition(table, replicamapexpected, timeoutms); return waitforcondition(replicamapcondition, timeoutms); }","repo":"def-\/yugabyte-db","label":[1,0,0,0]}
{"id":25790,"original_code":"@Test\n\tpublic void testBlowingUpWithDuplicateLoaders() {\n\t\tKeyValuePairLoader kvpl = new KeyValuePairLoader();\n\t\tkvpl.setKeyValuePairs(cmdLineArgsWFullClassName);\n\t\ttry {\n\t\t\tAndHowConfiguration config = AndHowTestConfig.instance()\n\t\t\t\t.setLoaders(kvpl, kvpl)\n\t\t\t\t.addOverrideGroups(configPtGroups);\n\t\t\tAndHow.setConfig(config);\n\t\t\tAndHow.instance();\n\t\t\tfail();\t\/\/The line above should throw an error\n\t\t} catch (AppFatalException ce) {\n\t\t\tassertEquals(1, ce.getProblems().filter(ConstructionProblem.class).size());\n\t\t\tassertTrue(ce.getProblems().filter(ConstructionProblem.class).get(0) instanceof ConstructionProblem.DuplicateLoader);\n\t\t\tConstructionProblem.DuplicateLoader dl = (ConstructionProblem.DuplicateLoader)ce.getProblems().filter(ConstructionProblem.class).get(0);\n\t\t\tassertEquals(kvpl, dl.getLoader());\n\t\t\tassertTrue(ce.getSampleDirectory().length() > 0);\n\t\t\tFile sampleDir = new File(ce.getSampleDirectory());\n\t\t\tassertTrue(sampleDir.exists());\n\t\t\tassertTrue(sampleDir.listFiles().length > 0);\n\t\t}\n\t}","code_wo_comment":"@Test\n\tpublic void testBlowingUpWithDuplicateLoaders() {\n\t\tKeyValuePairLoader kvpl = new KeyValuePairLoader();\n\t\tkvpl.setKeyValuePairs(cmdLineArgsWFullClassName);\n\t\ttry {\n\t\t\tAndHowConfiguration config = AndHowTestConfig.instance()\n\t\t\t\t.setLoaders(kvpl, kvpl)\n\t\t\t\t.addOverrideGroups(configPtGroups);\n\t\t\tAndHow.setConfig(config);\n\t\t\tAndHow.instance();\n\t\t\tfail();\n\t\t} catch (AppFatalException ce) {\n\t\t\tassertEquals(1, ce.getProblems().filter(ConstructionProblem.class).size());\n\t\t\tassertTrue(ce.getProblems().filter(ConstructionProblem.class).get(0) instanceof ConstructionProblem.DuplicateLoader);\n\t\t\tConstructionProblem.DuplicateLoader dl = (ConstructionProblem.DuplicateLoader)ce.getProblems().filter(ConstructionProblem.class).get(0);\n\t\t\tassertEquals(kvpl, dl.getLoader());\n\t\t\tassertTrue(ce.getSampleDirectory().length() > 0);\n\t\t\tFile sampleDir = new File(ce.getSampleDirectory());\n\t\t\tassertTrue(sampleDir.exists());\n\t\t\tassertTrue(sampleDir.listFiles().length > 0);\n\t\t}\n\t}","cleancode":"@test public void testblowingupwithduplicateloaders() { keyvaluepairloader kvpl = new keyvaluepairloader(); kvpl.setkeyvaluepairs(cmdlineargswfullclassname); try { andhowconfiguration config = andhowtestconfig.instance() .setloaders(kvpl, kvpl) .addoverridegroups(configptgroups); andhow.setconfig(config); andhow.instance(); fail(); } catch (appfatalexception ce) { assertequals(1, ce.getproblems().filter(constructionproblem.class).size()); asserttrue(ce.getproblems().filter(constructionproblem.class).get(0) instanceof constructionproblem.duplicateloader); constructionproblem.duplicateloader dl = (constructionproblem.duplicateloader)ce.getproblems().filter(constructionproblem.class).get(0); assertequals(kvpl, dl.getloader()); asserttrue(ce.getsampledirectory().length() > 0); file sampledir = new file(ce.getsampledirectory()); asserttrue(sampledir.exists()); asserttrue(sampledir.listfiles().length > 0); } }","repo":"emafazillah\/andhow","label":[1,0,0,0]}
{"id":17643,"original_code":"public void bootstrapMessagingSystem(){\n    try{\n      messagingSystem = new MessagingSystem(ACTIVEMQ_BROKER_URI, ACTIVEMQ_BROKER_PORT);\n      messagingSystem.createConnection();\n      messagingSystem.createSession();\n      \/\/TODO: handle topics, not just queues\n      messagingSystem.createDestination(ACTIVEMQ_DESTINATION_NAME);\n      messagingSystem.createProducer();\n      System.out.println(\"SolrToActiveMQComponent: Bootstrapping messaging system done.\");\n      messagingSystem.validateConnection();\n    }\n    catch (JMSException e){\n      System.out.println(\"SolrToActiveMQComponent: Bootstrapping messaging system failed.\\n\" + e);\n      messagingSystem.invalidateConnection();\n    }\n  }","code_wo_comment":"public void bootstrapMessagingSystem(){\n    try{\n      messagingSystem = new MessagingSystem(ACTIVEMQ_BROKER_URI, ACTIVEMQ_BROKER_PORT);\n      messagingSystem.createConnection();\n      messagingSystem.createSession();\n     \n      messagingSystem.createDestination(ACTIVEMQ_DESTINATION_NAME);\n      messagingSystem.createProducer();\n      System.out.println(\"SolrToActiveMQComponent: Bootstrapping messaging system done.\");\n      messagingSystem.validateConnection();\n    }\n    catch (JMSException e){\n      System.out.println(\"SolrToActiveMQComponent: Bootstrapping messaging system failed.\\n\" + e);\n      messagingSystem.invalidateConnection();\n    }\n  }","cleancode":"public void bootstrapmessagingsystem(){ try{ messagingsystem = new messagingsystem(activemq_broker_uri, activemq_broker_port); messagingsystem.createconnection(); messagingsystem.createsession(); messagingsystem.createdestination(activemq_destination_name); messagingsystem.createproducer(); system.out.println(\"solrtoactivemqcomponent: bootstrapping messaging system done.\"); messagingsystem.validateconnection(); } catch (jmsexception e){ system.out.println(\"solrtoactivemqcomponent: bootstrapping messaging system failed.\\n\" + e); messagingsystem.invalidateconnection(); } }","repo":"dbraga\/solr2activemq","label":[0,1,0,0]}
{"id":9486,"original_code":"public boolean shouldAcquire(String name) {\n    \/\/ the org.robolectric.res package lives in the base classloader, but not its tests; yuck.\n    int lastDot = name.lastIndexOf('.');\n    String pkgName = name.substring(0, lastDot == -1 ? 0 : lastDot);\n    if (pkgName.equals(\"org.robolectric.res\")) {\n      return name.contains(\"Test\");\n    }\n    if (name.matches(\"com\\\\.android\\\\.internal\\\\.R(\\\\$.*)?\")) return true;\n    \/\/ Android SDK code almost universally refers to com.android.internal.R, except\n    \/\/ when refering to android.R.stylable, as in HorizontalScrollView. arghgh.\n    \/\/ See https:\/\/github.com\/robolectric\/robolectric\/issues\/521\n    if (name.equals(\"android.R$styleable\")) return true;\n    return !(\n        name.matches(\".*\\\\.R(|\\\\$[a-z]+)$\")\n            || CLASSES_TO_ALWAYS_DELEGATE.contains(name)\n            || name.startsWith(\"java.\")\n            || name.startsWith(\"javax.\")\n            || name.startsWith(\"sun.\")\n            || name.startsWith(\"com.sun.\")\n            || name.startsWith(\"org.w3c.\")\n            || name.startsWith(\"org.xml.\")\n            || name.startsWith(\"org.junit\")\n            || name.startsWith(\"org.hamcrest\")\n            || name.startsWith(\"org.specs2\")  \/\/ allows for android projects with mixed scala\\java tests to be\n            || name.startsWith(\"scala.\")      \/\/  run with Maven Surefire (see the RoboSpecs project on github)\n            || name.startsWith(\"org.sqlite.\") \/\/ ugh, we're barfing while loading org.sqlite now for some reason?!? todo: still?\n    );\n  }","code_wo_comment":"public boolean shouldAcquire(String name) {\n   \n    int lastDot = name.lastIndexOf('.');\n    String pkgName = name.substring(0, lastDot == -1 ? 0 : lastDot);\n    if (pkgName.equals(\"org.robolectric.res\")) {\n      return name.contains(\"Test\");\n    }\n    if (name.matches(\"com\\\\.android\\\\.internal\\\\.R(\\\\$.*)?\")) return true;\n   \n   \n   \n    if (name.equals(\"android.R$styleable\")) return true;\n    return !(\n        name.matches(\".*\\\\.R(|\\\\$[a-z]+)$\")\n            || CLASSES_TO_ALWAYS_DELEGATE.contains(name)\n            || name.startsWith(\"java.\")\n            || name.startsWith(\"javax.\")\n            || name.startsWith(\"sun.\")\n            || name.startsWith(\"com.sun.\")\n            || name.startsWith(\"org.w3c.\")\n            || name.startsWith(\"org.xml.\")\n            || name.startsWith(\"org.junit\")\n            || name.startsWith(\"org.hamcrest\")\n            || name.startsWith(\"org.specs2\") \n            || name.startsWith(\"scala.\")     \n            || name.startsWith(\"org.sqlite.\")\n    );\n  }","cleancode":"public boolean shouldacquire(string name) { int lastdot = name.lastindexof('.'); string pkgname = name.substring(0, lastdot == -1 ? 0 : lastdot); if (pkgname.equals(\"org.robolectric.res\")) { return name.contains(\"test\"); } if (name.matches(\"com\\\\.android\\\\.internal\\\\.r(\\\\$.*)?\")) return true; if (name.equals(\"android.r$styleable\")) return true; return !( name.matches(\".*\\\\.r(|\\\\$[a-z]+)$\") || classes_to_always_delegate.contains(name) || name.startswith(\"java.\") || name.startswith(\"javax.\") || name.startswith(\"sun.\") || name.startswith(\"com.sun.\") || name.startswith(\"org.w3c.\") || name.startswith(\"org.xml.\") || name.startswith(\"org.junit\") || name.startswith(\"org.hamcrest\") || name.startswith(\"org.specs2\") || name.startswith(\"scala.\") || name.startswith(\"org.sqlite.\") ); }","repo":"ecgreb\/robolectric","label":[1,0,0,0]}
{"id":17714,"original_code":"public void writeBytes(int stream, byte[] b, int offset, int len) {\n    \/\/ TODO: optimize\n    final int end = offset + len;\n    for(int i=offset;i<end;i++)\n      writeByte(stream, b[i]);\n  }","code_wo_comment":"public void writeBytes(int stream, byte[] b, int offset, int len) {\n   \n    final int end = offset + len;\n    for(int i=offset;i<end;i++)\n      writeByte(stream, b[i]);\n  }","cleancode":"public void writebytes(int stream, byte[] b, int offset, int len) { final int end = offset + len; for(int i=offset;i<end;i++) writebyte(stream, b[i]); }","repo":"dannycho7\/RTP_Latest","label":[1,0,0,0]}
{"id":9527,"original_code":"public static VirtualFile createDir(Project project, final VirtualFile parent, final String name) {\n    final Ref<VirtualFile> result = new Ref<VirtualFile>();\n    new WriteCommandAction.Simple(project) {\n      @Override\n      protected void run() throws Throwable {\n        try {\n          VirtualFile dir = parent.findChild(name);\n          if (dir == null) {\n            dir = parent.createChildDirectory(this, name);\n          }\n          result.set(dir);\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }.execute();\n    return result.get();\n  }","code_wo_comment":"public static VirtualFile createDir(Project project, final VirtualFile parent, final String name) {\n    final Ref<VirtualFile> result = new Ref<VirtualFile>();\n    new WriteCommandAction.Simple(project) {\n      @Override\n      protected void run() throws Throwable {\n        try {\n          VirtualFile dir = parent.findChild(name);\n          if (dir == null) {\n            dir = parent.createChildDirectory(this, name);\n          }\n          result.set(dir);\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }.execute();\n    return result.get();\n  }","cleancode":"public static virtualfile createdir(project project, final virtualfile parent, final string name) { final ref<virtualfile> result = new ref<virtualfile>(); new writecommandaction.simple(project) { @override protected void run() throws throwable { try { virtualfile dir = parent.findchild(name); if (dir == null) { dir = parent.createchilddirectory(this, name); } result.set(dir); } catch (ioexception e) { throw new runtimeexception(e); } } }.execute(); return result.get(); }","repo":"consulo\/consulo-git","label":[0,1,0,0]}
{"id":9528,"original_code":"@CEntryPoint(name = \"execute\")\n\tpublic static int execute(IsolateThread thread, int statement) {\n\t\ttry {\n\t\t\tboolean hasResult = statements.get(statement).execute();\n\t\t\tif (hasResult) {\n\t\t\t\tthrow new SQLException(\"unexpected results on statement execute\");\n\t\t\t}\n\t\t\treturn statements.get(statement).getUpdateCount();\n\t\t} catch (Throwable e) {\n\t\t\tsetError(e);\n\t\t\treturn -1;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstatements.get(statement).close();\n\t\t\t} catch(Throwable t) {\n\t\t\t\t\/\/ Ignored. TODO: Do I have to handle this?\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"@CEntryPoint(name = \"execute\")\n\tpublic static int execute(IsolateThread thread, int statement) {\n\t\ttry {\n\t\t\tboolean hasResult = statements.get(statement).execute();\n\t\t\tif (hasResult) {\n\t\t\t\tthrow new SQLException(\"unexpected results on statement execute\");\n\t\t\t}\n\t\t\treturn statements.get(statement).getUpdateCount();\n\t\t} catch (Throwable e) {\n\t\t\tsetError(e);\n\t\t\treturn -1;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstatements.get(statement).close();\n\t\t\t} catch(Throwable t) {\n\t\t\t\n\t\t\t}\n\t\t}\n\t}","cleancode":"@centrypoint(name = \"execute\") public static int execute(isolatethread thread, int statement) { try { boolean hasresult = statements.get(statement).execute(); if (hasresult) { throw new sqlexception(\"unexpected results on statement execute\"); } return statements.get(statement).getupdatecount(); } catch (throwable e) { seterror(e); return -1; } finally { try { statements.get(statement).close(); } catch(throwable t) { } } }","repo":"csmu-cenr\/gdbc","label":[1,0,0,0]}
{"id":17766,"original_code":"@Test\n\t@RunAsClient\n\tpublic void simpleSession() throws InterruptedException, ExecutionException {\n\t\tfinal String uuid = uuid();\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\t\/\/ New line is a frame delimiter specific for xhr-polling\"\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tassertEquals(\"o\\n\", res.readEntity(String.class));\n\t\t}\n\t\t\/\/ After a session was established the server needs to accept requests for sending messages.\n\t\t\/\/ Xhr-polling accepts messages as a list of JSON-encoded strings.\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR_SEND), json(\"[\\\"a\\\"]\"))) {\n\t\t\tassertEquals(Status.NO_CONTENT, res.getStatusInfo());\n\t\t\tverifyEmptyEntity(res);\n\t\t}\n\t\t\/\/ We're using an echo service - we'll receive our message back. The message is encoded as an array 'a'.\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tassertEquals(\"a[\\\"a\\\"]\\n\", res.readEntity(String.class));\n\t\t}\n\t\t\/\/ Sending messages to not existing sessions is invalid.\n\t\ttry (ClosableResponse res = post(target(\"000\", \"bad_session\", XHR_SEND), json(\"[\\\"a\\\"]\"))) {\n\t\t\tverify404(XHR_SEND, res);\n\t\t}\n\t\t\/\/ The session must time out after 5 seconds of not having a receiving connection. The server must send a\n\t\t\/\/ heartbeat frame every 25 seconds. The heartbeat frame contains a single h character. This delay may be\n\t\t\/\/ configurable.\n\t\t\/\/ TODO\n\t\t\/\/ The server must not allow two receiving connections to wait on a single session. In such case the server must\n\t\t\/\/ send a close frame to the new connection.\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR_SEND), json(\"[\\\"xxxxxx\\\"]\"))) {\n\t\t\t\tassertEquals(Status.NO_CONTENT, res.getStatusInfo());\n\t\t\t}\n\t\t}\n\t\t\/\/ Due to the time it takes for an async request to be scheduled it might actually be the one that returns the\n\t\t\/\/ 'another connection still open' error. Therefore we need to check both.\n\t\tfinal Future<Response> asyncFuture = target(\"000\", uuid, XHR).request().async().post(json(null));\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tfinal String resPayload = res.readEntity(String.class);\n\t\t\ttry (ClosableResponse asyncRes = closable(asyncFuture.get())) {\n\t\t\t\tassertEquals(Status.OK, asyncRes.getStatusInfo());\n\t\t\t\tfinal String asyncResPayload = asyncRes.readEntity(String.class);\n\t\t\t\tif (ENABLE_CONCURRENT_REQUESTS_TEST) {\n\t\t\t\t\tfinal String expectedError = \"c[2010,\\\"Another connection still open\\\"]\\n\";\n\t\t\t\t\tif (!expectedError.equals(resPayload) && !expectedError.equals(asyncResPayload)) {\n\t\t\t\t\t\tfail(\"Neither response had '\" + expectedError + \"'! [blocking=\" + resPayload + \",async=\" + asyncResPayload + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tfinal String expected = \"a[\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\"]\\n\";\n\t\t\t\t\tif (!expected.equals(resPayload) && !expected.equals(asyncResPayload)) {\n\t\t\t\t\t\tfail(\"Neither response had '\" + expected + \"'! [blocking=\" + resPayload + \",async=\" + asyncResPayload + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tasyncFuture.cancel(true);\n\t\t}\n\t}","code_wo_comment":"@Test\n\t@RunAsClient\n\tpublic void simpleSession() throws InterruptedException, ExecutionException {\n\t\tfinal String uuid = uuid();\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tassertEquals(\"o\\n\", res.readEntity(String.class));\n\t\t}\n\t\n\t\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR_SEND), json(\"[\\\"a\\\"]\"))) {\n\t\t\tassertEquals(Status.NO_CONTENT, res.getStatusInfo());\n\t\t\tverifyEmptyEntity(res);\n\t\t}\n\t\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tassertEquals(\"a[\\\"a\\\"]\\n\", res.readEntity(String.class));\n\t\t}\n\t\n\t\ttry (ClosableResponse res = post(target(\"000\", \"bad_session\", XHR_SEND), json(\"[\\\"a\\\"]\"))) {\n\t\t\tverify404(XHR_SEND, res);\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR_SEND), json(\"[\\\"xxxxxx\\\"]\"))) {\n\t\t\t\tassertEquals(Status.NO_CONTENT, res.getStatusInfo());\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfinal Future<Response> asyncFuture = target(\"000\", uuid, XHR).request().async().post(json(null));\n\t\ttry (ClosableResponse res = post(target(\"000\", uuid, XHR), json(null))) {\n\t\t\tassertEquals(Status.OK, res.getStatusInfo());\n\t\t\tfinal String resPayload = res.readEntity(String.class);\n\t\t\ttry (ClosableResponse asyncRes = closable(asyncFuture.get())) {\n\t\t\t\tassertEquals(Status.OK, asyncRes.getStatusInfo());\n\t\t\t\tfinal String asyncResPayload = asyncRes.readEntity(String.class);\n\t\t\t\tif (ENABLE_CONCURRENT_REQUESTS_TEST) {\n\t\t\t\t\tfinal String expectedError = \"c[2010,\\\"Another connection still open\\\"]\\n\";\n\t\t\t\t\tif (!expectedError.equals(resPayload) && !expectedError.equals(asyncResPayload)) {\n\t\t\t\t\t\tfail(\"Neither response had '\" + expectedError + \"'! [blocking=\" + resPayload + \",async=\" + asyncResPayload + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\tfinal String expected = \"a[\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\"]\\n\";\n\t\t\t\t\tif (!expected.equals(resPayload) && !expected.equals(asyncResPayload)) {\n\t\t\t\t\t\tfail(\"Neither response had '\" + expected + \"'! [blocking=\" + resPayload + \",async=\" + asyncResPayload + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tasyncFuture.cancel(true);\n\t\t}\n\t}","cleancode":"@test @runasclient public void simplesession() throws interruptedexception, executionexception { final string uuid = uuid(); try (closableresponse res = post(target(\"000\", uuid, xhr), json(null))) { assertequals(status.ok, res.getstatusinfo()); assertequals(\"o\\n\", res.readentity(string.class)); } try (closableresponse res = post(target(\"000\", uuid, xhr_send), json(\"[\\\"a\\\"]\"))) { assertequals(status.no_content, res.getstatusinfo()); verifyemptyentity(res); } try (closableresponse res = post(target(\"000\", uuid, xhr), json(null))) { assertequals(status.ok, res.getstatusinfo()); assertequals(\"a[\\\"a\\\"]\\n\", res.readentity(string.class)); } try (closableresponse res = post(target(\"000\", \"bad_session\", xhr_send), json(\"[\\\"a\\\"]\"))) { verify404(xhr_send, res); } for (int i = 0; i < 10; i++) { try (closableresponse res = post(target(\"000\", uuid, xhr_send), json(\"[\\\"xxxxxx\\\"]\"))) { assertequals(status.no_content, res.getstatusinfo()); } } final future<response> asyncfuture = target(\"000\", uuid, xhr).request().async().post(json(null)); try (closableresponse res = post(target(\"000\", uuid, xhr), json(null))) { assertequals(status.ok, res.getstatusinfo()); final string respayload = res.readentity(string.class); try (closableresponse asyncres = closable(asyncfuture.get())) { assertequals(status.ok, asyncres.getstatusinfo()); final string asyncrespayload = asyncres.readentity(string.class); if (enable_concurrent_requests_test) { final string expectederror = \"c[2010,\\\"another connection still open\\\"]\\n\"; if (!expectederror.equals(respayload) && !expectederror.equals(asyncrespayload)) { fail(\"neither response had '\" + expectederror + \"'! [blocking=\" + respayload + \",async=\" + asyncrespayload + \"]\"); } final string expected = \"a[\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\",\\\"xxxxxx\\\"]\\n\"; if (!expected.equals(respayload) && !expected.equals(asyncrespayload)) { fail(\"neither response had '\" + expected + \"'! [blocking=\" + respayload + \",async=\" + asyncrespayload + \"]\"); } } } } finally { asyncfuture.cancel(true); } }","repo":"dansiviter\/cito-sockjs","label":[1,0,0,1]}
{"id":9593,"original_code":"@Override\n    public boolean isConcurrentAccessSupported()\n    {\n        \/\/ Maybe we could support concurrent some time in the future\n        return false;\n    }","code_wo_comment":"@Override\n    public boolean isConcurrentAccessSupported()\n    {\n       \n        return false;\n    }","cleancode":"@override public boolean isconcurrentaccesssupported() { return false; }","repo":"elharo\/plexus-archiver","label":[0,1,0,0]}
{"id":9601,"original_code":"public void writeContent(HttpCarbonMessage httpOutboundRequest) {\n        if (handlerExecutor != null) {\n            handlerExecutor.executeAtTargetRequestReceiving(httpOutboundRequest);\n        }\n        BackPressureHandler backpressureHandler = Util.getBackPressureHandler(targetHandler.getContext());\n        Util.setBackPressureListener(httpOutboundRequest, backpressureHandler, httpOutboundRequest.getSourceContext());\n        resetTargetChannelState();\n        httpOutboundRequest.getHttpContentAsync().setMessageListener((httpContent -> {\n            \/\/TODO:Until the listener is set, content writing happens in I\/O thread. If writability changed\n            \/\/while in I\/O thread and DefaultBackPressureListener is engaged, there's a chance of I\/O thread\n            \/\/getting blocked. Cannot recreate, only a possibility.\n            Util.checkUnWritabilityAndNotify(targetHandler.getContext(), backpressureHandler);\n            this.channel.eventLoop().execute(() -> {\n                try {\n                    senderReqRespStateManager.writeOutboundRequestEntity(httpOutboundRequest, httpContent);\n                } catch (Exception exception) {\n                    String errorMsg = \"Failed to send the request : \"\n                            + exception.getMessage().toLowerCase(Locale.ENGLISH);\n                    LOG.error(errorMsg, exception);\n                    this.targetHandler.getHttpResponseFuture().notifyHttpListener(exception);\n                }\n            });\n        }));\n    }","code_wo_comment":"public void writeContent(HttpCarbonMessage httpOutboundRequest) {\n        if (handlerExecutor != null) {\n            handlerExecutor.executeAtTargetRequestReceiving(httpOutboundRequest);\n        }\n        BackPressureHandler backpressureHandler = Util.getBackPressureHandler(targetHandler.getContext());\n        Util.setBackPressureListener(httpOutboundRequest, backpressureHandler, httpOutboundRequest.getSourceContext());\n        resetTargetChannelState();\n        httpOutboundRequest.getHttpContentAsync().setMessageListener((httpContent -> {\n           \n           \n           \n            Util.checkUnWritabilityAndNotify(targetHandler.getContext(), backpressureHandler);\n            this.channel.eventLoop().execute(() -> {\n                try {\n                    senderReqRespStateManager.writeOutboundRequestEntity(httpOutboundRequest, httpContent);\n                } catch (Exception exception) {\n                    String errorMsg = \"Failed to send the request : \"\n                            + exception.getMessage().toLowerCase(Locale.ENGLISH);\n                    LOG.error(errorMsg, exception);\n                    this.targetHandler.getHttpResponseFuture().notifyHttpListener(exception);\n                }\n            });\n        }));\n    }","cleancode":"public void writecontent(httpcarbonmessage httpoutboundrequest) { if (handlerexecutor != null) { handlerexecutor.executeattargetrequestreceiving(httpoutboundrequest); } backpressurehandler backpressurehandler = util.getbackpressurehandler(targethandler.getcontext()); util.setbackpressurelistener(httpoutboundrequest, backpressurehandler, httpoutboundrequest.getsourcecontext()); resettargetchannelstate(); httpoutboundrequest.gethttpcontentasync().setmessagelistener((httpcontent -> { util.checkunwritabilityandnotify(targethandler.getcontext(), backpressurehandler); this.channel.eventloop().execute(() -> { try { senderreqrespstatemanager.writeoutboundrequestentity(httpoutboundrequest, httpcontent); } catch (exception exception) { string errormsg = \"failed to send the request : \" + exception.getmessage().tolowercase(locale.english); log.error(errormsg, exception); this.targethandler.gethttpresponsefuture().notifyhttplistener(exception); } }); })); }","repo":"gabilang\/module-ballerina-http","label":[0,0,1,0]}
{"id":1413,"original_code":"@GetMapping(\"\/{viewId}\/{rowId}\/field\/{fieldName}\/zoomInto\")\n\tpublic JSONZoomInto getRowFieldZoomInto(\n\t\t\t@PathVariable(\"windowId\") final String windowIdStr,\n\t\t\t@PathVariable(PARAM_ViewId) final String viewIdStr,\n\t\t\t@PathVariable(\"rowId\") final String rowId,\n\t\t\t@PathVariable(\"fieldName\") final String fieldName)\n\t{\n\t\t\/\/ userSession.assertLoggedIn(); \/\/ NOTE: not needed because we are forwarding to windowRestController\n\t\tViewId.ofViewIdString(viewIdStr, WindowId.fromJson(windowIdStr)); \/\/ just validate the windowId and viewId\n\t\t\/\/ TODO: atm we are forwarding all calls to windowRestController hoping the document existing and has the same ID as view's row ID.\n\t\treturn windowRestController.getDocumentFieldZoomInto(windowIdStr, rowId, fieldName);\n\t}","code_wo_comment":"@GetMapping(\"\/{viewId}\/{rowId}\/field\/{fieldName}\/zoomInto\")\n\tpublic JSONZoomInto getRowFieldZoomInto(\n\t\t\t@PathVariable(\"windowId\") final String windowIdStr,\n\t\t\t@PathVariable(PARAM_ViewId) final String viewIdStr,\n\t\t\t@PathVariable(\"rowId\") final String rowId,\n\t\t\t@PathVariable(\"fieldName\") final String fieldName)\n\t{\n\t\n\t\tViewId.ofViewIdString(viewIdStr, WindowId.fromJson(windowIdStr));\n\t\n\t\treturn windowRestController.getDocumentFieldZoomInto(windowIdStr, rowId, fieldName);\n\t}","cleancode":"@getmapping(\"\/{viewid}\/{rowid}\/field\/{fieldname}\/zoominto\") public jsonzoominto getrowfieldzoominto( @pathvariable(\"windowid\") final string windowidstr, @pathvariable(param_viewid) final string viewidstr, @pathvariable(\"rowid\") final string rowid, @pathvariable(\"fieldname\") final string fieldname) { viewid.ofviewidstring(viewidstr, windowid.fromjson(windowidstr)); return windowrestcontroller.getdocumentfieldzoominto(windowidstr, rowid, fieldname); }","repo":"focadiz\/metasfresh","label":[1,0,0,0]}
{"id":26006,"original_code":"public void bad() throws Throwable\n    {\n        String password = (new CWE319_Cleartext_Tx_Sensitive_Info__URLConnection_passwordAuth_61b()).badSource();\n        if (password != null)\n        {\n            \/* POTENTIAL FLAW: Use password directly in PasswordAuthentication() *\/\n            PasswordAuthentication credentials = new PasswordAuthentication(\"user\", password.toCharArray());\n            IO.writeLine(credentials.toString());\n        }\n    }","code_wo_comment":"public void bad() throws Throwable\n    {\n        String password = (new CWE319_Cleartext_Tx_Sensitive_Info__URLConnection_passwordAuth_61b()).badSource();\n        if (password != null)\n        {\n           \n            PasswordAuthentication credentials = new PasswordAuthentication(\"user\", password.toCharArray());\n            IO.writeLine(credentials.toString());\n        }\n    }","cleancode":"public void bad() throws throwable { string password = (new cwe319_cleartext_tx_sensitive_info__urlconnection_passwordauth_61b()).badsource(); if (password != null) { passwordauthentication credentials = new passwordauthentication(\"user\", password.tochararray()); io.writeline(credentials.tostring()); } }","repo":"diktat-static-analysis\/juliet-benchmark-java","label":[0,0,1,0]}
{"id":26007,"original_code":"private void goodG2B() throws Throwable\n    {\n        String password = (new CWE319_Cleartext_Tx_Sensitive_Info__URLConnection_passwordAuth_61b()).goodG2BSource();\n        if (password != null)\n        {\n            \/* POTENTIAL FLAW: Use password directly in PasswordAuthentication() *\/\n            PasswordAuthentication credentials = new PasswordAuthentication(\"user\", password.toCharArray());\n            IO.writeLine(credentials.toString());\n        }\n    }","code_wo_comment":"private void goodG2B() throws Throwable\n    {\n        String password = (new CWE319_Cleartext_Tx_Sensitive_Info__URLConnection_passwordAuth_61b()).goodG2BSource();\n        if (password != null)\n        {\n           \n            PasswordAuthentication credentials = new PasswordAuthentication(\"user\", password.toCharArray());\n            IO.writeLine(credentials.toString());\n        }\n    }","cleancode":"private void goodg2b() throws throwable { string password = (new cwe319_cleartext_tx_sensitive_info__urlconnection_passwordauth_61b()).goodg2bsource(); if (password != null) { passwordauthentication credentials = new passwordauthentication(\"user\", password.tochararray()); io.writeline(credentials.tostring()); } }","repo":"diktat-static-analysis\/juliet-benchmark-java","label":[0,0,1,0]}
{"id":34231,"original_code":"@SuppressWarnings(\"deprecation\")\n    private void send(Iterator<TableRef> tableRefIterator) throws SQLException {\n        int i = 0;\n        long[] serverTimeStamps = null;\n        boolean sendAll = false;\n        if (tableRefIterator == null) {\n            serverTimeStamps = validateAll();\n            tableRefIterator = mutations.keySet().iterator();\n            sendAll = true;\n        }\n        Map<ImmutableBytesPtr, RowMutationState> valuesMap;\n        Map<TableInfo,List<Mutation>> physicalTableMutationMap = Maps.newLinkedHashMap(); \n        \/\/ add tracing for this operation\n        try (TraceScope trace = Tracing.startNewSpan(connection, \"Committing mutations to tables\")) {\n            Span span = trace.getSpan();\n            ImmutableBytesWritable indexMetaDataPtr = new ImmutableBytesWritable();\n            while (tableRefIterator.hasNext()) {\n                \/\/ at this point we are going through mutations for each table\n                final TableRef tableRef = tableRefIterator.next();\n                valuesMap = mutations.get(tableRef);\n                if (valuesMap == null || valuesMap.isEmpty()) {\n                    continue;\n                }\n                \/\/ Validate as we go if transactional since we can undo if a problem occurs (which is unlikely)\n                long serverTimestamp = serverTimeStamps == null ? validateAndGetServerTimestamp(tableRef, valuesMap) : serverTimeStamps[i++];\n                Long scn = connection.getSCN();\n                long mutationTimestamp = scn == null ? HConstants.LATEST_TIMESTAMP : scn;\n                final PTable table = tableRef.getTable();\n                Iterator<Pair<PName,List<Mutation>>> mutationsIterator = addRowMutations(tableRef, valuesMap, mutationTimestamp, serverTimestamp, false, sendAll);\n                \/\/ build map from physical table to mutation list\n                boolean isDataTable = true;\n                while (mutationsIterator.hasNext()) {\n                    Pair<PName,List<Mutation>> pair = mutationsIterator.next();\n                    PName hTableName = pair.getFirst();\n                    List<Mutation> mutationList = pair.getSecond();\n                    TableInfo tableInfo = new TableInfo(isDataTable, hTableName, tableRef);\n                    List<Mutation> oldMutationList = physicalTableMutationMap.put(tableInfo, mutationList);\n                    if (oldMutationList!=null)\n                        mutationList.addAll(0, oldMutationList);\n                    isDataTable = false;\n                }\n                \/\/ For transactions, track the statement indexes as we send data\n                \/\/ over because our CommitException should include all statements\n                \/\/ involved in the transaction since none of them would have been\n                \/\/ committed in the event of a failure.\n                if (table.isTransactional()) {\n                    addUncommittedStatementIndexes(valuesMap.values());\n                    if (txMutations.isEmpty()) {\n                        txMutations = Maps.newHashMapWithExpectedSize(mutations.size());\n                    }\n                    \/\/ Keep all mutations we've encountered until a commit or rollback.\n                    \/\/ This is not ideal, but there's not good way to get the values back\n                    \/\/ in the event that we need to replay the commit.\n                    \/\/ Copy TableRef so we have the original PTable and know when the\n                    \/\/ indexes have changed.\n                    joinMutationState(new TableRef(tableRef), valuesMap, txMutations);\n                }\n            }\n            long serverTimestamp = HConstants.LATEST_TIMESTAMP;\n            Iterator<Entry<TableInfo, List<Mutation>>> mutationsIterator = physicalTableMutationMap.entrySet().iterator();\n            while (mutationsIterator.hasNext()) {\n                Entry<TableInfo, List<Mutation>> pair = mutationsIterator.next();\n                TableInfo tableInfo = pair.getKey();\n                byte[] htableName = tableInfo.getHTableName().getBytes();\n                List<Mutation> mutationList = pair.getValue();\n                \/\/create a span per target table\n                \/\/TODO maybe we can be smarter about the table name to string here?\n                Span child = Tracing.child(span,\"Writing mutation batch for table: \"+Bytes.toString(htableName));\n                int retryCount = 0;\n                boolean shouldRetry = false;\n                long numMutations = 0;\n                long mutationSizeBytes = 0;\n                long mutationCommitTime = 0;\n                long numFailedMutations = 0;;\n                long startTime = 0;\n                do {\n                    TableRef origTableRef = tableInfo.getOrigTableRef();\n                    PTable table = origTableRef.getTable();\n                    table.getIndexMaintainers(indexMetaDataPtr, connection);\n                    final ServerCache cache = tableInfo.isDataTable() ? setMetaDataOnMutations(origTableRef, mutationList, indexMetaDataPtr) : null;\n                    \/\/ If we haven't retried yet, retry for this case only, as it's possible that\n                    \/\/ a split will occur after we send the index metadata cache to all known\n                    \/\/ region servers.\n                    shouldRetry = cache!=null;\n                    SQLException sqlE = null;\n                    HTableInterface hTable = connection.getQueryServices().getTable(htableName);\n                    try {\n                        if (table.isTransactional()) {\n                            \/\/ Track tables to which we've sent uncommitted data\n                            uncommittedPhysicalNames.add(table.getPhysicalName().getString());\n                            \/\/ If we have indexes, wrap the HTable in a delegate HTable that\n                            \/\/ will attach the necessary index meta data in the event of a\n                            \/\/ rollback\n                            if (!table.getIndexes().isEmpty()) {\n                                hTable = new MetaDataAwareHTable(hTable, origTableRef);\n                            }\n                            hTable = TransactionUtil.getPhoenixTransactionTable(phoenixTransactionContext, hTable, table);\n                        }\n                        numMutations = mutationList.size();\n                        GLOBAL_MUTATION_BATCH_SIZE.update(numMutations);\n                        mutationSizeBytes = calculateMutationSize(mutationList);\n                        startTime = System.currentTimeMillis();\n                        child.addTimelineAnnotation(\"Attempt \" + retryCount);\n                        List<List<Mutation>> mutationBatchList = getMutationBatchList(batchSize, batchSizeBytes, mutationList);\n                        for (List<Mutation> mutationBatch : mutationBatchList) {\n                            hTable.batch(mutationBatch);\n                            batchCount++;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug(\"Sent batch of \" + numMutations + \" for \" + Bytes.toString(htableName));\n                        child.stop();\n                        child.stop();\n                        shouldRetry = false;\n                        mutationCommitTime = System.currentTimeMillis() - startTime;\n                        GLOBAL_MUTATION_COMMIT_TIME.update(mutationCommitTime);\n                        numFailedMutations = 0;\n                        if (tableInfo.isDataTable()) {\n                            numRows -= numMutations;\n                        }\n                        \/\/ Remove batches as we process them\n                        mutations.remove(origTableRef);\n                    } catch (Exception e) {\n                    \tmutationCommitTime = System.currentTimeMillis() - startTime;\n                        serverTimestamp = ServerUtil.parseServerTimestamp(e);\n                        SQLException inferredE = ServerUtil.parseServerExceptionOrNull(e);\n                        if (inferredE != null) {\n                            if (shouldRetry && retryCount == 0 && inferredE.getErrorCode() == SQLExceptionCode.INDEX_METADATA_NOT_FOUND.getErrorCode()) {\n                                \/\/ Swallow this exception once, as it's possible that we split after sending the index metadata\n                                \/\/ and one of the region servers doesn't have it. This will cause it to have it the next go around.\n                                \/\/ If it fails again, we don't retry.\n                                String msg = \"Swallowing exception and retrying after clearing meta cache on connection. \" + inferredE;\n                                logger.warn(LogUtil.addCustomAnnotations(msg, connection));\n                                connection.getQueryServices().clearTableRegionCache(htableName);\n                                \/\/ add a new child span as this one failed\n                                child.addTimelineAnnotation(msg);\n                                child.stop();\n                                child = Tracing.child(span,\"Failed batch, attempting retry\");\n                                continue;\n                            }\n                            e = inferredE;\n                        }\n                        \/\/ Throw to client an exception that indicates the statements that\n                        \/\/ were not committed successfully.\n                        int[] uncommittedStatementIndexes = getUncommittedStatementIndexes();\n\t\t\t\t\t\tsqlE = new CommitException(e, uncommittedStatementIndexes, serverTimestamp);\n\t\t\t\t\t\tnumFailedMutations = uncommittedStatementIndexes.length;\n\t\t\t\t\t\tGLOBAL_MUTATION_BATCH_FAILED_COUNT.update(numFailedMutations);\n                    } finally {\n                    \tMutationMetric mutationsMetric = new MutationMetric(numMutations, mutationSizeBytes, mutationCommitTime, numFailedMutations);\n                        mutationMetricQueue.addMetricsForTable(Bytes.toString(htableName), mutationsMetric);\n                        try {\n                            if (cache!=null) \n                                cache.close();\n                        } finally {\n                            try {\n                                hTable.close();\n                            } \n                            catch (IOException e) {\n                                if (sqlE != null) {\n                                    sqlE.setNextException(ServerUtil.parseServerException(e));\n                                } else {\n                                    sqlE = ServerUtil.parseServerException(e);\n                                }\n                            } \n                            if (sqlE != null) {\n                                throw sqlE;\n                            }\n                        }\n                    }\n                } while (shouldRetry && retryCount++ < 1);\n            }\n        }\n    }","code_wo_comment":"@SuppressWarnings(\"deprecation\")\n    private void send(Iterator<TableRef> tableRefIterator) throws SQLException {\n        int i = 0;\n        long[] serverTimeStamps = null;\n        boolean sendAll = false;\n        if (tableRefIterator == null) {\n            serverTimeStamps = validateAll();\n            tableRefIterator = mutations.keySet().iterator();\n            sendAll = true;\n        }\n        Map<ImmutableBytesPtr, RowMutationState> valuesMap;\n        Map<TableInfo,List<Mutation>> physicalTableMutationMap = Maps.newLinkedHashMap(); \n       \n        try (TraceScope trace = Tracing.startNewSpan(connection, \"Committing mutations to tables\")) {\n            Span span = trace.getSpan();\n            ImmutableBytesWritable indexMetaDataPtr = new ImmutableBytesWritable();\n            while (tableRefIterator.hasNext()) {\n               \n                final TableRef tableRef = tableRefIterator.next();\n                valuesMap = mutations.get(tableRef);\n                if (valuesMap == null || valuesMap.isEmpty()) {\n                    continue;\n                }\n               \n                long serverTimestamp = serverTimeStamps == null ? validateAndGetServerTimestamp(tableRef, valuesMap) : serverTimeStamps[i++];\n                Long scn = connection.getSCN();\n                long mutationTimestamp = scn == null ? HConstants.LATEST_TIMESTAMP : scn;\n                final PTable table = tableRef.getTable();\n                Iterator<Pair<PName,List<Mutation>>> mutationsIterator = addRowMutations(tableRef, valuesMap, mutationTimestamp, serverTimestamp, false, sendAll);\n               \n                boolean isDataTable = true;\n                while (mutationsIterator.hasNext()) {\n                    Pair<PName,List<Mutation>> pair = mutationsIterator.next();\n                    PName hTableName = pair.getFirst();\n                    List<Mutation> mutationList = pair.getSecond();\n                    TableInfo tableInfo = new TableInfo(isDataTable, hTableName, tableRef);\n                    List<Mutation> oldMutationList = physicalTableMutationMap.put(tableInfo, mutationList);\n                    if (oldMutationList!=null)\n                        mutationList.addAll(0, oldMutationList);\n                    isDataTable = false;\n                }\n               \n               \n               \n               \n                if (table.isTransactional()) {\n                    addUncommittedStatementIndexes(valuesMap.values());\n                    if (txMutations.isEmpty()) {\n                        txMutations = Maps.newHashMapWithExpectedSize(mutations.size());\n                    }\n                   \n                   \n                   \n                   \n                   \n                    joinMutationState(new TableRef(tableRef), valuesMap, txMutations);\n                }\n            }\n            long serverTimestamp = HConstants.LATEST_TIMESTAMP;\n            Iterator<Entry<TableInfo, List<Mutation>>> mutationsIterator = physicalTableMutationMap.entrySet().iterator();\n            while (mutationsIterator.hasNext()) {\n                Entry<TableInfo, List<Mutation>> pair = mutationsIterator.next();\n                TableInfo tableInfo = pair.getKey();\n                byte[] htableName = tableInfo.getHTableName().getBytes();\n                List<Mutation> mutationList = pair.getValue();\n               \n               \n                Span child = Tracing.child(span,\"Writing mutation batch for table: \"+Bytes.toString(htableName));\n                int retryCount = 0;\n                boolean shouldRetry = false;\n                long numMutations = 0;\n                long mutationSizeBytes = 0;\n                long mutationCommitTime = 0;\n                long numFailedMutations = 0;;\n                long startTime = 0;\n                do {\n                    TableRef origTableRef = tableInfo.getOrigTableRef();\n                    PTable table = origTableRef.getTable();\n                    table.getIndexMaintainers(indexMetaDataPtr, connection);\n                    final ServerCache cache = tableInfo.isDataTable() ? setMetaDataOnMutations(origTableRef, mutationList, indexMetaDataPtr) : null;\n                   \n                   \n                   \n                    shouldRetry = cache!=null;\n                    SQLException sqlE = null;\n                    HTableInterface hTable = connection.getQueryServices().getTable(htableName);\n                    try {\n                        if (table.isTransactional()) {\n                           \n                            uncommittedPhysicalNames.add(table.getPhysicalName().getString());\n                           \n                           \n                           \n                            if (!table.getIndexes().isEmpty()) {\n                                hTable = new MetaDataAwareHTable(hTable, origTableRef);\n                            }\n                            hTable = TransactionUtil.getPhoenixTransactionTable(phoenixTransactionContext, hTable, table);\n                        }\n                        numMutations = mutationList.size();\n                        GLOBAL_MUTATION_BATCH_SIZE.update(numMutations);\n                        mutationSizeBytes = calculateMutationSize(mutationList);\n                        startTime = System.currentTimeMillis();\n                        child.addTimelineAnnotation(\"Attempt \" + retryCount);\n                        List<List<Mutation>> mutationBatchList = getMutationBatchList(batchSize, batchSizeBytes, mutationList);\n                        for (List<Mutation> mutationBatch : mutationBatchList) {\n                            hTable.batch(mutationBatch);\n                            batchCount++;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug(\"Sent batch of \" + numMutations + \" for \" + Bytes.toString(htableName));\n                        child.stop();\n                        child.stop();\n                        shouldRetry = false;\n                        mutationCommitTime = System.currentTimeMillis() - startTime;\n                        GLOBAL_MUTATION_COMMIT_TIME.update(mutationCommitTime);\n                        numFailedMutations = 0;\n                        if (tableInfo.isDataTable()) {\n                            numRows -= numMutations;\n                        }\n                       \n                        mutations.remove(origTableRef);\n                    } catch (Exception e) {\n                    \tmutationCommitTime = System.currentTimeMillis() - startTime;\n                        serverTimestamp = ServerUtil.parseServerTimestamp(e);\n                        SQLException inferredE = ServerUtil.parseServerExceptionOrNull(e);\n                        if (inferredE != null) {\n                            if (shouldRetry && retryCount == 0 && inferredE.getErrorCode() == SQLExceptionCode.INDEX_METADATA_NOT_FOUND.getErrorCode()) {\n                               \n                               \n                               \n                                String msg = \"Swallowing exception and retrying after clearing meta cache on connection. \" + inferredE;\n                                logger.warn(LogUtil.addCustomAnnotations(msg, connection));\n                                connection.getQueryServices().clearTableRegionCache(htableName);\n                               \n                                child.addTimelineAnnotation(msg);\n                                child.stop();\n                                child = Tracing.child(span,\"Failed batch, attempting retry\");\n                                continue;\n                            }\n                            e = inferredE;\n                        }\n                       \n                       \n                        int[] uncommittedStatementIndexes = getUncommittedStatementIndexes();\n\t\t\t\t\t\tsqlE = new CommitException(e, uncommittedStatementIndexes, serverTimestamp);\n\t\t\t\t\t\tnumFailedMutations = uncommittedStatementIndexes.length;\n\t\t\t\t\t\tGLOBAL_MUTATION_BATCH_FAILED_COUNT.update(numFailedMutations);\n                    } finally {\n                    \tMutationMetric mutationsMetric = new MutationMetric(numMutations, mutationSizeBytes, mutationCommitTime, numFailedMutations);\n                        mutationMetricQueue.addMetricsForTable(Bytes.toString(htableName), mutationsMetric);\n                        try {\n                            if (cache!=null) \n                                cache.close();\n                        } finally {\n                            try {\n                                hTable.close();\n                            } \n                            catch (IOException e) {\n                                if (sqlE != null) {\n                                    sqlE.setNextException(ServerUtil.parseServerException(e));\n                                } else {\n                                    sqlE = ServerUtil.parseServerException(e);\n                                }\n                            } \n                            if (sqlE != null) {\n                                throw sqlE;\n                            }\n                        }\n                    }\n                } while (shouldRetry && retryCount++ < 1);\n            }\n        }\n    }","cleancode":"@suppresswarnings(\"deprecation\") private void send(iterator<tableref> tablerefiterator) throws sqlexception { int i = 0; long[] servertimestamps = null; boolean sendall = false; if (tablerefiterator == null) { servertimestamps = validateall(); tablerefiterator = mutations.keyset().iterator(); sendall = true; } map<immutablebytesptr, rowmutationstate> valuesmap; map<tableinfo,list<mutation>> physicaltablemutationmap = maps.newlinkedhashmap(); try (tracescope trace = tracing.startnewspan(connection, \"committing mutations to tables\")) { span span = trace.getspan(); immutablebyteswritable indexmetadataptr = new immutablebyteswritable(); while (tablerefiterator.hasnext()) { final tableref tableref = tablerefiterator.next(); valuesmap = mutations.get(tableref); if (valuesmap == null || valuesmap.isempty()) { continue; } long servertimestamp = servertimestamps == null ? validateandgetservertimestamp(tableref, valuesmap) : servertimestamps[i++]; long scn = connection.getscn(); long mutationtimestamp = scn == null ? hconstants.latest_timestamp : scn; final ptable table = tableref.gettable(); iterator<pair<pname,list<mutation>>> mutationsiterator = addrowmutations(tableref, valuesmap, mutationtimestamp, servertimestamp, false, sendall); boolean isdatatable = true; while (mutationsiterator.hasnext()) { pair<pname,list<mutation>> pair = mutationsiterator.next(); pname htablename = pair.getfirst(); list<mutation> mutationlist = pair.getsecond(); tableinfo tableinfo = new tableinfo(isdatatable, htablename, tableref); list<mutation> oldmutationlist = physicaltablemutationmap.put(tableinfo, mutationlist); if (oldmutationlist!=null) mutationlist.addall(0, oldmutationlist); isdatatable = false; } if (table.istransactional()) { adduncommittedstatementindexes(valuesmap.values()); if (txmutations.isempty()) { txmutations = maps.newhashmapwithexpectedsize(mutations.size()); } joinmutationstate(new tableref(tableref), valuesmap, txmutations); } } long servertimestamp = hconstants.latest_timestamp; iterator<entry<tableinfo, list<mutation>>> mutationsiterator = physicaltablemutationmap.entryset().iterator(); while (mutationsiterator.hasnext()) { entry<tableinfo, list<mutation>> pair = mutationsiterator.next(); tableinfo tableinfo = pair.getkey(); byte[] htablename = tableinfo.gethtablename().getbytes(); list<mutation> mutationlist = pair.getvalue(); span child = tracing.child(span,\"writing mutation batch for table: \"+bytes.tostring(htablename)); int retrycount = 0; boolean shouldretry = false; long nummutations = 0; long mutationsizebytes = 0; long mutationcommittime = 0; long numfailedmutations = 0;; long starttime = 0; do { tableref origtableref = tableinfo.getorigtableref(); ptable table = origtableref.gettable(); table.getindexmaintainers(indexmetadataptr, connection); final servercache cache = tableinfo.isdatatable() ? setmetadataonmutations(origtableref, mutationlist, indexmetadataptr) : null; shouldretry = cache!=null; sqlexception sqle = null; htableinterface htable = connection.getqueryservices().gettable(htablename); try { if (table.istransactional()) { uncommittedphysicalnames.add(table.getphysicalname().getstring()); if (!table.getindexes().isempty()) { htable = new metadataawarehtable(htable, origtableref); } htable = transactionutil.getphoenixtransactiontable(phoenixtransactioncontext, htable, table); } nummutations = mutationlist.size(); global_mutation_batch_size.update(nummutations); mutationsizebytes = calculatemutationsize(mutationlist); starttime = system.currenttimemillis(); child.addtimelineannotation(\"attempt \" + retrycount); list<list<mutation>> mutationbatchlist = getmutationbatchlist(batchsize, batchsizebytes, mutationlist); for (list<mutation> mutationbatch : mutationbatchlist) { htable.batch(mutationbatch); batchcount++; } if (logger.isdebugenabled()) logger.debug(\"sent batch of \" + nummutations + \" for \" + bytes.tostring(htablename)); child.stop(); child.stop(); shouldretry = false; mutationcommittime = system.currenttimemillis() - starttime; global_mutation_commit_time.update(mutationcommittime); numfailedmutations = 0; if (tableinfo.isdatatable()) { numrows -= nummutations; } mutations.remove(origtableref); } catch (exception e) { mutationcommittime = system.currenttimemillis() - starttime; servertimestamp = serverutil.parseservertimestamp(e); sqlexception inferrede = serverutil.parseserverexceptionornull(e); if (inferrede != null) { if (shouldretry && retrycount == 0 && inferrede.geterrorcode() == sqlexceptioncode.index_metadata_not_found.geterrorcode()) { string msg = \"swallowing exception and retrying after clearing meta cache on connection. \" + inferrede; logger.warn(logutil.addcustomannotations(msg, connection)); connection.getqueryservices().cleartableregioncache(htablename); child.addtimelineannotation(msg); child.stop(); child = tracing.child(span,\"failed batch, attempting retry\"); continue; } e = inferrede; } int[] uncommittedstatementindexes = getuncommittedstatementindexes(); sqle = new commitexception(e, uncommittedstatementindexes, servertimestamp); numfailedmutations = uncommittedstatementindexes.length; global_mutation_batch_failed_count.update(numfailedmutations); } finally { mutationmetric mutationsmetric = new mutationmetric(nummutations, mutationsizebytes, mutationcommittime, numfailedmutations); mutationmetricqueue.addmetricsfortable(bytes.tostring(htablename), mutationsmetric); try { if (cache!=null) cache.close(); } finally { try { htable.close(); } catch (ioexception e) { if (sqle != null) { sqle.setnextexception(serverutil.parseserverexception(e)); } else { sqle = serverutil.parseserverexception(e); } } if (sqle != null) { throw sqle; } } } } while (shouldretry && retrycount++ < 1); } } }","repo":"cruisehz\/phoenix","label":[1,0,0,0]}
{"id":1597,"original_code":"@Transactional()\n  @Override\n  public EmailResponse resendConfirmationthroughEmail(\n      String applicationId, String securityToken, String emailId, String appName) {\n    logger.info(\"UserManagementProfileServiceImpl - resendConfirmationthroughEmail() - Starts\");\n    AppEntity appPropertiesDetails = null;\n    String content = \"\";\n    String subject = \"\";\n    AppOrgInfoBean appOrgInfoBean = null;\n    appOrgInfoBean = commonDao.getUserAppDetailsByAllApi(\"\", applicationId);\n    appPropertiesDetails =\n        userProfileManagementDao.getAppPropertiesDetailsByAppId(appOrgInfoBean.getAppInfoId());\n    Map<String, String> templateArgs = new HashMap<>();\n    if ((appPropertiesDetails == null)\n        || (appPropertiesDetails.getRegEmailSub() == null)\n        || (appPropertiesDetails.getRegEmailBody() == null)\n        || appPropertiesDetails.getRegEmailBody().equalsIgnoreCase(\"\")\n        || appPropertiesDetails.getRegEmailSub().equalsIgnoreCase(\"\")) {\n      subject = appConfig.getConfirmationMailSubject();\n      content = appConfig.getConfirmationMail();\n    } else {\n      content = appPropertiesDetails.getRegEmailBody();\n      subject = appPropertiesDetails.getRegEmailSub();\n    }\n    templateArgs.put(\"appName\", appName);\n    \/\/ TODO(#496): replace with actual study's org name.\n    templateArgs.put(\"orgName\", appConfig.getOrgName());\n    templateArgs.put(\"contactEmail\", appConfig.getContactEmail());\n    templateArgs.put(\"securitytoken\", securityToken);\n    EmailRequest emailRequest =\n        new EmailRequest(\n            appConfig.getFromEmail(),\n            new String[] {emailId},\n            null,\n            null,\n            subject,\n            content,\n            templateArgs);\n    logger.info(\"UserManagementProfileServiceImpl - resendConfirmationthroughEmail() - Ends\");\n    return emailService.sendMimeMail(emailRequest);\n  }","code_wo_comment":"@Transactional()\n  @Override\n  public EmailResponse resendConfirmationthroughEmail(\n      String applicationId, String securityToken, String emailId, String appName) {\n    logger.info(\"UserManagementProfileServiceImpl - resendConfirmationthroughEmail() - Starts\");\n    AppEntity appPropertiesDetails = null;\n    String content = \"\";\n    String subject = \"\";\n    AppOrgInfoBean appOrgInfoBean = null;\n    appOrgInfoBean = commonDao.getUserAppDetailsByAllApi(\"\", applicationId);\n    appPropertiesDetails =\n        userProfileManagementDao.getAppPropertiesDetailsByAppId(appOrgInfoBean.getAppInfoId());\n    Map<String, String> templateArgs = new HashMap<>();\n    if ((appPropertiesDetails == null)\n        || (appPropertiesDetails.getRegEmailSub() == null)\n        || (appPropertiesDetails.getRegEmailBody() == null)\n        || appPropertiesDetails.getRegEmailBody().equalsIgnoreCase(\"\")\n        || appPropertiesDetails.getRegEmailSub().equalsIgnoreCase(\"\")) {\n      subject = appConfig.getConfirmationMailSubject();\n      content = appConfig.getConfirmationMail();\n    } else {\n      content = appPropertiesDetails.getRegEmailBody();\n      subject = appPropertiesDetails.getRegEmailSub();\n    }\n    templateArgs.put(\"appName\", appName);\n   \n    templateArgs.put(\"orgName\", appConfig.getOrgName());\n    templateArgs.put(\"contactEmail\", appConfig.getContactEmail());\n    templateArgs.put(\"securitytoken\", securityToken);\n    EmailRequest emailRequest =\n        new EmailRequest(\n            appConfig.getFromEmail(),\n            new String[] {emailId},\n            null,\n            null,\n            subject,\n            content,\n            templateArgs);\n    logger.info(\"UserManagementProfileServiceImpl - resendConfirmationthroughEmail() - Ends\");\n    return emailService.sendMimeMail(emailRequest);\n  }","cleancode":"@transactional() @override public emailresponse resendconfirmationthroughemail( string applicationid, string securitytoken, string emailid, string appname) { logger.info(\"usermanagementprofileserviceimpl - resendconfirmationthroughemail() - starts\"); appentity apppropertiesdetails = null; string content = \"\"; string subject = \"\"; apporginfobean apporginfobean = null; apporginfobean = commondao.getuserappdetailsbyallapi(\"\", applicationid); apppropertiesdetails = userprofilemanagementdao.getapppropertiesdetailsbyappid(apporginfobean.getappinfoid()); map<string, string> templateargs = new hashmap<>(); if ((apppropertiesdetails == null) || (apppropertiesdetails.getregemailsub() == null) || (apppropertiesdetails.getregemailbody() == null) || apppropertiesdetails.getregemailbody().equalsignorecase(\"\") || apppropertiesdetails.getregemailsub().equalsignorecase(\"\")) { subject = appconfig.getconfirmationmailsubject(); content = appconfig.getconfirmationmail(); } else { content = apppropertiesdetails.getregemailbody(); subject = apppropertiesdetails.getregemailsub(); } templateargs.put(\"appname\", appname); templateargs.put(\"orgname\", appconfig.getorgname()); templateargs.put(\"contactemail\", appconfig.getcontactemail()); templateargs.put(\"securitytoken\", securitytoken); emailrequest emailrequest = new emailrequest( appconfig.getfromemail(), new string[] {emailid}, null, null, subject, content, templateargs); logger.info(\"usermanagementprofileserviceimpl - resendconfirmationthroughemail() - ends\"); return emailservice.sendmimemail(emailrequest); }","repo":"deepsinghchouhan\/fdamystudies","label":[1,0,0,0]}
{"id":18031,"original_code":"private String replaceParam(String message, Object... parameters) {\n        int startSize = 0;\n        int parametersIndex = 0;\n        int index;\n        String tmpMessage = message;\n        while ((index = message.indexOf(\"{}\", startSize)) != -1) {\n            if (parametersIndex >= parameters.length) {\n                break;\n            }\n            \/**\n             * @Fix the Illegal group reference issue\n             *\/\n            tmpMessage = tmpMessage.replaceFirst(\"\\\\{\\\\}\", Matcher.quoteReplacement(String.valueOf(parameters[parametersIndex++])));\n            startSize = index + 2;\n        }\n        return tmpMessage;\n    }","code_wo_comment":"private String replaceParam(String message, Object... parameters) {\n        int startSize = 0;\n        int parametersIndex = 0;\n        int index;\n        String tmpMessage = message;\n        while ((index = message.indexOf(\"{}\", startSize)) != -1) {\n            if (parametersIndex >= parameters.length) {\n                break;\n            }\n           \n            tmpMessage = tmpMessage.replaceFirst(\"\\\\{\\\\}\", Matcher.quoteReplacement(String.valueOf(parameters[parametersIndex++])));\n            startSize = index + 2;\n        }\n        return tmpMessage;\n    }","cleancode":"private string replaceparam(string message, object... parameters) { int startsize = 0; int parametersindex = 0; int index; string tmpmessage = message; while ((index = message.indexof(\"{}\", startsize)) != -1) { if (parametersindex >= parameters.length) { break; } tmpmessage = tmpmessage.replacefirst(\"\\\\{\\\\}\", matcher.quotereplacement(string.valueof(parameters[parametersindex++]))); startsize = index + 2; } return tmpmessage; }","repo":"erda-project\/erda-java-extensions","label":[0,0,1,0]}
{"id":26234,"original_code":"@GET\n\t@PermitAll\n\t@Path(\"\/server\/info\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic Response getServerInformation() throws ApiException {\n\t\tMap<String, Object> returnMap = new HashMap<String, Object>();\n\t\tList<Object> configurations = new ArrayList<Object>();\n\t\tAppConstants appConstants = AppConstants.getInstance();\n\t\tfor (Configuration configuration : getIbisManager().getConfigurations()) {\n\t\t\tMap<String, Object> cfg = new HashMap<String, Object>();\n\t\t\tcfg.put(\"name\", configuration.getName());\n\t\t\tcfg.put(\"version\", configuration.getVersion());\n\t\t\tcfg.put(\"stubbed\", configuration.isStubbed());\n\t\t\tcfg.put(\"type\", configuration.getClassLoaderType());\n\t\t\tif(configuration.getConfigurationException() != null) {\n\t\t\t\tcfg.put(\"exception\", configuration.getConfigurationException().getMessage());\n\t\t\t}\n\t\t\tClassLoader classLoader = configuration.getClassLoader();\n\t\t\tif(classLoader instanceof DatabaseClassLoader) {\n\t\t\t\tcfg.put(\"filename\", ((DatabaseClassLoader) classLoader).getFileName());\n\t\t\t\tcfg.put(\"created\", ((DatabaseClassLoader) classLoader).getCreationDate());\n\t\t\t\tcfg.put(\"user\", ((DatabaseClassLoader) classLoader).getUser());\n\t\t\t}\n\t\t\tString parentConfig = AppConstants.getInstance().getString(\"configurations.\" + configuration.getName() + \".parentConfig\", null);\n\t\t\tif(parentConfig != null)\n\t\t\t\tcfg.put(\"parent\", parentConfig);\n\t\t\t\tconfigurations.add(cfg);\n\t\t}\n\t\t\/\/TODO Replace this with java.util.Collections!\n\t\tCollections.sort(configurations, new Comparator<Map<String, String>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Map<String, String> lhs, Map<String, String> rhs) {\n\t\t\t\tString name1 = lhs.get(\"name\");\n\t\t\t\tString name2 = rhs.get(\"name\");\n\t\t\t\treturn name1.startsWith(\"IAF_\") ? -1 : name2.startsWith(\"IAF_\") ? 1 : name1.compareTo(name2);\n\t\t\t}\n\t\t});\n\t\treturnMap.put(\"configurations\", configurations);\n\t\tMap<String, Object> framework = new HashMap<String, Object>(2);\n\t\tframework.put(\"name\", \"FF!\");\n\t\tframework.put(\"version\", appConstants.getProperty(\"application.version\"));\n\t\treturnMap.put(\"framework\", framework);\n\t\tMap<String, Object> instance = new HashMap<String, Object>(2);\n\t\tinstance.put(\"version\", appConstants.getProperty(\"instance.version\"));\n\t\tinstance.put(\"name\", getIbisContext().getApplicationName());\n\t\treturnMap.put(\"instance\", instance);\n\t\tString dtapStage = appConstants.getProperty(\"dtap.stage\");\n\t\treturnMap.put(\"dtap.stage\", dtapStage);\n\t\tString dtapSide = appConstants.getProperty(\"dtap.side\");\n\t\treturnMap.put(\"dtap.side\", dtapSide);\n\t\treturnMap.put(\"applicationServer\", servletConfig.getServletContext().getServerInfo());\n\t\treturnMap.put(\"javaVersion\", System.getProperty(\"java.runtime.name\") + \" (\" + System.getProperty(\"java.runtime.version\") + \")\");\n\t\tMap<String, Object> fileSystem = new HashMap<String, Object>(2);\n\t\tfileSystem.put(\"totalSpace\", Misc.getFileSystemTotalSpace());\n\t\tfileSystem.put(\"freeSpace\", Misc.getFileSystemFreeSpace());\n\t\treturnMap.put(\"fileSystem\", fileSystem);\n\t\treturnMap.put(\"processMetrics\", ProcessMetrics.toMap());\n\t\tDate date = new Date();\n\t\treturnMap.put(\"serverTime\", date.getTime());\n\t\treturnMap.put(\"machineName\" , Misc.getHostname());\n\t\tApplicationMetrics metrics = getIbisContext().getBean(\"metrics\", ApplicationMetrics.class);\n\t\treturnMap.put(\"uptime\", (metrics != null) ? metrics.getUptimeDate() : \"\");\n\t\treturn Response.status(Response.Status.OK).entity(returnMap).build();\n\t}","code_wo_comment":"@GET\n\t@PermitAll\n\t@Path(\"\/server\/info\")\n\t@Produces(MediaType.APPLICATION_JSON)\n\tpublic Response getServerInformation() throws ApiException {\n\t\tMap<String, Object> returnMap = new HashMap<String, Object>();\n\t\tList<Object> configurations = new ArrayList<Object>();\n\t\tAppConstants appConstants = AppConstants.getInstance();\n\t\tfor (Configuration configuration : getIbisManager().getConfigurations()) {\n\t\t\tMap<String, Object> cfg = new HashMap<String, Object>();\n\t\t\tcfg.put(\"name\", configuration.getName());\n\t\t\tcfg.put(\"version\", configuration.getVersion());\n\t\t\tcfg.put(\"stubbed\", configuration.isStubbed());\n\t\t\tcfg.put(\"type\", configuration.getClassLoaderType());\n\t\t\tif(configuration.getConfigurationException() != null) {\n\t\t\t\tcfg.put(\"exception\", configuration.getConfigurationException().getMessage());\n\t\t\t}\n\t\t\tClassLoader classLoader = configuration.getClassLoader();\n\t\t\tif(classLoader instanceof DatabaseClassLoader) {\n\t\t\t\tcfg.put(\"filename\", ((DatabaseClassLoader) classLoader).getFileName());\n\t\t\t\tcfg.put(\"created\", ((DatabaseClassLoader) classLoader).getCreationDate());\n\t\t\t\tcfg.put(\"user\", ((DatabaseClassLoader) classLoader).getUser());\n\t\t\t}\n\t\t\tString parentConfig = AppConstants.getInstance().getString(\"configurations.\" + configuration.getName() + \".parentConfig\", null);\n\t\t\tif(parentConfig != null)\n\t\t\t\tcfg.put(\"parent\", parentConfig);\n\t\t\t\tconfigurations.add(cfg);\n\t\t}\n\t\n\t\tCollections.sort(configurations, new Comparator<Map<String, String>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Map<String, String> lhs, Map<String, String> rhs) {\n\t\t\t\tString name1 = lhs.get(\"name\");\n\t\t\t\tString name2 = rhs.get(\"name\");\n\t\t\t\treturn name1.startsWith(\"IAF_\") ? -1 : name2.startsWith(\"IAF_\") ? 1 : name1.compareTo(name2);\n\t\t\t}\n\t\t});\n\t\treturnMap.put(\"configurations\", configurations);\n\t\tMap<String, Object> framework = new HashMap<String, Object>(2);\n\t\tframework.put(\"name\", \"FF!\");\n\t\tframework.put(\"version\", appConstants.getProperty(\"application.version\"));\n\t\treturnMap.put(\"framework\", framework);\n\t\tMap<String, Object> instance = new HashMap<String, Object>(2);\n\t\tinstance.put(\"version\", appConstants.getProperty(\"instance.version\"));\n\t\tinstance.put(\"name\", getIbisContext().getApplicationName());\n\t\treturnMap.put(\"instance\", instance);\n\t\tString dtapStage = appConstants.getProperty(\"dtap.stage\");\n\t\treturnMap.put(\"dtap.stage\", dtapStage);\n\t\tString dtapSide = appConstants.getProperty(\"dtap.side\");\n\t\treturnMap.put(\"dtap.side\", dtapSide);\n\t\treturnMap.put(\"applicationServer\", servletConfig.getServletContext().getServerInfo());\n\t\treturnMap.put(\"javaVersion\", System.getProperty(\"java.runtime.name\") + \" (\" + System.getProperty(\"java.runtime.version\") + \")\");\n\t\tMap<String, Object> fileSystem = new HashMap<String, Object>(2);\n\t\tfileSystem.put(\"totalSpace\", Misc.getFileSystemTotalSpace());\n\t\tfileSystem.put(\"freeSpace\", Misc.getFileSystemFreeSpace());\n\t\treturnMap.put(\"fileSystem\", fileSystem);\n\t\treturnMap.put(\"processMetrics\", ProcessMetrics.toMap());\n\t\tDate date = new Date();\n\t\treturnMap.put(\"serverTime\", date.getTime());\n\t\treturnMap.put(\"machineName\" , Misc.getHostname());\n\t\tApplicationMetrics metrics = getIbisContext().getBean(\"metrics\", ApplicationMetrics.class);\n\t\treturnMap.put(\"uptime\", (metrics != null) ? metrics.getUptimeDate() : \"\");\n\t\treturn Response.status(Response.Status.OK).entity(returnMap).build();\n\t}","cleancode":"@get @permitall @path(\"\/server\/info\") @produces(mediatype.application_json) public response getserverinformation() throws apiexception { map<string, object> returnmap = new hashmap<string, object>(); list<object> configurations = new arraylist<object>(); appconstants appconstants = appconstants.getinstance(); for (configuration configuration : getibismanager().getconfigurations()) { map<string, object> cfg = new hashmap<string, object>(); cfg.put(\"name\", configuration.getname()); cfg.put(\"version\", configuration.getversion()); cfg.put(\"stubbed\", configuration.isstubbed()); cfg.put(\"type\", configuration.getclassloadertype()); if(configuration.getconfigurationexception() != null) { cfg.put(\"exception\", configuration.getconfigurationexception().getmessage()); } classloader classloader = configuration.getclassloader(); if(classloader instanceof databaseclassloader) { cfg.put(\"filename\", ((databaseclassloader) classloader).getfilename()); cfg.put(\"created\", ((databaseclassloader) classloader).getcreationdate()); cfg.put(\"user\", ((databaseclassloader) classloader).getuser()); } string parentconfig = appconstants.getinstance().getstring(\"configurations.\" + configuration.getname() + \".parentconfig\", null); if(parentconfig != null) cfg.put(\"parent\", parentconfig); configurations.add(cfg); } collections.sort(configurations, new comparator<map<string, string>>() { @override public int compare(map<string, string> lhs, map<string, string> rhs) { string name1 = lhs.get(\"name\"); string name2 = rhs.get(\"name\"); return name1.startswith(\"iaf_\") ? -1 : name2.startswith(\"iaf_\") ? 1 : name1.compareto(name2); } }); returnmap.put(\"configurations\", configurations); map<string, object> framework = new hashmap<string, object>(2); framework.put(\"name\", \"ff!\"); framework.put(\"version\", appconstants.getproperty(\"application.version\")); returnmap.put(\"framework\", framework); map<string, object> instance = new hashmap<string, object>(2); instance.put(\"version\", appconstants.getproperty(\"instance.version\")); instance.put(\"name\", getibiscontext().getapplicationname()); returnmap.put(\"instance\", instance); string dtapstage = appconstants.getproperty(\"dtap.stage\"); returnmap.put(\"dtap.stage\", dtapstage); string dtapside = appconstants.getproperty(\"dtap.side\"); returnmap.put(\"dtap.side\", dtapside); returnmap.put(\"applicationserver\", servletconfig.getservletcontext().getserverinfo()); returnmap.put(\"javaversion\", system.getproperty(\"java.runtime.name\") + \" (\" + system.getproperty(\"java.runtime.version\") + \")\"); map<string, object> filesystem = new hashmap<string, object>(2); filesystem.put(\"totalspace\", misc.getfilesystemtotalspace()); filesystem.put(\"freespace\", misc.getfilesystemfreespace()); returnmap.put(\"filesystem\", filesystem); returnmap.put(\"processmetrics\", processmetrics.tomap()); date date = new date(); returnmap.put(\"servertime\", date.gettime()); returnmap.put(\"machinename\" , misc.gethostname()); applicationmetrics metrics = getibiscontext().getbean(\"metrics\", applicationmetrics.class); returnmap.put(\"uptime\", (metrics != null) ? metrics.getuptimedate() : \"\"); return response.status(response.status.ok).entity(returnmap).build(); }","repo":"francisgw\/iaf","label":[1,0,0,0]}
{"id":18158,"original_code":"public static int getSqlStatementType(String sql) {\n        sql = sql.trim();\n        if (sql.length() < 3) {\n            return STATEMENT_OTHER;\n        }\n        String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);\n        if (prefixSql.equals(\"SEL\")) {\n            return STATEMENT_SELECT;\n        } else if (prefixSql.equals(\"INS\") ||\n                prefixSql.equals(\"UPD\") ||\n                prefixSql.equals(\"REP\") ||\n                prefixSql.equals(\"DEL\")) {\n            return STATEMENT_UPDATE;\n        } else if (prefixSql.equals(\"ATT\")) {\n            return STATEMENT_ATTACH;\n        } else if (prefixSql.equals(\"COM\")) {\n            return STATEMENT_COMMIT;\n        } else if (prefixSql.equals(\"END\")) {\n            return STATEMENT_COMMIT;\n        } else if (prefixSql.equals(\"ROL\")) {\n            return STATEMENT_ABORT;\n        } else if (prefixSql.equals(\"BEG\")) {\n            return STATEMENT_BEGIN;\n        } else if (prefixSql.equals(\"PRA\")) {\n            return STATEMENT_PRAGMA;\n        } else if (prefixSql.equals(\"CRE\") || prefixSql.equals(\"DRO\") ||\n                prefixSql.equals(\"ALT\")) {\n            return STATEMENT_DDL;\n        } else if (prefixSql.equals(\"ANA\") || prefixSql.equals(\"DET\")) {\n            return STATEMENT_UNPREPARED;\n        }\n        return STATEMENT_OTHER;\n    }","code_wo_comment":"public static int getSqlStatementType(String sql) {\n        sql = sql.trim();\n        if (sql.length() < 3) {\n            return STATEMENT_OTHER;\n        }\n        String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);\n        if (prefixSql.equals(\"SEL\")) {\n            return STATEMENT_SELECT;\n        } else if (prefixSql.equals(\"INS\") ||\n                prefixSql.equals(\"UPD\") ||\n                prefixSql.equals(\"REP\") ||\n                prefixSql.equals(\"DEL\")) {\n            return STATEMENT_UPDATE;\n        } else if (prefixSql.equals(\"ATT\")) {\n            return STATEMENT_ATTACH;\n        } else if (prefixSql.equals(\"COM\")) {\n            return STATEMENT_COMMIT;\n        } else if (prefixSql.equals(\"END\")) {\n            return STATEMENT_COMMIT;\n        } else if (prefixSql.equals(\"ROL\")) {\n            return STATEMENT_ABORT;\n        } else if (prefixSql.equals(\"BEG\")) {\n            return STATEMENT_BEGIN;\n        } else if (prefixSql.equals(\"PRA\")) {\n            return STATEMENT_PRAGMA;\n        } else if (prefixSql.equals(\"CRE\") || prefixSql.equals(\"DRO\") ||\n                prefixSql.equals(\"ALT\")) {\n            return STATEMENT_DDL;\n        } else if (prefixSql.equals(\"ANA\") || prefixSql.equals(\"DET\")) {\n            return STATEMENT_UNPREPARED;\n        }\n        return STATEMENT_OTHER;\n    }","cleancode":"public static int getsqlstatementtype(string sql) { sql = sql.trim(); if (sql.length() < 3) { return statement_other; } string prefixsql = sql.substring(0, 3).touppercase(locale.root); if (prefixsql.equals(\"sel\")) { return statement_select; } else if (prefixsql.equals(\"ins\") || prefixsql.equals(\"upd\") || prefixsql.equals(\"rep\") || prefixsql.equals(\"del\")) { return statement_update; } else if (prefixsql.equals(\"att\")) { return statement_attach; } else if (prefixsql.equals(\"com\")) { return statement_commit; } else if (prefixsql.equals(\"end\")) { return statement_commit; } else if (prefixsql.equals(\"rol\")) { return statement_abort; } else if (prefixsql.equals(\"beg\")) { return statement_begin; } else if (prefixsql.equals(\"pra\")) { return statement_pragma; } else if (prefixsql.equals(\"cre\") || prefixsql.equals(\"dro\") || prefixsql.equals(\"alt\")) { return statement_ddl; } else if (prefixsql.equals(\"ana\") || prefixsql.equals(\"det\")) { return statement_unprepared; } return statement_other; }","repo":"finki001\/couchbase-lite-java-core","label":[0,0,0,0]}
{"id":34557,"original_code":"@Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ComplexBean that = (ComplexBean) o;\n        \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n        if (!Arrays.equals(strs, that.strs))\n            return false;\n        \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n        if (!Arrays.equals(jobs, that.jobs))\n            return false;\n        if (list != null ? !list.equals(that.list) : that.list != null)\n            return false;\n        if (map != null ? !map.equals(that.map) : that.map != null)\n            return false;\n        return clazz != null ? clazz.equals(that.clazz) : that.clazz == null;\n    }","code_wo_comment":"@Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ComplexBean that = (ComplexBean) o;\n       \n        if (!Arrays.equals(strs, that.strs))\n            return false;\n       \n        if (!Arrays.equals(jobs, that.jobs))\n            return false;\n        if (list != null ? !list.equals(that.list) : that.list != null)\n            return false;\n        if (map != null ? !map.equals(that.map) : that.map != null)\n            return false;\n        return clazz != null ? clazz.equals(that.clazz) : that.clazz == null;\n    }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; complexbean that = (complexbean) o; if (!arrays.equals(strs, that.strs)) return false; if (!arrays.equals(jobs, that.jobs)) return false; if (list != null ? !list.equals(that.list) : that.list != null) return false; if (map != null ? !map.equals(that.map) : that.map != null) return false; return clazz != null ? clazz.equals(that.clazz) : that.clazz == null; }","repo":"dbl-x\/sofa-rpc","label":[0,0,1,0]}
{"id":10052,"original_code":"@Override\n\t\tpublic void selectionDone(SelectionEvent evt) {\n\t\t\tif (!useUnixTextSelection)\n\t\t\t\treturn;\n\t\t\tObject o = evt.getSelection();\n\t\t\tif (!(o instanceof CharacterIterator))\n\t\t\t\treturn;\n\t\t\tCharacterIterator iter = (CharacterIterator) o;\n\t\t\t\/\/ first see if we can access the clipboard\n\t\t\tif (!PermissionChecker.getInstance().checkPermission(new AWTPermission(\"accessClipboard\"))) {\n\t\t\t\t\/\/ Can't access clipboard.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint sz = iter.getEndIndex() - iter.getBeginIndex();\n\t\t\tif (sz == 0)\n\t\t\t\treturn;\n\t\t\tchar[] cbuff = new char[sz];\n\t\t\tcbuff[0] = iter.first();\n\t\t\tfor (int i = 1; i < cbuff.length; ++i) {\n\t\t\t\tcbuff[i] = iter.next();\n\t\t\t}\n\t\t\tfinal String strSel = new String(cbuff);\n\t\t\t\/\/ HACK: getSystemClipboard sometimes deadlocks on\n\t\t\t\/\/ linux when called from the AWT Thread. The Thread\n\t\t\t\/\/ creation prevents that.\n\t\t\tnew Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tClipboard cb;\n\t\t\t\t\tcb = Toolkit.getDefaultToolkit().getSystemClipboard();\n\t\t\t\t\tStringSelection sel;\n\t\t\t\t\tsel = new StringSelection(strSel);\n\t\t\t\t\tcb.setContents(sel, sel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}","code_wo_comment":"@Override\n\t\tpublic void selectionDone(SelectionEvent evt) {\n\t\t\tif (!useUnixTextSelection)\n\t\t\t\treturn;\n\t\t\tObject o = evt.getSelection();\n\t\t\tif (!(o instanceof CharacterIterator))\n\t\t\t\treturn;\n\t\t\tCharacterIterator iter = (CharacterIterator) o;\n\t\t\n\t\t\tif (!PermissionChecker.getInstance().checkPermission(new AWTPermission(\"accessClipboard\"))) {\n\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint sz = iter.getEndIndex() - iter.getBeginIndex();\n\t\t\tif (sz == 0)\n\t\t\t\treturn;\n\t\t\tchar[] cbuff = new char[sz];\n\t\t\tcbuff[0] = iter.first();\n\t\t\tfor (int i = 1; i < cbuff.length; ++i) {\n\t\t\t\tcbuff[i] = iter.next();\n\t\t\t}\n\t\t\tfinal String strSel = new String(cbuff);\n\t\t\n\t\t\n\t\t\n\t\t\tnew Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tClipboard cb;\n\t\t\t\t\tcb = Toolkit.getDefaultToolkit().getSystemClipboard();\n\t\t\t\t\tStringSelection sel;\n\t\t\t\t\tsel = new StringSelection(strSel);\n\t\t\t\t\tcb.setContents(sel, sel);\n\t\t\t\t}\n\t\t\t}.start();\n\t\t}","cleancode":"@override public void selectiondone(selectionevent evt) { if (!useunixtextselection) return; object o = evt.getselection(); if (!(o instanceof characteriterator)) return; characteriterator iter = (characteriterator) o; if (!permissionchecker.getinstance().checkpermission(new awtpermission(\"accessclipboard\"))) { return; } int sz = iter.getendindex() - iter.getbeginindex(); if (sz == 0) return; char[] cbuff = new char[sz]; cbuff[0] = iter.first(); for (int i = 1; i < cbuff.length; ++i) { cbuff[i] = iter.next(); } final string strsel = new string(cbuff); new thread() { @override public void run() { clipboard cb; cb = toolkit.getdefaulttoolkit().getsystemclipboard(); stringselection sel; sel = new stringselection(strsel); cb.setcontents(sel, sel); } }.start(); }","repo":"css4j\/echosvg","label":[1,0,0,0]}
{"id":10102,"original_code":"protected boolean dispatchLocal(HttpServletRequest httpRequest,\n\t\t\tHttpServletResponse httpResponse) throws ServletException,\n\t\t\tIOException {\n\t\tif (LOGGER.isLoggable(Level.FINE)) {\n\t\t\tLOGGER.fine(\"Local dispatch \/\" + translateRequestPath(httpRequest));\n\t\t}\n\t\tif (!serveStatic) {\n\t\t\treturn false;\n\t\t}\n\/\/\t\tString contextRelativePath = httpRequest.getServletPath();\n\t\tString translatedNoQuery = \"\/\" + translateRequestPath(httpRequest);\n\/\/\t\tString absPath = getServletContext().getRealPath(contextRelativePath);\n\t\tString absPath = getServletContext().getRealPath(translatedNoQuery);\n\t\tif (this.isEnableMemento()) {\n\t\t\tMementoUtils.addDoNotNegotiateHeader(httpResponse);\n\t\t}\n\t\t\/\/IK: added null check for absPath, it may be null (ex. on jetty)\n\t\tif (absPath != null) {\n\t\t\tFile test = new File(absPath);\n\t\t\tif((test != null) && !test.exists()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tString translatedQ = \"\/\" + translateRequestPathQuery(httpRequest);\n\t\tWaybackRequest wbRequest = new WaybackRequest();\n\/\/\t\t\twbRequest.setContextPrefix(getUrlRoot());\n\t\twbRequest.setAccessPoint(this);\n\t\twbRequest.extractHttpRequestInfo(httpRequest);\n\t\tUIResults uiResults = new UIResults(wbRequest,uriConverter);\n\t\ttry {\n\t\t\tuiResults.forward(httpRequest, httpResponse, translatedQ);\n\t\t\treturn true;\n\t\t} catch(IOException e) {\n\t\t\t\/\/ TODO: figure out if we got IO because of a missing dispatcher\n\t\t}\n\t\treturn false;\n\t}","code_wo_comment":"protected boolean dispatchLocal(HttpServletRequest httpRequest,\n\t\t\tHttpServletResponse httpResponse) throws ServletException,\n\t\t\tIOException {\n\t\tif (LOGGER.isLoggable(Level.FINE)) {\n\t\t\tLOGGER.fine(\"Local dispatch \/\" + translateRequestPath(httpRequest));\n\t\t}\n\t\tif (!serveStatic) {\n\t\t\treturn false;\n\t\t}\n\t\tString translatedNoQuery = \"\/\" + translateRequestPath(httpRequest);\n\t\tString absPath = getServletContext().getRealPath(translatedNoQuery);\n\t\tif (this.isEnableMemento()) {\n\t\t\tMementoUtils.addDoNotNegotiateHeader(httpResponse);\n\t\t}\n\t\n\t\tif (absPath != null) {\n\t\t\tFile test = new File(absPath);\n\t\t\tif((test != null) && !test.exists()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tString translatedQ = \"\/\" + translateRequestPathQuery(httpRequest);\n\t\tWaybackRequest wbRequest = new WaybackRequest();\n\t\twbRequest.setAccessPoint(this);\n\t\twbRequest.extractHttpRequestInfo(httpRequest);\n\t\tUIResults uiResults = new UIResults(wbRequest,uriConverter);\n\t\ttry {\n\t\t\tuiResults.forward(httpRequest, httpResponse, translatedQ);\n\t\t\treturn true;\n\t\t} catch(IOException e) {\n\t\t\n\t\t}\n\t\treturn false;\n\t}","cleancode":"protected boolean dispatchlocal(httpservletrequest httprequest, httpservletresponse httpresponse) throws servletexception, ioexception { if (logger.isloggable(level.fine)) { logger.fine(\"local dispatch \/\" + translaterequestpath(httprequest)); } if (!servestatic) { return false; } string translatednoquery = \"\/\" + translaterequestpath(httprequest); string abspath = getservletcontext().getrealpath(translatednoquery); if (this.isenablememento()) { mementoutils.adddonotnegotiateheader(httpresponse); } if (abspath != null) { file test = new file(abspath); if((test != null) && !test.exists()) { return false; } } string translatedq = \"\/\" + translaterequestpathquery(httprequest); waybackrequest wbrequest = new waybackrequest(); wbrequest.setaccesspoint(this); wbrequest.extracthttprequestinfo(httprequest); uiresults uiresults = new uiresults(wbrequest,uriconverter); try { uiresults.forward(httprequest, httpresponse, translatedq); return true; } catch(ioexception e) { } return false; }","repo":"csrster\/openwayback-csrdev","label":[1,0,0,0]}
{"id":10103,"original_code":"public boolean handleRequest(HttpServletRequest httpRequest,\n\t\t\tHttpServletResponse httpResponse) throws ServletException,\n\t\t\tIOException {\n\t\tWaybackRequest wbRequest = null;\n\t\tboolean handled = false;\n\t\ttry {\n\t\t\tPerfStats.clearAll();\n\t\t\tif (this.isEnablePerfStatsHeader() && (perfStatsHeader != null)) {\n\t\t\t\tPerfStats.timeStart(PerfStat.Total);\n\t\t\t\thttpResponse = new PerfWritingHttpServletResponse(httpRequest,\n\t\t\t\t\thttpResponse, PerfStat.Total, perfStatsHeader,\n\t\t\t\t\tperfStatsHeaderFormat);\n\t\t\t}\n\t\t\tString inputPath = translateRequestPathQuery(httpRequest);\n\t\t\tThread.currentThread().setName(\"Thread \" +\n\t\t\t\t\tThread.currentThread().getId() + \" \" + getBeanName() +\n\t\t\t\t\t\" handling: \" + inputPath);\n\t\t\tLOGGER.fine(\"Handling translated: \" + inputPath);\n\t\t\twbRequest = getParser().parse(httpRequest, this);\n\t\t\tif (wbRequest != null) {\n\t\t\t\thandled = true;\n\t\t\t\t\/\/ TODO: refactor this code into RequestParser implementations\n\t\t\t\twbRequest.setAccessPoint(this);\n\/\/\t\t\t\twbRequest.setContextPrefix(getAbsoluteLocalPrefix(httpRequest));\n\/\/\t\t\t\twbRequest.setContextPrefix(getUrlRoot());\n\t\t\t\twbRequest.extractHttpRequestInfo(httpRequest);\n\t\t\t\t\/\/ end of refactor\n\t\t\t\tif (getAuthentication() != null) {\n\t\t\t\t\tif (!getAuthentication().isTrue(wbRequest)) {\n\t\t\t\t\t\tthrow new AuthenticationControlException(\n\t\t\t\t\t\t\t\"Unauthorized\", isRequestAuth());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/ set exclusionFilter on wbRequest only if not set externally\n\t\t\t\tif (wbRequest.getExclusionFilter() == null) {\n\t\t\t\t\twbRequest.setExclusionFilter(createExclusionFilter());\n\t\t\t\t}\n\t\t\t\t\/\/ TODO: refactor this into RequestParser implementations, so a\n\t\t\t\t\/\/ user could alter requests to change the behavior within a\n\t\t\t\t\/\/ single AccessPoint. For now, this is a simple way to expose\n\t\t\t\t\/\/ the feature to configuration.g\n\t\t\t\twbRequest.setExactScheme(isExactSchemeMatch());\n\t\t\t\tif (wbRequest.isReplayRequest()) {\n\t\t\t\t\tif (bounceToReplayPrefix) {\n\t\t\t\t\t\t\/\/ we don't accept replay requests on this AccessPoint\n\t\t\t\t\t\t\/\/ bounce the user to the right place:\n\t\t\t\t\t\tString suffix = translateRequestPathQuery(httpRequest);\n\t\t\t\t\t\tString replayUrl = replayPrefix + suffix;\n\t\t\t\t\t\thttpResponse.sendRedirect(replayUrl);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\thandleReplay(wbRequest, httpRequest, httpResponse);\n\t\t\t\t} else {\n\t\t\t\t\tif (bounceToQueryPrefix) {\n\t\t\t\t\t\t\/\/ we don't accept replay requests on this AccessPoint\n\t\t\t\t\t\t\/\/ bounce the user to the right place:\n\t\t\t\t\t\tString suffix = translateRequestPathQuery(httpRequest);\n\t\t\t\t\t\tString replayUrl = queryPrefix + suffix;\n\t\t\t\t\t\thttpResponse.sendRedirect(replayUrl);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\twbRequest.setExactHost(isExactHostMatch());\n\t\t\t\t\thandleQuery(wbRequest, httpRequest, httpResponse);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandled = dispatchLocal(httpRequest, httpResponse);\n\t\t\t}\n\t\t} catch (BetterRequestException e) {\n\t\t\te.generateResponse(httpResponse, wbRequest);\n\t\t\thttpResponse.getWriter(); \/\/ cause perf headers to be committed\n\t\t\thandled = true;\n\t\t} catch (WaybackException e) {\n\t\t\tif (httpResponse.isCommitted()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (wbRequest == null) {\n\t\t\t\twbRequest = new WaybackRequest();\n\t\t\t\twbRequest.setAccessPoint(this);\n\t\t\t}\n\t\t\tlogError(httpResponse, errorMsgHeader, e, wbRequest);\n\t\t\tLiveWebState liveWebState = LiveWebState.NOT_FOUND;\n\t\t\tif ((getLiveWebRedirector() != null) &&\n\t\t\t\t\t!wbRequest.hasMementoAcceptDatetime() && !wbRequest.isMementoTimemapRequest()) {\n\t\t\t\tliveWebState = getLiveWebRedirector().handleRedirect(e, wbRequest, httpRequest, httpResponse);\n\t\t\t}\n\t\t\t\/\/ If not liveweb redirected, then render current exception\n\t\t\tif (liveWebState != LiveWebState.REDIRECTED) {\n\t\t\t\te.setLiveWebAvailable(liveWebState == LiveWebState.FOUND);\n\t\t\t\tgetException().renderException(httpRequest, httpResponse, wbRequest, e, getUriConverter());\n\t\t\t}\n\t\t\thandled = true;\n\t\t} catch (Exception other) {\n\t\t\tlogError(httpResponse, errorMsgHeader, other, wbRequest);\n\t\t} finally {\n\t\t\t\/\/Slightly hacky, but ensures that all block loaders are closed\n\t\t\tZipNumBlockLoader.closeAllReaders();\n\t\t}\n\t\treturn handled;\n\t}","code_wo_comment":"public boolean handleRequest(HttpServletRequest httpRequest,\n\t\t\tHttpServletResponse httpResponse) throws ServletException,\n\t\t\tIOException {\n\t\tWaybackRequest wbRequest = null;\n\t\tboolean handled = false;\n\t\ttry {\n\t\t\tPerfStats.clearAll();\n\t\t\tif (this.isEnablePerfStatsHeader() && (perfStatsHeader != null)) {\n\t\t\t\tPerfStats.timeStart(PerfStat.Total);\n\t\t\t\thttpResponse = new PerfWritingHttpServletResponse(httpRequest,\n\t\t\t\t\thttpResponse, PerfStat.Total, perfStatsHeader,\n\t\t\t\t\tperfStatsHeaderFormat);\n\t\t\t}\n\t\t\tString inputPath = translateRequestPathQuery(httpRequest);\n\t\t\tThread.currentThread().setName(\"Thread \" +\n\t\t\t\t\tThread.currentThread().getId() + \" \" + getBeanName() +\n\t\t\t\t\t\" handling: \" + inputPath);\n\t\t\tLOGGER.fine(\"Handling translated: \" + inputPath);\n\t\t\twbRequest = getParser().parse(httpRequest, this);\n\t\t\tif (wbRequest != null) {\n\t\t\t\thandled = true;\n\t\t\t\n\t\t\t\twbRequest.setAccessPoint(this);\n\t\t\t\twbRequest.extractHttpRequestInfo(httpRequest);\n\t\t\t\n\t\t\t\tif (getAuthentication() != null) {\n\t\t\t\t\tif (!getAuthentication().isTrue(wbRequest)) {\n\t\t\t\t\t\tthrow new AuthenticationControlException(\n\t\t\t\t\t\t\t\"Unauthorized\", isRequestAuth());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tif (wbRequest.getExclusionFilter() == null) {\n\t\t\t\t\twbRequest.setExclusionFilter(createExclusionFilter());\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\twbRequest.setExactScheme(isExactSchemeMatch());\n\t\t\t\tif (wbRequest.isReplayRequest()) {\n\t\t\t\t\tif (bounceToReplayPrefix) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tString suffix = translateRequestPathQuery(httpRequest);\n\t\t\t\t\t\tString replayUrl = replayPrefix + suffix;\n\t\t\t\t\t\thttpResponse.sendRedirect(replayUrl);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\thandleReplay(wbRequest, httpRequest, httpResponse);\n\t\t\t\t} else {\n\t\t\t\t\tif (bounceToQueryPrefix) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tString suffix = translateRequestPathQuery(httpRequest);\n\t\t\t\t\t\tString replayUrl = queryPrefix + suffix;\n\t\t\t\t\t\thttpResponse.sendRedirect(replayUrl);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\twbRequest.setExactHost(isExactHostMatch());\n\t\t\t\t\thandleQuery(wbRequest, httpRequest, httpResponse);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thandled = dispatchLocal(httpRequest, httpResponse);\n\t\t\t}\n\t\t} catch (BetterRequestException e) {\n\t\t\te.generateResponse(httpResponse, wbRequest);\n\t\t\thttpResponse.getWriter();\n\t\t\thandled = true;\n\t\t} catch (WaybackException e) {\n\t\t\tif (httpResponse.isCommitted()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (wbRequest == null) {\n\t\t\t\twbRequest = new WaybackRequest();\n\t\t\t\twbRequest.setAccessPoint(this);\n\t\t\t}\n\t\t\tlogError(httpResponse, errorMsgHeader, e, wbRequest);\n\t\t\tLiveWebState liveWebState = LiveWebState.NOT_FOUND;\n\t\t\tif ((getLiveWebRedirector() != null) &&\n\t\t\t\t\t!wbRequest.hasMementoAcceptDatetime() && !wbRequest.isMementoTimemapRequest()) {\n\t\t\t\tliveWebState = getLiveWebRedirector().handleRedirect(e, wbRequest, httpRequest, httpResponse);\n\t\t\t}\n\t\t\n\t\t\tif (liveWebState != LiveWebState.REDIRECTED) {\n\t\t\t\te.setLiveWebAvailable(liveWebState == LiveWebState.FOUND);\n\t\t\t\tgetException().renderException(httpRequest, httpResponse, wbRequest, e, getUriConverter());\n\t\t\t}\n\t\t\thandled = true;\n\t\t} catch (Exception other) {\n\t\t\tlogError(httpResponse, errorMsgHeader, other, wbRequest);\n\t\t} finally {\n\t\t\n\t\t\tZipNumBlockLoader.closeAllReaders();\n\t\t}\n\t\treturn handled;\n\t}","cleancode":"public boolean handlerequest(httpservletrequest httprequest, httpservletresponse httpresponse) throws servletexception, ioexception { waybackrequest wbrequest = null; boolean handled = false; try { perfstats.clearall(); if (this.isenableperfstatsheader() && (perfstatsheader != null)) { perfstats.timestart(perfstat.total); httpresponse = new perfwritinghttpservletresponse(httprequest, httpresponse, perfstat.total, perfstatsheader, perfstatsheaderformat); } string inputpath = translaterequestpathquery(httprequest); thread.currentthread().setname(\"thread \" + thread.currentthread().getid() + \" \" + getbeanname() + \" handling: \" + inputpath); logger.fine(\"handling translated: \" + inputpath); wbrequest = getparser().parse(httprequest, this); if (wbrequest != null) { handled = true; wbrequest.setaccesspoint(this); wbrequest.extracthttprequestinfo(httprequest); if (getauthentication() != null) { if (!getauthentication().istrue(wbrequest)) { throw new authenticationcontrolexception( \"unauthorized\", isrequestauth()); } } if (wbrequest.getexclusionfilter() == null) { wbrequest.setexclusionfilter(createexclusionfilter()); } wbrequest.setexactscheme(isexactschemematch()); if (wbrequest.isreplayrequest()) { if (bouncetoreplayprefix) { string suffix = translaterequestpathquery(httprequest); string replayurl = replayprefix + suffix; httpresponse.sendredirect(replayurl); return true; } handlereplay(wbrequest, httprequest, httpresponse); } else { if (bouncetoqueryprefix) { string suffix = translaterequestpathquery(httprequest); string replayurl = queryprefix + suffix; httpresponse.sendredirect(replayurl); return true; } wbrequest.setexacthost(isexacthostmatch()); handlequery(wbrequest, httprequest, httpresponse); } } else { handled = dispatchlocal(httprequest, httpresponse); } } catch (betterrequestexception e) { e.generateresponse(httpresponse, wbrequest); httpresponse.getwriter(); handled = true; } catch (waybackexception e) { if (httpresponse.iscommitted()) { return true; } if (wbrequest == null) { wbrequest = new waybackrequest(); wbrequest.setaccesspoint(this); } logerror(httpresponse, errormsgheader, e, wbrequest); livewebstate livewebstate = livewebstate.not_found; if ((getlivewebredirector() != null) && !wbrequest.hasmementoacceptdatetime() && !wbrequest.ismementotimemaprequest()) { livewebstate = getlivewebredirector().handleredirect(e, wbrequest, httprequest, httpresponse); } if (livewebstate != livewebstate.redirected) { e.setlivewebavailable(livewebstate == livewebstate.found); getexception().renderexception(httprequest, httpresponse, wbrequest, e, geturiconverter()); } handled = true; } catch (exception other) { logerror(httpresponse, errormsgheader, other, wbrequest); } finally { zipnumblockloader.closeallreaders(); } return handled; }","repo":"csrster\/openwayback-csrdev","label":[1,0,0,0]}
{"id":1957,"original_code":"private void actionDelete(AjaxRequestTarget aTarget)\n        throws IOException, UIMAException, ClassNotFoundException\n    {\n        BratAnnotatorModel bratAnnotatorModel = getModelObject();\n        JCas jCas = getCas(bratAnnotatorModel);\n        AnnotationFS fs = selectByAddr(jCas, selectedAnnotationId);\n        TypeAdapter adapter = getAdapter(selectedAnnotationLayer);\n        String attachFeatureName = adapter.getAttachFeatureName();\n        String attachTypeName = adapter.getAnnotationTypeName();\n        Set<TypeAdapter> typeAdapters = new HashSet<TypeAdapter>();\n        for (AnnotationLayer layer : annotationService.listAnnotationLayer(bratAnnotatorModel\n                .getProject())) {\n            typeAdapters.add(getAdapter(layer));\n        }\n        \/\/ delete associated relation annotation\n        for (TypeAdapter ad : typeAdapters) {\n            if (adapter.getAnnotationTypeName().equals(ad.getAnnotationTypeName())) {\n                continue;\n            }\n            String tn = ad.getAttachTypeName();\n            if (tn == null) {\n                continue;\n            }\n            if (tn.equals(attachTypeName)) {\n                Sentence thisSentence = BratAjaxCasUtil.getCurrentSentence(jCas, beginOffset,\n                        endOffset);\n                ad.deleteBySpan(jCas, fs, thisSentence.getBegin(), thisSentence.getEnd());\n                break;\n            }\n            String fn = ad.getAttachFeatureName();\n            if (fn == null) {\n                continue;\n            }\n            if (fn.equals(attachFeatureName)) {\n                Sentence thisSentence = BratAjaxCasUtil.getCurrentSentence(jCas, beginOffset,\n                        endOffset);\n                ad.deleteBySpan(jCas, fs, thisSentence.getBegin(), thisSentence.getEnd());\n                break;\n            }\n        }\n        \/\/ BEGIN HACK - Issue 933\n        if (adapter instanceof ChainAdapter) {\n            ((ChainAdapter) adapter).setArc(false);\n        }\n        \/\/ END HACK - Issue 933\n        adapter.delete(jCas, selectedAnnotationId);\n        repository.updateJCas(bratAnnotatorModel.getMode(), bratAnnotatorModel.getDocument(),\n                bratAnnotatorModel.getUser(), jCas);\n        \/\/ update timestamp now\n        int sentenceNumber = BratAjaxCasUtil.getSentenceNumber(jCas, beginOffset);\n        bratAnnotatorModel.getDocument().setSentenceAccessed(sentenceNumber);\n        repository.updateTimeStamp(bratAnnotatorModel.getDocument(), bratAnnotatorModel.getUser(),\n                bratAnnotatorModel.getMode());\n        if (bratAnnotatorModel.isScrollPage()) {\n            updateSentenceAddressAndOffsets(jCas, beginOffset);\n        }\n        bratAnnotatorModel.setRememberedSpanLayer(selectedAnnotationLayer);\n        bratAnnotatorModel.setAnnotate(false);\n        \/\/ store latest annotations\n        for (IModel<String> model : featureValueModels) {\n            AnnotationFeature feature = featuresModel.get(featureValueModels.indexOf(model))\n                    .getObject().feature;\n            selectedAnnotationLayer = feature.getLayer();\n            selectedFeatureValues.put(feature, model.getObject());\n        }\n        info(generateMessage(selectedAnnotationLayer, null, true));\n        \/\/ A hack to rememeber the Visural DropDown display\n        \/\/ value\n        bratAnnotatorModel.setRememberedSpanLayer(selectedAnnotationLayer);\n        bratAnnotatorModel.setRememberedSpanFeatures(selectedFeatureValues);\n        selectedSpanText = \"\";\n        selectedAnnotationId = -1;\n        aTarget.add(annotationFeatureForm);\n       \/\/ setLayerAndFeatureModels(jCas);\n        bratRender(aTarget, jCas);\n        onChange(aTarget, getModelObject());\n    }","code_wo_comment":"private void actionDelete(AjaxRequestTarget aTarget)\n        throws IOException, UIMAException, ClassNotFoundException\n    {\n        BratAnnotatorModel bratAnnotatorModel = getModelObject();\n        JCas jCas = getCas(bratAnnotatorModel);\n        AnnotationFS fs = selectByAddr(jCas, selectedAnnotationId);\n        TypeAdapter adapter = getAdapter(selectedAnnotationLayer);\n        String attachFeatureName = adapter.getAttachFeatureName();\n        String attachTypeName = adapter.getAnnotationTypeName();\n        Set<TypeAdapter> typeAdapters = new HashSet<TypeAdapter>();\n        for (AnnotationLayer layer : annotationService.listAnnotationLayer(bratAnnotatorModel\n                .getProject())) {\n            typeAdapters.add(getAdapter(layer));\n        }\n       \n        for (TypeAdapter ad : typeAdapters) {\n            if (adapter.getAnnotationTypeName().equals(ad.getAnnotationTypeName())) {\n                continue;\n            }\n            String tn = ad.getAttachTypeName();\n            if (tn == null) {\n                continue;\n            }\n            if (tn.equals(attachTypeName)) {\n                Sentence thisSentence = BratAjaxCasUtil.getCurrentSentence(jCas, beginOffset,\n                        endOffset);\n                ad.deleteBySpan(jCas, fs, thisSentence.getBegin(), thisSentence.getEnd());\n                break;\n            }\n            String fn = ad.getAttachFeatureName();\n            if (fn == null) {\n                continue;\n            }\n            if (fn.equals(attachFeatureName)) {\n                Sentence thisSentence = BratAjaxCasUtil.getCurrentSentence(jCas, beginOffset,\n                        endOffset);\n                ad.deleteBySpan(jCas, fs, thisSentence.getBegin(), thisSentence.getEnd());\n                break;\n            }\n        }\n       \n        if (adapter instanceof ChainAdapter) {\n            ((ChainAdapter) adapter).setArc(false);\n        }\n       \n        adapter.delete(jCas, selectedAnnotationId);\n        repository.updateJCas(bratAnnotatorModel.getMode(), bratAnnotatorModel.getDocument(),\n                bratAnnotatorModel.getUser(), jCas);\n       \n        int sentenceNumber = BratAjaxCasUtil.getSentenceNumber(jCas, beginOffset);\n        bratAnnotatorModel.getDocument().setSentenceAccessed(sentenceNumber);\n        repository.updateTimeStamp(bratAnnotatorModel.getDocument(), bratAnnotatorModel.getUser(),\n                bratAnnotatorModel.getMode());\n        if (bratAnnotatorModel.isScrollPage()) {\n            updateSentenceAddressAndOffsets(jCas, beginOffset);\n        }\n        bratAnnotatorModel.setRememberedSpanLayer(selectedAnnotationLayer);\n        bratAnnotatorModel.setAnnotate(false);\n       \n        for (IModel<String> model : featureValueModels) {\n            AnnotationFeature feature = featuresModel.get(featureValueModels.indexOf(model))\n                    .getObject().feature;\n            selectedAnnotationLayer = feature.getLayer();\n            selectedFeatureValues.put(feature, model.getObject());\n        }\n        info(generateMessage(selectedAnnotationLayer, null, true));\n       \n       \n        bratAnnotatorModel.setRememberedSpanLayer(selectedAnnotationLayer);\n        bratAnnotatorModel.setRememberedSpanFeatures(selectedFeatureValues);\n        selectedSpanText = \"\";\n        selectedAnnotationId = -1;\n        aTarget.add(annotationFeatureForm);\n      \n        bratRender(aTarget, jCas);\n        onChange(aTarget, getModelObject());\n    }","cleancode":"private void actiondelete(ajaxrequesttarget atarget) throws ioexception, uimaexception, classnotfoundexception { bratannotatormodel bratannotatormodel = getmodelobject(); jcas jcas = getcas(bratannotatormodel); annotationfs fs = selectbyaddr(jcas, selectedannotationid); typeadapter adapter = getadapter(selectedannotationlayer); string attachfeaturename = adapter.getattachfeaturename(); string attachtypename = adapter.getannotationtypename(); set<typeadapter> typeadapters = new hashset<typeadapter>(); for (annotationlayer layer : annotationservice.listannotationlayer(bratannotatormodel .getproject())) { typeadapters.add(getadapter(layer)); } for (typeadapter ad : typeadapters) { if (adapter.getannotationtypename().equals(ad.getannotationtypename())) { continue; } string tn = ad.getattachtypename(); if (tn == null) { continue; } if (tn.equals(attachtypename)) { sentence thissentence = bratajaxcasutil.getcurrentsentence(jcas, beginoffset, endoffset); ad.deletebyspan(jcas, fs, thissentence.getbegin(), thissentence.getend()); break; } string fn = ad.getattachfeaturename(); if (fn == null) { continue; } if (fn.equals(attachfeaturename)) { sentence thissentence = bratajaxcasutil.getcurrentsentence(jcas, beginoffset, endoffset); ad.deletebyspan(jcas, fs, thissentence.getbegin(), thissentence.getend()); break; } } if (adapter instanceof chainadapter) { ((chainadapter) adapter).setarc(false); } adapter.delete(jcas, selectedannotationid); repository.updatejcas(bratannotatormodel.getmode(), bratannotatormodel.getdocument(), bratannotatormodel.getuser(), jcas); int sentencenumber = bratajaxcasutil.getsentencenumber(jcas, beginoffset); bratannotatormodel.getdocument().setsentenceaccessed(sentencenumber); repository.updatetimestamp(bratannotatormodel.getdocument(), bratannotatormodel.getuser(), bratannotatormodel.getmode()); if (bratannotatormodel.isscrollpage()) { updatesentenceaddressandoffsets(jcas, beginoffset); } bratannotatormodel.setrememberedspanlayer(selectedannotationlayer); bratannotatormodel.setannotate(false); for (imodel<string> model : featurevaluemodels) { annotationfeature feature = featuresmodel.get(featurevaluemodels.indexof(model)) .getobject().feature; selectedannotationlayer = feature.getlayer(); selectedfeaturevalues.put(feature, model.getobject()); } info(generatemessage(selectedannotationlayer, null, true)); bratannotatormodel.setrememberedspanlayer(selectedannotationlayer); bratannotatormodel.setrememberedspanfeatures(selectedfeaturevalues); selectedspantext = \"\"; selectedannotationid = -1; atarget.add(annotationfeatureform); bratrender(atarget, jcas); onchange(atarget, getmodelobject()); }","repo":"debovis\/webanno","label":[0,0,0,0]}
{"id":34792,"original_code":"private List<Pair<Object, Double>> getMostInfluentialFeatures(Label clazz, FeatureVector featureVector) {\n        assert this.model instanceof NaiveBayesModel;\n        NaiveBayesModel myModel = (NaiveBayesModel) this.model;\n        List<Pair<Object, Double>> mostInfluentialFeatures = new ArrayList<>();\n        for (Object feature : featureVector) {\n            double classConditional = myModel.computeClassConditionalProbability(feature, clazz);\n            if (useLogits)\n                classConditional = -Math.log(classConditional);\n            mostInfluentialFeatures.add(Pair.of(feature, classConditional));\n        }\n        \/\/ sort the list\n        \/\/ TODO understand logits!!\n        \/\/  remove 1 counts!\n        if (useLogits)\n            mostInfluentialFeatures.sort(Comparator.comparing(Pair::getRight));\n        else\n            mostInfluentialFeatures.sort((o1, o2) -> o2.getRight().compareTo(o1.getRight()));\n        return mostInfluentialFeatures.subList(0, mostInfluentialFeatures.size() <= numberOfInfluentialFeatures ? mostInfluentialFeatures.size() - 1 : numberOfInfluentialFeatures);\n    }","code_wo_comment":"private List<Pair<Object, Double>> getMostInfluentialFeatures(Label clazz, FeatureVector featureVector) {\n        assert this.model instanceof NaiveBayesModel;\n        NaiveBayesModel myModel = (NaiveBayesModel) this.model;\n        List<Pair<Object, Double>> mostInfluentialFeatures = new ArrayList<>();\n        for (Object feature : featureVector) {\n            double classConditional = myModel.computeClassConditionalProbability(feature, clazz);\n            if (useLogits)\n                classConditional = -Math.log(classConditional);\n            mostInfluentialFeatures.add(Pair.of(feature, classConditional));\n        }\n       \n       \n       \n        if (useLogits)\n            mostInfluentialFeatures.sort(Comparator.comparing(Pair::getRight));\n        else\n            mostInfluentialFeatures.sort((o1, o2) -> o2.getRight().compareTo(o1.getRight()));\n        return mostInfluentialFeatures.subList(0, mostInfluentialFeatures.size() <= numberOfInfluentialFeatures ? mostInfluentialFeatures.size() - 1 : numberOfInfluentialFeatures);\n    }","cleancode":"private list<pair<object, double>> getmostinfluentialfeatures(label clazz, featurevector featurevector) { assert this.model instanceof naivebayesmodel; naivebayesmodel mymodel = (naivebayesmodel) this.model; list<pair<object, double>> mostinfluentialfeatures = new arraylist<>(); for (object feature : featurevector) { double classconditional = mymodel.computeclassconditionalprobability(feature, clazz); if (uselogits) classconditional = -math.log(classconditional); mostinfluentialfeatures.add(pair.of(feature, classconditional)); } if (uselogits) mostinfluentialfeatures.sort(comparator.comparing(pair::getright)); else mostinfluentialfeatures.sort((o1, o2) -> o2.getright().compareto(o1.getright())); return mostinfluentialfeatures.sublist(0, mostinfluentialfeatures.size() <= numberofinfluentialfeatures ? mostinfluentialfeatures.size() - 1 : numberofinfluentialfeatures); }","repo":"floschne\/NLP_ThumbnailAnnotator","label":[1,0,0,0]}
{"id":34835,"original_code":"@Override\n    public boolean allowsNewVlanCreation() throws CloudException, InternalException {\n        \/\/ TODO: change me when implemented\n        return false;\n    }","code_wo_comment":"@Override\n    public boolean allowsNewVlanCreation() throws CloudException, InternalException {\n       \n        return false;\n    }","cleancode":"@override public boolean allowsnewvlancreation() throws cloudexception, internalexception { return false; }","repo":"erik-johnson\/dasein-cloud-vcloud","label":[0,1,0,0]}
{"id":34840,"original_code":"@DataProvider(name = \"TrimCigarData\")\n    public Object[][] makeTrimCigarData() {\n        List<Object[]> tests = new ArrayList<>();\n        for ( final CigarOperator op : Arrays.asList(CigarOperator.D, CigarOperator.EQ, CigarOperator.X, CigarOperator.M) ) {\n            for ( int myLength = 1; myLength < 6; myLength++ ) {\n                for ( int start = 0; start < myLength - 1; start++ ) {\n                    for ( int end = start; end < myLength; end++ ) {\n                        final int length = end - start + 1;\n                        final List<CigarOperator> padOps = Arrays.asList(CigarOperator.D, CigarOperator.M);\n                        for ( final CigarOperator padOp: padOps) {\n                            for ( int leftPad = 0; leftPad < 2; leftPad++ ) {\n                                for ( int rightPad = 0; rightPad < 2; rightPad++ ) {\n                                    tests.add(new Object[]{\n                                            (leftPad > 0 ? leftPad + padOp.toString() : \"\") + myLength + op.toString() + (rightPad > 0 ? rightPad + padOp.toString() : \"\"),\n                                            start + leftPad,\n                                            end + leftPad,\n                                            length + op.toString()});\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for ( final int leftPad : Arrays.asList(0, 1, 2, 5) ) {\n            for ( final int rightPad : Arrays.asList(0, 1, 2, 5) ) {\n                final int length = leftPad + rightPad;\n                if ( length > 0 ) {\n                    for ( final int insSize : Arrays.asList(1, 10) ) {\n                        for ( int start = 0; start <= leftPad; start++ ) {\n                            for ( int stop = leftPad; stop < length; stop++ ) {\n                                final int leftPadRemaining = leftPad - start;\n                                final int rightPadRemaining = stop - leftPad + 1;\n                                final String insC = insSize + \"I\";\n                                tests.add(new Object[]{\n                                        leftPad + \"M\" + insC + rightPad + \"M\",\n                                        start,\n                                        stop,\n                                        (leftPadRemaining > 0 ? leftPadRemaining + \"M\" : \"\") + insC + (rightPadRemaining > 0 ? rightPadRemaining + \"M\" : \"\")\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        tests.add(new Object[]{\"3M2D4M\", 0, 8, \"3M2D4M\"});\n        tests.add(new Object[]{\"3M2D4M\", 2, 8, \"1M2D4M\"});\n        tests.add(new Object[]{\"3M2D4M\", 2, 6, \"1M2D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 3, 6, \"2D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 4, 6, \"1D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 5, 6, \"2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 6, 6, \"1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 0, 5, \"2M3I4M\"});\n        tests.add(new Object[]{\"2M3I4M\", 1, 5, \"1M3I4M\"});\n        tests.add(new Object[]{\"2M3I4M\", 1, 4, \"1M3I3M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 4, \"3I3M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 3, \"3I2M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 2, \"3I1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 3, 4, \"2M\"});\n        tests.add(new Object[]{\"2M3I4M\", 3, 3, \"1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 4, 4, \"1M\"});\n        \/\/ this doesn't work -- but I'm not sure it should\n        \/\/        tests.add(new Object[]{\"2M3I4M\", 2, 1, \"3I\"});\n        return tests.toArray(new Object[][]{});\n    }","code_wo_comment":"@DataProvider(name = \"TrimCigarData\")\n    public Object[][] makeTrimCigarData() {\n        List<Object[]> tests = new ArrayList<>();\n        for ( final CigarOperator op : Arrays.asList(CigarOperator.D, CigarOperator.EQ, CigarOperator.X, CigarOperator.M) ) {\n            for ( int myLength = 1; myLength < 6; myLength++ ) {\n                for ( int start = 0; start < myLength - 1; start++ ) {\n                    for ( int end = start; end < myLength; end++ ) {\n                        final int length = end - start + 1;\n                        final List<CigarOperator> padOps = Arrays.asList(CigarOperator.D, CigarOperator.M);\n                        for ( final CigarOperator padOp: padOps) {\n                            for ( int leftPad = 0; leftPad < 2; leftPad++ ) {\n                                for ( int rightPad = 0; rightPad < 2; rightPad++ ) {\n                                    tests.add(new Object[]{\n                                            (leftPad > 0 ? leftPad + padOp.toString() : \"\") + myLength + op.toString() + (rightPad > 0 ? rightPad + padOp.toString() : \"\"),\n                                            start + leftPad,\n                                            end + leftPad,\n                                            length + op.toString()});\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        for ( final int leftPad : Arrays.asList(0, 1, 2, 5) ) {\n            for ( final int rightPad : Arrays.asList(0, 1, 2, 5) ) {\n                final int length = leftPad + rightPad;\n                if ( length > 0 ) {\n                    for ( final int insSize : Arrays.asList(1, 10) ) {\n                        for ( int start = 0; start <= leftPad; start++ ) {\n                            for ( int stop = leftPad; stop < length; stop++ ) {\n                                final int leftPadRemaining = leftPad - start;\n                                final int rightPadRemaining = stop - leftPad + 1;\n                                final String insC = insSize + \"I\";\n                                tests.add(new Object[]{\n                                        leftPad + \"M\" + insC + rightPad + \"M\",\n                                        start,\n                                        stop,\n                                        (leftPadRemaining > 0 ? leftPadRemaining + \"M\" : \"\") + insC + (rightPadRemaining > 0 ? rightPadRemaining + \"M\" : \"\")\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        tests.add(new Object[]{\"3M2D4M\", 0, 8, \"3M2D4M\"});\n        tests.add(new Object[]{\"3M2D4M\", 2, 8, \"1M2D4M\"});\n        tests.add(new Object[]{\"3M2D4M\", 2, 6, \"1M2D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 3, 6, \"2D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 4, 6, \"1D2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 5, 6, \"2M\"});\n        tests.add(new Object[]{\"3M2D4M\", 6, 6, \"1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 0, 5, \"2M3I4M\"});\n        tests.add(new Object[]{\"2M3I4M\", 1, 5, \"1M3I4M\"});\n        tests.add(new Object[]{\"2M3I4M\", 1, 4, \"1M3I3M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 4, \"3I3M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 3, \"3I2M\"});\n        tests.add(new Object[]{\"2M3I4M\", 2, 2, \"3I1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 3, 4, \"2M\"});\n        tests.add(new Object[]{\"2M3I4M\", 3, 3, \"1M\"});\n        tests.add(new Object[]{\"2M3I4M\", 4, 4, \"1M\"});\n       \n       \n        return tests.toArray(new Object[][]{});\n    }","cleancode":"@dataprovider(name = \"trimcigardata\") public object[][] maketrimcigardata() { list<object[]> tests = new arraylist<>(); for ( final cigaroperator op : arrays.aslist(cigaroperator.d, cigaroperator.eq, cigaroperator.x, cigaroperator.m) ) { for ( int mylength = 1; mylength < 6; mylength++ ) { for ( int start = 0; start < mylength - 1; start++ ) { for ( int end = start; end < mylength; end++ ) { final int length = end - start + 1; final list<cigaroperator> padops = arrays.aslist(cigaroperator.d, cigaroperator.m); for ( final cigaroperator padop: padops) { for ( int leftpad = 0; leftpad < 2; leftpad++ ) { for ( int rightpad = 0; rightpad < 2; rightpad++ ) { tests.add(new object[]{ (leftpad > 0 ? leftpad + padop.tostring() : \"\") + mylength + op.tostring() + (rightpad > 0 ? rightpad + padop.tostring() : \"\"), start + leftpad, end + leftpad, length + op.tostring()}); } } } } } } } for ( final int leftpad : arrays.aslist(0, 1, 2, 5) ) { for ( final int rightpad : arrays.aslist(0, 1, 2, 5) ) { final int length = leftpad + rightpad; if ( length > 0 ) { for ( final int inssize : arrays.aslist(1, 10) ) { for ( int start = 0; start <= leftpad; start++ ) { for ( int stop = leftpad; stop < length; stop++ ) { final int leftpadremaining = leftpad - start; final int rightpadremaining = stop - leftpad + 1; final string insc = inssize + \"i\"; tests.add(new object[]{ leftpad + \"m\" + insc + rightpad + \"m\", start, stop, (leftpadremaining > 0 ? leftpadremaining + \"m\" : \"\") + insc + (rightpadremaining > 0 ? rightpadremaining + \"m\" : \"\") }); } } } } } } tests.add(new object[]{\"3m2d4m\", 0, 8, \"3m2d4m\"}); tests.add(new object[]{\"3m2d4m\", 2, 8, \"1m2d4m\"}); tests.add(new object[]{\"3m2d4m\", 2, 6, \"1m2d2m\"}); tests.add(new object[]{\"3m2d4m\", 3, 6, \"2d2m\"}); tests.add(new object[]{\"3m2d4m\", 4, 6, \"1d2m\"}); tests.add(new object[]{\"3m2d4m\", 5, 6, \"2m\"}); tests.add(new object[]{\"3m2d4m\", 6, 6, \"1m\"}); tests.add(new object[]{\"2m3i4m\", 0, 5, \"2m3i4m\"}); tests.add(new object[]{\"2m3i4m\", 1, 5, \"1m3i4m\"}); tests.add(new object[]{\"2m3i4m\", 1, 4, \"1m3i3m\"}); tests.add(new object[]{\"2m3i4m\", 2, 4, \"3i3m\"}); tests.add(new object[]{\"2m3i4m\", 2, 3, \"3i2m\"}); tests.add(new object[]{\"2m3i4m\", 2, 2, \"3i1m\"}); tests.add(new object[]{\"2m3i4m\", 3, 4, \"2m\"}); tests.add(new object[]{\"2m3i4m\", 3, 3, \"1m\"}); tests.add(new object[]{\"2m3i4m\", 4, 4, \"1m\"}); return tests.toarray(new object[][]{}); }","repo":"ga4gh\/gatk","label":[0,0,1,0]}
{"id":18558,"original_code":"@Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        \/\/TODO set last message time\n        final ChatDescription description = descriptionList.get(position);\n        User mainUser = ((GlobalVars)(inboxFragment.getActivity()).getApplication()).getUser();\n        final User otherUser;\n        if (Objects.equals(mainUser.getUid(), description.getUserid1()))\n            otherUser = userMap.get(description.getUserid2());\n        else otherUser = userMap.get(description.getUserid1());\n        final InboxViewHolder viewHolder = (InboxViewHolder) holder;\n        Glide.with(context).load(otherUser.getProfileUrl()).asBitmap().centerCrop().dontAnimate().\n                into(new BitmapImageViewTarget(viewHolder.ivProfile) {\n                    @Override\n                    protected void setResource(Bitmap resource) {\n                        RoundedBitmapDrawable circularBitmapDrawable =\n                                RoundedBitmapDrawableFactory.create(context.getResources(), resource);\n                        circularBitmapDrawable.setCircular(true);\n                        viewHolder.ivProfile.setImageDrawable(circularBitmapDrawable);\n                        viewHolder.ivProfile.setBorderColor(otherUser.getColorHexDark(context));\n                    }\n                });\n        String lastMessage;\n        if (description.lastMessage != null) lastMessage = description.lastMessage.getText();\n        else lastMessage = \"\";\n        viewHolder.tvLastMessage.setText(lastMessage);\n        viewHolder.tvLastMessage.setEllipsize(TextUtils.TruncateAt.END);\n        viewHolder.tvLastMessage.setMaxLines(2);\n        viewHolder.tvOtherUserName.setText(otherUser.getFirstName());\n        Long seconds = description.getLastMessage().getSentTime().getTime();\n        viewHolder.tvTime.setText(TimeFormatter.getTimeDifference(seconds));\n        viewHolder.itemView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent i = new Intent(view.getContext(), MessageActivity.class);\n                i.putExtra(\"otherUser\", Parcels.wrap(otherUser));\n                i.putExtra(\"description\", Parcels.wrap(description));\n                inboxFragment.startActivityForResult(i, InboxFragment.CHANGEDESCRIPTION);\n            }\n        });\n        if (position == 0) holder.itemView.setPadding(0, 200, 0, 0); \/\/not the right way to do this\n    }","code_wo_comment":"@Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n       \n        final ChatDescription description = descriptionList.get(position);\n        User mainUser = ((GlobalVars)(inboxFragment.getActivity()).getApplication()).getUser();\n        final User otherUser;\n        if (Objects.equals(mainUser.getUid(), description.getUserid1()))\n            otherUser = userMap.get(description.getUserid2());\n        else otherUser = userMap.get(description.getUserid1());\n        final InboxViewHolder viewHolder = (InboxViewHolder) holder;\n        Glide.with(context).load(otherUser.getProfileUrl()).asBitmap().centerCrop().dontAnimate().\n                into(new BitmapImageViewTarget(viewHolder.ivProfile) {\n                    @Override\n                    protected void setResource(Bitmap resource) {\n                        RoundedBitmapDrawable circularBitmapDrawable =\n                                RoundedBitmapDrawableFactory.create(context.getResources(), resource);\n                        circularBitmapDrawable.setCircular(true);\n                        viewHolder.ivProfile.setImageDrawable(circularBitmapDrawable);\n                        viewHolder.ivProfile.setBorderColor(otherUser.getColorHexDark(context));\n                    }\n                });\n        String lastMessage;\n        if (description.lastMessage != null) lastMessage = description.lastMessage.getText();\n        else lastMessage = \"\";\n        viewHolder.tvLastMessage.setText(lastMessage);\n        viewHolder.tvLastMessage.setEllipsize(TextUtils.TruncateAt.END);\n        viewHolder.tvLastMessage.setMaxLines(2);\n        viewHolder.tvOtherUserName.setText(otherUser.getFirstName());\n        Long seconds = description.getLastMessage().getSentTime().getTime();\n        viewHolder.tvTime.setText(TimeFormatter.getTimeDifference(seconds));\n        viewHolder.itemView.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                Intent i = new Intent(view.getContext(), MessageActivity.class);\n                i.putExtra(\"otherUser\", Parcels.wrap(otherUser));\n                i.putExtra(\"description\", Parcels.wrap(description));\n                inboxFragment.startActivityForResult(i, InboxFragment.CHANGEDESCRIPTION);\n            }\n        });\n        if (position == 0) holder.itemView.setPadding(0, 200, 0, 0);\n    }","cleancode":"@override public void onbindviewholder(recyclerview.viewholder holder, int position) { final chatdescription description = descriptionlist.get(position); user mainuser = ((globalvars)(inboxfragment.getactivity()).getapplication()).getuser(); final user otheruser; if (objects.equals(mainuser.getuid(), description.getuserid1())) otheruser = usermap.get(description.getuserid2()); else otheruser = usermap.get(description.getuserid1()); final inboxviewholder viewholder = (inboxviewholder) holder; glide.with(context).load(otheruser.getprofileurl()).asbitmap().centercrop().dontanimate(). into(new bitmapimageviewtarget(viewholder.ivprofile) { @override protected void setresource(bitmap resource) { roundedbitmapdrawable circularbitmapdrawable = roundedbitmapdrawablefactory.create(context.getresources(), resource); circularbitmapdrawable.setcircular(true); viewholder.ivprofile.setimagedrawable(circularbitmapdrawable); viewholder.ivprofile.setbordercolor(otheruser.getcolorhexdark(context)); } }); string lastmessage; if (description.lastmessage != null) lastmessage = description.lastmessage.gettext(); else lastmessage = \"\"; viewholder.tvlastmessage.settext(lastmessage); viewholder.tvlastmessage.setellipsize(textutils.truncateat.end); viewholder.tvlastmessage.setmaxlines(2); viewholder.tvotherusername.settext(otheruser.getfirstname()); long seconds = description.getlastmessage().getsenttime().gettime(); viewholder.tvtime.settext(timeformatter.gettimedifference(seconds)); viewholder.itemview.setonclicklistener(new view.onclicklistener() { @override public void onclick(view view) { intent i = new intent(view.getcontext(), messageactivity.class); i.putextra(\"otheruser\", parcels.wrap(otheruser)); i.putextra(\"description\", parcels.wrap(description)); inboxfragment.startactivityforresult(i, inboxfragment.changedescription); } }); if (position == 0) holder.itemview.setpadding(0, 200, 0, 0); }","repo":"dgisser\/Ripple","label":[0,1,0,0]}
{"id":18576,"original_code":"private void computeTimes (TransportNetwork network, ProfileRequest req, TIntIntMap accessTimes, TIntIntMap egressTimes) {\n        if (!accessTimes.containsKey(this.boardStops[0])) throw new IllegalArgumentException(\"Access times do not contain first stop of path!\");\n        if (!egressTimes.containsKey(this.alightStops[this.length - 1])) throw new IllegalArgumentException(\"Egress times do not contain last stop of path!\");\n        int accessTime = accessTimes.get(this.boardStops[0]);\n        int egressTime = egressTimes.get(this.alightStops[this.length - 1]);\n        if (network.transitLayer.hasFrequencies) {\n            \/\/ TODO fix\n            throw new UnsupportedOperationException(\"Frequency-based trips are not yet supported in customer-facing profile routing\");\n        }\n        \/\/ we now know what patterns are being used, interleave to find times\n        \/\/ NB no need to reverse-optimize these itineraries; we'll just filter them below.\n        TripPattern[] patterns = IntStream.of(this.patterns).mapToObj(p -> network.transitLayer.tripPatterns.get(p)).toArray(s -> new TripPattern[s]);\n        \/\/ find all possible times to board and alight each pattern\n        \/\/ for each trip pattern, for each trip on that pattern, array of [depart origin, arrive destination]\n        int[][][] times = new int[patterns.length][][];\n        for (int patIdx = 0; patIdx < patterns.length; patIdx++) {\n            final int pidx = patIdx;\n            int fromStopInPattern = 0;\n            while (patterns[patIdx].stops[fromStopInPattern] != this.boardStops[pidx]) fromStopInPattern++;\n            int toStopInPattern = fromStopInPattern;\n            while (patterns[patIdx].stops[toStopInPattern] != this.alightStops[pidx]) {\n                \/\/ if we visit the board stop multiple times, board at the one closest to the alight stop\n                \/\/ TODO better handle duplicated stops\/loop routes\n                if (patterns[patIdx].stops[toStopInPattern] == this.boardStops[pidx]) fromStopInPattern = toStopInPattern;\n                toStopInPattern++;\n            }\n            final int finalFromStopInPattern = fromStopInPattern;\n            final int finalToStopInPattern = toStopInPattern;\n            times[patIdx] = patterns[patIdx].tripSchedules.stream()\n                    .map(ts -> new int[] { ts.departures[finalFromStopInPattern], ts.arrivals[finalToStopInPattern] })\n                    .toArray(s -> new int[s][]);\n        }\n        \/\/ sort by departure time of each trip, within each pattern\n        Stream.of(times).forEach(t -> Arrays.sort(t, (t1, t2) -> t1[0] - t2[0]));\n        \/\/ loop over departures within the time window\n        \/\/ firstTrip is the trip on the first pattern\n        int firstTrip = 0;\n        while (times[0][firstTrip][0] < req.fromTime + accessTime + FastRaptorWorker.BOARD_SLACK_SECONDS) firstTrip++;\n        \/\/ now interleave times\n        double walkSpeedMillimetersPerSecond = req.walkSpeed * 1000;\n        TIMES: while (firstTrip < times[0].length) {\n            Itinerary itin = new Itinerary(this.patterns.length);\n            int time = times[0][firstTrip][0];\n            \/\/ linear scan over timetable to do interleaving\n            for (int patIdx = 0; patIdx < this.patterns.length; patIdx++) {\n                int trip = 0;\n                while (times[patIdx][trip][0] < time) {\n                    trip++;\n                    if (trip >= times[patIdx].length) break TIMES; \/\/ we've found the end of the times at which this path is possible\n                }\n                itin.boardTimes[patIdx] = times[patIdx][trip][0];\n                itin.alightTimes[patIdx] = times[patIdx][trip][1];\n                if (patIdx < this.length - 1) {\n                    \/\/ find the transfer time\n                    TIntList transfers = network.transitLayer.transfersForStop.get(this.alightStops[patIdx]);\n                    int transferTime;\n                    if (this.alightStops[patIdx] != this.boardStops[patIdx + 1]) {\n                        transferTime = -1;\n                        for (int i = 0; i < transfers.size(); i += 2) {\n                            if (transfers.get(i) == this.boardStops[patIdx + 1]) {\n                                int transferDistanceMillimeters = transfers.get(i + 1);\n                                transferTime = (int)(transferDistanceMillimeters \/ walkSpeedMillimetersPerSecond);\n                                break;\n                            }\n                        }\n                        if (transferTime == -1) {\n                            throw new IllegalStateException(\"Did not find transfer in transit network, indicates an internal error\");\n                        }\n                    }\n                    else transferTime = 0; \/\/ no transfer time, we are at the same stop (board slack applied below)\n                    \/\/ TODO should board slack be applied at the origin stop? Is this done in RaptorWorker?\n                    \/\/ See also below in computeStatistics\n                    time = times[patIdx][trip][1] + transferTime + FastRaptorWorker.BOARD_SLACK_SECONDS;\n                    itin.arriveAtBoardStopTimes[patIdx + 1] = time;\n                }\n            }\n            this.itineraries.add(itin);\n            firstTrip++;\n        }\n        sortAndFilterItineraries();\n        computeStatistics(req, accessTime, egressTime);\n    }","code_wo_comment":"private void computeTimes (TransportNetwork network, ProfileRequest req, TIntIntMap accessTimes, TIntIntMap egressTimes) {\n        if (!accessTimes.containsKey(this.boardStops[0])) throw new IllegalArgumentException(\"Access times do not contain first stop of path!\");\n        if (!egressTimes.containsKey(this.alightStops[this.length - 1])) throw new IllegalArgumentException(\"Egress times do not contain last stop of path!\");\n        int accessTime = accessTimes.get(this.boardStops[0]);\n        int egressTime = egressTimes.get(this.alightStops[this.length - 1]);\n        if (network.transitLayer.hasFrequencies) {\n           \n            throw new UnsupportedOperationException(\"Frequency-based trips are not yet supported in customer-facing profile routing\");\n        }\n       \n       \n        TripPattern[] patterns = IntStream.of(this.patterns).mapToObj(p -> network.transitLayer.tripPatterns.get(p)).toArray(s -> new TripPattern[s]);\n       \n       \n        int[][][] times = new int[patterns.length][][];\n        for (int patIdx = 0; patIdx < patterns.length; patIdx++) {\n            final int pidx = patIdx;\n            int fromStopInPattern = 0;\n            while (patterns[patIdx].stops[fromStopInPattern] != this.boardStops[pidx]) fromStopInPattern++;\n            int toStopInPattern = fromStopInPattern;\n            while (patterns[patIdx].stops[toStopInPattern] != this.alightStops[pidx]) {\n               \n               \n                if (patterns[patIdx].stops[toStopInPattern] == this.boardStops[pidx]) fromStopInPattern = toStopInPattern;\n                toStopInPattern++;\n            }\n            final int finalFromStopInPattern = fromStopInPattern;\n            final int finalToStopInPattern = toStopInPattern;\n            times[patIdx] = patterns[patIdx].tripSchedules.stream()\n                    .map(ts -> new int[] { ts.departures[finalFromStopInPattern], ts.arrivals[finalToStopInPattern] })\n                    .toArray(s -> new int[s][]);\n        }\n       \n        Stream.of(times).forEach(t -> Arrays.sort(t, (t1, t2) -> t1[0] - t2[0]));\n       \n       \n        int firstTrip = 0;\n        while (times[0][firstTrip][0] < req.fromTime + accessTime + FastRaptorWorker.BOARD_SLACK_SECONDS) firstTrip++;\n       \n        double walkSpeedMillimetersPerSecond = req.walkSpeed * 1000;\n        TIMES: while (firstTrip < times[0].length) {\n            Itinerary itin = new Itinerary(this.patterns.length);\n            int time = times[0][firstTrip][0];\n           \n            for (int patIdx = 0; patIdx < this.patterns.length; patIdx++) {\n                int trip = 0;\n                while (times[patIdx][trip][0] < time) {\n                    trip++;\n                    if (trip >= times[patIdx].length) break TIMES;\n                }\n                itin.boardTimes[patIdx] = times[patIdx][trip][0];\n                itin.alightTimes[patIdx] = times[patIdx][trip][1];\n                if (patIdx < this.length - 1) {\n                   \n                    TIntList transfers = network.transitLayer.transfersForStop.get(this.alightStops[patIdx]);\n                    int transferTime;\n                    if (this.alightStops[patIdx] != this.boardStops[patIdx + 1]) {\n                        transferTime = -1;\n                        for (int i = 0; i < transfers.size(); i += 2) {\n                            if (transfers.get(i) == this.boardStops[patIdx + 1]) {\n                                int transferDistanceMillimeters = transfers.get(i + 1);\n                                transferTime = (int)(transferDistanceMillimeters \/ walkSpeedMillimetersPerSecond);\n                                break;\n                            }\n                        }\n                        if (transferTime == -1) {\n                            throw new IllegalStateException(\"Did not find transfer in transit network, indicates an internal error\");\n                        }\n                    }\n                    else transferTime = 0;\n                   \n                   \n                    time = times[patIdx][trip][1] + transferTime + FastRaptorWorker.BOARD_SLACK_SECONDS;\n                    itin.arriveAtBoardStopTimes[patIdx + 1] = time;\n                }\n            }\n            this.itineraries.add(itin);\n            firstTrip++;\n        }\n        sortAndFilterItineraries();\n        computeStatistics(req, accessTime, egressTime);\n    }","cleancode":"private void computetimes (transportnetwork network, profilerequest req, tintintmap accesstimes, tintintmap egresstimes) { if (!accesstimes.containskey(this.boardstops[0])) throw new illegalargumentexception(\"access times do not contain first stop of path!\"); if (!egresstimes.containskey(this.alightstops[this.length - 1])) throw new illegalargumentexception(\"egress times do not contain last stop of path!\"); int accesstime = accesstimes.get(this.boardstops[0]); int egresstime = egresstimes.get(this.alightstops[this.length - 1]); if (network.transitlayer.hasfrequencies) { throw new unsupportedoperationexception(\"frequency-based trips are not yet supported in customer-facing profile routing\"); } trippattern[] patterns = intstream.of(this.patterns).maptoobj(p -> network.transitlayer.trippatterns.get(p)).toarray(s -> new trippattern[s]); int[][][] times = new int[patterns.length][][]; for (int patidx = 0; patidx < patterns.length; patidx++) { final int pidx = patidx; int fromstopinpattern = 0; while (patterns[patidx].stops[fromstopinpattern] != this.boardstops[pidx]) fromstopinpattern++; int tostopinpattern = fromstopinpattern; while (patterns[patidx].stops[tostopinpattern] != this.alightstops[pidx]) { if (patterns[patidx].stops[tostopinpattern] == this.boardstops[pidx]) fromstopinpattern = tostopinpattern; tostopinpattern++; } final int finalfromstopinpattern = fromstopinpattern; final int finaltostopinpattern = tostopinpattern; times[patidx] = patterns[patidx].tripschedules.stream() .map(ts -> new int[] { ts.departures[finalfromstopinpattern], ts.arrivals[finaltostopinpattern] }) .toarray(s -> new int[s][]); } stream.of(times).foreach(t -> arrays.sort(t, (t1, t2) -> t1[0] - t2[0])); int firsttrip = 0; while (times[0][firsttrip][0] < req.fromtime + accesstime + fastraptorworker.board_slack_seconds) firsttrip++; double walkspeedmillimeterspersecond = req.walkspeed * 1000; times: while (firsttrip < times[0].length) { itinerary itin = new itinerary(this.patterns.length); int time = times[0][firsttrip][0]; for (int patidx = 0; patidx < this.patterns.length; patidx++) { int trip = 0; while (times[patidx][trip][0] < time) { trip++; if (trip >= times[patidx].length) break times; } itin.boardtimes[patidx] = times[patidx][trip][0]; itin.alighttimes[patidx] = times[patidx][trip][1]; if (patidx < this.length - 1) { tintlist transfers = network.transitlayer.transfersforstop.get(this.alightstops[patidx]); int transfertime; if (this.alightstops[patidx] != this.boardstops[patidx + 1]) { transfertime = -1; for (int i = 0; i < transfers.size(); i += 2) { if (transfers.get(i) == this.boardstops[patidx + 1]) { int transferdistancemillimeters = transfers.get(i + 1); transfertime = (int)(transferdistancemillimeters \/ walkspeedmillimeterspersecond); break; } } if (transfertime == -1) { throw new illegalstateexception(\"did not find transfer in transit network, indicates an internal error\"); } } else transfertime = 0; time = times[patidx][trip][1] + transfertime + fastraptorworker.board_slack_seconds; itin.arriveatboardstoptimes[patidx + 1] = time; } } this.itineraries.add(itin); firsttrip++; } sortandfilteritineraries(); computestatistics(req, accesstime, egresstime); }","repo":"enoxos\/r5","label":[1,0,1,0]}
{"id":18691,"original_code":"protected FocusListener createFocusListener() {\n        return new BasicComboBoxUI.FocusHandler() {\n            public void focusLost(final FocusEvent e) {\n                hasFocus = false;\n                if (!e.isTemporary()) {\n                    setPopupVisible(comboBox, false);\n                }\n                comboBox.repaint();\n                \/\/ Notify assistive technologies that the combo box lost focus\n                final AccessibleContext ac = ((Accessible)comboBox).getAccessibleContext();\n                if (ac != null) {\n                    ac.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY, AccessibleState.FOCUSED, null);\n                }\n            }\n        };\n    }","code_wo_comment":"protected FocusListener createFocusListener() {\n        return new BasicComboBoxUI.FocusHandler() {\n            public void focusLost(final FocusEvent e) {\n                hasFocus = false;\n                if (!e.isTemporary()) {\n                    setPopupVisible(comboBox, false);\n                }\n                comboBox.repaint();\n               \n                final AccessibleContext ac = ((Accessible)comboBox).getAccessibleContext();\n                if (ac != null) {\n                    ac.firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY, AccessibleState.FOCUSED, null);\n                }\n            }\n        };\n    }","cleancode":"protected focuslistener createfocuslistener() { return new basiccomboboxui.focushandler() { public void focuslost(final focusevent e) { hasfocus = false; if (!e.istemporary()) { setpopupvisible(combobox, false); } combobox.repaint(); final accessiblecontext ac = ((accessible)combobox).getaccessiblecontext(); if (ac != null) { ac.firepropertychange(accessiblecontext.accessible_state_property, accessiblestate.focused, null); } } }; }","repo":"dbac\/jdk8","label":[1,0,0,0]}
{"id":10532,"original_code":"public WebSocket<JsonNode> socket() {\n        final Http.Session session = session();\n        final User currentUser = Application.getLocalUser(session());\n        return new WebSocket<JsonNode>() {\n            @Override\n            public void onReady(In<JsonNode> in, Out<JsonNode> out) {\n                try {\n                    User u = Application.getLocalUser(session);\n                    \/\/Logger.debug(\"User \" + u.id + \" connected\");\n                    \/\/ Add the new user to the data structures\n                    boolean alreadyOnline = onlineUsers.containsValue(u);\n                    onlineUsers.put(out, u);\n                    \/*try (Jedis j = jedisPool.getResource()) {\n                        j.sadd(\"online_users\", Long.toString(u.id));\n                    }*\/\n                    \/\/ Notify logged users about the new player\n                    if (!alreadyOnline) {\n                        ObjectMapper mapper = new ObjectMapper();\n                        ObjectNode notification = JsonNodeFactory.instance.objectNode();\n                        notification.put(\"action\", \"newuser\");\n                        notification.put(\"newuser\", mapper.writeValueAsString(currentUser));\n                        broadcastMessage(notification, new HashSet<User>() {{ add(u); }});\n                    }\n                } catch (RuntimeException e) {\n                    \/\/Logger.debug(\"Unknown user connected\");\n                } catch (JsonProcessingException e) {\n                    Logger.error(e.getMessage(), e);\n                }\n                in.onMessage((data) -> {\n                    Logger.debug(currentUser.id + \" - \" + data.toString());\n                    String action = data.findPath(\"action\").textValue();\n                    switch (action) {\n                        \/\/ TODO: add error handling\n                        case \"newgame\":\n                            onNewGameResponse(data, currentUser);\n                            break;\n                        case \"ready\":\n                            onUserReady(data, currentUser);\n                            break;\n                        case \"setrowboat\":\n                            onSetShip(data, currentUser, new Rowboat());\n                            break;\n                        case \"setdestructor\":\n                            onSetShip(data, currentUser, new Destructor());\n                            break;\n                        case \"setflattop\":\n                            onSetShip(data, currentUser, new Flattop());\n                            break;\n                        case \"shoot\":\n                            onShoot(data, currentUser);\n                            break;\n                        case \"userleaves\":\n                            onUserLeaves(data, currentUser);\n                            break;\n                        case \"getOnlineUsers\":\n                            onGetOnlineUsers(data, currentUser);\n                            break;\n                        default:\n                    }\n                });\n                in.onClose(() -> {\n                    User u = onlineUsers.get(out);\n                    if (u != null) {\n                        \/\/Logger.debug(\"User \" + u.id + \" disconnected\");\n                        \/\/ Remove user from the data structures\n                        onlineUsers.remove(out);\n                        \/\/ Wait for 100 ms to see if the user connects through another websocket\n                        \/\/Thread.sleep(100);\n                        boolean stillOnline = onlineUsers.containsValue(u);\n                        \/*try (Jedis j = jedisPool.getResource()) {\n                            j.srem(\"online_users\", Long.toString(u.id));\n                        }*\/\n                        \/\/ Notify logged users about the leaving player\n                        if (!stillOnline) {\n                            try {\n                                ObjectMapper mapper = new ObjectMapper();\n                                ObjectNode notification = JsonNodeFactory.instance.objectNode();\n                                notification.put(\"action\", \"userleaves\");\n                                notification.put(\"leavinguser\", mapper.writeValueAsString(currentUser));\n                                broadcastMessage(notification, new HashSet<User>() {{ add(u); }});\n                            } catch (JsonProcessingException e) {\n                                Logger.error(e.getMessage(), e);\n                            }\n                        }\n                    } else {\n                        \/\/Logger.debug(\"Unknown user disconnected\");\n                    }\n                });\n            }\n        };\n    }","code_wo_comment":"public WebSocket<JsonNode> socket() {\n        final Http.Session session = session();\n        final User currentUser = Application.getLocalUser(session());\n        return new WebSocket<JsonNode>() {\n            @Override\n            public void onReady(In<JsonNode> in, Out<JsonNode> out) {\n                try {\n                    User u = Application.getLocalUser(session);\n                   \n                   \n                    boolean alreadyOnline = onlineUsers.containsValue(u);\n                    onlineUsers.put(out, u);\n                   \n                   \n                    if (!alreadyOnline) {\n                        ObjectMapper mapper = new ObjectMapper();\n                        ObjectNode notification = JsonNodeFactory.instance.objectNode();\n                        notification.put(\"action\", \"newuser\");\n                        notification.put(\"newuser\", mapper.writeValueAsString(currentUser));\n                        broadcastMessage(notification, new HashSet<User>() {{ add(u); }});\n                    }\n                } catch (RuntimeException e) {\n                   \n                } catch (JsonProcessingException e) {\n                    Logger.error(e.getMessage(), e);\n                }\n                in.onMessage((data) -> {\n                    Logger.debug(currentUser.id + \" - \" + data.toString());\n                    String action = data.findPath(\"action\").textValue();\n                    switch (action) {\n                       \n                        case \"newgame\":\n                            onNewGameResponse(data, currentUser);\n                            break;\n                        case \"ready\":\n                            onUserReady(data, currentUser);\n                            break;\n                        case \"setrowboat\":\n                            onSetShip(data, currentUser, new Rowboat());\n                            break;\n                        case \"setdestructor\":\n                            onSetShip(data, currentUser, new Destructor());\n                            break;\n                        case \"setflattop\":\n                            onSetShip(data, currentUser, new Flattop());\n                            break;\n                        case \"shoot\":\n                            onShoot(data, currentUser);\n                            break;\n                        case \"userleaves\":\n                            onUserLeaves(data, currentUser);\n                            break;\n                        case \"getOnlineUsers\":\n                            onGetOnlineUsers(data, currentUser);\n                            break;\n                        default:\n                    }\n                });\n                in.onClose(() -> {\n                    User u = onlineUsers.get(out);\n                    if (u != null) {\n                       \n                       \n                        onlineUsers.remove(out);\n                       \n                       \n                        boolean stillOnline = onlineUsers.containsValue(u);\n                       \n                       \n                        if (!stillOnline) {\n                            try {\n                                ObjectMapper mapper = new ObjectMapper();\n                                ObjectNode notification = JsonNodeFactory.instance.objectNode();\n                                notification.put(\"action\", \"userleaves\");\n                                notification.put(\"leavinguser\", mapper.writeValueAsString(currentUser));\n                                broadcastMessage(notification, new HashSet<User>() {{ add(u); }});\n                            } catch (JsonProcessingException e) {\n                                Logger.error(e.getMessage(), e);\n                            }\n                        }\n                    } else {\n                       \n                    }\n                });\n            }\n        };\n    }","cleancode":"public websocket<jsonnode> socket() { final http.session session = session(); final user currentuser = application.getlocaluser(session()); return new websocket<jsonnode>() { @override public void onready(in<jsonnode> in, out<jsonnode> out) { try { user u = application.getlocaluser(session); boolean alreadyonline = onlineusers.containsvalue(u); onlineusers.put(out, u); if (!alreadyonline) { objectmapper mapper = new objectmapper(); objectnode notification = jsonnodefactory.instance.objectnode(); notification.put(\"action\", \"newuser\"); notification.put(\"newuser\", mapper.writevalueasstring(currentuser)); broadcastmessage(notification, new hashset<user>() {{ add(u); }}); } } catch (runtimeexception e) { } catch (jsonprocessingexception e) { logger.error(e.getmessage(), e); } in.onmessage((data) -> { logger.debug(currentuser.id + \" - \" + data.tostring()); string action = data.findpath(\"action\").textvalue(); switch (action) { case \"newgame\": onnewgameresponse(data, currentuser); break; case \"ready\": onuserready(data, currentuser); break; case \"setrowboat\": onsetship(data, currentuser, new rowboat()); break; case \"setdestructor\": onsetship(data, currentuser, new destructor()); break; case \"setflattop\": onsetship(data, currentuser, new flattop()); break; case \"shoot\": onshoot(data, currentuser); break; case \"userleaves\": onuserleaves(data, currentuser); break; case \"getonlineusers\": ongetonlineusers(data, currentuser); break; default: } }); in.onclose(() -> { user u = onlineusers.get(out); if (u != null) { onlineusers.remove(out); boolean stillonline = onlineusers.containsvalue(u); if (!stillonline) { try { objectmapper mapper = new objectmapper(); objectnode notification = jsonnodefactory.instance.objectnode(); notification.put(\"action\", \"userleaves\"); notification.put(\"leavinguser\", mapper.writevalueasstring(currentuser)); broadcastmessage(notification, new hashset<user>() {{ add(u); }}); } catch (jsonprocessingexception e) { logger.error(e.getmessage(), e); } } } else { } }); } }; }","repo":"daniel-sandro\/WTEC1516","label":[0,1,0,0]}
{"id":10559,"original_code":"private void postNotification(Context context, AnswerSet answerSet, String message) {\n        int surveyId = answerSet.getDbSurveyId();\n        NotificationManager notificationManager = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Intent intent = new Intent(context, SurveyActivity.class);\n        intent.putExtra(\"programId\", answerSet.getDbProgramId());\n        intent.putExtra(\"answerSetUUID\", answerSet.getUuid());\n        intent.setAction(\"com.sema.notification.\" + surveyId);\n        PendingIntent pIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n        Survey survey = answerSet.getSurvey();\n        Program program = survey != null ? survey.getProgram() : null;\n        if (survey != null && program != null) {\n            String programName = program.getDisplayName();\n            Notification n = new NotificationCompat.Builder(context)\n                    .setContentTitle(programName)\n                    .setContentText(message)\n                    .setSmallIcon(R.drawable.ic_launcher)\n                    .setContentIntent(pIntent)\n                    .setAutoCancel(true)\n                    .setSound(Uri.parse(\"android.resource:\/\/\" + context.getPackageName() + \"\/\" + R.raw.notification_extended))\n                    .build();\n            notificationManager.notify(answerSet.getStartAlarmRequestCode(), n); \/\/ TODO: alternatively could use the same app wide if want only one entry in notifications\n        }\n    }","code_wo_comment":"private void postNotification(Context context, AnswerSet answerSet, String message) {\n        int surveyId = answerSet.getDbSurveyId();\n        NotificationManager notificationManager = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);\n        Intent intent = new Intent(context, SurveyActivity.class);\n        intent.putExtra(\"programId\", answerSet.getDbProgramId());\n        intent.putExtra(\"answerSetUUID\", answerSet.getUuid());\n        intent.setAction(\"com.sema.notification.\" + surveyId);\n        PendingIntent pIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n        Survey survey = answerSet.getSurvey();\n        Program program = survey != null ? survey.getProgram() : null;\n        if (survey != null && program != null) {\n            String programName = program.getDisplayName();\n            Notification n = new NotificationCompat.Builder(context)\n                    .setContentTitle(programName)\n                    .setContentText(message)\n                    .setSmallIcon(R.drawable.ic_launcher)\n                    .setContentIntent(pIntent)\n                    .setAutoCancel(true)\n                    .setSound(Uri.parse(\"android.resource:\/\/\" + context.getPackageName() + \"\/\" + R.raw.notification_extended))\n                    .build();\n            notificationManager.notify(answerSet.getStartAlarmRequestCode(), n);\n        }\n    }","cleancode":"private void postnotification(context context, answerset answerset, string message) { int surveyid = answerset.getdbsurveyid(); notificationmanager notificationmanager = (notificationmanager)context.getsystemservice(context.notification_service); intent intent = new intent(context, surveyactivity.class); intent.putextra(\"programid\", answerset.getdbprogramid()); intent.putextra(\"answersetuuid\", answerset.getuuid()); intent.setaction(\"com.sema.notification.\" + surveyid); pendingintent pintent = pendingintent.getactivity(context, 0, intent, pendingintent.flag_update_current); survey survey = answerset.getsurvey(); program program = survey != null ? survey.getprogram() : null; if (survey != null && program != null) { string programname = program.getdisplayname(); notification n = new notificationcompat.builder(context) .setcontenttitle(programname) .setcontenttext(message) .setsmallicon(r.drawable.ic_launcher) .setcontentintent(pintent) .setautocancel(true) .setsound(uri.parse(\"android.resource:\/\/\" + context.getpackagename() + \"\/\" + r.raw.notification_extended)) .build(); notificationmanager.notify(answerset.getstartalarmrequestcode(), n); } }","repo":"eorygen\/sema2_android","label":[1,0,0,0]}
{"id":18865,"original_code":"private static  Attributes<Cell> attributesFrom(Node node, URI uri, ComplexCellModel cellModel, Predicate<String> attributeFilter) {\n\tif (!node.hasAttributes()) {\t\/\/\t** base case **\n\t\treturn new OrderedMap<Cell>(0);\n\t}\n\tif (cellModel.isSimple()) {\n\t\tlog.error(\"CellModel '{}' does not allow attributes but the elem does\", cellModel.getName());\n\t\tthrow new RuntimeException(\"Element and model attribute mismatch\", new IllegalArgumentException());\n\t}\n\t\/\/ \t\t\t\t\t\t\t\t** recursive case **\n\tOrderedMap<Cell> attributes = new OrderedMap<Cell>(node.getAttributes().getLength());\n\tNamedNodeMap elemAttributes = node.getAttributes();\t\/\/ TODO: notice this is not ordered like the input ^^'\n\tfor (int i=0; i<elemAttributes.getLength(); i++) {\n\t\tNode attribute = elemAttributes.item(i);\n\t\tString attributeName = attribute.getNodeName();\n\t\tURI childURI = cellURI(uri, cellModel, ATTRIBUTE_PREFIX+attributeName);\n\t\t\/\/ if we are looking for public attributes, they need to match with the attributes model, otherwise we just\n\t\t\/\/ point to the node cell model (IDEA: maybe in the future point to the internal model)\n\t\tCellModel attributeCellModel = findAttributeWithName(cellModel, attributeName);\n\t\tif (attributeFilter.test(attributeName)) {\n\t\t\tCell attributeCell = DaggerCellComponent.builder()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.withURI(childURI)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.fromNode(attribute)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.withCellModel(attributeCellModel)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.build()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.createCell();\n\t\t\tattributes.addChild(attributeName, attributeCell); \n\t\t\t\/\/System.err.println(\"\\t\\ta[\"+i+\"]:\"+attributeName+\":\"+attributeCell.getValue());\n\t\t} else  {\n\t\t}\n\t}\n\treturn attributes;\n}","code_wo_comment":"private static  Attributes<Cell> attributesFrom(Node node, URI uri, ComplexCellModel cellModel, Predicate<String> attributeFilter) {\n\tif (!node.hasAttributes()) {\n\t\treturn new OrderedMap<Cell>(0);\n\t}\n\tif (cellModel.isSimple()) {\n\t\tlog.error(\"CellModel '{}' does not allow attributes but the elem does\", cellModel.getName());\n\t\tthrow new RuntimeException(\"Element and model attribute mismatch\", new IllegalArgumentException());\n\t}\n\n\tOrderedMap<Cell> attributes = new OrderedMap<Cell>(node.getAttributes().getLength());\n\tNamedNodeMap elemAttributes = node.getAttributes();\n\tfor (int i=0; i<elemAttributes.getLength(); i++) {\n\t\tNode attribute = elemAttributes.item(i);\n\t\tString attributeName = attribute.getNodeName();\n\t\tURI childURI = cellURI(uri, cellModel, ATTRIBUTE_PREFIX+attributeName);\n\t\n\t\n\t\tCellModel attributeCellModel = findAttributeWithName(cellModel, attributeName);\n\t\tif (attributeFilter.test(attributeName)) {\n\t\t\tCell attributeCell = DaggerCellComponent.builder()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.withURI(childURI)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.fromNode(attribute)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.withCellModel(attributeCellModel)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.build()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.createCell();\n\t\t\tattributes.addChild(attributeName, attributeCell); \n\t\t\n\t\t} else  {\n\t\t}\n\t}\n\treturn attributes;\n}","cleancode":"private static attributes<cell> attributesfrom(node node, uri uri, complexcellmodel cellmodel, predicate<string> attributefilter) { if (!node.hasattributes()) { return new orderedmap<cell>(0); } if (cellmodel.issimple()) { log.error(\"cellmodel '{}' does not allow attributes but the elem does\", cellmodel.getname()); throw new runtimeexception(\"element and model attribute mismatch\", new illegalargumentexception()); } orderedmap<cell> attributes = new orderedmap<cell>(node.getattributes().getlength()); namednodemap elemattributes = node.getattributes(); for (int i=0; i<elemattributes.getlength(); i++) { node attribute = elemattributes.item(i); string attributename = attribute.getnodename(); uri childuri = celluri(uri, cellmodel, attribute_prefix+attributename); cellmodel attributecellmodel = findattributewithname(cellmodel, attributename); if (attributefilter.test(attributename)) { cell attributecell = daggercellcomponent.builder() .withuri(childuri) .fromnode(attribute) .withcellmodel(attributecellmodel) .build() .createcell(); attributes.addchild(attributename, attributecell); } else { } } return attributes; }","repo":"danigiri\/particle","label":[1,0,0,0]}
{"id":2495,"original_code":"private List<AbstractCriterionWidget> createCriteriaWidgets(final ICentreDomainTreeManagerAndEnhancer centre, final Class<? extends AbstractEntity<?>> root) {\n        final Class<?> managedType = centre.getEnhancer().getManagedType(root);\n        final List<AbstractCriterionWidget> criteriaWidgets = new ArrayList<>();\n        for (final String critProp : centre.getFirstTick().checkedProperties(root)) {\n            if (!AbstractDomainTree.isPlaceholder(critProp)) {\n                final boolean isEntityItself = \"\".equals(critProp); \/\/ empty property means \"entity itself\"\n                final Class<?> propertyType = isEntityItself ? managedType : PropertyTypeDeterminator.determinePropertyType(managedType, critProp);\n                final AbstractCriterionWidget criterionWidget;\n                if (AbstractDomainTree.isCritOnlySingle(managedType, critProp)) {\n                    if (EntityUtils.isEntityType(propertyType)) {\n                        final List<Pair<String, Boolean>> additionalProps = dslDefaultConfig.getAdditionalPropsForAutocompleter(critProp);\n                        criterionWidget = new EntitySingleCriterionWidget(root, managedType, critProp, additionalProps, getCentreContextConfigFor(critProp));\n                    } else if (EntityUtils.isString(propertyType)) {\n                        criterionWidget = new StringSingleCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isBoolean(propertyType)) {\n                        criterionWidget = new BooleanSingleCriterionWidget(root, managedType, critProp);\n                    } else if (Integer.class.isAssignableFrom(propertyType) || Long.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new IntegerSingleCriterionWidget(root, managedType, critProp);\n                    } else if (BigDecimal.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new DecimalSingleCriterionWidget(root, managedType, critProp);\n                    } else if (Money.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new MoneySingleCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isDate(propertyType)) {\n                        criterionWidget = new DateSingleCriterionWidget(root, managedType, critProp);\n                    } else {\n                        throw new UnsupportedOperationException(String.format(\"The crit-only single editor type [%s] is currently unsupported.\", propertyType));\n                    }\n                } else {\n                    if (EntityUtils.isEntityType(propertyType)) {\n                        final List<Pair<String, Boolean>> additionalProps = dslDefaultConfig.getAdditionalPropsForAutocompleter(critProp);\n                        criterionWidget = new EntityCriterionWidget(root, managedType, critProp, additionalProps, getCentreContextConfigFor(critProp));\n                    } else if (EntityUtils.isString(propertyType)) {\n                        criterionWidget = new StringCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isBoolean(propertyType)) {\n                        criterionWidget = new BooleanCriterionWidget(root, managedType, critProp);\n                    } else if (Integer.class.isAssignableFrom(propertyType) || Long.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new IntegerCriterionWidget(root, managedType, critProp);\n                    } else if (BigDecimal.class.isAssignableFrom(propertyType)) { \/\/ TODO do not forget about Money later (after Money widget will be available)\n                        criterionWidget = new DecimalCriterionWidget(root, managedType, critProp);\n                    } else if (Money.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new MoneyCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isDate(propertyType)) {\n                        criterionWidget = new DateCriterionWidget(root, managedType, critProp);\n                    } else {\n                        throw new UnsupportedOperationException(String.format(\"The multi \/ range editor type [%s] is currently unsupported.\", propertyType));\n                    }\n                }\n                criteriaWidgets.add(criterionWidget);\n            }\n        }\n        return criteriaWidgets;\n    }","code_wo_comment":"private List<AbstractCriterionWidget> createCriteriaWidgets(final ICentreDomainTreeManagerAndEnhancer centre, final Class<? extends AbstractEntity<?>> root) {\n        final Class<?> managedType = centre.getEnhancer().getManagedType(root);\n        final List<AbstractCriterionWidget> criteriaWidgets = new ArrayList<>();\n        for (final String critProp : centre.getFirstTick().checkedProperties(root)) {\n            if (!AbstractDomainTree.isPlaceholder(critProp)) {\n                final boolean isEntityItself = \"\".equals(critProp);\n                final Class<?> propertyType = isEntityItself ? managedType : PropertyTypeDeterminator.determinePropertyType(managedType, critProp);\n                final AbstractCriterionWidget criterionWidget;\n                if (AbstractDomainTree.isCritOnlySingle(managedType, critProp)) {\n                    if (EntityUtils.isEntityType(propertyType)) {\n                        final List<Pair<String, Boolean>> additionalProps = dslDefaultConfig.getAdditionalPropsForAutocompleter(critProp);\n                        criterionWidget = new EntitySingleCriterionWidget(root, managedType, critProp, additionalProps, getCentreContextConfigFor(critProp));\n                    } else if (EntityUtils.isString(propertyType)) {\n                        criterionWidget = new StringSingleCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isBoolean(propertyType)) {\n                        criterionWidget = new BooleanSingleCriterionWidget(root, managedType, critProp);\n                    } else if (Integer.class.isAssignableFrom(propertyType) || Long.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new IntegerSingleCriterionWidget(root, managedType, critProp);\n                    } else if (BigDecimal.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new DecimalSingleCriterionWidget(root, managedType, critProp);\n                    } else if (Money.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new MoneySingleCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isDate(propertyType)) {\n                        criterionWidget = new DateSingleCriterionWidget(root, managedType, critProp);\n                    } else {\n                        throw new UnsupportedOperationException(String.format(\"The crit-only single editor type [%s] is currently unsupported.\", propertyType));\n                    }\n                } else {\n                    if (EntityUtils.isEntityType(propertyType)) {\n                        final List<Pair<String, Boolean>> additionalProps = dslDefaultConfig.getAdditionalPropsForAutocompleter(critProp);\n                        criterionWidget = new EntityCriterionWidget(root, managedType, critProp, additionalProps, getCentreContextConfigFor(critProp));\n                    } else if (EntityUtils.isString(propertyType)) {\n                        criterionWidget = new StringCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isBoolean(propertyType)) {\n                        criterionWidget = new BooleanCriterionWidget(root, managedType, critProp);\n                    } else if (Integer.class.isAssignableFrom(propertyType) || Long.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new IntegerCriterionWidget(root, managedType, critProp);\n                    } else if (BigDecimal.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new DecimalCriterionWidget(root, managedType, critProp);\n                    } else if (Money.class.isAssignableFrom(propertyType)) {\n                        criterionWidget = new MoneyCriterionWidget(root, managedType, critProp);\n                    } else if (EntityUtils.isDate(propertyType)) {\n                        criterionWidget = new DateCriterionWidget(root, managedType, critProp);\n                    } else {\n                        throw new UnsupportedOperationException(String.format(\"The multi \/ range editor type [%s] is currently unsupported.\", propertyType));\n                    }\n                }\n                criteriaWidgets.add(criterionWidget);\n            }\n        }\n        return criteriaWidgets;\n    }","cleancode":"private list<abstractcriterionwidget> createcriteriawidgets(final icentredomaintreemanagerandenhancer centre, final class<? extends abstractentity<?>> root) { final class<?> managedtype = centre.getenhancer().getmanagedtype(root); final list<abstractcriterionwidget> criteriawidgets = new arraylist<>(); for (final string critprop : centre.getfirsttick().checkedproperties(root)) { if (!abstractdomaintree.isplaceholder(critprop)) { final boolean isentityitself = \"\".equals(critprop); final class<?> propertytype = isentityitself ? managedtype : propertytypedeterminator.determinepropertytype(managedtype, critprop); final abstractcriterionwidget criterionwidget; if (abstractdomaintree.iscritonlysingle(managedtype, critprop)) { if (entityutils.isentitytype(propertytype)) { final list<pair<string, boolean>> additionalprops = dsldefaultconfig.getadditionalpropsforautocompleter(critprop); criterionwidget = new entitysinglecriterionwidget(root, managedtype, critprop, additionalprops, getcentrecontextconfigfor(critprop)); } else if (entityutils.isstring(propertytype)) { criterionwidget = new stringsinglecriterionwidget(root, managedtype, critprop); } else if (entityutils.isboolean(propertytype)) { criterionwidget = new booleansinglecriterionwidget(root, managedtype, critprop); } else if (integer.class.isassignablefrom(propertytype) || long.class.isassignablefrom(propertytype)) { criterionwidget = new integersinglecriterionwidget(root, managedtype, critprop); } else if (bigdecimal.class.isassignablefrom(propertytype)) { criterionwidget = new decimalsinglecriterionwidget(root, managedtype, critprop); } else if (money.class.isassignablefrom(propertytype)) { criterionwidget = new moneysinglecriterionwidget(root, managedtype, critprop); } else if (entityutils.isdate(propertytype)) { criterionwidget = new datesinglecriterionwidget(root, managedtype, critprop); } else { throw new unsupportedoperationexception(string.format(\"the crit-only single editor type [%s] is currently unsupported.\", propertytype)); } } else { if (entityutils.isentitytype(propertytype)) { final list<pair<string, boolean>> additionalprops = dsldefaultconfig.getadditionalpropsforautocompleter(critprop); criterionwidget = new entitycriterionwidget(root, managedtype, critprop, additionalprops, getcentrecontextconfigfor(critprop)); } else if (entityutils.isstring(propertytype)) { criterionwidget = new stringcriterionwidget(root, managedtype, critprop); } else if (entityutils.isboolean(propertytype)) { criterionwidget = new booleancriterionwidget(root, managedtype, critprop); } else if (integer.class.isassignablefrom(propertytype) || long.class.isassignablefrom(propertytype)) { criterionwidget = new integercriterionwidget(root, managedtype, critprop); } else if (bigdecimal.class.isassignablefrom(propertytype)) { criterionwidget = new decimalcriterionwidget(root, managedtype, critprop); } else if (money.class.isassignablefrom(propertytype)) { criterionwidget = new moneycriterionwidget(root, managedtype, critprop); } else if (entityutils.isdate(propertytype)) { criterionwidget = new datecriterionwidget(root, managedtype, critprop); } else { throw new unsupportedoperationexception(string.format(\"the multi \/ range editor type [%s] is currently unsupported.\", propertytype)); } } criteriawidgets.add(criterionwidget); } } return criteriawidgets; }","repo":"fieldenms\/","label":[1,0,0,0]}
{"id":2538,"original_code":"private void initializeFop2x(XProcRuntime runtime, XStep step, Properties options) {\n        Object fopFactoryBuilder = null;\n        Constructor factBuilderConstructor = null;\n        try {\n            factBuilderConstructor = klass.getConstructor(URI.class);\n        } catch (NoSuchMethodException nsme) {\n            \/\/ nop;\n        }\n        resolver = runtime.getResolver();\n        URI baseURI = step.getStep().getNode().getBaseURI();\n        String s = getStringProp(\"BaseURL\");\n        if (s != null) {\n            baseURI = baseURI.resolve(s);\n        }\n        try {\n            if (resolver == null) {\n                fopFactoryBuilder = factBuilderConstructor.newInstance(baseURI);\n            } else {\n                \/\/ FIXME: make an org.apache.xmlgraphics.io.ResourceResolver resolver!?\n                fopFactoryBuilder = factBuilderConstructor.newInstance(baseURI);\n            }\n            Class fclass = fopFactoryBuilder.getClass();\n            \/\/ FIXME: make this configurable\n            Boolean b = false;\n            \/* Why doesn't this call work with reflection?\n            method = fclass.getMethod(\"setStrictFOValidation\", Boolean.class);\n            method.invoke(fopFactoryBuilder, b);\n            *\/\n            b = getBooleanProp(\"BreakIndentInheritanceOnReferenceAreaBoundary\");\n            if (b != null) {\n                method = fclass.getMethod(\"setBreakIndentInheritanceOnReferenceAreaBoundary\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            Float f = getFloatProp(\"SourceResolution\");\n            if (f != null) {\n                method = fclass.getMethod(\"setSourceResolution\", Float.class);\n                method.invoke(fopFactoryBuilder, f);\n            }\n            \/* FIXME:\n            s = getStringProp(\"FontBaseURL\");\n            if (s != null) {\n                fopFactory.getFontManager().setFontBaseURL(s);\n            }\n            *\/\n            b = getBooleanProp(\"Base14KerningEnabled\");\n            if (b != null) {\n                Method getFontManager = fclass.getMethod(\"getFontManager\");\n                Object fontManager = getFontManager.invoke(fopFactoryBuilder);\n                method = fontManager.getClass().getMethod(\"setBase14KerningEnabled\", Boolean.class);\n                method.invoke(fontManager, b);\n            }\n            \/* FIXME:\n            s = getStringProp(\"HyphenBaseURL\");\n            if (s != null) {\n                fopFactory.setHyphenBaseURL(s);\n            }\n            *\/\n            s = getStringProp(\"PageHeight\");\n            if (s != null) {\n                method = fclass.getMethod(\"setPageHeight\", String.class);\n                method.invoke(fopFactoryBuilder, s);\n            }\n            s = getStringProp(\"PageWidth\");\n            if (s != null) {\n                method = fclass.getMethod(\"setPageWidth\", String.class);\n                method.invoke(fopFactoryBuilder, s);\n            }\n            f = getFloatProp(\"TargetResolution\");\n            if (f != null) {\n                method = fclass.getMethod(\"setTargetResolution\", Float.class);\n                method.invoke(fopFactoryBuilder, f);\n            }\n            b = getBooleanProp(\"StrictUserConfigValidation\");\n            if (b != null) {\n                method = fclass.getMethod(\"setStrictUserConfigValidation\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            b = getBooleanProp(\"StrictValidation\");\n            if (b != null) {\n                method = fclass.getMethod(\"setStrictUserConfigValidation\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            b = getBooleanProp(\"UseCache\");\n            if (b != null && !b) {\n                Method getFontManager = fclass.getMethod(\"getFontManager\");\n                Object fontManager = getFontManager.invoke(fopFactoryBuilder);\n                method = fontManager.getClass().getMethod(\"disableFontCache\");\n                method.invoke(fontManager);\n            }\n            \/* FIXME:\n            s = getStringProp(\"UserConfig\");\n            if (s != null) {\n                fopFactory.setUserConfig(s);\n            }\n            *\/\n            method = fclass.getMethod(\"build\");\n            fopFactory = method.invoke(fopFactoryBuilder);\n        } catch (Exception e) {\n            throw new XProcException(e);\n        }\n    }","code_wo_comment":"private void initializeFop2x(XProcRuntime runtime, XStep step, Properties options) {\n        Object fopFactoryBuilder = null;\n        Constructor factBuilderConstructor = null;\n        try {\n            factBuilderConstructor = klass.getConstructor(URI.class);\n        } catch (NoSuchMethodException nsme) {\n           \n        }\n        resolver = runtime.getResolver();\n        URI baseURI = step.getStep().getNode().getBaseURI();\n        String s = getStringProp(\"BaseURL\");\n        if (s != null) {\n            baseURI = baseURI.resolve(s);\n        }\n        try {\n            if (resolver == null) {\n                fopFactoryBuilder = factBuilderConstructor.newInstance(baseURI);\n            } else {\n               \n                fopFactoryBuilder = factBuilderConstructor.newInstance(baseURI);\n            }\n            Class fclass = fopFactoryBuilder.getClass();\n           \n            Boolean b = false;\n           \n            b = getBooleanProp(\"BreakIndentInheritanceOnReferenceAreaBoundary\");\n            if (b != null) {\n                method = fclass.getMethod(\"setBreakIndentInheritanceOnReferenceAreaBoundary\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            Float f = getFloatProp(\"SourceResolution\");\n            if (f != null) {\n                method = fclass.getMethod(\"setSourceResolution\", Float.class);\n                method.invoke(fopFactoryBuilder, f);\n            }\n           \n            b = getBooleanProp(\"Base14KerningEnabled\");\n            if (b != null) {\n                Method getFontManager = fclass.getMethod(\"getFontManager\");\n                Object fontManager = getFontManager.invoke(fopFactoryBuilder);\n                method = fontManager.getClass().getMethod(\"setBase14KerningEnabled\", Boolean.class);\n                method.invoke(fontManager, b);\n            }\n           \n            s = getStringProp(\"PageHeight\");\n            if (s != null) {\n                method = fclass.getMethod(\"setPageHeight\", String.class);\n                method.invoke(fopFactoryBuilder, s);\n            }\n            s = getStringProp(\"PageWidth\");\n            if (s != null) {\n                method = fclass.getMethod(\"setPageWidth\", String.class);\n                method.invoke(fopFactoryBuilder, s);\n            }\n            f = getFloatProp(\"TargetResolution\");\n            if (f != null) {\n                method = fclass.getMethod(\"setTargetResolution\", Float.class);\n                method.invoke(fopFactoryBuilder, f);\n            }\n            b = getBooleanProp(\"StrictUserConfigValidation\");\n            if (b != null) {\n                method = fclass.getMethod(\"setStrictUserConfigValidation\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            b = getBooleanProp(\"StrictValidation\");\n            if (b != null) {\n                method = fclass.getMethod(\"setStrictUserConfigValidation\", Boolean.class);\n                method.invoke(fopFactoryBuilder, b);\n            }\n            b = getBooleanProp(\"UseCache\");\n            if (b != null && !b) {\n                Method getFontManager = fclass.getMethod(\"getFontManager\");\n                Object fontManager = getFontManager.invoke(fopFactoryBuilder);\n                method = fontManager.getClass().getMethod(\"disableFontCache\");\n                method.invoke(fontManager);\n            }\n           \n            method = fclass.getMethod(\"build\");\n            fopFactory = method.invoke(fopFactoryBuilder);\n        } catch (Exception e) {\n            throw new XProcException(e);\n        }\n    }","cleancode":"private void initializefop2x(xprocruntime runtime, xstep step, properties options) { object fopfactorybuilder = null; constructor factbuilderconstructor = null; try { factbuilderconstructor = klass.getconstructor(uri.class); } catch (nosuchmethodexception nsme) { } resolver = runtime.getresolver(); uri baseuri = step.getstep().getnode().getbaseuri(); string s = getstringprop(\"baseurl\"); if (s != null) { baseuri = baseuri.resolve(s); } try { if (resolver == null) { fopfactorybuilder = factbuilderconstructor.newinstance(baseuri); } else { fopfactorybuilder = factbuilderconstructor.newinstance(baseuri); } class fclass = fopfactorybuilder.getclass(); boolean b = false; b = getbooleanprop(\"breakindentinheritanceonreferenceareaboundary\"); if (b != null) { method = fclass.getmethod(\"setbreakindentinheritanceonreferenceareaboundary\", boolean.class); method.invoke(fopfactorybuilder, b); } float f = getfloatprop(\"sourceresolution\"); if (f != null) { method = fclass.getmethod(\"setsourceresolution\", float.class); method.invoke(fopfactorybuilder, f); } b = getbooleanprop(\"base14kerningenabled\"); if (b != null) { method getfontmanager = fclass.getmethod(\"getfontmanager\"); object fontmanager = getfontmanager.invoke(fopfactorybuilder); method = fontmanager.getclass().getmethod(\"setbase14kerningenabled\", boolean.class); method.invoke(fontmanager, b); } s = getstringprop(\"pageheight\"); if (s != null) { method = fclass.getmethod(\"setpageheight\", string.class); method.invoke(fopfactorybuilder, s); } s = getstringprop(\"pagewidth\"); if (s != null) { method = fclass.getmethod(\"setpagewidth\", string.class); method.invoke(fopfactorybuilder, s); } f = getfloatprop(\"targetresolution\"); if (f != null) { method = fclass.getmethod(\"settargetresolution\", float.class); method.invoke(fopfactorybuilder, f); } b = getbooleanprop(\"strictuserconfigvalidation\"); if (b != null) { method = fclass.getmethod(\"setstrictuserconfigvalidation\", boolean.class); method.invoke(fopfactorybuilder, b); } b = getbooleanprop(\"strictvalidation\"); if (b != null) { method = fclass.getmethod(\"setstrictuserconfigvalidation\", boolean.class); method.invoke(fopfactorybuilder, b); } b = getbooleanprop(\"usecache\"); if (b != null && !b) { method getfontmanager = fclass.getmethod(\"getfontmanager\"); object fontmanager = getfontmanager.invoke(fopfactorybuilder); method = fontmanager.getclass().getmethod(\"disablefontcache\"); method.invoke(fontmanager); } method = fclass.getmethod(\"build\"); fopfactory = method.invoke(fopfactorybuilder); } catch (exception e) { throw new xprocexception(e); } }","repo":"fsasaki\/xmlcalabash1-print","label":[0,0,1,0]}
{"id":2539,"original_code":"public void format(XdmNode doc, OutputStream out, String contentType) {\n        String outputFormat = null;\n        if (contentType == null || \"application\/pdf\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/pdf\"; \/\/ \"PDF\";\n        } else if (\"application\/PostScript\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/postscript\"; \/\/\"PostScript\";\n        } else if (\"application\/afp\".equalsIgnoreCase(contentType)) {\n            outputFormat =  \"application\/x-afp\";  \/\/\"AFP\";\n        } else if (\"application\/rtf\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/rtf\";\n        } else if (\"text\/plain\".equalsIgnoreCase(contentType)) {\n           outputFormat = \"text\/plain\";\n        } else {\n            throw new XProcException(step.getNode(), \"Unsupported content-type on p:xsl-formatter: \" + contentType);\n        }\n        if (! (\"1.x\".equals(fopVersion) || \"2.x\".equals(fopVersion))) {\n            throw new XProcException(\"Unexpected FOP version: \" + fopVersion);\n        }\n        try {\n            InputSource fodoc = S9apiUtils.xdmToInputSource(runtime, doc);\n            SAXSource source = new SAXSource(fodoc);\n            Object userAgent = null;\n            Object fop = null;\n            if (\"1.x\".equals(fopVersion)) {\n                method = fopFactory.getClass().getMethod(\"newFop\", String.class, OutputStream.class);\n                fop = method.invoke(fopFactory, outputFormat, out);\n                method = fop.getClass().getMethod(\"getUserAgent\");\n                userAgent = method.invoke(fop);\n            } else {\n                method = fopFactory.getClass().getMethod(\"newFOUserAgent\");\n                userAgent = method.invoke(fopFactory);\n            }\n            Class uaClass = userAgent.getClass();\n            Boolean b = getBooleanProp(\"Accessibility\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setAccessibility\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            String s = getStringProp(\"Author\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setAuthor\", String.class);\n                method.invoke(userAgent, s);\n            }\n            if (\"1.x\".equals(fopVersion)) {\n                method = uaClass.getMethod(\"setBaseURL\", String.class);\n                method.invoke(userAgent, step.getNode().getBaseURI().toString());\n                s = getStringProp(\"BaseURL\");\n                if (s != null) {\n                    method.invoke(userAgent, s);\n                }\n            } else {\n                \/\/ FIXME: how do I do this in 2.x?\n            }\n            b = getBooleanProp(\"ConserveMemoryPolicy\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setConserveMemoryPolicy\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            s = getStringProp(\"CreationDate\");\n            if (s != null) {\n                DateFormat df = DateFormat.getDateInstance();\n                Date d = df.parse(s);\n                method = uaClass.getMethod(\"setCreationDate\", Date.class);\n                method.invoke(userAgent, d);\n            }\n            s = getStringProp(\"Creator\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setCreator\", String.class);\n                method.invoke(userAgent, s);\n            }\n            s = getStringProp(\"Keywords\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setKeywords\", String.class);\n                method.invoke(userAgent, s);\n            }\n            b = getBooleanProp(\"LocatorEnabled\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setLocatorEnabled\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            s = getStringProp(\"Producer\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setProducer\", String.class);\n                method.invoke(userAgent, s);\n            }\n            s = getStringProp(\"Subject\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setSubject\", String.class);\n                method.invoke(userAgent, s);\n            }\n            Float f = getFloatProp(\"TargetResolution\");\n            if (f != null) {\n                method = uaClass.getMethod(\"setTargetResolution\", Float.class);\n                method.invoke(userAgent, f);\n            }\n            s = getStringProp(\"Title\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setTitle\", String.class);\n                method.invoke(userAgent, s);\n            }\n            if (\"2.x\".equals(fopVersion)) {\n                method = uaClass.getMethod(\"newFop\", String.class, OutputStream.class);\n                fop = method.invoke(userAgent, outputFormat, out);\n            }\n            method = fop.getClass().getMethod(\"getDefaultHandler\");\n            Object defHandler = method.invoke(fop);\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.transform(source, new SAXResult((ContentHandler) defHandler));\n        } catch (Exception e) {\n            throw new XProcException(step.getNode(), \"Failed to process FO document with FOP\", e);\n        }\n    }","code_wo_comment":"public void format(XdmNode doc, OutputStream out, String contentType) {\n        String outputFormat = null;\n        if (contentType == null || \"application\/pdf\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/pdf\";\n        } else if (\"application\/PostScript\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/postscript\";\n        } else if (\"application\/afp\".equalsIgnoreCase(contentType)) {\n            outputFormat =  \"application\/x-afp\"; \n        } else if (\"application\/rtf\".equalsIgnoreCase(contentType)) {\n            outputFormat = \"application\/rtf\";\n        } else if (\"text\/plain\".equalsIgnoreCase(contentType)) {\n           outputFormat = \"text\/plain\";\n        } else {\n            throw new XProcException(step.getNode(), \"Unsupported content-type on p:xsl-formatter: \" + contentType);\n        }\n        if (! (\"1.x\".equals(fopVersion) || \"2.x\".equals(fopVersion))) {\n            throw new XProcException(\"Unexpected FOP version: \" + fopVersion);\n        }\n        try {\n            InputSource fodoc = S9apiUtils.xdmToInputSource(runtime, doc);\n            SAXSource source = new SAXSource(fodoc);\n            Object userAgent = null;\n            Object fop = null;\n            if (\"1.x\".equals(fopVersion)) {\n                method = fopFactory.getClass().getMethod(\"newFop\", String.class, OutputStream.class);\n                fop = method.invoke(fopFactory, outputFormat, out);\n                method = fop.getClass().getMethod(\"getUserAgent\");\n                userAgent = method.invoke(fop);\n            } else {\n                method = fopFactory.getClass().getMethod(\"newFOUserAgent\");\n                userAgent = method.invoke(fopFactory);\n            }\n            Class uaClass = userAgent.getClass();\n            Boolean b = getBooleanProp(\"Accessibility\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setAccessibility\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            String s = getStringProp(\"Author\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setAuthor\", String.class);\n                method.invoke(userAgent, s);\n            }\n            if (\"1.x\".equals(fopVersion)) {\n                method = uaClass.getMethod(\"setBaseURL\", String.class);\n                method.invoke(userAgent, step.getNode().getBaseURI().toString());\n                s = getStringProp(\"BaseURL\");\n                if (s != null) {\n                    method.invoke(userAgent, s);\n                }\n            } else {\n               \n            }\n            b = getBooleanProp(\"ConserveMemoryPolicy\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setConserveMemoryPolicy\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            s = getStringProp(\"CreationDate\");\n            if (s != null) {\n                DateFormat df = DateFormat.getDateInstance();\n                Date d = df.parse(s);\n                method = uaClass.getMethod(\"setCreationDate\", Date.class);\n                method.invoke(userAgent, d);\n            }\n            s = getStringProp(\"Creator\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setCreator\", String.class);\n                method.invoke(userAgent, s);\n            }\n            s = getStringProp(\"Keywords\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setKeywords\", String.class);\n                method.invoke(userAgent, s);\n            }\n            b = getBooleanProp(\"LocatorEnabled\");\n            if (b != null) {\n                method = uaClass.getMethod(\"setLocatorEnabled\", Boolean.class);\n                method.invoke(userAgent, b);\n            }\n            s = getStringProp(\"Producer\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setProducer\", String.class);\n                method.invoke(userAgent, s);\n            }\n            s = getStringProp(\"Subject\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setSubject\", String.class);\n                method.invoke(userAgent, s);\n            }\n            Float f = getFloatProp(\"TargetResolution\");\n            if (f != null) {\n                method = uaClass.getMethod(\"setTargetResolution\", Float.class);\n                method.invoke(userAgent, f);\n            }\n            s = getStringProp(\"Title\");\n            if (s != null) {\n                method = uaClass.getMethod(\"setTitle\", String.class);\n                method.invoke(userAgent, s);\n            }\n            if (\"2.x\".equals(fopVersion)) {\n                method = uaClass.getMethod(\"newFop\", String.class, OutputStream.class);\n                fop = method.invoke(userAgent, outputFormat, out);\n            }\n            method = fop.getClass().getMethod(\"getDefaultHandler\");\n            Object defHandler = method.invoke(fop);\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.transform(source, new SAXResult((ContentHandler) defHandler));\n        } catch (Exception e) {\n            throw new XProcException(step.getNode(), \"Failed to process FO document with FOP\", e);\n        }\n    }","cleancode":"public void format(xdmnode doc, outputstream out, string contenttype) { string outputformat = null; if (contenttype == null || \"application\/pdf\".equalsignorecase(contenttype)) { outputformat = \"application\/pdf\"; } else if (\"application\/postscript\".equalsignorecase(contenttype)) { outputformat = \"application\/postscript\"; } else if (\"application\/afp\".equalsignorecase(contenttype)) { outputformat = \"application\/x-afp\"; } else if (\"application\/rtf\".equalsignorecase(contenttype)) { outputformat = \"application\/rtf\"; } else if (\"text\/plain\".equalsignorecase(contenttype)) { outputformat = \"text\/plain\"; } else { throw new xprocexception(step.getnode(), \"unsupported content-type on p:xsl-formatter: \" + contenttype); } if (! (\"1.x\".equals(fopversion) || \"2.x\".equals(fopversion))) { throw new xprocexception(\"unexpected fop version: \" + fopversion); } try { inputsource fodoc = s9apiutils.xdmtoinputsource(runtime, doc); saxsource source = new saxsource(fodoc); object useragent = null; object fop = null; if (\"1.x\".equals(fopversion)) { method = fopfactory.getclass().getmethod(\"newfop\", string.class, outputstream.class); fop = method.invoke(fopfactory, outputformat, out); method = fop.getclass().getmethod(\"getuseragent\"); useragent = method.invoke(fop); } else { method = fopfactory.getclass().getmethod(\"newfouseragent\"); useragent = method.invoke(fopfactory); } class uaclass = useragent.getclass(); boolean b = getbooleanprop(\"accessibility\"); if (b != null) { method = uaclass.getmethod(\"setaccessibility\", boolean.class); method.invoke(useragent, b); } string s = getstringprop(\"author\"); if (s != null) { method = uaclass.getmethod(\"setauthor\", string.class); method.invoke(useragent, s); } if (\"1.x\".equals(fopversion)) { method = uaclass.getmethod(\"setbaseurl\", string.class); method.invoke(useragent, step.getnode().getbaseuri().tostring()); s = getstringprop(\"baseurl\"); if (s != null) { method.invoke(useragent, s); } } else { } b = getbooleanprop(\"conservememorypolicy\"); if (b != null) { method = uaclass.getmethod(\"setconservememorypolicy\", boolean.class); method.invoke(useragent, b); } s = getstringprop(\"creationdate\"); if (s != null) { dateformat df = dateformat.getdateinstance(); date d = df.parse(s); method = uaclass.getmethod(\"setcreationdate\", date.class); method.invoke(useragent, d); } s = getstringprop(\"creator\"); if (s != null) { method = uaclass.getmethod(\"setcreator\", string.class); method.invoke(useragent, s); } s = getstringprop(\"keywords\"); if (s != null) { method = uaclass.getmethod(\"setkeywords\", string.class); method.invoke(useragent, s); } b = getbooleanprop(\"locatorenabled\"); if (b != null) { method = uaclass.getmethod(\"setlocatorenabled\", boolean.class); method.invoke(useragent, b); } s = getstringprop(\"producer\"); if (s != null) { method = uaclass.getmethod(\"setproducer\", string.class); method.invoke(useragent, s); } s = getstringprop(\"subject\"); if (s != null) { method = uaclass.getmethod(\"setsubject\", string.class); method.invoke(useragent, s); } float f = getfloatprop(\"targetresolution\"); if (f != null) { method = uaclass.getmethod(\"settargetresolution\", float.class); method.invoke(useragent, f); } s = getstringprop(\"title\"); if (s != null) { method = uaclass.getmethod(\"settitle\", string.class); method.invoke(useragent, s); } if (\"2.x\".equals(fopversion)) { method = uaclass.getmethod(\"newfop\", string.class, outputstream.class); fop = method.invoke(useragent, outputformat, out); } method = fop.getclass().getmethod(\"getdefaulthandler\"); object defhandler = method.invoke(fop); transformerfactory transformerfactory = transformerfactory.newinstance(); transformer transformer = transformerfactory.newtransformer(); transformer.transform(source, new saxresult((contenthandler) defhandler)); } catch (exception e) { throw new xprocexception(step.getnode(), \"failed to process fo document with fop\", e); } }","repo":"fsasaki\/xmlcalabash1-print","label":[0,0,1,0]}
{"id":10831,"original_code":"@Override\n  @SuppressLint(\"SetJavaScriptEnabled\")\n  protected void onCreate(@Nullable Bundle savedInstanceState) {\n    Dank.dependencyInjector().inject(this);\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_login);\n    ButterKnife.bind(this);\n    findAndSetupToolbar();\n    toolbar.setBackground(null);\n    toolbar.setTitle(R.string.login);\n    contentViewGroup.setClipToOutline(true);\n    \/\/ Setup WebView.\n    CookieManager.getInstance().removeAllCookies(null);\n    webView.setWebChromeClient(new WebChromeClient() {\n      @Override\n      public void onProgressChanged(WebView view, int newProgress) {\n        if (!loggedIn) {\n          boolean shouldShowProgress = newProgress < 75;\n          setProgressVisible(shouldShowProgress);\n        }\n      }\n    });\n    webView.setWebViewClient(new WebViewClient() {\n      @Override\n      public void onPageStarted(WebView view, String url, Bitmap favicon) {\n        if (url.contains(\"code=\")) {\n          \/\/ We've detected the redirect URL.\n          webView.stopLoading();\n          loggedIn = true;\n          handleOnPermissionGranted(url);\n        } else if (url.contains(\"error=\")) {\n          Toast.makeText(LoginActivity.this, R.string.login_error_oauth_permission_rejected, Toast.LENGTH_LONG).show();\n          webView.stopLoading();\n          setResult(RESULT_CANCELED);\n          finish();\n        }\n      }\n    });\n    \/\/ Bug workaround: WebView crashes when dropdown is shown on\n    \/\/ a Nougat emulator. Haven't tested on other devices.\n    webView.clearFormData();\n    webView.getSettings().setSaveFormData(false);\n    webView.getSettings().setJavaScriptEnabled(true);\n    webView.getSettings().setDomStorageEnabled(true);\n    userLoginHelper = reddit.get().login().loginHelper();\n    webView.loadUrl(userLoginHelper.authorizationUrl());\n  }","code_wo_comment":"@Override\n  @SuppressLint(\"SetJavaScriptEnabled\")\n  protected void onCreate(@Nullable Bundle savedInstanceState) {\n    Dank.dependencyInjector().inject(this);\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_login);\n    ButterKnife.bind(this);\n    findAndSetupToolbar();\n    toolbar.setBackground(null);\n    toolbar.setTitle(R.string.login);\n    contentViewGroup.setClipToOutline(true);\n   \n    CookieManager.getInstance().removeAllCookies(null);\n    webView.setWebChromeClient(new WebChromeClient() {\n      @Override\n      public void onProgressChanged(WebView view, int newProgress) {\n        if (!loggedIn) {\n          boolean shouldShowProgress = newProgress < 75;\n          setProgressVisible(shouldShowProgress);\n        }\n      }\n    });\n    webView.setWebViewClient(new WebViewClient() {\n      @Override\n      public void onPageStarted(WebView view, String url, Bitmap favicon) {\n        if (url.contains(\"code=\")) {\n         \n          webView.stopLoading();\n          loggedIn = true;\n          handleOnPermissionGranted(url);\n        } else if (url.contains(\"error=\")) {\n          Toast.makeText(LoginActivity.this, R.string.login_error_oauth_permission_rejected, Toast.LENGTH_LONG).show();\n          webView.stopLoading();\n          setResult(RESULT_CANCELED);\n          finish();\n        }\n      }\n    });\n   \n   \n    webView.clearFormData();\n    webView.getSettings().setSaveFormData(false);\n    webView.getSettings().setJavaScriptEnabled(true);\n    webView.getSettings().setDomStorageEnabled(true);\n    userLoginHelper = reddit.get().login().loginHelper();\n    webView.loadUrl(userLoginHelper.authorizationUrl());\n  }","cleancode":"@override @suppresslint(\"setjavascriptenabled\") protected void oncreate(@nullable bundle savedinstancestate) { dank.dependencyinjector().inject(this); super.oncreate(savedinstancestate); setcontentview(r.layout.activity_login); butterknife.bind(this); findandsetuptoolbar(); toolbar.setbackground(null); toolbar.settitle(r.string.login); contentviewgroup.setcliptooutline(true); cookiemanager.getinstance().removeallcookies(null); webview.setwebchromeclient(new webchromeclient() { @override public void onprogresschanged(webview view, int newprogress) { if (!loggedin) { boolean shouldshowprogress = newprogress < 75; setprogressvisible(shouldshowprogress); } } }); webview.setwebviewclient(new webviewclient() { @override public void onpagestarted(webview view, string url, bitmap favicon) { if (url.contains(\"code=\")) { webview.stoploading(); loggedin = true; handleonpermissiongranted(url); } else if (url.contains(\"error=\")) { toast.maketext(loginactivity.this, r.string.login_error_oauth_permission_rejected, toast.length_long).show(); webview.stoploading(); setresult(result_canceled); finish(); } } }); webview.clearformdata(); webview.getsettings().setsaveformdata(false); webview.getsettings().setjavascriptenabled(true); webview.getsettings().setdomstorageenabled(true); userloginhelper = reddit.get().login().loginhelper(); webview.loadurl(userloginhelper.authorizationurl()); }","repo":"federa7675\/Dawn","label":[0,0,1,0]}
{"id":2698,"original_code":"private static void setChipVersion() {\n      \/\/TODO: Get chip version directly if possible.\n      String model = IrisHal.getModel();\n      if (Model.isV2(model)) {\n         hardware.set(\"ZM5304AU-CME3R\");\n      }\n      else if (Model.isV3(model)) {\n         hardware.set(\"ZM5101\");\n      }\n      else {\n         hardware.set(\"unknown\");\n      }\n   }","code_wo_comment":"private static void setChipVersion() {\n     \n      String model = IrisHal.getModel();\n      if (Model.isV2(model)) {\n         hardware.set(\"ZM5304AU-CME3R\");\n      }\n      else if (Model.isV3(model)) {\n         hardware.set(\"ZM5101\");\n      }\n      else {\n         hardware.set(\"unknown\");\n      }\n   }","cleancode":"private static void setchipversion() { string model = irishal.getmodel(); if (model.isv2(model)) { hardware.set(\"zm5304au-cme3r\"); } else if (model.isv3(model)) { hardware.set(\"zm5101\"); } else { hardware.set(\"unknown\"); } }","repo":"eanderso\/arcusplatform","label":[1,0,0,0]}
{"id":19228,"original_code":"@Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if ((keyCode == KeyEvent.KEYCODE_MENU) && (null == getSupportActionBar())) {\n            \/\/ This is to fix a bug in the v7 support lib. If there is no options menu and you hit MENU, it will crash with a\n            \/\/ NPE @ android.support.v7.app.ActionBarImplICS.getThemedContext(ActionBarImplICS.java:274)\n            \/\/ This can safely be removed if we add in menu options on this screen\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }","code_wo_comment":"@Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if ((keyCode == KeyEvent.KEYCODE_MENU) && (null == getSupportActionBar())) {\n           \n           \n           \n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }","cleancode":"@override public boolean onkeydown(int keycode, keyevent event) { if ((keycode == keyevent.keycode_menu) && (null == getsupportactionbar())) { return true; } return super.onkeydown(keycode, event); }","repo":"developers16\/GithubsSample","label":[1,0,0,0]}
{"id":19294,"original_code":"public FFprobe setShowProgramVersion(final boolean showProgramVersion) {\n        this.showProgramVersion = showProgramVersion;\n        return this;\n    }","code_wo_comment":"public FFprobe setShowProgramVersion(final boolean showProgramVersion) {\n        this.showProgramVersion = showProgramVersion;\n        return this;\n    }","cleancode":"public ffprobe setshowprogramversion(final boolean showprogramversion) { this.showprogramversion = showprogramversion; return this; }","repo":"entropycoder\/Jaffree","label":[0,1,0,0]}
{"id":19297,"original_code":"public FFprobe setShowPixelFormats(final boolean showPixelFormats) {\n        this.showPixelFormats = showPixelFormats;\n        return this;\n    }","code_wo_comment":"public FFprobe setShowPixelFormats(final boolean showPixelFormats) {\n        this.showPixelFormats = showPixelFormats;\n        return this;\n    }","cleancode":"public ffprobe setshowpixelformats(final boolean showpixelformats) { this.showpixelformats = showpixelformats; return this; }","repo":"entropycoder\/Jaffree","label":[0,1,0,0]}
{"id":19398,"original_code":"private void label_iconRealizarPedidoMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_label_iconRealizarPedidoMouseClicked\n        \/\/ TODO add your handling code here:\n        \/\/instanciar a tela cad pessoa apenas uma vez\n        tela_realizarPedido= new Realizar_Pedido(this.conta);\n        tela_realizarPedido.setVisible(true);\n        tela_realizarPedido.setLocationRelativeTo(null);\n    }","code_wo_comment":"private void label_iconRealizarPedidoMouseClicked(java.awt.event.MouseEvent evt) {       \n       \n        tela_realizarPedido= new Realizar_Pedido(this.conta);\n        tela_realizarPedido.setVisible(true);\n        tela_realizarPedido.setLocationRelativeTo(null);\n    }","cleancode":"private void label_iconrealizarpedidomouseclicked(java.awt.event.mouseevent evt) { tela_realizarpedido= new realizar_pedido(this.conta); tela_realizarpedido.setvisible(true); tela_realizarpedido.setlocationrelativeto(null); }","repo":"fsilva-c\/Screens_LP2","label":[0,1,0,0]}
{"id":19831,"original_code":"public Expression getObject() {\n        return fObject;\n    }","code_wo_comment":"public Expression getObject() {\n        return fObject;\n    }","cleancode":"public expression getobject() { return fobject; }","repo":"duarterafael\/Conformitate","label":[0,1,0,0]}
{"id":19832,"original_code":"public MAttribute getAttribute() {\n        return fAttribute;\n    }","code_wo_comment":"public MAttribute getAttribute() {\n        return fAttribute;\n    }","cleancode":"public mattribute getattribute() { return fattribute; }","repo":"duarterafael\/Conformitate","label":[0,1,0,0]}
{"id":19833,"original_code":"public MRValue getRValue() {\n        return fRValue;\n    }","code_wo_comment":"public MRValue getRValue() {\n        return fRValue;\n    }","cleancode":"public mrvalue getrvalue() { return frvalue; }","repo":"duarterafael\/Conformitate","label":[0,1,0,0]}
{"id":19851,"original_code":"public String getTagitLayoutPath() {\n\t\tString res = \"content\/none.xhtml\";\n\t\t\/\/if explorer is in createMode\n\t\tswitch( explorerAction.getMode() ) {\n\t\tcase CREATE_LOCATION:\n\t\t\tres = \"content_new\/location_new.xhtml\";\n\t\t\tif( newLocationAction.getMode() == -1 ) {\n\t\t\t\tnewLocationAction.begin();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CREATE_ROUTE:\n\t\t\tres = \"content_new\/route_new.xhtml\";\n\t\t\tif( newRouteAction.getMode() != 2 ) {\n\t\t\t\tnewRouteAction.setMode(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\/\/there must be a ranking because everything that is displayable on tagit\n\t\t\t\/\/is a PointOfInetrest but maybe also another type (like a route)\n\t\t\t\/\/until then we break, when contentItem has topType (like route)\n\t\t\t\/\/init with none\n\t\t\tfor( KiWiResource type : currentContentItem.getTypes() ) {\n\t\t\t\tString seRQLID = type.getSeRQLID();\n\t\t\t\tif(seRQLID.contains(Constants.NS_FCP_CORE+\"Location\")) {\n\t\t\t\t\tres = \"content\/location.xhtml\";\n\t\t\t\t\tlocationAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_KIWI_CORE+\"BlogPost\")) {\n\t\t\t\t\t\/\/TODO should be a specific Blog interface\n\t\t\t\t\tres = \"content\/blog.xhtml\";\n\t\t\t\t\tnewsItemAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_FCP_CORE+\"NewsItem\")) {\n\t\t\t\t\tres = \"content\/newsItem.xhtml\";\n\t\t\t\t\tnewsItemAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_TAGIT + \"Route\")) {\n\t\t\t\t\t\/\/TODO CHANGE!!!\n\t\t\t\t\tres = \"content\/route.xhtml\";\n\t\t\t\t\t\/\/res = \"content\/photoroute.xhtml\";\n\t\t\t\t\trouteAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_KIWI_CORE + \"User\")) {\n\t\t\t\t\t\/\/if( currentUser.getContentItem().getId() == currentContentItem.getId() ) {\n\t\t\t\t\t\/\/\tres = \"content\/user.xhtml\";\n\t\t\t\t\t\/\/\tpersonAction.begin();\n\t\t\t\t\t\/\/\tbreak;\n\t\t\t\t\t\/\/} else {\n\t\t\t\t\t\tres = \"content\/person.xhtml\";\n\t\t\t\t\t\tpersonAction.begin();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\/\/}\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_DEMO+\"LocatedMeeting\")) {\n\t\t\t\t\tres = \"content\/location.xhtml\";\n\t\t\t\t\tlocationAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\/\/TODO some common type for all pois\n\t\t}\n\t\tlog.info(\"set layout to #0\",res);\n\t\treturn res;\n\t}","code_wo_comment":"public String getTagitLayoutPath() {\n\t\tString res = \"content\/none.xhtml\";\n\t\n\t\tswitch( explorerAction.getMode() ) {\n\t\tcase CREATE_LOCATION:\n\t\t\tres = \"content_new\/location_new.xhtml\";\n\t\t\tif( newLocationAction.getMode() == -1 ) {\n\t\t\t\tnewLocationAction.begin();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CREATE_ROUTE:\n\t\t\tres = \"content_new\/route_new.xhtml\";\n\t\t\tif( newRouteAction.getMode() != 2 ) {\n\t\t\t\tnewRouteAction.setMode(2);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\tfor( KiWiResource type : currentContentItem.getTypes() ) {\n\t\t\t\tString seRQLID = type.getSeRQLID();\n\t\t\t\tif(seRQLID.contains(Constants.NS_FCP_CORE+\"Location\")) {\n\t\t\t\t\tres = \"content\/location.xhtml\";\n\t\t\t\t\tlocationAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_KIWI_CORE+\"BlogPost\")) {\n\t\t\t\t\n\t\t\t\t\tres = \"content\/blog.xhtml\";\n\t\t\t\t\tnewsItemAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_FCP_CORE+\"NewsItem\")) {\n\t\t\t\t\tres = \"content\/newsItem.xhtml\";\n\t\t\t\t\tnewsItemAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_TAGIT + \"Route\")) {\n\t\t\t\t\n\t\t\t\t\tres = \"content\/route.xhtml\";\n\t\t\t\t\n\t\t\t\t\trouteAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_KIWI_CORE + \"User\")) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\tres = \"content\/person.xhtml\";\n\t\t\t\t\t\tpersonAction.begin();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\t} else if(seRQLID.contains(Constants.NS_DEMO+\"LocatedMeeting\")) {\n\t\t\t\t\tres = \"content\/location.xhtml\";\n\t\t\t\t\tlocationAction.begin();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlog.info(\"set layout to #0\",res);\n\t\treturn res;\n\t}","cleancode":"public string gettagitlayoutpath() { string res = \"content\/none.xhtml\"; switch( exploreraction.getmode() ) { case create_location: res = \"content_new\/location_new.xhtml\"; if( newlocationaction.getmode() == -1 ) { newlocationaction.begin(); } break; case create_route: res = \"content_new\/route_new.xhtml\"; if( newrouteaction.getmode() != 2 ) { newrouteaction.setmode(2); } break; default: for( kiwiresource type : currentcontentitem.gettypes() ) { string serqlid = type.getserqlid(); if(serqlid.contains(constants.ns_fcp_core+\"location\")) { res = \"content\/location.xhtml\"; locationaction.begin(); break; } else if(serqlid.contains(constants.ns_kiwi_core+\"blogpost\")) { res = \"content\/blog.xhtml\"; newsitemaction.begin(); break; } else if(serqlid.contains(constants.ns_fcp_core+\"newsitem\")) { res = \"content\/newsitem.xhtml\"; newsitemaction.begin(); break; } else if(serqlid.contains(constants.ns_tagit + \"route\")) { res = \"content\/route.xhtml\"; routeaction.begin(); break; } else if(serqlid.contains(constants.ns_kiwi_core + \"user\")) { res = \"content\/person.xhtml\"; personaction.begin(); break; } else if(serqlid.contains(constants.ns_demo+\"locatedmeeting\")) { res = \"content\/location.xhtml\"; locationaction.begin(); break; } } } log.info(\"set layout to #0\",res); return res; }","repo":"fregaham\/KiWi","label":[1,1,0,0]}
{"id":11778,"original_code":"void load(FPod fpod)\n  {\n    this.fpod = fpod;\n    this.typesByName = new HashMap();\n    \/\/ create a hollow Type for each FType (this requires two steps,\n    \/\/ because we don't necessary have all the Types created for\n    \/\/ superclasses until this loop completes)\n    int numTypes = fpod.types == null ? 0 : fpod.types.length;\n    types = new ClassType[numTypes];\n    for (int i=0; i<numTypes; ++i)\n    {\n      \/\/ create type instance\n      ClassType type = new ClassType(this, fpod.types[i]);\n      \/\/ add to my data structures\n      types[i] = type;\n      if (typesByName.put(type.name, type) != null)\n        throw Err.make(\"Invalid pod: \" + name + \" type already defined: \" + type.name);\n    }\n    \/\/ get TypeType to use for mixin List (we need to handle case\n    \/\/ when loading sys itself - and lookup within my own pod)\n    Type typeType = Sys.TypeType;\n    if (typeType == null)\n      typeType = (Type)typesByName.get(\"Type\");\n    \/\/ now that everthing is mapped, we can fill in the super\n    \/\/ class fields (unless something is wacked, this will only\n    \/\/ use Types in my pod or in pods already loaded)\n    for (int i=0; i<numTypes; ++i)\n    {\n      FType ftype = fpod.types[i];\n      ClassType type = types[i];\n      type.base = type(ftype.base);\n      Object[] mixins = new Object[ftype.mixins.length];\n      for (int j=0; j<mixins.length; ++j)\n        mixins[j] = type(ftype.mixins[j]);\n      type.mixins = new List(typeType, mixins).ro();\n    }\n  }","code_wo_comment":"void load(FPod fpod)\n  {\n    this.fpod = fpod;\n    this.typesByName = new HashMap();\n   \n   \n   \n    int numTypes = fpod.types == null ? 0 : fpod.types.length;\n    types = new ClassType[numTypes];\n    for (int i=0; i<numTypes; ++i)\n    {\n     \n      ClassType type = new ClassType(this, fpod.types[i]);\n     \n      types[i] = type;\n      if (typesByName.put(type.name, type) != null)\n        throw Err.make(\"Invalid pod: \" + name + \" type already defined: \" + type.name);\n    }\n   \n   \n    Type typeType = Sys.TypeType;\n    if (typeType == null)\n      typeType = (Type)typesByName.get(\"Type\");\n   \n   \n   \n    for (int i=0; i<numTypes; ++i)\n    {\n      FType ftype = fpod.types[i];\n      ClassType type = types[i];\n      type.base = type(ftype.base);\n      Object[] mixins = new Object[ftype.mixins.length];\n      for (int j=0; j<mixins.length; ++j)\n        mixins[j] = type(ftype.mixins[j]);\n      type.mixins = new List(typeType, mixins).ro();\n    }\n  }","cleancode":"void load(fpod fpod) { this.fpod = fpod; this.typesbyname = new hashmap(); int numtypes = fpod.types == null ? 0 : fpod.types.length; types = new classtype[numtypes]; for (int i=0; i<numtypes; ++i) { classtype type = new classtype(this, fpod.types[i]); types[i] = type; if (typesbyname.put(type.name, type) != null) throw err.make(\"invalid pod: \" + name + \" type already defined: \" + type.name); } type typetype = sys.typetype; if (typetype == null) typetype = (type)typesbyname.get(\"type\"); for (int i=0; i<numtypes; ++i) { ftype ftype = fpod.types[i]; classtype type = types[i]; type.base = type(ftype.base); object[] mixins = new object[ftype.mixins.length]; for (int j=0; j<mixins.length; ++j) mixins[j] = type(ftype.mixins[j]); type.mixins = new list(typetype, mixins).ro(); } }","repo":"fanx-dev\/fantom","label":[0,1,0,0]}
{"id":11829,"original_code":"@Override\n  public action to_value(action expression, origin the_origin) {\n    if (constraints != null) {\n      \/\/ We need to specially handled narrowed variables here\n      \/\/ because the reference type is not narrowed.\n      \/\/ Say the variable declaration is \"string or null foo\", and it's narrowed to string.\n      \/\/ The is_reference_type(the_type) would return a union type, which is not what we want.\n      action narrowed_action = can_narrow(expression, constraints);\n      if (narrowed_action != null) {\n        return narrowed_action;\n      }\n    }\n    type the_type = expression.result().type_bound();\n    if (common_types.is_reference_type(the_type)) {\n      \/\/ TODO: check that flavor is readonly or mutable.\n      type value_type = common_types.get_reference_parameter(the_type);\n      \/\/ TODO: replace this with a promotion lookup.\n      return promote(expression, value_type, the_origin);\n    } else {\n      return expression;\n    }\n  }","code_wo_comment":"@Override\n  public action to_value(action expression, origin the_origin) {\n    if (constraints != null) {\n     \n     \n     \n     \n      action narrowed_action = can_narrow(expression, constraints);\n      if (narrowed_action != null) {\n        return narrowed_action;\n      }\n    }\n    type the_type = expression.result().type_bound();\n    if (common_types.is_reference_type(the_type)) {\n     \n      type value_type = common_types.get_reference_parameter(the_type);\n     \n      return promote(expression, value_type, the_origin);\n    } else {\n      return expression;\n    }\n  }","cleancode":"@override public action to_value(action expression, origin the_origin) { if (constraints != null) { action narrowed_action = can_narrow(expression, constraints); if (narrowed_action != null) { return narrowed_action; } } type the_type = expression.result().type_bound(); if (common_types.is_reference_type(the_type)) { type value_type = common_types.get_reference_parameter(the_type); return promote(expression, value_type, the_origin); } else { return expression; } }","repo":"dynin\/ideal","label":[1,1,0,0]}
{"id":20164,"original_code":"@Override\n    protected void reloadSettings( List<String> updatedSettings ) {\n        \/\/ TODO: Implement disconnect and reconnect to PostgreSQL instance.\n    }","code_wo_comment":"@Override\n    protected void reloadSettings( List<String> updatedSettings ) {\n       \n    }","cleancode":"@override protected void reloadsettings( list<string> updatedsettings ) { }","repo":"em3ndez\/Polypheny-DB","label":[0,1,0,0]}
{"id":20491,"original_code":"private void attemptLogin() {\n        \/\/ Reset errors.\n        mEmailView.setError(null);\n        mPasswordView.setError(null);\n        \/\/ Store values at the time of the login attempt.\n        final String email = mEmailView.getText().toString();\n        final String password = mPasswordView.getText().toString();\n        boolean cancel = false;\n        View focusView = null;\n        \/\/ Check for a valid password.\n        if (TextUtils.isEmpty(password)) {\n            mPasswordView.setError(getString(R.string.error_field_required));\n            focusView = mPasswordView;\n            cancel = true;\n        }\n        \/\/ Check for a valid email address.\n        if (TextUtils.isEmpty(email)) {\n            mEmailView.setError(getString(R.string.error_field_required));\n            focusView = mEmailView;\n            cancel = true;\n        }\n        if (cancel) {\n            \/\/ There was an error; don't attempt login and focus the first\n            \/\/ form field with an error.\n            focusView.requestFocus();\n        } else {\n            \/\/We show the loader and hide the form\n            showHideView(mProgressView, mLoginFormView, true);\n            \/\/We set the response listener with corresponding overridden methods\n            AppResponseListener<JSONObject> responseListener = new AppResponseListener<JSONObject>(getApplicationContext()){\n                @Override\n                public void onResponse(JSONObject response) {\n                    Context context = getApplicationContext();\n                    String firstName = null;\n                    String lastName = null;\n                    try {\n                        firstName = response.getString(UserRequestManager.FIRST_NAME);\n                        lastName = response.getString(UserRequestManager.LAST_NAME);\n                    } catch (JSONException e) {\n                        e.printStackTrace();\n                    }\n                    \/\/TODO: Use method UserManager.logInUser loading user from database\n                    PrefsManager.saveUserCredentials(context, email, password);\n                    PrefsManager.setStringPref(context, PrefsManager.PREF_USER_FIRST_NAME, firstName);\n                    PrefsManager.setStringPref(context, PrefsManager.PREF_USER_LAST_NAME, lastName);\n                    startActivityClosingAllOthers(DrawerActivity.class);\n                    onPostResponse();\n                }\n                @Override\n                public void onUnauthorizedError(VolleyError error) {\n                    showToast(R.string.error_wrong_credentials);\n                }\n                @Override\n                public void onPostResponse(){\n                    showHideView(mLoginFormView, mProgressView, true);\n                }\n            };\n            \/\/We add the request\n            JsonObjectRequest request = UserRequestManager.userLogInRequest(email, password, responseListener);\n            VolleyManager.getInstance(getApplicationContext()).addToRequestQueue(request);\n        }\n    }","code_wo_comment":"private void attemptLogin() {\n       \n        mEmailView.setError(null);\n        mPasswordView.setError(null);\n       \n        final String email = mEmailView.getText().toString();\n        final String password = mPasswordView.getText().toString();\n        boolean cancel = false;\n        View focusView = null;\n       \n        if (TextUtils.isEmpty(password)) {\n            mPasswordView.setError(getString(R.string.error_field_required));\n            focusView = mPasswordView;\n            cancel = true;\n        }\n       \n        if (TextUtils.isEmpty(email)) {\n            mEmailView.setError(getString(R.string.error_field_required));\n            focusView = mEmailView;\n            cancel = true;\n        }\n        if (cancel) {\n           \n           \n            focusView.requestFocus();\n        } else {\n           \n            showHideView(mProgressView, mLoginFormView, true);\n           \n            AppResponseListener<JSONObject> responseListener = new AppResponseListener<JSONObject>(getApplicationContext()){\n                @Override\n                public void onResponse(JSONObject response) {\n                    Context context = getApplicationContext();\n                    String firstName = null;\n                    String lastName = null;\n                    try {\n                        firstName = response.getString(UserRequestManager.FIRST_NAME);\n                        lastName = response.getString(UserRequestManager.LAST_NAME);\n                    } catch (JSONException e) {\n                        e.printStackTrace();\n                    }\n                   \n                    PrefsManager.saveUserCredentials(context, email, password);\n                    PrefsManager.setStringPref(context, PrefsManager.PREF_USER_FIRST_NAME, firstName);\n                    PrefsManager.setStringPref(context, PrefsManager.PREF_USER_LAST_NAME, lastName);\n                    startActivityClosingAllOthers(DrawerActivity.class);\n                    onPostResponse();\n                }\n                @Override\n                public void onUnauthorizedError(VolleyError error) {\n                    showToast(R.string.error_wrong_credentials);\n                }\n                @Override\n                public void onPostResponse(){\n                    showHideView(mLoginFormView, mProgressView, true);\n                }\n            };\n           \n            JsonObjectRequest request = UserRequestManager.userLogInRequest(email, password, responseListener);\n            VolleyManager.getInstance(getApplicationContext()).addToRequestQueue(request);\n        }\n    }","cleancode":"private void attemptlogin() { memailview.seterror(null); mpasswordview.seterror(null); final string email = memailview.gettext().tostring(); final string password = mpasswordview.gettext().tostring(); boolean cancel = false; view focusview = null; if (textutils.isempty(password)) { mpasswordview.seterror(getstring(r.string.error_field_required)); focusview = mpasswordview; cancel = true; } if (textutils.isempty(email)) { memailview.seterror(getstring(r.string.error_field_required)); focusview = memailview; cancel = true; } if (cancel) { focusview.requestfocus(); } else { showhideview(mprogressview, mloginformview, true); appresponselistener<jsonobject> responselistener = new appresponselistener<jsonobject>(getapplicationcontext()){ @override public void onresponse(jsonobject response) { context context = getapplicationcontext(); string firstname = null; string lastname = null; try { firstname = response.getstring(userrequestmanager.first_name); lastname = response.getstring(userrequestmanager.last_name); } catch (jsonexception e) { e.printstacktrace(); } prefsmanager.saveusercredentials(context, email, password); prefsmanager.setstringpref(context, prefsmanager.pref_user_first_name, firstname); prefsmanager.setstringpref(context, prefsmanager.pref_user_last_name, lastname); startactivityclosingallothers(draweractivity.class); onpostresponse(); } @override public void onunauthorizederror(volleyerror error) { showtoast(r.string.error_wrong_credentials); } @override public void onpostresponse(){ showhideview(mloginformview, mprogressview, true); } }; jsonobjectrequest request = userrequestmanager.userloginrequest(email, password, responselistener); volleymanager.getinstance(getapplicationcontext()).addtorequestqueue(request); } }","repo":"edwinperaza\/playmagnet","label":[1,0,0,0]}
{"id":20492,"original_code":"public static boolean isEmailValid(String email) {\n        \/\/TODO: Replace this with your own logic\n        return email.contains(\"@\");\n    }","code_wo_comment":"public static boolean isEmailValid(String email) {\n       \n        return email.contains(\"@\");\n    }","cleancode":"public static boolean isemailvalid(string email) { return email.contains(\"@\"); }","repo":"edwinperaza\/playmagnet","label":[0,1,0,0]}
{"id":20609,"original_code":"private void _setShutter(String name) {\n        Shutter oldValue = getShutter();\n        Shutter shutter = Shutter.getShutter(name, oldValue);\n        \/\/ XXX: Fix for older XML files saved with wrong shutter value\n        if (shutter == Shutter.OPEN && _lamps.size() == 1) {\n            Lamp lamp = _lamps.iterator().next();\n            if (lamp != Lamp.IR_GREY_BODY_HIGH && lamp != Lamp.IR_GREY_BODY_LOW) {\n                shutter = Shutter.CLOSED;\n            }\n        }\n        setShutter(shutter);\n    }","code_wo_comment":"private void _setShutter(String name) {\n        Shutter oldValue = getShutter();\n        Shutter shutter = Shutter.getShutter(name, oldValue);\n       \n        if (shutter == Shutter.OPEN && _lamps.size() == 1) {\n            Lamp lamp = _lamps.iterator().next();\n            if (lamp != Lamp.IR_GREY_BODY_HIGH && lamp != Lamp.IR_GREY_BODY_LOW) {\n                shutter = Shutter.CLOSED;\n            }\n        }\n        setShutter(shutter);\n    }","cleancode":"private void _setshutter(string name) { shutter oldvalue = getshutter(); shutter shutter = shutter.getshutter(name, oldvalue); if (shutter == shutter.open && _lamps.size() == 1) { lamp lamp = _lamps.iterator().next(); if (lamp != lamp.ir_grey_body_high && lamp != lamp.ir_grey_body_low) { shutter = shutter.closed; } } setshutter(shutter); }","repo":"cquiroz\/ocs","label":[0,0,1,0]}
{"id":20684,"original_code":"@Override\n    public synchronized void compress(SpdyFrame frame, int start)\n            throws IOException {\n        init(frame.version);\n        if (compressBuffer == null) {\n            compressBuffer = new byte[frame.data.length];\n        }\n        \/\/System.out.println(HexDumpListener.getHexDump(frame.data, 0, frame.endData, true, true));\n        Deflater zip = zipOut;\n        \/\/ last byte for flush ?\n        zip.setInput(frame.data, start, frame.endData - start - 1);\n        int coff = start;\n        zip.setLevel(Deflater.DEFAULT_COMPRESSION);\n        while (true) {\n            int rd = zip.deflate(compressBuffer, coff, compressBuffer.length - coff);\n            if (rd == 0) {\n                \/\/ needsInput needs to be called - we're done with this frame ?\n                zip.setInput(frame.data, frame.endData - 1, 1);\n                zip.setLevel(Deflater.BEST_SPEED);\n                while (true) {\n                    rd = zip.deflate(compressBuffer, coff, compressBuffer.length - coff);\n                    coff += rd;\n                    if (rd == 0) {\n                        break;\n                    }\n                    byte[] b = new byte[compressBuffer.length * 2];\n                    System.arraycopy(compressBuffer, 0, b, 0, coff);\n                    compressBuffer = b;\n                }\n                zip.setLevel(Deflater.DEFAULT_COMPRESSION);\n                break;\n            }\n            coff += rd;\n        }\n        byte[] tmp = frame.data;\n        frame.data = compressBuffer;\n        compressBuffer = tmp;\n        frame.endData = coff;\n    }","code_wo_comment":"@Override\n    public synchronized void compress(SpdyFrame frame, int start)\n            throws IOException {\n        init(frame.version);\n        if (compressBuffer == null) {\n            compressBuffer = new byte[frame.data.length];\n        }\n       \n        Deflater zip = zipOut;\n       \n        zip.setInput(frame.data, start, frame.endData - start - 1);\n        int coff = start;\n        zip.setLevel(Deflater.DEFAULT_COMPRESSION);\n        while (true) {\n            int rd = zip.deflate(compressBuffer, coff, compressBuffer.length - coff);\n            if (rd == 0) {\n               \n                zip.setInput(frame.data, frame.endData - 1, 1);\n                zip.setLevel(Deflater.BEST_SPEED);\n                while (true) {\n                    rd = zip.deflate(compressBuffer, coff, compressBuffer.length - coff);\n                    coff += rd;\n                    if (rd == 0) {\n                        break;\n                    }\n                    byte[] b = new byte[compressBuffer.length * 2];\n                    System.arraycopy(compressBuffer, 0, b, 0, coff);\n                    compressBuffer = b;\n                }\n                zip.setLevel(Deflater.DEFAULT_COMPRESSION);\n                break;\n            }\n            coff += rd;\n        }\n        byte[] tmp = frame.data;\n        frame.data = compressBuffer;\n        compressBuffer = tmp;\n        frame.endData = coff;\n    }","cleancode":"@override public synchronized void compress(spdyframe frame, int start) throws ioexception { init(frame.version); if (compressbuffer == null) { compressbuffer = new byte[frame.data.length]; } deflater zip = zipout; zip.setinput(frame.data, start, frame.enddata - start - 1); int coff = start; zip.setlevel(deflater.default_compression); while (true) { int rd = zip.deflate(compressbuffer, coff, compressbuffer.length - coff); if (rd == 0) { zip.setinput(frame.data, frame.enddata - 1, 1); zip.setlevel(deflater.best_speed); while (true) { rd = zip.deflate(compressbuffer, coff, compressbuffer.length - coff); coff += rd; if (rd == 0) { break; } byte[] b = new byte[compressbuffer.length * 2]; system.arraycopy(compressbuffer, 0, b, 0, coff); compressbuffer = b; } zip.setlevel(deflater.default_compression); break; } coff += rd; } byte[] tmp = frame.data; frame.data = compressbuffer; compressbuffer = tmp; frame.enddata = coff; }","repo":"costinm\/tomcat","label":[1,0,0,0]}
{"id":12650,"original_code":"@Test\n\tpublic void test() throws Exception {\n\t\t\/\/ Workaround for failing tests. When these tests are executed in\n\t\t\/\/ separate test methods, only the first one passes successfully.\n\t\ttestLogDebug();\n\t\ttestLogError();\n\t\ttestLogWarn();\n\t\ttestLogInfo();\n\t\ttestLogTrace();\n\t\ttestLogDebugWithThrowable();\n\t\ttestLogErrorWithThrowable();\n\t\ttestLogWarnWithThrowable();\n\t\ttestLogInfoWithThrowable();\n\t\ttestLogTraceWithThrowable();\n\t}","code_wo_comment":"@Test\n\tpublic void test() throws Exception {\n\t\n\t\n\t\ttestLogDebug();\n\t\ttestLogError();\n\t\ttestLogWarn();\n\t\ttestLogInfo();\n\t\ttestLogTrace();\n\t\ttestLogDebugWithThrowable();\n\t\ttestLogErrorWithThrowable();\n\t\ttestLogWarnWithThrowable();\n\t\ttestLogInfoWithThrowable();\n\t\ttestLogTraceWithThrowable();\n\t}","cleancode":"@test public void test() throws exception { testlogdebug(); testlogerror(); testlogwarn(); testloginfo(); testlogtrace(); testlogdebugwiththrowable(); testlogerrorwiththrowable(); testlogwarnwiththrowable(); testloginfowiththrowable(); testlogtracewiththrowable(); }","repo":"delchev\/cloud-dirigible","label":[0,0,0,1]}
{"id":20936,"original_code":"public static void addFuncprodutividade() {\n        funcionarios[1] = new FuncProdutividade(JOptionPane.showInputDialog(\"Numero do BI do funcionario produtividade\"), JOptionPane.showInputDialog(\"Data de ingresso do funcionario produtividade\"), Double.parseDouble(JOptionPane.showInputDialog(\"Salario do funcionario produtividade\")), Integer.parseInt(JOptionPane.showInputDialog(\"Unidade produzida do funcionario produtividade\")), Double.parseDouble(JOptionPane.showInputDialog(\"Valor da unidade produzida funcionario produtividade\")));\n    }","code_wo_comment":"public static void addFuncprodutividade() {\n        funcionarios[1] = new FuncProdutividade(JOptionPane.showInputDialog(\"Numero do BI do funcionario produtividade\"), JOptionPane.showInputDialog(\"Data de ingresso do funcionario produtividade\"), Double.parseDouble(JOptionPane.showInputDialog(\"Salario do funcionario produtividade\")), Integer.parseInt(JOptionPane.showInputDialog(\"Unidade produzida do funcionario produtividade\")), Double.parseDouble(JOptionPane.showInputDialog(\"Valor da unidade produzida funcionario produtividade\")));\n    }","cleancode":"public static void addfuncprodutividade() { funcionarios[1] = new funcprodutividade(joptionpane.showinputdialog(\"numero do bi do funcionario produtividade\"), joptionpane.showinputdialog(\"data de ingresso do funcionario produtividade\"), double.parsedouble(joptionpane.showinputdialog(\"salario do funcionario produtividade\")), integer.parseint(joptionpane.showinputdialog(\"unidade produzida do funcionario produtividade\")), double.parsedouble(joptionpane.showinputdialog(\"valor da unidade produzida funcionario produtividade\"))); }","repo":"fernandogomesfg\/Algoritmos-em-Java","label":[1,0,0,0]}
{"id":20938,"original_code":"public static void printSalarioProdutividade() {\n        for (int i = 0; i < funcionarios.length; i++) {\n            if (funcionarios[i] instanceof FuncProdutividade) {\n                System.out.println(funcionarios[i].calcularRemuneracao());\n            }\n        }\n    }","code_wo_comment":"public static void printSalarioProdutividade() {\n        for (int i = 0; i < funcionarios.length; i++) {\n            if (funcionarios[i] instanceof FuncProdutividade) {\n                System.out.println(funcionarios[i].calcularRemuneracao());\n            }\n        }\n    }","cleancode":"public static void printsalarioprodutividade() { for (int i = 0; i < funcionarios.length; i++) { if (funcionarios[i] instanceof funcprodutividade) { system.out.println(funcionarios[i].calcularremuneracao()); } } }","repo":"fernandogomesfg\/Algoritmos-em-Java","label":[1,0,0,0]}
{"id":12906,"original_code":"private void distribute(Distribution[] distributionList, int iterationNum) {\n        Distribution[] busy = null; \/\/*TODO CONSIDER USE LIST WITH INITIAL CAP SIZE\n        for (int inc = 0; inc < distributionList.length; inc++) {\n            if (distributionList[inc] == null)\n                continue;\n            if (!distributionList[inc].getiStepDecorator().offerQueueSubjectUpdate(distributionList[inc].getData(), distributionList[inc].getSubject())) {\n                if (busy == null) {\n                    busy = new Distribution[distributionList.length];\n                }\n                busy[inc] = distributionList[inc];\n                logger.debug(\"Distribution not succeeded. Moving to Deceleration Mode for Subject: \"  + busy[inc].getSubject() + \". Iteration number - \" + iterationNum + \"\/\" + MAXIMUM_OFFERS_RETRIES);\n            }\n        }\n        if (!isEmpty(busy)) {\n            \/\/* ***** Deceleration Mode *****\n            if (iterationNum >= MAXIMUM_OFFERS_RETRIES) {\n                logger.debug(\"Deceleration Mode failed after \" + iterationNum + \"\/\" + MAXIMUM_OFFERS_RETRIES + \" retries. Moving back to normal distribution\");\n                for (Distribution dist : distributionList) {\n                    if (dist == null)\n                        continue;\n                    dist.getiStepDecorator().queueSubjectUpdate(dist.getData(), dist.getSubject());\n                }\n            }\n            try {\n                logger.debug(\"Retarding the distribution for \" + WAIT_PERIOD_MILLI * iterationNum + \" milliseconds\");\n                Thread.sleep(WAIT_PERIOD_MILLI * iterationNum);\n            } catch (InterruptedException e) {\n                throw new SteppingSystemException(\"Distribution timeout failed\");\n            }\n            distribute(busy, ++iterationNum);\n        }\n    }","code_wo_comment":"private void distribute(Distribution[] distributionList, int iterationNum) {\n        Distribution[] busy = null;\n        for (int inc = 0; inc < distributionList.length; inc++) {\n            if (distributionList[inc] == null)\n                continue;\n            if (!distributionList[inc].getiStepDecorator().offerQueueSubjectUpdate(distributionList[inc].getData(), distributionList[inc].getSubject())) {\n                if (busy == null) {\n                    busy = new Distribution[distributionList.length];\n                }\n                busy[inc] = distributionList[inc];\n                logger.debug(\"Distribution not succeeded. Moving to Deceleration Mode for Subject: \"  + busy[inc].getSubject() + \". Iteration number - \" + iterationNum + \"\/\" + MAXIMUM_OFFERS_RETRIES);\n            }\n        }\n        if (!isEmpty(busy)) {\n           \n            if (iterationNum >= MAXIMUM_OFFERS_RETRIES) {\n                logger.debug(\"Deceleration Mode failed after \" + iterationNum + \"\/\" + MAXIMUM_OFFERS_RETRIES + \" retries. Moving back to normal distribution\");\n                for (Distribution dist : distributionList) {\n                    if (dist == null)\n                        continue;\n                    dist.getiStepDecorator().queueSubjectUpdate(dist.getData(), dist.getSubject());\n                }\n            }\n            try {\n                logger.debug(\"Retarding the distribution for \" + WAIT_PERIOD_MILLI * iterationNum + \" milliseconds\");\n                Thread.sleep(WAIT_PERIOD_MILLI * iterationNum);\n            } catch (InterruptedException e) {\n                throw new SteppingSystemException(\"Distribution timeout failed\");\n            }\n            distribute(busy, ++iterationNum);\n        }\n    }","cleancode":"private void distribute(distribution[] distributionlist, int iterationnum) { distribution[] busy = null; for (int inc = 0; inc < distributionlist.length; inc++) { if (distributionlist[inc] == null) continue; if (!distributionlist[inc].getistepdecorator().offerqueuesubjectupdate(distributionlist[inc].getdata(), distributionlist[inc].getsubject())) { if (busy == null) { busy = new distribution[distributionlist.length]; } busy[inc] = distributionlist[inc]; logger.debug(\"distribution not succeeded. moving to deceleration mode for subject: \" + busy[inc].getsubject() + \". iteration number - \" + iterationnum + \"\/\" + maximum_offers_retries); } } if (!isempty(busy)) { if (iterationnum >= maximum_offers_retries) { logger.debug(\"deceleration mode failed after \" + iterationnum + \"\/\" + maximum_offers_retries + \" retries. moving back to normal distribution\"); for (distribution dist : distributionlist) { if (dist == null) continue; dist.getistepdecorator().queuesubjectupdate(dist.getdata(), dist.getsubject()); } } try { logger.debug(\"retarding the distribution for \" + wait_period_milli * iterationnum + \" milliseconds\"); thread.sleep(wait_period_milli * iterationnum); } catch (interruptedexception e) { throw new steppingsystemexception(\"distribution timeout failed\"); } distribute(busy, ++iterationnum); } }","repo":"gabibeyo\/stepping","label":[1,0,0,0]}
{"id":13058,"original_code":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CheckChainMap)) return false;\n        if (!super.equals(o)) return false;\n        CheckChainMap<?, ?> that = (CheckChainMap<?, ?>) o;\n        \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n        return Arrays.equals(table, that.table);\n    }","code_wo_comment":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof CheckChainMap)) return false;\n        if (!super.equals(o)) return false;\n        CheckChainMap<?, ?> that = (CheckChainMap<?, ?>) o;\n       \n        return Arrays.equals(table, that.table);\n    }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (!(o instanceof checkchainmap)) return false; if (!super.equals(o)) return false; checkchainmap<?, ?> that = (checkchainmap<?, ?>) o; return arrays.equals(table, that.table); }","repo":"finefuture\/gazelle","label":[1,0,0,0]}
{"id":13286,"original_code":"private boolean isEmailValid(String email) {\n        \/\/TODO: Replace this with your own logic\n        return email.contains(\"@\");\n    }","code_wo_comment":"private boolean isEmailValid(String email) {\n       \n        return email.contains(\"@\");\n    }","cleancode":"private boolean isemailvalid(string email) { return email.contains(\"@\"); }","repo":"eZubia\/scrum-team","label":[1,0,0,0]}
{"id":13333,"original_code":"public int find(V target, InclusionMode mode) {\n    \treturn find(target, mode, MatchRequirement.EXACT_ONLY);\n    }","code_wo_comment":"public int find(V target, InclusionMode mode) {\n    \treturn find(target, mode, MatchRequirement.EXACT_ONLY);\n    }","cleancode":"public int find(v target, inclusionmode mode) { return find(target, mode, matchrequirement.exact_only); }","repo":"devjn\/fesimplegeoprox-android-maps","label":[1,0,0,0]}
{"id":13381,"original_code":"public void close(boolean removeSocket, boolean stopKeepAliveTask) {  \n        isRunning = false;\n    \t\/\/ we need to close everything because the socket may be closed by the other end\n    \t\/\/ like in LB scenarios sending OPTIONS and killing the socket after it gets the response    \t\n        if (mySock != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing socket \" + key);\n        \ttry {\n\t            mySock.close();\n\t            mySock = null;\n        \t} catch (IOException ex) {\n                if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                    logger.logDebug(\"Error closing socket \" + ex);\n            }\n        }        \n        if(myParser != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing my parser \" + myParser);\n            myParser.close();            \n        }  \n        \/\/ no need to close myClientInputStream since myParser.close() above will do it\n        if(myClientOutputStream != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing client output stream \" + myClientOutputStream);\n        \ttry {\n        \t\tmyClientOutputStream.close();\n        \t} catch (IOException ex) {\n                if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                    logger.logDebug(\"Error closing client output stream\" + ex);\n            }\n        }   \n        if(removeSocket) {                  \n\t        \/\/ remove the \"tcp:\" part of the key to cleanup the ioHandler hashmap\n\t        String ioHandlerKey = key.substring(4);\n\t        if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n\t            logger.logDebug(\"Closing TCP socket \" + ioHandlerKey);\n\t        \/\/ Issue 358 : remove socket and semaphore on close to avoid leaking\n\t        sipStack.ioHandler.removeSocket(ioHandlerKey);\n\t        if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG)) {\n                logger.logDebug(\"Closing message Channel (key = \" + key +\")\" + this);\n            }\n        } else {\n            if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG)) {\n                String ioHandlerKey = key.substring(4);\n                logger.logDebug(\"not removing socket key from the cached map since it has already been updated by the iohandler.sendBytes \" + ioHandlerKey);\n            }\n        }\n        if(stopKeepAliveTask) {\n\t\t\tcancelPingKeepAliveTimeoutTaskIfStarted();\n\t\t}\n    }","code_wo_comment":"public void close(boolean removeSocket, boolean stopKeepAliveTask) {  \n        isRunning = false;\n    \n    \n        if (mySock != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing socket \" + key);\n        \ttry {\n\t            mySock.close();\n\t            mySock = null;\n        \t} catch (IOException ex) {\n                if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                    logger.logDebug(\"Error closing socket \" + ex);\n            }\n        }        \n        if(myParser != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing my parser \" + myParser);\n            myParser.close();            \n        }  \n       \n        if(myClientOutputStream != null) {\n        \tif (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                logger.logDebug(\"Closing client output stream \" + myClientOutputStream);\n        \ttry {\n        \t\tmyClientOutputStream.close();\n        \t} catch (IOException ex) {\n                if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n                    logger.logDebug(\"Error closing client output stream\" + ex);\n            }\n        }   \n        if(removeSocket) {                  \n\t       \n\t        String ioHandlerKey = key.substring(4);\n\t        if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG))\n\t            logger.logDebug(\"Closing TCP socket \" + ioHandlerKey);\n\t       \n\t        sipStack.ioHandler.removeSocket(ioHandlerKey);\n\t        if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG)) {\n                logger.logDebug(\"Closing message Channel (key = \" + key +\")\" + this);\n            }\n        } else {\n            if (logger.isLoggingEnabled(LogWriter.TRACE_DEBUG)) {\n                String ioHandlerKey = key.substring(4);\n                logger.logDebug(\"not removing socket key from the cached map since it has already been updated by the iohandler.sendBytes \" + ioHandlerKey);\n            }\n        }\n        if(stopKeepAliveTask) {\n\t\t\tcancelPingKeepAliveTimeoutTaskIfStarted();\n\t\t}\n    }","cleancode":"public void close(boolean removesocket, boolean stopkeepalivetask) { isrunning = false; if (mysock != null) { if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"closing socket \" + key); try { mysock.close(); mysock = null; } catch (ioexception ex) { if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"error closing socket \" + ex); } } if(myparser != null) { if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"closing my parser \" + myparser); myparser.close(); } if(myclientoutputstream != null) { if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"closing client output stream \" + myclientoutputstream); try { myclientoutputstream.close(); } catch (ioexception ex) { if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"error closing client output stream\" + ex); } } if(removesocket) { string iohandlerkey = key.substring(4); if (logger.isloggingenabled(logwriter.trace_debug)) logger.logdebug(\"closing tcp socket \" + iohandlerkey); sipstack.iohandler.removesocket(iohandlerkey); if (logger.isloggingenabled(logwriter.trace_debug)) { logger.logdebug(\"closing message channel (key = \" + key +\")\" + this); } } else { if (logger.isloggingenabled(logwriter.trace_debug)) { string iohandlerkey = key.substring(4); logger.logdebug(\"not removing socket key from the cached map since it has already been updated by the iohandler.sendbytes \" + iohandlerkey); } } if(stopkeepalivetask) { cancelpingkeepalivetimeouttaskifstarted(); } }","repo":"fhg-fokus-nubomedia\/signaling-plane","label":[0,0,0,0]}
{"id":21575,"original_code":"private String getTypeString(int type, int length)\n    {\n        if (type == DataType.INT.getType()) {\n            return \"int\";\n        }\n        if (type == DataType.FLOAT.getType()) {\n            return \"float\";\n        }\n        if (type == DataType.DOUBLE.getType()) {\n            return \"double\";\n        }\n        if (type == DataType.DATE.getType()) {\n            return \"date\";\n        }\n        if (type == DataType.CHAR.getType()) {\n            return \"char(\" + length + \")\";\n        }\n        if (type == DataType.VARCHAR.getType()) {\n            return \"varchar(\" + length + \")\";\n        }\n        \/\/ todo add more types\n        return null;\n    }","code_wo_comment":"private String getTypeString(int type, int length)\n    {\n        if (type == DataType.INT.getType()) {\n            return \"int\";\n        }\n        if (type == DataType.FLOAT.getType()) {\n            return \"float\";\n        }\n        if (type == DataType.DOUBLE.getType()) {\n            return \"double\";\n        }\n        if (type == DataType.DATE.getType()) {\n            return \"date\";\n        }\n        if (type == DataType.CHAR.getType()) {\n            return \"char(\" + length + \")\";\n        }\n        if (type == DataType.VARCHAR.getType()) {\n            return \"varchar(\" + length + \")\";\n        }\n       \n        return null;\n    }","cleancode":"private string gettypestring(int type, int length) { if (type == datatype.int.gettype()) { return \"int\"; } if (type == datatype.float.gettype()) { return \"float\"; } if (type == datatype.double.gettype()) { return \"double\"; } if (type == datatype.date.gettype()) { return \"date\"; } if (type == datatype.char.gettype()) { return \"char(\" + length + \")\"; } if (type == datatype.varchar.gettype()) { return \"varchar(\" + length + \")\"; } return null; }","repo":"dbiir\/pard","label":[0,1,0,0]}
{"id":13395,"original_code":"public static int getPreOpsOutputSize(Component component, Schema schema,\n\t    TableAliasName tan) {\n\tif (component instanceof ThetaJoinComponent)\n\t    throw new RuntimeException(\n\t\t    \"SQL generator with Theta does not work for now!\");\n\t\/\/ TODO similar to Equijoin, but not subtracting joinColumnsLength\n\tfinal Component[] parents = component.getParents();\n\tif (parents == null)\n\t    \/\/ this is a DataSourceComponent\n\t    return getPreOpsOutputSize((DataSourceComponent) component, schema,\n\t\t    tan);\n\telse if (parents.length == 1)\n\t    return getPreOpsOutputSize(parents[0], schema, tan);\n\telse if (parents.length == 2) {\n\t    final Component firstParent = parents[0];\n\t    final Component secondParent = parents[1];\n\t    final int joinColumnsLength = firstParent.getHashIndexes().size();\n\t    return getPreOpsOutputSize(firstParent, schema, tan)\n\t\t    + getPreOpsOutputSize(secondParent, schema, tan)\n\t\t    - joinColumnsLength;\n\t}\n\tthrow new RuntimeException(\"More than two parents for a component \"\n\t\t+ component);\n    }","code_wo_comment":"public static int getPreOpsOutputSize(Component component, Schema schema,\n\t    TableAliasName tan) {\n\tif (component instanceof ThetaJoinComponent)\n\t    throw new RuntimeException(\n\t\t    \"SQL generator with Theta does not work for now!\");\n\n\tfinal Component[] parents = component.getParents();\n\tif (parents == null)\n\t   \n\t    return getPreOpsOutputSize((DataSourceComponent) component, schema,\n\t\t    tan);\n\telse if (parents.length == 1)\n\t    return getPreOpsOutputSize(parents[0], schema, tan);\n\telse if (parents.length == 2) {\n\t    final Component firstParent = parents[0];\n\t    final Component secondParent = parents[1];\n\t    final int joinColumnsLength = firstParent.getHashIndexes().size();\n\t    return getPreOpsOutputSize(firstParent, schema, tan)\n\t\t    + getPreOpsOutputSize(secondParent, schema, tan)\n\t\t    - joinColumnsLength;\n\t}\n\tthrow new RuntimeException(\"More than two parents for a component \"\n\t\t+ component);\n    }","cleancode":"public static int getpreopsoutputsize(component component, schema schema, tablealiasname tan) { if (component instanceof thetajoincomponent) throw new runtimeexception( \"sql generator with theta does not work for now!\"); final component[] parents = component.getparents(); if (parents == null) return getpreopsoutputsize((datasourcecomponent) component, schema, tan); else if (parents.length == 1) return getpreopsoutputsize(parents[0], schema, tan); else if (parents.length == 2) { final component firstparent = parents[0]; final component secondparent = parents[1]; final int joincolumnslength = firstparent.gethashindexes().size(); return getpreopsoutputsize(firstparent, schema, tan) + getpreopsoutputsize(secondparent, schema, tan) - joincolumnslength; } throw new runtimeexception(\"more than two parents for a component \" + component); }","repo":"epfldata\/squall","label":[1,0,0,0]}
{"id":21617,"original_code":"@Test\n    @Parameters({ \"clusterName\", \"ambariUser\", \"ambariPassword\", \"emailNeeded\",\n            \"enableSecurity\", \"kerberosMasterKey\", \"kerberosAdmin\", \"kerberosPassword\",\n            \"runRecipesOnHosts\" })\n    public void testClusterCreation(@Optional(\"it-cluster\") String clusterName, @Optional(\"admin\") String ambariUser,\n            @Optional(\"admin123!@#\") String ambariPassword, @Optional(\"false\") boolean emailNeeded,\n            @Optional(\"false\") boolean enableSecurity, @Optional String kerberosMasterKey, @Optional String kerberosAdmin, @Optional String kerberosPassword,\n            @Optional(\"\") String runRecipesOnHosts) throws Exception {\n        \/\/ GIVEN\n        IntegrationTestContext itContext = getItContext();\n        String stackIdStr = itContext.getContextParam(CloudbreakITContextConstants.STACK_ID);\n        Integer stackId = Integer.valueOf(stackIdStr);\n        Integer blueprintId = Integer.valueOf(itContext.getContextParam(CloudbreakITContextConstants.BLUEPRINT_ID));\n        List<HostGroup> hostgroups = itContext.getContextParam(CloudbreakITContextConstants.HOSTGROUP_ID, List.class);\n        List<Map<String, Object>> map = convertHostGroups(hostgroups, runRecipesOnHosts);\n        itContext.putContextParam(CloudbreakITContextConstants.AMBARI_USER_ID, ambariUser);\n        itContext.putContextParam(CloudbreakITContextConstants.AMBARI_PASSWORD_ID, ambariPassword);\n        \/\/ WHEN\n        \/\/ TODO email needed\n        CloudbreakClient client = getClient();\n        client.postCluster(clusterName, ambariUser, ambariPassword, blueprintId, \"Cluster for integration test\", Integer.valueOf(stackId), map,\n                enableSecurity, kerberosMasterKey, kerberosAdmin, kerberosPassword);\n        \/\/ THEN\n        CloudbreakUtil.waitAndCheckStackStatus(itContext, stackIdStr, \"AVAILABLE\");\n        CloudbreakUtil.checkClusterAvailability(client, stackIdStr, ambariUser, ambariPassword);\n    }","code_wo_comment":"@Test\n    @Parameters({ \"clusterName\", \"ambariUser\", \"ambariPassword\", \"emailNeeded\",\n            \"enableSecurity\", \"kerberosMasterKey\", \"kerberosAdmin\", \"kerberosPassword\",\n            \"runRecipesOnHosts\" })\n    public void testClusterCreation(@Optional(\"it-cluster\") String clusterName, @Optional(\"admin\") String ambariUser,\n            @Optional(\"admin123!@#\") String ambariPassword, @Optional(\"false\") boolean emailNeeded,\n            @Optional(\"false\") boolean enableSecurity, @Optional String kerberosMasterKey, @Optional String kerberosAdmin, @Optional String kerberosPassword,\n            @Optional(\"\") String runRecipesOnHosts) throws Exception {\n       \n        IntegrationTestContext itContext = getItContext();\n        String stackIdStr = itContext.getContextParam(CloudbreakITContextConstants.STACK_ID);\n        Integer stackId = Integer.valueOf(stackIdStr);\n        Integer blueprintId = Integer.valueOf(itContext.getContextParam(CloudbreakITContextConstants.BLUEPRINT_ID));\n        List<HostGroup> hostgroups = itContext.getContextParam(CloudbreakITContextConstants.HOSTGROUP_ID, List.class);\n        List<Map<String, Object>> map = convertHostGroups(hostgroups, runRecipesOnHosts);\n        itContext.putContextParam(CloudbreakITContextConstants.AMBARI_USER_ID, ambariUser);\n        itContext.putContextParam(CloudbreakITContextConstants.AMBARI_PASSWORD_ID, ambariPassword);\n       \n       \n        CloudbreakClient client = getClient();\n        client.postCluster(clusterName, ambariUser, ambariPassword, blueprintId, \"Cluster for integration test\", Integer.valueOf(stackId), map,\n                enableSecurity, kerberosMasterKey, kerberosAdmin, kerberosPassword);\n       \n        CloudbreakUtil.waitAndCheckStackStatus(itContext, stackIdStr, \"AVAILABLE\");\n        CloudbreakUtil.checkClusterAvailability(client, stackIdStr, ambariUser, ambariPassword);\n    }","cleancode":"@test @parameters({ \"clustername\", \"ambariuser\", \"ambaripassword\", \"emailneeded\", \"enablesecurity\", \"kerberosmasterkey\", \"kerberosadmin\", \"kerberospassword\", \"runrecipesonhosts\" }) public void testclustercreation(@optional(\"it-cluster\") string clustername, @optional(\"admin\") string ambariuser, @optional(\"admin123!@#\") string ambaripassword, @optional(\"false\") boolean emailneeded, @optional(\"false\") boolean enablesecurity, @optional string kerberosmasterkey, @optional string kerberosadmin, @optional string kerberospassword, @optional(\"\") string runrecipesonhosts) throws exception { integrationtestcontext itcontext = getitcontext(); string stackidstr = itcontext.getcontextparam(cloudbreakitcontextconstants.stack_id); integer stackid = integer.valueof(stackidstr); integer blueprintid = integer.valueof(itcontext.getcontextparam(cloudbreakitcontextconstants.blueprint_id)); list<hostgroup> hostgroups = itcontext.getcontextparam(cloudbreakitcontextconstants.hostgroup_id, list.class); list<map<string, object>> map = converthostgroups(hostgroups, runrecipesonhosts); itcontext.putcontextparam(cloudbreakitcontextconstants.ambari_user_id, ambariuser); itcontext.putcontextparam(cloudbreakitcontextconstants.ambari_password_id, ambaripassword); cloudbreakclient client = getclient(); client.postcluster(clustername, ambariuser, ambaripassword, blueprintid, \"cluster for integration test\", integer.valueof(stackid), map, enablesecurity, kerberosmasterkey, kerberosadmin, kerberospassword); cloudbreakutil.waitandcheckstackstatus(itcontext, stackidstr, \"available\"); cloudbreakutil.checkclusteravailability(client, stackidstr, ambariuser, ambaripassword); }","repo":"doktoric\/test123","label":[1,0,0,0]}
{"id":13832,"original_code":"private void reloadItemsList() {\n        documentPartsDataSource.ensureConnectionIsOpen();\n        List<DocumentCollectionItem> documentCollectionItems = new ArrayList<>();\n        Log.d(\"DocCollectionActivity\", \"Checking filetypes to add\");\n        for (FileType fileType : SectionsProvider.getFileTypesForSectionModel(sectionModel)) {\n            Log.d(\"DocCollectionActivity\", \"Checking filetype: \" + fileType);\n            \/\/ TODO: use some sort of map instead\n            boolean isPresent = false;\n            for (DocumentPart documentPart : documentPartsDataSource.getDocumentPartsForSection(sectionModel)) {\n                if (documentPart.getType().equals(fileType)) {\n                    DocumentCollectionItem docData = new DocumentCollectionItem(getString(fileType.getNameResourceId()), getString(R.string.document_collection_list_item_present_title), fileType, true);\n                    documentCollectionItems.add(docData);\n                    isPresent = true;\n                    break;\n                }\n            }\n            if (!isPresent) {\n                Log.d(\"DocCollectionActivity\", \"File type not found in documentparts, add as TO-DO\");\n                DocumentCollectionItem docData = new DocumentCollectionItem(getString(fileType.getNameResourceId()), getString(R.string.document_collection_list_item_not_present_title), fileType, false);\n                documentCollectionItems.add(docData);\n            }\n        }\n        listView = (ListView) findViewById(R.id.documentlist);\n        DocumentCollectionViewAdapter listViewAdapter = new DocumentCollectionViewAdapter(this, R.layout.fragment_document, documentCollectionItems);\n        listView.setAdapter(listViewAdapter);\n    }","code_wo_comment":"private void reloadItemsList() {\n        documentPartsDataSource.ensureConnectionIsOpen();\n        List<DocumentCollectionItem> documentCollectionItems = new ArrayList<>();\n        Log.d(\"DocCollectionActivity\", \"Checking filetypes to add\");\n        for (FileType fileType : SectionsProvider.getFileTypesForSectionModel(sectionModel)) {\n            Log.d(\"DocCollectionActivity\", \"Checking filetype: \" + fileType);\n           \n            boolean isPresent = false;\n            for (DocumentPart documentPart : documentPartsDataSource.getDocumentPartsForSection(sectionModel)) {\n                if (documentPart.getType().equals(fileType)) {\n                    DocumentCollectionItem docData = new DocumentCollectionItem(getString(fileType.getNameResourceId()), getString(R.string.document_collection_list_item_present_title), fileType, true);\n                    documentCollectionItems.add(docData);\n                    isPresent = true;\n                    break;\n                }\n            }\n            if (!isPresent) {\n                Log.d(\"DocCollectionActivity\", \"File type not found in documentparts, add as TO-DO\");\n                DocumentCollectionItem docData = new DocumentCollectionItem(getString(fileType.getNameResourceId()), getString(R.string.document_collection_list_item_not_present_title), fileType, false);\n                documentCollectionItems.add(docData);\n            }\n        }\n        listView = (ListView) findViewById(R.id.documentlist);\n        DocumentCollectionViewAdapter listViewAdapter = new DocumentCollectionViewAdapter(this, R.layout.fragment_document, documentCollectionItems);\n        listView.setAdapter(listViewAdapter);\n    }","cleancode":"private void reloaditemslist() { documentpartsdatasource.ensureconnectionisopen(); list<documentcollectionitem> documentcollectionitems = new arraylist<>(); log.d(\"doccollectionactivity\", \"checking filetypes to add\"); for (filetype filetype : sectionsprovider.getfiletypesforsectionmodel(sectionmodel)) { log.d(\"doccollectionactivity\", \"checking filetype: \" + filetype); boolean ispresent = false; for (documentpart documentpart : documentpartsdatasource.getdocumentpartsforsection(sectionmodel)) { if (documentpart.gettype().equals(filetype)) { documentcollectionitem docdata = new documentcollectionitem(getstring(filetype.getnameresourceid()), getstring(r.string.document_collection_list_item_present_title), filetype, true); documentcollectionitems.add(docdata); ispresent = true; break; } } if (!ispresent) { log.d(\"doccollectionactivity\", \"file type not found in documentparts, add as to-do\"); documentcollectionitem docdata = new documentcollectionitem(getstring(filetype.getnameresourceid()), getstring(r.string.document_collection_list_item_not_present_title), filetype, false); documentcollectionitems.add(docdata); } } listview = (listview) findviewbyid(r.id.documentlist); documentcollectionviewadapter listviewadapter = new documentcollectionviewadapter(this, r.layout.fragment_document, documentcollectionitems); listview.setadapter(listviewadapter); }","repo":"devolksbank\/NL-Help-U","label":[1,0,0,0]}
{"id":22238,"original_code":"public static String replaceLeadingSpacesWithNbsps (String str)\n    {\n        \/\/ todo: support for tabs?\n        Matcher m = _LeadingSpacesPattern.matcher(str);\n        StringBuffer buf = new StringBuffer();\n        while (m.find()) {\n            int spaceCount = m.group(1).length();\n            m.appendReplacement(buf, AWUtil.repeatedString(\"&nbsp;\", spaceCount));\n        }\n        m.appendTail(buf);\n        return buf.toString();\n    }","code_wo_comment":"public static String replaceLeadingSpacesWithNbsps (String str)\n    {\n       \n        Matcher m = _LeadingSpacesPattern.matcher(str);\n        StringBuffer buf = new StringBuffer();\n        while (m.find()) {\n            int spaceCount = m.group(1).length();\n            m.appendReplacement(buf, AWUtil.repeatedString(\"&nbsp;\", spaceCount));\n        }\n        m.appendTail(buf);\n        return buf.toString();\n    }","cleancode":"public static string replaceleadingspaceswithnbsps (string str) { matcher m = _leadingspacespattern.matcher(str); stringbuffer buf = new stringbuffer(); while (m.find()) { int spacecount = m.group(1).length(); m.appendreplacement(buf, awutil.repeatedstring(\"&nbsp;\", spacecount)); } m.appendtail(buf); return buf.tostring(); }","repo":"fbarthez\/aribaweb","label":[0,1,0,0]}
{"id":14274,"original_code":"IbisSocket connect(TcpSendPort sp, ibis.ipl.impl.ReceivePortIdentifier rip,\n            int timeout, boolean fillTimeout) throws IOException {\n        IbisIdentifier id = (IbisIdentifier) rip.ibisIdentifier();\n        String name = rip.name();\n        IbisSocketAddress idAddr;\n        synchronized (addresses) {\n            idAddr = addresses.get(id);\n            if (idAddr == null) {\n                idAddr = new IbisSocketAddress(id.getImplementationData());\n                addresses.put(id, idAddr);\n            }\n        }\n        long startTime = System.currentTimeMillis();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"--> Creating socket for connection to \" + name\n                    + \" at \" + idAddr);\n        }\n        PortType sendPortType = sp.getPortType();\n        do {\n            DataOutputStream out = null;\n            IbisSocket s = null;\n            int result = -1;\n            sp.printManagementProperties(System.out);\n            try {\n                s = factory.createClientSocket(idAddr, timeout, fillTimeout,\n                        sp.managementProperties());\n                s.setTcpNoDelay(true);\n                out = new DataOutputStream(new BufferedArrayOutputStream(\n                        s.getOutputStream()));\n                out.writeUTF(name);\n                sp.getIdent().writeTo(out);\n                sendPortType.writeTo(out);\n                out.flush();\n                result = s.getInputStream().read();\n                switch (result) {\n                case ReceivePort.ACCEPTED:\n                    return s;\n                case ReceivePort.ALREADY_CONNECTED:\n                    throw new AlreadyConnectedException(\"Already connected\",\n                            rip);\n                case ReceivePort.TYPE_MISMATCH:\n                    \/\/ Read receiveport type from input, to produce a\n                    \/\/ better error message.\n                    DataInputStream in = new DataInputStream(s.getInputStream());\n                    PortType rtp = new PortType(in);\n                    CapabilitySet s1 = rtp.unmatchedCapabilities(sendPortType);\n                    CapabilitySet s2 = sendPortType.unmatchedCapabilities(rtp);\n                    String message = \"\";\n                    if (s1.size() != 0) {\n                        message = message\n                                + \"\\nUnmatched receiveport capabilities: \"\n                                + s1.toString() + \".\";\n                    }\n                    if (s2.size() != 0) {\n                        message = message\n                                + \"\\nUnmatched sendport capabilities: \"\n                                + s2.toString() + \".\";\n                    }\n                    throw new PortMismatchException(\n                            \"Cannot connect ports of different port types.\"\n                                    + message, rip);\n                case ReceivePort.DENIED:\n                    throw new ConnectionRefusedException(\n                            \"Receiver denied connection\", rip);\n                case ReceivePort.NO_MANY_TO_X:\n                    throw new ConnectionRefusedException(\n                            \"Receiver already has a connection and neither ManyToOne not ManyToMany \"\n                                    + \"is set\", rip);\n                case ReceivePort.NOT_PRESENT:\n                case ReceivePort.DISABLED:\n                    \/\/ and try again if we did not reach the timeout...\n                    if (timeout > 0\n                            && System.currentTimeMillis() > startTime + timeout) {\n                        throw new ConnectionTimedOutException(\n                                \"Could not connect\", rip);\n                    }\n                    break;\n                case -1:\n                    throw new IOException(\"Encountered EOF in TcpIbis.connect\");\n                default:\n                    throw new IOException(\"Illegal opcode in TcpIbis.connect\");\n                }\n            } catch (SocketTimeoutException e) {\n                throw new ConnectionTimedOutException(\"Could not connect\", rip);\n            } finally {\n                if (result != ReceivePort.ACCEPTED) {\n                    try {\n                        if (out != null) {\n                            out.close();\n                        }\n                    } catch (Throwable e) {\n                        \/\/ ignored\n                    }\n                    try {\n                        s.close();\n                    } catch (Throwable e) {\n                        \/\/ ignored\n                    }\n                }\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                \/\/ ignore\n            }\n        } while (true);\n    }","code_wo_comment":"IbisSocket connect(TcpSendPort sp, ibis.ipl.impl.ReceivePortIdentifier rip,\n            int timeout, boolean fillTimeout) throws IOException {\n        IbisIdentifier id = (IbisIdentifier) rip.ibisIdentifier();\n        String name = rip.name();\n        IbisSocketAddress idAddr;\n        synchronized (addresses) {\n            idAddr = addresses.get(id);\n            if (idAddr == null) {\n                idAddr = new IbisSocketAddress(id.getImplementationData());\n                addresses.put(id, idAddr);\n            }\n        }\n        long startTime = System.currentTimeMillis();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"--> Creating socket for connection to \" + name\n                    + \" at \" + idAddr);\n        }\n        PortType sendPortType = sp.getPortType();\n        do {\n            DataOutputStream out = null;\n            IbisSocket s = null;\n            int result = -1;\n            sp.printManagementProperties(System.out);\n            try {\n                s = factory.createClientSocket(idAddr, timeout, fillTimeout,\n                        sp.managementProperties());\n                s.setTcpNoDelay(true);\n                out = new DataOutputStream(new BufferedArrayOutputStream(\n                        s.getOutputStream()));\n                out.writeUTF(name);\n                sp.getIdent().writeTo(out);\n                sendPortType.writeTo(out);\n                out.flush();\n                result = s.getInputStream().read();\n                switch (result) {\n                case ReceivePort.ACCEPTED:\n                    return s;\n                case ReceivePort.ALREADY_CONNECTED:\n                    throw new AlreadyConnectedException(\"Already connected\",\n                            rip);\n                case ReceivePort.TYPE_MISMATCH:\n                   \n                   \n                    DataInputStream in = new DataInputStream(s.getInputStream());\n                    PortType rtp = new PortType(in);\n                    CapabilitySet s1 = rtp.unmatchedCapabilities(sendPortType);\n                    CapabilitySet s2 = sendPortType.unmatchedCapabilities(rtp);\n                    String message = \"\";\n                    if (s1.size() != 0) {\n                        message = message\n                                + \"\\nUnmatched receiveport capabilities: \"\n                                + s1.toString() + \".\";\n                    }\n                    if (s2.size() != 0) {\n                        message = message\n                                + \"\\nUnmatched sendport capabilities: \"\n                                + s2.toString() + \".\";\n                    }\n                    throw new PortMismatchException(\n                            \"Cannot connect ports of different port types.\"\n                                    + message, rip);\n                case ReceivePort.DENIED:\n                    throw new ConnectionRefusedException(\n                            \"Receiver denied connection\", rip);\n                case ReceivePort.NO_MANY_TO_X:\n                    throw new ConnectionRefusedException(\n                            \"Receiver already has a connection and neither ManyToOne not ManyToMany \"\n                                    + \"is set\", rip);\n                case ReceivePort.NOT_PRESENT:\n                case ReceivePort.DISABLED:\n                   \n                    if (timeout > 0\n                            && System.currentTimeMillis() > startTime + timeout) {\n                        throw new ConnectionTimedOutException(\n                                \"Could not connect\", rip);\n                    }\n                    break;\n                case -1:\n                    throw new IOException(\"Encountered EOF in TcpIbis.connect\");\n                default:\n                    throw new IOException(\"Illegal opcode in TcpIbis.connect\");\n                }\n            } catch (SocketTimeoutException e) {\n                throw new ConnectionTimedOutException(\"Could not connect\", rip);\n            } finally {\n                if (result != ReceivePort.ACCEPTED) {\n                    try {\n                        if (out != null) {\n                            out.close();\n                        }\n                    } catch (Throwable e) {\n                       \n                    }\n                    try {\n                        s.close();\n                    } catch (Throwable e) {\n                       \n                    }\n                }\n            }\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n               \n            }\n        } while (true);\n    }","cleancode":"ibissocket connect(tcpsendport sp, ibis.ipl.impl.receiveportidentifier rip, int timeout, boolean filltimeout) throws ioexception { ibisidentifier id = (ibisidentifier) rip.ibisidentifier(); string name = rip.name(); ibissocketaddress idaddr; synchronized (addresses) { idaddr = addresses.get(id); if (idaddr == null) { idaddr = new ibissocketaddress(id.getimplementationdata()); addresses.put(id, idaddr); } } long starttime = system.currenttimemillis(); if (logger.isdebugenabled()) { logger.debug(\"--> creating socket for connection to \" + name + \" at \" + idaddr); } porttype sendporttype = sp.getporttype(); do { dataoutputstream out = null; ibissocket s = null; int result = -1; sp.printmanagementproperties(system.out); try { s = factory.createclientsocket(idaddr, timeout, filltimeout, sp.managementproperties()); s.settcpnodelay(true); out = new dataoutputstream(new bufferedarrayoutputstream( s.getoutputstream())); out.writeutf(name); sp.getident().writeto(out); sendporttype.writeto(out); out.flush(); result = s.getinputstream().read(); switch (result) { case receiveport.accepted: return s; case receiveport.already_connected: throw new alreadyconnectedexception(\"already connected\", rip); case receiveport.type_mismatch: datainputstream in = new datainputstream(s.getinputstream()); porttype rtp = new porttype(in); capabilityset s1 = rtp.unmatchedcapabilities(sendporttype); capabilityset s2 = sendporttype.unmatchedcapabilities(rtp); string message = \"\"; if (s1.size() != 0) { message = message + \"\\nunmatched receiveport capabilities: \" + s1.tostring() + \".\"; } if (s2.size() != 0) { message = message + \"\\nunmatched sendport capabilities: \" + s2.tostring() + \".\"; } throw new portmismatchexception( \"cannot connect ports of different port types.\" + message, rip); case receiveport.denied: throw new connectionrefusedexception( \"receiver denied connection\", rip); case receiveport.no_many_to_x: throw new connectionrefusedexception( \"receiver already has a connection and neither manytoone not manytomany \" + \"is set\", rip); case receiveport.not_present: case receiveport.disabled: if (timeout > 0 && system.currenttimemillis() > starttime + timeout) { throw new connectiontimedoutexception( \"could not connect\", rip); } break; case -1: throw new ioexception(\"encountered eof in tcpibis.connect\"); default: throw new ioexception(\"illegal opcode in tcpibis.connect\"); } } catch (sockettimeoutexception e) { throw new connectiontimedoutexception(\"could not connect\", rip); } finally { if (result != receiveport.accepted) { try { if (out != null) { out.close(); } } catch (throwable e) { } try { s.close(); } catch (throwable e) { } } } try { thread.sleep(100); } catch (interruptedexception e) { } } while (true); }","repo":"dadepo\/ipl","label":[0,0,1,0]}
{"id":22476,"original_code":"@AllowedMethod\n\t@Transactional(TransactionType.WRITE)\n\tpublic String update()\n\t{\n\t\tlog.debug(\"---------------- update()\");\n\t\tsaveOrUpdate();\n\t\t\/\/ TODO: i18n: Externalize.\n\t\t\/\/ TODO: Enhance: Print link to updated shop.\n\t\taddActionMessage(\"Shop <strong>\" + escape(shop.getName()) + \"<\/strong> updated successfully.\");\n\t\treturn RESULT_REDIRECT_VIEW;\n\t}","code_wo_comment":"@AllowedMethod\n\t@Transactional(TransactionType.WRITE)\n\tpublic String update()\n\t{\n\t\tlog.debug(\"---------------- update()\");\n\t\tsaveOrUpdate();\n\t\n\t\n\t\taddActionMessage(\"Shop <strong>\" + escape(shop.getName()) + \"<\/strong> updated successfully.\");\n\t\treturn RESULT_REDIRECT_VIEW;\n\t}","cleancode":"@allowedmethod @transactional(transactiontype.write) public string update() { log.debug(\"---------------- update()\"); saveorupdate(); addactionmessage(\"shop <strong>\" + escape(shop.getname()) + \"<\/strong> updated successfully.\"); return result_redirect_view; }","repo":"doanhoa93\/struts2shop","label":[0,1,0,0]}
{"id":30694,"original_code":"public static void learnAndSaveAllModels(){\n        \/\/ Seleccionamos el directorio en el que se van a recoger todos los\n        String input_path = \"data\/automatic_learn\/\";\n        File[] inputFiles = new File(input_path).listFiles(x -> x.getName().endsWith(\".arff\"));\n        String output_path = \"results\/automatic_learn\/LCM\/\";\n        for (File inputFile : inputFiles) {\n            try {\n                if (inputFile.isFile()) {\n                    \/\/Create the DiscreteDataSet\n                    DiscreteDataSet data = new DiscreteDataSet(DataFileLoader.loadData(input_path + inputFile.getName(), DiscreteVariable.class));\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"############## \"+ data.getName() + \" ############## \\n\");\n                    \/\/ Learn the LTM\n                    LTM ltm = learnBestLCMVaryingCardinality(data);\n                    \/\/ Save it in BIF format\n                    newBifWriter writer = new newBifWriter(new FileOutputStream(output_path + \"LCM_\" + FilenameUtils.removeExtension(inputFile.getName()) + \".bif\"), false);\n                    writer.write(ltm);\n                }\n            }catch(Exception e){\n                System.out.println(\"Error with \" + inputFile.getName());\n                e.printStackTrace();\n            }\n        }\n    }","code_wo_comment":"public static void learnAndSaveAllModels(){\n       \n        String input_path = \"data\/automatic_learn\/\";\n        File[] inputFiles = new File(input_path).listFiles(x -> x.getName().endsWith(\".arff\"));\n        String output_path = \"results\/automatic_learn\/LCM\/\";\n        for (File inputFile : inputFiles) {\n            try {\n                if (inputFile.isFile()) {\n                   \n                    DiscreteDataSet data = new DiscreteDataSet(DataFileLoader.loadData(input_path + inputFile.getName(), DiscreteVariable.class));\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"------------------------------------------------------------------------------\");\n                    System.out.println(\"############## \"+ data.getName() + \" ############## \\n\");\n                   \n                    LTM ltm = learnBestLCMVaryingCardinality(data);\n                   \n                    newBifWriter writer = new newBifWriter(new FileOutputStream(output_path + \"LCM_\" + FilenameUtils.removeExtension(inputFile.getName()) + \".bif\"), false);\n                    writer.write(ltm);\n                }\n            }catch(Exception e){\n                System.out.println(\"Error with \" + inputFile.getName());\n                e.printStackTrace();\n            }\n        }\n    }","cleancode":"public static void learnandsaveallmodels(){ string input_path = \"data\/automatic_learn\/\"; file[] inputfiles = new file(input_path).listfiles(x -> x.getname().endswith(\".arff\")); string output_path = \"results\/automatic_learn\/lcm\/\"; for (file inputfile : inputfiles) { try { if (inputfile.isfile()) { discretedataset data = new discretedataset(datafileloader.loaddata(input_path + inputfile.getname(), discretevariable.class)); system.out.println(\"------------------------------------------------------------------------------\"); system.out.println(\"------------------------------------------------------------------------------\"); system.out.println(\"------------------------------------------------------------------------------\"); system.out.println(\"############## \"+ data.getname() + \" ############## \\n\"); ltm ltm = learnbestlcmvaryingcardinality(data); newbifwriter writer = new newbifwriter(new fileoutputstream(output_path + \"lcm_\" + filenameutils.removeextension(inputfile.getname()) + \".bif\"), false); writer.write(ltm); } }catch(exception e){ system.out.println(\"error with \" + inputfile.getname()); e.printstacktrace(); } } }","repo":"fernandoj92\/mvca-parkinson","label":[1,0,0,0]}
{"id":22578,"original_code":"public void sendLevelFinish() {\n    TaskQueue.getTaskQueue()\n        .push(\n            new Task() {\n              public void execute() {\n                try {\n                  \/\/ for thread safety\n                  final Level level = World.getWorld().getLevel();\n                  PacketBuilder bldr =\n                      new PacketBuilder(\n                          PersistingPacketManager.getPacketManager().getOutgoingPacket(4));\n                  bldr.putShort(\"width\", level.getWidth());\n                  bldr.putShort(\"height\", level.getHeight());\n                  bldr.putShort(\"depth\", level.getDepth());\n                  session.send(bldr.toPacket());\n                  Position spawn = level.getSpawnPosition();\n                  Rotation r = level.getSpawnRotation();\n                  sendSpawn(\n                      (byte) -1,\n                      session.getPlayer().nameId,\n                      session.getPlayer().getColoredName(),\n                      session.getPlayer().getTeamName(),\n                      session.getPlayer().getName(),\n                      session.getPlayer().getListName(),\n                      session.getPlayer().getSkinUrl(),\n                      spawn.getX(),\n                      spawn.getY(),\n                      spawn.getZ(),\n                      (byte) r.getRotation(),\n                      (byte) r.getLook(),\n                      false,\n                      true);\n                  \/\/ now load the player's game (TODO in the future do this in parallel with loading\n                  \/\/ the\n                  \/\/ level)\n                  SavedGameManager.getSavedGameManager()\n                      .queuePersistenceRequest(new LoadPersistenceRequest(session.getPlayer()));\n                  session.setReady();\n                  World.getWorld().completeRegistration(session);\n                } catch (Exception ex) {\n                  Server.log(ex);\n                }\n              }\n            });\n  }","code_wo_comment":"public void sendLevelFinish() {\n    TaskQueue.getTaskQueue()\n        .push(\n            new Task() {\n              public void execute() {\n                try {\n                 \n                  final Level level = World.getWorld().getLevel();\n                  PacketBuilder bldr =\n                      new PacketBuilder(\n                          PersistingPacketManager.getPacketManager().getOutgoingPacket(4));\n                  bldr.putShort(\"width\", level.getWidth());\n                  bldr.putShort(\"height\", level.getHeight());\n                  bldr.putShort(\"depth\", level.getDepth());\n                  session.send(bldr.toPacket());\n                  Position spawn = level.getSpawnPosition();\n                  Rotation r = level.getSpawnRotation();\n                  sendSpawn(\n                      (byte) -1,\n                      session.getPlayer().nameId,\n                      session.getPlayer().getColoredName(),\n                      session.getPlayer().getTeamName(),\n                      session.getPlayer().getName(),\n                      session.getPlayer().getListName(),\n                      session.getPlayer().getSkinUrl(),\n                      spawn.getX(),\n                      spawn.getY(),\n                      spawn.getZ(),\n                      (byte) r.getRotation(),\n                      (byte) r.getLook(),\n                      false,\n                      true);\n                 \n                 \n                 \n                  SavedGameManager.getSavedGameManager()\n                      .queuePersistenceRequest(new LoadPersistenceRequest(session.getPlayer()));\n                  session.setReady();\n                  World.getWorld().completeRegistration(session);\n                } catch (Exception ex) {\n                  Server.log(ex);\n                }\n              }\n            });\n  }","cleancode":"public void sendlevelfinish() { taskqueue.gettaskqueue() .push( new task() { public void execute() { try { final level level = world.getworld().getlevel(); packetbuilder bldr = new packetbuilder( persistingpacketmanager.getpacketmanager().getoutgoingpacket(4)); bldr.putshort(\"width\", level.getwidth()); bldr.putshort(\"height\", level.getheight()); bldr.putshort(\"depth\", level.getdepth()); session.send(bldr.topacket()); position spawn = level.getspawnposition(); rotation r = level.getspawnrotation(); sendspawn( (byte) -1, session.getplayer().nameid, session.getplayer().getcoloredname(), session.getplayer().getteamname(), session.getplayer().getname(), session.getplayer().getlistname(), session.getplayer().getskinurl(), spawn.getx(), spawn.gety(), spawn.getz(), (byte) r.getrotation(), (byte) r.getlook(), false, true); savedgamemanager.getsavedgamemanager() .queuepersistencerequest(new loadpersistencerequest(session.getplayer())); session.setready(); world.getworld().completeregistration(session); } catch (exception ex) { server.log(ex); } } }); }","repo":"derekdinan\/CTFServer","label":[0,1,0,0]}
{"id":30787,"original_code":"private void onFrameLoad(JavaScriptObject cajaFrameObject)\n\t{\n\t\t\/\/--- This is to catch the theoretical case where we call start and stop then start really fast,\n\t\t\/\/--- but the load call from the first start didn't finish before the first stop, and comes in between\n\t\t\/\/--- the first stop and the second start...NOTE this is just done based on my thoughts on possible fringe\n\t\t\/\/--- cases, not because I actually noticed this behavior.\n\t\t\/\/this.stop();\n\t\t\/\/m_cajaFrameObjects.push(cajaFrameObject);\n\t}","code_wo_comment":"private void onFrameLoad(JavaScriptObject cajaFrameObject)\n\t{\n\t\n\t\n\t\n\t\n\t\n\t\n\t}","cleancode":"private void onframeload(javascriptobject cajaframeobject) { }","repo":"dougkoellmer\/swarm","label":[1,0,1,0]}
{"id":14459,"original_code":"public void assignNurseToRegister(Patient patient, Nurse nurse)\n    {\n        VaccinationRegister registerToAssingNurse = searchForVaccinationRegister(patient);\n        registerToAssingNurse.assignNurse(nurse);\n    }","code_wo_comment":"public void assignNurseToRegister(Patient patient, Nurse nurse)\n    {\n        VaccinationRegister registerToAssingNurse = searchForVaccinationRegister(patient);\n        registerToAssingNurse.assignNurse(nurse);\n    }","cleancode":"public void assignnursetoregister(patient patient, nurse nurse) { vaccinationregister registertoassingnurse = searchforvaccinationregister(patient); registertoassingnurse.assignnurse(nurse); }","repo":"deividgdt\/UNED_II","label":[0,0,0,0]}
{"id":22775,"original_code":"public List<PairIntArray> findEdges() {\n        \/\/ DFS search for sequential neighbors.\n        Stack<PairInt> stack = new Stack<PairInt>();\n        int thresh0 = 1;\n        for (int i = 0; i < img.getWidth(); i++) {\n            for (int j = 0; j < img.getHeight(); j++) {\n                \/\/for now, choosing to look only at the blue\n                int bPix = img.getValue(i, j);\n                if (bPix >= thresh0) {\n                    stack.add(new PairInt(i, j));\n                }\n            }\n        }\n        numberOfPixelsAboveThreshold = stack.size();\n        log.log(Level.FINE, \"Number of pixels that exceed threshhold={0}\", \n            Long.toString(numberOfPixelsAboveThreshold));\n        List<PairIntArray> output = new ArrayList<PairIntArray>();\n        int[] uNodeEdgeIdx = new int[img.getWidth() * img.getHeight()];\n        Arrays.fill(uNodeEdgeIdx, -1);\n        while (!stack.isEmpty()) {\n            PairInt uNode = stack.pop();\n            int uX = uNode.getX();\n            int uY = uNode.getY();\n            int uIdx = (uY * img.getWidth()) + uX;\n            boolean foundNeighbor = false;\n            \/\/ for each neighbor v of u\n            for (int vX = (uX - 1); vX < (uX + 2); vX++) {\n                if (foundNeighbor) {\n                    break;\n                }\n                if (vX < 0 || vX > (img.getWidth() - 1)) {\n                    continue;\n                }\n                for (int vY = (uY - 1); vY < (uY + 2); vY++) {\n                    if (vY < 0 || vY > (img.getHeight() - 1)) {\n                        continue;\n                    }\n                    int vIdx = (vY * img.getWidth()) + vX;\n                    if (uNodeEdgeIdx[vIdx] != -1 || (uIdx == vIdx)) {\n                        continue;\n                    }\n                    if (img.getValue(vX, vY) < thresh0) {\n                        continue;\n                    }\n                    \/\/ if u is not in an edge already, create a new one\n                    if (uNodeEdgeIdx[uIdx] == -1) {\n                        PairIntArray edge = new PairIntArray();\n                        edge.add(uX, uY);\n                        uNodeEdgeIdx[uIdx] = output.size();\n                        output.add(edge);                        \n                    }\n                    \/\/ keep the curve points ordered\n                    \/\/ add v to the edge u if u is the last node in it's edge\n                    PairIntArray appendToNode = output.get(uNodeEdgeIdx[uIdx]);\n                    int aIdx = appendToNode.getN() - 1;\n                    if ((appendToNode.getX(aIdx) != uX) || \n                        (appendToNode.getY(aIdx) != uY)) {\n                        continue;\n                    }\n                    appendToNode.add(vX, vY);\n                    uNodeEdgeIdx[vIdx] = uNodeEdgeIdx[uIdx];\n                    \/\/TODO: do we only want 1 neighbor from the 9 as a continuation?\n                    \/\/ yes for now, but this requires edges be only 1 pixel wide\n                   \/\/ inserting back at the top of the stack assures that the \n                   \/\/ search continues next from an associated point\n                   stack.add(new PairInt(vX, vY));\n                   foundNeighbor = true;\n                   break;\n                }\n            }\n        }\n        log.fine(output.size() + \" edges after DFS\");\n        int nIterMax = 100;\n        int n, sz, lastSize;\n        \/\/ count the number of points in edges\n        long sum = countPixelsInEdges(output);\n        log.log(Level.FINE, \n            \"==> {0} pixels are in edges out of {1} pixels > threshhold\", \n            new Object[]{Long.toString(sum), \n                Long.toString(numberOfPixelsAboveThreshold)});\n        log.log(Level.FINE, \"there are {0} edges\", \n            Integer.toString(output.size()));\n        output = mergeAdjacentEndPoints(output);\n        log.log(Level.FINE, \"{0} edges after merge adjacent\", \n            Integer.toString(output.size()));\n        \/*\n        \/\/not necessary now that lines from CannyEdgeFilter are 1 pix width.\n        MiscellaneousCurveHelper ch = new MiscellaneousCurveHelper();\n        n = 0;\n        sz = output.size();\n        lastSize = Integer.MAX_VALUE;\n        while ((sz < lastSize) && (n < nIterMax)) {\n            lastSize = sz;\n            output = ch.pruneAndIncludeAdjacentCurves(output, img.getWidth());\n            sz = output.size();\n            log.log(Level.FINE, \"{0}) {1} edges after prune overlapping\", \n                new Object[]{Integer.toString(n), Integer.toString(sz)});\n            n++;\n        }\n        *\/\n        \/\/ This helps to merge edges (that is extracted curves) at adjacent \n        \/\/ points that resemble an intersection of the lines, but it's not \n        \/\/ necessarily useful if only interested in corners and not inflection\n        \/\/ points because the curvature is determined correctly \n        \/\/ whether the curves are merged or not.\n        output = connectClosestPointsIfCanTrim(output);\n        log.fine(output.size() + \" edges after connect closest\");\n        output = fillInGaps(output);\n        log.log(Level.FINE, \"{0} edges after fill in gaps\", \n            new Object[]{Integer.toString(output.size())});\n        \/\/TODO:  this may need to change\n        removeEdgesShorterThan(output, edgeSizeLowerLimit);\n        sz = output.size();\n        log.log(Level.FINE, \"{0} edges after removing those shorter\", \n            new Object[]{Integer.toString(sz)});\n        long sum2 = countPixelsInEdges(output);\n        log.log(Level.FINE, \n            \"==> {0}) pixels are in edges out of {1} pixels > threshhold\", \n            new Object[]{Long.toString(sum2), \n                Long.toString(numberOfPixelsAboveThreshold)});\n        \/\/pruneSpurs(output);\n        adjustEdgesTowardsBrightPixels(output);\n        return output;\n    }","code_wo_comment":"public List<PairIntArray> findEdges() {\n       \n        Stack<PairInt> stack = new Stack<PairInt>();\n        int thresh0 = 1;\n        for (int i = 0; i < img.getWidth(); i++) {\n            for (int j = 0; j < img.getHeight(); j++) {\n               \n                int bPix = img.getValue(i, j);\n                if (bPix >= thresh0) {\n                    stack.add(new PairInt(i, j));\n                }\n            }\n        }\n        numberOfPixelsAboveThreshold = stack.size();\n        log.log(Level.FINE, \"Number of pixels that exceed threshhold={0}\", \n            Long.toString(numberOfPixelsAboveThreshold));\n        List<PairIntArray> output = new ArrayList<PairIntArray>();\n        int[] uNodeEdgeIdx = new int[img.getWidth() * img.getHeight()];\n        Arrays.fill(uNodeEdgeIdx, -1);\n        while (!stack.isEmpty()) {\n            PairInt uNode = stack.pop();\n            int uX = uNode.getX();\n            int uY = uNode.getY();\n            int uIdx = (uY * img.getWidth()) + uX;\n            boolean foundNeighbor = false;\n           \n            for (int vX = (uX - 1); vX < (uX + 2); vX++) {\n                if (foundNeighbor) {\n                    break;\n                }\n                if (vX < 0 || vX > (img.getWidth() - 1)) {\n                    continue;\n                }\n                for (int vY = (uY - 1); vY < (uY + 2); vY++) {\n                    if (vY < 0 || vY > (img.getHeight() - 1)) {\n                        continue;\n                    }\n                    int vIdx = (vY * img.getWidth()) + vX;\n                    if (uNodeEdgeIdx[vIdx] != -1 || (uIdx == vIdx)) {\n                        continue;\n                    }\n                    if (img.getValue(vX, vY) < thresh0) {\n                        continue;\n                    }\n                   \n                    if (uNodeEdgeIdx[uIdx] == -1) {\n                        PairIntArray edge = new PairIntArray();\n                        edge.add(uX, uY);\n                        uNodeEdgeIdx[uIdx] = output.size();\n                        output.add(edge);                        \n                    }\n                   \n                   \n                    PairIntArray appendToNode = output.get(uNodeEdgeIdx[uIdx]);\n                    int aIdx = appendToNode.getN() - 1;\n                    if ((appendToNode.getX(aIdx) != uX) || \n                        (appendToNode.getY(aIdx) != uY)) {\n                        continue;\n                    }\n                    appendToNode.add(vX, vY);\n                    uNodeEdgeIdx[vIdx] = uNodeEdgeIdx[uIdx];\n                   \n                   \n                  \n                  \n                   stack.add(new PairInt(vX, vY));\n                   foundNeighbor = true;\n                   break;\n                }\n            }\n        }\n        log.fine(output.size() + \" edges after DFS\");\n        int nIterMax = 100;\n        int n, sz, lastSize;\n       \n        long sum = countPixelsInEdges(output);\n        log.log(Level.FINE, \n            \"==> {0} pixels are in edges out of {1} pixels > threshhold\", \n            new Object[]{Long.toString(sum), \n                Long.toString(numberOfPixelsAboveThreshold)});\n        log.log(Level.FINE, \"there are {0} edges\", \n            Integer.toString(output.size()));\n        output = mergeAdjacentEndPoints(output);\n        log.log(Level.FINE, \"{0} edges after merge adjacent\", \n            Integer.toString(output.size()));\n       \n       \n       \n       \n       \n       \n        output = connectClosestPointsIfCanTrim(output);\n        log.fine(output.size() + \" edges after connect closest\");\n        output = fillInGaps(output);\n        log.log(Level.FINE, \"{0} edges after fill in gaps\", \n            new Object[]{Integer.toString(output.size())});\n       \n        removeEdgesShorterThan(output, edgeSizeLowerLimit);\n        sz = output.size();\n        log.log(Level.FINE, \"{0} edges after removing those shorter\", \n            new Object[]{Integer.toString(sz)});\n        long sum2 = countPixelsInEdges(output);\n        log.log(Level.FINE, \n            \"==> {0}) pixels are in edges out of {1} pixels > threshhold\", \n            new Object[]{Long.toString(sum2), \n                Long.toString(numberOfPixelsAboveThreshold)});\n       \n        adjustEdgesTowardsBrightPixels(output);\n        return output;\n    }","cleancode":"public list<pairintarray> findedges() { stack<pairint> stack = new stack<pairint>(); int thresh0 = 1; for (int i = 0; i < img.getwidth(); i++) { for (int j = 0; j < img.getheight(); j++) { int bpix = img.getvalue(i, j); if (bpix >= thresh0) { stack.add(new pairint(i, j)); } } } numberofpixelsabovethreshold = stack.size(); log.log(level.fine, \"number of pixels that exceed threshhold={0}\", long.tostring(numberofpixelsabovethreshold)); list<pairintarray> output = new arraylist<pairintarray>(); int[] unodeedgeidx = new int[img.getwidth() * img.getheight()]; arrays.fill(unodeedgeidx, -1); while (!stack.isempty()) { pairint unode = stack.pop(); int ux = unode.getx(); int uy = unode.gety(); int uidx = (uy * img.getwidth()) + ux; boolean foundneighbor = false; for (int vx = (ux - 1); vx < (ux + 2); vx++) { if (foundneighbor) { break; } if (vx < 0 || vx > (img.getwidth() - 1)) { continue; } for (int vy = (uy - 1); vy < (uy + 2); vy++) { if (vy < 0 || vy > (img.getheight() - 1)) { continue; } int vidx = (vy * img.getwidth()) + vx; if (unodeedgeidx[vidx] != -1 || (uidx == vidx)) { continue; } if (img.getvalue(vx, vy) < thresh0) { continue; } if (unodeedgeidx[uidx] == -1) { pairintarray edge = new pairintarray(); edge.add(ux, uy); unodeedgeidx[uidx] = output.size(); output.add(edge); } pairintarray appendtonode = output.get(unodeedgeidx[uidx]); int aidx = appendtonode.getn() - 1; if ((appendtonode.getx(aidx) != ux) || (appendtonode.gety(aidx) != uy)) { continue; } appendtonode.add(vx, vy); unodeedgeidx[vidx] = unodeedgeidx[uidx]; stack.add(new pairint(vx, vy)); foundneighbor = true; break; } } } log.fine(output.size() + \" edges after dfs\"); int nitermax = 100; int n, sz, lastsize; long sum = countpixelsinedges(output); log.log(level.fine, \"==> {0} pixels are in edges out of {1} pixels > threshhold\", new object[]{long.tostring(sum), long.tostring(numberofpixelsabovethreshold)}); log.log(level.fine, \"there are {0} edges\", integer.tostring(output.size())); output = mergeadjacentendpoints(output); log.log(level.fine, \"{0} edges after merge adjacent\", integer.tostring(output.size())); output = connectclosestpointsifcantrim(output); log.fine(output.size() + \" edges after connect closest\"); output = fillingaps(output); log.log(level.fine, \"{0} edges after fill in gaps\", new object[]{integer.tostring(output.size())}); removeedgesshorterthan(output, edgesizelowerlimit); sz = output.size(); log.log(level.fine, \"{0} edges after removing those shorter\", new object[]{integer.tostring(sz)}); long sum2 = countpixelsinedges(output); log.log(level.fine, \"==> {0}) pixels are in edges out of {1} pixels > threshhold\", new object[]{long.tostring(sum2), long.tostring(numberofpixelsabovethreshold)}); adjustedgestowardsbrightpixels(output); return output; }","repo":"dukson\/curvature-scale-space-corners-and-transformations","label":[1,0,0,0]}
{"id":22779,"original_code":"public void fillPath(DirectionRobot robot, int endX, int endY) {\n        int width = robot.getX() - endX;\n        int height = robot.getY() - endY;\n        \/\/todo refactor logic\n        \/\/select direction\n        AbstractRobot.Direction abstractDirection = robot.getDirection();\n        System.out.println(\"first!\");\n        if (width < 0) {\n            \/\/start on the left side\n            switch (abstractDirection) {\n                case UP: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case LEFT: {\n                    this.addComand(new RotateRightComand(robot));\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case DOWN: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n            }\n            abstractDirection = AbstractRobot.Direction.RIGHT;\n        }\n        if (width > 0) {\n            \/\/start on the right side\n            switch (abstractDirection) {\n                case UP: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n                case DOWN: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateLeftComand(robot));\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n            }\n            abstractDirection = AbstractRobot.Direction.LEFT;\n        }\n        \/\/move X\n        System.out.println(width);\n        for (int i = 0; i < abs(width); i++) {\n            this.addComand(new MoveForwardComand(robot));\n        }\n        \/\/select direction again\n        if (height < 0) {\n            \/\/if start above end\n            switch (abstractDirection) {\n                case LEFT: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n            }\n\/\/            abstractDirection = AbstractRobot.Direction.DOWN;\n        }\n        if (height > 0) {\n            \/\/if start below end\n            switch (abstractDirection) {\n                case LEFT: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateLeftComand(robot)); \/\/done\n                }\n                break;\n            }\n\/\/            abstractDirection = AbstractRobot.Direction.UP;\n        }\n        \/\/move Y\n        System.out.println(height);\n        for (int i = 0; i < abs(height); i++) {\n            this.addComand(new MoveForwardComand(robot));\n        }\n    }","code_wo_comment":"public void fillPath(DirectionRobot robot, int endX, int endY) {\n        int width = robot.getX() - endX;\n        int height = robot.getY() - endY;\n       \n       \n        AbstractRobot.Direction abstractDirection = robot.getDirection();\n        System.out.println(\"first!\");\n        if (width < 0) {\n           \n            switch (abstractDirection) {\n                case UP: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case LEFT: {\n                    this.addComand(new RotateRightComand(robot));\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case DOWN: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n            }\n            abstractDirection = AbstractRobot.Direction.RIGHT;\n        }\n        if (width > 0) {\n           \n            switch (abstractDirection) {\n                case UP: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n                case DOWN: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateLeftComand(robot));\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n            }\n            abstractDirection = AbstractRobot.Direction.LEFT;\n        }\n       \n        System.out.println(width);\n        for (int i = 0; i < abs(width); i++) {\n            this.addComand(new MoveForwardComand(robot));\n        }\n       \n        if (height < 0) {\n           \n            switch (abstractDirection) {\n                case LEFT: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n            }\n        }\n        if (height > 0) {\n           \n            switch (abstractDirection) {\n                case LEFT: {\n                    this.addComand(new RotateRightComand(robot));\n                }\n                break;\n                case RIGHT: {\n                    this.addComand(new RotateLeftComand(robot));\n                }\n                break;\n            }\n        }\n       \n        System.out.println(height);\n        for (int i = 0; i < abs(height); i++) {\n            this.addComand(new MoveForwardComand(robot));\n        }\n    }","cleancode":"public void fillpath(directionrobot robot, int endx, int endy) { int width = robot.getx() - endx; int height = robot.gety() - endy; abstractrobot.direction abstractdirection = robot.getdirection(); system.out.println(\"first!\"); if (width < 0) { switch (abstractdirection) { case up: { this.addcomand(new rotaterightcomand(robot)); } break; case left: { this.addcomand(new rotaterightcomand(robot)); this.addcomand(new rotaterightcomand(robot)); } break; case down: { this.addcomand(new rotateleftcomand(robot)); } break; } abstractdirection = abstractrobot.direction.right; } if (width > 0) { switch (abstractdirection) { case up: { this.addcomand(new rotateleftcomand(robot)); } break; case down: { this.addcomand(new rotaterightcomand(robot)); } break; case right: { this.addcomand(new rotateleftcomand(robot)); this.addcomand(new rotateleftcomand(robot)); } break; } abstractdirection = abstractrobot.direction.left; } system.out.println(width); for (int i = 0; i < abs(width); i++) { this.addcomand(new moveforwardcomand(robot)); } if (height < 0) { switch (abstractdirection) { case left: { this.addcomand(new rotateleftcomand(robot)); } break; case right: { this.addcomand(new rotaterightcomand(robot)); } break; } } if (height > 0) { switch (abstractdirection) { case left: { this.addcomand(new rotaterightcomand(robot)); } break; case right: { this.addcomand(new rotateleftcomand(robot)); } break; } } system.out.println(height); for (int i = 0; i < abs(height); i++) { this.addcomand(new moveforwardcomand(robot)); } }","repo":"defoltbmd\/SimpleRobot","label":[1,0,0,0]}
{"id":14669,"original_code":"public Dimension preferredLayoutSize(Container parent) \n    {\n\t\/* Sync the (now obsolete) policy fields with the\n\t * JScrollPane.\n\t *\/\n\tJScrollPane scrollPane = (JScrollPane)parent;\n\tvsbPolicy = scrollPane.getVerticalScrollBarPolicy();\n\thsbPolicy = scrollPane.getHorizontalScrollBarPolicy();\n\tInsets insets = parent.getInsets();\n\tint prefWidth = insets.left + insets.right;\n\tint prefHeight = insets.top + insets.bottom;\n\t\/* Note that viewport.getViewSize() is equivalent to \n\t * viewport.getView().getPreferredSize() modulo a null\n\t * view or a view whose size was explicitly set.\n\t *\/\n\tDimension extentSize = null;\n\tDimension viewSize = null;\n\tComponent view = null;\n\tif (viewport !=  null) {\n\t    extentSize = viewport.getPreferredSize();\n            \/\/Bug fix: always use the preferred size for the client.\n\t    \/\/viewSize = viewport.getViewSize();\n\t    viewSize = viewport.getView().getPreferredSize();\n\t    view = viewport.getView();\n\t}\n\t\/* If there's a viewport add its preferredSize.\n\t *\/\n\tif (extentSize != null) {\n\t    prefWidth += extentSize.width;\n\t    prefHeight += extentSize.height;\n\t}\n\t\/* If there's a JScrollPane.viewportBorder, add its insets.\n\t *\/\n\tBorder viewportBorder = scrollPane.getViewportBorder();\n\tif (viewportBorder != null) {\n\t    Insets vpbInsets = viewportBorder.getBorderInsets(parent);\n\t    prefWidth += vpbInsets.left + vpbInsets.right;\n\t    prefHeight += vpbInsets.top + vpbInsets.bottom;\n\t}\n\t\/* If a header exists and it's visible, factor its\n\t * preferred size in.\n\t *\/\n\tif ((rowHead != null) && rowHead.isVisible()) {\n\t    prefWidth += rowHead.getPreferredSize().width;\n\t}\n\tif ((colHead != null) && colHead.isVisible()) {\n\t    prefHeight += colHead.getPreferredSize().height;\n\t}\n\t\/* If a scrollbar is going to appear, factor its preferred size in.\n\t * If the scrollbars policy is AS_NEEDED, this can be a little\n\t * tricky:\n\t * \n\t * - If the view is a Scrollable then scrollableTracksViewportWidth\n\t * and scrollableTracksViewportHeight can be used to effectively \n\t * disable scrolling (if they're true) in their respective dimensions.\n\t * \n\t * - Assuming that a scrollbar hasn't been disabled by the \n\t * previous constraint, we need to decide if the scrollbar is going \n\t * to appear to correctly compute the JScrollPanes preferred size.\n\t * To do this we compare the preferredSize of the viewport (the \n\t * extentSize) to the preferredSize of the view.  Although we're\n\t * not responsible for laying out the view we'll assume that the \n\t * JViewport will always give it its preferredSize.\n\t *\/\n\tif ((vsb != null) && (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {\n\t    if (vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS) {\n\t\tprefWidth += vsb.getPreferredSize().width;\n\t    }\n\t    else if ((viewSize != null) && (extentSize != null)) {\n\t\tboolean canScroll = true;\n\t\tif (view instanceof Scrollable) {\n\t\t    canScroll = !((Scrollable)view).getScrollableTracksViewportHeight();\n\t\t}\n\t\tif (canScroll && (viewSize.height > extentSize.height)) {\n\t\t    prefWidth += vsb.getPreferredSize().width;\n\t\t}\n\t    }\n\t}\n\tif ((hsb != null) && (hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)) {\n\t    if (hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS) {\n\t\tprefHeight += hsb.getPreferredSize().height;\n\t    }\n\t    else if ((viewSize != null) && (extentSize != null)) {\n\t\tboolean canScroll = true;\n\t\tif (view instanceof Scrollable) {\n\t\t    canScroll = !((Scrollable)view).getScrollableTracksViewportWidth();\n\t\t}\n\t\tif (canScroll && (viewSize.width > extentSize.width)) {\n\t\t    prefHeight += hsb.getPreferredSize().height;\n\t\t}\n\t    }\n\t}\n        Dimension dim = new Dimension(prefWidth, prefHeight);\n\treturn dim;\n    }","code_wo_comment":"public Dimension preferredLayoutSize(Container parent) \n    {\n\n\tJScrollPane scrollPane = (JScrollPane)parent;\n\tvsbPolicy = scrollPane.getVerticalScrollBarPolicy();\n\thsbPolicy = scrollPane.getHorizontalScrollBarPolicy();\n\tInsets insets = parent.getInsets();\n\tint prefWidth = insets.left + insets.right;\n\tint prefHeight = insets.top + insets.bottom;\n\n\tDimension extentSize = null;\n\tDimension viewSize = null;\n\tComponent view = null;\n\tif (viewport !=  null) {\n\t    extentSize = viewport.getPreferredSize();\n           \n\t   \n\t    viewSize = viewport.getView().getPreferredSize();\n\t    view = viewport.getView();\n\t}\n\n\tif (extentSize != null) {\n\t    prefWidth += extentSize.width;\n\t    prefHeight += extentSize.height;\n\t}\n\n\tBorder viewportBorder = scrollPane.getViewportBorder();\n\tif (viewportBorder != null) {\n\t    Insets vpbInsets = viewportBorder.getBorderInsets(parent);\n\t    prefWidth += vpbInsets.left + vpbInsets.right;\n\t    prefHeight += vpbInsets.top + vpbInsets.bottom;\n\t}\n\n\tif ((rowHead != null) && rowHead.isVisible()) {\n\t    prefWidth += rowHead.getPreferredSize().width;\n\t}\n\tif ((colHead != null) && colHead.isVisible()) {\n\t    prefHeight += colHead.getPreferredSize().height;\n\t}\n\n\tif ((vsb != null) && (vsbPolicy != VERTICAL_SCROLLBAR_NEVER)) {\n\t    if (vsbPolicy == VERTICAL_SCROLLBAR_ALWAYS) {\n\t\tprefWidth += vsb.getPreferredSize().width;\n\t    }\n\t    else if ((viewSize != null) && (extentSize != null)) {\n\t\tboolean canScroll = true;\n\t\tif (view instanceof Scrollable) {\n\t\t    canScroll = !((Scrollable)view).getScrollableTracksViewportHeight();\n\t\t}\n\t\tif (canScroll && (viewSize.height > extentSize.height)) {\n\t\t    prefWidth += vsb.getPreferredSize().width;\n\t\t}\n\t    }\n\t}\n\tif ((hsb != null) && (hsbPolicy != HORIZONTAL_SCROLLBAR_NEVER)) {\n\t    if (hsbPolicy == HORIZONTAL_SCROLLBAR_ALWAYS) {\n\t\tprefHeight += hsb.getPreferredSize().height;\n\t    }\n\t    else if ((viewSize != null) && (extentSize != null)) {\n\t\tboolean canScroll = true;\n\t\tif (view instanceof Scrollable) {\n\t\t    canScroll = !((Scrollable)view).getScrollableTracksViewportWidth();\n\t\t}\n\t\tif (canScroll && (viewSize.width > extentSize.width)) {\n\t\t    prefHeight += hsb.getPreferredSize().height;\n\t\t}\n\t    }\n\t}\n        Dimension dim = new Dimension(prefWidth, prefHeight);\n\treturn dim;\n    }","cleancode":"public dimension preferredlayoutsize(container parent) { jscrollpane scrollpane = (jscrollpane)parent; vsbpolicy = scrollpane.getverticalscrollbarpolicy(); hsbpolicy = scrollpane.gethorizontalscrollbarpolicy(); insets insets = parent.getinsets(); int prefwidth = insets.left + insets.right; int prefheight = insets.top + insets.bottom; dimension extentsize = null; dimension viewsize = null; component view = null; if (viewport != null) { extentsize = viewport.getpreferredsize(); viewsize = viewport.getview().getpreferredsize(); view = viewport.getview(); } if (extentsize != null) { prefwidth += extentsize.width; prefheight += extentsize.height; } border viewportborder = scrollpane.getviewportborder(); if (viewportborder != null) { insets vpbinsets = viewportborder.getborderinsets(parent); prefwidth += vpbinsets.left + vpbinsets.right; prefheight += vpbinsets.top + vpbinsets.bottom; } if ((rowhead != null) && rowhead.isvisible()) { prefwidth += rowhead.getpreferredsize().width; } if ((colhead != null) && colhead.isvisible()) { prefheight += colhead.getpreferredsize().height; } if ((vsb != null) && (vsbpolicy != vertical_scrollbar_never)) { if (vsbpolicy == vertical_scrollbar_always) { prefwidth += vsb.getpreferredsize().width; } else if ((viewsize != null) && (extentsize != null)) { boolean canscroll = true; if (view instanceof scrollable) { canscroll = !((scrollable)view).getscrollabletracksviewportheight(); } if (canscroll && (viewsize.height > extentsize.height)) { prefwidth += vsb.getpreferredsize().width; } } } if ((hsb != null) && (hsbpolicy != horizontal_scrollbar_never)) { if (hsbpolicy == horizontal_scrollbar_always) { prefheight += hsb.getpreferredsize().height; } else if ((viewsize != null) && (extentsize != null)) { boolean canscroll = true; if (view instanceof scrollable) { canscroll = !((scrollable)view).getscrollabletracksviewportwidth(); } if (canscroll && (viewsize.width > extentsize.width)) { prefheight += hsb.getpreferredsize().height; } } } dimension dim = new dimension(prefwidth, prefheight); return dim; }","repo":"dannyhx\/artisynth_core","label":[0,0,1,0]}
{"id":31217,"original_code":"@Override\n        protected Void doInBackground(String... args) {\n            if (isCancelled()) {\n                return null;\n            }\n            \/\/ TODO subscribe to network events instead of using this\n            if (!networkAvailable) {\n                Toast.makeText(\n                        context,\n                        getString(R.string.toast_nonetwork),\n                        Toast.LENGTH_LONG).show();\n            } else {\n                \/\/ TODO remove this but with caution\n                updateUIBean = new UpdateUIBean();\n                \/\/ TODO to test different configs change the files poiting by CONFIG_FILE\n                \/\/  avoid changing the code directly\n                Config.readConfigFile(ReplayConstants.CONFIG_FILE, context);\n                SharedPreferences sharedPrefs =\n                        PreferenceManager.getDefaultSharedPreferences(context);\n                try {\n                    \/\/ metadata here is user's network type device used geolocation if permitted etc\n                    \/\/ Google storage forbids to store user related data\n                    \/\/ So we send that data to a private server\n                    server = sharedPrefs.getString(\"pref_server\", \"wehe2.meddle.mobi\");\n                    metadataServer = \"wehe-metadata.meddle.mobi\";\n                    \/\/ We first resolve the IP of the server and then communicate with the server\n                    \/\/ Using IP only, because we have multiple server under same domain and we want\n                    \/\/ the client not to switch server during a test run\n                    \/\/ TODO come up with a better way to handle Inet related queries, since this\n                    \/\/  introduced inefficiency\n                    final InetAddress[] address = {null, null};\n                    new Thread() {\n                        public void run() {\n                            while (!(address[0] instanceof Inet4Address || address[0] instanceof Inet6Address)) {\n                                try {\n                                    server = InetAddress.getByName(server).getHostAddress();\n                                    address[0] = InetAddress.getByName(server);\n                                } catch (UnknownHostException e) {\n                                    Log.w(\"GetReplayServerIP\", \"get IP of replay server failed!\");\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n                    }.start();\n                    new Thread() {\n                        public void run() {\n                            while (!(address[1] instanceof Inet4Address || address[1] instanceof Inet6Address)) {\n                                try {\n                                    metadataServer = InetAddress.getByName(metadataServer).getHostAddress();\n                                    address[1] = InetAddress.getByName(metadataServer);\n                                } catch (UnknownHostException e) {\n                                    Log.w(\"GetReplayServerIP\", \"get IP of replay server failed!\");\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n                    }.start();\n                    int maxWaitTime = 5000;\n                    int currentWaitTime = 500;\n                    while (!(address[0] instanceof Inet4Address || address[0] instanceof Inet6Address)\n                            && !(address[1] instanceof Inet4Address || address[1] instanceof Inet6Address)) {\n                        try {\n                            if (currentWaitTime <= maxWaitTime) {\n                                Thread.sleep(currentWaitTime);\n                                currentWaitTime += 500;\n                            } else {\n                                Toast.makeText(context, R.string.server_unavailable,\n                                        Toast.LENGTH_LONG).show();\n                                return null;\n                            }\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    if (address[0] instanceof Inet6Address)\n                        server = \"[\" + server + \"]\";\n                    if (address[1] instanceof Inet6Address)\n                        metadataServer = \"[\" + metadataServer + \"]\";\n                    try {\n                        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                        Certificate ca;\n                        try (InputStream caInput = getResources().openRawResource(R.raw.main)) {\n                            ca = cf.generateCertificate(caInput);\n                            System.out.println(\"main=\" + ((X509Certificate) ca).getIssuerDN());\n                        }\n                        \/\/ Create a KeyStore containing our trusted CAs\n                        String keyStoreType = KeyStore.getDefaultType();\n                        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                        keyStore.load(null, null);\n                        keyStore.setCertificateEntry(\"main\", ca);\n                        \/\/ Create a TrustManager that trusts the CAs in our KeyStore\n                        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                        tmf.init(keyStore);\n                        \/\/ Create an SSLContext that uses our TrustManager\n                        SSLContext context = SSLContext.getInstance(\"TLS\");\n                        context.init(null, tmf.getTrustManagers(), null);\n                        sslSocketFactory = context.getSocketFactory();\n                        hostnameVerifier = (hostname, session) -> true;\n                    } catch (CertificateException e) {\n                        e.printStackTrace();\n                    } catch (NoSuchAlgorithmException e) {\n                        e.printStackTrace();\n                    } catch (KeyStoreException e) {\n                        e.printStackTrace();\n                    } catch (KeyManagementException e) {\n                        e.printStackTrace();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    try {\n                        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                        Certificate ca;\n                        try (InputStream caInput = getResources().openRawResource(R.raw.metadata)) {\n                            ca = cf.generateCertificate(caInput);\n                            System.out.println(\"metadata=\" + ((X509Certificate) ca).getIssuerDN());\n                        }\n                        \/\/ Create a KeyStore containing our trusted CAs\n                        String keyStoreType = KeyStore.getDefaultType();\n                        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                        keyStore.load(null, null);\n                        keyStore.setCertificateEntry(\"metadata\", ca);\n                        \/\/ Create a TrustManager that trusts the CAs in our KeyStore\n                        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                        tmf.init(keyStore);\n                        \/\/ Create an SSLContext that uses our TrustManager\n                        SSLContext context = SSLContext.getInstance(\"TLS\");\n                        context.init(null, tmf.getTrustManagers(), null);\n                        metadataSocketFactory = context.getSocketFactory();\n                    } catch (CertificateException e) {\n                        e.printStackTrace();\n                    } catch (NoSuchAlgorithmException e) {\n                        e.printStackTrace();\n                    } catch (KeyStoreException e) {\n                        e.printStackTrace();\n                    } catch (KeyManagementException e) {\n                        e.printStackTrace();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    Log.d(\"GetReplayServerIP\", \"Server IP: \" + server);\n                } catch (NullPointerException e) {\n                    e.printStackTrace();\n                    Log.w(\"GetReplayServerIP\", \"Invalid IP address!\");\n                }\n                \/\/ Extract data that was sent by previous activity. In our case, list of\n                \/\/ apps, server and timing\n                enableTiming = \"true\";\n                doTest = false;\n                int port = Integer.valueOf(Config.get(\"result_port\"));\n                analyzerServerUrl = (\"https:\/\/\" + server + \":\" + port + \"\/Results\");\n                date = new Date();\n                results = new JSONArray();\n                Log.d(\"Result Channel\",\n                        \"path: \" + server + \" port: \" + port);\n                confirmationReplays = sharedPrefs.getBoolean(\"confirmationReplays\", true);\n                \/\/ generate or retrieve an id for this phone\n                boolean hasID = sharedPrefs.getBoolean(\"hasID\", false);\n                if (!hasID) {\n                    randomID = new RandomString(10).nextString();\n                    SharedPreferences.Editor editor = sharedPrefs.edit();\n                    editor.putBoolean(\"hasID\", true);\n                    editor.putString(\"ID\", randomID);\n                    editor.apply();\n                } else {\n                    randomID = sharedPrefs.getString(\"ID\", null);\n                }\n                a_threshold = Integer.parseInt(Objects.requireNonNull(sharedPrefs.getString(\"pref_threshold_area\", \"10\")));\n                ks2pvalue_threshold = Integer.parseInt(Objects.requireNonNull(sharedPrefs.getString(\"pref_threshold_ks2p\", \"5\")));\n                confirmationReplays = sharedPrefs.getBoolean(\"pref_multiple_tests\", true);\n                \/\/ to get historyCount\n                settings = getSharedPreferences(STATUS, Context.MODE_PRIVATE);\n                \/\/ generate or retrieve an historyCount for this phone\n                boolean hasHistoryCount = settings.getBoolean(\"hasHistoryCount\", false);\n                if (!hasHistoryCount) {\n                    historyCount = 0;\n                    SharedPreferences.Editor editor = settings.edit();\n                    editor.putBoolean(\"hasHistoryCount\", true);\n                    editor.putInt(\"historyCount\", historyCount);\n                    editor.apply();\n                } else {\n                    historyCount = settings.getInt(\"historyCount\", -1);\n                }\n                \/\/ check if retrieve historyCount succeeded\n                if (historyCount == -1)\n                    throw new RuntimeException();\n                Config.set(\"timing\", enableTiming);\n                \/\/ make sure server is initialized!\n                while (server == null) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                Config.set(\"server\", server);\n                Config.set(\"jitter\", \"true\");\n                Config.set(\"publicIP\", \"\");\n                new Thread(new Runnable() {\n                    public void run() {\n                        Config.set(\"publicIP\", getPublicIP(\"80\"));\n                    }\n                }).start();\n                \/\/ Find a way to switch to no wait\n                while (Config.get(\"publicIP\").equals(\"\")) {\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                Log.d(\"Replay\", \"public IP: \" + Config.get(\"publicIP\"));\n            }\n            for (ApplicationBean app : selectedApps) {\n                rerun = false;\n                \/\/ Set the app to run test for\n                this.app = app;\n                \/\/ Run the test on this.app\n                runTest();\n            }\n            \/\/ Keep checking if the user exited from ReplayActivity or not\n            \/\/ TODO find a better way stop the tests immediately without continues checking\n            if (isCancelled()) {\n                return null;\n            }\n            if (results.length() > 0) {\n                Log.d(\"Result Channel\", \"Storing results\");\n                saveResults();\n            }\n            if (isCancelled()) {\n                return null;\n            }\n            showFinishDialog();\n            Log.d(\"Result Channel\", \"Exiting normally\");\n            return null;\n        }","code_wo_comment":"@Override\n        protected Void doInBackground(String... args) {\n            if (isCancelled()) {\n                return null;\n            }\n           \n            if (!networkAvailable) {\n                Toast.makeText(\n                        context,\n                        getString(R.string.toast_nonetwork),\n                        Toast.LENGTH_LONG).show();\n            } else {\n               \n                updateUIBean = new UpdateUIBean();\n               \n               \n                Config.readConfigFile(ReplayConstants.CONFIG_FILE, context);\n                SharedPreferences sharedPrefs =\n                        PreferenceManager.getDefaultSharedPreferences(context);\n                try {\n                   \n                   \n                   \n                    server = sharedPrefs.getString(\"pref_server\", \"wehe2.meddle.mobi\");\n                    metadataServer = \"wehe-metadata.meddle.mobi\";\n                   \n                   \n                   \n                   \n                   \n                    final InetAddress[] address = {null, null};\n                    new Thread() {\n                        public void run() {\n                            while (!(address[0] instanceof Inet4Address || address[0] instanceof Inet6Address)) {\n                                try {\n                                    server = InetAddress.getByName(server).getHostAddress();\n                                    address[0] = InetAddress.getByName(server);\n                                } catch (UnknownHostException e) {\n                                    Log.w(\"GetReplayServerIP\", \"get IP of replay server failed!\");\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n                    }.start();\n                    new Thread() {\n                        public void run() {\n                            while (!(address[1] instanceof Inet4Address || address[1] instanceof Inet6Address)) {\n                                try {\n                                    metadataServer = InetAddress.getByName(metadataServer).getHostAddress();\n                                    address[1] = InetAddress.getByName(metadataServer);\n                                } catch (UnknownHostException e) {\n                                    Log.w(\"GetReplayServerIP\", \"get IP of replay server failed!\");\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n                    }.start();\n                    int maxWaitTime = 5000;\n                    int currentWaitTime = 500;\n                    while (!(address[0] instanceof Inet4Address || address[0] instanceof Inet6Address)\n                            && !(address[1] instanceof Inet4Address || address[1] instanceof Inet6Address)) {\n                        try {\n                            if (currentWaitTime <= maxWaitTime) {\n                                Thread.sleep(currentWaitTime);\n                                currentWaitTime += 500;\n                            } else {\n                                Toast.makeText(context, R.string.server_unavailable,\n                                        Toast.LENGTH_LONG).show();\n                                return null;\n                            }\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                    if (address[0] instanceof Inet6Address)\n                        server = \"[\" + server + \"]\";\n                    if (address[1] instanceof Inet6Address)\n                        metadataServer = \"[\" + metadataServer + \"]\";\n                    try {\n                        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                        Certificate ca;\n                        try (InputStream caInput = getResources().openRawResource(R.raw.main)) {\n                            ca = cf.generateCertificate(caInput);\n                            System.out.println(\"main=\" + ((X509Certificate) ca).getIssuerDN());\n                        }\n                       \n                        String keyStoreType = KeyStore.getDefaultType();\n                        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                        keyStore.load(null, null);\n                        keyStore.setCertificateEntry(\"main\", ca);\n                       \n                        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                        tmf.init(keyStore);\n                       \n                        SSLContext context = SSLContext.getInstance(\"TLS\");\n                        context.init(null, tmf.getTrustManagers(), null);\n                        sslSocketFactory = context.getSocketFactory();\n                        hostnameVerifier = (hostname, session) -> true;\n                    } catch (CertificateException e) {\n                        e.printStackTrace();\n                    } catch (NoSuchAlgorithmException e) {\n                        e.printStackTrace();\n                    } catch (KeyStoreException e) {\n                        e.printStackTrace();\n                    } catch (KeyManagementException e) {\n                        e.printStackTrace();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    try {\n                        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n                        Certificate ca;\n                        try (InputStream caInput = getResources().openRawResource(R.raw.metadata)) {\n                            ca = cf.generateCertificate(caInput);\n                            System.out.println(\"metadata=\" + ((X509Certificate) ca).getIssuerDN());\n                        }\n                       \n                        String keyStoreType = KeyStore.getDefaultType();\n                        KeyStore keyStore = KeyStore.getInstance(keyStoreType);\n                        keyStore.load(null, null);\n                        keyStore.setCertificateEntry(\"metadata\", ca);\n                       \n                        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n                        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n                        tmf.init(keyStore);\n                       \n                        SSLContext context = SSLContext.getInstance(\"TLS\");\n                        context.init(null, tmf.getTrustManagers(), null);\n                        metadataSocketFactory = context.getSocketFactory();\n                    } catch (CertificateException e) {\n                        e.printStackTrace();\n                    } catch (NoSuchAlgorithmException e) {\n                        e.printStackTrace();\n                    } catch (KeyStoreException e) {\n                        e.printStackTrace();\n                    } catch (KeyManagementException e) {\n                        e.printStackTrace();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    Log.d(\"GetReplayServerIP\", \"Server IP: \" + server);\n                } catch (NullPointerException e) {\n                    e.printStackTrace();\n                    Log.w(\"GetReplayServerIP\", \"Invalid IP address!\");\n                }\n               \n               \n                enableTiming = \"true\";\n                doTest = false;\n                int port = Integer.valueOf(Config.get(\"result_port\"));\n                analyzerServerUrl = (\"https:\/\/\" + server + \":\" + port + \"\/Results\");\n                date = new Date();\n                results = new JSONArray();\n                Log.d(\"Result Channel\",\n                        \"path: \" + server + \" port: \" + port);\n                confirmationReplays = sharedPrefs.getBoolean(\"confirmationReplays\", true);\n               \n                boolean hasID = sharedPrefs.getBoolean(\"hasID\", false);\n                if (!hasID) {\n                    randomID = new RandomString(10).nextString();\n                    SharedPreferences.Editor editor = sharedPrefs.edit();\n                    editor.putBoolean(\"hasID\", true);\n                    editor.putString(\"ID\", randomID);\n                    editor.apply();\n                } else {\n                    randomID = sharedPrefs.getString(\"ID\", null);\n                }\n                a_threshold = Integer.parseInt(Objects.requireNonNull(sharedPrefs.getString(\"pref_threshold_area\", \"10\")));\n                ks2pvalue_threshold = Integer.parseInt(Objects.requireNonNull(sharedPrefs.getString(\"pref_threshold_ks2p\", \"5\")));\n                confirmationReplays = sharedPrefs.getBoolean(\"pref_multiple_tests\", true);\n               \n                settings = getSharedPreferences(STATUS, Context.MODE_PRIVATE);\n               \n                boolean hasHistoryCount = settings.getBoolean(\"hasHistoryCount\", false);\n                if (!hasHistoryCount) {\n                    historyCount = 0;\n                    SharedPreferences.Editor editor = settings.edit();\n                    editor.putBoolean(\"hasHistoryCount\", true);\n                    editor.putInt(\"historyCount\", historyCount);\n                    editor.apply();\n                } else {\n                    historyCount = settings.getInt(\"historyCount\", -1);\n                }\n               \n                if (historyCount == -1)\n                    throw new RuntimeException();\n                Config.set(\"timing\", enableTiming);\n               \n                while (server == null) {\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                Config.set(\"server\", server);\n                Config.set(\"jitter\", \"true\");\n                Config.set(\"publicIP\", \"\");\n                new Thread(new Runnable() {\n                    public void run() {\n                        Config.set(\"publicIP\", getPublicIP(\"80\"));\n                    }\n                }).start();\n               \n                while (Config.get(\"publicIP\").equals(\"\")) {\n                    try {\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                Log.d(\"Replay\", \"public IP: \" + Config.get(\"publicIP\"));\n            }\n            for (ApplicationBean app : selectedApps) {\n                rerun = false;\n               \n                this.app = app;\n               \n                runTest();\n            }\n           \n           \n            if (isCancelled()) {\n                return null;\n            }\n            if (results.length() > 0) {\n                Log.d(\"Result Channel\", \"Storing results\");\n                saveResults();\n            }\n            if (isCancelled()) {\n                return null;\n            }\n            showFinishDialog();\n            Log.d(\"Result Channel\", \"Exiting normally\");\n            return null;\n        }","cleancode":"@override protected void doinbackground(string... args) { if (iscancelled()) { return null; } if (!networkavailable) { toast.maketext( context, getstring(r.string.toast_nonetwork), toast.length_long).show(); } else { updateuibean = new updateuibean(); config.readconfigfile(replayconstants.config_file, context); sharedpreferences sharedprefs = preferencemanager.getdefaultsharedpreferences(context); try { server = sharedprefs.getstring(\"pref_server\", \"wehe2.meddle.mobi\"); metadataserver = \"wehe-metadata.meddle.mobi\"; final inetaddress[] address = {null, null}; new thread() { public void run() { while (!(address[0] instanceof inet4address || address[0] instanceof inet6address)) { try { server = inetaddress.getbyname(server).gethostaddress(); address[0] = inetaddress.getbyname(server); } catch (unknownhostexception e) { log.w(\"getreplayserverip\", \"get ip of replay server failed!\"); e.printstacktrace(); } } } }.start(); new thread() { public void run() { while (!(address[1] instanceof inet4address || address[1] instanceof inet6address)) { try { metadataserver = inetaddress.getbyname(metadataserver).gethostaddress(); address[1] = inetaddress.getbyname(metadataserver); } catch (unknownhostexception e) { log.w(\"getreplayserverip\", \"get ip of replay server failed!\"); e.printstacktrace(); } } } }.start(); int maxwaittime = 5000; int currentwaittime = 500; while (!(address[0] instanceof inet4address || address[0] instanceof inet6address) && !(address[1] instanceof inet4address || address[1] instanceof inet6address)) { try { if (currentwaittime <= maxwaittime) { thread.sleep(currentwaittime); currentwaittime += 500; } else { toast.maketext(context, r.string.server_unavailable, toast.length_long).show(); return null; } } catch (interruptedexception e) { e.printstacktrace(); } } if (address[0] instanceof inet6address) server = \"[\" + server + \"]\"; if (address[1] instanceof inet6address) metadataserver = \"[\" + metadataserver + \"]\"; try { certificatefactory cf = certificatefactory.getinstance(\"x.509\"); certificate ca; try (inputstream cainput = getresources().openrawresource(r.raw.main)) { ca = cf.generatecertificate(cainput); system.out.println(\"main=\" + ((x509certificate) ca).getissuerdn()); } string keystoretype = keystore.getdefaulttype(); keystore keystore = keystore.getinstance(keystoretype); keystore.load(null, null); keystore.setcertificateentry(\"main\", ca); string tmfalgorithm = trustmanagerfactory.getdefaultalgorithm(); trustmanagerfactory tmf = trustmanagerfactory.getinstance(tmfalgorithm); tmf.init(keystore); sslcontext context = sslcontext.getinstance(\"tls\"); context.init(null, tmf.gettrustmanagers(), null); sslsocketfactory = context.getsocketfactory(); hostnameverifier = (hostname, session) -> true; } catch (certificateexception e) { e.printstacktrace(); } catch (nosuchalgorithmexception e) { e.printstacktrace(); } catch (keystoreexception e) { e.printstacktrace(); } catch (keymanagementexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } try { certificatefactory cf = certificatefactory.getinstance(\"x.509\"); certificate ca; try (inputstream cainput = getresources().openrawresource(r.raw.metadata)) { ca = cf.generatecertificate(cainput); system.out.println(\"metadata=\" + ((x509certificate) ca).getissuerdn()); } string keystoretype = keystore.getdefaulttype(); keystore keystore = keystore.getinstance(keystoretype); keystore.load(null, null); keystore.setcertificateentry(\"metadata\", ca); string tmfalgorithm = trustmanagerfactory.getdefaultalgorithm(); trustmanagerfactory tmf = trustmanagerfactory.getinstance(tmfalgorithm); tmf.init(keystore); sslcontext context = sslcontext.getinstance(\"tls\"); context.init(null, tmf.gettrustmanagers(), null); metadatasocketfactory = context.getsocketfactory(); } catch (certificateexception e) { e.printstacktrace(); } catch (nosuchalgorithmexception e) { e.printstacktrace(); } catch (keystoreexception e) { e.printstacktrace(); } catch (keymanagementexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } log.d(\"getreplayserverip\", \"server ip: \" + server); } catch (nullpointerexception e) { e.printstacktrace(); log.w(\"getreplayserverip\", \"invalid ip address!\"); } enabletiming = \"true\"; dotest = false; int port = integer.valueof(config.get(\"result_port\")); analyzerserverurl = (\"https:\/\/\" + server + \":\" + port + \"\/results\"); date = new date(); results = new jsonarray(); log.d(\"result channel\", \"path: \" + server + \" port: \" + port); confirmationreplays = sharedprefs.getboolean(\"confirmationreplays\", true); boolean hasid = sharedprefs.getboolean(\"hasid\", false); if (!hasid) { randomid = new randomstring(10).nextstring(); sharedpreferences.editor editor = sharedprefs.edit(); editor.putboolean(\"hasid\", true); editor.putstring(\"id\", randomid); editor.apply(); } else { randomid = sharedprefs.getstring(\"id\", null); } a_threshold = integer.parseint(objects.requirenonnull(sharedprefs.getstring(\"pref_threshold_area\", \"10\"))); ks2pvalue_threshold = integer.parseint(objects.requirenonnull(sharedprefs.getstring(\"pref_threshold_ks2p\", \"5\"))); confirmationreplays = sharedprefs.getboolean(\"pref_multiple_tests\", true); settings = getsharedpreferences(status, context.mode_private); boolean hashistorycount = settings.getboolean(\"hashistorycount\", false); if (!hashistorycount) { historycount = 0; sharedpreferences.editor editor = settings.edit(); editor.putboolean(\"hashistorycount\", true); editor.putint(\"historycount\", historycount); editor.apply(); } else { historycount = settings.getint(\"historycount\", -1); } if (historycount == -1) throw new runtimeexception(); config.set(\"timing\", enabletiming); while (server == null) { try { thread.sleep(1000); } catch (interruptedexception e) { e.printstacktrace(); } } config.set(\"server\", server); config.set(\"jitter\", \"true\"); config.set(\"publicip\", \"\"); new thread(new runnable() { public void run() { config.set(\"publicip\", getpublicip(\"80\")); } }).start(); while (config.get(\"publicip\").equals(\"\")) { try { thread.sleep(500); } catch (interruptedexception e) { e.printstacktrace(); } } log.d(\"replay\", \"public ip: \" + config.get(\"publicip\")); } for (applicationbean app : selectedapps) { rerun = false; this.app = app; runtest(); } if (iscancelled()) { return null; } if (results.length() > 0) { log.d(\"result channel\", \"storing results\"); saveresults(); } if (iscancelled()) { return null; } showfinishdialog(); log.d(\"result channel\", \"exiting normally\"); return null; }","repo":"dng24\/wehe-android","label":[1,1,0,1]}
{"id":23038,"original_code":"@Override\n    public void resetToPreferredSizes() {\n        Insets i = getInsets();\n        if (getOrientation() == VERTICAL_SPLIT) {\n            int h = getHeight() - i.top - i.bottom - getDividerSize();\n            int topH = getTopComponent().getPreferredSize().height;\n            int bottomH = getBottomComponent().getPreferredSize().height;\n            int extraSpace = h - topH - bottomH;\n            \/\/ we have more space than necessary; resize to give each at least\n            \/\/ preferred size\n            if (extraSpace >= 0) {\n                setDividerLocation(i.top + topH\n                                   + ((int) (extraSpace * getResizeWeight() + .5)));\n            }\n            \/\/ TODO implement shrinking excess space to ensure that one has\n            \/\/ preferred and nothing more\n        } else {\n            int w = getWidth() - i.left - i.right - getDividerSize();\n            int leftH = getLeftComponent().getPreferredSize().width;\n            int rightH = getRightComponent().getPreferredSize().width;\n            int extraSpace = w - leftH - rightH;\n            \/\/ we have more space than necessary; resize to give each at least\n            \/\/ preferred size\n            if (extraSpace >= 0) {\n                setDividerLocation(i.left + leftH\n                                   + ((int) (extraSpace * getResizeWeight() + .5)));\n            }\n            \/\/ TODO implement shrinking excess space to ensure that one has\n            \/\/ preferred and nothing more\n        }\n    }","code_wo_comment":"@Override\n    public void resetToPreferredSizes() {\n        Insets i = getInsets();\n        if (getOrientation() == VERTICAL_SPLIT) {\n            int h = getHeight() - i.top - i.bottom - getDividerSize();\n            int topH = getTopComponent().getPreferredSize().height;\n            int bottomH = getBottomComponent().getPreferredSize().height;\n            int extraSpace = h - topH - bottomH;\n           \n           \n            if (extraSpace >= 0) {\n                setDividerLocation(i.top + topH\n                                   + ((int) (extraSpace * getResizeWeight() + .5)));\n            }\n           \n           \n        } else {\n            int w = getWidth() - i.left - i.right - getDividerSize();\n            int leftH = getLeftComponent().getPreferredSize().width;\n            int rightH = getRightComponent().getPreferredSize().width;\n            int extraSpace = w - leftH - rightH;\n           \n           \n            if (extraSpace >= 0) {\n                setDividerLocation(i.left + leftH\n                                   + ((int) (extraSpace * getResizeWeight() + .5)));\n            }\n           \n           \n        }\n    }","cleancode":"@override public void resettopreferredsizes() { insets i = getinsets(); if (getorientation() == vertical_split) { int h = getheight() - i.top - i.bottom - getdividersize(); int toph = gettopcomponent().getpreferredsize().height; int bottomh = getbottomcomponent().getpreferredsize().height; int extraspace = h - toph - bottomh; if (extraspace >= 0) { setdividerlocation(i.top + toph + ((int) (extraspace * getresizeweight() + .5))); } } else { int w = getwidth() - i.left - i.right - getdividersize(); int lefth = getleftcomponent().getpreferredsize().width; int righth = getrightcomponent().getpreferredsize().width; int extraspace = w - lefth - righth; if (extraspace >= 0) { setdividerlocation(i.left + lefth + ((int) (extraspace * getresizeweight() + .5))); } } }","repo":"g-pechorin\/flexdock","label":[0,1,0,0]}
{"id":23040,"original_code":"@Override\n  public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n    \/\/ Update each of the widgets with the remote adapter\n    for (int i = 0; i < appWidgetIds.length; ++i) {\n      RemoteViews layout = buildLayout(context, appWidgetIds[i]);\n      appWidgetManager.updateAppWidget(appWidgetIds[i], layout);\n    }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n    \/\/ wtf another google bug?\n    this.onEnabled(context);\n  }","code_wo_comment":"@Override\n  public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {\n   \n    for (int i = 0; i < appWidgetIds.length; ++i) {\n      RemoteViews layout = buildLayout(context, appWidgetIds[i]);\n      appWidgetManager.updateAppWidget(appWidgetIds[i], layout);\n    }\n    super.onUpdate(context, appWidgetManager, appWidgetIds);\n   \n    this.onEnabled(context);\n  }","cleancode":"@override public void onupdate(context context, appwidgetmanager appwidgetmanager, int[] appwidgetids) { for (int i = 0; i < appwidgetids.length; ++i) { remoteviews layout = buildlayout(context, appwidgetids[i]); appwidgetmanager.updateappwidget(appwidgetids[i], layout); } super.onupdate(context, appwidgetmanager, appwidgetids); this.onenabled(context); }","repo":"ekux44\/LampShade","label":[0,0,1,0]}
{"id":14870,"original_code":"private void onApnChanged() {\n        DctConstants.State overallState = getOverallState();\n        boolean isDisconnected = (overallState == DctConstants.State.IDLE ||\n                overallState == DctConstants.State.FAILED);\n        if (mPhone instanceof GSMPhone) {\n            \/\/ The \"current\" may no longer be valid.  MMS depends on this to send properly. TBD\n            ((GSMPhone)mPhone).updateCurrentCarrierInProvider();\n        }\n        \/\/ TODO: It'd be nice to only do this if the changed entrie(s)\n        \/\/ match the current operator.\n        if (DBG) log(\"onApnChanged: createAllApnList and cleanUpAllConnections\");\n        createAllApnList();\n        setInitialAttachApn();\n        cleanUpAllConnections(!isDisconnected, Phone.REASON_APN_CHANGED);\n        if (isDisconnected) {\n            setupDataOnConnectableApns(Phone.REASON_APN_CHANGED);\n        }\n    }","code_wo_comment":"private void onApnChanged() {\n        DctConstants.State overallState = getOverallState();\n        boolean isDisconnected = (overallState == DctConstants.State.IDLE ||\n                overallState == DctConstants.State.FAILED);\n        if (mPhone instanceof GSMPhone) {\n           \n            ((GSMPhone)mPhone).updateCurrentCarrierInProvider();\n        }\n       \n       \n        if (DBG) log(\"onApnChanged: createAllApnList and cleanUpAllConnections\");\n        createAllApnList();\n        setInitialAttachApn();\n        cleanUpAllConnections(!isDisconnected, Phone.REASON_APN_CHANGED);\n        if (isDisconnected) {\n            setupDataOnConnectableApns(Phone.REASON_APN_CHANGED);\n        }\n    }","cleancode":"private void onapnchanged() { dctconstants.state overallstate = getoverallstate(); boolean isdisconnected = (overallstate == dctconstants.state.idle || overallstate == dctconstants.state.failed); if (mphone instanceof gsmphone) { ((gsmphone)mphone).updatecurrentcarrierinprovider(); } if (dbg) log(\"onapnchanged: createallapnlist and cleanupallconnections\"); createallapnlist(); setinitialattachapn(); cleanupallconnections(!isdisconnected, phone.reason_apn_changed); if (isdisconnected) { setupdataonconnectableapns(phone.reason_apn_changed); } }","repo":"efortuna\/AndroidSDKClone","label":[1,0,0,0]}
{"id":14914,"original_code":"public static Class<?> getRawType(Type type) {\n\t\tif (type instanceof Class<?>) {\n\t\t\t\/\/ type is a normal class.\n\t\t\treturn (Class<?>)type;\n\t\t}\n\t\telse if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType parameterizedType = (ParameterizedType)type;\n\t\t\t\/\/ I'm not exactly sure why getRawType() returns Type instead of Class.\n\t\t\t\/\/ Neal isn't either but suspects some pathological case related\n\t\t\t\/\/ to nested classes exists.\n\t\t\tType rawType = parameterizedType.getRawType();\n\t\t\tAsserts.isTrue(rawType instanceof Class);\n\t\t\treturn (Class<?>)rawType;\n\t\t}\n\t\telse if (type instanceof GenericArrayType) {\n\t\t\tType componentType = ((GenericArrayType)type).getGenericComponentType();\n\t\t\treturn Array.newInstance(getRawType(componentType), 0).getClass();\n\t\t}\n\t\telse if (type instanceof TypeVariable) {\n\t\t\t\/\/ we could use the variable's bounds, but that won't work if there are multiple.\n\t\t\t\/\/ having a raw type that's more general than necessary is okay\n\t\t\treturn Object.class;\n\t\t}\n\t\telse if (type instanceof WildcardType) {\n\t\t\treturn getRawType(((WildcardType)type).getUpperBounds()[0]);\n\t\t}\n\t\telse {\n\t\t\tString className = type == null ? \"null\" : type.getClass().getName();\n\t\t\tthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n\t\t\t\t\t+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n\t\t}\n\t}","code_wo_comment":"public static Class<?> getRawType(Type type) {\n\t\tif (type instanceof Class<?>) {\n\t\t\n\t\t\treturn (Class<?>)type;\n\t\t}\n\t\telse if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType parameterizedType = (ParameterizedType)type;\n\t\t\n\t\t\n\t\t\n\t\t\tType rawType = parameterizedType.getRawType();\n\t\t\tAsserts.isTrue(rawType instanceof Class);\n\t\t\treturn (Class<?>)rawType;\n\t\t}\n\t\telse if (type instanceof GenericArrayType) {\n\t\t\tType componentType = ((GenericArrayType)type).getGenericComponentType();\n\t\t\treturn Array.newInstance(getRawType(componentType), 0).getClass();\n\t\t}\n\t\telse if (type instanceof TypeVariable) {\n\t\t\n\t\t\n\t\t\treturn Object.class;\n\t\t}\n\t\telse if (type instanceof WildcardType) {\n\t\t\treturn getRawType(((WildcardType)type).getUpperBounds()[0]);\n\t\t}\n\t\telse {\n\t\t\tString className = type == null ? \"null\" : type.getClass().getName();\n\t\t\tthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n\t\t\t\t\t+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n\t\t}\n\t}","cleancode":"public static class<?> getrawtype(type type) { if (type instanceof class<?>) { return (class<?>)type; } else if (type instanceof parameterizedtype) { parameterizedtype parameterizedtype = (parameterizedtype)type; type rawtype = parameterizedtype.getrawtype(); asserts.istrue(rawtype instanceof class); return (class<?>)rawtype; } else if (type instanceof genericarraytype) { type componenttype = ((genericarraytype)type).getgenericcomponenttype(); return array.newinstance(getrawtype(componenttype), 0).getclass(); } else if (type instanceof typevariable) { return object.class; } else if (type instanceof wildcardtype) { return getrawtype(((wildcardtype)type).getupperbounds()[0]); } else { string classname = type == null ? \"null\" : type.getclass().getname(); throw new illegalargumentexception(\"expected a class, parameterizedtype, or \" + \"genericarraytype, but <\" + type + \"> is of type \" + classname); } }","repo":"foolite\/panda","label":[1,0,0,0]}
{"id":31546,"original_code":"private void processResponseBody(List<AudioGson> audioGsons) {\n        Log.i(getClass().getName(), \"processResponseBody\");\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                Log.i(getClass().getName(), \"run\");\n                RoomDb roomDb = RoomDb.getDatabase(getContext());\n                AudioDao audioDao = roomDb.audioDao();\n                \/\/ Empty the database table before downloading up-to-date content\n                audioDao.deleteAll();\n                \/\/ TODO: also delete corresponding audio files (only those that are no longer used)\n                for (AudioGson audioGson : audioGsons) {\n                    Log.i(getClass().getName(), \"audioGson.getId(): \" + audioGson.getId());\n                    Audio audio = GsonToRoomConverter.getAudio(audioGson);\n                    \/\/ Check if the corresponding audio file has already been downloaded\n                    File audioFile = FileHelper.getAudioFile(audioGson, getContext());\n                    Log.i(getClass().getName(), \"audioFile: \" + audioFile);\n                    Log.i(getClass().getName(), \"audioFile.exists(): \" + audioFile.exists());\n                    if (!audioFile.exists()) {\n                        \/\/ Download file bytes\n                        BaseApplication baseApplication = (BaseApplication) getActivity().getApplication();\n                        String downloadUrl = baseApplication.getBaseUrl() + audioGson.getBytesUrl();\n                        Log.i(getClass().getName(), \"downloadUrl: \" + downloadUrl);\n                        byte[] bytes = MultimediaDownloader.downloadFileBytes(downloadUrl);\n                        Log.i(getClass().getName(), \"bytes.length: \" + bytes.length);\n                        \/\/ Store the downloaded file in the external storage directory\n                        try {\n                            FileOutputStream fileOutputStream = new FileOutputStream(audioFile);\n                            fileOutputStream.write(bytes);\n                        } catch (FileNotFoundException e) {\n                            Log.e(getClass().getName(), null, e);\n                        } catch (IOException e) {\n                            Log.e(getClass().getName(), null, e);\n                        }\n                        Log.i(getClass().getName(), \"audioFile.exists(): \" + audioFile.exists());\n                    }\n                    \/\/ Store the Audio in the database\n                    audioDao.insert(audio);\n                    Log.i(getClass().getName(), \"Stored Audio in database with ID \" + audio.getId());\n                }\n                \/\/ Update the UI\n                List<Audio> audios = audioDao.loadAll();\n                Log.i(getClass().getName(), \"audios.size(): \" + audios.size());\n                getActivity().runOnUiThread(() -> {\n                    textView.setText(\"audios.size(): \" + audios.size());\n                    Snackbar.make(textView, \"audios.size(): \" + audios.size(), Snackbar.LENGTH_LONG).show();\n                    progressBar.setVisibility(View.GONE);\n                });\n            }\n        });\n    }","code_wo_comment":"private void processResponseBody(List<AudioGson> audioGsons) {\n        Log.i(getClass().getName(), \"processResponseBody\");\n        ExecutorService executorService = Executors.newSingleThreadExecutor();\n        executorService.execute(new Runnable() {\n            @Override\n            public void run() {\n                Log.i(getClass().getName(), \"run\");\n                RoomDb roomDb = RoomDb.getDatabase(getContext());\n                AudioDao audioDao = roomDb.audioDao();\n               \n                audioDao.deleteAll();\n               \n                for (AudioGson audioGson : audioGsons) {\n                    Log.i(getClass().getName(), \"audioGson.getId(): \" + audioGson.getId());\n                    Audio audio = GsonToRoomConverter.getAudio(audioGson);\n                   \n                    File audioFile = FileHelper.getAudioFile(audioGson, getContext());\n                    Log.i(getClass().getName(), \"audioFile: \" + audioFile);\n                    Log.i(getClass().getName(), \"audioFile.exists(): \" + audioFile.exists());\n                    if (!audioFile.exists()) {\n                       \n                        BaseApplication baseApplication = (BaseApplication) getActivity().getApplication();\n                        String downloadUrl = baseApplication.getBaseUrl() + audioGson.getBytesUrl();\n                        Log.i(getClass().getName(), \"downloadUrl: \" + downloadUrl);\n                        byte[] bytes = MultimediaDownloader.downloadFileBytes(downloadUrl);\n                        Log.i(getClass().getName(), \"bytes.length: \" + bytes.length);\n                       \n                        try {\n                            FileOutputStream fileOutputStream = new FileOutputStream(audioFile);\n                            fileOutputStream.write(bytes);\n                        } catch (FileNotFoundException e) {\n                            Log.e(getClass().getName(), null, e);\n                        } catch (IOException e) {\n                            Log.e(getClass().getName(), null, e);\n                        }\n                        Log.i(getClass().getName(), \"audioFile.exists(): \" + audioFile.exists());\n                    }\n                   \n                    audioDao.insert(audio);\n                    Log.i(getClass().getName(), \"Stored Audio in database with ID \" + audio.getId());\n                }\n               \n                List<Audio> audios = audioDao.loadAll();\n                Log.i(getClass().getName(), \"audios.size(): \" + audios.size());\n                getActivity().runOnUiThread(() -> {\n                    textView.setText(\"audios.size(): \" + audios.size());\n                    Snackbar.make(textView, \"audios.size(): \" + audios.size(), Snackbar.LENGTH_LONG).show();\n                    progressBar.setVisibility(View.GONE);\n                });\n            }\n        });\n    }","cleancode":"private void processresponsebody(list<audiogson> audiogsons) { log.i(getclass().getname(), \"processresponsebody\"); executorservice executorservice = executors.newsinglethreadexecutor(); executorservice.execute(new runnable() { @override public void run() { log.i(getclass().getname(), \"run\"); roomdb roomdb = roomdb.getdatabase(getcontext()); audiodao audiodao = roomdb.audiodao(); audiodao.deleteall(); for (audiogson audiogson : audiogsons) { log.i(getclass().getname(), \"audiogson.getid(): \" + audiogson.getid()); audio audio = gsontoroomconverter.getaudio(audiogson); file audiofile = filehelper.getaudiofile(audiogson, getcontext()); log.i(getclass().getname(), \"audiofile: \" + audiofile); log.i(getclass().getname(), \"audiofile.exists(): \" + audiofile.exists()); if (!audiofile.exists()) { baseapplication baseapplication = (baseapplication) getactivity().getapplication(); string downloadurl = baseapplication.getbaseurl() + audiogson.getbytesurl(); log.i(getclass().getname(), \"downloadurl: \" + downloadurl); byte[] bytes = multimediadownloader.downloadfilebytes(downloadurl); log.i(getclass().getname(), \"bytes.length: \" + bytes.length); try { fileoutputstream fileoutputstream = new fileoutputstream(audiofile); fileoutputstream.write(bytes); } catch (filenotfoundexception e) { log.e(getclass().getname(), null, e); } catch (ioexception e) { log.e(getclass().getname(), null, e); } log.i(getclass().getname(), \"audiofile.exists(): \" + audiofile.exists()); } audiodao.insert(audio); log.i(getclass().getname(), \"stored audio in database with id \" + audio.getid()); } list<audio> audios = audiodao.loadall(); log.i(getclass().getname(), \"audios.size(): \" + audios.size()); getactivity().runonuithread(() -> { textview.settext(\"audios.size(): \" + audios.size()); snackbar.make(textview, \"audios.size(): \" + audios.size(), snackbar.length_long).show(); progressbar.setvisibility(view.gone); }); } }); }","repo":"elimu-ai\/content-provider","label":[0,1,0,0]}
{"id":15539,"original_code":"@Override\n\tprotected EntityManager getEntityManager() {\n\t\treturn entityManager;\n\t}","code_wo_comment":"@Override\n\tprotected EntityManager getEntityManager() {\n\t\treturn entityManager;\n\t}","cleancode":"@override protected entitymanager getentitymanager() { return entitymanager; }","repo":"dwws-ufes\/2020-doeLivro","label":[0,0,0,0]}
{"id":15540,"original_code":"@Override\n\tpublic List<Book> getBookByTitle(String title) {\n\t\t\/\/ FIXME: auto-generated method stub\n\t\treturn null;\n\t}","code_wo_comment":"@Override\n\tpublic List<Book> getBookByTitle(String title) {\n\t\n\t\treturn null;\n\t}","cleancode":"@override public list<book> getbookbytitle(string title) { return null; }","repo":"dwws-ufes\/2020-doeLivro","label":[1,0,0,0]}
{"id":15541,"original_code":"@Override\n\tpublic List<Book> getBookByAuthor(String author) {\n\t\t\/\/ FIXME: auto-generated method stub\n\t\treturn null;\n\t}","code_wo_comment":"@Override\n\tpublic List<Book> getBookByAuthor(String author) {\n\t\n\t\treturn null;\n\t}","cleancode":"@override public list<book> getbookbyauthor(string author) { return null; }","repo":"dwws-ufes\/2020-doeLivro","label":[0,1,0,0]}
{"id":15542,"original_code":"@Override\n\tpublic List<Book> getBookList() {\n\t\t\/\/ FIXME: auto-generated method stub\n\t\treturn null;\n\t}","code_wo_comment":"@Override\n\tpublic List<Book> getBookList() {\n\t\n\t\treturn null;\n\t}","cleancode":"@override public list<book> getbooklist() { return null; }","repo":"dwws-ufes\/2020-doeLivro","label":[0,1,0,0]}
{"id":31991,"original_code":"public static void doGoTo( String strQualifedType )\n  {\n    EditorUtilities.showWaitCursor( true );\n    try\n    {\n      IType type = TypeSystem.getByFullNameIfValid( strQualifedType );\n      if( type == null )\n      {\n        return;\n      }\n      IFile[] sourceFiles = type.getSourceFiles();\n      if( sourceFiles != null && sourceFiles.length > 0 )\n      {\n        \/\/## todo: maybe support multiple files here?\n        IFile sourceFile = sourceFiles[0];\n        LabFrame.instance().openFile( PathUtil.create( sourceFile.toURI() ) );\n      }\n    }\n    catch( Exception e )\n    {\n      throw new RuntimeException( e );\n    }\n    finally\n    {\n      EditorUtilities.showWaitCursor( false );\n    }\n  }","code_wo_comment":"public static void doGoTo( String strQualifedType )\n  {\n    EditorUtilities.showWaitCursor( true );\n    try\n    {\n      IType type = TypeSystem.getByFullNameIfValid( strQualifedType );\n      if( type == null )\n      {\n        return;\n      }\n      IFile[] sourceFiles = type.getSourceFiles();\n      if( sourceFiles != null && sourceFiles.length > 0 )\n      {\n       \n        IFile sourceFile = sourceFiles[0];\n        LabFrame.instance().openFile( PathUtil.create( sourceFile.toURI() ) );\n      }\n    }\n    catch( Exception e )\n    {\n      throw new RuntimeException( e );\n    }\n    finally\n    {\n      EditorUtilities.showWaitCursor( false );\n    }\n  }","cleancode":"public static void dogoto( string strqualifedtype ) { editorutilities.showwaitcursor( true ); try { itype type = typesystem.getbyfullnameifvalid( strqualifedtype ); if( type == null ) { return; } ifile[] sourcefiles = type.getsourcefiles(); if( sourcefiles != null && sourcefiles.length > 0 ) { ifile sourcefile = sourcefiles[0]; labframe.instance().openfile( pathutil.create( sourcefile.touri() ) ); } } catch( exception e ) { throw new runtimeexception( e ); } finally { editorutilities.showwaitcursor( false ); } }","repo":"dmcreyno\/gosu-lang","label":[1,0,0,0]}
{"id":15967,"original_code":"public Table<Locator, String, String> getMetadataValues(Set<Locator> locators) {\n        ColumnFamily CF = CassandraModel.CF_METRIC_METADATA;\n        boolean isBatch = locators.size() > 1;\n        Table<Locator, String, String> metaTable = HashBasedTable.create();\n        Timer.Context ctx = isBatch ? Instrumentation.getBatchReadTimerContext(CF) : Instrumentation.getReadTimerContext(CF);\n        try {\n            \/\/ We don't paginate this call. So we should make sure the number of reads is tolerable.\n            \/\/ TODO: Think about paginating this call.\n            OperationResult<Rows<Locator, String>> query = keyspace\n                    .prepareQuery(CF)\n                    .getKeySlice(locators)\n                    .execute();\n            for (Row<Locator, String> row : query.getResult()) {\n                ColumnList<String> columns = row.getColumns();\n                for (Column<String> column : columns) {\n                    String metaValue = column.getValue(StringMetadataSerializer.get());\n                    String metaKey = column.getName();\n                    metaTable.put(row.getKey(), metaKey, metaValue);\n                }\n            }\n        } catch (ConnectionException e) {\n            if (e instanceof NotFoundException) { \/\/ TODO: Not really sure what happens when one of the keys is not found.\n                Instrumentation.markNotFound(CF);\n            } else {\n                if (isBatch) { Instrumentation.markBatchReadError(e); }\n                else { Instrumentation.markReadError(e); }\n            }\n            log.warn((isBatch ? \"Batch \" : \"\") + \" read query failed for column family \" + CF.getName(), e);\n        } finally {\n            ctx.stop();\n        }\n        return metaTable;\n    }","code_wo_comment":"public Table<Locator, String, String> getMetadataValues(Set<Locator> locators) {\n        ColumnFamily CF = CassandraModel.CF_METRIC_METADATA;\n        boolean isBatch = locators.size() > 1;\n        Table<Locator, String, String> metaTable = HashBasedTable.create();\n        Timer.Context ctx = isBatch ? Instrumentation.getBatchReadTimerContext(CF) : Instrumentation.getReadTimerContext(CF);\n        try {\n           \n           \n            OperationResult<Rows<Locator, String>> query = keyspace\n                    .prepareQuery(CF)\n                    .getKeySlice(locators)\n                    .execute();\n            for (Row<Locator, String> row : query.getResult()) {\n                ColumnList<String> columns = row.getColumns();\n                for (Column<String> column : columns) {\n                    String metaValue = column.getValue(StringMetadataSerializer.get());\n                    String metaKey = column.getName();\n                    metaTable.put(row.getKey(), metaKey, metaValue);\n                }\n            }\n        } catch (ConnectionException e) {\n            if (e instanceof NotFoundException) {\n                Instrumentation.markNotFound(CF);\n            } else {\n                if (isBatch) { Instrumentation.markBatchReadError(e); }\n                else { Instrumentation.markReadError(e); }\n            }\n            log.warn((isBatch ? \"Batch \" : \"\") + \" read query failed for column family \" + CF.getName(), e);\n        } finally {\n            ctx.stop();\n        }\n        return metaTable;\n    }","cleancode":"public table<locator, string, string> getmetadatavalues(set<locator> locators) { columnfamily cf = cassandramodel.cf_metric_metadata; boolean isbatch = locators.size() > 1; table<locator, string, string> metatable = hashbasedtable.create(); timer.context ctx = isbatch ? instrumentation.getbatchreadtimercontext(cf) : instrumentation.getreadtimercontext(cf); try { operationresult<rows<locator, string>> query = keyspace .preparequery(cf) .getkeyslice(locators) .execute(); for (row<locator, string> row : query.getresult()) { columnlist<string> columns = row.getcolumns(); for (column<string> column : columns) { string metavalue = column.getvalue(stringmetadataserializer.get()); string metakey = column.getname(); metatable.put(row.getkey(), metakey, metavalue); } } } catch (connectionexception e) { if (e instanceof notfoundexception) { instrumentation.marknotfound(cf); } else { if (isbatch) { instrumentation.markbatchreaderror(e); } else { instrumentation.markreaderror(e); } } log.warn((isbatch ? \"batch \" : \"\") + \" read query failed for column family \" + cf.getname(), e); } finally { ctx.stop(); } return metatable; }","repo":"dlobue\/blueflood","label":[1,0,0,0]}
{"id":15968,"original_code":"private Map<Locator, ColumnList<Long>> getColumnsFromDB(List<Locator> locators, ColumnFamily<Locator, Long> CF,\n                                                            Range range) {\n        if (range.getStart() > range.getStop()) {\n            throw new RuntimeException(String.format(\"Invalid rollup range: \", range.toString()));\n        }\n        boolean isBatch = locators.size() != 1;\n        final Map<Locator, ColumnList<Long>> columns = new HashMap<Locator, ColumnList<Long>>();\n        final RangeBuilder rangeBuilder = new RangeBuilder().setStart(range.getStart()).setEnd(range.getStop());\n        Timer.Context ctx = isBatch ? Instrumentation.getBatchReadTimerContext(CF) : Instrumentation.getReadTimerContext(CF);\n        try {\n            \/\/ We don't paginate this call. So we should make sure the number of reads is tolerable.\n            \/\/ TODO: Think about paginating this call.\n            OperationResult<Rows<Locator, Long>> query = keyspace\n                    .prepareQuery(CF)\n                    .getKeySlice(locators)\n                    .withColumnRange(rangeBuilder.build())\n                    .execute();\n            for (Row<Locator, Long> row : query.getResult()) {\n                columns.put(row.getKey(), row.getColumns());\n            }\n        } catch (ConnectionException e) {\n            if (e instanceof NotFoundException) { \/\/ TODO: Not really sure what happens when one of the keys is not found.\n                Instrumentation.markNotFound(CF);\n            } else {\n                if (isBatch) { Instrumentation.markBatchReadError(e); }\n                else { Instrumentation.markReadError(e); }\n            }\n            log.warn((isBatch ? \"Batch \" : \"\") + \" read query failed for column family \" + CF.getName(), e);\n        } finally {\n            ctx.stop();\n        }\n        return columns;\n    }","code_wo_comment":"private Map<Locator, ColumnList<Long>> getColumnsFromDB(List<Locator> locators, ColumnFamily<Locator, Long> CF,\n                                                            Range range) {\n        if (range.getStart() > range.getStop()) {\n            throw new RuntimeException(String.format(\"Invalid rollup range: \", range.toString()));\n        }\n        boolean isBatch = locators.size() != 1;\n        final Map<Locator, ColumnList<Long>> columns = new HashMap<Locator, ColumnList<Long>>();\n        final RangeBuilder rangeBuilder = new RangeBuilder().setStart(range.getStart()).setEnd(range.getStop());\n        Timer.Context ctx = isBatch ? Instrumentation.getBatchReadTimerContext(CF) : Instrumentation.getReadTimerContext(CF);\n        try {\n           \n           \n            OperationResult<Rows<Locator, Long>> query = keyspace\n                    .prepareQuery(CF)\n                    .getKeySlice(locators)\n                    .withColumnRange(rangeBuilder.build())\n                    .execute();\n            for (Row<Locator, Long> row : query.getResult()) {\n                columns.put(row.getKey(), row.getColumns());\n            }\n        } catch (ConnectionException e) {\n            if (e instanceof NotFoundException) {\n                Instrumentation.markNotFound(CF);\n            } else {\n                if (isBatch) { Instrumentation.markBatchReadError(e); }\n                else { Instrumentation.markReadError(e); }\n            }\n            log.warn((isBatch ? \"Batch \" : \"\") + \" read query failed for column family \" + CF.getName(), e);\n        } finally {\n            ctx.stop();\n        }\n        return columns;\n    }","cleancode":"private map<locator, columnlist<long>> getcolumnsfromdb(list<locator> locators, columnfamily<locator, long> cf, range range) { if (range.getstart() > range.getstop()) { throw new runtimeexception(string.format(\"invalid rollup range: \", range.tostring())); } boolean isbatch = locators.size() != 1; final map<locator, columnlist<long>> columns = new hashmap<locator, columnlist<long>>(); final rangebuilder rangebuilder = new rangebuilder().setstart(range.getstart()).setend(range.getstop()); timer.context ctx = isbatch ? instrumentation.getbatchreadtimercontext(cf) : instrumentation.getreadtimercontext(cf); try { operationresult<rows<locator, long>> query = keyspace .preparequery(cf) .getkeyslice(locators) .withcolumnrange(rangebuilder.build()) .execute(); for (row<locator, long> row : query.getresult()) { columns.put(row.getkey(), row.getcolumns()); } } catch (connectionexception e) { if (e instanceof notfoundexception) { instrumentation.marknotfound(cf); } else { if (isbatch) { instrumentation.markbatchreaderror(e); } else { instrumentation.markreaderror(e); } } log.warn((isbatch ? \"batch \" : \"\") + \" read query failed for column family \" + cf.getname(), e); } finally { ctx.stop(); } return columns; }","repo":"dlobue\/blueflood","label":[1,0,0,0]}
{"id":16078,"original_code":"void SetupDataDialog_componentAdded(java.awt.event.ContainerEvent event)\n\t{\n\t\t\/\/ to do: code goes here.\n\t}","code_wo_comment":"void SetupDataDialog_componentAdded(java.awt.event.ContainerEvent event)\n\t{\n\t\n\t}","cleancode":"void setupdatadialog_componentadded(java.awt.event.containerevent event) { }","repo":"fluffynukeit\/mdsplus","label":[0,1,0,0]}
{"id":7897,"original_code":"private Set<String> getSpammyItems() {\n    Set<String> spammyItems = null;\n    try {\n      spammyItems = new HashSet<String>(Files.readAllLines(SPAMMY_ITEM_FILE.toPath()));\n    } catch (IOException e) {\n      \/\/ TODO Auto-generated catch block\n      e.printStackTrace();\n      \/\/ TODO: Do something intelligent.\n    }\n    return spammyItems;\n  }","code_wo_comment":"private Set<String> getSpammyItems() {\n    Set<String> spammyItems = null;\n    try {\n      spammyItems = new HashSet<String>(Files.readAllLines(SPAMMY_ITEM_FILE.toPath()));\n    } catch (IOException e) {\n     \n      e.printStackTrace();\n     \n    }\n    return spammyItems;\n  }","cleancode":"private set<string> getspammyitems() { set<string> spammyitems = null; try { spammyitems = new hashset<string>(files.readalllines(spammy_item_file.topath())); } catch (ioexception e) { e.printstacktrace(); } return spammyitems; }","repo":"edmazur\/everquest-robot-stanvern","label":[1,0,0,0]}
{"id":7896,"original_code":"public void initialize() {\n    PayloadTrieBuilder<Item> itemsByNameBuilder = PayloadTrie.builder();\n    itemsByNameBuilder\n        .ignoreCase()\n        .ignoreOverlaps();\n    spammyItems = getSpammyItems();\n    BufferedReader bufferedReader;\n    try {\n      bufferedReader = new BufferedReader(new FileReader(ITEM_FILE));\n      String line = null;\n      while ((line = bufferedReader.readLine()) != null) {\n        String[] parts = line.split(\"\\t\");\n        String name = parts[0];\n        String url = parts[1];\n        Item item = new Item(name, url);\n        itemsByNameBuilder.addKeyword(normalize(name), item);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n      \/\/ TODO: Do something intelligent.\n    } catch (IOException e) {\n      e.printStackTrace();\n      \/\/ TODO: Do something intelligent.\n    }\n    itemsByName = itemsByNameBuilder.build();\n  }","code_wo_comment":"public void initialize() {\n    PayloadTrieBuilder<Item> itemsByNameBuilder = PayloadTrie.builder();\n    itemsByNameBuilder\n        .ignoreCase()\n        .ignoreOverlaps();\n    spammyItems = getSpammyItems();\n    BufferedReader bufferedReader;\n    try {\n      bufferedReader = new BufferedReader(new FileReader(ITEM_FILE));\n      String line = null;\n      while ((line = bufferedReader.readLine()) != null) {\n        String[] parts = line.split(\"\\t\");\n        String name = parts[0];\n        String url = parts[1];\n        Item item = new Item(name, url);\n        itemsByNameBuilder.addKeyword(normalize(name), item);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n     \n    } catch (IOException e) {\n      e.printStackTrace();\n     \n    }\n    itemsByName = itemsByNameBuilder.build();\n  }","cleancode":"public void initialize() { payloadtriebuilder<item> itemsbynamebuilder = payloadtrie.builder(); itemsbynamebuilder .ignorecase() .ignoreoverlaps(); spammyitems = getspammyitems(); bufferedreader bufferedreader; try { bufferedreader = new bufferedreader(new filereader(item_file)); string line = null; while ((line = bufferedreader.readline()) != null) { string[] parts = line.split(\"\\t\"); string name = parts[0]; string url = parts[1]; item item = new item(name, url); itemsbynamebuilder.addkeyword(normalize(name), item); } } catch (filenotfoundexception e) { e.printstacktrace(); } catch (ioexception e) { e.printstacktrace(); } itemsbyname = itemsbynamebuilder.build(); }","repo":"edmazur\/everquest-robot-stanvern","label":[1,0,0,0]}
{"id":24462,"original_code":"private void bordersChanged() {\n    JComponent component = (JComponent)toAWTComponent();\n    component.setBorder(JBUI.Borders.empty());\n    Collection<BorderInfo> borders = dataObject().getBorders();\n    Map<BorderPosition, Integer> emptyBorders = new LinkedHashMap<>();\n    for (BorderInfo border : borders) {\n      if (border.getBorderStyle() == BorderStyle.EMPTY) {\n        emptyBorders.put(border.getBorderPosition(), border.getWidth());\n      }\n    }\n    if (!emptyBorders.isEmpty()) {\n      component.setBorder(JBUI.Borders.empty(getBorderSize(emptyBorders, BorderPosition.TOP), getBorderSize(emptyBorders, BorderPosition.LEFT), getBorderSize(emptyBorders, BorderPosition.BOTTOM),\n                                             getBorderSize(emptyBorders, BorderPosition.RIGHT)));\n      return;\n    }\n    \/\/ FIXME [VISTALL] support other borders?\n  }","code_wo_comment":"private void bordersChanged() {\n    JComponent component = (JComponent)toAWTComponent();\n    component.setBorder(JBUI.Borders.empty());\n    Collection<BorderInfo> borders = dataObject().getBorders();\n    Map<BorderPosition, Integer> emptyBorders = new LinkedHashMap<>();\n    for (BorderInfo border : borders) {\n      if (border.getBorderStyle() == BorderStyle.EMPTY) {\n        emptyBorders.put(border.getBorderPosition(), border.getWidth());\n      }\n    }\n    if (!emptyBorders.isEmpty()) {\n      component.setBorder(JBUI.Borders.empty(getBorderSize(emptyBorders, BorderPosition.TOP), getBorderSize(emptyBorders, BorderPosition.LEFT), getBorderSize(emptyBorders, BorderPosition.BOTTOM),\n                                             getBorderSize(emptyBorders, BorderPosition.RIGHT)));\n      return;\n    }\n   \n  }","cleancode":"private void borderschanged() { jcomponent component = (jcomponent)toawtcomponent(); component.setborder(jbui.borders.empty()); collection<borderinfo> borders = dataobject().getborders(); map<borderposition, integer> emptyborders = new linkedhashmap<>(); for (borderinfo border : borders) { if (border.getborderstyle() == borderstyle.empty) { emptyborders.put(border.getborderposition(), border.getwidth()); } } if (!emptyborders.isempty()) { component.setborder(jbui.borders.empty(getbordersize(emptyborders, borderposition.top), getbordersize(emptyborders, borderposition.left), getbordersize(emptyborders, borderposition.bottom), getbordersize(emptyborders, borderposition.right))); return; } }","repo":"consulo\/consulo","label":[0,0,1,0]}
{"id":24543,"original_code":"private void saveXML(Reference ref, FileOutputStream fos) throws JAXBException\n\t{\n\t\tJAXBContext ctx = JAXBContext.newInstance(com.digi_dmx.gen.Context.class);\n\t\tMarshaller m = ctx.createMarshaller();\n\t\tm.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\t\tm.setProperty(Marshaller.JAXB_ENCODING, DEFAULT_ENCODING);\n\t\tcom.digi_dmx.gen.Context save = new com.digi_dmx.gen.Context();\n\t\tsave.setFactory(ref.getFactoryClassName());\n\t\tsave.setClazz(ref.getClassName());\n\t\tEnumeration<RefAddr> all = ref.getAll();\n\t\twhile (all.hasMoreElements())\n\t\t{\n\t\t\tRefAddr refAddr = all.nextElement();\n\t\t\tAttr attr = new Attr();\n\t\t\tattr.setName(refAddr.getType());\n\t\t\tObject content = refAddr.getContent();\n\t\t\tif (content != null)\n\t\t\t{\n\t\t\t\tattr.setValue(content.toString());\n\t\t\t}\n\t\t\tsave.addAttr(attr); \/\/ this hurts my soul\n\t\t}\n\t\tm.marshal(save, fos);\n\t}","code_wo_comment":"private void saveXML(Reference ref, FileOutputStream fos) throws JAXBException\n\t{\n\t\tJAXBContext ctx = JAXBContext.newInstance(com.digi_dmx.gen.Context.class);\n\t\tMarshaller m = ctx.createMarshaller();\n\t\tm.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n\t\tm.setProperty(Marshaller.JAXB_ENCODING, DEFAULT_ENCODING);\n\t\tcom.digi_dmx.gen.Context save = new com.digi_dmx.gen.Context();\n\t\tsave.setFactory(ref.getFactoryClassName());\n\t\tsave.setClazz(ref.getClassName());\n\t\tEnumeration<RefAddr> all = ref.getAll();\n\t\twhile (all.hasMoreElements())\n\t\t{\n\t\t\tRefAddr refAddr = all.nextElement();\n\t\t\tAttr attr = new Attr();\n\t\t\tattr.setName(refAddr.getType());\n\t\t\tObject content = refAddr.getContent();\n\t\t\tif (content != null)\n\t\t\t{\n\t\t\t\tattr.setValue(content.toString());\n\t\t\t}\n\t\t\tsave.addAttr(attr);\n\t\t}\n\t\tm.marshal(save, fos);\n\t}","cleancode":"private void savexml(reference ref, fileoutputstream fos) throws jaxbexception { jaxbcontext ctx = jaxbcontext.newinstance(com.digi_dmx.gen.context.class); marshaller m = ctx.createmarshaller(); m.setproperty(marshaller.jaxb_formatted_output, true); m.setproperty(marshaller.jaxb_encoding, default_encoding); com.digi_dmx.gen.context save = new com.digi_dmx.gen.context(); save.setfactory(ref.getfactoryclassname()); save.setclazz(ref.getclassname()); enumeration<refaddr> all = ref.getall(); while (all.hasmoreelements()) { refaddr refaddr = all.nextelement(); attr attr = new attr(); attr.setname(refaddr.gettype()); object content = refaddr.getcontent(); if (content != null) { attr.setvalue(content.tostring()); } save.addattr(attr); } m.marshal(save, fos); }","repo":"ebardes\/EasyJNDI","label":[1,0,0,0]}

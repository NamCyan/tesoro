{"id":24717,"original_code":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\t\tStudy study = ControllerUtil.findStudy(request, mStudyService);\n\t\tSubmission submission = (Submission) study.getSubmission();\n\t\tStudyCommand studyCommand = new StudyCommand();\n\t\t\/\/ copy study information\n\t\tstudyCommand.setStudy(study);\n\t\t\/\/ study from TBI do not contain submission_id\n\t\tif (submission != null) {\n\t\t\tstudyCommand.setSubmission_id(submission.getId());\n\t\t}\n\t\tList<Analysis> analysisList = study.getAnalyses();\n\t\tList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\n\t\tList<Analysis> changedAnalyses = new ArrayList<Analysis>();\n\t\tStringBuilder errBuilder = new StringBuilder();\n\t\tfor (Analysis analysis : analysisList) {\n\t\t\t\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\t\t\t\/\/ we this controller will extend BaseFormController.\n\t\t\tif (!analysis.getValidated()) {\n\t\t\t\tExecutionResult result = analysis.validate();\n\t\t\t\tif (!result.isSuccessful()) {\n\t\t\t\t\terrBuilder.append(result.getErrorMessage());\n\t\t\t\t}\n\t\t\t\tif (analysis.getValidated()) {\n\t\t\t\t\t\/\/ save to db if the validated flag is updated:\n\t\t\t\t\tchangedAnalyses.add(analysis);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/FIXME: display err message in GUI\n\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n\t\t\t}\n\t\t\t\/\/\n\t\t\t\/\/ Analysis\n\t\t\tAnalysisCommand analysisCommand = new AnalysisCommand();\n\t\t\tBeanUtils.copyProperties(analysisCommand, analysis);\n\t\t\t\/\/ Analysis Steps for Analysis and add algorithm type\n\t\t\tList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\n\t\t\tList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\t\t\tfor (AnalysisStep analysisStep : analysisStepList) {\n\t\t\t\tAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\n\t\t\t\tBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\t\t\t\t\/\/ analysisStepCommand.setId(analysisStep.getId());\n\t\t\t\t\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\n\t\t\t\tAlgorithm algorithm = analysisStep.getAlgorithmInfo();\n\t\t\t\tString algorithmType = new String();\n\t\t\t\tif (algorithm instanceof LikelihoodAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n\t\t\t\t} else if (algorithm instanceof ParsimonyAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_PARSIMONY;\n\t\t\t\t}  else if (algorithm instanceof OtherAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_OTHER;\n\t\t\t\t}else if (algorithm instanceof BayesianAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Bayesian;\n\t\t\t\t} else if (algorithm instanceof EvolutionAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Evolution;\n\t\t\t\t} else if (algorithm instanceof JoiningAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Joining;\n\t\t\t} else if (algorithm instanceof UPGMAAlgorithm) {\n\t\t\t\talgorithmType = Constants.ALGORITHM_UPGMA;\t\n\t\t\t}\n\t\t\t\t\/\/ add algorithm type for analysisStepCommand\n\t\t\t\tanalysisStepCommand.setAlgorithmType(algorithmType);\n\t\t\t\t\/\/ analyzed data for each analysis step\n\t\t\t\tList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\n\t\t\t\tList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\t\t\t\t\/\/ Matrix or Tree?\n\t\t\t\tfor (AnalyzedData analyzedData : analyzedDataSet) {\n\t\t\t\t\tAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\n\t\t\t\t\tBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\n\t\t\t\t\tString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\n\t\t\t\t\tanalyzedDataCommand.setInputOutputType(inputOutput);\n\t\t\t\t\tif (analyzedData instanceof AnalyzedMatrix) {\n\t\t\t\t\t\tAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedMatrix.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n\t\t\t\t\t} else if (analyzedData instanceof AnalyzedTree) {\n\t\t\t\t\t\tAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.TREE_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedTree.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n\t\t\t\t\t}\n\t\t\t\t\tanalyzedDataCommandList.add(analyzedDataCommand);\n\t\t\t\t} \/\/ end for\n\t\t\t\t\/\/ add analyzedData for analysisStepCommand\n\t\t\t\tCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\n\t\t\t\tanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\n\t\t\t\tanalysisStepCommandList.add(analysisStepCommand);\n\t\t\t}\n\t\t\tanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\n\t\t\tanalysisCommandList.add(analysisCommand);\n\t\t}\n\t\tgetStudyService().updateCollection(changedAnalyses);\n\t\tstudyCommand.setAnalysisCommandList(analysisCommandList);\n\t\treturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n\t}","code_wo_comment":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\t\tStudy study = ControllerUtil.findStudy(request, mStudyService);\n\t\tSubmission submission = (Submission) study.getSubmission();\n\t\tStudyCommand studyCommand = new StudyCommand();\n\t\n\t\tstudyCommand.setStudy(study);\n\t\n\t\tif (submission != null) {\n\t\t\tstudyCommand.setSubmission_id(submission.getId());\n\t\t}\n\t\tList<Analysis> analysisList = study.getAnalyses();\n\t\tList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\n\t\tList<Analysis> changedAnalyses = new ArrayList<Analysis>();\n\t\tStringBuilder errBuilder = new StringBuilder();\n\t\tfor (Analysis analysis : analysisList) {\n\t\t\n\t\t\n\t\t\tif (!analysis.getValidated()) {\n\t\t\t\tExecutionResult result = analysis.validate();\n\t\t\t\tif (!result.isSuccessful()) {\n\t\t\t\t\terrBuilder.append(result.getErrorMessage());\n\t\t\t\t}\n\t\t\t\tif (analysis.getValidated()) {\n\t\t\t\t\n\t\t\t\t\tchangedAnalyses.add(analysis);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(errBuilder.toString());\n\t\t\t}\n\t\t\n\t\t\n\t\t\tAnalysisCommand analysisCommand = new AnalysisCommand();\n\t\t\tBeanUtils.copyProperties(analysisCommand, analysis);\n\t\t\n\t\t\tList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\n\t\t\tList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\t\t\tfor (AnalysisStep analysisStep : analysisStepList) {\n\t\t\t\tAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\n\t\t\t\tBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\t\t\t\n\t\t\t\n\t\t\t\tAlgorithm algorithm = analysisStep.getAlgorithmInfo();\n\t\t\t\tString algorithmType = new String();\n\t\t\t\tif (algorithm instanceof LikelihoodAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n\t\t\t\t} else if (algorithm instanceof ParsimonyAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_PARSIMONY;\n\t\t\t\t}  else if (algorithm instanceof OtherAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_OTHER;\n\t\t\t\t}else if (algorithm instanceof BayesianAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Bayesian;\n\t\t\t\t} else if (algorithm instanceof EvolutionAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Evolution;\n\t\t\t\t} else if (algorithm instanceof JoiningAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Joining;\n\t\t\t} else if (algorithm instanceof UPGMAAlgorithm) {\n\t\t\t\talgorithmType = Constants.ALGORITHM_UPGMA;\t\n\t\t\t}\n\t\t\t\n\t\t\t\tanalysisStepCommand.setAlgorithmType(algorithmType);\n\t\t\t\n\t\t\t\tList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\n\t\t\t\tList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\t\t\t\n\t\t\t\tfor (AnalyzedData analyzedData : analyzedDataSet) {\n\t\t\t\t\tAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\n\t\t\t\t\tBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\n\t\t\t\t\tString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\n\t\t\t\t\tanalyzedDataCommand.setInputOutputType(inputOutput);\n\t\t\t\t\tif (analyzedData instanceof AnalyzedMatrix) {\n\t\t\t\t\t\tAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedMatrix.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n\t\t\t\t\t} else if (analyzedData instanceof AnalyzedTree) {\n\t\t\t\t\t\tAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.TREE_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedTree.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n\t\t\t\t\t}\n\t\t\t\t\tanalyzedDataCommandList.add(analyzedDataCommand);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\n\t\t\t\tanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\n\t\t\t\tanalysisStepCommandList.add(analysisStepCommand);\n\t\t\t}\n\t\t\tanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\n\t\t\tanalysisCommandList.add(analysisCommand);\n\t\t}\n\t\tgetStudyService().updateCollection(changedAnalyses);\n\t\tstudyCommand.setAnalysisCommandList(analysisCommandList);\n\t\treturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n\t}","cleancode":"public modelandview handlerequest(httpservletrequest request, httpservletresponse response) throws exception { study study = controllerutil.findstudy(request, mstudyservice); submission submission = (submission) study.getsubmission(); studycommand studycommand = new studycommand(); studycommand.setstudy(study); if (submission != null) { studycommand.setsubmission_id(submission.getid()); } list<analysis> analysislist = study.getanalyses(); list<analysiscommand> analysiscommandlist = new arraylist<analysiscommand>(); list<analysis> changedanalyses = new arraylist<analysis>(); stringbuilder errbuilder = new stringbuilder(); for (analysis analysis : analysislist) { if (!analysis.getvalidated()) { executionresult result = analysis.validate(); if (!result.issuccessful()) { errbuilder.append(result.geterrormessage()); } if (analysis.getvalidated()) { changedanalyses.add(analysis); } } if (logger.isdebugenabled()) { logger.debug(errbuilder.tostring()); } analysiscommand analysiscommand = new analysiscommand(); beanutils.copyproperties(analysiscommand, analysis); list<analysisstep> analysissteplist = analysis.getanalysisstepsreadonly(); list<analysisstepcommand> analysisstepcommandlist = new arraylist<analysisstepcommand>(); for (analysisstep analysisstep : analysissteplist) { analysisstepcommand analysisstepcommand = new analysisstepcommand(); beanutils.copyproperties(analysisstepcommand, analysisstep); algorithm algorithm = analysisstep.getalgorithminfo(); string algorithmtype = new string(); if (algorithm instanceof likelihoodalgorithm) { algorithmtype = constants.algorithm_likelihood; } else if (algorithm instanceof parsimonyalgorithm) { algorithmtype = constants.algorithm_parsimony; } else if (algorithm instanceof otheralgorithm) { algorithmtype = constants.algorithm_other; }else if (algorithm instanceof bayesianalgorithm) { algorithmtype = constants.algorithm_bayesian; } else if (algorithm instanceof evolutionalgorithm) { algorithmtype = constants.algorithm_evolution; } else if (algorithm instanceof joiningalgorithm) { algorithmtype = constants.algorithm_joining; } else if (algorithm instanceof upgmaalgorithm) { algorithmtype = constants.algorithm_upgma; } analysisstepcommand.setalgorithmtype(algorithmtype); list<analyzeddata> analyzeddataset = analysisstep.getdatasetreadonly(); list<analyzeddatacommand> analyzeddatacommandlist = new arraylist<analyzeddatacommand>(); for (analyzeddata analyzeddata : analyzeddataset) { analyzeddatacommand analyzeddatacommand = new analyzeddatacommand(); beanutils.copyproperties(analyzeddatacommand, analyzeddata); string inputoutput = (analyzeddata.isinputdata()) ? (\"input\") : (\"output\"); analyzeddatacommand.setinputoutputtype(inputoutput); if (analyzeddata instanceof analyzedmatrix) { analyzedmatrix analyzedmatrix = (analyzedmatrix) analyzeddata; analyzeddatacommand.setdatatype(constants.matrix_key); analyzeddatacommand.setdisplayname(analyzedmatrix.getmatrix().gettitle()); analyzeddatacommand.setid(analyzedmatrix.getid()); analyzeddatacommand.setdataid(analyzedmatrix.getmatrix().getid()); } else if (analyzeddata instanceof analyzedtree) { analyzedtree analyzedtree = (analyzedtree) analyzeddata; analyzeddatacommand.setdatatype(constants.tree_key); analyzeddatacommand.setdisplayname(analyzedtree.gettree().getlabel()); analyzeddatacommand.setid(analyzedtree.getid()); analyzeddatacommand.setdataid(analyzedtree.gettree().getid()); } analyzeddatacommandlist.add(analyzeddatacommand); } collections.sort(analyzeddatacommandlist, new analyzeddatacomparator()); analysisstepcommand.setanalyzeddatacommandlist(analyzeddatacommandlist); analysisstepcommandlist.add(analysisstepcommand); } analysiscommand.setanalysisstepcommandlist(analysisstepcommandlist); analysiscommandlist.add(analysiscommand); } getstudyservice().updatecollection(changedanalyses); studycommand.setanalysiscommandlist(analysiscommandlist); return new modelandview(\"analysissection\", constants.study_command_key, studycommand); }","repo":"TreeBASE\/treebasetest","label":[0,1,1,0]}
{"id":148,"original_code":"private void addVar(Varlet v){\n\t\t\tlong key=key(v.chromosome, v.beginLoc);\n\t\t\tArrayList<Varlet> list=keymap.get(key);\n\t\t\tassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\n\t\t\tsynchronized(list){\n\t\t\t\tlist.add(v);\n\t\t\t\tif(list.size()>=WRITE_BUFFER){\n\t\t\t\t\tif(MERGE_EQUAL_VARLETS){\n\t\t\t\t\t\tmergeEqualVarlets(list);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tCollections.sort(list);\n\t\t\t\t\t}\n\t\t\t\t\twriteList(list);\n\t\t\t\t\tlist.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}","code_wo_comment":"private void addVar(Varlet v){\n\t\t\tlong key=key(v.chromosome, v.beginLoc);\n\t\t\tArrayList<Varlet> list=keymap.get(key);\n\t\t\tassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\n\t\t\tsynchronized(list){\n\t\t\t\tlist.add(v);\n\t\t\t\tif(list.size()>=WRITE_BUFFER){\n\t\t\t\t\tif(MERGE_EQUAL_VARLETS){\n\t\t\t\t\t\tmergeEqualVarlets(list);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tCollections.sort(list);\n\t\t\t\t\t}\n\t\t\t\t\twriteList(list);\n\t\t\t\t\tlist.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private void addvar(varlet v){ long key=key(v.chromosome, v.beginloc); arraylist<varlet> list=keymap.get(key); assert(list!=null) : \"\\ncan't find \"+key+\" in \"+keymap.keyset()+\"\\n\"; synchronized(list){ list.add(v); if(list.size()>=write_buffer){ if(merge_equal_varlets){ mergeequalvarlets(list); }else{ collections.sort(list); } writelist(list); list.clear(); } } }","repo":"SilasK\/BBMap","label":[1,0,0,0]}
{"id":16664,"original_code":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\n\t\tswitch(driverType) {\n\t\t\tcase Chrome:\n\t\t\t\treturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\n\t\t\tcase Firefox:\n\t\t\t\treturn null; \/\/TODO: Make Firefox subclass\n\t\t\tcase IE:\n\t\t\t\treturn null; \/\/TODO: Make IE subclass\n\t\t\tcase Edge:\n\t\t\t\treturn null; \/\/TODO: Make Edge subclass\n\t\t\tcase Opera:\n\t\t\t\treturn null; \/\/TODO: Make Opera subclass\n\t\t\tcase Safari:\n\t\t\t\treturn null; \/\/TODO: Make Safari subclass\n\t\t\tcase iOS_iPhone:\n\t\t\t\treturn null; \/\/TODO: Make iOS_iPhone subclass\n\t\t\tcase iOS_iPad:\n\t\t\t\treturn null; \/\/TODO: Make iOS_iPad subclass\n\t\t\tcase Android:\n\t\t\t\treturn null; \/\/TODO: Make Android subclass\n\t\t\tcase HtmlUnit:\n\t\t\t\treturn null; \/\/TODO: Make HtmlUnit subclass\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}","code_wo_comment":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\n\t\tswitch(driverType) {\n\t\t\tcase Chrome:\n\t\t\t\treturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\n\t\t\tcase Firefox:\n\t\t\t\treturn null;\n\t\t\tcase IE:\n\t\t\t\treturn null;\n\t\t\tcase Edge:\n\t\t\t\treturn null;\n\t\t\tcase Opera:\n\t\t\t\treturn null;\n\t\t\tcase Safari:\n\t\t\t\treturn null;\n\t\t\tcase iOS_iPhone:\n\t\t\t\treturn null;\n\t\t\tcase iOS_iPad:\n\t\t\t\treturn null;\n\t\t\tcase Android:\n\t\t\t\treturn null;\n\t\t\tcase HtmlUnit:\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}","cleancode":"private nicewebdriver getnicewebdriverinstance(drivertype drivertype, object[] oargs){ switch(drivertype) { case chrome: return new nicechrome().underloadednicewebdriverconstructor(oargs).getthiswithverbositysetto(outputisverbose); case firefox: return null; case ie: return null; case edge: return null; case opera: return null; case safari: return null; case ios_iphone: return null; case ios_ipad: return null; case android: return null; case htmlunit: return null; default: return null; } }","repo":"Skenvy\/SeleniumNG","label":[0,1,0,0]}
{"id":33149,"original_code":"private void tag()\n        throws Exception\n    {\n        String[] asFilename = (String[])m_oCmdLineMap.get(\"filenames\");\n        for (int i=0; i < asFilename.length; i++)\n        {\n            File oSourceFile = new File(asFilename[i]);\n            MP3File oMP3File = new MP3File(oSourceFile);\n            if (m_oCmdLineMap.containsKey(\"1\"))\n            {\n                ID3V1_1Tag oID3V1_1Tag = new ID3V1_1Tag();\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V1_1Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V1_1Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V1_1Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    String sGenre = (String)m_oCmdLineMap.get(\"genre\");\n                    oID3V1_1Tag.setGenre(ID3V1Tag.Genre.lookupGenre(sGenre));\n                }\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V1_1Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V1_1Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).toString());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    oID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                }\n                oMP3File.setID3Tag(oID3V1_1Tag);\n            }\n            if (m_oCmdLineMap.containsKey(\"2\"))\n            {\n                ID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n                \/\/HACK: Need to have padding at the end of the tag, or Winamp won't see the last frame (at least 6 bytes seem to be required).\n                oID3V2_3_0Tag.setPaddingLength(16);\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V2_3_0Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    oID3V2_3_0Tag.setGenre((String)m_oCmdLineMap.get(\"genre\"));\n                }\n                oMP3File.setID3Tag(oID3V2_3_0Tag);\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V2_3_0Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V2_3_0Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).intValue());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    if (m_oCmdLineMap.containsKey(\"total\"))\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue(),\n                                                     ((Integer)m_oCmdLineMap.get(\"total\")).intValue());\n                    }\n                    else\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                    }\n                }\n            }\n            oMP3File.sync();\n        }\n    }","code_wo_comment":"private void tag()\n        throws Exception\n    {\n        String[] asFilename = (String[])m_oCmdLineMap.get(\"filenames\");\n        for (int i=0; i < asFilename.length; i++)\n        {\n            File oSourceFile = new File(asFilename[i]);\n            MP3File oMP3File = new MP3File(oSourceFile);\n            if (m_oCmdLineMap.containsKey(\"1\"))\n            {\n                ID3V1_1Tag oID3V1_1Tag = new ID3V1_1Tag();\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V1_1Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V1_1Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V1_1Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    String sGenre = (String)m_oCmdLineMap.get(\"genre\");\n                    oID3V1_1Tag.setGenre(ID3V1Tag.Genre.lookupGenre(sGenre));\n                }\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V1_1Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V1_1Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).toString());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    oID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                }\n                oMP3File.setID3Tag(oID3V1_1Tag);\n            }\n            if (m_oCmdLineMap.containsKey(\"2\"))\n            {\n                ID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n               \n                oID3V2_3_0Tag.setPaddingLength(16);\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V2_3_0Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    oID3V2_3_0Tag.setGenre((String)m_oCmdLineMap.get(\"genre\"));\n                }\n                oMP3File.setID3Tag(oID3V2_3_0Tag);\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V2_3_0Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V2_3_0Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).intValue());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    if (m_oCmdLineMap.containsKey(\"total\"))\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue(),\n                                                     ((Integer)m_oCmdLineMap.get(\"total\")).intValue());\n                    }\n                    else\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                    }\n                }\n            }\n            oMP3File.sync();\n        }\n    }","cleancode":"private void tag() throws exception { string[] asfilename = (string[])m_ocmdlinemap.get(\"filenames\"); for (int i=0; i < asfilename.length; i++) { file osourcefile = new file(asfilename[i]); mp3file omp3file = new mp3file(osourcefile); if (m_ocmdlinemap.containskey(\"1\")) { id3v1_1tag oid3v1_1tag = new id3v1_1tag(); if (m_ocmdlinemap.containskey(\"album\")) { oid3v1_1tag.setalbum((string)m_ocmdlinemap.get(\"album\")); } if (m_ocmdlinemap.containskey(\"artist\")) { oid3v1_1tag.setartist((string)m_ocmdlinemap.get(\"artist\")); } if (m_ocmdlinemap.containskey(\"comment\")) { oid3v1_1tag.setcomment((string)m_ocmdlinemap.get(\"comment\")); } if (m_ocmdlinemap.containskey(\"genre\")) { string sgenre = (string)m_ocmdlinemap.get(\"genre\"); oid3v1_1tag.setgenre(id3v1tag.genre.lookupgenre(sgenre)); } if (m_ocmdlinemap.containskey(\"title\")) { oid3v1_1tag.settitle((string)m_ocmdlinemap.get(\"title\")); } if (m_ocmdlinemap.containskey(\"year\")) { oid3v1_1tag.setyear(((integer)m_ocmdlinemap.get(\"year\")).tostring()); } if (m_ocmdlinemap.containskey(\"track\")) { oid3v1_1tag.setalbumtrack(((integer)m_ocmdlinemap.get(\"track\")).intvalue()); } omp3file.setid3tag(oid3v1_1tag); } if (m_ocmdlinemap.containskey(\"2\")) { id3v2_3_0tag oid3v2_3_0tag = new id3v2_3_0tag(); oid3v2_3_0tag.setpaddinglength(16); if (m_ocmdlinemap.containskey(\"album\")) { oid3v2_3_0tag.setalbum((string)m_ocmdlinemap.get(\"album\")); } if (m_ocmdlinemap.containskey(\"artist\")) { oid3v2_3_0tag.setartist((string)m_ocmdlinemap.get(\"artist\")); } if (m_ocmdlinemap.containskey(\"comment\")) { oid3v2_3_0tag.setcomment((string)m_ocmdlinemap.get(\"comment\")); } if (m_ocmdlinemap.containskey(\"genre\")) { oid3v2_3_0tag.setgenre((string)m_ocmdlinemap.get(\"genre\")); } omp3file.setid3tag(oid3v2_3_0tag); if (m_ocmdlinemap.containskey(\"title\")) { oid3v2_3_0tag.settitle((string)m_ocmdlinemap.get(\"title\")); } if (m_ocmdlinemap.containskey(\"year\")) { oid3v2_3_0tag.setyear(((integer)m_ocmdlinemap.get(\"year\")).intvalue()); } if (m_ocmdlinemap.containskey(\"track\")) { if (m_ocmdlinemap.containskey(\"total\")) { oid3v2_3_0tag.settracknumber(((integer)m_ocmdlinemap.get(\"track\")).intvalue(), ((integer)m_ocmdlinemap.get(\"total\")).intvalue()); } else { oid3v2_3_0tag.settracknumber(((integer)m_ocmdlinemap.get(\"track\")).intvalue()); } } } omp3file.sync(); } }","repo":"ShahzaibAyyub\/Music-Player-Library-Java-SQL","label":[1,0,0,0]}
{"id":8611,"original_code":"@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tif(currSel!= null && currSel instanceof GroupTreeNode){\n\t\t\t\t\t\t\/\/ differentiate clones in this group\n\t\t\t\t\t\tGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/\t\t\t\t\t\tif(gtn.getChildCount() == 2){\n\t\t\t\t\t\t\t\/\/ TODO: currently we only support two way comparison\n\t\t\t\t\t\t\tCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\n\t\t\t\t\t\t\tCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\n\t\t\t\t\t\t\tString file1 = ctn1.getFile();\n\t\t\t\t\t\t\tString file2 = ctn2.getFile();\n\t\t\t\t\t\t\tCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\n\t\t\t\t\t\t\tcomparison.setOpenInBackground(false);\n\t\t\t\t\t\t\tcomparison.execute();\n\/\/\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}","code_wo_comment":"@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tif(currSel!= null && currSel instanceof GroupTreeNode){\n\t\t\t\t\t\n\t\t\t\t\t\tGroupTreeNode gtn = (GroupTreeNode)currSel;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\n\t\t\t\t\t\t\tCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\n\t\t\t\t\t\t\tString file1 = ctn1.getFile();\n\t\t\t\t\t\t\tString file2 = ctn2.getFile();\n\t\t\t\t\t\t\tCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\n\t\t\t\t\t\t\tcomparison.setOpenInBackground(false);\n\t\t\t\t\t\t\tcomparison.execute();\n\t\t\t\t\t}\n\t\t\t\t}","cleancode":"@override public void actionperformed(actionevent e) { if(currsel!= null && currsel instanceof grouptreenode){ grouptreenode gtn = (grouptreenode)currsel; clonetreenode ctn1 = (clonetreenode)gtn.getchildat(0); clonetreenode ctn2 = (clonetreenode)gtn.getchildat(1); string file1 = ctn1.getfile(); string file2 = ctn2.getfile(); clonecomparison comparison = new clonecomparison(panel, new file(file1), new file(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end); comparison.setopeninbackground(false); comparison.execute(); } }","repo":"UCLA-SEAL\/Grafter","label":[1,0,0,0]}
{"id":25018,"original_code":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\n                                              long startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\n      if (parsingResult.hasGroupingOrAggregations()) {\n         throw log.queryMustNotUseGroupingOrAggregation(); \/\/ may happen only due to internal programming error\n      }\n      boolean isFullTextQuery;\n      if (parsingResult.getWhereClause() != null) {\n         isFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\n         if (!isIndexed && isFullTextQuery) {\n            throw new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n         }\n      }\n      if (parsingResult.getSortFields() != null) {\n         for (SortField sortField : parsingResult.getSortFields()) {\n            PropertyPath<?> p = sortField.getPath();\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n            }\n         }\n      }\n      if (parsingResult.getProjectedPaths() != null) {\n         for (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n            }\n         }\n      }\n      BooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\n      if (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n         \/\/ the query is a contradiction, there are no matches\n         return new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n      }\n      \/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\n      if (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n         \/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      IndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\n      boolean allProjectionsAreStored = true;\n      LinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\n      if (parsingResult.getProjectedPaths() != null) {\n         projectionsMap = new LinkedHashMap<>();\n         for (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\n            PropertyPath<?> p = parsingResult.getProjectedPaths()[i];\n            List<Integer> idx = projectionsMap.get(p);\n            if (idx == null) {\n               idx = new ArrayList<>();\n               projectionsMap.put(p, idx);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allProjectionsAreStored = false;\n               }\n            }\n            idx.add(i);\n         }\n      }\n      boolean allSortFieldsAreStored = true;\n      SortField[] sortFields = parsingResult.getSortFields();\n      if (sortFields != null) {\n         \/\/ deduplicate sort fields\n         LinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\n         for (SortField sf : sortFields) {\n            PropertyPath<?> p = sf.getPath();\n            String asStringPath = p.asStringPath();\n            if (!sortFieldMap.containsKey(asStringPath)) {\n               sortFieldMap.put(asStringPath, sf);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allSortFieldsAreStored = false;\n               }\n            }\n         }\n         sortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n      }\n      \/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n      \/\/todo [anistor] do we allow aggregation in fulltext queries?\n      \/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\n      BooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\n      BooleanExpr expansion = bse.expand(normalizedWhereClause);\n      if (expansion == normalizedWhereClause) {  \/\/ identity comparison is intended here!\n         \/\/ all involved fields are indexed, so go the Lucene way\n         if (allSortFieldsAreStored) {\n            if (allProjectionsAreStored) {\n               \/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\n               RowProcessor rowProcessor = null;\n               if (parsingResult.getProjectedPaths() != null) {\n                  if (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n                     \/\/ but some projections are duplicated ...\n                     final Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\n                     final int[] map = new int[parsingResult.getProjectedPaths().length];\n                     int j = 0;\n                     for (List<Integer> idx : projectionsMap.values()) {\n                        int i = idx.get(0);\n                        projectedTypes[j] = parsingResult.getProjectedTypes()[i];\n                        for (int k : idx) {\n                           map[k] = j;\n                        }\n                        j++;\n                     }\n                     RowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\n                     rowProcessor = inRow -> {\n                        if (projectionProcessor != null) {\n                           inRow = projectionProcessor.process(inRow);\n                        }\n                        Object[] outRow = new Object[map.length];\n                        for (int i = 0; i < map.length; i++) {\n                           outRow[i] = inRow[map[i]];\n                        }\n                        return outRow;\n                     };\n                     PropertyPath[] deduplicatedProjection = projectionsMap.keySet().toArray(new PropertyPath[projectionsMap.size()]);\n                     IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, deduplicatedProjection, projectedTypes, sortFields);\n                     return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n                  } else {\n                     rowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n                  }\n               }\n               return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n            } else {\n               IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\n               Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\n               String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\n               return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n            }\n         } else {\n            \/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\n            IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\n            Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n            String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\n            return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n         }\n      }\n      if (expansion == ConstantBooleanExpr.TRUE) {\n         \/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      \/\/ some fields are indexed, run a hybrid query\n      IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\n      Query expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n      return new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n   }","code_wo_comment":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\n                                              long startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\n      if (parsingResult.hasGroupingOrAggregations()) {\n         throw log.queryMustNotUseGroupingOrAggregation();\n      }\n      boolean isFullTextQuery;\n      if (parsingResult.getWhereClause() != null) {\n         isFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\n         if (!isIndexed && isFullTextQuery) {\n            throw new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n         }\n      }\n      if (parsingResult.getSortFields() != null) {\n         for (SortField sortField : parsingResult.getSortFields()) {\n            PropertyPath<?> p = sortField.getPath();\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n            }\n         }\n      }\n      if (parsingResult.getProjectedPaths() != null) {\n         for (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n            }\n         }\n      }\n      BooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\n      if (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n        \n         return new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n      }\n     \n      if (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n        \n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      IndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\n      boolean allProjectionsAreStored = true;\n      LinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\n      if (parsingResult.getProjectedPaths() != null) {\n         projectionsMap = new LinkedHashMap<>();\n         for (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\n            PropertyPath<?> p = parsingResult.getProjectedPaths()[i];\n            List<Integer> idx = projectionsMap.get(p);\n            if (idx == null) {\n               idx = new ArrayList<>();\n               projectionsMap.put(p, idx);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allProjectionsAreStored = false;\n               }\n            }\n            idx.add(i);\n         }\n      }\n      boolean allSortFieldsAreStored = true;\n      SortField[] sortFields = parsingResult.getSortFields();\n      if (sortFields != null) {\n        \n         LinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\n         for (SortField sf : sortFields) {\n            PropertyPath<?> p = sf.getPath();\n            String asStringPath = p.asStringPath();\n            if (!sortFieldMap.containsKey(asStringPath)) {\n               sortFieldMap.put(asStringPath, sf);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allSortFieldsAreStored = false;\n               }\n            }\n         }\n         sortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n      }\n     \n     \n     \n      BooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\n      BooleanExpr expansion = bse.expand(normalizedWhereClause);\n      if (expansion == normalizedWhereClause) { \n        \n         if (allSortFieldsAreStored) {\n            if (allProjectionsAreStored) {\n              \n               RowProcessor rowProcessor = null;\n               if (parsingResult.getProjectedPaths() != null) {\n                  if (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n                    \n                     final Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\n                     final int[] map = new int[parsingResult.getProjectedPaths().length];\n                     int j = 0;\n                     for (List<Integer> idx : projectionsMap.values()) {\n                        int i = idx.get(0);\n                        projectedTypes[j] = parsingResult.getProjectedTypes()[i];\n                        for (int k : idx) {\n                           map[k] = j;\n                        }\n                        j++;\n                     }\n                     RowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\n                     rowProcessor = inRow -> {\n                        if (projectionProcessor != null) {\n                           inRow = projectionProcessor.process(inRow);\n                        }\n                        Object[] outRow = new Object[map.length];\n                        for (int i = 0; i < map.length; i++) {\n                           outRow[i] = inRow[map[i]];\n                        }\n                        return outRow;\n                     };\n                     PropertyPath[] deduplicatedProjection = projectionsMap.keySet().toArray(new PropertyPath[projectionsMap.size()]);\n                     IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, deduplicatedProjection, projectedTypes, sortFields);\n                     return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n                  } else {\n                     rowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n                  }\n               }\n               return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n            } else {\n               IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\n               Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\n               String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\n               return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n            }\n         } else {\n           \n            IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\n            Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n            String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\n            return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n         }\n      }\n      if (expansion == ConstantBooleanExpr.TRUE) {\n        \n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n     \n      IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\n      Query expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n      return new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n   }","cleancode":"private basequery buildquerynoaggregations(queryfactory queryfactory, string querystring, map<string, object> namedparameters, long startoffset, int maxresults, ickleparsingresult<typemetadata> parsingresult) { if (parsingresult.hasgroupingoraggregations()) { throw log.querymustnotusegroupingoraggregation(); } boolean isfulltextquery; if (parsingresult.getwhereclause() != null) { isfulltextquery = parsingresult.getwhereclause().acceptvisitor(fulltextvisitor.instance); if (!isindexed && isfulltextquery) { throw new illegalstateexception(\"the cache must be indexed in order to use full-text queries.\"); } } if (parsingresult.getsortfields() != null) { for (sortfield sortfield : parsingresult.getsortfields()) { propertypath<?> p = sortfield.getpath(); if (propertyhelper.isrepeatedproperty(parsingresult.gettargetentitymetadata(), p.asarraypath())) { throw log.multivaluedpropertycannotbeusedinorderby(p.tostring()); } } } if (parsingresult.getprojectedpaths() != null) { for (propertypath<?> p : parsingresult.getprojectedpaths()) { if (propertyhelper.isrepeatedproperty(parsingresult.gettargetentitymetadata(), p.asarraypath())) { throw log.multivaluedpropertycannotbeprojected(p.asstringpath()); } } } booleanexpr normalizedwhereclause = booleanfilternormalizer.normalize(parsingresult.getwhereclause()); if (normalizedwhereclause == constantbooleanexpr.false) { return new emptyresultquery(queryfactory, cache, querystring, namedparameters, startoffset, maxresults); } if (!isindexed || (normalizedwhereclause == null || normalizedwhereclause == constantbooleanexpr.true) && parsingresult.getprojections() == null && parsingresult.getsortfields() == null) { return new embeddedquery(this, queryfactory, cache, querystring, namedparameters, parsingresult.getprojections(), startoffset, maxresults); } indexedfieldprovider.fieldindexingmetadata fieldindexingmetadata = propertyhelper.getindexedfieldprovider().get(parsingresult.gettargetentitymetadata()); boolean allprojectionsarestored = true; linkedhashmap<propertypath, list<integer>> projectionsmap = null; if (parsingresult.getprojectedpaths() != null) { projectionsmap = new linkedhashmap<>(); for (int i = 0; i < parsingresult.getprojectedpaths().length; i++) { propertypath<?> p = parsingresult.getprojectedpaths()[i]; list<integer> idx = projectionsmap.get(p); if (idx == null) { idx = new arraylist<>(); projectionsmap.put(p, idx); if (!fieldindexingmetadata.isstored(p.asarraypath())) { allprojectionsarestored = false; } } idx.add(i); } } boolean allsortfieldsarestored = true; sortfield[] sortfields = parsingresult.getsortfields(); if (sortfields != null) { linkedhashmap<string, sortfield> sortfieldmap = new linkedhashmap<>(); for (sortfield sf : sortfields) { propertypath<?> p = sf.getpath(); string asstringpath = p.asstringpath(); if (!sortfieldmap.containskey(asstringpath)) { sortfieldmap.put(asstringpath, sf); if (!fieldindexingmetadata.isstored(p.asarraypath())) { allsortfieldsarestored = false; } } } sortfields = sortfieldmap.values().toarray(new sortfield[sortfieldmap.size()]); } booleshannonexpansion bse = new booleshannonexpansion(max_expansion_cofactors, fieldindexingmetadata); booleanexpr expansion = bse.expand(normalizedwhereclause); if (expansion == normalizedwhereclause) { if (allsortfieldsarestored) { if (allprojectionsarestored) { rowprocessor rowprocessor = null; if (parsingresult.getprojectedpaths() != null) { if (projectionsmap.size() != parsingresult.getprojectedpaths().length) { final class<?>[] projectedtypes = new class<?>[projectionsmap.size()]; final int[] map = new int[parsingresult.getprojectedpaths().length]; int j = 0; for (list<integer> idx : projectionsmap.values()) { int i = idx.get(0); projectedtypes[j] = parsingresult.getprojectedtypes()[i]; for (int k : idx) { map[k] = j; } j++; } rowprocessor projectionprocessor = makeprojectionprocessor(projectedtypes); rowprocessor = inrow -> { if (projectionprocessor != null) { inrow = projectionprocessor.process(inrow); } object[] outrow = new object[map.length]; for (int i = 0; i < map.length; i++) { outrow[i] = inrow[map[i]]; } return outrow; }; propertypath[] deduplicatedprojection = projectionsmap.keyset().toarray(new propertypath[projectionsmap.size()]); ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, deduplicatedprojection, projectedtypes, sortfields); return new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, parsingresult.getprojections(), makeresultprocessor(rowprocessor), startoffset, maxresults); } else { rowprocessor = makeprojectionprocessor(parsingresult.getprojectedtypes()); } } return new embeddedlucenequery<>(this, queryfactory, namedparameters, parsingresult, parsingresult.getprojections(), makeresultprocessor(rowprocessor), startoffset, maxresults); } else { ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, null, null, sortfields); query indexquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), startoffset, maxresults); string projectionquerystr = syntaxtreeprinter.printtree(parsingresult.gettargetentityname(), parsingresult.getprojectedpaths(), null, null); return new hybridquery(queryfactory, cache, projectionquerystr, null, getobjectfilter(matcher, projectionquerystr, null, null), -1, -1, indexquery); } } else { ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, null, null, null); query indexquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), -1, -1); string projectionquerystr = syntaxtreeprinter.printtree(parsingresult.gettargetentityname(), parsingresult.getprojectedpaths(), null, sortfields); return new hybridquery(queryfactory, cache, projectionquerystr, null, getobjectfilter(matcher, projectionquerystr, null, null), startoffset, maxresults, indexquery); } } if (expansion == constantbooleanexpr.true) { return new embeddedquery(this, queryfactory, cache, querystring, namedparameters, parsingresult.getprojections(), startoffset, maxresults); } ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, expansion, null, null, null); query expandedquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), -1, -1); return new hybridquery(queryfactory, cache, querystring, namedparameters, getobjectfilter(matcher, querystring, namedparameters, null), startoffset, maxresults, expandedquery); }","repo":"TomasHofman\/infinispan","label":[1,0,0,0]}
{"id":448,"original_code":"public static char[][] fill(char contents, int width, int height) {\n        char[][] next = new char[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code_wo_comment":"public static char[][] fill(char contents, int width, int height) {\n        char[][] next = new char[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static char[][] fill(char contents, int width, int height) { char[][] next = new char[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":449,"original_code":"public static float[][] fill(float contents, int width, int height) {\n        float[][] next = new float[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code_wo_comment":"public static float[][] fill(float contents, int width, int height) {\n        float[][] next = new float[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static float[][] fill(float contents, int width, int height) { float[][] next = new float[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":450,"original_code":"public static double[][] fill(double contents, int width, int height) {\n        double[][] next = new double[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code_wo_comment":"public static double[][] fill(double contents, int width, int height) {\n        double[][] next = new double[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static double[][] fill(double contents, int width, int height) { double[][] next = new double[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":451,"original_code":"public static int[][] fill(int contents, int width, int height) {\n        int[][] next = new int[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code_wo_comment":"public static int[][] fill(int contents, int width, int height) {\n        int[][] next = new int[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static int[][] fill(int contents, int width, int height) { int[][] next = new int[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":452,"original_code":"public static byte[][] fill(byte contents, int width, int height) {\n        byte[][] next = new byte[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code_wo_comment":"public static byte[][] fill(byte contents, int width, int height) {\n        byte[][] next = new byte[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static byte[][] fill(byte contents, int width, int height) { byte[][] next = new byte[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":453,"original_code":"public static boolean[][] fill(boolean contents, int width, int height) {\n        boolean[][] next = new boolean[width][height];\n        if (contents) {\n            for (int x = 0; x < width; x++) {\n                Arrays.fill(next[x], true);\n            }\n        }\n        return next;\n    }","code_wo_comment":"public static boolean[][] fill(boolean contents, int width, int height) {\n        boolean[][] next = new boolean[width][height];\n        if (contents) {\n            for (int x = 0; x < width; x++) {\n                Arrays.fill(next[x], true);\n            }\n        }\n        return next;\n    }","cleancode":"public static boolean[][] fill(boolean contents, int width, int height) { boolean[][] next = new boolean[width][height]; if (contents) { for (int x = 0; x < width; x++) { arrays.fill(next[x], true); } } return next; }","repo":"SquidPony\/SquidLib","label":[1,0,0,0]}
{"id":16885,"original_code":"@JsonGetter(\"limit\")\n    public String getLimit ( ) { \n        return this.limit;\n    }","code_wo_comment":"@JsonGetter(\"limit\")\n    public String getLimit ( ) { \n        return this.limit;\n    }","cleancode":"@jsongetter(\"limit\") public string getlimit ( ) { return this.limit; }","repo":"adams-okode\/chirpstack-rest-sdk","label":[0,0,0,0]}
{"id":25078,"original_code":"@Override\n\tprotected void execute(CalculationMonitor monitor){\n\t\t\/\/ import the image data into 1D arrays : TO DO\n\t\tImageDataFloat\tlayersImg = new ImageDataFloat(layersImage.getImageData());\n\t\tImageDataFloat\tintensImg = new ImageDataFloat(intensityImage.getImageData());\n\t\tint nx = layersImg.getRows();\n\t\tint ny = layersImg.getCols();\n\t\tint nz = layersImg.getSlices();\n\t\tint nlayers = layersImg.getComponents()-1;\n\t\tint nxyz = nx*ny*nz;\n\t\tfloat rx = layersImg.getHeader().getDimResolutions()[0];\n\t\tfloat ry = layersImg.getHeader().getDimResolutions()[1];\n\t\tfloat rz = layersImg.getHeader().getDimResolutions()[2];\n\t\tfloat[][] layers = new float[nlayers+1][nxyz];\n\t\tfloat[][][][] buffer4 = layersImg.toArray4d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tlayers[l][xyz] = buffer4[x][y][z][l];\n\t\t}\n\t\tbuffer4 = null;\n\t\tlayersImg = null;\n\t\tfloat[] intensity = new float[nxyz];\n\t\tfloat[][][] buffer3 = intensImg.toArray3d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tintensity[xyz] = buffer3[x][y][z];\n\t\t}\n\t\tbuffer3 = null;\n\t\tintensImg = null;\n\t\t\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\n\t\tboolean[] ctxmask = new boolean[nxyz];\n\t\tif (maskImage.getImageData()!=null) {\n\t\t\tImageDataUByte\tmaskImg = new ImageDataUByte(maskImage.getImageData());\n\t\t\tbyte[][][] bufferbyte = maskImg.toArray3d();\n\t\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n\t\t\t}\n\t\t\tbufferbyte = null;\n\t\t\tmaskImg = null;\n\t\t} else {\n\t\t\tfor (int xyz=0;xyz<nxyz;xyz++) {\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n\t\t\t}\n\t\t}\n\t\t\/\/ main algorithm\n\t\t\/\/ 1. define partial voume for each layer, each voxel\n\t\tfloat[][] pvol = new float[nlayers+1][nxyz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfor (int l=0;l<=nlayers;l++) {\n\t\t\t\t\tpvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ 2. build and invert the GLM for each profile \/ voxel?\n\t\tfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\n\t\tfloat maskval = 1e13f;\n\t\tfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\n\t\tfloat[][][] residual = new float[nx][ny][nz];\n\t\tBitSet sampled = new BitSet(nx*ny*nz);\n\t\tfloat[] profiledist = new float[nx*ny*nz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\n\t\t\t\tint nsample = sampled.size();\n\t\t\t\tif (nsample>=nlayers) {\n\t\t\t\t\tdouble[][] glm = new double[nlayers][nsample];\n\t\t\t\t\tdouble[][] data = new double[nsample][1];\n\t\t\t\t\tint idx = 0;\n\t\t\t\t\tfor (int n=0;n<nsample;n++) {\n\t\t\t\t\t\t\/\/ get the next non-zero value\n\t\t\t\t\t\tidx = sampled.nextSetBit(idx);\n\t\t\t\t\t\t\/\/ build a weighting function based on distance to the original location\n\t\t\t\t\t\tdouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\n\t\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\t\tglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[n][0] = weight*intensity[idx];\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ invert the linear model\n\t\t\t\t\tMatrix mtx = new Matrix(glm);\n\t\t\t\t\tMatrix smp = new Matrix(data);\n\t\t\t\t\tMatrix val = mtx.solve(smp);\n\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\tmapping[x][y][z][l] = (float)val.get(l,0);\n\t\t\t\t\t}\n\t\t\t\t\tMatrix res = mtx.times(val).minus(smp);\n\t\t\t\t\tresidual[x][y][z] = (float)res.normInf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ output\n\t\tString imgname = intensityImage.getImageData().getName();\n\t\tImageDataFloat mapData = new ImageDataFloat(mapping);\t\t\n\t\tmapData.setHeader(layersImage.getImageData().getHeader());\n\t\tmapData.setName(imgname+\"_glmprofiles\");\n\t\tmappedImage.setValue(mapData);\n\t\tmapData = null;\n\t\tmapping = null;\n\t\tImageDataFloat resData = new ImageDataFloat(residual);\t\t\n\t\tresData.setHeader(layersImage.getImageData().getHeader());\n\t\tresData.setName(imgname+\"_glmresidual\");\n\t\tresidualImage.setValue(resData);\n\t\tresData = null;\n\t\tresidual = null;\n\t}","code_wo_comment":"@Override\n\tprotected void execute(CalculationMonitor monitor){\n\t\n\t\tImageDataFloat\tlayersImg = new ImageDataFloat(layersImage.getImageData());\n\t\tImageDataFloat\tintensImg = new ImageDataFloat(intensityImage.getImageData());\n\t\tint nx = layersImg.getRows();\n\t\tint ny = layersImg.getCols();\n\t\tint nz = layersImg.getSlices();\n\t\tint nlayers = layersImg.getComponents()-1;\n\t\tint nxyz = nx*ny*nz;\n\t\tfloat rx = layersImg.getHeader().getDimResolutions()[0];\n\t\tfloat ry = layersImg.getHeader().getDimResolutions()[1];\n\t\tfloat rz = layersImg.getHeader().getDimResolutions()[2];\n\t\tfloat[][] layers = new float[nlayers+1][nxyz];\n\t\tfloat[][][][] buffer4 = layersImg.toArray4d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tlayers[l][xyz] = buffer4[x][y][z][l];\n\t\t}\n\t\tbuffer4 = null;\n\t\tlayersImg = null;\n\t\tfloat[] intensity = new float[nxyz];\n\t\tfloat[][][] buffer3 = intensImg.toArray3d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tintensity[xyz] = buffer3[x][y][z];\n\t\t}\n\t\tbuffer3 = null;\n\t\tintensImg = null;\n\t\n\t\tboolean[] ctxmask = new boolean[nxyz];\n\t\tif (maskImage.getImageData()!=null) {\n\t\t\tImageDataUByte\tmaskImg = new ImageDataUByte(maskImage.getImageData());\n\t\t\tbyte[][][] bufferbyte = maskImg.toArray3d();\n\t\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n\t\t\t}\n\t\t\tbufferbyte = null;\n\t\t\tmaskImg = null;\n\t\t} else {\n\t\t\tfor (int xyz=0;xyz<nxyz;xyz++) {\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfloat[][] pvol = new float[nlayers+1][nxyz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfor (int l=0;l<=nlayers;l++) {\n\t\t\t\t\tpvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\n\t\tfloat maskval = 1e13f;\n\t\tfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\n\t\tfloat[][][] residual = new float[nx][ny][nz];\n\t\tBitSet sampled = new BitSet(nx*ny*nz);\n\t\tfloat[] profiledist = new float[nx*ny*nz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\n\t\t\t\tint nsample = sampled.size();\n\t\t\t\tif (nsample>=nlayers) {\n\t\t\t\t\tdouble[][] glm = new double[nlayers][nsample];\n\t\t\t\t\tdouble[][] data = new double[nsample][1];\n\t\t\t\t\tint idx = 0;\n\t\t\t\t\tfor (int n=0;n<nsample;n++) {\n\t\t\t\t\t\n\t\t\t\t\t\tidx = sampled.nextSetBit(idx);\n\t\t\t\t\t\n\t\t\t\t\t\tdouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\n\t\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\t\tglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[n][0] = weight*intensity[idx];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tMatrix mtx = new Matrix(glm);\n\t\t\t\t\tMatrix smp = new Matrix(data);\n\t\t\t\t\tMatrix val = mtx.solve(smp);\n\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\tmapping[x][y][z][l] = (float)val.get(l,0);\n\t\t\t\t\t}\n\t\t\t\t\tMatrix res = mtx.times(val).minus(smp);\n\t\t\t\t\tresidual[x][y][z] = (float)res.normInf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tString imgname = intensityImage.getImageData().getName();\n\t\tImageDataFloat mapData = new ImageDataFloat(mapping);\t\t\n\t\tmapData.setHeader(layersImage.getImageData().getHeader());\n\t\tmapData.setName(imgname+\"_glmprofiles\");\n\t\tmappedImage.setValue(mapData);\n\t\tmapData = null;\n\t\tmapping = null;\n\t\tImageDataFloat resData = new ImageDataFloat(residual);\t\t\n\t\tresData.setHeader(layersImage.getImageData().getHeader());\n\t\tresData.setName(imgname+\"_glmresidual\");\n\t\tresidualImage.setValue(resData);\n\t\tresData = null;\n\t\tresidual = null;\n\t}","cleancode":"@override protected void execute(calculationmonitor monitor){ imagedatafloat layersimg = new imagedatafloat(layersimage.getimagedata()); imagedatafloat intensimg = new imagedatafloat(intensityimage.getimagedata()); int nx = layersimg.getrows(); int ny = layersimg.getcols(); int nz = layersimg.getslices(); int nlayers = layersimg.getcomponents()-1; int nxyz = nx*ny*nz; float rx = layersimg.getheader().getdimresolutions()[0]; float ry = layersimg.getheader().getdimresolutions()[1]; float rz = layersimg.getheader().getdimresolutions()[2]; float[][] layers = new float[nlayers+1][nxyz]; float[][][][] buffer4 = layersimg.toarray4d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) { int xyz = x+nx*y+nx*ny*z; layers[l][xyz] = buffer4[x][y][z][l]; } buffer4 = null; layersimg = null; float[] intensity = new float[nxyz]; float[][][] buffer3 = intensimg.toarray3d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) { int xyz = x+nx*y+nx*ny*z; intensity[xyz] = buffer3[x][y][z]; } buffer3 = null; intensimg = null; boolean[] ctxmask = new boolean[nxyz]; if (maskimage.getimagedata()!=null) { imagedataubyte maskimg = new imagedataubyte(maskimage.getimagedata()); byte[][][] bufferbyte = maskimg.toarray3d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) { int xyz = x+nx*y+nx*ny*z; ctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0); } bufferbyte = null; maskimg = null; } else { for (int xyz=0;xyz<nxyz;xyz++) { ctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0); } } float[][] pvol = new float[nlayers+1][nxyz]; for (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) { int xyz = x + nx*y + nx*ny*z; if (ctxmask[xyz]) { for (int l=0;l<=nlayers;l++) { pvol[l][xyz] = partialvolumefromsurface(x, y, z, layers[l], nx, ny, nz); } } } float delta = paramextent.getvalue().floatvalue()\/numerics.min(rx,ry,rz); float stdev = paramstdev.getvalue().floatvalue()\/numerics.min(rx,ry,rz); corticalprofile profile = new corticalprofile(nlayers, nx, ny, nz, rx, ry, rz); float maskval = 1e13f; float[][][][] mapping = new float[nx][ny][nz][nlayers]; float[][][] residual = new float[nx][ny][nz]; bitset sampled = new bitset(nx*ny*nz); float[] profiledist = new float[nx*ny*nz]; for (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) { int xyz = x + nx*y + nx*ny*z; if (ctxmask[xyz]) { findfastmarchingprofileneighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers); int nsample = sampled.size(); if (nsample>=nlayers) { double[][] glm = new double[nlayers][nsample]; double[][] data = new double[nsample][1]; int idx = 0; for (int n=0;n<nsample;n++) { idx = sampled.nextsetbit(idx); double weight = fastmath.exp(-0.5*numerics.square(profiledist[idx]\/stdev)); for (int l=0;l<nlayers;l++) { glm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]); } data[n][0] = weight*intensity[idx]; } matrix mtx = new matrix(glm); matrix smp = new matrix(data); matrix val = mtx.solve(smp); for (int l=0;l<nlayers;l++) { mapping[x][y][z][l] = (float)val.get(l,0); } matrix res = mtx.times(val).minus(smp); residual[x][y][z] = (float)res.norminf(); } } } string imgname = intensityimage.getimagedata().getname(); imagedatafloat mapdata = new imagedatafloat(mapping); mapdata.setheader(layersimage.getimagedata().getheader()); mapdata.setname(imgname+\"_glmprofiles\"); mappedimage.setvalue(mapdata); mapdata = null; mapping = null; imagedatafloat resdata = new imagedatafloat(residual); resdata.setheader(layersimage.getimagedata().getheader()); resdata.setname(imgname+\"_glmresidual\"); residualimage.setvalue(resdata); resdata = null; residual = null; }","repo":"alaurent4\/nighres","label":[0,1,0,0]}
{"id":16887,"original_code":"@JsonGetter(\"offset\")\n    public String getOffset ( ) { \n        return this.offset;\n    }","code_wo_comment":"@JsonGetter(\"offset\")\n    public String getOffset ( ) { \n        return this.offset;\n    }","cleancode":"@jsongetter(\"offset\") public string getoffset ( ) { return this.offset; }","repo":"adams-okode\/chirpstack-rest-sdk","label":[0,0,0,0]}
{"id":16886,"original_code":"@JsonSetter(\"limit\")\n    public void setLimit (String value) { \n        this.limit = value;\n    }","code_wo_comment":"@JsonSetter(\"limit\")\n    public void setLimit (String value) { \n        this.limit = value;\n    }","cleancode":"@jsonsetter(\"limit\") public void setlimit (string value) { this.limit = value; }","repo":"adams-okode\/chirpstack-rest-sdk","label":[0,0,0,0]}
{"id":16888,"original_code":"@JsonSetter(\"offset\")\n    public void setOffset (String value) { \n        this.offset = value;\n    }","code_wo_comment":"@JsonSetter(\"offset\")\n    public void setOffset (String value) { \n        this.offset = value;\n    }","cleancode":"@jsonsetter(\"offset\") public void setoffset (string value) { this.offset = value; }","repo":"adams-okode\/chirpstack-rest-sdk","label":[0,0,0,0]}
{"id":25180,"original_code":"public static int staticCompare(UUID u1, UUID u2)\n    {\n        \/\/ First: major sorting by types\n        int type = u1.version();\n        int diff = type - u2.version();\n        if (diff != 0) {\n            return diff;\n        }\n        \/\/ Second: for time-based variant, order by time stamp:\n        if (type == UUIDType.TIME_BASED.raw()) {\n            diff = compareULongs(u1.timestamp(), u2.timestamp());\n            if (diff == 0) {\n                \/\/ or if that won't work, by other bits lexically\n                diff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n            }\n        } else {\n            \/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\n            diff = compareULongs(u1.getMostSignificantBits(),\n                    u2.getMostSignificantBits());\n            if (diff == 0) {\n                diff = compareULongs(u1.getLeastSignificantBits(),\n                        u2.getLeastSignificantBits());\n            }\n        }\n        return diff;\n    }","code_wo_comment":"public static int staticCompare(UUID u1, UUID u2)\n    {\n       \n        int type = u1.version();\n        int diff = type - u2.version();\n        if (diff != 0) {\n            return diff;\n        }\n       \n        if (type == UUIDType.TIME_BASED.raw()) {\n            diff = compareULongs(u1.timestamp(), u2.timestamp());\n            if (diff == 0) {\n               \n                diff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n            }\n        } else {\n           \n            diff = compareULongs(u1.getMostSignificantBits(),\n                    u2.getMostSignificantBits());\n            if (diff == 0) {\n                diff = compareULongs(u1.getLeastSignificantBits(),\n                        u2.getLeastSignificantBits());\n            }\n        }\n        return diff;\n    }","cleancode":"public static int staticcompare(uuid u1, uuid u2) { int type = u1.version(); int diff = type - u2.version(); if (diff != 0) { return diff; } if (type == uuidtype.time_based.raw()) { diff = compareulongs(u1.timestamp(), u2.timestamp()); if (diff == 0) { diff = compareulongs(u1.getleastsignificantbits(), u2.getleastsignificantbits()); } } else { diff = compareulongs(u1.getmostsignificantbits(), u2.getmostsignificantbits()); if (diff == 0) { diff = compareulongs(u1.getleastsignificantbits(), u2.getleastsignificantbits()); } } return diff; }","repo":"andrebrait\/java-uuid-generator","label":[0,0,0,0]}
{"id":653,"original_code":"public PlayerPathData populateStats() {\n        this.playerEntity = strongholdPath.getPlayerEntity();\n        StrongholdGenerator.Start start = this.strongholdPath.getStart();\n        StrongholdTreeAccessor treeAccessor = (StrongholdTreeAccessor) start;\n        List<StrongholdPathEntry> history = this.strongholdPath.getHistory();\n        ArrayList<StructurePiece> solution = new ArrayList<>();\n        StrongholdGenerator.Piece current = this.strongholdPath.getHistory().get(strongholdPath.getHistory().size() - 1).getCurrentPiece();\n        while (current != null) {\n            solution.add(current);\n            current = (StrongholdGenerator.Piece) treeAccessor.getParents().get(current);\n        }\n        List<StrongholdPathEntry> validEntries = history.stream()\n                .filter(entry -> validateEntryForLoss(strongholdPath, strongholdPath.getNextEntry(entry)))\n                .filter(entry -> !solution.contains(strongholdPath.getNextEntry(entry).getCurrentPiece()) && solution.contains(entry.getCurrentPiece()))\n                .collect(Collectors.toList());\n        List<Pair<StrongholdPathEntry, Double>> losses = new ArrayList<>();\n        validEntries.forEach(strongholdPathEntry -> losses.add(new Pair<>(strongholdPathEntry, loss(strongholdPath, strongholdPath.getNextEntry(strongholdPathEntry), solution))));\n        this.inaccuracies = losses.stream().filter(pair -> pair.getRight() >= INACCURACY_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.mistakes = losses.stream().filter(pair -> pair.getRight() >= MISTAKE_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.blunders = losses.stream().filter(pair -> pair.getRight() >= BLUNDER_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        inaccuracies.removeAll(this.mistakes);\n        mistakes.removeAll(this.blunders);\n        ArrayList<Pair<StrongholdGenerator.Piece, Integer>> rooms = new ArrayList<>();\n        history.forEach(pathEntry -> {\n            Pair<StrongholdGenerator.Piece, Integer> pair = new Pair<>(pathEntry.getCurrentPiece(), pathEntry.getTicksSpentInPiece().get());\n            rooms.add(pair);\n        });\n        return new PlayerPathData(\n                rooms,\n                strongholdPath.getTotalTime(),\n                computeDifficulty(solution),\n                history.stream()\n                        .filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n                        .map(StrongholdPathEntry::getTicksSpentInPiece)\n                        .mapToInt(AtomicInteger::get)\n                        .sum(),\n                \/\/ TODO: don't count entering the first Five-Way\n                (int) history.stream()\n                        .map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n                        .filter(Objects::nonNull)\n                        .map(StrongholdPathEntry::getCurrentPiece)\n                        .filter(solution::contains)\n                        .count(),\n                this.inaccuracies.size(),\n                this.mistakes.size(),\n                this.blunders.size(),\n                (int) history.stream()\n                        .filter(entry -> !(entry.getCurrentPiece() instanceof StrongholdGenerator.PortalRoom))\n                        .filter(entry -> !areAdjacent(entry.getCurrentPiece(), strongholdPath.getNextEntry(entry).getCurrentPiece(), treeAccessor))\n                        .count(),\n                history.size() - 1,\n                history.stream()\n                        .filter(entry -> FEINBERG_AVG_ROOM_TIMES.containsKey(entry.getCurrentPiece().getClass()))\n                        .mapToInt(value -> value.getTicksSpentInPiece().get() - FEINBERG_AVG_ROOM_TIMES.get(value.getCurrentPiece().getClass()))\n                        .sum()\n        );\n    }","code_wo_comment":"public PlayerPathData populateStats() {\n        this.playerEntity = strongholdPath.getPlayerEntity();\n        StrongholdGenerator.Start start = this.strongholdPath.getStart();\n        StrongholdTreeAccessor treeAccessor = (StrongholdTreeAccessor) start;\n        List<StrongholdPathEntry> history = this.strongholdPath.getHistory();\n        ArrayList<StructurePiece> solution = new ArrayList<>();\n        StrongholdGenerator.Piece current = this.strongholdPath.getHistory().get(strongholdPath.getHistory().size() - 1).getCurrentPiece();\n        while (current != null) {\n            solution.add(current);\n            current = (StrongholdGenerator.Piece) treeAccessor.getParents().get(current);\n        }\n        List<StrongholdPathEntry> validEntries = history.stream()\n                .filter(entry -> validateEntryForLoss(strongholdPath, strongholdPath.getNextEntry(entry)))\n                .filter(entry -> !solution.contains(strongholdPath.getNextEntry(entry).getCurrentPiece()) && solution.contains(entry.getCurrentPiece()))\n                .collect(Collectors.toList());\n        List<Pair<StrongholdPathEntry, Double>> losses = new ArrayList<>();\n        validEntries.forEach(strongholdPathEntry -> losses.add(new Pair<>(strongholdPathEntry, loss(strongholdPath, strongholdPath.getNextEntry(strongholdPathEntry), solution))));\n        this.inaccuracies = losses.stream().filter(pair -> pair.getRight() >= INACCURACY_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.mistakes = losses.stream().filter(pair -> pair.getRight() >= MISTAKE_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.blunders = losses.stream().filter(pair -> pair.getRight() >= BLUNDER_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        inaccuracies.removeAll(this.mistakes);\n        mistakes.removeAll(this.blunders);\n        ArrayList<Pair<StrongholdGenerator.Piece, Integer>> rooms = new ArrayList<>();\n        history.forEach(pathEntry -> {\n            Pair<StrongholdGenerator.Piece, Integer> pair = new Pair<>(pathEntry.getCurrentPiece(), pathEntry.getTicksSpentInPiece().get());\n            rooms.add(pair);\n        });\n        return new PlayerPathData(\n                rooms,\n                strongholdPath.getTotalTime(),\n                computeDifficulty(solution),\n                history.stream()\n                        .filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n                        .map(StrongholdPathEntry::getTicksSpentInPiece)\n                        .mapToInt(AtomicInteger::get)\n                        .sum(),\n               \n                (int) history.stream()\n                        .map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n                        .filter(Objects::nonNull)\n                        .map(StrongholdPathEntry::getCurrentPiece)\n                        .filter(solution::contains)\n                        .count(),\n                this.inaccuracies.size(),\n                this.mistakes.size(),\n                this.blunders.size(),\n                (int) history.stream()\n                        .filter(entry -> !(entry.getCurrentPiece() instanceof StrongholdGenerator.PortalRoom))\n                        .filter(entry -> !areAdjacent(entry.getCurrentPiece(), strongholdPath.getNextEntry(entry).getCurrentPiece(), treeAccessor))\n                        .count(),\n                history.size() - 1,\n                history.stream()\n                        .filter(entry -> FEINBERG_AVG_ROOM_TIMES.containsKey(entry.getCurrentPiece().getClass()))\n                        .mapToInt(value -> value.getTicksSpentInPiece().get() - FEINBERG_AVG_ROOM_TIMES.get(value.getCurrentPiece().getClass()))\n                        .sum()\n        );\n    }","cleancode":"public playerpathdata populatestats() { this.playerentity = strongholdpath.getplayerentity(); strongholdgenerator.start start = this.strongholdpath.getstart(); strongholdtreeaccessor treeaccessor = (strongholdtreeaccessor) start; list<strongholdpathentry> history = this.strongholdpath.gethistory(); arraylist<structurepiece> solution = new arraylist<>(); strongholdgenerator.piece current = this.strongholdpath.gethistory().get(strongholdpath.gethistory().size() - 1).getcurrentpiece(); while (current != null) { solution.add(current); current = (strongholdgenerator.piece) treeaccessor.getparents().get(current); } list<strongholdpathentry> validentries = history.stream() .filter(entry -> validateentryforloss(strongholdpath, strongholdpath.getnextentry(entry))) .filter(entry -> !solution.contains(strongholdpath.getnextentry(entry).getcurrentpiece()) && solution.contains(entry.getcurrentpiece())) .collect(collectors.tolist()); list<pair<strongholdpathentry, double>> losses = new arraylist<>(); validentries.foreach(strongholdpathentry -> losses.add(new pair<>(strongholdpathentry, loss(strongholdpath, strongholdpath.getnextentry(strongholdpathentry), solution)))); this.inaccuracies = losses.stream().filter(pair -> pair.getright() >= inaccuracy_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); this.mistakes = losses.stream().filter(pair -> pair.getright() >= mistake_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); this.blunders = losses.stream().filter(pair -> pair.getright() >= blunder_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); inaccuracies.removeall(this.mistakes); mistakes.removeall(this.blunders); arraylist<pair<strongholdgenerator.piece, integer>> rooms = new arraylist<>(); history.foreach(pathentry -> { pair<strongholdgenerator.piece, integer> pair = new pair<>(pathentry.getcurrentpiece(), pathentry.getticksspentinpiece().get()); rooms.add(pair); }); return new playerpathdata( rooms, strongholdpath.gettotaltime(), computedifficulty(solution), history.stream() .filter(pathentry -> !solution.contains(pathentry.getcurrentpiece())) .map(strongholdpathentry::getticksspentinpiece) .maptoint(atomicinteger::get) .sum(), (int) history.stream() .map(strongholdpathentry -> strongholdpath.getnextentry(strongholdpathentry)) .filter(objects::nonnull) .map(strongholdpathentry::getcurrentpiece) .filter(solution::contains) .count(), this.inaccuracies.size(), this.mistakes.size(), this.blunders.size(), (int) history.stream() .filter(entry -> !(entry.getcurrentpiece() instanceof strongholdgenerator.portalroom)) .filter(entry -> !areadjacent(entry.getcurrentpiece(), strongholdpath.getnextentry(entry).getcurrentpiece(), treeaccessor)) .count(), history.size() - 1, history.stream() .filter(entry -> feinberg_avg_room_times.containskey(entry.getcurrentpiece().getclass())) .maptoint(value -> value.getticksspentinpiece().get() - feinberg_avg_room_times.get(value.getcurrentpiece().getclass())) .sum() ); }","repo":"ScribbleLP\/StrongholdTrainer","label":[0,1,0,0]}
{"id":17055,"original_code":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\n\t\t\tString reportLink) throws Exception {\n\t\tMimeMessage message = sender.createMimeMessage();\n\t\tMimeMessageHelper helper = new MimeMessageHelper(message);\n\t\tString stud1 = userService.findById(userId1).getfName();\n\t\tString stud2 = userService.findById(userId2).getfName();\n\t\thelper.setTo(\"anubhuti.vyas.28@gmail.com\");\n\t\thelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n\t\t\t\t+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n\t\t\t\t+ reportLink+ \"\/match0.html\");\n\t\t\/\/ to do add link in email\n\t\thelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\n\t\tsender.send(message);\n\t}","code_wo_comment":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\n\t\t\tString reportLink) throws Exception {\n\t\tMimeMessage message = sender.createMimeMessage();\n\t\tMimeMessageHelper helper = new MimeMessageHelper(message);\n\t\tString stud1 = userService.findById(userId1).getfName();\n\t\tString stud2 = userService.findById(userId2).getfName();\n\t\thelper.setTo(\"anubhuti.vyas.28@gmail.com\");\n\t\thelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n\t\t\t\t+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n\t\t\t\t+ reportLink+ \"\/match0.html\");\n\t\n\t\thelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\n\t\tsender.send(message);\n\t}","cleancode":"public void sendemail(string userid1, string userid2, string asgmtname, double score, string recipientmail, string reportlink) throws exception { mimemessage message = sender.createmimemessage(); mimemessagehelper helper = new mimemessagehelper(message); string stud1 = userservice.findbyid(userid1).getfname(); string stud2 = userservice.findbyid(userid2).getfname(); helper.setto(\"anubhuti.vyas.28@gmail.com\"); helper.settext(\"codesniffer found plagiarised submission with similarity score\" + score + \"click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\" + reportlink+ \"\/match0.html\"); helper.setsubject(\"plag detected in \" + asgmtname + \" between \" + stud1 + \" and \" + stud2); sender.send(message); }","repo":"Stephen3333\/codesniffer","label":[0,1,0,0]}
{"id":17081,"original_code":"@Override\n    public void refresh()\n            throws LoginException, GSSException\n    {\n        \/\/ TODO: do we need to call logout() on the LoginContext?\n        loginContext = new LoginContext(\"\", null, null, new Configuration()\n        {\n            @Override\n            public AppConfigurationEntry[] getAppConfigurationEntry(String name)\n            {\n                ImmutableMap.Builder<String, String> options = ImmutableMap.builder();\n                options.put(\"refreshKrb5Config\", \"true\");\n                options.put(\"doNotPrompt\", \"true\");\n                options.put(\"useKeyTab\", \"true\");\n                if (getBoolean(\"trino.client.debugKerberos\")) {\n                    options.put(\"debug\", \"true\");\n                }\n                keytab.ifPresent(file -> options.put(\"keyTab\", file.getAbsolutePath()));\n                credentialCache.ifPresent(file -> {\n                    options.put(\"ticketCache\", file.getAbsolutePath());\n                    options.put(\"renewTGT\", \"true\");\n                });\n                if (!keytab.isPresent() || credentialCache.isPresent()) {\n                    options.put(\"useTicketCache\", \"true\");\n                }\n                principal.ifPresent(value -> options.put(\"principal\", value));\n                return new AppConfigurationEntry[] {\n                        new AppConfigurationEntry(Krb5LoginModule.class.getName(), REQUIRED, options.buildOrThrow())\n                };\n            }\n        });\n        loginContext.login();\n    }","code_wo_comment":"@Override\n    public void refresh()\n            throws LoginException, GSSException\n    {\n       \n        loginContext = new LoginContext(\"\", null, null, new Configuration()\n        {\n            @Override\n            public AppConfigurationEntry[] getAppConfigurationEntry(String name)\n            {\n                ImmutableMap.Builder<String, String> options = ImmutableMap.builder();\n                options.put(\"refreshKrb5Config\", \"true\");\n                options.put(\"doNotPrompt\", \"true\");\n                options.put(\"useKeyTab\", \"true\");\n                if (getBoolean(\"trino.client.debugKerberos\")) {\n                    options.put(\"debug\", \"true\");\n                }\n                keytab.ifPresent(file -> options.put(\"keyTab\", file.getAbsolutePath()));\n                credentialCache.ifPresent(file -> {\n                    options.put(\"ticketCache\", file.getAbsolutePath());\n                    options.put(\"renewTGT\", \"true\");\n                });\n                if (!keytab.isPresent() || credentialCache.isPresent()) {\n                    options.put(\"useTicketCache\", \"true\");\n                }\n                principal.ifPresent(value -> options.put(\"principal\", value));\n                return new AppConfigurationEntry[] {\n                        new AppConfigurationEntry(Krb5LoginModule.class.getName(), REQUIRED, options.buildOrThrow())\n                };\n            }\n        });\n        loginContext.login();\n    }","cleancode":"@override public void refresh() throws loginexception, gssexception { logincontext = new logincontext(\"\", null, null, new configuration() { @override public appconfigurationentry[] getappconfigurationentry(string name) { immutablemap.builder<string, string> options = immutablemap.builder(); options.put(\"refreshkrb5config\", \"true\"); options.put(\"donotprompt\", \"true\"); options.put(\"usekeytab\", \"true\"); if (getboolean(\"trino.client.debugkerberos\")) { options.put(\"debug\", \"true\"); } keytab.ifpresent(file -> options.put(\"keytab\", file.getabsolutepath())); credentialcache.ifpresent(file -> { options.put(\"ticketcache\", file.getabsolutepath()); options.put(\"renewtgt\", \"true\"); }); if (!keytab.ispresent() || credentialcache.ispresent()) { options.put(\"useticketcache\", \"true\"); } principal.ifpresent(value -> options.put(\"principal\", value)); return new appconfigurationentry[] { new appconfigurationentry(krb5loginmodule.class.getname(), required, options.buildorthrow()) }; } }); logincontext.login(); }","repo":"SanjayTechGuru\/TRINO","label":[1,0,0,0]}
{"id":17089,"original_code":"@Override\n      public void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\n          throws IOException, InterruptedException {\n        int defCount = 0;\n        refs.clear();\n        \/\/ We only expect two values, a DEF and a reference, but there might be more.\n        for (BytesWritable type : values) {\n          if (type.getLength() == DEF.getLength()) {\n            defCount++;\n          } else {\n            byte[] bytes = new byte[type.getLength()];\n            System.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\n            refs.add(bytes);\n          }\n        }\n        \/\/ TODO check for more than one def, should not happen\n        List<String> refsList = new ArrayList<>(refs.size());\n        String keyString = null;\n        if (defCount == 0 || refs.size() != 1) {\n          for (byte[] ref : refs) {\n            refsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n          }\n          keyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\n              Bytes.getLong(key.getBytes(), 8));\n          LOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n        }\n        if (defCount == 0 && refs.size() > 0) {\n          \/\/ this is bad, found a node that is referenced but not defined. It must have been\n          \/\/ lost, emit some info about this node for debugging purposes.\n          context.write(new Text(keyString), new Text(refsList.toString()));\n          context.getCounter(Counts.UNDEFINED).increment(1);\n        } else if (defCount > 0 && refs.size() == 0) {\n          \/\/ node is defined but not referenced\n          context.write(new Text(keyString), new Text(\"none\"));\n          context.getCounter(Counts.UNREFERENCED).increment(1);\n        } else {\n          if (refs.size() > 1) {\n            if (refsList != null) {\n              context.write(new Text(keyString), new Text(refsList.toString()));\n            }\n            context.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n          }\n          \/\/ node is defined and referenced\n          context.getCounter(Counts.REFERENCED).increment(1);\n        }\n      }","code_wo_comment":"@Override\n      public void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\n          throws IOException, InterruptedException {\n        int defCount = 0;\n        refs.clear();\n       \n        for (BytesWritable type : values) {\n          if (type.getLength() == DEF.getLength()) {\n            defCount++;\n          } else {\n            byte[] bytes = new byte[type.getLength()];\n            System.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\n            refs.add(bytes);\n          }\n        }\n       \n        List<String> refsList = new ArrayList<>(refs.size());\n        String keyString = null;\n        if (defCount == 0 || refs.size() != 1) {\n          for (byte[] ref : refs) {\n            refsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n          }\n          keyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\n              Bytes.getLong(key.getBytes(), 8));\n          LOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n        }\n        if (defCount == 0 && refs.size() > 0) {\n         \n         \n          context.write(new Text(keyString), new Text(refsList.toString()));\n          context.getCounter(Counts.UNDEFINED).increment(1);\n        } else if (defCount > 0 && refs.size() == 0) {\n         \n          context.write(new Text(keyString), new Text(\"none\"));\n          context.getCounter(Counts.UNREFERENCED).increment(1);\n        } else {\n          if (refs.size() > 1) {\n            if (refsList != null) {\n              context.write(new Text(keyString), new Text(refsList.toString()));\n            }\n            context.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n          }\n         \n          context.getCounter(Counts.REFERENCED).increment(1);\n        }\n      }","cleancode":"@override public void reduce(byteswritable key, iterable<byteswritable> values, context context) throws ioexception, interruptedexception { int defcount = 0; refs.clear(); for (byteswritable type : values) { if (type.getlength() == def.getlength()) { defcount++; } else { byte[] bytes = new byte[type.getlength()]; system.arraycopy(type.getbytes(), 0, bytes, 0, type.getlength()); refs.add(bytes); } } list<string> refslist = new arraylist<>(refs.size()); string keystring = null; if (defcount == 0 || refs.size() != 1) { for (byte[] ref : refs) { refslist.add(comma_joiner.join(bytes.getlong(ref), bytes.getlong(ref, 8))); } keystring = comma_joiner.join(bytes.getlong(key.getbytes()), bytes.getlong(key.getbytes(), 8)); log.error(\"linked list error: key = \" + keystring + \" references = \" + refslist); } if (defcount == 0 && refs.size() > 0) { context.write(new text(keystring), new text(refslist.tostring())); context.getcounter(counts.undefined).increment(1); } else if (defcount > 0 && refs.size() == 0) { context.write(new text(keystring), new text(\"none\")); context.getcounter(counts.unreferenced).increment(1); } else { if (refs.size() > 1) { if (refslist != null) { context.write(new text(keystring), new text(refslist.tostring())); } context.getcounter(counts.extrareferences).increment(refs.size() - 1); } context.getcounter(counts.referenced).increment(1); } }","repo":"YCjia\/kudu","label":[1,1,0,0]}
{"id":748,"original_code":"public boolean addNewTodo(Request req, Response res)\n    {\n        res.type(\"application\/json\");\n        Object o = JSON.parse(req.body());\n        try {\n            if(o.getClass().equals(BasicDBObject.class))\n            {\n                try {\n                    BasicDBObject dbO = (BasicDBObject) o;\n                    String owner = dbO.getString(\"owner\");\n                    \/\/For some reason age is a string right now, caused by angular.\n                    \/\/This is a problem and should not be this way but here ya go\n                    boolean status = dbO.getBoolean(\"status\");\n                    String body = dbO.getString(\"body\");\n                    String category = dbO.getString(\"category\");\n                    System.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\n                    return todoController.addNewTodo(owner, category, body, status);\n                }\n                catch(NullPointerException e)\n                {\n                    System.err.println(\"A value was malformed or omitted, new todo request failed.\");\n                    return false;\n                }\n            }\n            else\n            {\n                System.err.println(\"Expected BasicDBObject, received \" + o.getClass());\n                return false;\n            }\n        }\n        catch(RuntimeException ree)\n        {\n            ree.printStackTrace();\n            return false;\n        }\n    }","code_wo_comment":"public boolean addNewTodo(Request req, Response res)\n    {\n        res.type(\"application\/json\");\n        Object o = JSON.parse(req.body());\n        try {\n            if(o.getClass().equals(BasicDBObject.class))\n            {\n                try {\n                    BasicDBObject dbO = (BasicDBObject) o;\n                    String owner = dbO.getString(\"owner\");\n                   \n                   \n                    boolean status = dbO.getBoolean(\"status\");\n                    String body = dbO.getString(\"body\");\n                    String category = dbO.getString(\"category\");\n                    System.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\n                    return todoController.addNewTodo(owner, category, body, status);\n                }\n                catch(NullPointerException e)\n                {\n                    System.err.println(\"A value was malformed or omitted, new todo request failed.\");\n                    return false;\n                }\n            }\n            else\n            {\n                System.err.println(\"Expected BasicDBObject, received \" + o.getClass());\n                return false;\n            }\n        }\n        catch(RuntimeException ree)\n        {\n            ree.printStackTrace();\n            return false;\n        }\n    }","cleancode":"public boolean addnewtodo(request req, response res) { res.type(\"application\/json\"); object o = json.parse(req.body()); try { if(o.getclass().equals(basicdbobject.class)) { try { basicdbobject dbo = (basicdbobject) o; string owner = dbo.getstring(\"owner\"); boolean status = dbo.getboolean(\"status\"); string body = dbo.getstring(\"body\"); string category = dbo.getstring(\"category\"); system.err.println(\"adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']'); return todocontroller.addnewtodo(owner, category, body, status); } catch(nullpointerexception e) { system.err.println(\"a value was malformed or omitted, new todo request failed.\"); return false; } } else { system.err.println(\"expected basicdbobject, received \" + o.getclass()); return false; } } catch(runtimeexception ree) { ree.printstacktrace(); return false; } }","repo":"UMM-CSci-3601-S18\/lab-4-mongo-voyageurs-national-park","label":[0,0,1,0]}
{"id":25329,"original_code":"public void shutdown() {\n\t\t    try {\n\t\t\t\tLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\n\t\t\t\trunning.set(false);\n\t\t\t\t\/\/ This isn't good, the Jedis object is not thread safe\n\t\t\t\tjedis.disconnect();\n\t\t    } catch (Exception e) {\n\t\t    \tLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n\t\t    }\n\t\t}","code_wo_comment":"public void shutdown() {\n\t\t    try {\n\t\t\t\tLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\n\t\t\t\trunning.set(false);\n\t\t\t\n\t\t\t\tjedis.disconnect();\n\t\t    } catch (Exception e) {\n\t\t    \tLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n\t\t    }\n\t\t}","cleancode":"public void shutdown() { try { logger.info(\"shutting down listener on \" + host + \":\" + port); running.set(false); jedis.disconnect(); } catch (exception e) { logger.error(\"caught exception while shutting down: \" + e.getmessage()); } }","repo":"Samsung\/Spark-CEP","label":[1,0,0,0]}
{"id":17260,"original_code":"public int getLineForVertical(int vertical) {\n        int high = getLineCount(), low = -1, guess;\n        while (high - low > 1) {\n            guess = (high + low) \/ 2;\n            if (getLineTop(guess) > vertical)\n                high = guess;\n            else\n                low = guess;\n        }\n        if (low < 0)\n            return 0;\n        else\n            return low;\n    }","code_wo_comment":"public int getLineForVertical(int vertical) {\n        int high = getLineCount(), low = -1, guess;\n        while (high - low > 1) {\n            guess = (high + low) \/ 2;\n            if (getLineTop(guess) > vertical)\n                high = guess;\n            else\n                low = guess;\n        }\n        if (low < 0)\n            return 0;\n        else\n            return low;\n    }","cleancode":"public int getlineforvertical(int vertical) { int high = getlinecount(), low = -1, guess; while (high - low > 1) { guess = (high + low) \/ 2; if (getlinetop(guess) > vertical) high = guess; else low = guess; } if (low < 0) return 0; else return low; }","repo":"VPeruS\/JotaTextEditor","label":[1,0,0,0]}
{"id":9218,"original_code":"@Override\n    public void visitElement(PsiElement element) {\n        if (this.context.skip(element)) {\n            return;\n        }\n        \/\/ TODO: the refactor\n        this.holder.registerProblem(element, this.context.getMessage());\n    }","code_wo_comment":"@Override\n    public void visitElement(PsiElement element) {\n        if (this.context.skip(element)) {\n            return;\n        }\n       \n        this.holder.registerProblem(element, this.context.getMessage());\n    }","cleancode":"@override public void visitelement(psielement element) { if (this.context.skip(element)) { return; } this.holder.registerproblem(element, this.context.getmessage()); }","repo":"aarthibl\/intellibot","label":[1,0,0,0]}
{"id":9220,"original_code":"private static ConfigurationOptions defaultOptions() {\n        return ConfigurationOptions.defaults()\n                .serializers(SpongeCommon.game().configManager().serializers());\n    }","code_wo_comment":"private static ConfigurationOptions defaultOptions() {\n        return ConfigurationOptions.defaults()\n                .serializers(SpongeCommon.game().configManager().serializers());\n    }","cleancode":"private static configurationoptions defaultoptions() { return configurationoptions.defaults() .serializers(spongecommon.game().configmanager().serializers()); }","repo":"SpongePowered\/Common","label":[1,0,0,0]}
{"id":25606,"original_code":"@Test\n\tpublic void testRetrieveUserByName() {\n\t\tem.getTransaction().begin();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\n\t\tem.getTransaction().commit();\n\t\tList<User> users = null;\n\t\ttry {\n\t\t\t\/\/TODO use .equals() once we ahve overridden appropriate methods\n\t\t\tusers = dao.getUsers();\n\t\t} catch (Throwable th){\n\t\t\tfail(th.getMessage());\n\t\t}\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\n\t\tassertEquals(3, users.size());\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\n\t\t\tassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());\n\t\t\tassertEquals(cal.getTime().toString(), users.get(i).getDate().toString());\n\t\t}\n\t}","code_wo_comment":"@Test\n\tpublic void testRetrieveUserByName() {\n\t\tem.getTransaction().begin();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\n\t\tem.getTransaction().commit();\n\t\tList<User> users = null;\n\t\ttry {\n\t\t\n\t\t\tusers = dao.getUsers();\n\t\t} catch (Throwable th){\n\t\t\tfail(th.getMessage());\n\t\t}\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\n\t\tassertEquals(3, users.size());\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\n\t\t\tassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());\n\t\t\tassertEquals(cal.getTime().toString(), users.get(i).getDate().toString());\n\t\t}\n\t}","cleancode":"@test public void testretrieveuserbyname() { em.gettransaction().begin(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (1, 'boom1', '1988-09-15', 'test user1');\").executeupdate(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (2, 'boom2', '1988-09-15', 'test user2');\").executeupdate(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (3, 'boom3', '1988-09-15', 'test user3');\").executeupdate(); em.gettransaction().commit(); list<user> users = null; try { users = dao.getusers(); } catch (throwable th){ fail(th.getmessage()); } calendar cal = calendar.getinstance(); cal.set(1988, calendar.september, 15, 0, 0, 0); assertequals(3, users.size()); for (int i = 0; i < 3; i++) { assertequals(\"boom\" + users.get(i).getid(), users.get(i).getname()); assertequals(\"test user\" + users.get(i).getid(), users.get(i).getdescription()); assertequals(cal.gettime().tostring(), users.get(i).getdate().tostring()); } }","repo":"andrewflbarnes\/debt-tracker","label":[0,1,0,0]}
{"id":1134,"original_code":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\n\t\t\tKeyedBackendSerializationProxy<K> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\n\t\t\tserializationProxy.read(currentStateHandleInView);\n\t\t\t\/\/ check for key serializer compatibility; this also reconfigures the\n\t\t\t\/\/ key serializer to be compatible, if it is required and is possible\n\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\trocksDBKeyedStateBackend.keySerializer)\n\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\n\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t}\n\t\t\tthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\n\t\t\t\tSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\n\t\t\tList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\n\t\t\t\t\tserializationProxy.getStateMetaInfoSnapshots();\n\t\t\tcurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\t\t\t\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\n\t\t\tfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\n\t\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\n\t\t\t\tif (registeredColumn == null) {\n\t\t\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\n\t\t\t\t\t\trestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\n\t\t\t\t\t\trocksDBKeyedStateBackend.columnOptions);\n\t\t\t\t\tRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\n\t\t\t\t\t\t\tnew RegisteredKeyedBackendStateMetaInfo<>(\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateType(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getName(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getNamespaceSerializer(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateSerializer());\n\t\t\t\t\trocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\n\t\t\t\t\tColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\n\t\t\t\t\tregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n\t\t\t\t}\n\t\t\t\tcurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n\t\t\t}\n\t\t}","code_wo_comment":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\n\t\t\tKeyedBackendSerializationProxy<K> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\n\t\t\tserializationProxy.read(currentStateHandleInView);\n\t\t\n\t\t\n\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\trocksDBKeyedStateBackend.keySerializer)\n\t\t\t\t.isRequiresMigration()) {\n\t\t\t\n\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t}\n\t\t\tthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\n\t\t\t\tSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\n\t\t\tList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\n\t\t\t\t\tserializationProxy.getStateMetaInfoSnapshots();\n\t\t\tcurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\t\t\n\t\t\tfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\n\t\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\n\t\t\t\tif (registeredColumn == null) {\n\t\t\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\n\t\t\t\t\t\trestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\n\t\t\t\t\t\trocksDBKeyedStateBackend.columnOptions);\n\t\t\t\t\tRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\n\t\t\t\t\t\t\tnew RegisteredKeyedBackendStateMetaInfo<>(\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateType(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getName(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getNamespaceSerializer(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateSerializer());\n\t\t\t\t\trocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\n\t\t\t\t\tColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\n\t\t\t\t\tregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n\t\t\t}\n\t\t}","cleancode":"private void restorekvstatemetadata() throws ioexception, statemigrationexception, rocksdbexception { keyedbackendserializationproxy<k> serializationproxy = new keyedbackendserializationproxy<>(rocksdbkeyedstatebackend.usercodeclassloader); serializationproxy.read(currentstatehandleinview); if (compatibilityutil.resolvecompatibilityresult( serializationproxy.getkeyserializer(), unloadabledummytypeserializer.class, serializationproxy.getkeyserializerconfigsnapshot(), rocksdbkeyedstatebackend.keyserializer) .isrequiresmigration()) { throw new statemigrationexception(\"the new key serializer is not compatible to read previous keys. \" + \"aborting now since state migration is currently not available\"); } this.keygroupstreamcompressiondecorator = serializationproxy.isusingkeygroupcompression() ? snappystreamcompressiondecorator.instance : uncompressedstreamcompressiondecorator.instance; list<registeredkeyedbackendstatemetainfo.snapshot<?, ?>> restoredmetainfos = serializationproxy.getstatemetainfosnapshots(); currentstatehandlekvstatecolumnfamilies = new arraylist<>(restoredmetainfos.size()); for (registeredkeyedbackendstatemetainfo.snapshot<?, ?> restoredmetainfo : restoredmetainfos) { tuple2<columnfamilyhandle, registeredkeyedbackendstatemetainfo<?, ?>> registeredcolumn = rocksdbkeyedstatebackend.kvstateinformation.get(restoredmetainfo.getname()); if (registeredcolumn == null) { columnfamilydescriptor columnfamilydescriptor = new columnfamilydescriptor( restoredmetainfo.getname().getbytes(configconstants.default_charset), rocksdbkeyedstatebackend.columnoptions); registeredkeyedbackendstatemetainfo<?, ?> statemetainfo = new registeredkeyedbackendstatemetainfo<>( restoredmetainfo.getstatetype(), restoredmetainfo.getname(), restoredmetainfo.getnamespaceserializer(), restoredmetainfo.getstateserializer()); rocksdbkeyedstatebackend.restoredkvstatemetainfos.put(restoredmetainfo.getname(), restoredmetainfo); columnfamilyhandle columnfamily = rocksdbkeyedstatebackend.db.createcolumnfamily(columnfamilydescriptor); registeredcolumn = new tuple2<columnfamilyhandle, registeredkeyedbackendstatemetainfo<?, ?>>(columnfamily, statemetainfo); rocksdbkeyedstatebackend.kvstateinformation.put(statemetainfo.getname(), registeredcolumn); } else { } currentstatehandlekvstatecolumnfamilies.add(registeredcolumn.f0); } }","repo":"alpinegizmo\/flink","label":[1,1,0,0]}
{"id":1136,"original_code":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\n\t\t\t\tStreamStateHandle metaStateHandle) throws Exception {\n\t\t\tFSDataInputStream inputStream = null;\n\t\t\ttry {\n\t\t\t\tinputStream = metaStateHandle.openInputStream();\n\t\t\t\tstateBackend.cancelStreamRegistry.registerClosable(inputStream);\n\t\t\t\tKeyedBackendSerializationProxy<T> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\n\t\t\t\tDataInputView in = new DataInputViewStreamWrapper(inputStream);\n\t\t\t\tserializationProxy.read(in);\n\t\t\t\t\/\/ check for key serializer compatibility; this also reconfigures the\n\t\t\t\t\/\/ key serializer to be compatible, if it is required and is possible\n\t\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\t\tstateBackend.keySerializer)\n\t\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\t\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\n\t\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t\t}\n\t\t\t\treturn serializationProxy.getStateMetaInfoSnapshots();\n\t\t\t} finally {\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}","code_wo_comment":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\n\t\t\t\tStreamStateHandle metaStateHandle) throws Exception {\n\t\t\tFSDataInputStream inputStream = null;\n\t\t\ttry {\n\t\t\t\tinputStream = metaStateHandle.openInputStream();\n\t\t\t\tstateBackend.cancelStreamRegistry.registerClosable(inputStream);\n\t\t\t\tKeyedBackendSerializationProxy<T> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\n\t\t\t\tDataInputView in = new DataInputViewStreamWrapper(inputStream);\n\t\t\t\tserializationProxy.read(in);\n\t\t\t\n\t\t\t\n\t\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\t\tstateBackend.keySerializer)\n\t\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\n\t\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t\t}\n\t\t\t\treturn serializationProxy.getStateMetaInfoSnapshots();\n\t\t\t} finally {\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private list<registeredkeyedbackendstatemetainfo.snapshot<?, ?>> readmetadata( streamstatehandle metastatehandle) throws exception { fsdatainputstream inputstream = null; try { inputstream = metastatehandle.openinputstream(); statebackend.cancelstreamregistry.registerclosable(inputstream); keyedbackendserializationproxy<t> serializationproxy = new keyedbackendserializationproxy<>(statebackend.usercodeclassloader); datainputview in = new datainputviewstreamwrapper(inputstream); serializationproxy.read(in); if (compatibilityutil.resolvecompatibilityresult( serializationproxy.getkeyserializer(), unloadabledummytypeserializer.class, serializationproxy.getkeyserializerconfigsnapshot(), statebackend.keyserializer) .isrequiresmigration()) { throw new statemigrationexception(\"the new key serializer is not compatible to read previous keys. \" + \"aborting now since state migration is currently not available\"); } return serializationproxy.getstatemetainfosnapshots(); } finally { if (inputstream != null) { statebackend.cancelstreamregistry.unregisterclosable(inputstream); inputstream.close(); } } }","repo":"alpinegizmo\/flink","label":[1,0,0,0]}
{"id":25762,"original_code":"@Test\n    public void testCreateDbAndTable() throws Exception {\n        \/\/ 1. create connect context\n        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n        \/\/ 2. create database db1\n        String createDbStmtStr = \"create database db1;\";\n        CreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\n        Catalog.getCurrentCatalog().createDb(createDbStmt);\n        System.out.println(Catalog.getCurrentCatalog().getDbNames());\n        \/\/ 3. create table tbl1\n        String createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n                \"'colocate_with' = 'g1');\";\n        CreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\n        Catalog.getCurrentCatalog().createTable(createTableStmt);\n        \/\/ must set replicas' path hash, or the tablet scheduler won't work\n        updateReplicaPathHash();\n        \/\/ 4. get and test the created db and table\n        Database db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\n        Assert.assertNotNull(db);\n        OlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl.readLock();\n        try {\n            Assert.assertNotNull(tbl);\n            System.out.println(tbl.getName());\n            Assert.assertEquals(\"Doris\", tbl.getEngine());\n            Assert.assertEquals(1, tbl.getBaseSchema().size());\n        } finally {\n            tbl.readUnlock();\n        }\n        \/\/ 5. process a schema change job\n        String alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\n        AlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\n        Catalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n        \/\/ 6. check alter job\n        Map<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\n        Assert.assertEquals(1, alterJobs.size());\n        for (AlterJobV2 alterJobV2 : alterJobs.values()) {\n            while (!alterJobV2.getJobState().isFinalState()) {\n                System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\n                Thread.sleep(1000);\n            }\n            System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\n            Assert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n        }\n        OlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl1.readLock();\n        try {\n            Assert.assertEquals(2, tbl1.getBaseSchema().size());\n            String baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\n            Assert.assertEquals(baseIndexName, tbl1.getName());\n            MaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\n            Assert.assertNotNull(indexMeta);\n        } finally {\n            tbl1.readUnlock();\n        }\n        \/\/ 7. query\n        \/\/ TODO: we can not process real query for now. So it has to be a explain query\n        String queryStr = \"explain select * from db1.tbl1\";\n        String a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\n        System.out.println(a);\n        StmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\n        stmtExecutor.execute();\n        Planner planner = stmtExecutor.planner();\n        List<PlanFragment> fragments = planner.getFragments();\n        Assert.assertEquals(2, fragments.size());\n        PlanFragment fragment = fragments.get(1);\n        Assert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\n        Assert.assertEquals(0, fragment.getChildren().size());\n        \/\/ test show backends;\n        BackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\n        ProcResult result = dir.fetchResult();\n        Assert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\n        Assert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\n        Assert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\n                result.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n    }","code_wo_comment":"@Test\n    public void testCreateDbAndTable() throws Exception {\n       \n        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n       \n        String createDbStmtStr = \"create database db1;\";\n        CreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\n        Catalog.getCurrentCatalog().createDb(createDbStmt);\n        System.out.println(Catalog.getCurrentCatalog().getDbNames());\n       \n        String createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n                \"'colocate_with' = 'g1');\";\n        CreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\n        Catalog.getCurrentCatalog().createTable(createTableStmt);\n       \n        updateReplicaPathHash();\n       \n        Database db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\n        Assert.assertNotNull(db);\n        OlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl.readLock();\n        try {\n            Assert.assertNotNull(tbl);\n            System.out.println(tbl.getName());\n            Assert.assertEquals(\"Doris\", tbl.getEngine());\n            Assert.assertEquals(1, tbl.getBaseSchema().size());\n        } finally {\n            tbl.readUnlock();\n        }\n       \n        String alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\n        AlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\n        Catalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n       \n        Map<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\n        Assert.assertEquals(1, alterJobs.size());\n        for (AlterJobV2 alterJobV2 : alterJobs.values()) {\n            while (!alterJobV2.getJobState().isFinalState()) {\n                System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\n                Thread.sleep(1000);\n            }\n            System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\n            Assert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n        }\n        OlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl1.readLock();\n        try {\n            Assert.assertEquals(2, tbl1.getBaseSchema().size());\n            String baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\n            Assert.assertEquals(baseIndexName, tbl1.getName());\n            MaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\n            Assert.assertNotNull(indexMeta);\n        } finally {\n            tbl1.readUnlock();\n        }\n       \n       \n        String queryStr = \"explain select * from db1.tbl1\";\n        String a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\n        System.out.println(a);\n        StmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\n        stmtExecutor.execute();\n        Planner planner = stmtExecutor.planner();\n        List<PlanFragment> fragments = planner.getFragments();\n        Assert.assertEquals(2, fragments.size());\n        PlanFragment fragment = fragments.get(1);\n        Assert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\n        Assert.assertEquals(0, fragment.getChildren().size());\n       \n        BackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\n        ProcResult result = dir.fetchResult();\n        Assert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\n        Assert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\n        Assert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\n                result.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n    }","cleancode":"@test public void testcreatedbandtable() throws exception { connectcontext ctx = utframeutils.createdefaultctx(); string createdbstmtstr = \"create database db1;\"; createdbstmt createdbstmt = (createdbstmt) utframeutils.parseandanalyzestmt(createdbstmtstr, ctx); catalog.getcurrentcatalog().createdb(createdbstmt); system.out.println(catalog.getcurrentcatalog().getdbnames()); string createtblstmtstr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" + \"'colocate_with' = 'g1');\"; createtablestmt createtablestmt = (createtablestmt) utframeutils.parseandanalyzestmt(createtblstmtstr, ctx); catalog.getcurrentcatalog().createtable(createtablestmt); updatereplicapathhash(); database db = catalog.getcurrentcatalog().getdbnullable(\"default_cluster:db1\"); assert.assertnotnull(db); olaptable tbl = (olaptable) db.gettablenullable(\"tbl1\"); tbl.readlock(); try { assert.assertnotnull(tbl); system.out.println(tbl.getname()); assert.assertequals(\"doris\", tbl.getengine()); assert.assertequals(1, tbl.getbaseschema().size()); } finally { tbl.readunlock(); } string alterstmtstr = \"alter table db1.tbl1 add column k2 int default '1'\"; altertablestmt altertablestmt = (altertablestmt) utframeutils.parseandanalyzestmt(alterstmtstr, ctx); catalog.getcurrentcatalog().getalterinstance().processaltertable(altertablestmt); map<long, alterjobv2> alterjobs = catalog.getcurrentcatalog().getschemachangehandler().getalterjobsv2(); assert.assertequals(1, alterjobs.size()); for (alterjobv2 alterjobv2 : alterjobs.values()) { while (!alterjobv2.getjobstate().isfinalstate()) { system.out.println(\"alter job \" + alterjobv2.getjobid() + \" is running. state: \" + alterjobv2.getjobstate()); thread.sleep(1000); } system.out.println(\"alter job \" + alterjobv2.getjobid() + \" is done. state: \" + alterjobv2.getjobstate()); assert.assertequals(alterjobv2.jobstate.finished, alterjobv2.getjobstate()); } olaptable tbl1 = (olaptable) db.gettablenullable(\"tbl1\"); tbl1.readlock(); try { assert.assertequals(2, tbl1.getbaseschema().size()); string baseindexname = tbl1.getindexnamebyid(tbl.getbaseindexid()); assert.assertequals(baseindexname, tbl1.getname()); materializedindexmeta indexmeta = tbl1.getindexmetabyindexid(tbl1.getbaseindexid()); assert.assertnotnull(indexmeta); } finally { tbl1.readunlock(); } string querystr = \"explain select * from db1.tbl1\"; string a = utframeutils.getsqlplanorerrormsg(ctx, querystr); system.out.println(a); stmtexecutor stmtexecutor = new stmtexecutor(ctx, querystr); stmtexecutor.execute(); planner planner = stmtexecutor.planner(); list<planfragment> fragments = planner.getfragments(); assert.assertequals(2, fragments.size()); planfragment fragment = fragments.get(1); assert.asserttrue(fragment.getplanroot() instanceof olapscannode); assert.assertequals(0, fragment.getchildren().size()); backendsprocdir dir = new backendsprocdir(catalog.getcurrentsysteminfo()); procresult result = dir.fetchresult(); assert.assertequals(backendsprocdir.title_names.size(), result.getcolumnnames().size()); assert.assertequals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getrows().get(0).get(19)); assert.assertequals(\"{\\\"lastsuccessreporttabletstime\\\":\\\"n\/a\\\",\\\"laststreamloadtime\\\":-1}\", result.getrows().get(0).get(backendsprocdir.title_names.size() - 1)); }","repo":"WilsonWangCS\/incubator-doris","label":[1,0,0,0]}
{"id":17588,"original_code":"private void registerSnapshot () {\n        try {\n            Statement statement = connection.createStatement();\n            \/\/ TODO copy over feed_id and feed_version from source namespace?\n            \/\/ FIXME do the following only on databases that support schemas.\n            \/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\n            statement.execute(\"create schema \" + tablePrefix);\n            \/\/ TODO: Record total snapshot processing time?\n            \/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n            \/\/ feeds table already exists.\n            PreparedStatement insertStatement = connection.prepareStatement(\n                    \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\n            insertStatement.setString(1, tablePrefix);\n            insertStatement.setString(2, feedIdToSnapshot);\n            insertStatement.execute();\n            connection.commit();\n            LOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n        } catch (Exception ex) {\n            LOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\n            DbUtils.closeQuietly(connection);\n        }\n    }","code_wo_comment":"private void registerSnapshot () {\n        try {\n            Statement statement = connection.createStatement();\n           \n           \n           \n            statement.execute(\"create schema \" + tablePrefix);\n           \n           \n           \n            PreparedStatement insertStatement = connection.prepareStatement(\n                    \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\n            insertStatement.setString(1, tablePrefix);\n            insertStatement.setString(2, feedIdToSnapshot);\n            insertStatement.execute();\n            connection.commit();\n            LOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n        } catch (Exception ex) {\n            LOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\n            DbUtils.closeQuietly(connection);\n        }\n    }","cleancode":"private void registersnapshot () { try { statement statement = connection.createstatement(); statement.execute(\"create schema \" + tableprefix); preparedstatement insertstatement = connection.preparestatement( \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\"); insertstatement.setstring(1, tableprefix); insertstatement.setstring(2, feedidtosnapshot); insertstatement.execute(); connection.commit(); log.info(\"created new snapshot namespace: {}\", insertstatement); } catch (exception ex) { log.error(\"exception while registering snapshot namespace in feeds table: {}\", ex.getmessage()); dbutils.closequietly(connection); } }","repo":"Wilhansen\/gtfs-lib","label":[1,1,0,0]}
{"id":9474,"original_code":"@Override\n        protected void channelRead0(ChannelHandlerContext ctx,\n                CoapMessage msg) {\n            try {\n                \/\/ Find proper device and raise event.\n                Device targetDevice = ctx.channel().attr(keyDevice).get();\n                if (targetDevice == null) {\n                    throw new InternalServerErrorException(\n                            \"Unable to find device\");\n                }\n                if (msg instanceof CoapRequest) {\n                    onRequestReceived(targetDevice, (CoapRequest) msg);\n                } else if (msg instanceof CoapResponse) {\n                    \/\/ TODO: Re-architecturing required\n                    IRequestChannel reqChannel = ((CoapDevice) targetDevice)\n                            .getRequestChannel();\n                    CoapClient coapClient = (CoapClient) reqChannel;\n                    coapClient.onResponseReceived(msg);\n                }\n            } catch (ServerException e) {\n                ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                        e.getErrorResponse()));\n                Log.f(ctx.channel(), e);\n            } catch (ClientException e) {\n                Log.f(ctx.channel(), e);\n            } catch (Throwable t) {\n                Log.f(ctx.channel(), t);\n                if (msg instanceof CoapRequest) {\n                    ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                            ResponseStatus.INTERNAL_SERVER_ERROR));\n                }\n            }\n        }","code_wo_comment":"@Override\n        protected void channelRead0(ChannelHandlerContext ctx,\n                CoapMessage msg) {\n            try {\n               \n                Device targetDevice = ctx.channel().attr(keyDevice).get();\n                if (targetDevice == null) {\n                    throw new InternalServerErrorException(\n                            \"Unable to find device\");\n                }\n                if (msg instanceof CoapRequest) {\n                    onRequestReceived(targetDevice, (CoapRequest) msg);\n                } else if (msg instanceof CoapResponse) {\n                   \n                    IRequestChannel reqChannel = ((CoapDevice) targetDevice)\n                            .getRequestChannel();\n                    CoapClient coapClient = (CoapClient) reqChannel;\n                    coapClient.onResponseReceived(msg);\n                }\n            } catch (ServerException e) {\n                ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                        e.getErrorResponse()));\n                Log.f(ctx.channel(), e);\n            } catch (ClientException e) {\n                Log.f(ctx.channel(), e);\n            } catch (Throwable t) {\n                Log.f(ctx.channel(), t);\n                if (msg instanceof CoapRequest) {\n                    ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                            ResponseStatus.INTERNAL_SERVER_ERROR));\n                }\n            }\n        }","cleancode":"@override protected void channelread0(channelhandlercontext ctx, coapmessage msg) { try { device targetdevice = ctx.channel().attr(keydevice).get(); if (targetdevice == null) { throw new internalservererrorexception( \"unable to find device\"); } if (msg instanceof coaprequest) { onrequestreceived(targetdevice, (coaprequest) msg); } else if (msg instanceof coapresponse) { irequestchannel reqchannel = ((coapdevice) targetdevice) .getrequestchannel(); coapclient coapclient = (coapclient) reqchannel; coapclient.onresponsereceived(msg); } } catch (serverexception e) { ctx.writeandflush(messagebuilder.createresponse(msg, e.geterrorresponse())); log.f(ctx.channel(), e); } catch (clientexception e) { log.f(ctx.channel(), e); } catch (throwable t) { log.f(ctx.channel(), t); if (msg instanceof coaprequest) { ctx.writeandflush(messagebuilder.createresponse(msg, responsestatus.internal_server_error)); } } }","repo":"SenthilKumarGS\/TizenRT","label":[1,0,0,0]}
{"id":9490,"original_code":"public LNode reverseListRec(LNode head)\n    {\n        \/\/ TODO: implement this method\n\t\t  \/*This method takes a reference to the head of a linked list and returns \n        the reference to the head of the linked list in the reversed order.  *\/\n        if(head == null) { return head; }\n        if(head.getLink() == null) { return head; }\n        head.getLink().setLink(head);\n        head.setLink(null);\n        return reverseListRec(head);\n         \/\/ replace this statement with your own return\n    }","code_wo_comment":"public LNode reverseListRec(LNode head)\n    {\n       \n\t\t \n        if(head == null) { return head; }\n        if(head.getLink() == null) { return head; }\n        head.getLink().setLink(head);\n        head.setLink(null);\n        return reverseListRec(head);\n        \n    }","cleancode":"public lnode reverselistrec(lnode head) { if(head == null) { return head; } if(head.getlink() == null) { return head; } head.getlink().setlink(head); head.setlink(null); return reverselistrec(head); }","repo":"Sailia\/data_structures","label":[0,1,0,0]}
{"id":17706,"original_code":"@SuppressWarnings(\"ParameterName\")\n    public void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n        \/\/ ask the kinematics to determine our swerve command\n        ChassisSpeeds speeds;\n        if (fieldRelative == true) {\n            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n        } else {\n            speeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n        }\n        SwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n        \/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\n        SwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n        \/\/ command each swerve module\n        for (int i = 0; i < modules.length; i++) {\n            modules[i].setDesiredState(swerveModuleStates[i]);\n        }\n        \/\/ report our commands to the dashboard\n        SmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\n        SmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n    }","code_wo_comment":"@SuppressWarnings(\"ParameterName\")\n    public void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n       \n        ChassisSpeeds speeds;\n        if (fieldRelative == true) {\n            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n        } else {\n            speeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n        }\n        SwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n       \n        SwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n       \n        for (int i = 0; i < modules.length; i++) {\n            modules[i].setDesiredState(swerveModuleStates[i]);\n        }\n       \n        SmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\n        SmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n    }","cleancode":"@suppresswarnings(\"parametername\") public void drive(double xspeed, double yspeed, double rot, boolean fieldrelative) { chassisspeeds speeds; if (fieldrelative == true) { speeds = chassisspeeds.fromfieldrelativespeeds(xspeed, yspeed, rot, getheading()); } else { speeds = new chassisspeeds(xspeed, yspeed, rot); } swervemodulestate[] swervemodulestates = kinematics.toswervemodulestates(speeds); swervedrivekinematics.desaturatewheelspeeds(swervemodulestates, kmaxspeed); for (int i = 0; i < modules.length; i++) { modules[i].setdesiredstate(swervemodulestates[i]); } smartdashboard.putnumber(\"swervedrive\/xspeed\", xspeed); smartdashboard.putnumber(\"swervedrive\/yspeed\", yspeed); smartdashboard.putnumber(\"swervedrive\/rot\", rot); smartdashboard.putboolean(\"swervedrive\/fieldrelative\", fieldrelative); }","repo":"Sammoore15\/Robot2022-2832-altencoderforingestor","label":[0,0,0,0]}
{"id":1344,"original_code":"private int generateNewTicketNumber() \n    {\n        \/\/TODO: this may take foreever. fix\n        int generated = numberGenerator.next();\n        while(purchased.containsKey(generated)){\n            generated = numberGenerator.next();\n        }\n        return generated;\n    }","code_wo_comment":"private int generateNewTicketNumber() \n    {\n       \n        int generated = numberGenerator.next();\n        while(purchased.containsKey(generated)){\n            generated = numberGenerator.next();\n        }\n        return generated;\n    }","cleancode":"private int generatenewticketnumber() { int generated = numbergenerator.next(); while(purchased.containskey(generated)){ generated = numbergenerator.next(); } return generated; }","repo":"aha0x0x\/LotteryApplication","label":[0,0,1,0]}
{"id":17729,"original_code":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n    {\n        \/\/ prepare the layout parameters for the EditText\n        \/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\n        LayoutParams layoutParams = new GridLayout.LayoutParams();\n        layoutParams.width = LayoutParams.WRAP_CONTENT;\n        layoutParams.height = LayoutParams.WRAP_CONTENT;\n        \/\/ set the row and column in the correct location of the Sudoku Board\n        layoutParams.rowSpec = GridLayout.spec(row);\n        layoutParams.columnSpec = GridLayout.spec(col);\n        \/\/ set the layout params and add the EditText to the GridLayout parent\n        _text.setLayoutParams(layoutParams);\n        parent.addView(_text);\n    }","code_wo_comment":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n    {\n       \n       \n        LayoutParams layoutParams = new GridLayout.LayoutParams();\n        layoutParams.width = LayoutParams.WRAP_CONTENT;\n        layoutParams.height = LayoutParams.WRAP_CONTENT;\n       \n        layoutParams.rowSpec = GridLayout.spec(row);\n        layoutParams.columnSpec = GridLayout.spec(col);\n       \n        _text.setLayoutParams(layoutParams);\n        parent.addView(_text);\n    }","cleancode":"public void setparentatrowandcolumn(gridlayout parent, int row, int col) { layoutparams layoutparams = new gridlayout.layoutparams(); layoutparams.width = layoutparams.wrap_content; layoutparams.height = layoutparams.wrap_content; layoutparams.rowspec = gridlayout.spec(row); layoutparams.columnspec = gridlayout.spec(col); _text.setlayoutparams(layoutparams); parent.addview(_text); }","repo":"SnoBoarder\/Sudoku-Solver","label":[0,1,0,0]}
{"id":34188,"original_code":"public void testZKSMFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\")};\n\t\tEncryptedInteger c = new EncryptedInteger(new BigInteger(\"10\"), pub);\n\t\tBigInteger r = c.set(new BigInteger(\"10\"));\n\t\tint msgIndex = 2;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code_wo_comment":"public void testZKSMFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\")};\n\t\tEncryptedInteger c = new EncryptedInteger(new BigInteger(\"10\"), pub);\n\t\tBigInteger r = c.set(new BigInteger(\"10\"));\n\t\tint msgIndex = 2;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmfalse() throws zksetmembershipexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\")}; encryptedinteger c = new encryptedinteger(new biginteger(\"10\"), pub); biginteger r = c.set(new biginteger(\"10\")); int msgindex = 2; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","repo":"SoftwareEngineeringToolDemos\/type-inference","label":[0,0,1,0]}
{"id":34189,"original_code":"public void testZKSMSingleMemberSetFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\")};\n\t\tEncryptedInteger c = new EncryptedInteger(BigInteger.ONE, pub);\n\t\tBigInteger r = c.set(BigInteger.ONE);\n\t\tint msgIndex = 0;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code_wo_comment":"public void testZKSMSingleMemberSetFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\")};\n\t\tEncryptedInteger c = new EncryptedInteger(BigInteger.ONE, pub);\n\t\tBigInteger r = c.set(BigInteger.ONE);\n\t\tint msgIndex = 0;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmsinglemembersetfalse() throws zksetmembershipexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\")}; encryptedinteger c = new encryptedinteger(biginteger.one, pub); biginteger r = c.set(biginteger.one); int msgindex = 0; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","repo":"SoftwareEngineeringToolDemos\/type-inference","label":[0,0,1,0]}
{"id":34190,"original_code":"public void testZKSMAddTrue() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code_wo_comment":"public void testZKSMAddTrue() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmaddtrue() throws zksetmembershipexception, publickeysnotequalexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\"), new biginteger(\"6\")}; encryptedinteger c1 = new encryptedinteger(new biginteger(\"2\"), pub); biginteger r1 = c1.set(new biginteger(\"2\")); encryptedinteger c2 = new encryptedinteger(new biginteger(\"3\"), pub); biginteger r2 = c2.set(new biginteger(\"3\")); encryptedinteger c = c1.add(c2); biginteger r = r1.multiply(r2).mod(this.pub.getnsquared()); int msgindex = 5; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","repo":"SoftwareEngineeringToolDemos\/type-inference","label":[0,0,1,0]}
{"id":34191,"original_code":"public void testZKSMManyOperations() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code_wo_comment":"public void testZKSMManyOperations() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmmanyoperations() throws zksetmembershipexception, publickeysnotequalexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\"), new biginteger(\"6\")}; encryptedinteger c1 = new encryptedinteger(new biginteger(\"2\"), pub); biginteger r1 = c1.set(new biginteger(\"2\")); encryptedinteger c2 = new encryptedinteger(new biginteger(\"3\"), pub); biginteger r2 = c2.set(new biginteger(\"3\")); encryptedinteger c = c1.add(c2); biginteger r = r1.multiply(r2).mod(this.pub.getnsquared()); int msgindex = 5; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","repo":"SoftwareEngineeringToolDemos\/type-inference","label":[0,0,1,0]}
{"id":34311,"original_code":"private void assertTestSummary() {\n    int fails = testResult.fails().size();\n    int errors = testResult.errors().size();\n    int succeeds = testResult.succeeds().size();\n    int testCount = fails + errors + succeeds;\n    if (testMode.isJ2cl()) {\n      \/\/ Like Junit4, J2CL always counts errors as failures\n      fails += errors;\n      errors = 0;\n      \/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\n      testCount = 1;\n      \/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\n      assertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n    }\n    if (fails + errors > 0) {\n      assertTestSummaryForFailure(fails, errors, testCount);\n    } else {\n      assertTestSummaryForSuccess(testCount);\n    }\n  }","code_wo_comment":"private void assertTestSummary() {\n    int fails = testResult.fails().size();\n    int errors = testResult.errors().size();\n    int succeeds = testResult.succeeds().size();\n    int testCount = fails + errors + succeeds;\n    if (testMode.isJ2cl()) {\n     \n      fails += errors;\n      errors = 0;\n     \n      testCount = 1;\n     \n      assertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n    }\n    if (fails + errors > 0) {\n      assertTestSummaryForFailure(fails, errors, testCount);\n    } else {\n      assertTestSummaryForSuccess(testCount);\n    }\n  }","cleancode":"private void asserttestsummary() { int fails = testresult.fails().size(); int errors = testresult.errors().size(); int succeeds = testresult.succeeds().size(); int testcount = fails + errors + succeeds; if (testmode.isj2cl()) { fails += errors; errors = 0; testcount = 1; assertthat(consolelogs.stream().filter(x -> x.contains(\": passed\"))).hassize(succeeds); } if (fails + errors > 0) { asserttestsummaryforfailure(fails, errors, testcount); } else { asserttestsummaryforsuccess(testcount); } }","repo":"VishrutMehta\/j2cl","label":[0,0,1,0]}
{"id":18084,"original_code":"public boolean connect(long timeoutMs) {\n        if (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\n        long startMs = System.currentTimeMillis();\n        long endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\n        long currentTime = startMs;\n        Throwable lastError = null;\n        int attempt = 0;\n        while (currentTime <= endMs) {\n            currentTime = System.currentTimeMillis();\n            if (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\n            if (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\n            try {\n                connect();\n                return true;\n            } catch (Exception e) {\n                Exceptions.propagateIfFatal(e);\n                if (!terminated.get() && shouldRetryOn(e)) {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\n                    lastError = e;\n                } else {\n                    throw Exceptions.propagate(e);\n                }\n            }\n            attempt++;\n        }\n        LOG.warn(\"unable to connect to JMX url: \"+url, lastError);\n        return false;\n    }","code_wo_comment":"public boolean connect(long timeoutMs) {\n        if (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\n        long startMs = System.currentTimeMillis();\n        long endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\n        long currentTime = startMs;\n        Throwable lastError = null;\n        int attempt = 0;\n        while (currentTime <= endMs) {\n            currentTime = System.currentTimeMillis();\n            if (attempt != 0) sleep(100);\n            if (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\n            try {\n                connect();\n                return true;\n            } catch (Exception e) {\n                Exceptions.propagateIfFatal(e);\n                if (!terminated.get() && shouldRetryOn(e)) {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\n                    lastError = e;\n                } else {\n                    throw Exceptions.propagate(e);\n                }\n            }\n            attempt++;\n        }\n        LOG.warn(\"unable to connect to JMX url: \"+url, lastError);\n        return false;\n    }","cleancode":"public boolean connect(long timeoutms) { if (log.isdebugenabled()) log.debug(\"connecting to jmx url: {} ({})\", url, ((timeoutms == -1) ? \"indefinitely\" : timeoutms+\"ms timeout\")); long startms = system.currenttimemillis(); long endms = (timeoutms == -1) ? long.max_value : (startms + timeoutms); long currenttime = startms; throwable lasterror = null; int attempt = 0; while (currenttime <= endms) { currenttime = system.currenttimemillis(); if (attempt != 0) sleep(100); if (log.istraceenabled()) log.trace(\"trying connection to {} at time {}\", url, currenttime); try { connect(); return true; } catch (exception e) { exceptions.propagateiffatal(e); if (!terminated.get() && shouldretryon(e)) { if (log.isdebugenabled()) log.debug(\"attempt {} failed connecting to {} ({})\", new object[] {attempt + 1, url, e.getmessage()}); lasterror = e; } else { throw exceptions.propagate(e); } } attempt++; } log.warn(\"unable to connect to jmx url: \"+url, lasterror); return false; }","repo":"YYTVicky\/brooklyn-server","label":[1,0,0,0]}
{"id":34588,"original_code":"public String toString(int indentFactor) {\n        try {\n            StringWriter w = new StringWriter();\n            synchronized (w.getBuffer()) {\n                return this.write(w, indentFactor, 0).toString();\n            }\n        }\n        catch (Exception e) {\n            \/\/there is no conceivable exception that can come out of this, but throw something\n            \/\/just in case.   Want the signature to not have exception in it.\n            throw new RuntimeException(\"Can not serialize JSONObject????\", e);\n        }\n    }","code_wo_comment":"public String toString(int indentFactor) {\n        try {\n            StringWriter w = new StringWriter();\n            synchronized (w.getBuffer()) {\n                return this.write(w, indentFactor, 0).toString();\n            }\n        }\n        catch (Exception e) {\n           \n           \n            throw new RuntimeException(\"Can not serialize JSONObject????\", e);\n        }\n    }","cleancode":"public string tostring(int indentfactor) { try { stringwriter w = new stringwriter(); synchronized (w.getbuffer()) { return this.write(w, indentfactor, 0).tostring(); } } catch (exception e) { throw new runtimeexception(\"can not serialize jsonobject????\", e); } }","repo":"agilepro\/purple","label":[0,0,0,0]}
{"id":18326,"original_code":"private void validate() throws IllegalStateException {\n      Set<DateComponentOrdering> orderings = Sets.newHashSet();\n      if(preferred != null) {\n        orderings.add(preferred.getOrdering());\n      }\n      for(DateTimeParser parser : otherParsers) {\n        if(!orderings.add(parser.getOrdering())) {\n          throw new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n                  \"[\" + parser.getOrdering() + \"]\");\n        }\n      }\n    }","code_wo_comment":"private void validate() throws IllegalStateException {\n      Set<DateComponentOrdering> orderings = Sets.newHashSet();\n      if(preferred != null) {\n        orderings.add(preferred.getOrdering());\n      }\n      for(DateTimeParser parser : otherParsers) {\n        if(!orderings.add(parser.getOrdering())) {\n          throw new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n                  \"[\" + parser.getOrdering() + \"]\");\n        }\n      }\n    }","cleancode":"private void validate() throws illegalstateexception { set<datecomponentordering> orderings = sets.newhashset(); if(preferred != null) { orderings.add(preferred.getordering()); } for(datetimeparser parser : otherparsers) { if(!orderings.add(parser.getordering())) { throw new illegalstateexception(\"datecomponentordering can only be used once in a datetimemultiparser.\" + \"[\" + parser.getordering() + \"]\"); } } }","repo":"adam-collins\/parsers","label":[1,0,0,0]}
{"id":18370,"original_code":"public static String getEnumName(String fieldName ) {\n\t\t\/\/Later TODO\n\t\t\/\/return super.getEnumName(fieldName);\n\t\treturn null;\n\t}","code_wo_comment":"public static String getEnumName(String fieldName ) {\n\t\n\t\n\t\treturn null;\n\t}","cleancode":"public static string getenumname(string fieldname ) { return null; }","repo":"aloklal99\/apache-ranger","label":[0,1,0,0]}
{"id":18422,"original_code":"public static StatsValues createStatsValues(StatsField statsField) {\n    final SchemaField sf = statsField.getSchemaField();\n    if (null == sf) {\n      \/\/ function stats\n      return new NumericStatsValues(statsField);\n    }\n    final FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\n    if (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\n      DateStatsValues statsValues = new DateStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedDateStatsValues(statsValues, statsField);\n      }\n      return statsValues;\n    } else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\n      NumericStatsValues statsValue = new NumericStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedNumericStatsValues(statsValue, statsField);\n      }\n      return statsValue;\n    } else if (StrField.class.isInstance(fieldType)) {\n      return new StringStatsValues(statsField);\n    } else if (AbstractEnumField.class.isInstance(fieldType)) {\n      return new EnumStatsValues(statsField);\n    } else {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST,\n          \"Field type \" + fieldType + \" is not currently supported\");\n    }\n  }","code_wo_comment":"public static StatsValues createStatsValues(StatsField statsField) {\n    final SchemaField sf = statsField.getSchemaField();\n    if (null == sf) {\n     \n      return new NumericStatsValues(statsField);\n    }\n    final FieldType fieldType = sf.getType();\n    if (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\n      DateStatsValues statsValues = new DateStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedDateStatsValues(statsValues, statsField);\n      }\n      return statsValues;\n    } else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\n      NumericStatsValues statsValue = new NumericStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedNumericStatsValues(statsValue, statsField);\n      }\n      return statsValue;\n    } else if (StrField.class.isInstance(fieldType)) {\n      return new StringStatsValues(statsField);\n    } else if (AbstractEnumField.class.isInstance(fieldType)) {\n      return new EnumStatsValues(statsField);\n    } else {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST,\n          \"Field type \" + fieldType + \" is not currently supported\");\n    }\n  }","cleancode":"public static statsvalues createstatsvalues(statsfield statsfield) { final schemafield sf = statsfield.getschemafield(); if (null == sf) { return new numericstatsvalues(statsfield); } final fieldtype fieldtype = sf.gettype(); if (triedatefield.class.isinstance(fieldtype) || datepointfield.class.isinstance(fieldtype)) { datestatsvalues statsvalues = new datestatsvalues(statsfield); if (sf.multivalued()) { return new sorteddatestatsvalues(statsvalues, statsfield); } return statsvalues; } else if (triefield.class.isinstance(fieldtype) || pointfield.class.isinstance(fieldtype)) { numericstatsvalues statsvalue = new numericstatsvalues(statsfield); if (sf.multivalued()) { return new sortednumericstatsvalues(statsvalue, statsfield); } return statsvalue; } else if (strfield.class.isinstance(fieldtype)) { return new stringstatsvalues(statsfield); } else if (abstractenumfield.class.isinstance(fieldtype)) { return new enumstatsvalues(statsfield); } else { throw new solrexception( solrexception.errorcode.bad_request, \"field type \" + fieldtype + \" is not currently supported\"); } }","repo":"ackepenek\/solr","label":[0,1,0,0]}
{"id":18424,"original_code":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\n        this.setSelected(entry, true);\n    }","code_wo_comment":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\n        this.setSelected(entry, true);\n    }","cleancode":"public void setselected(@nullable packlistwidget.packentry entry) { this.setselected(entry, true); }","repo":"VanillaImprovements\/VVDownloader","label":[0,1,0,0]}
{"id":2045,"original_code":"synchronized ImmutableList<JobEvent> getActiveEvents() {\n    ImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\n    for (String id : activeJobIds) {\n      JobEvent p = eventsByJobId.get(id);\n      assert p != null;\n      builder.add(p);\n    }\n    return builder.build();\n  }","code_wo_comment":"synchronized ImmutableList<JobEvent> getActiveEvents() {\n    ImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\n    for (String id : activeJobIds) {\n      JobEvent p = eventsByJobId.get(id);\n      assert p != null;\n      builder.add(p);\n    }\n    return builder.build();\n  }","cleancode":"synchronized immutablelist<jobevent> getactiveevents() { immutablelist.builder<jobevent> builder = immutablelist.builder(); for (string id : activejobids) { jobevent p = eventsbyjobid.get(id); assert p != null; builder.add(p); } return builder.build(); }","repo":"TeamSPoon\/CYC_JRTL_with_CommonLisp_OLD","label":[1,0,0,0]}
{"id":18433,"original_code":"private VdsmVm appendStatistics(VdsmVm vm, V1VirtualMachineInstance vmi) {\n        VmStatistics statistics = new VmStatistics();\n        statistics.setId(vm.getId());\n        DateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\n        if (creationTimestampDate != null) {\n            DateTime now = DateTime.now();\n            Seconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\n            statistics.setElapsedTime((double) seconds.getSeconds());\n        }\n        PrometheusClient promClient = getPrometheusClient();\n        if (promClient != null) {\n            \/\/ FIXME: Kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total CPU time,\n            \/\/ so we are setting it here only as system time, which is wrong.\n            statistics.setCpuSys(\n                    promClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n            );\n        }\n        return vm.setVmStatistics(statistics)\n                .setDiskStatistics(Collections.emptyList())\n                .setVmJobs(Collections.emptyList());\n    }","code_wo_comment":"private VdsmVm appendStatistics(VdsmVm vm, V1VirtualMachineInstance vmi) {\n        VmStatistics statistics = new VmStatistics();\n        statistics.setId(vm.getId());\n        DateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\n        if (creationTimestampDate != null) {\n            DateTime now = DateTime.now();\n            Seconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\n            statistics.setElapsedTime((double) seconds.getSeconds());\n        }\n        PrometheusClient promClient = getPrometheusClient();\n        if (promClient != null) {\n           \n           \n            statistics.setCpuSys(\n                    promClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n            );\n        }\n        return vm.setVmStatistics(statistics)\n                .setDiskStatistics(Collections.emptyList())\n                .setVmJobs(Collections.emptyList());\n    }","cleancode":"private vdsmvm appendstatistics(vdsmvm vm, v1virtualmachineinstance vmi) { vmstatistics statistics = new vmstatistics(); statistics.setid(vm.getid()); datetime creationtimestampdate = vmi.getmetadata().getcreationtimestamp(); if (creationtimestampdate != null) { datetime now = datetime.now(); seconds seconds = seconds.secondsbetween(creationtimestampdate, now); statistics.setelapsedtime((double) seconds.getseconds()); } prometheusclient promclient = getprometheusclient(); if (promclient != null) { statistics.setcpusys( promclient.getvmicpuusage(vmi.getmetadata().getname(), vmi.getmetadata().getnamespace()) ); } return vm.setvmstatistics(statistics) .setdiskstatistics(collections.emptylist()) .setvmjobs(collections.emptylist()); }","repo":"StevenCode\/ovirt-engine","label":[0,0,1,0]}
{"id":18456,"original_code":"@Test \n    @Ignore(\"dbpedia is not reliable\")\n    public void testDBPedia() throws Exception {\n        testResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n    }","code_wo_comment":"@Test \n    @Ignore(\"dbpedia is not reliable\")\n    public void testDBPedia() throws Exception {\n        testResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n    }","cleancode":"@test @ignore(\"dbpedia is not reliable\") public void testdbpedia() throws exception { testresource(dbpedia, \"dbpedia-berlin.sparql\" ); }","repo":"YYTVicky\/marmotta","label":[1,0,0,0]}
{"id":34925,"original_code":"@Test\n    public void canCompleteItself() throws IOException {\n        String jid = queue.put(\"Foo\", null, null);\n        queue.pop().complete(); \/\/ TODO: this test passes even when this line is removed\n        Assert.assertEquals(\"complete\", client.getJob(jid).getState());\n    }","code_wo_comment":"@Test\n    public void canCompleteItself() throws IOException {\n        String jid = queue.put(\"Foo\", null, null);\n        queue.pop().complete();\n        Assert.assertEquals(\"complete\", client.getJob(jid).getState());\n    }","cleancode":"@test public void cancompleteitself() throws ioexception { string jid = queue.put(\"foo\", null, null); queue.pop().complete(); assert.assertequals(\"complete\", client.getjob(jid).getstate()); }","repo":"Zimbra\/qless-java","label":[0,0,0,1]}
{"id":18643,"original_code":"@Override\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\n        if (affectedControllerId.equals(source.getControllerId())) {\n            Card card = game.getCard(objectId);\n            MageObject sourceObject = source.getSourceObject(game);\n            if (card != null && !card.isLand() && sourceObject != null) {\n                UUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\n                if (exileId != null) {\n                    ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\n                    if (exileZone != null && exileZone.contains(objectId)) {\n                        if (game.getTurnNum() == turnNumber) {\n                            if (!exileZone.contains(cardId)) {\n                                \/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect\n                                \/\/ TODO: Handle if card was cast\/removed from exile with effect from another card.\n                                \/\/       If so, this effect could prevent player from casting although they should be able to use it\n                                return false;\n                            }\n                        }\n                        this.turnNumber = game.getTurnNum();\n                        this.cardId = objectId;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","code_wo_comment":"@Override\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\n        if (affectedControllerId.equals(source.getControllerId())) {\n            Card card = game.getCard(objectId);\n            MageObject sourceObject = source.getSourceObject(game);\n            if (card != null && !card.isLand() && sourceObject != null) {\n                UUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\n                if (exileId != null) {\n                    ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\n                    if (exileZone != null && exileZone.contains(objectId)) {\n                        if (game.getTurnNum() == turnNumber) {\n                            if (!exileZone.contains(cardId)) {\n                               \n                               \n                               \n                                return false;\n                            }\n                        }\n                        this.turnNumber = game.getTurnNum();\n                        this.cardId = objectId;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","cleancode":"@override public boolean applies(uuid objectid, ability source, uuid affectedcontrollerid, game game) { if (affectedcontrollerid.equals(source.getcontrollerid())) { card card = game.getcard(objectid); mageobject sourceobject = source.getsourceobject(game); if (card != null && !card.island() && sourceobject != null) { uuid exileid = cardutil.getexilezoneid(game, source.getsourceid(), source.getsourceobjectzonechangecounter()); if (exileid != null) { exilezone exilezone = game.getstate().getexile().getexilezone(exileid); if (exilezone != null && exilezone.contains(objectid)) { if (game.getturnnum() == turnnumber) { if (!exilezone.contains(cardid)) { return false; } } this.turnnumber = game.getturnnum(); this.cardid = objectid; return true; } } } } return false; }","repo":"amc8391\/mage","label":[0,0,1,0]}
{"id":2359,"original_code":"public static String getFilePathDiskCache(final String key) {\n        if (sDiskLruCache == null) {\n            return null;\n        }\n        \/\/ This violates encapsulation but there is no convenience method to get a filename from\n        \/\/ DiskLruCache. Filename was derived from private class method Entry#getCleanFile\n        \/\/ in DiskLruCache.java\n        return sDiskLruCache.getDirectory()\n                + File.separator\n                + createValidDiskCacheKey(key)\n                + \".\"\n                + DISK_CACHE_INDEX;\n    }","code_wo_comment":"public static String getFilePathDiskCache(final String key) {\n        if (sDiskLruCache == null) {\n            return null;\n        }\n       \n       \n       \n        return sDiskLruCache.getDirectory()\n                + File.separator\n                + createValidDiskCacheKey(key)\n                + \".\"\n                + DISK_CACHE_INDEX;\n    }","cleancode":"public static string getfilepathdiskcache(final string key) { if (sdisklrucache == null) { return null; } return sdisklrucache.getdirectory() + file.separator + createvaliddiskcachekey(key) + \".\" + disk_cache_index; }","repo":"SinnerSchraderMobileMirrors\/mopub-android-sdk","label":[1,0,0,0]}
{"id":18861,"original_code":"private void setUpViews() {\n        glucometerAttribution = findViewById(R.id.glucometerAttribution);\n        glucometerImg = findViewById(R.id.glucometerImg);\n        insertStripText = findViewById(R.id.insertStripText);\n        upArrow = findViewById(R.id.upArrow);\n        droplet = findViewById(R.id.dropletImg);\n        attributionText = findViewById(R.id.attributionText);\n        placeBloodSweatImg = findViewById(R.id.placeBloodSweatImg);\n        placeBloodSweatText = findViewById(R.id.placeBloodSweatText);\n        waitForReadingText = findViewById(R.id.waitForReadingText);\n        progressBar = findViewById(R.id.progressBar);\n        unitsText = findViewById(R.id.unitsText);\n        glucoseLevelText = findViewById(R.id.glucoseLevelText);\n        descriptionTxt = findViewById(R.id.descriptionTxt);\n        detailsBtn = findViewById(R.id.detailsBtn);\n        anotherReadingBtn = findViewById(R.id.anotherReadingBtn);\n        showBtn = findViewById(R.id.button7);\n        dippedBtn = findViewById(R.id.button6);\n        stripBtn = findViewById(R.id.button8);\n        startButton = findViewById(R.id.btnStripInserted);\n        rgMode = findViewById(R.id.rgMode);\n        rbBlood = findViewById(R.id.rbBlood);\n        rbSweat = findViewById(R.id.rbSweat);\n        rb_mg_dL = findViewById(R.id.rb_mg_dL);\n        rb_mmol_L = findViewById(R.id.rb_mmol_L);\n        glucometerSwitch = findViewById(R.id.glucometerSwitch);\n        rgUnits = findViewById(R.id.rgUnits);\n        startButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!rbSweat.isChecked() && !rbBlood.isChecked()) {\n                    Toast.makeText(GlucometerActivity.this, \"Please select a mode\", Toast.LENGTH_SHORT).show();\n                }\n                else {\n                    instance.sendDataToArduino(\"start\");\n                    instance.setReading(true);\n                    glucometerSwitch.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    startButton.setEnabled(false);\n                    glucometerImg.setVisibility(View.VISIBLE);\n                    glucometerAttribution.setVisibility(View.VISIBLE);\n                    insertStripText.setVisibility(View.VISIBLE);\n                    upArrow.setVisibility(View.VISIBLE);\n                }\n            }\n        });\n        rgMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rbBlood:\n                        instance.sendDataToArduino(\"Blood\");\n                        droplet.setColorFilter(Color.parseColor(\"#F44336\"));\n                        placeBloodSweatText.setText(\"Place blood on the test strip\");\n                        break;\n                    case R.id.rbSweat:\n                        instance.sendDataToArduino(\"Sweat\");\n                        droplet.setColorFilter(Color.parseColor(\"#1b95e0\"));\n                        placeBloodSweatText.setText(\"Place sweat on the test strip\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        glucometerSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (isChecked){\n                    instance.sendDataToArduino(\"G_on\");\n                    viewDelay();\n                }else {\n                    instance.sendDataToArduino(\"G_off\");\n                    startButton.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    glucometerSwitch.setEnabled(false);\n                    viewHandler = new Handler();\n                    Runnable delay = new Runnable() {\n                        @Override\n                        public void run() {\n                            glucometerSwitch.setEnabled(true);\n                        }\n                    };\n                    viewHandler.postDelayed(delay, 1000);\n                }\n            }\n        });\n        rgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rb_mg_dL:\n                        \/\/TODO Display readings in mg\/dL\n                        unitsText.setText(\"mg\/dL\");\n                        break;\n                    case R.id.rb_mmol_L:\n                        \/\/TODO Display readings in mmol\/L\n                        unitsText.setText(\"mmol\/L\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        detailsBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                \/\/Move to new activity\n                Intent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n                startActivity(intent);\n            }\n        });\n        anotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setReading(false);\n                glucometerSwitch.setEnabled(true);\n                rbBlood.setEnabled(true);\n                rbSweat.setEnabled(true);\n                rb_mg_dL.setEnabled(true);\n                rb_mmol_L.setEnabled(true);\n                startButton.setEnabled(true);\n                instance.setStringData(null);\n                instance.setCommand(null);\n                unitsText.setVisibility(View.INVISIBLE);\n                glucoseLevelText.setVisibility(View.INVISIBLE);\n                descriptionTxt.setVisibility(View.INVISIBLE);\n                detailsBtn.setVisibility(View.INVISIBLE);\n                anotherReadingBtn.setVisibility(View.INVISIBLE);\n            }\n        });\n        showBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"show\");\n            }\n        });\n        stripBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"strip\");\n            }\n        });\n        dippedBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"dipped\");\n            }\n        });\n    }","code_wo_comment":"private void setUpViews() {\n        glucometerAttribution = findViewById(R.id.glucometerAttribution);\n        glucometerImg = findViewById(R.id.glucometerImg);\n        insertStripText = findViewById(R.id.insertStripText);\n        upArrow = findViewById(R.id.upArrow);\n        droplet = findViewById(R.id.dropletImg);\n        attributionText = findViewById(R.id.attributionText);\n        placeBloodSweatImg = findViewById(R.id.placeBloodSweatImg);\n        placeBloodSweatText = findViewById(R.id.placeBloodSweatText);\n        waitForReadingText = findViewById(R.id.waitForReadingText);\n        progressBar = findViewById(R.id.progressBar);\n        unitsText = findViewById(R.id.unitsText);\n        glucoseLevelText = findViewById(R.id.glucoseLevelText);\n        descriptionTxt = findViewById(R.id.descriptionTxt);\n        detailsBtn = findViewById(R.id.detailsBtn);\n        anotherReadingBtn = findViewById(R.id.anotherReadingBtn);\n        showBtn = findViewById(R.id.button7);\n        dippedBtn = findViewById(R.id.button6);\n        stripBtn = findViewById(R.id.button8);\n        startButton = findViewById(R.id.btnStripInserted);\n        rgMode = findViewById(R.id.rgMode);\n        rbBlood = findViewById(R.id.rbBlood);\n        rbSweat = findViewById(R.id.rbSweat);\n        rb_mg_dL = findViewById(R.id.rb_mg_dL);\n        rb_mmol_L = findViewById(R.id.rb_mmol_L);\n        glucometerSwitch = findViewById(R.id.glucometerSwitch);\n        rgUnits = findViewById(R.id.rgUnits);\n        startButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!rbSweat.isChecked() && !rbBlood.isChecked()) {\n                    Toast.makeText(GlucometerActivity.this, \"Please select a mode\", Toast.LENGTH_SHORT).show();\n                }\n                else {\n                    instance.sendDataToArduino(\"start\");\n                    instance.setReading(true);\n                    glucometerSwitch.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    startButton.setEnabled(false);\n                    glucometerImg.setVisibility(View.VISIBLE);\n                    glucometerAttribution.setVisibility(View.VISIBLE);\n                    insertStripText.setVisibility(View.VISIBLE);\n                    upArrow.setVisibility(View.VISIBLE);\n                }\n            }\n        });\n        rgMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rbBlood:\n                        instance.sendDataToArduino(\"Blood\");\n                        droplet.setColorFilter(Color.parseColor(\"#F44336\"));\n                        placeBloodSweatText.setText(\"Place blood on the test strip\");\n                        break;\n                    case R.id.rbSweat:\n                        instance.sendDataToArduino(\"Sweat\");\n                        droplet.setColorFilter(Color.parseColor(\"#1b95e0\"));\n                        placeBloodSweatText.setText(\"Place sweat on the test strip\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        glucometerSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (isChecked){\n                    instance.sendDataToArduino(\"G_on\");\n                    viewDelay();\n                }else {\n                    instance.sendDataToArduino(\"G_off\");\n                    startButton.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    glucometerSwitch.setEnabled(false);\n                    viewHandler = new Handler();\n                    Runnable delay = new Runnable() {\n                        @Override\n                        public void run() {\n                            glucometerSwitch.setEnabled(true);\n                        }\n                    };\n                    viewHandler.postDelayed(delay, 1000);\n                }\n            }\n        });\n        rgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rb_mg_dL:\n                       \n                        unitsText.setText(\"mg\/dL\");\n                        break;\n                    case R.id.rb_mmol_L:\n                       \n                        unitsText.setText(\"mmol\/L\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        detailsBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               \n                Intent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n                startActivity(intent);\n            }\n        });\n        anotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setReading(false);\n                glucometerSwitch.setEnabled(true);\n                rbBlood.setEnabled(true);\n                rbSweat.setEnabled(true);\n                rb_mg_dL.setEnabled(true);\n                rb_mmol_L.setEnabled(true);\n                startButton.setEnabled(true);\n                instance.setStringData(null);\n                instance.setCommand(null);\n                unitsText.setVisibility(View.INVISIBLE);\n                glucoseLevelText.setVisibility(View.INVISIBLE);\n                descriptionTxt.setVisibility(View.INVISIBLE);\n                detailsBtn.setVisibility(View.INVISIBLE);\n                anotherReadingBtn.setVisibility(View.INVISIBLE);\n            }\n        });\n        showBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"show\");\n            }\n        });\n        stripBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"strip\");\n            }\n        });\n        dippedBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"dipped\");\n            }\n        });\n    }","cleancode":"private void setupviews() { glucometerattribution = findviewbyid(r.id.glucometerattribution); glucometerimg = findviewbyid(r.id.glucometerimg); insertstriptext = findviewbyid(r.id.insertstriptext); uparrow = findviewbyid(r.id.uparrow); droplet = findviewbyid(r.id.dropletimg); attributiontext = findviewbyid(r.id.attributiontext); placebloodsweatimg = findviewbyid(r.id.placebloodsweatimg); placebloodsweattext = findviewbyid(r.id.placebloodsweattext); waitforreadingtext = findviewbyid(r.id.waitforreadingtext); progressbar = findviewbyid(r.id.progressbar); unitstext = findviewbyid(r.id.unitstext); glucoseleveltext = findviewbyid(r.id.glucoseleveltext); descriptiontxt = findviewbyid(r.id.descriptiontxt); detailsbtn = findviewbyid(r.id.detailsbtn); anotherreadingbtn = findviewbyid(r.id.anotherreadingbtn); showbtn = findviewbyid(r.id.button7); dippedbtn = findviewbyid(r.id.button6); stripbtn = findviewbyid(r.id.button8); startbutton = findviewbyid(r.id.btnstripinserted); rgmode = findviewbyid(r.id.rgmode); rbblood = findviewbyid(r.id.rbblood); rbsweat = findviewbyid(r.id.rbsweat); rb_mg_dl = findviewbyid(r.id.rb_mg_dl); rb_mmol_l = findviewbyid(r.id.rb_mmol_l); glucometerswitch = findviewbyid(r.id.glucometerswitch); rgunits = findviewbyid(r.id.rgunits); startbutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { if (!rbsweat.ischecked() && !rbblood.ischecked()) { toast.maketext(glucometeractivity.this, \"please select a mode\", toast.length_short).show(); } else { instance.senddatatoarduino(\"start\"); instance.setreading(true); glucometerswitch.setenabled(false); rbblood.setenabled(false); rbsweat.setenabled(false); rb_mg_dl.setenabled(false); rb_mmol_l.setenabled(false); startbutton.setenabled(false); glucometerimg.setvisibility(view.visible); glucometerattribution.setvisibility(view.visible); insertstriptext.setvisibility(view.visible); uparrow.setvisibility(view.visible); } } }); rgmode.setoncheckedchangelistener(new radiogroup.oncheckedchangelistener() { @override public void oncheckedchanged(radiogroup group, int checkedid) { switch (checkedid) { case r.id.rbblood: instance.senddatatoarduino(\"blood\"); droplet.setcolorfilter(color.parsecolor(\"#f44336\")); placebloodsweattext.settext(\"place blood on the test strip\"); break; case r.id.rbsweat: instance.senddatatoarduino(\"sweat\"); droplet.setcolorfilter(color.parsecolor(\"#1b95e0\")); placebloodsweattext.settext(\"place sweat on the test strip\"); break; } viewdelay(); } }); glucometerswitch.setoncheckedchangelistener(new compoundbutton.oncheckedchangelistener() { @override public void oncheckedchanged(compoundbutton buttonview, boolean ischecked) { if (ischecked){ instance.senddatatoarduino(\"g_on\"); viewdelay(); }else { instance.senddatatoarduino(\"g_off\"); startbutton.setenabled(false); rbblood.setenabled(false); rbsweat.setenabled(false); rb_mg_dl.setenabled(false); rb_mmol_l.setenabled(false); glucometerswitch.setenabled(false); viewhandler = new handler(); runnable delay = new runnable() { @override public void run() { glucometerswitch.setenabled(true); } }; viewhandler.postdelayed(delay, 1000); } } }); rgunits.setoncheckedchangelistener(new radiogroup.oncheckedchangelistener() { @override public void oncheckedchanged(radiogroup group, int checkedid) { switch (checkedid) { case r.id.rb_mg_dl: unitstext.settext(\"mg\/dl\"); break; case r.id.rb_mmol_l: unitstext.settext(\"mmol\/l\"); break; } viewdelay(); } }); detailsbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(glucometeractivity.this, glucosereadingdetailsactivity.class); intent.addflags(intent.flag_activity_no_animation); startactivity(intent); } }); anotherreadingbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setreading(false); glucometerswitch.setenabled(true); rbblood.setenabled(true); rbsweat.setenabled(true); rb_mg_dl.setenabled(true); rb_mmol_l.setenabled(true); startbutton.setenabled(true); instance.setstringdata(null); instance.setcommand(null); unitstext.setvisibility(view.invisible); glucoseleveltext.setvisibility(view.invisible); descriptiontxt.setvisibility(view.invisible); detailsbtn.setvisibility(view.invisible); anotherreadingbtn.setvisibility(view.invisible); } }); showbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"show\"); } }); stripbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"strip\"); } }); dippedbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"dipped\"); } }); }","repo":"W6WM9M\/VitalityMeter","label":[0,1,0,0]}
{"id":10671,"original_code":"public void render(SpriteBatch batch) {\n        viewport.apply();\n        batch.setProjectionMatrix(viewport.getCamera().combined);\n        batch.begin();\n        \/\/ TODO: Draw a game over message\n        \/\/ Feel free to get more creative with this screen. Perhaps you could cover the screen in enemy robots?\n        float timeElapsed = Utils.secondsSince(startTime);\n        int enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\n        for (int i = 0; i < enemiesToShow; i++){\n            Enemy enemy = enemies.get(i);\n            enemy.update(0);\n            enemy.render(batch);\n        }\n        font.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\n        batch.end();\n    }","code_wo_comment":"public void render(SpriteBatch batch) {\n        viewport.apply();\n        batch.setProjectionMatrix(viewport.getCamera().combined);\n        batch.begin();\n       \n       \n        float timeElapsed = Utils.secondsSince(startTime);\n        int enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\n        for (int i = 0; i < enemiesToShow; i++){\n            Enemy enemy = enemies.get(i);\n            enemy.update(0);\n            enemy.render(batch);\n        }\n        font.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\n        batch.end();\n    }","cleancode":"public void render(spritebatch batch) { viewport.apply(); batch.setprojectionmatrix(viewport.getcamera().combined); batch.begin(); float timeelapsed = utils.secondssince(starttime); int enemiestoshow = (int) (constants.enemy_count * (timeelapsed \/ constants.level_end_duration)); for (int i = 0; i < enemiestoshow; i++){ enemy enemy = enemies.get(i); enemy.update(0); enemy.render(batch); } font.draw(batch, constants.game_over_message, viewport.getworldwidth() \/ 2, viewport.getworldheight() \/ 2.5f, 0, align.center, false); batch.end(); }","repo":"Sceptres\/ud406","label":[0,1,0,0]}
{"id":2527,"original_code":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\n        return Language.i18n(locale, base + \".\" +  enumToGet.name().toLowerCase());\n    }","code_wo_comment":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\n        return Language.i18n(locale, base + \".\" +  enumToGet.name().toLowerCase());\n    }","cleancode":"public static <t extends enum> string getenumi18n(locale locale, string base, t enumtoget) { return language.i18n(locale, base + \".\" + enumtoget.name().tolowercase()); }","repo":"TortleWortle\/CascadeBot","label":[0,0,0,0]}
{"id":10747,"original_code":"public JsonObject setMaxComments(int comments){\n        JsonObject result = new JsonObject();\n        if( dbServices.setMaxCommentsPerVideo(comments)) {\n            result.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n        }\n        else\n            result.addProperty(\"error\",\"Failed to set max comments per video\");\n        return result;\n    }","code_wo_comment":"public JsonObject setMaxComments(int comments){\n        JsonObject result = new JsonObject();\n        if( dbServices.setMaxCommentsPerVideo(comments)) {\n            result.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n        }\n        else\n            result.addProperty(\"error\",\"Failed to set max comments per video\");\n        return result;\n    }","cleancode":"public jsonobject setmaxcomments(int comments){ jsonobject result = new jsonobject(); if( dbservices.setmaxcommentspervideo(comments)) { result.addproperty(\"msg\", \"max comments to collect for each video is now: \" + comments); } else result.addproperty(\"error\",\"failed to set max comments per video\"); return result; }","repo":"UCY-LINC-LAB\/YouTube-Twitter-Analysis","label":[0,1,0,0]}
{"id":2557,"original_code":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\n    OzoneConfiguration conf = new OzoneConfiguration();\n    \/\/ TODO: If you don't have OM HA configured, change the following as appropriate.\n    conf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\n    if (disableChecksum)\n      conf.set(\"ozone.client.checksum.type\", \"NONE\");\n    return OzoneClientFactory.getRpcClient(conf);\n  }","code_wo_comment":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\n    OzoneConfiguration conf = new OzoneConfiguration();\n   \n    conf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\n    if (disableChecksum)\n      conf.set(\"ozone.client.checksum.type\", \"NONE\");\n    return OzoneClientFactory.getRpcClient(conf);\n  }","cleancode":"static ozoneclient getozoneclient(boolean secure) throws ioexception { ozoneconfiguration conf = new ozoneconfiguration(); conf.set(\"ozone.om.address\", \"9.29.173.57:9862\"); if (disablechecksum) conf.set(\"ozone.client.checksum.type\", \"none\"); return ozoneclientfactory.getrpcclient(conf); }","repo":"SincereXIA\/ozonerpc2","label":[1,0,0,0]}
{"id":10797,"original_code":"@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\n\tST_field_t info;\n\tfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\n    boolean flip;\n    int len;\n    CString textbuf;\t\t\/* temp buffer for storing labels *\/\n\tint sides = BOTTOM | RIGHT | TOP | LEFT;\n\t\/* Always use rankdir to determine how records are laid out *\/\n\tflip = NOT(GD_realflip(agraphof(n)));\n\tZ.z().reclblp = ND_label(n).text;\n    len = strlen(Z.z().reclblp);\n    \/* For some forgotten reason, an empty label is parsed into a space, so\n     * we need at least two bytes in textbuf.\n     *\/\n     len = MAX(len, 1);\n     textbuf = CString.gmalloc(len + 1);\n    if (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ \tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ \treclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ \tinfo = parse_reclbl(n, flip, NOT(0), textbuf);\n    }\n    Memory.free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));;\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ \tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ \t\t\tagerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ \t}\n    } else {\n\tsz.x = MAX(info.size.x, sz.x);\n\tsz.y = MAX(info.size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\n    ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.));\t\/* FIXME - is this still true:    suspected to introduce ronding error - see Kluge below *\/\n    pos_reclbl(info, ul, sides);\n    ND_width(n, PS2INCH(info.size.x));\n    ND_height(n, PS2INCH(info.size.y + 1));\t\/* Kluge!!  +1 to fix rounding diff between layout and rendering \n\t\t\t\t\t\t   otherwise we can get -1 coords in output *\/\n    ND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","code_wo_comment":"@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\n\tST_field_t info;\n\tfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\n    boolean flip;\n    int len;\n    CString textbuf;\t\n\tint sides = BOTTOM | RIGHT | TOP | LEFT;\n\n\tflip = NOT(GD_realflip(agraphof(n)));\n\tZ.z().reclblp = ND_label(n).text;\n    len = strlen(Z.z().reclblp);\n   \n     len = MAX(len, 1);\n     textbuf = CString.gmalloc(len + 1);\n    if (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\");\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\");\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\");\n    }\n    Memory.free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));;\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\");\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\");\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\");\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\");\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\");\n    } else {\n\tsz.x = MAX(info.size.x, sz.x);\n\tsz.y = MAX(info.size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\n    ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.));\n    pos_reclbl(info, ul, sides);\n    ND_width(n, PS2INCH(info.size.x));\n    ND_height(n, PS2INCH(info.size.y + 1));\n    ND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","cleancode":"@unused @doc(\"init 'record' node\") @reviewed(when = \"02\/12\/2020\") @original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\") public static void record_init(st_agnode_s n) { entering(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\"); try { st_field_t info; final st_pointf ul = new st_pointf(), sz = new st_pointf(); boolean flip; int len; cstring textbuf; int sides = bottom | right | top | left; flip = not(gd_realflip(agraphof(n))); z.z().reclblp = nd_label(n).text; len = strlen(z.z().reclblp); len = max(len, 1); textbuf = cstring.gmalloc(len + 1); if (n(info = parse_reclbl(n, flip, not(0), textbuf))) { unsupported(\"7iezaksu9hyxhmv3r4cp4o529\"); unsupported(\"8f1id7rqm71svssnxbjo0uwcu\"); unsupported(\"2wv3zfqhq53941rwk4vu9p9th\"); } memory.free(textbuf); size_reclbl(n, info); sz.x = points(nd_width(n));; sz.y = points(nd_height(n)); if (mapbool(late_string(n, z.z().n_fixed, new cstring(\"false\")))) { unsupported(\"8iu51xbtntpdf5sc00g91djym\"); unsupported(\"4vs5u30jzsrn6fpjd327xjf7r\"); unsupported(\"7k6yytek9nu1ihxix2880667g\"); unsupported(\"bnetqzovnscxile7ao44kc0qd\"); unsupported(\"flupwh3kosf3fkhkxllllt1\"); } else { sz.x = max(info.size.x, sz.x); sz.y = max(info.size.y, sz.y); } resize_reclbl(info, sz, mapbool(late_string(n, z.z().n_nojustify, new cstring(\"false\")))); ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); pos_reclbl(info, ul, sides); nd_width(n, ps2inch(info.size.x)); nd_height(n, ps2inch(info.size.y + 1)); nd_shape_info(n, info); } finally { leaving(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\"); } }","repo":"SandraBSofiaH\/Final-UMldoclet","label":[1,1,1,0]}
{"id":19017,"original_code":"private Table buildHeader() {\n        Skin skin = getSkin();\n        SquareButton ffBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        ffBack.flipHorizontal();\n        playBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        playBack.flipHorizontal();\n        play = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        SquareButton ffForward = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        repeatBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-repeat\"), true);\n        newBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-new\"));\n        newBtn.getIconCell().padTop(2).padLeft(1);\n        SquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\n        upBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        upBtn.flipVertical();\n        downBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        downBtn.flipVertical(); downBtn.flipHorizontal();\n        Table header = new Table();\n        header.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\n        Table topPart = new Table();\n        Table bottomPart = new Table();\n        topPart.add(ffBack).padLeft(6).left();\n        \/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\n        topPart.add(play).padLeft(6).left();\n        topPart.add(ffForward).padLeft(6).left();\n        topPart.add(repeatBtn).padLeft(6).left();\n        topPart.add().growX().minWidth(20);\n        topPart.add(upBtn).padRight(6).right();\n        topPart.add(downBtn).padRight(10).right();\n        topPart.add(newBtn).right().padRight(6);\n        topPart.add(deleteBtn).right().padRight(6);\n        topActionCell = topPart.add().right();\n        typeLabel = new Label(\"Items\", skin);\n        typeLabel.setColor(ColorLibrary.FONT_GRAY);\n        bottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\n        header.add(topPart).height(33).padBottom(1).growX().row();\n        header.add(bottomPart).height(16).growX().row();\n        \/**\n         * Build header actions\n         *\/\n        ffBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n            }\n        });\n        ffForward.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);\n            }\n        });\n        playBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.rewind);\n            }\n        });\n        play.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.play);\n            }\n        });\n        repeatBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.toggleLoop);\n            }\n        });\n        deleteBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.deleteSelection);\n            }\n        });\n        newBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.newItem);\n            }\n        });\n        upBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.up);\n            }\n        });\n        downBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.down);\n            }\n        });\n        return header;\n    }","code_wo_comment":"private Table buildHeader() {\n        Skin skin = getSkin();\n        SquareButton ffBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        ffBack.flipHorizontal();\n        playBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        playBack.flipHorizontal();\n        play = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        SquareButton ffForward = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        repeatBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-repeat\"), true);\n        newBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-new\"));\n        newBtn.getIconCell().padTop(2).padLeft(1);\n        SquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\n        upBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        upBtn.flipVertical();\n        downBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        downBtn.flipVertical(); downBtn.flipHorizontal();\n        Table header = new Table();\n        header.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\n        Table topPart = new Table();\n        Table bottomPart = new Table();\n        topPart.add(ffBack).padLeft(6).left();\n       \n        topPart.add(play).padLeft(6).left();\n        topPart.add(ffForward).padLeft(6).left();\n        topPart.add(repeatBtn).padLeft(6).left();\n        topPart.add().growX().minWidth(20);\n        topPart.add(upBtn).padRight(6).right();\n        topPart.add(downBtn).padRight(10).right();\n        topPart.add(newBtn).right().padRight(6);\n        topPart.add(deleteBtn).right().padRight(6);\n        topActionCell = topPart.add().right();\n        typeLabel = new Label(\"Items\", skin);\n        typeLabel.setColor(ColorLibrary.FONT_GRAY);\n        bottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\n        header.add(topPart).height(33).padBottom(1).growX().row();\n        header.add(bottomPart).height(16).growX().row();\n       \n        ffBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n            }\n        });\n        ffForward.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);\n            }\n        });\n        playBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.rewind);\n            }\n        });\n        play.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.play);\n            }\n        });\n        repeatBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.toggleLoop);\n            }\n        });\n        deleteBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.deleteSelection);\n            }\n        });\n        newBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.newItem);\n            }\n        });\n        upBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.up);\n            }\n        });\n        downBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.down);\n            }\n        });\n        return header;\n    }","cleancode":"private table buildheader() { skin skin = getskin(); squarebutton ffback = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-ff\")); ffback.fliphorizontal(); playback = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\"), true); playback.fliphorizontal(); play = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\"), true); squarebutton ffforward = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-ff\")); repeatbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-repeat\"), true); newbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-new\")); newbtn.geticoncell().padtop(2).padleft(1); squarebutton deletebtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-delete\")); upbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\")); upbtn.flipvertical(); downbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\")); downbtn.flipvertical(); downbtn.fliphorizontal(); table header = new table(); header.setbackground(skin.getdrawable(\"timeline-top-bar-bg\")); table toppart = new table(); table bottompart = new table(); toppart.add(ffback).padleft(6).left(); toppart.add(play).padleft(6).left(); toppart.add(ffforward).padleft(6).left(); toppart.add(repeatbtn).padleft(6).left(); toppart.add().growx().minwidth(20); toppart.add(upbtn).padright(6).right(); toppart.add(downbtn).padright(10).right(); toppart.add(newbtn).right().padright(6); toppart.add(deletebtn).right().padright(6); topactioncell = toppart.add().right(); typelabel = new label(\"items\", skin); typelabel.setcolor(colorlibrary.font_gray); bottompart.add(typelabel).padbottom(2).padleft(5).left().expandx(); header.add(toppart).height(33).padbottom(1).growx().row(); header.add(bottompart).height(16).growx().row(); ffback.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.skiptostart); } }); ffforward.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.skiptoend); } }); playback.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.rewind); } }); play.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.play); } }); repeatbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.toggleloop); } }); deletebtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.deleteselection); } }); newbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.newitem); } }); upbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.up); } }); downbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.down); } }); return header; }","repo":"TheSenPie\/talos","label":[0,1,0,0]}
{"id":10974,"original_code":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    BufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\n    INDArray image = loader.asMatrix(buffImg);\n    \/\/ TODO: we should consider the model as not only the model, but also the\n    \/\/ input transforms\n    \/\/ for that model.\n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    log.info(\"Complete with output from vgg16..\");\n    \/\/ TODO: return a more native datastructure!\n    \/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n    \/\/ log.info(\"Image Predictions: {}\", predictions);\n    return decodeVGG16Predictions(output[0]);\n  }","code_wo_comment":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    BufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\n    INDArray image = loader.asMatrix(buffImg);\n   \n   \n   \n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    log.info(\"Complete with output from vgg16..\");\n   \n   \n   \n    return decodeVGG16Predictions(output[0]);\n  }","cleancode":"public map<string, double> classifyimagevgg16(iplimage iplimage) throws ioexception { nativeimageloader loader = new nativeimageloader(224, 224, 3); bufferedimage buffimg = opencv.tobufferedimage(iplimage); indarray image = loader.asmatrix(buffimg); datanormalization scaler = new vgg16imagepreprocessor(); scaler.transform(image); indarray[] output = vgg16.output(false, image); log.info(\"complete with output from vgg16..\"); return decodevgg16predictions(output[0]); }","repo":"ShaunHolt\/myrobotlab","label":[1,0,0,0]}
{"id":10975,"original_code":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\n    File file = new File(filename);\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    INDArray image = loader.asMatrix(file);\n    \/\/ TODO: we should consider the model as not only the model, but also the\n    \/\/ input transforms\n    \/\/ for that model.\n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    \/\/ TODO: return a more native datastructure!\n    \/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n    \/\/ log.info(\"Image Predictions: {}\", predictions);\n    return decodeVGG16Predictions(output[0]);\n  }","code_wo_comment":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\n    File file = new File(filename);\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    INDArray image = loader.asMatrix(file);\n   \n   \n   \n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n   \n   \n   \n    return decodeVGG16Predictions(output[0]);\n  }","cleancode":"public map<string, double> classifyimagefilevgg16(string filename) throws ioexception { file file = new file(filename); nativeimageloader loader = new nativeimageloader(224, 224, 3); indarray image = loader.asmatrix(file); datanormalization scaler = new vgg16imagepreprocessor(); scaler.transform(image); indarray[] output = vgg16.output(false, image); return decodevgg16predictions(output[0]); }","repo":"ShaunHolt\/myrobotlab","label":[1,0,0,0]}
{"id":10994,"original_code":"private long getReservedCacheSize(String uuid) {\n        \/\/ TODO: Revisit the cache size after running more storage tests.\n        \/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n        \/\/       StorageStatsManager, because this is ignoring the cache...\n        StorageManager storageManager = getSystemService(StorageManager.class);\n        long freeBytes = 0;\n        if (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\n            freeBytes = Environment.getDataDirectory().getUsableSpace();\n        } else {\n            final VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\n            freeBytes = vol.getPath().getUsableSpace();\n        }\n        return Math.round(freeBytes * CACHE_RESERVE_RATIO);\n    }","code_wo_comment":"private long getReservedCacheSize(String uuid) {\n       \n       \n       \n        StorageManager storageManager = getSystemService(StorageManager.class);\n        long freeBytes = 0;\n        if (uuid == StorageManager.UUID_PRIVATE_INTERNAL) {\n            freeBytes = Environment.getDataDirectory().getUsableSpace();\n        } else {\n            final VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\n            freeBytes = vol.getPath().getUsableSpace();\n        }\n        return Math.round(freeBytes * CACHE_RESERVE_RATIO);\n    }","cleancode":"private long getreservedcachesize(string uuid) { storagemanager storagemanager = getsystemservice(storagemanager.class); long freebytes = 0; if (uuid == storagemanager.uuid_private_internal) { freebytes = environment.getdatadirectory().getusablespace(); } else { final volumeinfo vol = storagemanager.findvolumebyuuid(uuid); freebytes = vol.getpath().getusablespace(); } return math.round(freebytes * cache_reserve_ratio); }","repo":"Y-D-Lu\/rr_frameworks_base","label":[1,0,0,0]}
{"id":11115,"original_code":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\n                                                    String body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\n        List<String> toList = toEmails;\n        List<String> ccList = ccEmails;\n        if (toEmails.size() <= 0) {\n            if (ccEmails.size() <= 0) {\n                \/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n                \/\/ a draft email with the subject (and no recipients).\n                throw new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n            }\n            \/\/ Email app does not work with no \"to\" recipient.  Move all 'cc' to 'to'\n            \/\/ in this case.\n            toList = ccEmails;\n            ccList = null;\n        }\n        \/\/ Use the event title as the email subject (prepended with 'Re: ').\n        String subject = null;\n        if (eventTitle != null) {\n            subject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n        }\n        \/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n        \/\/ the picker to show apps like text messaging, which does not make sense\n        \/\/ for email addresses.  We put all data in the URI instead of using the extra\n        \/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n        \/\/ those (though gmail does).\n        Uri.Builder uriBuilder = new Uri.Builder();\n        uriBuilder.scheme(\"mailto\");\n        \/\/ We will append the first email to the 'mailto' field later (because the\n        \/\/ current state of the Email app requires it).  Add the remaining 'to' values\n        \/\/ here.  When the email codebase is updated, we can simplify this.\n        if (toList.size() > 1) {\n            for (int i = 1; i < toList.size(); i++) {\n                \/\/ The Email app requires repeated parameter settings instead of\n                \/\/ a single comma-separated list.\n                uriBuilder.appendQueryParameter(\"to\", toList.get(i));\n            }\n        }\n        \/\/ Add the subject parameter.\n        if (subject != null) {\n            uriBuilder.appendQueryParameter(\"subject\", subject);\n        }\n        \/\/ Add the subject parameter.\n        if (body != null) {\n            uriBuilder.appendQueryParameter(\"body\", body);\n        }\n        \/\/ Add the cc parameters.\n        if (ccList != null && ccList.size() > 0) {\n            for (String email : ccList) {\n                uriBuilder.appendQueryParameter(\"cc\", email);\n            }\n        }\n        \/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n        \/\/ doesn't seem to have a way to do this.\n        String uri = uriBuilder.toString();\n        if (uri.startsWith(\"mailto:\")) {\n            StringBuilder builder = new StringBuilder(uri);\n            builder.insert(7, Uri.encode(toList.get(0)));\n            uri = builder.toString();\n        }\n        \/\/ Start the email intent.  Email from the account of the calendar owner in case there\n        \/\/ are multiple email accounts.\n        Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\n        emailIntent.putExtra(\"fromAccountString\", ownerAccount);\n        \/\/ Workaround a Email bug that overwrites the body with this intent extra.  If not\n        \/\/ set, it clears the body.\n        if (body != null) {\n            emailIntent.putExtra(Intent.EXTRA_TEXT, body);\n        }\n        return Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n    }","code_wo_comment":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\n                                                    String body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\n        List<String> toList = toEmails;\n        List<String> ccList = ccEmails;\n        if (toEmails.size() <= 0) {\n            if (ccEmails.size() <= 0) {\n               \n               \n                throw new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n            }\n           \n           \n            toList = ccEmails;\n            ccList = null;\n        }\n       \n        String subject = null;\n        if (eventTitle != null) {\n            subject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n        }\n       \n       \n       \n       \n       \n        Uri.Builder uriBuilder = new Uri.Builder();\n        uriBuilder.scheme(\"mailto\");\n       \n       \n       \n        if (toList.size() > 1) {\n            for (int i = 1; i < toList.size(); i++) {\n               \n               \n                uriBuilder.appendQueryParameter(\"to\", toList.get(i));\n            }\n        }\n       \n        if (subject != null) {\n            uriBuilder.appendQueryParameter(\"subject\", subject);\n        }\n       \n        if (body != null) {\n            uriBuilder.appendQueryParameter(\"body\", body);\n        }\n       \n        if (ccList != null && ccList.size() > 0) {\n            for (String email : ccList) {\n                uriBuilder.appendQueryParameter(\"cc\", email);\n            }\n        }\n       \n       \n        String uri = uriBuilder.toString();\n        if (uri.startsWith(\"mailto:\")) {\n            StringBuilder builder = new StringBuilder(uri);\n            builder.insert(7, Uri.encode(toList.get(0)));\n            uri = builder.toString();\n        }\n       \n       \n        Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\n        emailIntent.putExtra(\"fromAccountString\", ownerAccount);\n       \n       \n        if (body != null) {\n            emailIntent.putExtra(Intent.EXTRA_TEXT, body);\n        }\n        return Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n    }","cleancode":"public static intent createemailattendeesintent(resources resources, string eventtitle, string body, list<string> toemails, list<string> ccemails, string owneraccount) { list<string> tolist = toemails; list<string> cclist = ccemails; if (toemails.size() <= 0) { if (ccemails.size() <= 0) { throw new illegalargumentexception(\"both toemails and ccemails are empty.\"); } tolist = ccemails; cclist = null; } string subject = null; if (eventtitle != null) { subject = resources.getstring(r.string.email_subject_prefix) + eventtitle; } uri.builder uribuilder = new uri.builder(); uribuilder.scheme(\"mailto\"); if (tolist.size() > 1) { for (int i = 1; i < tolist.size(); i++) { uribuilder.appendqueryparameter(\"to\", tolist.get(i)); } } if (subject != null) { uribuilder.appendqueryparameter(\"subject\", subject); } if (body != null) { uribuilder.appendqueryparameter(\"body\", body); } if (cclist != null && cclist.size() > 0) { for (string email : cclist) { uribuilder.appendqueryparameter(\"cc\", email); } } string uri = uribuilder.tostring(); if (uri.startswith(\"mailto:\")) { stringbuilder builder = new stringbuilder(uri); builder.insert(7, uri.encode(tolist.get(0))); uri = builder.tostring(); } intent emailintent = new intent(intent.action_sendto, uri.parse(uri)); emailintent.putextra(\"fromaccountstring\", owneraccount); if (body != null) { emailintent.putextra(intent.extra_text, body); } return intent.createchooser(emailintent, resources.getstring(r.string.email_picker_label)); }","repo":"Shusshu\/Android-RecurrencePicker","label":[0,1,1,0]}
{"id":11181,"original_code":"@NotNull\n    public abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","code_wo_comment":"@NotNull\n    public abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","cleancode":"@notnull public abstract biome getbiome(@notnull worldinfo worldinfo, int x, int y, int z);","repo":"abcd1234-byte\/spigot2","label":[0,1,0,0]}
{"id":3159,"original_code":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\n    if (type.isArray())\n      return; \/\/ TODO: Array types not supported yet ...\n    if (dynamicFieldSuffix == null) {\n      dynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n      \/\/ treat strings with multiple terms as text only if using the default!\n      if (\"_s\".equals(dynamicFieldSuffix)) {\n        String str = (String)value;\n        if (str.indexOf(\" \") != -1)\n          dynamicFieldSuffix = \"_t\";\n      }\n    }\n    if (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\n      doc.addField(fieldName + dynamicFieldSuffix, value);\n  }","code_wo_comment":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\n    if (type.isArray())\n      return;\n    if (dynamicFieldSuffix == null) {\n      dynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n     \n      if (\"_s\".equals(dynamicFieldSuffix)) {\n        String str = (String)value;\n        if (str.indexOf(\" \") != -1)\n          dynamicFieldSuffix = \"_t\";\n      }\n    }\n    if (dynamicFieldSuffix != null)\n      doc.addField(fieldName + dynamicFieldSuffix, value);\n  }","cleancode":"private static void addfield(solrinputdocument doc, string fieldname, object value, class type, string dynamicfieldsuffix) { if (type.isarray()) return; if (dynamicfieldsuffix == null) { dynamicfieldsuffix = getdefaultdynamicfieldmapping(type); if (\"_s\".equals(dynamicfieldsuffix)) { string str = (string)value; if (str.indexof(\" \") != -1) dynamicfieldsuffix = \"_t\"; } } if (dynamicfieldsuffix != null) doc.addfield(fieldname + dynamicfieldsuffix, value); }","repo":"Stratio\/spark-solr","label":[1,0,0,0]}
{"id":11407,"original_code":"protected Path getRealPath2(TVFSAbstractPath path) {\n\t\tList<String> list = new ArrayList<>();\n\t\tfor (String s : path.path) {\n\t\t\tlist.add(s);\n\t\t}\n\t\tPath p;\n\t\tif (list.isEmpty()) {\n\t\t\t\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\n\t\t\tp = fileSystem.getRootPath();\n\t\t} else {\n\t\t\tString first = \"\";\n\t\t\tString others[] = null;\n\/\/\t\t\tif (list.size() >= 1) {\n\/\/\t\t\t\tfirst = list.get(0);\n\/\/\t\t\t}\n\/\/\t\t\tif (list.size() > 1) {\n\/\/\t\t\t\tothers = new String[list.size() - 1];\n\/\/\n\/\/\t\t\t\tfor (int i = 1; i < list.size(); i++) {\n\/\/\t\t\t\t\tothers[i - 1] = list.get(i);\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\t\t\t\/\/if (others == null) {\n\t\t\tp = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\t\t\t\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/\t\t\t} else {\n\/\/\t\t\t\tp = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/\t\t\t}\n\t\t}\n\t\treturn p;\n\t}","code_wo_comment":"protected Path getRealPath2(TVFSAbstractPath path) {\n\t\tList<String> list = new ArrayList<>();\n\t\tfor (String s : path.path) {\n\t\t\tlist.add(s);\n\t\t}\n\t\tPath p;\n\t\tif (list.isEmpty()) {\n\t\t\n\t\t\tp = fileSystem.getRootPath();\n\t\t} else {\n\t\t\tString first = \"\";\n\t\t\tString others[] = null;\n\t\t\n\t\t\tp = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\t\t\n\t\t}\n\t\treturn p;\n\t}","cleancode":"protected path getrealpath2(tvfsabstractpath path) { list<string> list = new arraylist<>(); for (string s : path.path) { list.add(s); } path p; if (list.isempty()) { p = filesystem.getrootpath(); } else { string first = \"\"; string others[] = null; p = filesystem.getrootpath().resolve(list.stream().collect(collectors.joining(filesystem.getseparator()))); } return p; }","repo":"abarhub\/tinyvfs","label":[1,0,0,0]}
{"id":11482,"original_code":"@Override\n    public void populateGui()\n    {\n        \/\/ Filler\n        this.getFiller();\n        \/\/ Items\n        for (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n        {\n            \/\/ Args\n            Material material = entry.getKey();\n            int startAmount = entry.getValue();\n            double startValue = plugin.getCollectorManager().value(collector, material);\n            List<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\n            List<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n            \/\/ Add\n            this.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n            {\n                \/\/ Cancel\n                event.setCancelled(true);\n                \/\/ Args\n                Player player = (Player) event.getWhoClicked();\n                int amount = collector.getMaterialAmount(material);\n                double total = plugin.getCollectorManager().sell(collector, material);\n                \/\/ Check\n                if (total == 0.0d)\n                {\n                    \/\/ TODO: Make it so collectors don't pick up items which can't be sold\n                    return;\n                }\n                \/\/ Deposit & Inform\n                plugin.getMoneyManager().pay(player.getUniqueId(), total);\n                String message = plugin.getConfig().getString(\"messages.material-sold\");\n                if (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n                \/\/ Update\n                this.update();\n            }));\n        }\n        \/\/ Navigation\n        this.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\n        this.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n    }","code_wo_comment":"@Override\n    public void populateGui()\n    {\n       \n        this.getFiller();\n       \n        for (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n        {\n           \n            Material material = entry.getKey();\n            int startAmount = entry.getValue();\n            double startValue = plugin.getCollectorManager().value(collector, material);\n            List<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\n            List<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n           \n            this.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n            {\n               \n                event.setCancelled(true);\n               \n                Player player = (Player) event.getWhoClicked();\n                int amount = collector.getMaterialAmount(material);\n                double total = plugin.getCollectorManager().sell(collector, material);\n               \n                if (total == 0.0d)\n                {\n                   \n                    return;\n                }\n               \n                plugin.getMoneyManager().pay(player.getUniqueId(), total);\n                String message = plugin.getConfig().getString(\"messages.material-sold\");\n                if (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n               \n                this.update();\n            }));\n        }\n       \n        this.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\n        this.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n    }","cleancode":"@override public void populategui() { this.getfiller(); for (map.entry<material, integer> entry : collector.getcontents().entryset()) { material material = entry.getkey(); int startamount = entry.getvalue(); double startvalue = plugin.getcollectormanager().value(collector, material); list<string> lore = color.color(plugin.getconfig().getstringlist(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", string.format(\"%,d\", startamount)).replace(\"%value%\", string.format(\"%,.1f\", startvalue))).collect(collectors.tolist())); list<component> components = lore.stream().map(component::text).collect(collectors.tolist()); this.additem(itembuilder.from(material).name(component.text(this.getnicedenumstring(material.name()))).lore(components).asguiitem(event -> { event.setcancelled(true); player player = (player) event.getwhoclicked(); int amount = collector.getmaterialamount(material); double total = plugin.getcollectormanager().sell(collector, material); if (total == 0.0d) { return; } plugin.getmoneymanager().pay(player.getuniqueid(), total); string message = plugin.getconfig().getstring(\"messages.material-sold\"); if (message != null && !message.isempty()) player.sendmessage(color.color(message.replace(\"%amount%\", string.format(\"%,d\", amount)).replace(\"%material%\", this.getnicedenumstring(material.name())).replace(\"%total%\", string.format(\"%.1f\", total)))); this.update(); })); } this.setitem(3, 3, itembuilder.from(material.arrow).name(component.text(color.color(\"previous\"))).asguiitem(event -> this.previous())); this.setitem(3, 7, itembuilder.from(material.arrow).name(component.text(color.color(\"next\"))).asguiitem(event -> this.next())); }","repo":"Workinq\/AsyncCollectors","label":[0,1,0,0]}
{"id":3400,"original_code":"protected List<String> updateProvisioning(Map<String, File> artifacts, Provisioner provisionService) throws Exception {\n        ResourceInstaller resourceInstaller = provisionService.getResourceInstaller();\n        Map<ResourceIdentity, Resource> installedResources = getInstalledResources(provisionService);\n        Map<Requirement, Resource> requirements = new HashMap<Requirement, Resource>();\n        Set<Map.Entry<String, File>> entries = artifacts.entrySet();\n        List<Resource> resourcesToInstall = new ArrayList<Resource>();\n        List<String> resourceUrisInstalled = new ArrayList<String>();\n        updateStatus(\"installing\", null, null);\n        for (Map.Entry<String, File> entry : entries) {\n            String name = entry.getKey();\n            File file = entry.getValue();\n            String coords = name;\n            int idx = coords.lastIndexOf(':');\n            if (idx > 0) {\n                coords = name.substring(idx + 1);\n            }\n            \/\/ lets switch to gravia's mvn coordinates\n            coords = coords.replace('\/', ':');\n            MavenCoordinates mvnCoords = parse(coords);\n            URL url = file.toURI().toURL();\n            if (url == null) {\n                LOGGER.warn(\"Could not find URL for file \" + file);\n                continue;\n            }\n            \/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\n            boolean isShared = !isWar(name, file);\n            Resource resource = findMavenResource(mvnCoords, url, isShared);\n            if (resource == null) {\n                LOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n            } else {\n                ResourceIdentity identity = resource.getIdentity();\n                Resource oldResource = installedResources.remove(identity);\n                if (oldResource == null && !resourcehandleMap.containsKey(identity)) {\n                    if (isShared) {\n                        \/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n                        \/\/ which breaks the tests ;)\n                        LOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                    } else {\n                        LOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                        resourcesToInstall.add(resource);\n                        resourceUrisInstalled.add(name);\n                    }\n                }\n            }\n        }\n        for (Resource installedResource : installedResources.values()) {\n            ResourceIdentity identity = installedResource.getIdentity();\n            ResourceHandle resourceHandle = resourcehandleMap.get(identity);\n            if (resourceHandle == null) {\n                \/\/ TODO should not really happen when we can ask about the installed Resources\n                LOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n            } else {\n                LOGGER.info(\"Uninstalling \" + installedResource);\n                resourceHandle.uninstall();\n                resourcehandleMap.remove(identity);\n                LOGGER.info(\"Uninstalled \" + installedResource);\n            }\n        }\n        if (resourcesToInstall.size() > 0) {\n            LOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");\n            Set<ResourceHandle> resourceHandles = new LinkedHashSet<>();\n            ResourceInstaller.Context context = new DefaultInstallerContext(resourcesToInstall, requirements);\n            for (Resource resource : resourcesToInstall) {\n                resourceHandles.add(resourceInstaller.installResource(context, resource));\n            }\n            LOGGER.info(\"Got \" + resourceHandles.size() + \" resource handle(s)\");\n            for (ResourceHandle resourceHandle : resourceHandles) {\n                resourcehandleMap.put(resourceHandle.getResource().getIdentity(), resourceHandle);\n            }\n        }\n        return resourceUrisInstalled;\n    }","code_wo_comment":"protected List<String> updateProvisioning(Map<String, File> artifacts, Provisioner provisionService) throws Exception {\n        ResourceInstaller resourceInstaller = provisionService.getResourceInstaller();\n        Map<ResourceIdentity, Resource> installedResources = getInstalledResources(provisionService);\n        Map<Requirement, Resource> requirements = new HashMap<Requirement, Resource>();\n        Set<Map.Entry<String, File>> entries = artifacts.entrySet();\n        List<Resource> resourcesToInstall = new ArrayList<Resource>();\n        List<String> resourceUrisInstalled = new ArrayList<String>();\n        updateStatus(\"installing\", null, null);\n        for (Map.Entry<String, File> entry : entries) {\n            String name = entry.getKey();\n            File file = entry.getValue();\n            String coords = name;\n            int idx = coords.lastIndexOf(':');\n            if (idx > 0) {\n                coords = name.substring(idx + 1);\n            }\n           \n            coords = coords.replace('\/', ':');\n            MavenCoordinates mvnCoords = parse(coords);\n            URL url = file.toURI().toURL();\n            if (url == null) {\n                LOGGER.warn(\"Could not find URL for file \" + file);\n                continue;\n            }\n           \n            boolean isShared = !isWar(name, file);\n            Resource resource = findMavenResource(mvnCoords, url, isShared);\n            if (resource == null) {\n                LOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n            } else {\n                ResourceIdentity identity = resource.getIdentity();\n                Resource oldResource = installedResources.remove(identity);\n                if (oldResource == null && !resourcehandleMap.containsKey(identity)) {\n                    if (isShared) {\n                       \n                       \n                        LOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                    } else {\n                        LOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                        resourcesToInstall.add(resource);\n                        resourceUrisInstalled.add(name);\n                    }\n                }\n            }\n        }\n        for (Resource installedResource : installedResources.values()) {\n            ResourceIdentity identity = installedResource.getIdentity();\n            ResourceHandle resourceHandle = resourcehandleMap.get(identity);\n            if (resourceHandle == null) {\n               \n                LOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n            } else {\n                LOGGER.info(\"Uninstalling \" + installedResource);\n                resourceHandle.uninstall();\n                resourcehandleMap.remove(identity);\n                LOGGER.info(\"Uninstalled \" + installedResource);\n            }\n        }\n        if (resourcesToInstall.size() > 0) {\n            LOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");\n            Set<ResourceHandle> resourceHandles = new LinkedHashSet<>();\n            ResourceInstaller.Context context = new DefaultInstallerContext(resourcesToInstall, requirements);\n            for (Resource resource : resourcesToInstall) {\n                resourceHandles.add(resourceInstaller.installResource(context, resource));\n            }\n            LOGGER.info(\"Got \" + resourceHandles.size() + \" resource handle(s)\");\n            for (ResourceHandle resourceHandle : resourceHandles) {\n                resourcehandleMap.put(resourceHandle.getResource().getIdentity(), resourceHandle);\n            }\n        }\n        return resourceUrisInstalled;\n    }","cleancode":"protected list<string> updateprovisioning(map<string, file> artifacts, provisioner provisionservice) throws exception { resourceinstaller resourceinstaller = provisionservice.getresourceinstaller(); map<resourceidentity, resource> installedresources = getinstalledresources(provisionservice); map<requirement, resource> requirements = new hashmap<requirement, resource>(); set<map.entry<string, file>> entries = artifacts.entryset(); list<resource> resourcestoinstall = new arraylist<resource>(); list<string> resourceurisinstalled = new arraylist<string>(); updatestatus(\"installing\", null, null); for (map.entry<string, file> entry : entries) { string name = entry.getkey(); file file = entry.getvalue(); string coords = name; int idx = coords.lastindexof(':'); if (idx > 0) { coords = name.substring(idx + 1); } coords = coords.replace('\/', ':'); mavencoordinates mvncoords = parse(coords); url url = file.touri().tourl(); if (url == null) { logger.warn(\"could not find url for file \" + file); continue; } boolean isshared = !iswar(name, file); resource resource = findmavenresource(mvncoords, url, isshared); if (resource == null) { logger.warn(\"could not find resource for \" + mvncoords + \" and \" + url); } else { resourceidentity identity = resource.getidentity(); resource oldresource = installedresources.remove(identity); if (oldresource == null && !resourcehandlemap.containskey(identity)) { if (isshared) { logger.debug(\"todo not installing \" + (isshared ? \"shared\" : \"non-shared\") + \" resource: \" + identity); } else { logger.info(\"installing \" + (isshared ? \"shared\" : \"non-shared\") + \" resource: \" + identity); resourcestoinstall.add(resource); resourceurisinstalled.add(name); } } } } for (resource installedresource : installedresources.values()) { resourceidentity identity = installedresource.getidentity(); resourcehandle resourcehandle = resourcehandlemap.get(identity); if (resourcehandle == null) { logger.warn(\"todo: cannot uninstall \" + installedresource + \" as we have no handle!\"); } else { logger.info(\"uninstalling \" + installedresource); resourcehandle.uninstall(); resourcehandlemap.remove(identity); logger.info(\"uninstalled \" + installedresource); } } if (resourcestoinstall.size() > 0) { logger.info(\"installing \" + resourcestoinstall.size() + \" resource(s)\"); set<resourcehandle> resourcehandles = new linkedhashset<>(); resourceinstaller.context context = new defaultinstallercontext(resourcestoinstall, requirements); for (resource resource : resourcestoinstall) { resourcehandles.add(resourceinstaller.installresource(context, resource)); } logger.info(\"got \" + resourcehandles.size() + \" resource handle(s)\"); for (resourcehandle resourcehandle : resourcehandles) { resourcehandlemap.put(resourcehandle.getresource().getidentity(), resourcehandle); } } return resourceurisinstalled; }","repo":"WillemJiang\/fabric8","label":[1,0,0,0]}
{"id":3401,"original_code":"private static MavenCoordinates parse(String coordinates) {\n        MavenCoordinates result;\n        String[] parts = coordinates.split(\":\");\n        if (parts.length == 3) {\n            result =  MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n        } else if (parts.length == 4) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n        } else if (parts.length == 5) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n        } else {\n            throw new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n        }\n        return result;\n    }","code_wo_comment":"private static MavenCoordinates parse(String coordinates) {\n        MavenCoordinates result;\n        String[] parts = coordinates.split(\":\");\n        if (parts.length == 3) {\n            result =  MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n        } else if (parts.length == 4) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n        } else if (parts.length == 5) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n        } else {\n            throw new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n        }\n        return result;\n    }","cleancode":"private static mavencoordinates parse(string coordinates) { mavencoordinates result; string[] parts = coordinates.split(\":\"); if (parts.length == 3) { result = mavencoordinates.create(parts[0], parts[1], parts[2], null, null); } else if (parts.length == 4) { result = mavencoordinates.create(parts[0], parts[1], parts[2], parts[3], null); } else if (parts.length == 5) { result = mavencoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]); } else { throw new illegalargumentexception(\"invalid coordinates: \" + coordinates); } return result; }","repo":"WillemJiang\/fabric8","label":[0,0,1,0]}
{"id":19814,"original_code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code_wo_comment":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonentry() throws datamodelexception { }","repo":"airlenet\/yang-maven-plugin","label":[0,1,0,0]}
{"id":19815,"original_code":"@Override\n    public void validateDataOnExit()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code_wo_comment":"@Override\n    public void validateDataOnExit()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonexit() throws datamodelexception { }","repo":"airlenet\/yang-maven-plugin","label":[0,1,0,0]}
{"id":19923,"original_code":"@OnClick(R.id.btn_meter_set_minus)\n    void decreaseLevel() {\n        if (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\n            return;\n        }\n        mLevelToSet--;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n        \/\/TODO send setting level frame and change shared prefs and display\n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","code_wo_comment":"@OnClick(R.id.btn_meter_set_minus)\n    void decreaseLevel() {\n        if (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\n            return;\n        }\n        mLevelToSet--;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n       \n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","cleancode":"@onclick(r.id.btn_meter_set_minus) void decreaselevel() { if (mleveltoset == channels.chn_min_value_of_everything) { return; } mleveltoset--; mtextviewlevel.settext(string.format(locale.us, \"%1$d\", mleveltoset)); updatelevelforprefsandviewandsendframe(mleveltoset); islevelzero(); }","repo":"SirdarYangK\/SirdarYKCode","label":[0,1,0,0]}
{"id":19924,"original_code":"@OnClick(R.id.btn_meter_set_plus)\n    void increaseLevel() {\n        if (mLevelToSet == Channels.CHN_MAX_LEVEL) {\n            return;\n        }\n        mLevelToSet++;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n        \/\/TODO send setting level frame and change shared prefs and display\n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","code_wo_comment":"@OnClick(R.id.btn_meter_set_plus)\n    void increaseLevel() {\n        if (mLevelToSet == Channels.CHN_MAX_LEVEL) {\n            return;\n        }\n        mLevelToSet++;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n       \n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","cleancode":"@onclick(r.id.btn_meter_set_plus) void increaselevel() { if (mleveltoset == channels.chn_max_level) { return; } mleveltoset++; mtextviewlevel.settext(string.format(locale.us, \"%1$d\", mleveltoset)); updatelevelforprefsandviewandsendframe(mleveltoset); islevelzero(); }","repo":"SirdarYangK\/SirdarYKCode","label":[0,1,0,0]}
{"id":3700,"original_code":"@Override\n    public AJoinPoint insertBeginImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\t\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\t\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\n\tCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\t\/\/ return node;\n\t\/\/ TODO: Consider returning newStmt instead\n\treturn CxxJoinpoints.create(newStmt);\n    }","code_wo_comment":"@Override\n    public AJoinPoint insertBeginImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\n\n\tCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\n\n\treturn CxxJoinpoints.create(newStmt);\n    }","cleancode":"@override public ajoinpoint insertbeginimpl(ajoinpoint node) { stmt newstmt = clavanodes.tostmt(node.getnode()); cxxactions.insertstmt(\"before\", scope, newstmt, getweaverengine()); return cxxjoinpoints.create(newstmt); }","repo":"TheNunoGomes\/clava","label":[1,0,0,0]}
{"id":3701,"original_code":"@Override\n    public AJoinPoint insertEndImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\t\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\t\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\t\/\/ node.getJoinPointType());\n\tCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\t\/\/ return node;\n\t\/\/ TODO: Consider returning newStmt instead\n\treturn CxxJoinpoints.create(newStmt);\n\t\/*\n\t * List<? extends AStatement> statements = selectStatements(); if\n\t * (statements.isEmpty()) { throw new\n\t * RuntimeException(\"Not yet implemented when scope is empty\"); }\n\t * \n\t * Stmt newStmt =\n\t * CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n\t * \n\t * insertImpl(position, newStmt);\n\t * \n\t * \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n\t * this);\n\t *\/\n    }","code_wo_comment":"@Override\n    public AJoinPoint insertEndImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\n\n\n\tCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\n\n\treturn CxxJoinpoints.create(newStmt);\n\n    }","cleancode":"@override public ajoinpoint insertendimpl(ajoinpoint node) { stmt newstmt = clavanodes.tostmt(node.getnode()); cxxactions.insertstmt(\"after\", scope, newstmt, getweaverengine()); return cxxjoinpoints.create(newstmt); }","repo":"TheNunoGomes\/clava","label":[1,0,0,0]}
{"id":12023,"original_code":"public void update(long fps) {\n        if (paddleMoving == LEFT) {\n            \/\/ to fix Paddle going off the Screen\n            if (x >= -MYscreenDPI \/ 10)\n                \/\/ Decrement position\n                x = x - paddleSpeed \/ fps;\n        }\n        if (paddleMoving == RIGHT) {\n            \/\/ to fix Paddle going off the Screen\n            if (x <= scrX - length - MYscreenDPI \/ 14)\n                \/\/ Increment position\n                x = x + paddleSpeed \/ fps;\n        }\n        \/\/ Apply the New position\n        rect.left = x;\n        rect.right = x + length;\n    }","code_wo_comment":"public void update(long fps) {\n        if (paddleMoving == LEFT) {\n           \n            if (x >= -MYscreenDPI \/ 10)\n               \n                x = x - paddleSpeed \/ fps;\n        }\n        if (paddleMoving == RIGHT) {\n           \n            if (x <= scrX - length - MYscreenDPI \/ 14)\n               \n                x = x + paddleSpeed \/ fps;\n        }\n       \n        rect.left = x;\n        rect.right = x + length;\n    }","cleancode":"public void update(long fps) { if (paddlemoving == left) { if (x >= -myscreendpi \/ 10) x = x - paddlespeed \/ fps; } if (paddlemoving == right) { if (x <= scrx - length - myscreendpi \/ 14) x = x + paddlespeed \/ fps; } rect.left = x; rect.right = x + length; }","repo":"Shuffler\/Breakout-Android-Game","label":[0,0,1,0]}
{"id":20364,"original_code":"@JsonGetter(\"action\")\n    public ApplicationActionTypeEnum getAction ( ) { \n        return this.action;\n    }","code_wo_comment":"@JsonGetter(\"action\")\n    public ApplicationActionTypeEnum getAction ( ) { \n        return this.action;\n    }","cleancode":"@jsongetter(\"action\") public applicationactiontypeenum getaction ( ) { return this.action; }","repo":"agaveplatform\/java-sdk","label":[0,0,0,0]}
{"id":20365,"original_code":"@JsonSetter(\"action\")\n    private void setAction (ApplicationActionTypeEnum value) { \n        this.action = value;\n    }","code_wo_comment":"@JsonSetter(\"action\")\n    private void setAction (ApplicationActionTypeEnum value) { \n        this.action = value;\n    }","cleancode":"@jsonsetter(\"action\") private void setaction (applicationactiontypeenum value) { this.action = value; }","repo":"agaveplatform\/java-sdk","label":[0,0,0,0]}
{"id":12178,"original_code":"public static String generateFunction(){\n    \tList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n    \t\/* TODO Need to find alternative for this\n    \tDataMapperRoot rootDiagram =  (DataMapperRoot)DataMapperDiagramEditor.getInstance().getDiagram().getElement();\n    \tTreeNode inputTreeNode = rootDiagram.getInput().getTreeNode().get(0);\n    \tTreeNode outputTreeNode = rootDiagram.getOutput().getTreeNode().get(0);\n    \tString input = inputTreeNode.getName();\n\t\tString output = outputTreeNode.getName();\n\t\tString functionStart = \"function map_S_\"+input+\"_S_\"+output+\"(\" + input + \", \" + output + \"){\\n\";\n\t\tString functionReturn = \"return \" + output + \";\\n\";\n\t\tJsFunction mainFunction = new JsFunction(0);\n\t\tmainFunction.setFunctionStart(functionStart);\n\t\tmainFunction.setFunctionReturn(functionReturn);\n\t\tdmcFunctions.add(mainFunction);\n\t\tList<JsFunction> innerFunctions = getFunctionForTheTreeNode(rootDiagram.getInput().getTreeNode(), dmcFunctions, 0, null);\n\t\tmainFunction.getFunctions().addAll(innerFunctions);\n\t\t*\/\n\t\tString documentString = \"\";\n\t\tfor (JsFunction func : dmcFunctions) {\n\t\t\tdocumentString += func.toString() + \"\\n\\n\";\n\t\t}\n\t\treturn documentString;\n    }","code_wo_comment":"public static String generateFunction(){\n    \tList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n    \n\t\tString documentString = \"\";\n\t\tfor (JsFunction func : dmcFunctions) {\n\t\t\tdocumentString += func.toString() + \"\\n\\n\";\n\t\t}\n\t\treturn documentString;\n    }","cleancode":"public static string generatefunction(){ list<jsfunction> dmcfunctions = new arraylist<jsfunction>(); string documentstring = \"\"; for (jsfunction func : dmcfunctions) { documentstring += func.tostring() + \"\\n\\n\"; } return documentstring; }","repo":"SanojPunchihewa\/devstudio-tooling-esb","label":[1,0,0,0]}
{"id":12258,"original_code":"public void postPutAll(final DistributedPutAllOperation putAllOp,\n      final VersionedObjectList successfulPuts, final LocalRegion region) {\n    \/\/ TODO: TX: add support for batching using performOp as for other\n    \/\/ update operations; add cacheWrite flag support for proper writer\n    \/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\n    markDirty();\n    if (isSnapshot()) {\n      addAffectedRegion(region);\n      region.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\n      return;\n    }\n    if (region.getPartitionAttributes() != null) {\n      \/\/ use PutAllPRMessage that already handles transactions\n      region.postPutAllSend(putAllOp, this, successfulPuts);\n    }\n    else {\n      try {\n        final PutAllEntryData[] data = putAllOp.putAllData;\n        final EntryEventImpl event = putAllOp.getBaseEvent();\n        final RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\n            data, data.length, event.isPossibleDuplicate(), null, this);\n        \/\/ process on self first\n        if (region.getDataPolicy().withStorage()) {\n          msg.doLocalPutAll(region, event, putAllOp, successfulPuts,\n              region.getMyId(), false \/* sendReply *\/);\n        }\n        addAffectedRegion(region);\n        if (region.getScope().isDistributed()) {\n          \/\/ distribute if required\n          msg.distribute(event);\n        }\n      } catch (RemoteOperationException roe) {\n        throw new TransactionDataNodeHasDepartedException(roe);\n      }\n    }\n  }","code_wo_comment":"public void postPutAll(final DistributedPutAllOperation putAllOp,\n      final VersionedObjectList successfulPuts, final LocalRegion region) {\n   \n   \n   \n    markDirty();\n    if (isSnapshot()) {\n      addAffectedRegion(region);\n      region.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\n      return;\n    }\n    if (region.getPartitionAttributes() != null) {\n     \n      region.postPutAllSend(putAllOp, this, successfulPuts);\n    }\n    else {\n      try {\n        final PutAllEntryData[] data = putAllOp.putAllData;\n        final EntryEventImpl event = putAllOp.getBaseEvent();\n        final RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\n            data, data.length, event.isPossibleDuplicate(), null, this);\n       \n        if (region.getDataPolicy().withStorage()) {\n          msg.doLocalPutAll(region, event, putAllOp, successfulPuts,\n              region.getMyId(), false);\n        }\n        addAffectedRegion(region);\n        if (region.getScope().isDistributed()) {\n         \n          msg.distribute(event);\n        }\n      } catch (RemoteOperationException roe) {\n        throw new TransactionDataNodeHasDepartedException(roe);\n      }\n    }\n  }","cleancode":"public void postputall(final distributedputalloperation putallop, final versionedobjectlist successfulputs, final localregion region) { markdirty(); if (issnapshot()) { addaffectedregion(region); region.getshareddataview().postputall(putallop, successfulputs, region); return; } if (region.getpartitionattributes() != null) { region.postputallsend(putallop, this, successfulputs); } else { try { final putallentrydata[] data = putallop.putalldata; final entryeventimpl event = putallop.getbaseevent(); final remoteputallmessage msg = new remoteputallmessage(event, null, data, data.length, event.ispossibleduplicate(), null, this); if (region.getdatapolicy().withstorage()) { msg.dolocalputall(region, event, putallop, successfulputs, region.getmyid(), false); } addaffectedregion(region); if (region.getscope().isdistributed()) { msg.distribute(event); } } catch (remoteoperationexception roe) { throw new transactiondatanodehasdepartedexception(roe); } } }","repo":"SnappyDataInc\/snappy-store","label":[0,1,0,0]}
{"id":12419,"original_code":"public static void layoutInit() {\n        Dimension dimension = new Dimension(560, 320);\n        if (OperatingSystem.getCurrent() == OperatingSystem.MACOS) {\n            dimension.setSize(dimension.getWidth() * PopupBase.MACOS_WIDTH_SCALE, dimension.getHeight());\n        }\n        FRAME.setPreferredSize(dimension);\n        LOG_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(LogFrame.class)) {\n                new LogFrame();\n            } else {\n                PopupBase.getAlive(LogFrame.class).reopen();\n            }\n        });\n        JS_BTN.addActionListener((e) -> {\n            MainJDEC.IS_ENABLED.setSelected(false);\n            MainJDEC.IS_ENABLED.setEnabled(false);\n            if (!PopupBase.isAlive(JoystickFrame.class)) {\n                new JoystickFrame();\n            } else {\n                PopupBase.getAlive(JoystickFrame.class).reopen();\n            }\n        });\n        STATS_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(StatsFrame.class)) {\n                new StatsFrame();\n            } else {\n                PopupBase.getAlive(StatsFrame.class).reopen();\n            }\n        });\n        NT_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(NTFrame.class)) {\n                NT_FRAME = new NTFrame();\n            } else {\n                PopupBase.getAlive(NTFrame.class).reopen();\n            }\n        });\n        USB_CONNECT.addActionListener((e) -> {\n            Thread reload = new Thread() {\n                @Override\n                public void run() {\n                    NetworkReloader.reloadRio(Protocol.UDP);\n                    NetworkReloader.reloadRio(Protocol.TCP);\n                    super.run();\n                    interrupt();\n                }\n            };\n            reload.start();\n        });\n        RESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n        \/\/TODO remove after testing\n        TEAM_NUMBER.setText(\"localhost\");\n        TEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\n        IS_ENABLED.setEnabled(false);\n        GlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n                .addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n                .addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\n        GBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\n        base.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\n        base.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\n        base.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));\n        base.clone().setPos(0, 2, 1, 1).build(IS_ENABLED);\n        base.clone().setPos(1, 2, 1, 1).build(ROBOT_DRIVE_MODE);\n        base.clone().setPos(0, 3, 2, 1).setFill(GridBagConstraints.NONE).build(new JLabel(\"Alliance Station\"));\n        base.clone().setPos(0, 4, 1, 1).build(ALLIANCE_NUM);\n        base.clone().setPos(1, 4, 1, 1).build(ALLIANCE_COLOR);\n        endr.clone().setPos(0, 5, 1, 1).build(new JLabel(\"Team Number:\"));\n        base.clone().setPos(1, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(TEAM_NUMBER);\n        endr.clone().setPos(0, 6, 1, 1).build(new JLabel(\"Game Data:\"));\n        base.clone().setPos(1, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(GAME_DATA);\n        endr.clone().setPos(0, 7, 1, 1).build(new JLabel(\"Protocol Year:\"));\n        base.clone().setPos(1, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(PROTOCOL_YEAR);\n        base.clone().setPos(2, 2, 2, 1).build(RESTART_CODE_BTN);\n        base.clone().setPos(2, 3, 2, 1).build(RESTART_ROBO_RIO_BTN);\n        base.clone().setPos(2, 4, 2, 1).build(ESTOP_BTN);\n        base.clone().setPos(2, 5, 1, 1).build(JS_BTN);\n        base.clone().setPos(3, 5, 1, 1).build(STATS_BTN);\n        base.clone().setPos(2, 6, 1, 1).build(NT_BTN);\n        base.clone().setPos(3, 6, 1, 1).build(LOG_BTN);\n        base.clone().setPos(2, 7, 1, 1).build(FMS_CONNECT);\n        base.clone().setPos(3, 7, 1, 1).build(USB_CONNECT);\n        base.clone().setPos(4, 2, 2, 1).setFill(GridBagConstraints.NONE).build(BAT_VOLTAGE);\n        endr.clone().setPos(4, 3, 1, 1).build(new JLabel(\"Robot:\"));\n        base.clone().setPos(5, 3, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CONNECTION_STATUS);\n        endr.clone().setPos(4, 4, 1, 1).build(new JLabel(\"Code: \"));\n        base.clone().setPos(5, 4, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CODE_STATUS);\n        endr.clone().setPos(4, 5, 1, 1).build(new JLabel(\"EStop: \"));\n        base.clone().setPos(5, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ESTOP_STATUS);\n        endr.clone().setPos(4, 6, 1, 1).build(new JLabel(\"FMS: \"));\n        base.clone().setPos(5, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(FMS_CONNECTION_STATUS);\n        endr.clone().setPos(4, 7, 1, 1).build(new JLabel(\"Time: \"));\n        base.clone().setPos(5, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(MATCH_TIME);\n    }","code_wo_comment":"public static void layoutInit() {\n        Dimension dimension = new Dimension(560, 320);\n        if (OperatingSystem.getCurrent() == OperatingSystem.MACOS) {\n            dimension.setSize(dimension.getWidth() * PopupBase.MACOS_WIDTH_SCALE, dimension.getHeight());\n        }\n        FRAME.setPreferredSize(dimension);\n        LOG_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(LogFrame.class)) {\n                new LogFrame();\n            } else {\n                PopupBase.getAlive(LogFrame.class).reopen();\n            }\n        });\n        JS_BTN.addActionListener((e) -> {\n            MainJDEC.IS_ENABLED.setSelected(false);\n            MainJDEC.IS_ENABLED.setEnabled(false);\n            if (!PopupBase.isAlive(JoystickFrame.class)) {\n                new JoystickFrame();\n            } else {\n                PopupBase.getAlive(JoystickFrame.class).reopen();\n            }\n        });\n        STATS_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(StatsFrame.class)) {\n                new StatsFrame();\n            } else {\n                PopupBase.getAlive(StatsFrame.class).reopen();\n            }\n        });\n        NT_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(NTFrame.class)) {\n                NT_FRAME = new NTFrame();\n            } else {\n                PopupBase.getAlive(NTFrame.class).reopen();\n            }\n        });\n        USB_CONNECT.addActionListener((e) -> {\n            Thread reload = new Thread() {\n                @Override\n                public void run() {\n                    NetworkReloader.reloadRio(Protocol.UDP);\n                    NetworkReloader.reloadRio(Protocol.TCP);\n                    super.run();\n                    interrupt();\n                }\n            };\n            reload.start();\n        });\n        RESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n       \n        TEAM_NUMBER.setText(\"localhost\");\n        TEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\n        IS_ENABLED.setEnabled(false);\n        GlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n                .addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n                .addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\n        GBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\n        base.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\n        base.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\n        base.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));\n        base.clone().setPos(0, 2, 1, 1).build(IS_ENABLED);\n        base.clone().setPos(1, 2, 1, 1).build(ROBOT_DRIVE_MODE);\n        base.clone().setPos(0, 3, 2, 1).setFill(GridBagConstraints.NONE).build(new JLabel(\"Alliance Station\"));\n        base.clone().setPos(0, 4, 1, 1).build(ALLIANCE_NUM);\n        base.clone().setPos(1, 4, 1, 1).build(ALLIANCE_COLOR);\n        endr.clone().setPos(0, 5, 1, 1).build(new JLabel(\"Team Number:\"));\n        base.clone().setPos(1, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(TEAM_NUMBER);\n        endr.clone().setPos(0, 6, 1, 1).build(new JLabel(\"Game Data:\"));\n        base.clone().setPos(1, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(GAME_DATA);\n        endr.clone().setPos(0, 7, 1, 1).build(new JLabel(\"Protocol Year:\"));\n        base.clone().setPos(1, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(PROTOCOL_YEAR);\n        base.clone().setPos(2, 2, 2, 1).build(RESTART_CODE_BTN);\n        base.clone().setPos(2, 3, 2, 1).build(RESTART_ROBO_RIO_BTN);\n        base.clone().setPos(2, 4, 2, 1).build(ESTOP_BTN);\n        base.clone().setPos(2, 5, 1, 1).build(JS_BTN);\n        base.clone().setPos(3, 5, 1, 1).build(STATS_BTN);\n        base.clone().setPos(2, 6, 1, 1).build(NT_BTN);\n        base.clone().setPos(3, 6, 1, 1).build(LOG_BTN);\n        base.clone().setPos(2, 7, 1, 1).build(FMS_CONNECT);\n        base.clone().setPos(3, 7, 1, 1).build(USB_CONNECT);\n        base.clone().setPos(4, 2, 2, 1).setFill(GridBagConstraints.NONE).build(BAT_VOLTAGE);\n        endr.clone().setPos(4, 3, 1, 1).build(new JLabel(\"Robot:\"));\n        base.clone().setPos(5, 3, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CONNECTION_STATUS);\n        endr.clone().setPos(4, 4, 1, 1).build(new JLabel(\"Code: \"));\n        base.clone().setPos(5, 4, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CODE_STATUS);\n        endr.clone().setPos(4, 5, 1, 1).build(new JLabel(\"EStop: \"));\n        base.clone().setPos(5, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ESTOP_STATUS);\n        endr.clone().setPos(4, 6, 1, 1).build(new JLabel(\"FMS: \"));\n        base.clone().setPos(5, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(FMS_CONNECTION_STATUS);\n        endr.clone().setPos(4, 7, 1, 1).build(new JLabel(\"Time: \"));\n        base.clone().setPos(5, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(MATCH_TIME);\n    }","cleancode":"public static void layoutinit() { dimension dimension = new dimension(560, 320); if (operatingsystem.getcurrent() == operatingsystem.macos) { dimension.setsize(dimension.getwidth() * popupbase.macos_width_scale, dimension.getheight()); } frame.setpreferredsize(dimension); log_btn.addactionlistener((e) -> { if (!popupbase.isalive(logframe.class)) { new logframe(); } else { popupbase.getalive(logframe.class).reopen(); } }); js_btn.addactionlistener((e) -> { mainjdec.is_enabled.setselected(false); mainjdec.is_enabled.setenabled(false); if (!popupbase.isalive(joystickframe.class)) { new joystickframe(); } else { popupbase.getalive(joystickframe.class).reopen(); } }); stats_btn.addactionlistener((e) -> { if (!popupbase.isalive(statsframe.class)) { new statsframe(); } else { popupbase.getalive(statsframe.class).reopen(); } }); nt_btn.addactionlistener((e) -> { if (!popupbase.isalive(ntframe.class)) { nt_frame = new ntframe(); } else { popupbase.getalive(ntframe.class).reopen(); } }); usb_connect.addactionlistener((e) -> { thread reload = new thread() { @override public void run() { networkreloader.reloadrio(protocol.udp); networkreloader.reloadrio(protocol.tcp); super.run(); interrupt(); } }; reload.start(); }); restart_code_btn.addactionlistener(e -> is_enabled.setselected(false)); team_number.settext(\"localhost\"); team_number.getdocument().adddocumentlistener(new teamnumlistener()); is_enabled.setenabled(false); globalscreen.addnativekeylistener(globalkeylistener.instance .addkeyevent(nativekeyevent.vc_enter, () -> mainjdec.is_enabled.setselected(false)) .addkeyevent(nativekeyevent.vc_space, mainjdec.estop_btn::doclick)); gbcpanelbuilder endr = base.clone().setanchor(gridbagconstraints.line_end).setfill(gridbagconstraints.none); base.clone().setpos(0, 0, 6, 1).setfill(gridbagconstraints.none).build(title); base.clone().setpos(0, 1, 6, 1).setfill(gridbagconstraints.none).build(link); base.clone().setpos(5, 0, 1, 2).setfill(gridbagconstraints.none).build(new jlabel(new imageicon(mainframe.icon_min))); base.clone().setpos(0, 2, 1, 1).build(is_enabled); base.clone().setpos(1, 2, 1, 1).build(robot_drive_mode); base.clone().setpos(0, 3, 2, 1).setfill(gridbagconstraints.none).build(new jlabel(\"alliance station\")); base.clone().setpos(0, 4, 1, 1).build(alliance_num); base.clone().setpos(1, 4, 1, 1).build(alliance_color); endr.clone().setpos(0, 5, 1, 1).build(new jlabel(\"team number:\")); base.clone().setpos(1, 5, 1, 1).setanchor(gridbagconstraints.line_start).build(team_number); endr.clone().setpos(0, 6, 1, 1).build(new jlabel(\"game data:\")); base.clone().setpos(1, 6, 1, 1).setanchor(gridbagconstraints.line_start).build(game_data); endr.clone().setpos(0, 7, 1, 1).build(new jlabel(\"protocol year:\")); base.clone().setpos(1, 7, 1, 1).setanchor(gridbagconstraints.line_start).build(protocol_year); base.clone().setpos(2, 2, 2, 1).build(restart_code_btn); base.clone().setpos(2, 3, 2, 1).build(restart_robo_rio_btn); base.clone().setpos(2, 4, 2, 1).build(estop_btn); base.clone().setpos(2, 5, 1, 1).build(js_btn); base.clone().setpos(3, 5, 1, 1).build(stats_btn); base.clone().setpos(2, 6, 1, 1).build(nt_btn); base.clone().setpos(3, 6, 1, 1).build(log_btn); base.clone().setpos(2, 7, 1, 1).build(fms_connect); base.clone().setpos(3, 7, 1, 1).build(usb_connect); base.clone().setpos(4, 2, 2, 1).setfill(gridbagconstraints.none).build(bat_voltage); endr.clone().setpos(4, 3, 1, 1).build(new jlabel(\"robot:\")); base.clone().setpos(5, 3, 1, 1).setanchor(gridbagconstraints.line_start).build(robot_connection_status); endr.clone().setpos(4, 4, 1, 1).build(new jlabel(\"code: \")); base.clone().setpos(5, 4, 1, 1).setanchor(gridbagconstraints.line_start).build(robot_code_status); endr.clone().setpos(4, 5, 1, 1).build(new jlabel(\"estop: \")); base.clone().setpos(5, 5, 1, 1).setanchor(gridbagconstraints.line_start).build(estop_status); endr.clone().setpos(4, 6, 1, 1).build(new jlabel(\"fms: \")); base.clone().setpos(5, 6, 1, 1).setanchor(gridbagconstraints.line_start).build(fms_connection_status); endr.clone().setpos(4, 7, 1, 1).build(new jlabel(\"time: \")); base.clone().setpos(5, 7, 1, 1).setanchor(gridbagconstraints.line_start).build(match_time); }","repo":"Tecbot3158\/open-ds","label":[1,0,0,0]}
{"id":20824,"original_code":"public static String[] getStorageDirectories(boolean includePrimary)\n    {\n        final Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n        \/\/ Final set of paths\n        final Set<String> rv = new HashSet<String>();\n        \/\/ Primary physical SD-CARD (not emulated)\n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n        \/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n        \/\/ Primary emulated SD-CARD\n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if(includePrimary) {\n            if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n                \/\/ Device has physical external storage; use plain paths.\n                if (TextUtils.isEmpty(rawExternalStorage)) {\n                    \/\/ EXTERNAL_STORAGE undefined; falling back to default.\n                    rv.add(\"\/storage\/sdcard0\");\n                } else {\n                    rv.add(rawExternalStorage);\n                }\n            } else {\n                \/\/ Device has emulated storage; external storage paths should have\n                \/\/ userId burned into them.\n                final String rawUserId;\n                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n                    rawUserId = \"\";\n                } else {\n                    final String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\n                    final String[] folders = DIR_SEPARATOR.split(path);\n                    final String lastFolder = folders[folders.length - 1];\n                    boolean isDigit = false;\n                    try {\n                        Integer.valueOf(lastFolder);\n                        isDigit = true;\n                    } catch (NumberFormatException ignored) {\n                    }\n                    rawUserId = isDigit ? lastFolder : \"\";\n                }\n                \/\/ \/storage\/emulated\/0[1,2,...]\n                if (TextUtils.isEmpty(rawUserId)) {\n                    rv.add(rawEmulatedStorageTarget);\n                } else {\n                    rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n                }\n            }\n        }\n        \/\/ Add all secondary storages\n        if(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n        {\n            \/\/ All Secondary SD-CARDs splited into array\n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        return rv.toArray(new String[0]);\n    }","code_wo_comment":"public static String[] getStorageDirectories(boolean includePrimary)\n    {\n        final Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n       \n        final Set<String> rv = new HashSet<String>();\n       \n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n       \n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n       \n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if(includePrimary) {\n            if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n               \n                if (TextUtils.isEmpty(rawExternalStorage)) {\n                   \n                    rv.add(\"\/storage\/sdcard0\");\n                } else {\n                    rv.add(rawExternalStorage);\n                }\n            } else {\n               \n               \n                final String rawUserId;\n                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n                    rawUserId = \"\";\n                } else {\n                    final String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\n                    final String[] folders = DIR_SEPARATOR.split(path);\n                    final String lastFolder = folders[folders.length - 1];\n                    boolean isDigit = false;\n                    try {\n                        Integer.valueOf(lastFolder);\n                        isDigit = true;\n                    } catch (NumberFormatException ignored) {\n                    }\n                    rawUserId = isDigit ? lastFolder : \"\";\n                }\n               \n                if (TextUtils.isEmpty(rawUserId)) {\n                    rv.add(rawEmulatedStorageTarget);\n                } else {\n                    rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n                }\n            }\n        }\n       \n        if(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n        {\n           \n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        return rv.toArray(new String[0]);\n    }","cleancode":"public static string[] getstoragedirectories(boolean includeprimary) { final pattern dir_separator = pattern.compile(\"\/\"); final set<string> rv = new hashset<string>(); final string rawexternalstorage = system.getenv(\"external_storage\"); final string rawsecondarystoragesstr = system.getenv(\"secondary_storage\"); final string rawemulatedstoragetarget = system.getenv(\"emulated_storage_target\"); if(includeprimary) { if (textutils.isempty(rawemulatedstoragetarget)) { if (textutils.isempty(rawexternalstorage)) { rv.add(\"\/storage\/sdcard0\"); } else { rv.add(rawexternalstorage); } } else { final string rawuserid; if (build.version.sdk_int < build.version_codes.jelly_bean_mr1) { rawuserid = \"\"; } else { final string path = android.os.environment.getexternalstoragedirectory().getabsolutepath(); final string[] folders = dir_separator.split(path); final string lastfolder = folders[folders.length - 1]; boolean isdigit = false; try { integer.valueof(lastfolder); isdigit = true; } catch (numberformatexception ignored) { } rawuserid = isdigit ? lastfolder : \"\"; } if (textutils.isempty(rawuserid)) { rv.add(rawemulatedstoragetarget); } else { rv.add(rawemulatedstoragetarget + file.separator + rawuserid); } } } if(!textutils.isempty(rawsecondarystoragesstr)) { final string[] rawsecondarystorages = rawsecondarystoragesstr.split(file.pathseparator); collections.addall(rv, rawsecondarystorages); } return rv.toarray(new string[0]); }","repo":"acestream\/acestream-android-sdk","label":[0,0,0,1]}
{"id":20869,"original_code":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\n        HttpEntity<Object> entity = new HttpEntity<>(args, headers);\n        ResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            System.out.println(response.getBody());\n        } else {\n            System.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n        }\n    }","code_wo_comment":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\n        HttpEntity<Object> entity = new HttpEntity<>(args, headers);\n        ResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            System.out.println(response.getBody());\n        } else {\n            System.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n        }\n    }","cleancode":"private void execute(object args, string url, httpheaders headers, httpmethod method) { httpentity<object> entity = new httpentity<>(args, headers); responseentity<object> response = resttemplate.exchange(url, method, entity, object.class); if (response.getstatuscode().is2xxsuccessful()) { system.out.println(response.getbody()); } else { system.out.println(\"error! \" + response.getstatuscode().name() + \": \" + response.getbody()); } }","repo":"TONY-All\/Hangar","label":[0,0,1,0]}
{"id":20888,"original_code":"private static void LoadSpriteTables()\n\t{\n\t\t\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\t\t\/\/final FileList files = files_win;\n\t\tfinal String[] files = files_win;\n\t\tint load_index;\n\t\tint i;\n\t\t\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\n\t\tLoadGrfIndexed(files[0], trg1idx, 0);\n\t\tSpriteCache.DupSprite(  2, 130); \/\/ non-breaking space medium\n\t\tSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\n\t\tSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\n\t\tload_index = 4793;\n\t\t\/\/ TODO why start from 1?\n\t\t\/\/for (i = 1; files.basic[i].filename != null; i++) {\n\t\tfor (i = 1; files[i] != null; i++) {\n\t\t\tload_index += LoadGrfFile(files[i], load_index, i);\n\t\t}\n\t\tif (_sprite_page_to_load != 0) {\n\t\t\tLoadGrfIndexed(\n\t\t\t\t\tfiles_landscape[_sprite_page_to_load - 1],\n\t\t\t\t\t\/\/files.landscape[_sprite_page_to_load - 1].filename,\n\t\t\t\t\t_landscape_spriteindexes[_sprite_page_to_load - 1],\n\t\t\t\t\ti++\n\t\t\t\t\t);\n\t\t}\n\t\tassert(load_index == Sprites.SPR_CANALS_BASE);\n\t\tload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_SLOPES_BASE);\n\t\t\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\n\t\tLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\n\t\tload_index = Sprites.SPR_AUTORAIL_BASE;\n\t\tload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_OPENTTD_BASE);\n\t\tLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\n\t\tload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\t\t\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason. \n\t\t\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\t\t\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\t\t\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\t\t\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\t\t\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\t\t\/\/ TODO make deep copy??\n\t\t\/\/Global._engine_info =  EngineTables2.orig_engine_info;\n\t\t\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_engine_info, 0, \n\t\t\t\tGlobal._engine_info, 0, Global._engine_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_rail_vehicle_info , 0, \n\t\t\t\tGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_ship_vehicle_info, 0, \n\t\t\t\tGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_aircraft_vehicle_info, 0, \n\t\t\t\tGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_road_vehicle_info, 0, \n\t\t\t\tGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\n\t\tBridge.loadOrigBridges();\n\t\t\/\/ Unload sprite group data\n\t\tEngine.UnloadWagonOverrides();\n\t\tEngine.UnloadCustomEngineSprites();\n\t\tEngine.UnloadCustomEngineNames();\n\t\t\/\/ Reset price base data\n\t\tEconomy.ResetPriceBaseMultipliers();\n\t\t\/\/ TODO was called from LoadNewGRF \n\t\tGRFFile.ResetNewGRFData();\n\t\tGRFFile.LoadNewGRF(load_index, i);\n\t}","code_wo_comment":"private static void LoadSpriteTables()\n\t{\n\t\n\t\n\t\tfinal String[] files = files_win;\n\t\tint load_index;\n\t\tint i;\n\t\n\t\tLoadGrfIndexed(files[0], trg1idx, 0);\n\t\tSpriteCache.DupSprite(  2, 130);\n\t\tSpriteCache.DupSprite(226, 354);\n\t\tSpriteCache.DupSprite(450, 578);\n\t\tload_index = 4793;\n\t\n\t\n\t\tfor (i = 1; files[i] != null; i++) {\n\t\t\tload_index += LoadGrfFile(files[i], load_index, i);\n\t\t}\n\t\tif (_sprite_page_to_load != 0) {\n\t\t\tLoadGrfIndexed(\n\t\t\t\t\tfiles_landscape[_sprite_page_to_load - 1],\n\t\t\t\t\n\t\t\t\t\t_landscape_spriteindexes[_sprite_page_to_load - 1],\n\t\t\t\t\ti++\n\t\t\t\t\t);\n\t\t}\n\t\tassert(load_index == Sprites.SPR_CANALS_BASE);\n\t\tload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_SLOPES_BASE);\n\t\n\t\tLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\n\t\tload_index = Sprites.SPR_AUTORAIL_BASE;\n\t\tload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_OPENTTD_BASE);\n\t\tLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\n\t\tload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_engine_info, 0, \n\t\t\t\tGlobal._engine_info, 0, Global._engine_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_rail_vehicle_info , 0, \n\t\t\t\tGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_ship_vehicle_info, 0, \n\t\t\t\tGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_aircraft_vehicle_info, 0, \n\t\t\t\tGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_road_vehicle_info, 0, \n\t\t\t\tGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\n\t\tBridge.loadOrigBridges();\n\t\n\t\tEngine.UnloadWagonOverrides();\n\t\tEngine.UnloadCustomEngineSprites();\n\t\tEngine.UnloadCustomEngineNames();\n\t\n\t\tEconomy.ResetPriceBaseMultipliers();\n\t\n\t\tGRFFile.ResetNewGRFData();\n\t\tGRFFile.LoadNewGRF(load_index, i);\n\t}","cleancode":"private static void loadspritetables() { final string[] files = files_win; int load_index; int i; loadgrfindexed(files[0], trg1idx, 0); spritecache.dupsprite( 2, 130); spritecache.dupsprite(226, 354); spritecache.dupsprite(450, 578); load_index = 4793; for (i = 1; files[i] != null; i++) { load_index += loadgrffile(files[i], load_index, i); } if (_sprite_page_to_load != 0) { loadgrfindexed( files_landscape[_sprite_page_to_load - 1], _landscape_spriteindexes[_sprite_page_to_load - 1], i++ ); } assert(load_index == sprites.spr_canals_base); load_index += loadgrffile(\"canalsw.grf\", load_index, i++); assert(load_index == sprites.spr_slopes_base); loadgrfindexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++); load_index = sprites.spr_autorail_base; load_index += loadgrffile(\"autorail.grf\", load_index, i++); assert(load_index == sprites.spr_openttd_base); loadgrfindexed(\"openttd.grf\", _openttd_grf_indexes, i++); load_index = sprites.spr_openttd_base + openttd_sprites_count; system.arraycopy( enginetables2.orig_engine_info, 0, global._engine_info, 0, global._engine_info.length ); system.arraycopy( enginetables2.orig_rail_vehicle_info , 0, global._rail_vehicle_info, 0, global._rail_vehicle_info.length ); system.arraycopy( enginetables2.orig_ship_vehicle_info, 0, global._ship_vehicle_info, 0, global._ship_vehicle_info.length ); system.arraycopy( enginetables2.orig_aircraft_vehicle_info, 0, global._aircraft_vehicle_info, 0, global._aircraft_vehicle_info.length ); system.arraycopy( enginetables2.orig_road_vehicle_info, 0, global._road_vehicle_info, 0, global._road_vehicle_info.length ); bridge.loadorigbridges(); engine.unloadwagonoverrides(); engine.unloadcustomenginesprites(); engine.unloadcustomenginenames(); economy.resetpricebasemultipliers(); grffile.resetnewgrfdata(); grffile.loadnewgrf(load_index, i); }","repo":"alexey-lukyanenko\/jdrive","label":[1,1,0,0]}
{"id":13084,"original_code":"@Override\n    public void addContentView(View view) {\n        \/\/todo add you childView to rootView , Usually not youself  layout the View!\n        addView(view);\n    }","code_wo_comment":"@Override\n    public void addContentView(View view) {\n       \n        addView(view);\n    }","cleancode":"@override public void addcontentview(view view) { addview(view); }","repo":"Tamicer\/FilterBar","label":[0,1,0,0]}
{"id":13100,"original_code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n            \/\/ todo change the file location\/name according to your needs\n            File futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[4096];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        Log.d(\"writeResponseBodyToDisk\", \"file download: \" + fileSizeDownloaded + \" of \" + fileSize);\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","code_wo_comment":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n           \n            File futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[4096];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        Log.d(\"writeResponseBodyToDisk\", \"file download: \" + fileSizeDownloaded + \" of \" + fileSize);\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","cleancode":"private boolean writeresponsebodytodisk(responsebody body) { try { file futurestudioiconfile = new file(getexternalfilesdir(null) + file.separator + nombreeditar + \".jpg\"); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[4096]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { log.d(\"writeresponsebodytodisk\", \"file download: \" + filesizedownloaded + \" of \" + filesize); break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) { return false; } finally { if (inputstream != null) { inputstream.close(); } if (outputstream != null) { outputstream.close(); } } } catch (ioexception e) { return false; } }","repo":"UNIZAR-30226-2021-14\/Front-end","label":[1,0,0,0]}
{"id":13511,"original_code":"@Override\n    public GraphStageLogic createLogic(Attributes attr) throws Exception {\n        JsonParser parser = new JsonParser();\n        return new GraphStageLogic(shape) {\n            {\n                setHandler(out, new AbstractOutHandler() {\n                    @Override\n                    public void onPull() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                });\n                setHandler(in, new AbstractInHandler() {\n                    @Override\n                    public void onPush() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        ByteString bytes = grab(in);\n                        \/\/ TODO either PR ByteBuffer support into actson, or sneaky-access the underlying byte array fields here\n                        for (ByteBuffer b: bytes.getByteBuffers()) {\n                            byte[] buf= new byte[b.remaining()];\n                            b.get(buf, 0, b.remaining());\n                            int i = 0;\n                            while (i < buf.length) {\n                              i += parser.getFeeder().feed(buf, i, buf.length - i);\n                              parseInto(events);\n                            }\n                        }\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                    public void onUpstreamFinish() throws Exception {\n                        parser.getFeeder().done();\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        emitMultiple(out, events.iterator());\n                        complete(out);\n                    }\n                });\n            }\n            private void parseInto(List<JSONEvent> events) {\n                Option<JSONEvent> evt = next();\n                while (evt.isDefined()) {\n                    events.add(evt.get());\n                    evt = next();\n                }\n            };\n            private Option<JSONEvent> next() {\n                switch(parser.nextEvent()) {\n                case JsonEvent.END_ARRAY: return some(JSONEvent.END_ARRAY);\n                case JsonEvent.END_OBJECT: return some(JSONEvent.END_OBJECT);\n                case JsonEvent.ERROR: throw new IllegalArgumentException(\"There was a parse error at around character \" + parser.getParsedCharacterCount());\n                case JsonEvent.EOF: return none();\n                case JsonEvent.FIELD_NAME: return some(new JSONEvent.FieldName(parser.getCurrentString()));\n                case JsonEvent.NEED_MORE_INPUT: return none();\n                case JsonEvent.START_ARRAY: return some(JSONEvent.START_ARRAY);\n                case JsonEvent.START_OBJECT: return some(JSONEvent.START_OBJECT);\n                case JsonEvent.VALUE_DOUBLE: return some(new JSONEvent.NumericValue(String.valueOf(parser.getCurrentDouble())));\n                case JsonEvent.VALUE_FALSE: return some(JSONEvent.FALSE);\n                case JsonEvent.VALUE_INT: return some(new JSONEvent.NumericValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_NULL: return some(JSONEvent.NULL);\n                case JsonEvent.VALUE_STRING: return some(new JSONEvent.StringValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_TRUE: return some(JSONEvent.TRUE);\n                default: throw new UnsupportedOperationException(\"Unexpected event in JSON parser\");\n                }\n            }\n        };\n    }","code_wo_comment":"@Override\n    public GraphStageLogic createLogic(Attributes attr) throws Exception {\n        JsonParser parser = new JsonParser();\n        return new GraphStageLogic(shape) {\n            {\n                setHandler(out, new AbstractOutHandler() {\n                    @Override\n                    public void onPull() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                });\n                setHandler(in, new AbstractInHandler() {\n                    @Override\n                    public void onPush() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        ByteString bytes = grab(in);\n                       \n                        for (ByteBuffer b: bytes.getByteBuffers()) {\n                            byte[] buf= new byte[b.remaining()];\n                            b.get(buf, 0, b.remaining());\n                            int i = 0;\n                            while (i < buf.length) {\n                              i += parser.getFeeder().feed(buf, i, buf.length - i);\n                              parseInto(events);\n                            }\n                        }\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                    public void onUpstreamFinish() throws Exception {\n                        parser.getFeeder().done();\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        emitMultiple(out, events.iterator());\n                        complete(out);\n                    }\n                });\n            }\n            private void parseInto(List<JSONEvent> events) {\n                Option<JSONEvent> evt = next();\n                while (evt.isDefined()) {\n                    events.add(evt.get());\n                    evt = next();\n                }\n            };\n            private Option<JSONEvent> next() {\n                switch(parser.nextEvent()) {\n                case JsonEvent.END_ARRAY: return some(JSONEvent.END_ARRAY);\n                case JsonEvent.END_OBJECT: return some(JSONEvent.END_OBJECT);\n                case JsonEvent.ERROR: throw new IllegalArgumentException(\"There was a parse error at around character \" + parser.getParsedCharacterCount());\n                case JsonEvent.EOF: return none();\n                case JsonEvent.FIELD_NAME: return some(new JSONEvent.FieldName(parser.getCurrentString()));\n                case JsonEvent.NEED_MORE_INPUT: return none();\n                case JsonEvent.START_ARRAY: return some(JSONEvent.START_ARRAY);\n                case JsonEvent.START_OBJECT: return some(JSONEvent.START_OBJECT);\n                case JsonEvent.VALUE_DOUBLE: return some(new JSONEvent.NumericValue(String.valueOf(parser.getCurrentDouble())));\n                case JsonEvent.VALUE_FALSE: return some(JSONEvent.FALSE);\n                case JsonEvent.VALUE_INT: return some(new JSONEvent.NumericValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_NULL: return some(JSONEvent.NULL);\n                case JsonEvent.VALUE_STRING: return some(new JSONEvent.StringValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_TRUE: return some(JSONEvent.TRUE);\n                default: throw new UnsupportedOperationException(\"Unexpected event in JSON parser\");\n                }\n            }\n        };\n    }","cleancode":"@override public graphstagelogic createlogic(attributes attr) throws exception { jsonparser parser = new jsonparser(); return new graphstagelogic(shape) { { sethandler(out, new abstractouthandler() { @override public void onpull() throws exception { list<jsonevent> events = new arraylist<>(); parseinto(events); if (events.isempty()) { pull(in); } else { emitmultiple(out, events.iterator()); } } }); sethandler(in, new abstractinhandler() { @override public void onpush() throws exception { list<jsonevent> events = new arraylist<>(); bytestring bytes = grab(in); for (bytebuffer b: bytes.getbytebuffers()) { byte[] buf= new byte[b.remaining()]; b.get(buf, 0, b.remaining()); int i = 0; while (i < buf.length) { i += parser.getfeeder().feed(buf, i, buf.length - i); parseinto(events); } } if (events.isempty()) { pull(in); } else { emitmultiple(out, events.iterator()); } } public void onupstreamfinish() throws exception { parser.getfeeder().done(); list<jsonevent> events = new arraylist<>(); parseinto(events); emitmultiple(out, events.iterator()); complete(out); } }); } private void parseinto(list<jsonevent> events) { option<jsonevent> evt = next(); while (evt.isdefined()) { events.add(evt.get()); evt = next(); } }; private option<jsonevent> next() { switch(parser.nextevent()) { case jsonevent.end_array: return some(jsonevent.end_array); case jsonevent.end_object: return some(jsonevent.end_object); case jsonevent.error: throw new illegalargumentexception(\"there was a parse error at around character \" + parser.getparsedcharactercount()); case jsonevent.eof: return none(); case jsonevent.field_name: return some(new jsonevent.fieldname(parser.getcurrentstring())); case jsonevent.need_more_input: return none(); case jsonevent.start_array: return some(jsonevent.start_array); case jsonevent.start_object: return some(jsonevent.start_object); case jsonevent.value_double: return some(new jsonevent.numericvalue(string.valueof(parser.getcurrentdouble()))); case jsonevent.value_false: return some(jsonevent.false); case jsonevent.value_int: return some(new jsonevent.numericvalue(parser.getcurrentstring())); case jsonevent.value_null: return some(jsonevent.null); case jsonevent.value_string: return some(new jsonevent.stringvalue(parser.getcurrentstring())); case jsonevent.value_true: return some(jsonevent.true); default: throw new unsupportedoperationexception(\"unexpected event in json parser\"); } } }; }","repo":"alar17\/ts-reaktive","label":[1,0,0,0]}
{"id":13714,"original_code":"private void annotateInferredType(Tree tree, AnnotatedTypeMirror type) {\n        switch (tree.getKind()) {\n        case NEW_ARRAY:\n        case NEW_CLASS:\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(tree), type);\n            break;\n        case METHOD:\n            ExecutableElement methodElt = TreeUtils.elementFromDeclaration(\n                    (MethodTree) tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(methodElt), type);\n            break;\n        case TYPE_CAST:\n            if (!checker.isAnnotated(type)) {\n                Tree t = tree;\n                while (t.getKind() == Kind.TYPE_CAST) {\n                    t = ((TypeCastTree) t).getExpression();\n                    if (t instanceof ExpressionTree)\n                        t = TreeUtils.skipParens((ExpressionTree) t);\n                }\n                AnnotatedTypeMirror castType = getAnnotatedType(t);\n                InferenceUtils.assignAnnotations(type, castType);\n            }\n            break;\n        case METHOD_INVOCATION:\n            if (type.getKind() != TypeKind.VOID) {\n                MethodInvocationTree miTree = (MethodInvocationTree) tree;\n                ExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\n                ExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\n                if (ElementUtils.isStatic(iMethodElt)) {\n\/\/                    System.out.println(\"WARN: be supported in SFlowVisitor\");\n                } else {\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    AnnotatedTypeMirror rcvType = null;\n                    if (rcvTree != null) {\n                        \/\/ like x = y.m(z);\n                        rcvType = getAnnotatedType(rcvTree); \n                    } else if (currentMethod != null) {\n                        rcvType = getAnnotatedType(currentMethod).getReceiverType();\n                    }\n                    if (rcvType != null) {\n                        \/\/ Do viewpoint adaptation\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(\n                            rcvType.getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n                    }\n                }\n            }\n            break;\n        case VARIABLE:\n            \/\/ TODO: Consider using viewpoint adaptation\n            VariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n            \/\/ If there is an initialization for field, we need adapt it from \n            \/\/ ClassTree type\n            if (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\n                ClassTree classTree = this.getVisitorState().getClassTree();\n                TypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\n                AnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\n                InferenceMain.getInstance().getCurrentExtractor()\n                    .annotateInferredType(getIdentifier(classElt), defConstructorType);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n                        .getAnnotations(), type.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            }\n            break;\n        case IDENTIFIER:\n            Element idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n            \/\/ We don't want to annotate CLASS type\n            if (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\n                InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n                \/\/ May need viewpoint adaptation if it is a field\n\t\t\t\tif (idElt.getKind() == ElementKind.FIELD) {\n\t\t\t\t\t\/\/ We need to adapt it from PoV of THIS\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    if (currentMethod != null) {\n\t\t\t\t\t\tAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n\t\t\t\t\t\t\t\t.getReceiverType().getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\/\/ This happen in the static initializer \n                        \/\/ ignore\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n            break;\n        case ARRAY_ACCESS:\n            \/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2. \n            ArrayAccessTree aTree = (ArrayAccessTree) tree;\n            ExpressionTree aExpr = aTree.getExpression();\n            AnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\n            assert aExprType.getKind() == TypeKind.ARRAY;\n            Set<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n                    .getComponentType().getAnnotations();\n            Set<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\n                    aExprType.getAnnotations(), componentAnnos);\n            if (!adaptedAnnos.isEmpty()) {\n                type.clearAnnotations();\n                type.addAnnotations(adaptedAnnos);\n            }\n            break;\t\n        case MEMBER_SELECT:\n            \/\/ WEI: added on Aug 2\n            \/\/ WEI: Remove the above line, also considering remove the \n            \/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\n            MemberSelectTree mTree = (MemberSelectTree) tree;\n            Element fieldElt = TreeUtils.elementFromUse(mTree);\n            if (checker.isAccessOuterThis(mTree)) {\n                \/\/ If it is like Body.this\n                \/\/ FIXME:\n                MethodTree methodTree = this.getVisitorState().getMethodTree();\n                if (methodTree != null) {\n                    ExecutableElement currentMethodElt = TreeUtils\n                            .elementFromDeclaration(methodTree);\n                    Element outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\n                    Reference inferredRef = null;\n                    if (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n                    } else {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n                    }\n                    if (inferredRef != null)\n                        InferenceUtils.annotateReferenceType(type, \n                                ((ExecutableReference) inferredRef).getReceiverRef());\n                    else\n                        System.err.println(\"WARN: Cannot annotate \" + mTree);\n                }\n            } else if (!fieldElt.getSimpleName().contentEquals(\"super\")\n                    && fieldElt.getKind() == ElementKind.FIELD\n                    && !ElementUtils.isStatic(fieldElt)\n                    && checker.isAnnotated(type)\n                    ) {\n                \/\/ Do viewpoint adaptation\n                ExpressionTree expr = mTree.getExpression();\n                AnnotatedTypeMirror exprType = getAnnotatedType(expr);\n                AnnotatedTypeMirror fieldType = getAnnotatedType(fieldElt);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(\n                        exprType.getAnnotations(),\n                        fieldType.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            } else if (!checker.isAnnotated(type) \n                    && fieldElt.getSimpleName().contentEquals(\"class\"))\n                type.addAnnotation(checker.BOTTOM);\n            break;\n        default: \n            if(!checker.isAnnotated(type)) {\n                if (tree instanceof UnaryTree) {\n                    AnnotatedTypeMirror aType = getAnnotatedType(\n                            ((UnaryTree) tree).getExpression());\n                    InferenceUtils.assignAnnotations(type, aType);\n                } else if (tree instanceof BinaryTree && !checker.isAnnotated(type)) {\n                    ExpressionTree left = ((BinaryTree)tree).getLeftOperand();\n                    ExpressionTree right = ((BinaryTree)tree).getRightOperand();\n                    AnnotatedTypeMirror leftType = getAnnotatedType(left);\n                    AnnotatedTypeMirror rightType = getAnnotatedType(right);\n                    Set<AnnotationMirror> leftSet = leftType.getAnnotations();\n                    Set<AnnotationMirror> rightSet = rightType.getAnnotations();\n                    Set<AnnotationMirror> set = qualHierarchy.leastUpperBound(leftSet, rightSet);\n                    type.addAnnotations(set);\n                }\n            }\n        }\n    }","code_wo_comment":"private void annotateInferredType(Tree tree, AnnotatedTypeMirror type) {\n        switch (tree.getKind()) {\n        case NEW_ARRAY:\n        case NEW_CLASS:\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(tree), type);\n            break;\n        case METHOD:\n            ExecutableElement methodElt = TreeUtils.elementFromDeclaration(\n                    (MethodTree) tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(methodElt), type);\n            break;\n        case TYPE_CAST:\n            if (!checker.isAnnotated(type)) {\n                Tree t = tree;\n                while (t.getKind() == Kind.TYPE_CAST) {\n                    t = ((TypeCastTree) t).getExpression();\n                    if (t instanceof ExpressionTree)\n                        t = TreeUtils.skipParens((ExpressionTree) t);\n                }\n                AnnotatedTypeMirror castType = getAnnotatedType(t);\n                InferenceUtils.assignAnnotations(type, castType);\n            }\n            break;\n        case METHOD_INVOCATION:\n            if (type.getKind() != TypeKind.VOID) {\n                MethodInvocationTree miTree = (MethodInvocationTree) tree;\n                ExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\n                ExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\n                if (ElementUtils.isStatic(iMethodElt)) {\n                } else {\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    AnnotatedTypeMirror rcvType = null;\n                    if (rcvTree != null) {\n                       \n                        rcvType = getAnnotatedType(rcvTree); \n                    } else if (currentMethod != null) {\n                        rcvType = getAnnotatedType(currentMethod).getReceiverType();\n                    }\n                    if (rcvType != null) {\n                       \n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(\n                            rcvType.getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n                    }\n                }\n            }\n            break;\n        case VARIABLE:\n           \n            VariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n           \n           \n            if (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\n                ClassTree classTree = this.getVisitorState().getClassTree();\n                TypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\n                AnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\n                InferenceMain.getInstance().getCurrentExtractor()\n                    .annotateInferredType(getIdentifier(classElt), defConstructorType);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n                        .getAnnotations(), type.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            }\n            break;\n        case IDENTIFIER:\n            Element idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n           \n            if (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\n                InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n               \n\t\t\t\tif (idElt.getKind() == ElementKind.FIELD) {\n\t\t\t\t\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    if (currentMethod != null) {\n\t\t\t\t\t\tAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n\t\t\t\t\t\t\t\t.getReceiverType().getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\n                       \n\t\t\t\t\t}\n\t\t\t\t}\n            }\n            break;\n        case ARRAY_ACCESS:\n           \n            ArrayAccessTree aTree = (ArrayAccessTree) tree;\n            ExpressionTree aExpr = aTree.getExpression();\n            AnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\n            assert aExprType.getKind() == TypeKind.ARRAY;\n            Set<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n                    .getComponentType().getAnnotations();\n            Set<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\n                    aExprType.getAnnotations(), componentAnnos);\n            if (!adaptedAnnos.isEmpty()) {\n                type.clearAnnotations();\n                type.addAnnotations(adaptedAnnos);\n            }\n            break;\t\n        case MEMBER_SELECT:\n           \n           \n           \n            MemberSelectTree mTree = (MemberSelectTree) tree;\n            Element fieldElt = TreeUtils.elementFromUse(mTree);\n            if (checker.isAccessOuterThis(mTree)) {\n               \n               \n                MethodTree methodTree = this.getVisitorState().getMethodTree();\n                if (methodTree != null) {\n                    ExecutableElement currentMethodElt = TreeUtils\n                            .elementFromDeclaration(methodTree);\n                    Element outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\n                    Reference inferredRef = null;\n                    if (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n                    } else {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n                    }\n                    if (inferredRef != null)\n                        InferenceUtils.annotateReferenceType(type, \n                                ((ExecutableReference) inferredRef).getReceiverRef());\n                    else\n                        System.err.println(\"WARN: Cannot annotate \" + mTree);\n                }\n            } else if (!fieldElt.getSimpleName().contentEquals(\"super\")\n                    && fieldElt.getKind() == ElementKind.FIELD\n                    && !ElementUtils.isStatic(fieldElt)\n                    && checker.isAnnotated(type)\n                    ) {\n               \n                ExpressionTree expr = mTree.getExpression();\n                AnnotatedTypeMirror exprType = getAnnotatedType(expr);\n                AnnotatedTypeMirror fieldType = getAnnotatedType(fieldElt);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(\n                        exprType.getAnnotations(),\n                        fieldType.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            } else if (!checker.isAnnotated(type) \n                    && fieldElt.getSimpleName().contentEquals(\"class\"))\n                type.addAnnotation(checker.BOTTOM);\n            break;\n        default: \n            if(!checker.isAnnotated(type)) {\n                if (tree instanceof UnaryTree) {\n                    AnnotatedTypeMirror aType = getAnnotatedType(\n                            ((UnaryTree) tree).getExpression());\n                    InferenceUtils.assignAnnotations(type, aType);\n                } else if (tree instanceof BinaryTree && !checker.isAnnotated(type)) {\n                    ExpressionTree left = ((BinaryTree)tree).getLeftOperand();\n                    ExpressionTree right = ((BinaryTree)tree).getRightOperand();\n                    AnnotatedTypeMirror leftType = getAnnotatedType(left);\n                    AnnotatedTypeMirror rightType = getAnnotatedType(right);\n                    Set<AnnotationMirror> leftSet = leftType.getAnnotations();\n                    Set<AnnotationMirror> rightSet = rightType.getAnnotations();\n                    Set<AnnotationMirror> set = qualHierarchy.leastUpperBound(leftSet, rightSet);\n                    type.addAnnotations(set);\n                }\n            }\n        }\n    }","cleancode":"private void annotateinferredtype(tree tree, annotatedtypemirror type) { switch (tree.getkind()) { case new_array: case new_class: inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(tree), type); break; case method: executableelement methodelt = treeutils.elementfromdeclaration( (methodtree) tree); inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(methodelt), type); break; case type_cast: if (!checker.isannotated(type)) { tree t = tree; while (t.getkind() == kind.type_cast) { t = ((typecasttree) t).getexpression(); if (t instanceof expressiontree) t = treeutils.skipparens((expressiontree) t); } annotatedtypemirror casttype = getannotatedtype(t); inferenceutils.assignannotations(type, casttype); } break; case method_invocation: if (type.getkind() != typekind.void) { methodinvocationtree mitree = (methodinvocationtree) tree; executableelement imethodelt = treeutils.elementfromuse(mitree); expressiontree rcvtree = inferenceutils.getreceivertree(mitree); if (elementutils.isstatic(imethodelt)) { } else { executableelement currentmethod = getcurrentmethodelt(); annotatedtypemirror rcvtype = null; if (rcvtree != null) { rcvtype = getannotatedtype(rcvtree); } else if (currentmethod != null) { rcvtype = getannotatedtype(currentmethod).getreceivertype(); } if (rcvtype != null) { set<annotationmirror> set = checker.adaptfieldset( rcvtype.getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } } } break; case variable: variableelement varelt = treeutils.elementfromdeclaration((variabletree)tree); inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(varelt), type); if (varelt.getkind().isfield() && !elementutils.isstatic(varelt)) { classtree classtree = this.getvisitorstate().getclasstree(); typeelement classelt = treeutils.elementfromdeclaration(classtree); annotateddeclaredtype defconstructortype = getannotatedtype(classelt); inferencemain.getinstance().getcurrentextractor() .annotateinferredtype(getidentifier(classelt), defconstructortype); set<annotationmirror> set = checker.adaptfieldset(defconstructortype .getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } break; case identifier: element idelt = treeutils.elementfromuse((identifiertree) tree); if (idelt.getkind() != elementkind.class && idelt.getkind() != elementkind.interface) { inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(idelt), type); if (idelt.getkind() == elementkind.field) { executableelement currentmethod = getcurrentmethodelt(); if (currentmethod != null) { annotatedexecutabletype methodtype = getannotatedtype(currentmethod); set<annotationmirror> set = checker.adaptfieldset(methodtype .getreceivertype().getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } else { } } } break; case array_access: arrayaccesstree atree = (arrayaccesstree) tree; expressiontree aexpr = atree.getexpression(); annotatedtypemirror aexprtype = getannotatedtype(aexpr); assert aexprtype.getkind() == typekind.array; set<annotationmirror> componentannos = ((annotatedarraytype) aexprtype) .getcomponenttype().getannotations(); set<annotationmirror> adaptedannos = checker.adaptfieldset( aexprtype.getannotations(), componentannos); if (!adaptedannos.isempty()) { type.clearannotations(); type.addannotations(adaptedannos); } break; case member_select: memberselecttree mtree = (memberselecttree) tree; element fieldelt = treeutils.elementfromuse(mtree); if (checker.isaccessouterthis(mtree)) { methodtree methodtree = this.getvisitorstate().getmethodtree(); if (methodtree != null) { executableelement currentmethodelt = treeutils .elementfromdeclaration(methodtree); element outerelt = checker.getouterthiselement(mtree, currentmethodelt); reference inferredref = null; if (outerelt != null && outerelt.getkind() == elementkind.method) { inferredref = inferencemain.getinstance().getcurrentextractor().getinferredreference(getidentifier(outerelt)); } else { inferredref = inferencemain.getinstance().getcurrentextractor().getinferredreference(getidentifier(currentmethodelt)); } if (inferredref != null) inferenceutils.annotatereferencetype(type, ((executablereference) inferredref).getreceiverref()); else system.err.println(\"warn: cannot annotate \" + mtree); } } else if (!fieldelt.getsimplename().contentequals(\"super\") && fieldelt.getkind() == elementkind.field && !elementutils.isstatic(fieldelt) && checker.isannotated(type) ) { expressiontree expr = mtree.getexpression(); annotatedtypemirror exprtype = getannotatedtype(expr); annotatedtypemirror fieldtype = getannotatedtype(fieldelt); set<annotationmirror> set = checker.adaptfieldset( exprtype.getannotations(), fieldtype.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } else if (!checker.isannotated(type) && fieldelt.getsimplename().contentequals(\"class\")) type.addannotation(checker.bottom); break; default: if(!checker.isannotated(type)) { if (tree instanceof unarytree) { annotatedtypemirror atype = getannotatedtype( ((unarytree) tree).getexpression()); inferenceutils.assignannotations(type, atype); } else if (tree instanceof binarytree && !checker.isannotated(type)) { expressiontree left = ((binarytree)tree).getleftoperand(); expressiontree right = ((binarytree)tree).getrightoperand(); annotatedtypemirror lefttype = getannotatedtype(left); annotatedtypemirror righttype = getannotatedtype(right); set<annotationmirror> leftset = lefttype.getannotations(); set<annotationmirror> rightset = righttype.getannotations(); set<annotationmirror> set = qualhierarchy.leastupperbound(leftset, rightset); type.addannotations(set); } } } }","repo":"SoftwareEngineeringToolDemos\/type-inference","label":[1,0,1,0]}
{"id":13884,"original_code":"private boolean isPasswordValid(String password) {\n        \/\/TODO: Replace this with your own logic\n        return password.length() > 5;\n    }","code_wo_comment":"private boolean isPasswordValid(String password) {\n       \n        return password.length() > 5;\n    }","cleancode":"private boolean ispasswordvalid(string password) { return password.length() > 5; }","repo":"ShivamPokhriyal\/Custom-UI-Sample","label":[1,0,0,0]}
{"id":30271,"original_code":"private List<String> commonLinkAndCompileFlagsForClang(\n      ObjcProvider provider, ObjcConfiguration objcConfiguration,\n      AppleConfiguration appleConfiguration) {\n    ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    Platform platform = appleConfiguration.getSingleArchPlatform();\n    switch (platform) {\n      case IOS_SIMULATOR:\n        builder.add(\"-mios-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case IOS_DEVICE:\n        builder.add(\"-miphoneos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case WATCHOS_SIMULATOR:\n        \/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n        \/\/ version.\n        builder.add(\"-mwatchos-simulator-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case WATCHOS_DEVICE:\n        \/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n        \/\/ version.\n        builder.add(\"-mwatchos-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case TVOS_SIMULATOR:\n        builder.add(\"-mtvos-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case TVOS_DEVICE:\n        builder.add(\"-mtvos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unhandled platform \" + platform);\n    }\n    if (objcConfiguration.generateDsym()) {\n      builder.add(\"-g\");\n    }\n    return builder\n        .add(\"-arch\", appleConfiguration.getSingleArchitecture())\n        .add(\"-isysroot\", AppleToolchain.sdkDir())\n        \/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n        .addAll(commonFrameworkFlags(provider, appleConfiguration))\n        .build();\n  }","code_wo_comment":"private List<String> commonLinkAndCompileFlagsForClang(\n      ObjcProvider provider, ObjcConfiguration objcConfiguration,\n      AppleConfiguration appleConfiguration) {\n    ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    Platform platform = appleConfiguration.getSingleArchPlatform();\n    switch (platform) {\n      case IOS_SIMULATOR:\n        builder.add(\"-mios-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case IOS_DEVICE:\n        builder.add(\"-miphoneos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case WATCHOS_SIMULATOR:\n       \n       \n        builder.add(\"-mwatchos-simulator-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case WATCHOS_DEVICE:\n       \n       \n        builder.add(\"-mwatchos-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case TVOS_SIMULATOR:\n        builder.add(\"-mtvos-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case TVOS_DEVICE:\n        builder.add(\"-mtvos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unhandled platform \" + platform);\n    }\n    if (objcConfiguration.generateDsym()) {\n      builder.add(\"-g\");\n    }\n    return builder\n        .add(\"-arch\", appleConfiguration.getSingleArchitecture())\n        .add(\"-isysroot\", AppleToolchain.sdkDir())\n       \n        .addAll(commonFrameworkFlags(provider, appleConfiguration))\n        .build();\n  }","cleancode":"private list<string> commonlinkandcompileflagsforclang( objcprovider provider, objcconfiguration objcconfiguration, appleconfiguration appleconfiguration) { immutablelist.builder<string> builder = new immutablelist.builder<>(); platform platform = appleconfiguration.getsinglearchplatform(); switch (platform) { case ios_simulator: builder.add(\"-mios-simulator-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case ios_device: builder.add(\"-miphoneos-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case watchos_simulator: builder.add(\"-mwatchos-simulator-version-min=\" + appleconfiguration.getsdkversionforplatform(platform)); break; case watchos_device: builder.add(\"-mwatchos-version-min=\" + appleconfiguration.getsdkversionforplatform(platform)); break; case tvos_simulator: builder.add(\"-mtvos-simulator-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case tvos_device: builder.add(\"-mtvos-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; default: throw new illegalargumentexception(\"unhandled platform \" + platform); } if (objcconfiguration.generatedsym()) { builder.add(\"-g\"); } return builder .add(\"-arch\", appleconfiguration.getsinglearchitecture()) .add(\"-isysroot\", appletoolchain.sdkdir()) .addall(commonframeworkflags(provider, appleconfiguration)) .build(); }","repo":"Tingbopku\/tingbo1","label":[1,1,0,0]}
{"id":22098,"original_code":"@Override\n        public void onClick(DialogInterface dialog, int which) {\n            \/\/ User clicked OK button\n            int[] inputs = new int[playerManager.getSelectedPlayerCount()];\n            \/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\n            for (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\n                int index = getPlayerIndex(i);\n                EditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n                \/\/verify input\n                int input;\n                try {\n                    input = Integer.parseInt(editText.getText().toString());\n                } catch (NumberFormatException nfe) {\n                    Toast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                inputs[index] = input;\n            }\n            \/\/validate results\n            int totalValue = 0;\n            for (int value : inputs) {\n                if (value < 0) {\n                    Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                totalValue += value;\n            }\n            if (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\n                Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\n                toast.show();\n                return;\n            }\n            \/\/save results\n            \/\/todo: save playerID with input field for better code quality\n            Map<Long, Integer> inputMap = new HashMap<>();\n            for (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\n                inputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n            }\n            \/\/if this entry is score, update views && activate next round\n            if (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\n                gameScoreManager.enterScores(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                headerManager.updateScores();\n                rowManager.updateScores();\n                changeButtonVisibility(ButtonVisible.NONE);\n                if (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\n                    nextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n                }\n            } else {\n                gameScoreManager.enterPredictions(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                rowManager.updatePredictions();\n                changeButtonVisibility(ButtonVisible.SCORE);\n            }\n            \/\/change buttons\n            changeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n        }","code_wo_comment":"@Override\n        public void onClick(DialogInterface dialog, int which) {\n           \n            int[] inputs = new int[playerManager.getSelectedPlayerCount()];\n           \n            for (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\n                int index = getPlayerIndex(i);\n                EditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n               \n                int input;\n                try {\n                    input = Integer.parseInt(editText.getText().toString());\n                } catch (NumberFormatException nfe) {\n                    Toast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                inputs[index] = input;\n            }\n           \n            int totalValue = 0;\n            for (int value : inputs) {\n                if (value < 0) {\n                    Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                totalValue += value;\n            }\n            if (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\n                Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\n                toast.show();\n                return;\n            }\n           \n           \n            Map<Long, Integer> inputMap = new HashMap<>();\n            for (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\n                inputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n            }\n           \n            if (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\n                gameScoreManager.enterScores(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                headerManager.updateScores();\n                rowManager.updateScores();\n                changeButtonVisibility(ButtonVisible.NONE);\n                if (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\n                    nextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n                }\n            } else {\n                gameScoreManager.enterPredictions(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                rowManager.updatePredictions();\n                changeButtonVisibility(ButtonVisible.SCORE);\n            }\n           \n            changeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n        }","cleancode":"@override public void onclick(dialoginterface dialog, int which) { int[] inputs = new int[playermanager.getselectedplayercount()]; for (int i = startingplayer; i < playermanager.getselectedplayercount() + startingplayer; i++) { int index = getplayerindex(i); edittext edittext = (edittext) ((linearlayout) linearlayout.getchildat(i - startingplayer)).getchildat(3); int input; try { input = integer.parseint(edittext.gettext().tostring()); } catch (numberformatexception nfe) { toast toast = toast.maketext(context, \"invalid input\", toast.length_short); toast.show(); return; } inputs[index] = input; } int totalvalue = 0; for (int value : inputs) { if (value < 0) { toast toast = toast.maketext(context, context.getresources().getstring(r.string.invalid_number), toast.length_short); toast.show(); return; } totalvalue += value; } if (gamescoremanager.getnextentrytype() == readonlygamescoremanager.entrytype.score && totalvalue != gamescoremanager.getcardcount(gamescoremanager.getround())) { toast toast = toast.maketext(context, context.getresources().getstring(r.string.invalid_score), toast.length_long); toast.show(); return; } map<long, integer> inputmap = new hashmap<>(); for (int i = 0; i < playermanager.getselectedplayercount(); i++) { inputmap.put(playermanager.getselectedplayers()[i], inputs[i]); } if (gamescoremanager.getnextentrytype() == gamescoremanager.entrytype.score) { gamescoremanager.enterscores(inputmap); persistencemanager.getinstance().savegame(gamescoremanager); headermanager.updatescores(); rowmanager.updatescores(); changebuttonvisibility(buttonvisible.none); if (gamescoremanager.getround() != gamescoremanager.getamountofrounds()) { nextround.changebuttonvisibility(buttonvisible.predict); } } else { gamescoremanager.enterpredictions(inputmap); persistencemanager.getinstance().savegame(gamescoremanager); rowmanager.updatepredictions(); changebuttonvisibility(buttonvisible.score); } changebuttonvisibility(gamescoremanager.getnextentrytype() == readonlygamescoremanager.entrytype.score ? buttonvisible.score : buttonvisible.none); }","repo":"ThaChillera\/CardScore","label":[0,1,0,0]}
{"id":22436,"original_code":"@Override\n    public void prepareForSave(KualiDocumentEvent event) {\n        \/\/ TODO Auto-generated method stub\n        \/\/ first populate, then call super\n        if (event instanceof AttributedContinuePurapEvent) {\n            SpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n        }\n        if(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\n            this.setVendorPaymentTermsCode(null);\n        }\n        super.prepareForSave(event);\n        try {\n            if (this.proformaIndicator && !this.immediatePaymentIndicator) {\n                this.setImmediatePaymentIndicator(true);\n            }\n            LOG.debug(\"###########Inside OleInvoiceDocument \" + \"repareForSave###########\");\n            List<OleInvoiceItem> items = new ArrayList<OleInvoiceItem>();\n            items = this.getItems();\n            Iterator iterator = items.iterator();\n            HashMap dataMap = new HashMap();\n            String titleId;\n            while (iterator.hasNext()) {\n                LOG.debug(\"###########inside prepareForSave item loop###########\");\n                Object object = iterator.next();\n                if (object instanceof OleInvoiceItem) {\n                    LOG.debug(\"###########inside prepareForSave ole payment request item###########\");\n                    OleInvoiceItem singleItem = (OleInvoiceItem) object;\n                    if (StringUtils.isNotBlank(this.invoiceCurrencyType)) {\n                        this.setInvoiceCurrencyTypeId(new Long(this.getInvoiceCurrencyType()));\n                        String currencyType = SpringContext.getBean(OleInvoiceService.class).getCurrencyType(this.getInvoiceCurrencyType());\n                        if (StringUtils.isNotBlank(currencyType)) {\n                            if(!currencyType.equalsIgnoreCase(OleSelectConstant.CURRENCY_TYPE_NAME)) {\n                                if (StringUtils.isNotBlank(this.getInvoiceCurrencyExchangeRate())) {\n                                    try {\n                                        Double.parseDouble(this.getInvoiceCurrencyExchangeRate());\n                                        singleItem.setItemExchangeRate(new KualiDecimal(this.getInvoiceCurrencyExchangeRate()));\n                                        singleItem.setExchangeRate(this.getInvoiceCurrencyExchangeRate());\n                                    }\n                                    catch (NumberFormatException nfe) {\n                                        throw new RuntimeException(\"Invalid Exchange Rate\", nfe);\n                                    }\n                                }   else {\n                                    BigDecimal exchangeRate = SpringContext.getBean(OleInvoiceService.class).getExchangeRate(this.getInvoiceCurrencyType()).getExchangeRate();\n                                    this.setInvoiceCurrencyExchangeRate(exchangeRate.toString());\n                                    singleItem.setItemExchangeRate(new KualiDecimal(exchangeRate));\n                                    singleItem.setExchangeRate(exchangeRate.toString());\n                                }\n                                this.setVendorInvoiceAmount(this.getForeignVendorInvoiceAmount() != null ?\n                                        new KualiDecimal(this.getForeignVendorInvoiceAmount().divide(new BigDecimal(singleItem.getExchangeRate()), 4, RoundingMode.HALF_UP)) : null);\n                            }\n                        }\n                    }\n                    setItemDescription(singleItem);\n                    Map<String, String> copyCriteria = new HashMap<String, String>();\n                    if (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\n                        copyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\n                        List<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\n                        if (copies.size() > 0) {\n                            List<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\n                            for (OleCopy copy : copies) {\n                                OLEPaidCopy paidCopy = new OLEPaidCopy();\n                                paidCopy.setCopyId(copy.getCopyId());\n                                paidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\n                                paidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n                                \/\/copy.getOlePaidCopies().add(paidCopy);\n                                paidCopies.add(paidCopy);\n                            }\n                            getBusinessObjectService().save(paidCopies);\n                            singleItem.setPaidCopies(paidCopies);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);\n            throw new RuntimeException(e);\n        }\n    }","code_wo_comment":"@Override\n    public void prepareForSave(KualiDocumentEvent event) {\n       \n       \n        if (event instanceof AttributedContinuePurapEvent) {\n            SpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n        }\n        if(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\n            this.setVendorPaymentTermsCode(null);\n        }\n        super.prepareForSave(event);\n        try {\n            if (this.proformaIndicator && !this.immediatePaymentIndicator) {\n                this.setImmediatePaymentIndicator(true);\n            }\n            LOG.debug(\"###########Inside OleInvoiceDocument \" + \"repareForSave###########\");\n            List<OleInvoiceItem> items = new ArrayList<OleInvoiceItem>();\n            items = this.getItems();\n            Iterator iterator = items.iterator();\n            HashMap dataMap = new HashMap();\n            String titleId;\n            while (iterator.hasNext()) {\n                LOG.debug(\"###########inside prepareForSave item loop###########\");\n                Object object = iterator.next();\n                if (object instanceof OleInvoiceItem) {\n                    LOG.debug(\"###########inside prepareForSave ole payment request item###########\");\n                    OleInvoiceItem singleItem = (OleInvoiceItem) object;\n                    if (StringUtils.isNotBlank(this.invoiceCurrencyType)) {\n                        this.setInvoiceCurrencyTypeId(new Long(this.getInvoiceCurrencyType()));\n                        String currencyType = SpringContext.getBean(OleInvoiceService.class).getCurrencyType(this.getInvoiceCurrencyType());\n                        if (StringUtils.isNotBlank(currencyType)) {\n                            if(!currencyType.equalsIgnoreCase(OleSelectConstant.CURRENCY_TYPE_NAME)) {\n                                if (StringUtils.isNotBlank(this.getInvoiceCurrencyExchangeRate())) {\n                                    try {\n                                        Double.parseDouble(this.getInvoiceCurrencyExchangeRate());\n                                        singleItem.setItemExchangeRate(new KualiDecimal(this.getInvoiceCurrencyExchangeRate()));\n                                        singleItem.setExchangeRate(this.getInvoiceCurrencyExchangeRate());\n                                    }\n                                    catch (NumberFormatException nfe) {\n                                        throw new RuntimeException(\"Invalid Exchange Rate\", nfe);\n                                    }\n                                }   else {\n                                    BigDecimal exchangeRate = SpringContext.getBean(OleInvoiceService.class).getExchangeRate(this.getInvoiceCurrencyType()).getExchangeRate();\n                                    this.setInvoiceCurrencyExchangeRate(exchangeRate.toString());\n                                    singleItem.setItemExchangeRate(new KualiDecimal(exchangeRate));\n                                    singleItem.setExchangeRate(exchangeRate.toString());\n                                }\n                                this.setVendorInvoiceAmount(this.getForeignVendorInvoiceAmount() != null ?\n                                        new KualiDecimal(this.getForeignVendorInvoiceAmount().divide(new BigDecimal(singleItem.getExchangeRate()), 4, RoundingMode.HALF_UP)) : null);\n                            }\n                        }\n                    }\n                    setItemDescription(singleItem);\n                    Map<String, String> copyCriteria = new HashMap<String, String>();\n                    if (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\n                        copyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\n                        List<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\n                        if (copies.size() > 0) {\n                            List<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\n                            for (OleCopy copy : copies) {\n                                OLEPaidCopy paidCopy = new OLEPaidCopy();\n                                paidCopy.setCopyId(copy.getCopyId());\n                                paidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\n                                paidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n                               \n                                paidCopies.add(paidCopy);\n                            }\n                            getBusinessObjectService().save(paidCopies);\n                            singleItem.setPaidCopies(paidCopies);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);\n            throw new RuntimeException(e);\n        }\n    }","cleancode":"@override public void prepareforsave(kualidocumentevent event) { if (event instanceof attributedcontinuepurapevent) { springcontext.getbean(oleinvoiceservice.class).populateinvoice(this); } if(this.getvendorpaymenttermscode() != null && this.getvendorpaymenttermscode().isempty()) { this.setvendorpaymenttermscode(null); } super.prepareforsave(event); try { if (this.proformaindicator && !this.immediatepaymentindicator) { this.setimmediatepaymentindicator(true); } log.debug(\"###########inside oleinvoicedocument \" + \"repareforsave###########\"); list<oleinvoiceitem> items = new arraylist<oleinvoiceitem>(); items = this.getitems(); iterator iterator = items.iterator(); hashmap datamap = new hashmap(); string titleid; while (iterator.hasnext()) { log.debug(\"###########inside prepareforsave item loop###########\"); object object = iterator.next(); if (object instanceof oleinvoiceitem) { log.debug(\"###########inside prepareforsave ole payment request item###########\"); oleinvoiceitem singleitem = (oleinvoiceitem) object; if (stringutils.isnotblank(this.invoicecurrencytype)) { this.setinvoicecurrencytypeid(new long(this.getinvoicecurrencytype())); string currencytype = springcontext.getbean(oleinvoiceservice.class).getcurrencytype(this.getinvoicecurrencytype()); if (stringutils.isnotblank(currencytype)) { if(!currencytype.equalsignorecase(oleselectconstant.currency_type_name)) { if (stringutils.isnotblank(this.getinvoicecurrencyexchangerate())) { try { double.parsedouble(this.getinvoicecurrencyexchangerate()); singleitem.setitemexchangerate(new kualidecimal(this.getinvoicecurrencyexchangerate())); singleitem.setexchangerate(this.getinvoicecurrencyexchangerate()); } catch (numberformatexception nfe) { throw new runtimeexception(\"invalid exchange rate\", nfe); } } else { bigdecimal exchangerate = springcontext.getbean(oleinvoiceservice.class).getexchangerate(this.getinvoicecurrencytype()).getexchangerate(); this.setinvoicecurrencyexchangerate(exchangerate.tostring()); singleitem.setitemexchangerate(new kualidecimal(exchangerate)); singleitem.setexchangerate(exchangerate.tostring()); } this.setvendorinvoiceamount(this.getforeignvendorinvoiceamount() != null ? new kualidecimal(this.getforeignvendorinvoiceamount().divide(new bigdecimal(singleitem.getexchangerate()), 4, roundingmode.half_up)) : null); } } } setitemdescription(singleitem); map<string, string> copycriteria = new hashmap<string, string>(); if (singleitem.getpaidcopies().size() <= 0 && singleitem.getpoitemidentifier() != null && (this.getpurapdocumentidentifier() != null && singleitem.getitemidentifier() != null)) { copycriteria.put(\"poitemid\", singleitem.getpoitemidentifier().tostring()); list<olecopy> copies = (list<olecopy>) getbusinessobjectservice().findmatching(olecopy.class, copycriteria); if (copies.size() > 0) { list<olepaidcopy> paidcopies = new arraylist<olepaidcopy>(); for (olecopy copy : copies) { olepaidcopy paidcopy = new olepaidcopy(); paidcopy.setcopyid(copy.getcopyid()); paidcopy.setinvoiceitemid(this.getpurapdocumentidentifier()); paidcopy.setinvoiceidentifier(singleitem.getitemidentifier()); paidcopies.add(paidcopy); } getbusinessobjectservice().save(paidcopies); singleitem.setpaidcopies(paidcopies); } } } } } catch (exception e) { log.error(\"exception during prepareforsave() in oleinvoicedocument\", e); throw new runtimeexception(e); } }","repo":"VU-libtech\/OLE-INST","label":[0,1,0,0]}
{"id":14444,"original_code":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\n        this.fpp = filterablePagingProvider;\n        this.fcp = filterableCountProvider;\n        \/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\n        piggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\n            private static final long serialVersionUID = 1027614132444478021L;\n            @Override\n            public List<T> findEntities(int firstRow) {\n                return fpp.findEntities(firstRow,\n                        getCurrentFilter());\n            }\n        },\n                new LazyList.CountProvider() {\n            private static final long serialVersionUID = -7339189124024626177L;\n            @Override\n            public int size() {\n                return fcp.size(getCurrentFilter());\n            }\n        }, pageLength);\n        setBic(new DummyFilterableListContainer<T>(getType(),\n                piggybackLazyList));\n        getSelect().setContainerDataSource(getBic());\n    }","code_wo_comment":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\n        this.fpp = filterablePagingProvider;\n        this.fcp = filterableCountProvider;\n       \n        piggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\n            private static final long serialVersionUID = 1027614132444478021L;\n            @Override\n            public List<T> findEntities(int firstRow) {\n                return fpp.findEntities(firstRow,\n                        getCurrentFilter());\n            }\n        },\n                new LazyList.CountProvider() {\n            private static final long serialVersionUID = -7339189124024626177L;\n            @Override\n            public int size() {\n                return fcp.size(getCurrentFilter());\n            }\n        }, pageLength);\n        setBic(new DummyFilterableListContainer<T>(getType(),\n                piggybackLazyList));\n        getSelect().setContainerDataSource(getBic());\n    }","cleancode":"public void loadfrom(filterablepagingprovider<t> filterablepagingprovider, filterablecountprovider filterablecountprovider, int pagelength) { this.fpp = filterablepagingprovider; this.fcp = filterablecountprovider; piggybacklazylist = new lazylist<>(new lazylist.pagingprovider<t>() { private static final long serialversionuid = 1027614132444478021l; @override public list<t> findentities(int firstrow) { return fpp.findentities(firstrow, getcurrentfilter()); } }, new lazylist.countprovider() { private static final long serialversionuid = -7339189124024626177l; @override public int size() { return fcp.size(getcurrentfilter()); } }, pagelength); setbic(new dummyfilterablelistcontainer<t>(gettype(), piggybacklazylist)); getselect().setcontainerdatasource(getbic()); }","repo":"andreika63\/viritin","label":[1,0,0,0]}
{"id":22702,"original_code":"public CompraEntity find(Long compraId) {\n    LOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\n    return em.find(CompraEntity.class, compraId);\n}","code_wo_comment":"public CompraEntity find(Long compraId) {\n    LOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\n    return em.find(CompraEntity.class, compraId);\n}","cleancode":"public compraentity find(long compraid) { logger.log(level.info, \"buscando compra con el id={0}\", compraid); return em.find(compraentity.class, compraid); }","repo":"Uniandes-isis2603\/s2_Boletas","label":[0,1,0,0]}
{"id":22714,"original_code":"public Dialog onCreateDialog(int dialogId){\n\t\tDialog dialog = null;\n\t\ttry{\n\t\t\t\/\/Log.v(TAG, \"onCreateDialog() called\");\n\t\t\tif (mManagedDialogs == null) {\n\t\t\t\tmManagedDialogs = new SparseArray<Dialog>();\n\t\t\t}\n\t\t\tswitch(dialogId){\n\t\t\t\tcase DIALOG_DELETE_ATTACHMENT_ID:\n\t\t\t\t\tdialog = new AlertDialog.Builder(mActivity)\n\t\t\t        .setTitle(R.string.dialog_confirmDelete)\n\t\t\t        .setIcon(android.R.drawable.ic_dialog_alert)\n\t\t\t        .setMessage(R.string.dialog_areYouSure)\n\t\t\t        .setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\n\t\t\t    \t\tpublic void onClick(DialogInterface dialog, int whichButton){\n\t\t\t    \t\t\ttry{\n\t\t\t    \t\t\t\tif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\n\t\t\t    \t\t\t\t\tif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\n\t\t\t    \t\t\t\t\t\tErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n\t\t\t    \t\t\t\t\t}\n\t\t\t    \t\t\t\t\t\/\/ Notify the ListAdapter that it's cursor needs refreshing\n\t\t\t    \t\t\t\t\tnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n\t\t\t    \t\t\t\t}\n\t\t\t    \t\t\t}catch(HandledException h){ \/\/ Ignore.\n\t\t\t    \t\t\t}catch(Exception exp){\n\t\t\t    \t\t\t\tLog.e(TAG, \"ERR000FD\", exp);\n\t\t\t    \t\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n\t\t\t    \t\t\t}\n\t\t\t    \t\t}\n\t\t\t    \t})\n\t\t\t        .setNegativeButton(R.string.button_no, null)\n\t\t\t    \t.create();\n\t\t            mManagedDialogs.put(dialogId, dialog);\n\t\t            break;\n\t\t\t} \n\t\t}catch(HandledException h){ \/\/ Ignore.\n\t\t}catch(Exception exp){\n\t\t\tLog.e(TAG, \"ERR000FC\", exp);\n\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n\t\t}\n\t\treturn dialog;\n\t}","code_wo_comment":"public Dialog onCreateDialog(int dialogId){\n\t\tDialog dialog = null;\n\t\ttry{\n\t\t\n\t\t\tif (mManagedDialogs == null) {\n\t\t\t\tmManagedDialogs = new SparseArray<Dialog>();\n\t\t\t}\n\t\t\tswitch(dialogId){\n\t\t\t\tcase DIALOG_DELETE_ATTACHMENT_ID:\n\t\t\t\t\tdialog = new AlertDialog.Builder(mActivity)\n\t\t\t        .setTitle(R.string.dialog_confirmDelete)\n\t\t\t        .setIcon(android.R.drawable.ic_dialog_alert)\n\t\t\t        .setMessage(R.string.dialog_areYouSure)\n\t\t\t        .setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){\n\t\t\t    \t\tpublic void onClick(DialogInterface dialog, int whichButton){\n\t\t\t    \t\t\ttry{\n\t\t\t    \t\t\t\tif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\n\t\t\t    \t\t\t\t\tif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\n\t\t\t    \t\t\t\t\t\tErrorUtil.notifyUser(mActivity);\n\t\t\t    \t\t\t\t\t}\n\t\t\t    \t\t\t\t\n\t\t\t    \t\t\t\t\tnotifyDataSetChanged();\n\t\t\t    \t\t\t\t}\n\t\t\t    \t\t\t}catch(HandledException h){\n\t\t\t    \t\t\t}catch(Exception exp){\n\t\t\t    \t\t\t\tLog.e(TAG, \"ERR000FD\", exp);\n\t\t\t    \t\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n\t\t\t    \t\t\t}\n\t\t\t    \t\t}\n\t\t\t    \t})\n\t\t\t        .setNegativeButton(R.string.button_no, null)\n\t\t\t    \t.create();\n\t\t            mManagedDialogs.put(dialogId, dialog);\n\t\t            break;\n\t\t\t} \n\t\t}catch(HandledException h){\n\t\t}catch(Exception exp){\n\t\t\tLog.e(TAG, \"ERR000FC\", exp);\n\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n\t\t}\n\t\treturn dialog;\n\t}","cleancode":"public dialog oncreatedialog(int dialogid){ dialog dialog = null; try{ if (mmanageddialogs == null) { mmanageddialogs = new sparsearray<dialog>(); } switch(dialogid){ case dialog_delete_attachment_id: dialog = new alertdialog.builder(mactivity) .settitle(r.string.dialog_confirmdelete) .seticon(android.r.drawable.ic_dialog_alert) .setmessage(r.string.dialog_areyousure) .setpositivebutton(r.string.button_yes, new android.content.dialoginterface.onclicklistener(){ public void onclick(dialoginterface dialog, int whichbutton){ try{ if( whichbutton == android.content.dialoginterface.button_positive){ if( !completableutil.delete(mactivity, mattachmenturi) ){ errorutil.notifyuser(mactivity); } notifydatasetchanged(); } }catch(handledexception h){ }catch(exception exp){ log.e(tag, \"err000fd\", exp); errorutil.handleexceptionnotifyuser(\"err000fd\", exp, mactivity); } } }) .setnegativebutton(r.string.button_no, null) .create(); mmanageddialogs.put(dialogid, dialog); break; } }catch(handledexception h){ }catch(exception exp){ log.e(tag, \"err000fc\", exp); errorutil.handleexceptionnotifyuser(\"err000fc\", exp, mactivity); } return dialog; }","repo":"SpencerRiddering\/flingtap-done","label":[1,1,0,0]}
{"id":30955,"original_code":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\n\tpublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\n\t\t\tHttpServletRequest req, RedirectAttributes flash) {\n\t\tlogger.info(\"contactar-anunciante\");\n\t\tInteger id = Integer.parseInt(req.getParameter(\"id\"));\n\t\ttry {\n\t\t\tVehiculo veh = vehiculoService.findById(id);\n\t\t\tString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\t\t\t\/\/ Email message\n\t\t\tSimpleMailMessage shareEmail = new SimpleMailMessage();\n\t\t\tshareEmail.setTo(email);\n\t\t\tshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\n\t\t\tshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n\t\t\t\t\t+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n\t\t\t\t\t+ id);\n\t\t\temailService.sendEmail(shareEmail);\n\t\t\tmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\n\t\t\tlogger.info(\"Email enviado correctamente\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"redirect:\/anuncio\/detalle\/\" + id;\n\t}","code_wo_comment":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\n\tpublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\n\t\t\tHttpServletRequest req, RedirectAttributes flash) {\n\t\tlogger.info(\"contactar-anunciante\");\n\t\tInteger id = Integer.parseInt(req.getParameter(\"id\"));\n\t\ttry {\n\t\t\tVehiculo veh = vehiculoService.findById(id);\n\t\t\tString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\t\t\n\t\t\tSimpleMailMessage shareEmail = new SimpleMailMessage();\n\t\t\tshareEmail.setTo(email);\n\t\t\tshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\n\t\t\tshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n\t\t\t\t\t+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n\t\t\t\t\t+ id);\n\t\t\temailService.sendEmail(shareEmail);\n\t\t\tmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\n\t\t\tlogger.info(\"Email enviado correctamente\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"redirect:\/anuncio\/detalle\/\" + id;\n\t}","cleancode":"@requestmapping(value = \"\/shareanuncio\", method = requestmethod.post) public string shareanuncio(@requestparam(\"email\") string email, model model, authentication authentication, httpservletrequest req, redirectattributes flash) { logger.info(\"contactar-anunciante\"); integer id = integer.parseint(req.getparameter(\"id\")); try { vehiculo veh = vehiculoservice.findbyid(id); string appurl = req.getscheme() + \":\/\/\" + req.getservername() + \":\" + req.getserverport(); simplemailmessage shareemail = new simplemailmessage(); shareemail.setto(email); shareemail.setsubject(\"coches: un amigo te recomienda este anuncio\"); shareemail.settext(\"\u00a1hola!\\n\" + \"un amigo se ha acordado de ti al ver este anuncio \" + veh.getmarca() + \" y cree que te puede interesar.\" + \"\\n\u00bftienes curiosidad?\\n\" + appurl + \"\/anuncio\/detalle\/\" + id); emailservice.sendemail(shareemail); model.addattribute(\"emailsend\", \"el correo se envio correctamente\"); logger.info(\"email enviado correctamente\"); } catch (exception e) { e.printstacktrace(); } return \"redirect:\/anuncio\/detalle\/\" + id; }","repo":"adriancice\/adrian-pfm","label":[0,0,0,0]}
{"id":14663,"original_code":"private void initShape() {\n        \/\/ TODO: these could be optimised\n        float cx = dim * 0.5f;\n        float cy = dim * 0.5f + 1;\n        float r  = (dim - 3) * 0.5f;\n        float rh = r * 0.4f;\n        for (int i = 0; i < 10; i++) {\n            double ang = Math.PI\/180 * (i * 36 - 90);\n            float ri   = i % 2 == 0 ? r : rh;\n            float x    = (float) Math.cos(ang) * ri + cx;\n            float y    = (float) Math.sin(ang) * ri + cy;\n            if (i == 0) {\n                gp.moveTo(x, y);\n            } else {\n                gp.lineTo(x, y);\n            }\n        }\n        gp.closePath();\n    }","code_wo_comment":"private void initShape() {\n       \n        float cx = dim * 0.5f;\n        float cy = dim * 0.5f + 1;\n        float r  = (dim - 3) * 0.5f;\n        float rh = r * 0.4f;\n        for (int i = 0; i < 10; i++) {\n            double ang = Math.PI\/180 * (i * 36 - 90);\n            float ri   = i % 2 == 0 ? r : rh;\n            float x    = (float) Math.cos(ang) * ri + cx;\n            float y    = (float) Math.sin(ang) * ri + cy;\n            if (i == 0) {\n                gp.moveTo(x, y);\n            } else {\n                gp.lineTo(x, y);\n            }\n        }\n        gp.closePath();\n    }","cleancode":"private void initshape() { float cx = dim * 0.5f; float cy = dim * 0.5f + 1; float r = (dim - 3) * 0.5f; float rh = r * 0.4f; for (int i = 0; i < 10; i++) { double ang = math.pi\/180 * (i * 36 - 90); float ri = i % 2 == 0 ? r : rh; float x = (float) math.cos(ang) * ri + cx; float y = (float) math.sin(ang) * ri + cy; if (i == 0) { gp.moveto(x, y); } else { gp.lineto(x, y); } } gp.closepath(); }","repo":"Sciss\/Rating","label":[1,0,0,0]}
{"id":22873,"original_code":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n        \/\/ TODO Insert code for assignment 5.2.a\n        for(Rectangle rectangle:rectangles){\n            if(rectangle.getX() < this.gridRectangle.getX() ||\n               rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n               rectangle.getY() < this.gridRectangle.getY() ||\n               rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n            ){\n                throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n            }\n            int startX = (int)transformX(rectangle.getX());\n            int startY = (int)transformY(rectangle.getY());\n            int endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\n            if(endX == this.GRID_RESOLUTION_X){\n                endX = this.GRID_RESOLUTION_X - 1;\n            }\n            int endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\n            if(endY == this.GRID_RESOLUTION_Y){\n                endY = this.GRID_RESOLUTION_Y - 1;\n            }\n            for(int i = startX; i <= endX; i++){\n                for(int j = startY; j<=endY; j++){\n                    map[j][i].add(rectangle);\n                }\n            }\n        }\n    }","code_wo_comment":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n       \n        for(Rectangle rectangle:rectangles){\n            if(rectangle.getX() < this.gridRectangle.getX() ||\n               rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n               rectangle.getY() < this.gridRectangle.getY() ||\n               rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n            ){\n                throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n            }\n            int startX = (int)transformX(rectangle.getX());\n            int startY = (int)transformY(rectangle.getY());\n            int endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\n            if(endX == this.GRID_RESOLUTION_X){\n                endX = this.GRID_RESOLUTION_X - 1;\n            }\n            int endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\n            if(endY == this.GRID_RESOLUTION_Y){\n                endY = this.GRID_RESOLUTION_Y - 1;\n            }\n            for(int i = startX; i <= endX; i++){\n                for(int j = startY; j<=endY; j++){\n                    map[j][i].add(rectangle);\n                }\n            }\n        }\n    }","cleancode":"private void fillcollisionmap(set<rectangle> rectangles) throws collisionmapoutofboundsexception { for(rectangle rectangle:rectangles){ if(rectangle.getx() < this.gridrectangle.getx() || rectangle.getx() + rectangle.getwidth() > this.gridrectangle.getx() + this.gridrectangle.getwidth() || rectangle.gety() < this.gridrectangle.gety() || rectangle.gety() + rectangle.getheight() > this.gridrectangle.gety() + this.gridrectangle.getheight() ){ throw new collisionmapoutofboundsexception(\"a rectangle is out of the bounds of this rectangle\"); } int startx = (int)transformx(rectangle.getx()); int starty = (int)transformy(rectangle.gety()); int endx = (int)transformx(rectangle.getx() + rectangle.getwidth()); if(endx == this.grid_resolution_x){ endx = this.grid_resolution_x - 1; } int endy = (int)transformy(rectangle.gety() + rectangle.getheight()); if(endy == this.grid_resolution_y){ endy = this.grid_resolution_y - 1; } for(int i = startx; i <= endx; i++){ for(int j = starty; j<=endy; j++){ map[j][i].add(rectangle); } } } }","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","label":[0,1,0,0]}
{"id":22874,"original_code":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n        \/\/ TODO Insert code for assignment 5.2.b\n        if(\n                rectangle.getX() < this.gridRectangle.getX() ||\n                rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n                rectangle.getY() < this.gridRectangle.getY() ||\n                rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n        ){\n            throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n        }\n        Set<Rectangle> rectangleSet = new HashSet<>();\n        int startX = (int)transformX(rectangle.getX());\n        int startY = (int)transformY(rectangle.getY());\n        int endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\n        int endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\n        for(int i = startX; i <= endX; i++){\n            for(int j = startY; j<=endY; j++){\n                for(Rectangle re :map[j][i]){\n                    rectangleSet.add(re);\n                }\n            }\n        }\n        return rectangleSet;\n    }","code_wo_comment":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n       \n        if(\n                rectangle.getX() < this.gridRectangle.getX() ||\n                rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n                rectangle.getY() < this.gridRectangle.getY() ||\n                rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n        ){\n            throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n        }\n        Set<Rectangle> rectangleSet = new HashSet<>();\n        int startX = (int)transformX(rectangle.getX());\n        int startY = (int)transformY(rectangle.getY());\n        int endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\n        int endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\n        for(int i = startX; i <= endX; i++){\n            for(int j = startY; j<=endY; j++){\n                for(Rectangle re :map[j][i]){\n                    rectangleSet.add(re);\n                }\n            }\n        }\n        return rectangleSet;\n    }","cleancode":"private set<rectangle> getcollisioncandidates(final rectangle rectangle) throws collisionmapoutofboundsexception { if( rectangle.getx() < this.gridrectangle.getx() || rectangle.getx() + rectangle.getwidth() > this.gridrectangle.getx() + this.gridrectangle.getwidth() || rectangle.gety() < this.gridrectangle.gety() || rectangle.gety() + rectangle.getheight() > this.gridrectangle.gety() + this.gridrectangle.getheight() ){ throw new collisionmapoutofboundsexception(\"a rectangle is out of the bounds of this rectangle\"); } set<rectangle> rectangleset = new hashset<>(); int startx = (int)transformx(rectangle.getx()); int starty = (int)transformy(rectangle.gety()); int endx = (int)transformx(rectangle.getx() + rectangle.getwidth()) + 1; int endy = (int)transformy(rectangle.gety() + rectangle.getheight()) + 1; for(int i = startx; i <= endx; i++){ for(int j = starty; j<=endy; j++){ for(rectangle re :map[j][i]){ rectangleset.add(re); } } } return rectangleset; }","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","label":[0,1,0,0]}
{"id":22875,"original_code":"public boolean collide(final Rectangle rectangle) {\n        \/\/ TODO Insert code for assignment 5.2.c\n        if(rectangle == null){\n            throw new IllegalArgumentException(\"rectangle is null\");\n        }\n        boolean flag = false;\n        try{\n            Set<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\n            for(Rectangle re:rectangleSet){\n                if(re.intersects(rectangle)){\n                    flag = true;\n                }\n            }\n        }catch (Exception e){\n            System.out.println(e.getMessage());\n        }finally {\n            return flag;\n        }\n    }","code_wo_comment":"public boolean collide(final Rectangle rectangle) {\n       \n        if(rectangle == null){\n            throw new IllegalArgumentException(\"rectangle is null\");\n        }\n        boolean flag = false;\n        try{\n            Set<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\n            for(Rectangle re:rectangleSet){\n                if(re.intersects(rectangle)){\n                    flag = true;\n                }\n            }\n        }catch (Exception e){\n            System.out.println(e.getMessage());\n        }finally {\n            return flag;\n        }\n    }","cleancode":"public boolean collide(final rectangle rectangle) { if(rectangle == null){ throw new illegalargumentexception(\"rectangle is null\"); } boolean flag = false; try{ set<rectangle> rectangleset = this.getcollisioncandidates(rectangle); for(rectangle re:rectangleset){ if(re.intersects(rectangle)){ flag = true; } } }catch (exception e){ system.out.println(e.getmessage()); }finally { return flag; } }","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","label":[0,1,0,0]}
{"id":14690,"original_code":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\n        Objects.requireNonNull(inputNames);\n        this.inputNames = inputNames;\n        return this;\n    }","code_wo_comment":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\n        Objects.requireNonNull(inputNames);\n        this.inputNames = inputNames;\n        return this;\n    }","cleancode":"public mapperbuilder withinputnames(iterable<string> inputnames) { objects.requirenonnull(inputnames); this.inputnames = inputnames; return this; }","repo":"andbi-redpill\/datasonnet-mapper","label":[0,1,0,0]}
{"id":14723,"original_code":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\n\t\t\tGestorDatosComponentes gestorDatos) {\n\t\t\/\/ Id de usuario\n\t\tInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\t\t\/\/ Usuarios concurrentes\n\t\tString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\t\t\n\t\tInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\t\t\/\/ Tiempo\n\t\tString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\t\t\n\t\tInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\t\t\/\/ Resoluci\u00f3n\n\t\tString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\t\t\n\t\tInteger intIdResolution = Integer.valueOf(strIdResolution);\n\t\t\/\/ Disponibilidad\n\t\tBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\t\t\n\t\tInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\n\t\tFloat precioTotal = null;\n\t\tif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\n\t\t\tprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\n\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\n\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\n\t\t}else{\n\t\t\tif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\n\t\t\t\tFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\t\t\n\t\t\t}else{\n\t\t\t\tFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\n\t\t\t\tFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\n\t\t\t}\n\t\t}\n\t\t\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\t\t\/\/ entre ficheros de varias configuraciones\n\t\ttry {\n\t\t\tString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\n\t\t\tString resultadoAcuerdo = \"noAgreement\";\n\t\t\tif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\t\t\t\t\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\n\t\t\t\tString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\t\t\t\t\/\/ NVPDecoder object is created\n\t\t\t\tNVPDecoder resultValues = new NVPDecoder();\n\t\t\t\t\/\/ decode method of NVPDecoder will parse the request and decode the\n\t\t\t\t\/\/ name and value pair\n\t\t\t\tresultValues.decode(ppresponse);\n\t\t\t\t\/\/ checks for Acknowledgement and redirects accordingly to display\n\t\t\t\t\/\/ error messages\n\t\t\t\tString strAck = resultValues.get(\"ACK\");\n\t\t\t\tif (strAck != null\n\t\t\t\t\t\t&& !(strAck.equals(\"Success\") || strAck\n\t\t\t\t\t\t\t\t.equals(\"SuccessWithWarning\"))) {\n\t\t\t\t\t\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\t\t\t\t\n\t\t\t\t\tresultadoAcuerdo = \"noAgreement\";\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\n\t\t\t\t\tString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\n\t\t\t\t\tif(status.compareToIgnoreCase(\"Active\")==0){\n\t\t\t\t\t\tresultadoAcuerdo = \"agreement\";\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\n\t\t\tString idAlert = \"alertInfoUploadProduction\";\n\t\t\tif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\t\t\t\tidAlert = \"alertInfoBillingAgreement\";\n\t\t\t\t\/\/ Mostrar mensaje \u00e9xito\n\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\n\t\t\t\t\t\tgetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\t\t\t\t\n\t\t\t}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\n\t\t\t\tIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\n\t\t\t\tString mensaje = salida[0].getString(\"FIONEG003010\");\n\t\t\t\t\/\/ Mostrar alert informando al usuario del problema\t\t\t\t\n\t\t\t\tif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\t\t\t\t\t\/\/ Mostrar mensaje \u00e9xito\n\t\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t\/\/ Mostrar mensaje error\n\t\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\/\/ Cerramos la ventana de confirmaci\u00f3n\n\t\t\tgestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\t\t\t\/\/ Cerramos el di\u00e1logo de precios\n\t\t\tgestorEstados.closeModalAlert(\"dialogoPrecios\");\n\t\t} catch (FactoriaDatosException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (PersistenciaException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FawnaInvokerException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}catch(PayPalException ppEx){\t\t\t\t\n\t\t\tppEx.printStackTrace();\n\t\t}\t\t\n\t}","code_wo_comment":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\n\t\t\tGestorDatosComponentes gestorDatos) {\n\t\n\t\tInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\t\n\t\tString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\t\t\n\t\tInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\t\n\t\tString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\t\t\n\t\tInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\t\t\tString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\t\t\n\t\tInteger intIdResolution = Integer.valueOf(strIdResolution);\n\t\n\t\tBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\t\t\n\t\tInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\n\t\tFloat precioTotal = null;\n\t\tif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\n\t\t\tprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\n\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\n\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\n\t\t}else{\n\t\t\tif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\n\t\t\t\tFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\t\t\n\t\t\t}else{\n\t\t\t\tFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\n\t\t\t\tFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\n\t\t\tString resultadoAcuerdo = \"noAgreement\";\n\t\t\tif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\t\t\t\n\t\t\t\tString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\t\t\t\n\t\t\t\tNVPDecoder resultValues = new NVPDecoder();\n\t\t\t\n\t\t\t\n\t\t\t\tresultValues.decode(ppresponse);\n\t\t\t\n\t\t\t\n\t\t\t\tString strAck = resultValues.get(\"ACK\");\n\t\t\t\tif (strAck != null\n\t\t\t\t\t\t&& !(strAck.equals(\"Success\") || strAck\n\t\t\t\t\t\t\t\t.equals(\"SuccessWithWarning\"))) {\n\t\t\t\t\t\t\t\tresultadoAcuerdo = \"noAgreement\";\n\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\n\t\t\t\t\tif(status.compareToIgnoreCase(\"Active\")==0){\n\t\t\t\t\t\tresultadoAcuerdo = \"agreement\";\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\tString idAlert = \"alertInfoUploadProduction\";\n\t\t\tif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\t\t\t\tidAlert = \"alertInfoBillingAgreement\";\n\t\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\n\t\t\t\t\t\tgetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\t\t\t\t\n\t\t\t}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0)\n\t\t\t\tIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\n\t\t\t\tString mensaje = salida[0].getString(\"FIONEG003010\");\n\t\t\t\n\t\t\t\tif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\t\t\t\t\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\n\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\t\tgestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\t\t\t\t\tgestorEstados.closeModalAlert(\"dialogoPrecios\");\n\t\t} catch (FactoriaDatosException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (PersistenciaException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (FawnaInvokerException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t}catch(PayPalException ppEx){\t\t\t\t\n\t\t\tppEx.printStackTrace();\n\t\t}\t\t\n\t}","cleancode":"public void procesarajaxchangelistener(gestorestadocomponentes gestorestados, gestordatoscomponentes gestordatos) { integer intcodusuario = contextutils.getuseridasinteger(); string strnumusersconcurrentes = (string)gestordatos.getvalue(\"numusuariosconcu\"); integer intnumuserconcurrentes = integer.valueof(strnumusersconcurrentes); string stridunidadtiempo = (string)gestordatos.getvalue(\"idunidadtiempo\"); integer intidunidadtiempo = integer.valueof(stridunidadtiempo); string stridresolution = (string)gestordatos.getvalue(\"resolution\"); integer intidresolution = integer.valueof(stridresolution); boolean highavailability = (boolean)gestordatos.getvalue(\"checkavailability\"); integer inthighavailability = highavailability?new integer(1):new integer(0); float preciototal = null; if(gestordatos.getvalue(\"preciototal\") != null && !\"\".equals(gestordatos.getvalue(\"preciototal\")) && !\"0.0\".equals(gestordatos.getvalue(\"preciototal\"))){ preciototal = (float)gestordatos.getvalue(\"preciototal\"); bigdecimal bidpreciototal = new bigdecimal(preciototal); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); }else{ if(gestordatos.getvalue(\"preciototaltiempo\") != null && !\"\".equals(gestordatos.getvalue(\"preciototaltiempo\")) & !\"0.0\".equals(gestordatos.getvalue(\"preciototaltiempo\"))){ float preciototaltiempo = (float)gestordatos.getvalue(\"preciototaltiempo\"); bigdecimal bidpreciototal = new bigdecimal(preciototaltiempo); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); }else{ float preciototaluso = (float)gestordatos.getvalue(\"preciototaluso\"); float preciohosting = (float)gestordatos.getvalue(\"preciototalhosting\"); bigdecimal bidpreciototal = new bigdecimal(preciototaluso+preciohosting); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); } } try { string billingagreementid = helpercontext.getinstance().getvaluecontext(\"secure_user_billing_agreement_id\"); string resultadoacuerdo = \"noagreement\"; if(billingagreementid != null && !\"\".equals(billingagreementid)){ string ppresponse = paypalutilities.getinstance().baupdate(billingagreementid); nvpdecoder resultvalues = new nvpdecoder(); resultvalues.decode(ppresponse); string strack = resultvalues.get(\"ack\"); if (strack != null && !(strack.equals(\"success\") || strack .equals(\"successwithwarning\"))) { resultadoacuerdo = \"noagreement\"; } else { string status = resultvalues.get(\"billingagreementstatus\"); if(status.comparetoignorecase(\"active\")==0){ resultadoacuerdo = \"agreement\"; } } } string idalert = \"alertinfouploadproduction\"; if(resultadoacuerdo.comparetoignorecase(\"noagreement\")==0){ idalert = \"alertinfobillingagreement\"; handlemodalalert(gestordatos, gestorestados, idalert, \"info\", getmessage(\"fiona.alertbillagreement.cabecerapanel.valor\", \"billing agreement needed!\"), getmessage(\"fiona.alertbillagreement.mensajeok.valor\", \"you need to sign a new billing agreement!!\"), \"\", \"\"); }else if(resultadoacuerdo.comparetoignorecase(\"agreement\")==0) icontexto[] salida = invokeuploadtoproduction(intcodusuario, null,intnumuserconcurrentes,intidunidadtiempo, intidresolution,inthighavailability, preciototal); string mensaje = salida[0].getstring(\"fioneg003010\"); if(mensaje.comparetoignorecase(\"ok\")==0){ handlemodalalert(gestordatos, gestorestados, idalert, \"info\", getmessage(\"fiona.alertuploadprodok.cabecerapanel.valor\", \"success!\"), getmessage(\"fiona.alertuploadprodok.mensajeok.valor\", \"request completed!!\"), \"\", \"\"); }else{ handlemodalalert(gestordatos, gestorestados, idalert, \"error\", getmessage(\"fiona.alertuploadprodok.cabecerapanelerror.valor\", \"error!\"), getmessage(\"fiona.alertuploadprodok.mensajeerror.valor\", \"something went wrong...\"), \"\", \"\"); } } gestorestados.closemodalalert(\"alertuploadconfirm\"); gestorestados.closemodalalert(\"dialogoprecios\"); } catch (factoriadatosexception e) { e.printstacktrace(); } catch (persistenciaexception e) { e.printstacktrace(); } catch (fawnainvokerexception e) { e.printstacktrace(); }catch(paypalexception ppex){ ppex.printstacktrace(); } }","repo":"adele-robots\/fiona","label":[1,1,0,0]}
{"id":14725,"original_code":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\t\t\/\/ TODO: fix this so the label is a child of the Lane or Pool.\n\t\t\/\/ There's a problem with Resize Feature if the label is a direct child of Lane\/Pool.\n\t\treturn (ContainerShape) ownerPE.eContainer();\n\t}","code_wo_comment":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\t\n\t\n\t\treturn (ContainerShape) ownerPE.eContainer();\n\t}","cleancode":"protected containershape gettargetcontainer(pictogramelement ownerpe) { return (containershape) ownerpe.econtainer(); }","repo":"alfa-ryano\/org.eclipse.bpmn2-modeler","label":[1,0,0,0]}
{"id":31226,"original_code":"@ReactMethod\n    public void issue( \/\/ TODO: alternatively we can just take a json string here and pass that directly to the ffi for librgb\n            int alloc_coins,\n            String alloc_outpoint,\n            String network,\n            String ticker,\n            String name,\n            String description,\n            int precision,\n            Promise promise) {\n        try {\n            final Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();\n            final OutpointCoins allocation = new OutpointCoins((long) alloc_coins, alloc_outpoint);\n            runtime.issue(network, ticker, name, description, precision, Arrays.asList(allocation), new HashSet<OutpointCoins>(), null, null);\n            WritableMap map = Arguments.createMap();\n            promise.resolve(map);\n        } catch (Exception e) {\n            promise.reject(e);\n        }\n    }","code_wo_comment":"@ReactMethod\n    public void issue(\n            int alloc_coins,\n            String alloc_outpoint,\n            String network,\n            String ticker,\n            String name,\n            String description,\n            int precision,\n            Promise promise) {\n        try {\n            final Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();\n            final OutpointCoins allocation = new OutpointCoins((long) alloc_coins, alloc_outpoint);\n            runtime.issue(network, ticker, name, description, precision, Arrays.asList(allocation), new HashSet<OutpointCoins>(), null, null);\n            WritableMap map = Arguments.createMap();\n            promise.resolve(map);\n        } catch (Exception e) {\n            promise.reject(e);\n        }\n    }","cleancode":"@reactmethod public void issue( int alloc_coins, string alloc_outpoint, string network, string ticker, string name, string description, int precision, promise promise) { try { final runtime runtime = ((mainapplication) getcurrentactivity().getapplication()).getruntime(); final outpointcoins allocation = new outpointcoins((long) alloc_coins, alloc_outpoint); runtime.issue(network, ticker, name, description, precision, arrays.aslist(allocation), new hashset<outpointcoins>(), null, null); writablemap map = arguments.createmap(); promise.resolve(map); } catch (exception e) { promise.reject(e); } }","repo":"alexeyneu\/rgb-sdk","label":[1,0,0,0]}
{"id":31251,"original_code":"public static void main(String[] args){\n        \/*\n            Write a program to add a score of 100 to \n            the the array scores.\n        *\/\n        int[] scores = {88,91,80,78,95};\n        System.out.println(\"Current scores are: \" + Arrays.toString(scores));\n        \/\/TODO 1: Write code to make a new array that can hold a new score\n        int[] temp = new int[scores.length + 1];\n        for(int i = 0; i<scores.length; i++){\n            temp[i] = scores[i];\n        }\n        temp[temp.length -1] = 100;\n        scores = temp;\n        \/\/ ... code to add should stay above this line\n        System.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n        \/\/TODO 2: Next, write code to remove the first value from the scores\n        int[] temp2 = new int[scores.length -1];\n        for(int i = 1; i < scores.length; i++){\n            temp2[i-1] = scores[i];\n        }\n        \/\/ ... code to remove should stay above this line\n        System.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n        \/\/TODO 3: Implement the methods below\n        int[] arr2 = makeCopyOf(scores);\n        \/\/System.out.println(\"Copy of scores looks like: \" + scores);\n    }","code_wo_comment":"public static void main(String[] args){\n       \n        int[] scores = {88,91,80,78,95};\n        System.out.println(\"Current scores are: \" + Arrays.toString(scores));\n       \n        int[] temp = new int[scores.length + 1];\n        for(int i = 0; i<scores.length; i++){\n            temp[i] = scores[i];\n        }\n        temp[temp.length -1] = 100;\n        scores = temp;\n       \n        System.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n       \n        int[] temp2 = new int[scores.length -1];\n        for(int i = 1; i < scores.length; i++){\n            temp2[i-1] = scores[i];\n        }\n       \n        System.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n       \n        int[] arr2 = makeCopyOf(scores);\n       \n    }","cleancode":"public static void main(string[] args){ int[] scores = {88,91,80,78,95}; system.out.println(\"current scores are: \" + arrays.tostring(scores)); int[] temp = new int[scores.length + 1]; for(int i = 0; i<scores.length; i++){ temp[i] = scores[i]; } temp[temp.length -1] = 100; scores = temp; system.out.println(\"after 'adding' score: \" + arrays.tostring(scores)); int[] temp2 = new int[scores.length -1]; for(int i = 1; i < scores.length; i++){ temp2[i-1] = scores[i]; } system.out.println(\"after 'remove' scores are: \" + arrays.tostring(scores)); int[] arr2 = makecopyof(scores); }","repo":"SwettSoquelHS\/think-java-notswett","label":[0,1,0,0]}
{"id":23212,"original_code":"@Override\n    protected void setup(VaadinRequest request) {\n        addComponent(new ProgressIndicator() {\n            {\n                registerRpc(new ProgressIndicatorServerRpc() {\n                    @Override\n                    public void poll() {\n                        \/\/ System.out.println(\"Pausing poll request\");\n                        try {\n                            \/\/ Make the XHR request last longer to make it\n                            \/\/ easier to click the link at the right moment.\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        \/\/ System.out.println(\"Continuing poll request\");\n                    }\n                });\n                setPollingInterval(3000);\n            }\n        });\n        \/\/ Hacky URLs that are might not work in all deployment scenarios\n        addComponent(new Link(\"Navigate away\", new ExternalResource(\n                \"slowRequestHandler\")));\n        addComponent(new Link(\"Start download\", new ExternalResource(\n                \"slowRequestHandler?download\")));\n    }","code_wo_comment":"@Override\n    protected void setup(VaadinRequest request) {\n        addComponent(new ProgressIndicator() {\n            {\n                registerRpc(new ProgressIndicatorServerRpc() {\n                    @Override\n                    public void poll() {\n                       \n                        try {\n                           \n                           \n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                       \n                    }\n                });\n                setPollingInterval(3000);\n            }\n        });\n       \n        addComponent(new Link(\"Navigate away\", new ExternalResource(\n                \"slowRequestHandler\")));\n        addComponent(new Link(\"Start download\", new ExternalResource(\n                \"slowRequestHandler?download\")));\n    }","cleancode":"@override protected void setup(vaadinrequest request) { addcomponent(new progressindicator() { { registerrpc(new progressindicatorserverrpc() { @override public void poll() { try { thread.sleep(1000); } catch (interruptedexception e) { e.printstacktrace(); } } }); setpollinginterval(3000); } }); addcomponent(new link(\"navigate away\", new externalresource( \"slowrequesthandler\"))); addcomponent(new link(\"start download\", new externalresource( \"slowrequesthandler?download\"))); }","repo":"allanim\/vaadin","label":[0,0,1,0]}
{"id":23397,"original_code":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\n        boolean alreadyRemaped=false;\n        final String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\n        if(charGlyph!=null){\n            final int newRawInt=currentFontData.getDiffChar(charGlyph);\n            if(newRawInt!=-1){\n                glyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\n                glyphData.setDisplayValue(String.valueOf((char)newRawInt));\n                \/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n                \/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n                \/\/this is a sanity check to fix this mapping issue\n            }else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\n                final int altValue=StandardFonts.getAdobeMap(charGlyph);\n                \/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n                \/\/which breaks code further down so we reject this value\n                if(altValue>-1) {\n                    glyphData.setRawInt(altValue);\n                    glyphData.set(String.valueOf((char) altValue));\n                    alreadyRemaped = true;\n                }\n            }\n        }\n        return alreadyRemaped;\n    }","code_wo_comment":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\n        boolean alreadyRemaped=false;\n        final String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\n        if(charGlyph!=null){\n            final int newRawInt=currentFontData.getDiffChar(charGlyph);\n            if(newRawInt!=-1){\n                glyphData.setRawInt(newRawInt);\n                glyphData.setDisplayValue(String.valueOf((char)newRawInt));\n               \n               \n               \n            }else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\n                final int altValue=StandardFonts.getAdobeMap(charGlyph);\n               \n               \n                if(altValue>-1) {\n                    glyphData.setRawInt(altValue);\n                    glyphData.set(String.valueOf((char) altValue));\n                    alreadyRemaped = true;\n                }\n            }\n        }\n        return alreadyRemaped;\n    }","cleancode":"static boolean remapglyph(pdffont currentfontdata, glyphdata glyphdata){ boolean alreadyremaped=false; final string charglyph= currentfontdata.getmappedchar(glyphdata.getrawint(), false); if(charglyph!=null){ final int newrawint=currentfontdata.getdiffchar(charglyph); if(newrawint!=-1){ glyphdata.setrawint(newrawint); glyphdata.setdisplayvalue(string.valueof((char)newrawint)); }else if(!glyphdata.getdisplayvalue().isempty() && glyphdata.getdisplayvalue().charat(0)<32){ final int altvalue=standardfonts.getadobemap(charglyph); if(altvalue>-1) { glyphdata.setrawint(altvalue); glyphdata.set(string.valueof((char) altvalue)); alreadyremaped = true; } } } return alreadyremaped; }","repo":"UprootStaging\/maven-OpenViewerFX-src","label":[0,0,1,0]}
{"id":31695,"original_code":"@Override\n    @Nonnull\n    public MutableVfsItem getMutableItem(RepoPath repoPath) {\n        \/\/TORE: [by YS] should be storing repo once interfaces refactoring is done\n        LocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\n        if (localRepo != null) {\n            MutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\n            if (mutableFsItem != null) {\n                return mutableFsItem;\n            }\n        }\n        throw new ItemNotFoundRuntimeException(repoPath);\n    }","code_wo_comment":"@Override\n    @Nonnull\n    public MutableVfsItem getMutableItem(RepoPath repoPath) {\n       \n        LocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\n        if (localRepo != null) {\n            MutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\n            if (mutableFsItem != null) {\n                return mutableFsItem;\n            }\n        }\n        throw new ItemNotFoundRuntimeException(repoPath);\n    }","cleancode":"@override @nonnull public mutablevfsitem getmutableitem(repopath repopath) { localrepo localrepo = localorcachedrepositorybykey(repopath.getrepokey()); if (localrepo != null) { mutablevfsitem mutablefsitem = localrepo.getmutablefsitem(repopath); if (mutablefsitem != null) { return mutablefsitem; } } throw new itemnotfoundruntimeexception(repopath); }","repo":"alancnet\/artifactory","label":[1,0,0,0]}
{"id":15371,"original_code":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\n    container.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    SootMethod target = ie.getMethod();\n    target.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    \/*\n     * This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n     * definition of invokespecial.\n     *\/\n    if (\"<init>\".equals(target.getName()) || target.isPrivate()) {\n      return target;\n    } else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\n      return resolveConcreteDispatch(container.getDeclaringClass(), target);\n    } else {\n      return target;\n    }\n  }","code_wo_comment":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\n    container.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    SootMethod target = ie.getMethod();\n    target.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n   \n    if (\"<init>\".equals(target.getName()) || target.isPrivate()) {\n      return target;\n    } else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\n      return resolveConcreteDispatch(container.getDeclaringClass(), target);\n    } else {\n      return target;\n    }\n  }","cleancode":"public sootmethod resolvespecialdispatch(specialinvokeexpr ie, sootmethod container) { container.getdeclaringclass().checklevel(sootclass.hierarchy); sootmethod target = ie.getmethod(); target.getdeclaringclass().checklevel(sootclass.hierarchy); if (\"<init>\".equals(target.getname()) || target.isprivate()) { return target; } else if (isclasssubclassof(target.getdeclaringclass(), container.getdeclaringclass())) { return resolveconcretedispatch(container.getdeclaringclass(), target); } else { return target; } }","repo":"UCLA-SEAL\/JShrink","label":[1,0,0,0]}
{"id":15595,"original_code":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int dataPointId) {\n\t\t\/\/ TODO: how to identify the correct device if there are several devices in the\n\t\t\/\/ list?\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\t\t\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\t\tfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\n\t\treturn knxComObjects;\n\t}","code_wo_comment":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int dataPointId) {\n\t\n\t\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\t\n\t\tfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\n\t\treturn knxComObjects;\n\t}","cleancode":"public static list<knxcomobject> retrievecomobjectlistbydatapointid(final knxproject knxproject, final int datapointid) { final knxdeviceinstance knxdeviceinstance = knxproject.getdeviceinstances().get(0); final list<knxcomobject> knxcomobjects = knxdeviceinstance.getcomobjects().values().stream() .filter(c -> c.getnumber() == datapointid).filter(c -> c.isgroupobject()).collect(collectors.tolist()); return knxcomobjects; }","repo":"Thewbi\/knx_meister","label":[1,0,0,0]}
{"id":15596,"original_code":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int deviceIndex, final int dataPointId) {\n\t\t\/\/ TODO: how to identify the correct device if there are several devices in the\n\t\t\/\/ list?\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\t\t\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\t\t\/\/ @formatter:off\n\t\treturn knxDeviceInstance\n\t\t\t\t.getComObjects()\n\t\t\t\t.values()\n\t\t\t\t.stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId)\n\t\t\t\t.filter(c -> c.isGroupObject())\n\t\t\t\t.findFirst();\n\t\t\/\/ @formatter:on\n\t}","code_wo_comment":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int deviceIndex, final int dataPointId) {\n\t\n\t\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\t\n\t\n\t\treturn knxDeviceInstance\n\t\t\t\t.getComObjects()\n\t\t\t\t.values()\n\t\t\t\t.stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId)\n\t\t\t\t.filter(c -> c.isGroupObject())\n\t\t\t\t.findFirst();\n\t\n\t}","cleancode":"public static optional<knxcomobject> retrievecomobjectbydatapointid(final knxproject knxproject, final int deviceindex, final int datapointid) { final knxdeviceinstance knxdeviceinstance = knxproject.getdeviceinstances().get(deviceindex); return knxdeviceinstance .getcomobjects() .values() .stream() .filter(c -> c.getnumber() == datapointid) .filter(c -> c.isgroupobject()) .findfirst(); }","repo":"Thewbi\/knx_meister","label":[1,0,0,0]}
{"id":23864,"original_code":"private Expression _buildExpression() {\n    \t\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\n    \tExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n    \t\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n    \t\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\n    \tPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n    \t\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\n    \tMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n    \t\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\n    \twhile (_formulaVarMatcher.find()) {\n    \t\t\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\n    \t\tfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n    \t\t\t\/\/ Set ith match from regex as a variable in the formula expression builder\n    \t\t\t_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n    \t\t}\n    \t}\n    \t\/\/ Once regex stuff is done and variables are set, properly build the expression.\n    \tExpression _formulaExpression = _formulaExpressionBuilder.build();\n    \treturn _formulaExpression;\n    }","code_wo_comment":"private Expression _buildExpression() {\n    \n    \tExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n    \n    \n    \tPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n    \n    \tMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n    \n    \twhile (_formulaVarMatcher.find()) {\n    \t\n    \t\tfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n    \t\t\n    \t\t\t_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n    \t\t}\n    \t}\n    \n    \tExpression _formulaExpression = _formulaExpressionBuilder.build();\n    \treturn _formulaExpression;\n    }","cleancode":"private expression _buildexpression() { expressionbuilder _formulaexpressionbuilder = new expressionbuilder(this._formulaequation); pattern _formularegex = new pattern.compile(\"\\s?_[a-za-z0-9_]*_\\s?\"); matcher _formulavarmatcher = new _formularegex.matcher(this._formulaequation); while (_formulavarmatcher.find()) { for (int i=1; i<=_formulavarmatcher.groupcount(); i++) { _formulaexpressionbuilder.variable(_formulavarmatcher.group(i)); } } expression _formulaexpression = _formulaexpressionbuilder.build(); return _formulaexpression; }","repo":"ambedrake\/UniversalAuthenticatedReportGenerator","label":[0,1,0,0]}
{"id":32072,"original_code":"private void craftRecipe( Recipe<?> currentRecipe)\n    {\n        if (currentRecipe != null && this.canAcceptRecipeOutput(currentRecipe))\n        {\n            ItemStack inputStack = this.inventory.get(0);\n            ItemStack outputStack = this.inventory.get(2);\n            ItemStack recipeResultStack = currentRecipe.getOutput();\n            int resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\n            if (outputStack.isEmpty())\n            {\n                ItemStack newResultStack = recipeResultStack.copy();\n                newResultStack.setAmount(resultCount);\n                this.inventory.set(2, newResultStack);\n            }\n            else if (outputStack.getItem() == recipeResultStack.getItem())\n            {\n                \/\/ TODO: WHAT HAPPENS IF FINAL COUNT IS 63 AND WE SMELT DOUBLE?\n                outputStack.addAmount(resultCount);\n            }\n            if (!this.world.isClient)\n                this.setLastRecipe(currentRecipe);\n            if (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n            {\n                this.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n            }\n            inputStack.subtractAmount(1);\n        }\n    }","code_wo_comment":"private void craftRecipe( Recipe<?> currentRecipe)\n    {\n        if (currentRecipe != null && this.canAcceptRecipeOutput(currentRecipe))\n        {\n            ItemStack inputStack = this.inventory.get(0);\n            ItemStack outputStack = this.inventory.get(2);\n            ItemStack recipeResultStack = currentRecipe.getOutput();\n            int resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\n            if (outputStack.isEmpty())\n            {\n                ItemStack newResultStack = recipeResultStack.copy();\n                newResultStack.setAmount(resultCount);\n                this.inventory.set(2, newResultStack);\n            }\n            else if (outputStack.getItem() == recipeResultStack.getItem())\n            {\n               \n                outputStack.addAmount(resultCount);\n            }\n            if (!this.world.isClient)\n                this.setLastRecipe(currentRecipe);\n            if (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n            {\n                this.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n            }\n            inputStack.subtractAmount(1);\n        }\n    }","cleancode":"private void craftrecipe( recipe<?> currentrecipe) { if (currentrecipe != null && this.canacceptrecipeoutput(currentrecipe)) { itemstack inputstack = this.inventory.get(0); itemstack outputstack = this.inventory.get(2); itemstack reciperesultstack = currentrecipe.getoutput(); int resultcount = world.random.nextint(100) < dupechance100 ? 2 : 1; if (outputstack.isempty()) { itemstack newresultstack = reciperesultstack.copy(); newresultstack.setamount(resultcount); this.inventory.set(2, newresultstack); } else if (outputstack.getitem() == reciperesultstack.getitem()) { outputstack.addamount(resultcount); } if (!this.world.isclient) this.setlastrecipe(currentrecipe); if (inputstack.getitem() == blocks.wet_sponge.getitem() && !((itemstack) this.inventory.get(1)).isempty() && ((itemstack) this.inventory.get(1)).getitem() == items.bucket) { this.inventory.set(1, new itemstack(items.water_bucket)); } inputstack.subtractamount(1); } }","repo":"XuyuEre\/fabric-furnaces","label":[1,0,0,0]}
{"id":7716,"original_code":"public void mergeSort(Card[] cardArray)\n    {\n        \/\/ TODO: implement this method (in an iterative way)\n    }","code_wo_comment":"public void mergeSort(Card[] cardArray)\n    {\n       \n    }","cleancode":"public void mergesort(card[] cardarray) { }","repo":"Sailia\/data_structures","label":[0,1,0,0]}
{"id":7891,"original_code":"@Test\n    public void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\n        when(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\n        when(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\n        when(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\n        ResultActions results = mockMvc\n                .perform(\n                    get(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n                .andDo(print());\n        results\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andExpect(jsonPath(\"$.*\").isArray())\n                .andExpect(jsonPath(\"$.*\",hasSize(4)))\n                .andReturn();\n    }","code_wo_comment":"@Test\n    public void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\n        when(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\n        when(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\n        when(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\n        ResultActions results = mockMvc\n                .perform(\n                    get(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n                .andDo(print());\n        results\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andExpect(jsonPath(\"$.*\").isArray())\n                .andExpect(jsonPath(\"$.*\",hasSize(4)))\n                .andReturn();\n    }","cleancode":"@test public void findallsubcomments_for_comment_returns_collection_status_isfound() throws exception{ when(commentservice.findcommentsbycommentparentid(anyint())).thenreturn(arrays.aslist(comments)); when(userservice.finduserbyid(anyint())).thenreturn(optional.of(user)); when(commentlikeservice.checkifcommentisliked(any(comment.class), any(user.class))).thenreturn(true); resultactions results = mockmvc .perform( get(\"\/microblogging\/v1\/comment\/2?requesteduserid=1\")) .anddo(print()); results .andexpect(status().isok()) .andexpect(content().contenttype(mediatype.application_json)) .andexpect(jsonpath(\"$.*\").isarray()) .andexpect(jsonpath(\"$.*\",hassize(4))) .andreturn(); }","repo":"Yarulika\/Microblogging","label":[0,0,0,1]}
{"id":16097,"original_code":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n\t{\n\t\tFileHandler fileHandler = null; \n\t\ttry\n\t\t{\n\t\t\tTool tool = getTool();\n\t\t\tfileHandler = tool.getToolResource().getFileHandler();\n\t\t\tString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\n\t\t\tList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\t\t\t\/*\n\t\t\tlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" + \n\t\t\t\tlist.size() + \" files.\");\n\t\t\t*\/\n\t\t\treturn list;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (fileHandler != null)\n\t\t\t{\n\t\t\t\tfileHandler.close();\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n\t{\n\t\tFileHandler fileHandler = null; \n\t\ttry\n\t\t{\n\t\t\tTool tool = getTool();\n\t\t\tfileHandler = tool.getToolResource().getFileHandler();\n\t\t\tString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\n\t\t\tList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\t\t\n\t\t\treturn list;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (fileHandler != null)\n\t\t\t{\n\t\t\t\tfileHandler.close();\n\t\t\t}\n\t\t}\n\t}","cleancode":"public list<filehandler.fileattributes> listworkingdirectory() throws ioexception, exception { filehandler filehandler = null; try { tool tool = gettool(); filehandler = tool.gettoolresource().getfilehandler(); string workingdirectory = tool.gettoolresource().getworkingdirectory(task.getjobhandle()); list<filehandler.fileattributes> list = filehandler.list(workingdirectory); return list; } finally { if (filehandler != null) { filehandler.close(); } } }","repo":"SciGaP\/DEPRECATED-Cipres-Airavata-POC","label":[1,0,0,0]}
{"id":8012,"original_code":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n    {\n        IResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(), \n                NamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\n        InstructionList callInContext = new InstructionList();\n        callInContext.addInstruction(ABCConstants.OP_getlocal1);\n        callInContext.addInstruction(ABCConstants.OP_getlocal2);\n        callInContext.addInstruction(ABCConstants.OP_getlocal3);\n        callInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\n        callInContext.addInstruction(ABCConstants.OP_getlocal, 4);\n        Label callInContextReturnVoid = new Label();\n        callInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        callInContext.labelNext(callInContextReturnVoid);\n        \/\/ TODO This should be OP_returnvoid, but the Boolean default value\n        \/\/ for the 'returns' parameter isn't defaulting to true.\n        \/\/ Fix this after CMP-936 is fixed.\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        ImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n                .add(new Name(IASLanguageConstants.Function))\n                .add(new Name(IASLanguageConstants.Object))\n                .add(new Name(IASLanguageConstants.Array))\n                .add(new Name(IASLanguageConstants.Boolean))\n                .build();\n        classGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null, \n                Collections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n    }","code_wo_comment":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n    {\n        IResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(), \n                NamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\n        InstructionList callInContext = new InstructionList();\n        callInContext.addInstruction(ABCConstants.OP_getlocal1);\n        callInContext.addInstruction(ABCConstants.OP_getlocal2);\n        callInContext.addInstruction(ABCConstants.OP_getlocal3);\n        callInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\n        callInContext.addInstruction(ABCConstants.OP_getlocal, 4);\n        Label callInContextReturnVoid = new Label();\n        callInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        callInContext.labelNext(callInContextReturnVoid);\n       \n       \n       \n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        ImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n                .add(new Name(IASLanguageConstants.Function))\n                .add(new Name(IASLanguageConstants.Object))\n                .add(new Name(IASLanguageConstants.Array))\n                .add(new Name(IASLanguageConstants.Boolean))\n                .build();\n        classGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null, \n                Collections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n    }","cleancode":"protected final void codegencallincontextmethod(classgeneratorhelper classgen, boolean isoverride) { iresolvedqualifiersreference applyreference = referencefactory.resolvedqualifierqualifiedreference(royaleproject.getworkspace(), namespacedefinition.getas3namespacedefinition(), \"apply\"); instructionlist callincontext = new instructionlist(); callincontext.addinstruction(abcconstants.op_getlocal1); callincontext.addinstruction(abcconstants.op_getlocal2); callincontext.addinstruction(abcconstants.op_getlocal3); callincontext.addinstruction(abcconstants.op_callproperty, new object[] {applyreference.getmname(), 2}); callincontext.addinstruction(abcconstants.op_getlocal, 4); label callincontextreturnvoid = new label(); callincontext.addinstruction(abcconstants.op_iffalse, callincontextreturnvoid); callincontext.addinstruction(abcconstants.op_returnvalue); callincontext.labelnext(callincontextreturnvoid); callincontext.addinstruction(abcconstants.op_returnvalue); immutablelist<name> callincontextparams = new immutablelist.builder<name>() .add(new name(iaslanguageconstants.function)) .add(new name(iaslanguageconstants.object)) .add(new name(iaslanguageconstants.array)) .add(new name(iaslanguageconstants.boolean)) .build(); classgen.additraitsmethod(new name(\"callincontext\"), callincontextparams, null, collections.<object> singletonlist(boolean.true), false, true, isoverride, callincontext); }","repo":"alinakazi\/apache-royale-0.9.8-bin-js-swf","label":[1,0,0,0]}
{"id":16242,"original_code":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total();        \/\/ TODO add your handling code here:\n    }","code_wo_comment":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\n    }","cleancode":"private void rhkeyreleased(java.awt.event.keyevent evt) { }","repo":"ajpro-byte\/ClinicMGMT","label":[0,1,0,0]}
{"id":16243,"original_code":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n \/\/calc_total();        \/\/ TODO add your handling code here:\n if (ri.isEnabled()==true){\n calc_total();\n }else{\n }\n    }","code_wo_comment":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\n if (ri.isEnabled()==true){\n calc_total();\n }else{\n }\n    }","cleancode":"private void rikeyreleased(java.awt.event.keyevent evt) { if (ri.isenabled()==true){ calc_total(); }else{ } }","repo":"ajpro-byte\/ClinicMGMT","label":[0,1,0,0]}

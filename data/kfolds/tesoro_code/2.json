{"id":24717,"original_code":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\t\tStudy study = ControllerUtil.findStudy(request, mStudyService);\n\t\tSubmission submission = (Submission) study.getSubmission();\n\t\tStudyCommand studyCommand = new StudyCommand();\n\t\t\/\/ copy study information\n\t\tstudyCommand.setStudy(study);\n\t\t\/\/ study from TBI do not contain submission_id\n\t\tif (submission != null) {\n\t\t\tstudyCommand.setSubmission_id(submission.getId());\n\t\t}\n\t\tList<Analysis> analysisList = study.getAnalyses();\n\t\tList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\n\t\tList<Analysis> changedAnalyses = new ArrayList<Analysis>();\n\t\tStringBuilder errBuilder = new StringBuilder();\n\t\tfor (Analysis analysis : analysisList) {\n\t\t\t\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\t\t\t\/\/ we this controller will extend BaseFormController.\n\t\t\tif (!analysis.getValidated()) {\n\t\t\t\tExecutionResult result = analysis.validate();\n\t\t\t\tif (!result.isSuccessful()) {\n\t\t\t\t\terrBuilder.append(result.getErrorMessage());\n\t\t\t\t}\n\t\t\t\tif (analysis.getValidated()) {\n\t\t\t\t\t\/\/ save to db if the validated flag is updated:\n\t\t\t\t\tchangedAnalyses.add(analysis);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/FIXME: display err message in GUI\n\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n\t\t\t}\n\t\t\t\/\/\n\t\t\t\/\/ Analysis\n\t\t\tAnalysisCommand analysisCommand = new AnalysisCommand();\n\t\t\tBeanUtils.copyProperties(analysisCommand, analysis);\n\t\t\t\/\/ Analysis Steps for Analysis and add algorithm type\n\t\t\tList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\n\t\t\tList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\t\t\tfor (AnalysisStep analysisStep : analysisStepList) {\n\t\t\t\tAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\n\t\t\t\tBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\t\t\t\t\/\/ analysisStepCommand.setId(analysisStep.getId());\n\t\t\t\t\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\n\t\t\t\tAlgorithm algorithm = analysisStep.getAlgorithmInfo();\n\t\t\t\tString algorithmType = new String();\n\t\t\t\tif (algorithm instanceof LikelihoodAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n\t\t\t\t} else if (algorithm instanceof ParsimonyAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_PARSIMONY;\n\t\t\t\t}  else if (algorithm instanceof OtherAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_OTHER;\n\t\t\t\t}else if (algorithm instanceof BayesianAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Bayesian;\n\t\t\t\t} else if (algorithm instanceof EvolutionAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Evolution;\n\t\t\t\t} else if (algorithm instanceof JoiningAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Joining;\n\t\t\t} else if (algorithm instanceof UPGMAAlgorithm) {\n\t\t\t\talgorithmType = Constants.ALGORITHM_UPGMA;\t\n\t\t\t}\n\t\t\t\t\/\/ add algorithm type for analysisStepCommand\n\t\t\t\tanalysisStepCommand.setAlgorithmType(algorithmType);\n\t\t\t\t\/\/ analyzed data for each analysis step\n\t\t\t\tList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\n\t\t\t\tList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\t\t\t\t\/\/ Matrix or Tree?\n\t\t\t\tfor (AnalyzedData analyzedData : analyzedDataSet) {\n\t\t\t\t\tAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\n\t\t\t\t\tBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\n\t\t\t\t\tString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\n\t\t\t\t\tanalyzedDataCommand.setInputOutputType(inputOutput);\n\t\t\t\t\tif (analyzedData instanceof AnalyzedMatrix) {\n\t\t\t\t\t\tAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedMatrix.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n\t\t\t\t\t} else if (analyzedData instanceof AnalyzedTree) {\n\t\t\t\t\t\tAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.TREE_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedTree.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n\t\t\t\t\t}\n\t\t\t\t\tanalyzedDataCommandList.add(analyzedDataCommand);\n\t\t\t\t} \/\/ end for\n\t\t\t\t\/\/ add analyzedData for analysisStepCommand\n\t\t\t\tCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\n\t\t\t\tanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\n\t\t\t\tanalysisStepCommandList.add(analysisStepCommand);\n\t\t\t}\n\t\t\tanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\n\t\t\tanalysisCommandList.add(analysisCommand);\n\t\t}\n\t\tgetStudyService().updateCollection(changedAnalyses);\n\t\tstudyCommand.setAnalysisCommandList(analysisCommandList);\n\t\treturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n\t}","code":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\t\tStudy study = ControllerUtil.findStudy(request, mStudyService);\n\t\tSubmission submission = (Submission) study.getSubmission();\n\t\tStudyCommand studyCommand = new StudyCommand();\n\t\n\t\tstudyCommand.setStudy(study);\n\t\n\t\tif (submission != null) {\n\t\t\tstudyCommand.setSubmission_id(submission.getId());\n\t\t}\n\t\tList<Analysis> analysisList = study.getAnalyses();\n\t\tList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\n\t\tList<Analysis> changedAnalyses = new ArrayList<Analysis>();\n\t\tStringBuilder errBuilder = new StringBuilder();\n\t\tfor (Analysis analysis : analysisList) {\n\t\t\n\t\t\n\t\t\tif (!analysis.getValidated()) {\n\t\t\t\tExecutionResult result = analysis.validate();\n\t\t\t\tif (!result.isSuccessful()) {\n\t\t\t\t\terrBuilder.append(result.getErrorMessage());\n\t\t\t\t}\n\t\t\t\tif (analysis.getValidated()) {\n\t\t\t\t\n\t\t\t\t\tchangedAnalyses.add(analysis);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (LOGGER.isDebugEnabled()) {\n\t\t\t\tLOGGER.debug(errBuilder.toString());\n\t\t\t}\n\t\t\n\t\t\n\t\t\tAnalysisCommand analysisCommand = new AnalysisCommand();\n\t\t\tBeanUtils.copyProperties(analysisCommand, analysis);\n\t\t\n\t\t\tList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\n\t\t\tList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\t\t\tfor (AnalysisStep analysisStep : analysisStepList) {\n\t\t\t\tAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\n\t\t\t\tBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\t\t\t\n\t\t\t\n\t\t\t\tAlgorithm algorithm = analysisStep.getAlgorithmInfo();\n\t\t\t\tString algorithmType = new String();\n\t\t\t\tif (algorithm instanceof LikelihoodAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n\t\t\t\t} else if (algorithm instanceof ParsimonyAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_PARSIMONY;\n\t\t\t\t}  else if (algorithm instanceof OtherAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_OTHER;\n\t\t\t\t}else if (algorithm instanceof BayesianAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Bayesian;\n\t\t\t\t} else if (algorithm instanceof EvolutionAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Evolution;\n\t\t\t\t} else if (algorithm instanceof JoiningAlgorithm) {\n\t\t\t\t\talgorithmType = Constants.ALGORITHM_Joining;\n\t\t\t} else if (algorithm instanceof UPGMAAlgorithm) {\n\t\t\t\talgorithmType = Constants.ALGORITHM_UPGMA;\t\n\t\t\t}\n\t\t\t\n\t\t\t\tanalysisStepCommand.setAlgorithmType(algorithmType);\n\t\t\t\n\t\t\t\tList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\n\t\t\t\tList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\t\t\t\n\t\t\t\tfor (AnalyzedData analyzedData : analyzedDataSet) {\n\t\t\t\t\tAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\n\t\t\t\t\tBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\n\t\t\t\t\tString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\n\t\t\t\t\tanalyzedDataCommand.setInputOutputType(inputOutput);\n\t\t\t\t\tif (analyzedData instanceof AnalyzedMatrix) {\n\t\t\t\t\t\tAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedMatrix.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n\t\t\t\t\t} else if (analyzedData instanceof AnalyzedTree) {\n\t\t\t\t\t\tAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\n\t\t\t\t\t\tanalyzedDataCommand.setDataType(Constants.TREE_KEY);\n\t\t\t\t\t\tanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\n\t\t\t\t\t\tanalyzedDataCommand.setId(analyzedTree.getId());\n\t\t\t\t\t\tanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n\t\t\t\t\t}\n\t\t\t\t\tanalyzedDataCommandList.add(analyzedDataCommand);\n\t\t\t\t}\n\t\t\t\n\t\t\t\tCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\n\t\t\t\tanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\n\t\t\t\tanalysisStepCommandList.add(analysisStepCommand);\n\t\t\t}\n\t\t\tanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\n\t\t\tanalysisCommandList.add(analysisCommand);\n\t\t}\n\t\tgetStudyService().updateCollection(changedAnalyses);\n\t\tstudyCommand.setAnalysisCommandList(analysisCommandList);\n\t\treturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n\t}","cleancode":"public modelandview handlerequest(httpservletrequest request, httpservletresponse response) throws exception { study study = controllerutil.findstudy(request, mstudyservice); submission submission = (submission) study.getsubmission(); studycommand studycommand = new studycommand(); studycommand.setstudy(study); if (submission != null) { studycommand.setsubmission_id(submission.getid()); } list<analysis> analysislist = study.getanalyses(); list<analysiscommand> analysiscommandlist = new arraylist<analysiscommand>(); list<analysis> changedanalyses = new arraylist<analysis>(); stringbuilder errbuilder = new stringbuilder(); for (analysis analysis : analysislist) { if (!analysis.getvalidated()) { executionresult result = analysis.validate(); if (!result.issuccessful()) { errbuilder.append(result.geterrormessage()); } if (analysis.getvalidated()) { changedanalyses.add(analysis); } } if (logger.isdebugenabled()) { logger.debug(errbuilder.tostring()); } analysiscommand analysiscommand = new analysiscommand(); beanutils.copyproperties(analysiscommand, analysis); list<analysisstep> analysissteplist = analysis.getanalysisstepsreadonly(); list<analysisstepcommand> analysisstepcommandlist = new arraylist<analysisstepcommand>(); for (analysisstep analysisstep : analysissteplist) { analysisstepcommand analysisstepcommand = new analysisstepcommand(); beanutils.copyproperties(analysisstepcommand, analysisstep); algorithm algorithm = analysisstep.getalgorithminfo(); string algorithmtype = new string(); if (algorithm instanceof likelihoodalgorithm) { algorithmtype = constants.algorithm_likelihood; } else if (algorithm instanceof parsimonyalgorithm) { algorithmtype = constants.algorithm_parsimony; } else if (algorithm instanceof otheralgorithm) { algorithmtype = constants.algorithm_other; }else if (algorithm instanceof bayesianalgorithm) { algorithmtype = constants.algorithm_bayesian; } else if (algorithm instanceof evolutionalgorithm) { algorithmtype = constants.algorithm_evolution; } else if (algorithm instanceof joiningalgorithm) { algorithmtype = constants.algorithm_joining; } else if (algorithm instanceof upgmaalgorithm) { algorithmtype = constants.algorithm_upgma; } analysisstepcommand.setalgorithmtype(algorithmtype); list<analyzeddata> analyzeddataset = analysisstep.getdatasetreadonly(); list<analyzeddatacommand> analyzeddatacommandlist = new arraylist<analyzeddatacommand>(); for (analyzeddata analyzeddata : analyzeddataset) { analyzeddatacommand analyzeddatacommand = new analyzeddatacommand(); beanutils.copyproperties(analyzeddatacommand, analyzeddata); string inputoutput = (analyzeddata.isinputdata()) ? (\"input\") : (\"output\"); analyzeddatacommand.setinputoutputtype(inputoutput); if (analyzeddata instanceof analyzedmatrix) { analyzedmatrix analyzedmatrix = (analyzedmatrix) analyzeddata; analyzeddatacommand.setdatatype(constants.matrix_key); analyzeddatacommand.setdisplayname(analyzedmatrix.getmatrix().gettitle()); analyzeddatacommand.setid(analyzedmatrix.getid()); analyzeddatacommand.setdataid(analyzedmatrix.getmatrix().getid()); } else if (analyzeddata instanceof analyzedtree) { analyzedtree analyzedtree = (analyzedtree) analyzeddata; analyzeddatacommand.setdatatype(constants.tree_key); analyzeddatacommand.setdisplayname(analyzedtree.gettree().getlabel()); analyzeddatacommand.setid(analyzedtree.getid()); analyzeddatacommand.setdataid(analyzedtree.gettree().getid()); } analyzeddatacommandlist.add(analyzeddatacommand); } collections.sort(analyzeddatacommandlist, new analyzeddatacomparator()); analysisstepcommand.setanalyzeddatacommandlist(analyzeddatacommandlist); analysisstepcommandlist.add(analysisstepcommand); } analysiscommand.setanalysisstepcommandlist(analysisstepcommandlist); analysiscommandlist.add(analysiscommand); } getstudyservice().updatecollection(changedanalyses); studycommand.setanalysiscommandlist(analysiscommandlist); return new modelandview(\"analysissection\", constants.study_command_key, studycommand); }","comment":"\/** * * @see org.springframework.web.servlet.mvc.controller#handlerequest(javax.servlet.http.httpservletrequest, * javax.servlet.http.httpservletresponse) *\/\n\/\/ copy study information\n\/\/ study from tbi do not contain submission_id\n\/\/ fixme: next if block needs to me moved to the onsumbit method when \/\/ we this controller will extend baseformcontroller.\n\/\/ save to db if the validated flag is updated:\n\/\/fixme: display err message in gui\n\/\/$non-nls-1$\n\/\/ \/\/ analysis\n\/\/ analysis steps for analysis and add algorithm type\n\/\/ analysisstepcommand.setid(analysisstep.getid()); \/\/ analysisstepcommand.setsoftwareinfo(analysisstep.getsoftwareinfo());\n\/\/ add algorithm type for analysisstepcommand\n\/\/ analyzed data for each analysis step\n\/\/ matrix or tree?\n\/\/ end for\n\/\/ add analyzeddata for analysisstepcommand","repo":"TreeBASE\/treebasetest","code_context_2":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n}\n\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\n\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\n\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\n\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\n\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\n\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\n\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\n\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);","code_context_10":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n}\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\n\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\n\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\n\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\n\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\n\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\n\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\n\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\n\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);","code_context_20":"public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n}\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\n\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\n\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\n\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\n\npublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)\nthrows Exception {\nStudy study = ControllerUtil.findStudy(request, mStudyService);\nSubmission submission = (Submission) study.getSubmission();\nStudyCommand studyCommand = new StudyCommand();\n\/\/ copy study information\nstudyCommand.setStudy(study);\n\/\/ study from TBI do not contain submission_id\nif (submission != null) {\nstudyCommand.setSubmission_id(submission.getId());\n}\nList<Analysis> analysisList = study.getAnalyses();\nList<AnalysisCommand> analysisCommandList = new ArrayList<AnalysisCommand>();\nList<Analysis> changedAnalyses = new ArrayList<Analysis>();\nStringBuilder errBuilder = new StringBuilder();\nfor (Analysis analysis : analysisList) {\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n\n\/\/ FIXME: next if block needs to me moved to the onSumbit method when\n\/\/ we this controller will extend BaseFormController.\nif (!analysis.getValidated()) {\nExecutionResult result = analysis.validate();\nif (!result.isSuccessful()) {\nerrBuilder.append(result.getErrorMessage());\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\n\n}\nif (analysis.getValidated()) {\n\/\/ save to db if the validated flag is updated:\nchangedAnalyses.add(analysis);\n}\n}\n\/\/FIXME: display err message in GUI\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(errBuilder.toString()); \/\/$NON-NLS-1$\n}\n\/\/\n\/\/ Analysis\nAnalysisCommand analysisCommand = new AnalysisCommand();\nBeanUtils.copyProperties(analysisCommand, analysis);\n\/\/ Analysis Steps for Analysis and add algorithm type\nList<AnalysisStep> analysisStepList = analysis.getAnalysisStepsReadOnly();\nList<AnalysisStepCommand> analysisStepCommandList = new ArrayList<AnalysisStepCommand>();\nfor (AnalysisStep analysisStep : analysisStepList) {\nAnalysisStepCommand analysisStepCommand = new AnalysisStepCommand();\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\n\nBeanUtils.copyProperties(analysisStepCommand, analysisStep);\n\/\/ analysisStepCommand.setId(analysisStep.getId());\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\n\n\/\/ analysisStepCommand.setSoftwareInfo(analysisStep.getSoftwareInfo());\nAlgorithm algorithm = analysisStep.getAlgorithmInfo();\nString algorithmType = new String();\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n\nif (algorithm instanceof LikelihoodAlgorithm) {\nalgorithmType = Constants.ALGORITHM_LIKELIHOOD;\n} else if (algorithm instanceof ParsimonyAlgorithm) {\nalgorithmType = Constants.ALGORITHM_PARSIMONY;\n} else if (algorithm instanceof OtherAlgorithm) {\nalgorithmType = Constants.ALGORITHM_OTHER;\n}else if (algorithm instanceof BayesianAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Bayesian;\n} else if (algorithm instanceof EvolutionAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Evolution;\n} else if (algorithm instanceof JoiningAlgorithm) {\nalgorithmType = Constants.ALGORITHM_Joining;\n} else if (algorithm instanceof UPGMAAlgorithm) {\nalgorithmType = Constants.ALGORITHM_UPGMA;\n}\n\/\/ add algorithm type for analysisStepCommand\nanalysisStepCommand.setAlgorithmType(algorithmType);\n\/\/ analyzed data for each analysis step\nList<AnalyzedData> analyzedDataSet = analysisStep.getDataSetReadOnly();\nList<AnalyzedDataCommand> analyzedDataCommandList = new ArrayList<AnalyzedDataCommand>();\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\n\/\/ Matrix or Tree?\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n}\n\nfor (AnalyzedData analyzedData : analyzedDataSet) {\nAnalyzedDataCommand analyzedDataCommand = new AnalyzedDataCommand();\nBeanUtils.copyProperties(analyzedDataCommand, analyzedData);\nString inputOutput = (analyzedData.isInputData()) ? (\"Input\") : (\"Output\");\nanalyzedDataCommand.setInputOutputType(inputOutput);\nif (analyzedData instanceof AnalyzedMatrix) {\nAnalyzedMatrix analyzedMatrix = (AnalyzedMatrix) analyzedData;\nanalyzedDataCommand.setDataType(Constants.MATRIX_KEY);\nanalyzedDataCommand.setDisplayName(analyzedMatrix.getMatrix().getTitle());\nanalyzedDataCommand.setId(analyzedMatrix.getId());\nanalyzedDataCommand.setDataId(analyzedMatrix.getMatrix().getId());\n} else if (analyzedData instanceof AnalyzedTree) {\nAnalyzedTree analyzedTree = (AnalyzedTree) analyzedData;\nanalyzedDataCommand.setDataType(Constants.TREE_KEY);\nanalyzedDataCommand.setDisplayName(analyzedTree.getTree().getLabel());\nanalyzedDataCommand.setId(analyzedTree.getId());\nanalyzedDataCommand.setDataId(analyzedTree.getTree().getId());\n}\nanalyzedDataCommandList.add(analyzedDataCommand);\n} \/\/ end for\n\/\/ add analyzedData for analysisStepCommand\nCollections.sort(analyzedDataCommandList, new AnalyzedDataComparator());\nanalysisStepCommand.setAnalyzedDataCommandList(analyzedDataCommandList);\nanalysisStepCommandList.add(analysisStepCommand);\n}\nanalysisCommand.setAnalysisStepCommandList(analysisStepCommandList);\nanalysisCommandList.add(analysisCommand);\n}\ngetStudyService().updateCollection(changedAnalyses);\nstudyCommand.setAnalysisCommandList(analysisCommandList);\nreturn new ModelAndView(\"analysisSection\", Constants.STUDY_COMMAND_KEY, studyCommand);\n}","label":[0,1,1,0]}
{"id":148,"original_code":"private void addVar(Varlet v){\n\t\t\tlong key=key(v.chromosome, v.beginLoc);\n\t\t\tArrayList<Varlet> list=keymap.get(key);\n\t\t\tassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\n\t\t\tsynchronized(list){\n\t\t\t\tlist.add(v);\n\t\t\t\tif(list.size()>=WRITE_BUFFER){\n\t\t\t\t\tif(MERGE_EQUAL_VARLETS){\n\t\t\t\t\t\tmergeEqualVarlets(list);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tCollections.sort(list);\n\t\t\t\t\t}\n\t\t\t\t\twriteList(list);\n\t\t\t\t\tlist.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}","code":"private void addVar(Varlet v){\n\t\t\tlong key=key(v.chromosome, v.beginLoc);\n\t\t\tArrayList<Varlet> list=keymap.get(key);\n\t\t\tassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\n\t\t\tsynchronized(list){\n\t\t\t\tlist.add(v);\n\t\t\t\tif(list.size()>=WRITE_BUFFER){\n\t\t\t\t\tif(MERGE_EQUAL_VARLETS){\n\t\t\t\t\t\tmergeEqualVarlets(list);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tCollections.sort(list);\n\t\t\t\t\t}\n\t\t\t\t\twriteList(list);\n\t\t\t\t\tlist.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private void addvar(varlet v){ long key=key(v.chromosome, v.beginloc); arraylist<varlet> list=keymap.get(key); assert(list!=null) : \"\\ncan't find \"+key+\" in \"+keymap.keyset()+\"\\n\"; synchronized(list){ list.add(v); if(list.size()>=write_buffer){ if(merge_equal_varlets){ mergeequalvarlets(list); }else{ collections.sort(list); } writelist(list); list.clear(); } } }","comment":"\/** todo: synchronize once per read, not once per varlet *\/","repo":"SilasK\/BBMap","code_context_2":"private void addVar(Varlet v){\nlong key=key(v.chromosome, v.beginLoc);\nArrayList<Varlet> list=keymap.get(key);\nassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\nsynchronized(list){\nlist.add(v);\nif(list.size()>=WRITE_BUFFER){\nif(MERGE_EQUAL_VARLETS){\nmergeEqualVarlets(list);\n}else{\nCollections.sort(list);\n}\nwriteList(list);\nlist.clear();\n}\n}\n}","code_context_10":"private void addVar(Varlet v){\nlong key=key(v.chromosome, v.beginLoc);\nArrayList<Varlet> list=keymap.get(key);\nassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\nsynchronized(list){\nlist.add(v);\nif(list.size()>=WRITE_BUFFER){\nif(MERGE_EQUAL_VARLETS){\nmergeEqualVarlets(list);\n}else{\nCollections.sort(list);\n}\nwriteList(list);\nlist.clear();\n}\n}\n}","code_context_20":"private void addVar(Varlet v){\nlong key=key(v.chromosome, v.beginLoc);\nArrayList<Varlet> list=keymap.get(key);\nassert(list!=null) : \"\\nCan't find \"+key+\" in \"+keymap.keySet()+\"\\n\";\nsynchronized(list){\nlist.add(v);\nif(list.size()>=WRITE_BUFFER){\nif(MERGE_EQUAL_VARLETS){\nmergeEqualVarlets(list);\n}else{\nCollections.sort(list);\n}\nwriteList(list);\nlist.clear();\n}\n}\n}","label":[1,0,0,0]}
{"id":16664,"original_code":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\n\t\tswitch(driverType) {\n\t\t\tcase Chrome:\n\t\t\t\treturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\n\t\t\tcase Firefox:\n\t\t\t\treturn null; \/\/TODO: Make Firefox subclass\n\t\t\tcase IE:\n\t\t\t\treturn null; \/\/TODO: Make IE subclass\n\t\t\tcase Edge:\n\t\t\t\treturn null; \/\/TODO: Make Edge subclass\n\t\t\tcase Opera:\n\t\t\t\treturn null; \/\/TODO: Make Opera subclass\n\t\t\tcase Safari:\n\t\t\t\treturn null; \/\/TODO: Make Safari subclass\n\t\t\tcase iOS_iPhone:\n\t\t\t\treturn null; \/\/TODO: Make iOS_iPhone subclass\n\t\t\tcase iOS_iPad:\n\t\t\t\treturn null; \/\/TODO: Make iOS_iPad subclass\n\t\t\tcase Android:\n\t\t\t\treturn null; \/\/TODO: Make Android subclass\n\t\t\tcase HtmlUnit:\n\t\t\t\treturn null; \/\/TODO: Make HtmlUnit subclass\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}","code":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\n\t\tswitch(driverType) {\n\t\t\tcase Chrome:\n\t\t\t\treturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\n\t\t\tcase Firefox:\n\t\t\t\treturn null;\n\t\t\tcase IE:\n\t\t\t\treturn null;\n\t\t\tcase Edge:\n\t\t\t\treturn null;\n\t\t\tcase Opera:\n\t\t\t\treturn null;\n\t\t\tcase Safari:\n\t\t\t\treturn null;\n\t\t\tcase iOS_iPhone:\n\t\t\t\treturn null;\n\t\t\tcase iOS_iPad:\n\t\t\t\treturn null;\n\t\t\tcase Android:\n\t\t\t\treturn null;\n\t\t\tcase HtmlUnit:\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}","cleancode":"private nicewebdriver getnicewebdriverinstance(drivertype drivertype, object[] oargs){ switch(drivertype) { case chrome: return new nicechrome().underloadednicewebdriverconstructor(oargs).getthiswithverbositysetto(outputisverbose); case firefox: return null; case ie: return null; case edge: return null; case opera: return null; case safari: return null; case ios_iphone: return null; case ios_ipad: return null; case android: return null; case htmlunit: return null; default: return null; } }","comment":"\/\/todo: make firefox subclass\n\/\/todo: make ie subclass\n\/\/todo: make edge subclass\n\/\/todo: make opera subclass\n\/\/todo: make safari subclass\n\/\/todo: make ios_iphone subclass\n\/\/todo: make ios_ipad subclass\n\/\/todo: make android subclass\n\/\/todo: make htmlunit subclass","repo":"Skenvy\/SeleniumNG","code_context_2":"return new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\n\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\n\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\n\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\n\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\n\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\n\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\n\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\n\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;","code_context_10":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\n\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\n\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}","code_context_20":"private NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nprivate NiceWebDriver getNiceWebDriverInstance(DriverType driverType, Object[] oArgs){\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}\n\nswitch(driverType) {\ncase Chrome:\nreturn new NiceChrome().UnderloadedNiceWebDriverConstructor(oArgs).getThisWithVerbositySetTo(outputIsVerbose);\ncase Firefox:\nreturn null; \/\/TODO: Make Firefox subclass\ncase IE:\nreturn null; \/\/TODO: Make IE subclass\ncase Edge:\nreturn null; \/\/TODO: Make Edge subclass\ncase Opera:\nreturn null; \/\/TODO: Make Opera subclass\ncase Safari:\nreturn null; \/\/TODO: Make Safari subclass\ncase iOS_iPhone:\nreturn null; \/\/TODO: Make iOS_iPhone subclass\ncase iOS_iPad:\nreturn null; \/\/TODO: Make iOS_iPad subclass\ncase Android:\nreturn null; \/\/TODO: Make Android subclass\ncase HtmlUnit:\nreturn null; \/\/TODO: Make HtmlUnit subclass\ndefault:\nreturn null;\n}\n}","label":[0,1,0,0]}
{"id":33149,"original_code":"private void tag()\n        throws Exception\n    {\n        String[] asFilename = (String[])m_oCmdLineMap.get(\"filenames\");\n        for (int i=0; i < asFilename.length; i++)\n        {\n            File oSourceFile = new File(asFilename[i]);\n            MP3File oMP3File = new MP3File(oSourceFile);\n            if (m_oCmdLineMap.containsKey(\"1\"))\n            {\n                ID3V1_1Tag oID3V1_1Tag = new ID3V1_1Tag();\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V1_1Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V1_1Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V1_1Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    String sGenre = (String)m_oCmdLineMap.get(\"genre\");\n                    oID3V1_1Tag.setGenre(ID3V1Tag.Genre.lookupGenre(sGenre));\n                }\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V1_1Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V1_1Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).toString());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    oID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                }\n                oMP3File.setID3Tag(oID3V1_1Tag);\n            }\n            if (m_oCmdLineMap.containsKey(\"2\"))\n            {\n                ID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n                \/\/HACK: Need to have padding at the end of the tag, or Winamp won't see the last frame (at least 6 bytes seem to be required).\n                oID3V2_3_0Tag.setPaddingLength(16);\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V2_3_0Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    oID3V2_3_0Tag.setGenre((String)m_oCmdLineMap.get(\"genre\"));\n                }\n                oMP3File.setID3Tag(oID3V2_3_0Tag);\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V2_3_0Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V2_3_0Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).intValue());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    if (m_oCmdLineMap.containsKey(\"total\"))\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue(),\n                                                     ((Integer)m_oCmdLineMap.get(\"total\")).intValue());\n                    }\n                    else\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                    }\n                }\n            }\n            oMP3File.sync();\n        }\n    }","code":"private void tag()\n        throws Exception\n    {\n        String[] asFilename = (String[])m_oCmdLineMap.get(\"filenames\");\n        for (int i=0; i < asFilename.length; i++)\n        {\n            File oSourceFile = new File(asFilename[i]);\n            MP3File oMP3File = new MP3File(oSourceFile);\n            if (m_oCmdLineMap.containsKey(\"1\"))\n            {\n                ID3V1_1Tag oID3V1_1Tag = new ID3V1_1Tag();\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V1_1Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V1_1Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V1_1Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    String sGenre = (String)m_oCmdLineMap.get(\"genre\");\n                    oID3V1_1Tag.setGenre(ID3V1Tag.Genre.lookupGenre(sGenre));\n                }\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V1_1Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V1_1Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).toString());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    oID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                }\n                oMP3File.setID3Tag(oID3V1_1Tag);\n            }\n            if (m_oCmdLineMap.containsKey(\"2\"))\n            {\n                ID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n               \n                oID3V2_3_0Tag.setPaddingLength(16);\n                if (m_oCmdLineMap.containsKey(\"album\"))\n                {\n                    oID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"artist\"))\n                {\n                    oID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"comment\"))\n                {\n                    oID3V2_3_0Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"genre\"))\n                {\n                    oID3V2_3_0Tag.setGenre((String)m_oCmdLineMap.get(\"genre\"));\n                }\n                oMP3File.setID3Tag(oID3V2_3_0Tag);\n                if (m_oCmdLineMap.containsKey(\"title\"))\n                {\n                    oID3V2_3_0Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n                }\n                if (m_oCmdLineMap.containsKey(\"year\"))\n                {\n                    oID3V2_3_0Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).intValue());\n                }\n                if (m_oCmdLineMap.containsKey(\"track\"))\n                {\n                    if (m_oCmdLineMap.containsKey(\"total\"))\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue(),\n                                                     ((Integer)m_oCmdLineMap.get(\"total\")).intValue());\n                    }\n                    else\n                    {\n                        oID3V2_3_0Tag.setTrackNumber(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n                    }\n                }\n            }\n            oMP3File.sync();\n        }\n    }","cleancode":"private void tag() throws exception { string[] asfilename = (string[])m_ocmdlinemap.get(\"filenames\"); for (int i=0; i < asfilename.length; i++) { file osourcefile = new file(asfilename[i]); mp3file omp3file = new mp3file(osourcefile); if (m_ocmdlinemap.containskey(\"1\")) { id3v1_1tag oid3v1_1tag = new id3v1_1tag(); if (m_ocmdlinemap.containskey(\"album\")) { oid3v1_1tag.setalbum((string)m_ocmdlinemap.get(\"album\")); } if (m_ocmdlinemap.containskey(\"artist\")) { oid3v1_1tag.setartist((string)m_ocmdlinemap.get(\"artist\")); } if (m_ocmdlinemap.containskey(\"comment\")) { oid3v1_1tag.setcomment((string)m_ocmdlinemap.get(\"comment\")); } if (m_ocmdlinemap.containskey(\"genre\")) { string sgenre = (string)m_ocmdlinemap.get(\"genre\"); oid3v1_1tag.setgenre(id3v1tag.genre.lookupgenre(sgenre)); } if (m_ocmdlinemap.containskey(\"title\")) { oid3v1_1tag.settitle((string)m_ocmdlinemap.get(\"title\")); } if (m_ocmdlinemap.containskey(\"year\")) { oid3v1_1tag.setyear(((integer)m_ocmdlinemap.get(\"year\")).tostring()); } if (m_ocmdlinemap.containskey(\"track\")) { oid3v1_1tag.setalbumtrack(((integer)m_ocmdlinemap.get(\"track\")).intvalue()); } omp3file.setid3tag(oid3v1_1tag); } if (m_ocmdlinemap.containskey(\"2\")) { id3v2_3_0tag oid3v2_3_0tag = new id3v2_3_0tag(); oid3v2_3_0tag.setpaddinglength(16); if (m_ocmdlinemap.containskey(\"album\")) { oid3v2_3_0tag.setalbum((string)m_ocmdlinemap.get(\"album\")); } if (m_ocmdlinemap.containskey(\"artist\")) { oid3v2_3_0tag.setartist((string)m_ocmdlinemap.get(\"artist\")); } if (m_ocmdlinemap.containskey(\"comment\")) { oid3v2_3_0tag.setcomment((string)m_ocmdlinemap.get(\"comment\")); } if (m_ocmdlinemap.containskey(\"genre\")) { oid3v2_3_0tag.setgenre((string)m_ocmdlinemap.get(\"genre\")); } omp3file.setid3tag(oid3v2_3_0tag); if (m_ocmdlinemap.containskey(\"title\")) { oid3v2_3_0tag.settitle((string)m_ocmdlinemap.get(\"title\")); } if (m_ocmdlinemap.containskey(\"year\")) { oid3v2_3_0tag.setyear(((integer)m_ocmdlinemap.get(\"year\")).intvalue()); } if (m_ocmdlinemap.containskey(\"track\")) { if (m_ocmdlinemap.containskey(\"total\")) { oid3v2_3_0tag.settracknumber(((integer)m_ocmdlinemap.get(\"track\")).intvalue(), ((integer)m_ocmdlinemap.get(\"total\")).intvalue()); } else { oid3v2_3_0tag.settracknumber(((integer)m_ocmdlinemap.get(\"track\")).intvalue()); } } } omp3file.sync(); } }","comment":"\/\/hack: need to have padding at the end of the tag, or winamp won't see the last frame (at least 6 bytes seem to be required).","repo":"ShahzaibAyyub\/Music-Player-Library-Java-SQL","code_context_2":"{\nID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n\/\/HACK: Need to have padding at the end of the tag, or Winamp won't see the last frame (at least 6 bytes seem to be required).\noID3V2_3_0Tag.setPaddingLength(16);\nif (m_oCmdLineMap.containsKey(\"album\"))","code_context_10":"}\nif (m_oCmdLineMap.containsKey(\"track\"))\n{\noID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n}\noMP3File.setID3Tag(oID3V1_1Tag);\n}\nif (m_oCmdLineMap.containsKey(\"2\"))\n{\nID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n\/\/HACK: Need to have padding at the end of the tag, or Winamp won't see the last frame (at least 6 bytes seem to be required).\noID3V2_3_0Tag.setPaddingLength(16);\nif (m_oCmdLineMap.containsKey(\"album\"))\n{\noID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n}\nif (m_oCmdLineMap.containsKey(\"artist\"))\n{\noID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n}\nif (m_oCmdLineMap.containsKey(\"comment\"))","code_context_20":"String sGenre = (String)m_oCmdLineMap.get(\"genre\");\noID3V1_1Tag.setGenre(ID3V1Tag.Genre.lookupGenre(sGenre));\n}\nif (m_oCmdLineMap.containsKey(\"title\"))\n{\noID3V1_1Tag.setTitle((String)m_oCmdLineMap.get(\"title\"));\n}\nif (m_oCmdLineMap.containsKey(\"year\"))\n{\noID3V1_1Tag.setYear(((Integer)m_oCmdLineMap.get(\"year\")).toString());\n}\nif (m_oCmdLineMap.containsKey(\"track\"))\n{\noID3V1_1Tag.setAlbumTrack(((Integer)m_oCmdLineMap.get(\"track\")).intValue());\n}\noMP3File.setID3Tag(oID3V1_1Tag);\n}\nif (m_oCmdLineMap.containsKey(\"2\"))\n{\nID3V2_3_0Tag oID3V2_3_0Tag = new ID3V2_3_0Tag();\n\/\/HACK: Need to have padding at the end of the tag, or Winamp won't see the last frame (at least 6 bytes seem to be required).\noID3V2_3_0Tag.setPaddingLength(16);\nif (m_oCmdLineMap.containsKey(\"album\"))\n{\noID3V2_3_0Tag.setAlbum((String)m_oCmdLineMap.get(\"album\"));\n}\nif (m_oCmdLineMap.containsKey(\"artist\"))\n{\noID3V2_3_0Tag.setArtist((String)m_oCmdLineMap.get(\"artist\"));\n}\nif (m_oCmdLineMap.containsKey(\"comment\"))\n{\noID3V2_3_0Tag.setComment((String)m_oCmdLineMap.get(\"comment\"));\n}\nif (m_oCmdLineMap.containsKey(\"genre\"))\n{\noID3V2_3_0Tag.setGenre((String)m_oCmdLineMap.get(\"genre\"));\n}\noMP3File.setID3Tag(oID3V2_3_0Tag);\nif (m_oCmdLineMap.containsKey(\"title\"))\n{","label":[1,0,0,0]}
{"id":8611,"original_code":"@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tif(currSel!= null && currSel instanceof GroupTreeNode){\n\t\t\t\t\t\t\/\/ differentiate clones in this group\n\t\t\t\t\t\tGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/\t\t\t\t\t\tif(gtn.getChildCount() == 2){\n\t\t\t\t\t\t\t\/\/ TODO: currently we only support two way comparison\n\t\t\t\t\t\t\tCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\n\t\t\t\t\t\t\tCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\n\t\t\t\t\t\t\tString file1 = ctn1.getFile();\n\t\t\t\t\t\t\tString file2 = ctn2.getFile();\n\t\t\t\t\t\t\tCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\n\t\t\t\t\t\t\tcomparison.setOpenInBackground(false);\n\t\t\t\t\t\t\tcomparison.execute();\n\/\/\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}","code":"@Override\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tif(currSel!= null && currSel instanceof GroupTreeNode){\n\t\t\t\t\t\n\t\t\t\t\t\tGroupTreeNode gtn = (GroupTreeNode)currSel;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\n\t\t\t\t\t\t\tCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\n\t\t\t\t\t\t\tString file1 = ctn1.getFile();\n\t\t\t\t\t\t\tString file2 = ctn2.getFile();\n\t\t\t\t\t\t\tCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\n\t\t\t\t\t\t\tcomparison.setOpenInBackground(false);\n\t\t\t\t\t\t\tcomparison.execute();\n\t\t\t\t\t}\n\t\t\t\t}","cleancode":"@override public void actionperformed(actionevent e) { if(currsel!= null && currsel instanceof grouptreenode){ grouptreenode gtn = (grouptreenode)currsel; clonetreenode ctn1 = (clonetreenode)gtn.getchildat(0); clonetreenode ctn2 = (clonetreenode)gtn.getchildat(1); string file1 = ctn1.getfile(); string file2 = ctn2.getfile(); clonecomparison comparison = new clonecomparison(panel, new file(file1), new file(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end); comparison.setopeninbackground(false); comparison.execute(); } }","comment":"\/\/ differentiate clones in this group\n\/\/ if(gtn.getchildcount() == 2){ \/\/ todo: currently we only support two way comparison\n\/\/ }","repo":"UCLA-SEAL\/Grafter","code_context_2":"public void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\n\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}","code_context_10":"@Override\npublic void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}\n\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}","code_context_20":"@Override\npublic void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}\n\n@Override\npublic void actionPerformed(ActionEvent e) {\nif(currSel!= null && currSel instanceof GroupTreeNode){\n\/\/ differentiate clones in this group\nGroupTreeNode gtn = (GroupTreeNode)currSel;\n\/\/ if(gtn.getChildCount() == 2){\n\/\/ TODO: currently we only support two way comparison\nCloneTreeNode ctn1 = (CloneTreeNode)gtn.getChildAt(0);\nCloneTreeNode ctn2 = (CloneTreeNode)gtn.getChildAt(1);\nString file1 = ctn1.getFile();\nString file2 = ctn2.getFile();\nCloneComparison comparison = new CloneComparison(panel, new File(file1), new File(file2), ctn1.start, ctn1.end, ctn2.start, ctn2.end);\ncomparison.setOpenInBackground(false);\ncomparison.execute();\n\/\/ }\n}\n}","label":[1,0,0,0]}
{"id":25018,"original_code":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\n                                              long startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\n      if (parsingResult.hasGroupingOrAggregations()) {\n         throw log.queryMustNotUseGroupingOrAggregation(); \/\/ may happen only due to internal programming error\n      }\n      boolean isFullTextQuery;\n      if (parsingResult.getWhereClause() != null) {\n         isFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\n         if (!isIndexed && isFullTextQuery) {\n            throw new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n         }\n      }\n      if (parsingResult.getSortFields() != null) {\n         for (SortField sortField : parsingResult.getSortFields()) {\n            PropertyPath<?> p = sortField.getPath();\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n            }\n         }\n      }\n      if (parsingResult.getProjectedPaths() != null) {\n         for (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n            }\n         }\n      }\n      BooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\n      if (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n         \/\/ the query is a contradiction, there are no matches\n         return new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n      }\n      \/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\n      if (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n         \/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      IndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\n      boolean allProjectionsAreStored = true;\n      LinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\n      if (parsingResult.getProjectedPaths() != null) {\n         projectionsMap = new LinkedHashMap<>();\n         for (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\n            PropertyPath<?> p = parsingResult.getProjectedPaths()[i];\n            List<Integer> idx = projectionsMap.get(p);\n            if (idx == null) {\n               idx = new ArrayList<>();\n               projectionsMap.put(p, idx);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allProjectionsAreStored = false;\n               }\n            }\n            idx.add(i);\n         }\n      }\n      boolean allSortFieldsAreStored = true;\n      SortField[] sortFields = parsingResult.getSortFields();\n      if (sortFields != null) {\n         \/\/ deduplicate sort fields\n         LinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\n         for (SortField sf : sortFields) {\n            PropertyPath<?> p = sf.getPath();\n            String asStringPath = p.asStringPath();\n            if (!sortFieldMap.containsKey(asStringPath)) {\n               sortFieldMap.put(asStringPath, sf);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allSortFieldsAreStored = false;\n               }\n            }\n         }\n         sortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n      }\n      \/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n      \/\/todo [anistor] do we allow aggregation in fulltext queries?\n      \/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\n      BooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\n      BooleanExpr expansion = bse.expand(normalizedWhereClause);\n      if (expansion == normalizedWhereClause) {  \/\/ identity comparison is intended here!\n         \/\/ all involved fields are indexed, so go the Lucene way\n         if (allSortFieldsAreStored) {\n            if (allProjectionsAreStored) {\n               \/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\n               RowProcessor rowProcessor = null;\n               if (parsingResult.getProjectedPaths() != null) {\n                  if (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n                     \/\/ but some projections are duplicated ...\n                     final Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\n                     final int[] map = new int[parsingResult.getProjectedPaths().length];\n                     int j = 0;\n                     for (List<Integer> idx : projectionsMap.values()) {\n                        int i = idx.get(0);\n                        projectedTypes[j] = parsingResult.getProjectedTypes()[i];\n                        for (int k : idx) {\n                           map[k] = j;\n                        }\n                        j++;\n                     }\n                     RowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\n                     rowProcessor = inRow -> {\n                        if (projectionProcessor != null) {\n                           inRow = projectionProcessor.process(inRow);\n                        }\n                        Object[] outRow = new Object[map.length];\n                        for (int i = 0; i < map.length; i++) {\n                           outRow[i] = inRow[map[i]];\n                        }\n                        return outRow;\n                     };\n                     PropertyPath[] deduplicatedProjection = projectionsMap.keySet().toArray(new PropertyPath[projectionsMap.size()]);\n                     IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, deduplicatedProjection, projectedTypes, sortFields);\n                     return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n                  } else {\n                     rowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n                  }\n               }\n               return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n            } else {\n               IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\n               Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\n               String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\n               return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n            }\n         } else {\n            \/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\n            IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\n            Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n            String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\n            return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n         }\n      }\n      if (expansion == ConstantBooleanExpr.TRUE) {\n         \/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      \/\/ some fields are indexed, run a hybrid query\n      IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\n      Query expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n      return new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n   }","code":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\n                                              long startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\n      if (parsingResult.hasGroupingOrAggregations()) {\n         throw log.queryMustNotUseGroupingOrAggregation();\n      }\n      boolean isFullTextQuery;\n      if (parsingResult.getWhereClause() != null) {\n         isFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\n         if (!isIndexed && isFullTextQuery) {\n            throw new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n         }\n      }\n      if (parsingResult.getSortFields() != null) {\n         for (SortField sortField : parsingResult.getSortFields()) {\n            PropertyPath<?> p = sortField.getPath();\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n            }\n         }\n      }\n      if (parsingResult.getProjectedPaths() != null) {\n         for (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\n            if (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\n               throw log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n            }\n         }\n      }\n      BooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\n      if (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n        \n         return new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n      }\n     \n      if (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n        \n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n      IndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\n      boolean allProjectionsAreStored = true;\n      LinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\n      if (parsingResult.getProjectedPaths() != null) {\n         projectionsMap = new LinkedHashMap<>();\n         for (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\n            PropertyPath<?> p = parsingResult.getProjectedPaths()[i];\n            List<Integer> idx = projectionsMap.get(p);\n            if (idx == null) {\n               idx = new ArrayList<>();\n               projectionsMap.put(p, idx);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allProjectionsAreStored = false;\n               }\n            }\n            idx.add(i);\n         }\n      }\n      boolean allSortFieldsAreStored = true;\n      SortField[] sortFields = parsingResult.getSortFields();\n      if (sortFields != null) {\n        \n         LinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\n         for (SortField sf : sortFields) {\n            PropertyPath<?> p = sf.getPath();\n            String asStringPath = p.asStringPath();\n            if (!sortFieldMap.containsKey(asStringPath)) {\n               sortFieldMap.put(asStringPath, sf);\n               if (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\n                  allSortFieldsAreStored = false;\n               }\n            }\n         }\n         sortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n      }\n     \n     \n     \n      BooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\n      BooleanExpr expansion = bse.expand(normalizedWhereClause);\n      if (expansion == normalizedWhereClause) { \n        \n         if (allSortFieldsAreStored) {\n            if (allProjectionsAreStored) {\n              \n               RowProcessor rowProcessor = null;\n               if (parsingResult.getProjectedPaths() != null) {\n                  if (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n                    \n                     final Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\n                     final int[] map = new int[parsingResult.getProjectedPaths().length];\n                     int j = 0;\n                     for (List<Integer> idx : projectionsMap.values()) {\n                        int i = idx.get(0);\n                        projectedTypes[j] = parsingResult.getProjectedTypes()[i];\n                        for (int k : idx) {\n                           map[k] = j;\n                        }\n                        j++;\n                     }\n                     RowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\n                     rowProcessor = inRow -> {\n                        if (projectionProcessor != null) {\n                           inRow = projectionProcessor.process(inRow);\n                        }\n                        Object[] outRow = new Object[map.length];\n                        for (int i = 0; i < map.length; i++) {\n                           outRow[i] = inRow[map[i]];\n                        }\n                        return outRow;\n                     };\n                     PropertyPath[] deduplicatedProjection = projectionsMap.keySet().toArray(new PropertyPath[projectionsMap.size()]);\n                     IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, deduplicatedProjection, projectedTypes, sortFields);\n                     return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n                  } else {\n                     rowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n                  }\n               }\n               return new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n            } else {\n               IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\n               Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\n               String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\n               return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n            }\n         } else {\n           \n            IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\n            Query indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n            String projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\n            return new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n         }\n      }\n      if (expansion == ConstantBooleanExpr.TRUE) {\n        \n         return new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n      }\n     \n      IckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\n      Query expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n      return new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n   }","cleancode":"private basequery buildquerynoaggregations(queryfactory queryfactory, string querystring, map<string, object> namedparameters, long startoffset, int maxresults, ickleparsingresult<typemetadata> parsingresult) { if (parsingresult.hasgroupingoraggregations()) { throw log.querymustnotusegroupingoraggregation(); } boolean isfulltextquery; if (parsingresult.getwhereclause() != null) { isfulltextquery = parsingresult.getwhereclause().acceptvisitor(fulltextvisitor.instance); if (!isindexed && isfulltextquery) { throw new illegalstateexception(\"the cache must be indexed in order to use full-text queries.\"); } } if (parsingresult.getsortfields() != null) { for (sortfield sortfield : parsingresult.getsortfields()) { propertypath<?> p = sortfield.getpath(); if (propertyhelper.isrepeatedproperty(parsingresult.gettargetentitymetadata(), p.asarraypath())) { throw log.multivaluedpropertycannotbeusedinorderby(p.tostring()); } } } if (parsingresult.getprojectedpaths() != null) { for (propertypath<?> p : parsingresult.getprojectedpaths()) { if (propertyhelper.isrepeatedproperty(parsingresult.gettargetentitymetadata(), p.asarraypath())) { throw log.multivaluedpropertycannotbeprojected(p.asstringpath()); } } } booleanexpr normalizedwhereclause = booleanfilternormalizer.normalize(parsingresult.getwhereclause()); if (normalizedwhereclause == constantbooleanexpr.false) { return new emptyresultquery(queryfactory, cache, querystring, namedparameters, startoffset, maxresults); } if (!isindexed || (normalizedwhereclause == null || normalizedwhereclause == constantbooleanexpr.true) && parsingresult.getprojections() == null && parsingresult.getsortfields() == null) { return new embeddedquery(this, queryfactory, cache, querystring, namedparameters, parsingresult.getprojections(), startoffset, maxresults); } indexedfieldprovider.fieldindexingmetadata fieldindexingmetadata = propertyhelper.getindexedfieldprovider().get(parsingresult.gettargetentitymetadata()); boolean allprojectionsarestored = true; linkedhashmap<propertypath, list<integer>> projectionsmap = null; if (parsingresult.getprojectedpaths() != null) { projectionsmap = new linkedhashmap<>(); for (int i = 0; i < parsingresult.getprojectedpaths().length; i++) { propertypath<?> p = parsingresult.getprojectedpaths()[i]; list<integer> idx = projectionsmap.get(p); if (idx == null) { idx = new arraylist<>(); projectionsmap.put(p, idx); if (!fieldindexingmetadata.isstored(p.asarraypath())) { allprojectionsarestored = false; } } idx.add(i); } } boolean allsortfieldsarestored = true; sortfield[] sortfields = parsingresult.getsortfields(); if (sortfields != null) { linkedhashmap<string, sortfield> sortfieldmap = new linkedhashmap<>(); for (sortfield sf : sortfields) { propertypath<?> p = sf.getpath(); string asstringpath = p.asstringpath(); if (!sortfieldmap.containskey(asstringpath)) { sortfieldmap.put(asstringpath, sf); if (!fieldindexingmetadata.isstored(p.asarraypath())) { allsortfieldsarestored = false; } } } sortfields = sortfieldmap.values().toarray(new sortfield[sortfieldmap.size()]); } booleshannonexpansion bse = new booleshannonexpansion(max_expansion_cofactors, fieldindexingmetadata); booleanexpr expansion = bse.expand(normalizedwhereclause); if (expansion == normalizedwhereclause) { if (allsortfieldsarestored) { if (allprojectionsarestored) { rowprocessor rowprocessor = null; if (parsingresult.getprojectedpaths() != null) { if (projectionsmap.size() != parsingresult.getprojectedpaths().length) { final class<?>[] projectedtypes = new class<?>[projectionsmap.size()]; final int[] map = new int[parsingresult.getprojectedpaths().length]; int j = 0; for (list<integer> idx : projectionsmap.values()) { int i = idx.get(0); projectedtypes[j] = parsingresult.getprojectedtypes()[i]; for (int k : idx) { map[k] = j; } j++; } rowprocessor projectionprocessor = makeprojectionprocessor(projectedtypes); rowprocessor = inrow -> { if (projectionprocessor != null) { inrow = projectionprocessor.process(inrow); } object[] outrow = new object[map.length]; for (int i = 0; i < map.length; i++) { outrow[i] = inrow[map[i]]; } return outrow; }; propertypath[] deduplicatedprojection = projectionsmap.keyset().toarray(new propertypath[projectionsmap.size()]); ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, deduplicatedprojection, projectedtypes, sortfields); return new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, parsingresult.getprojections(), makeresultprocessor(rowprocessor), startoffset, maxresults); } else { rowprocessor = makeprojectionprocessor(parsingresult.getprojectedtypes()); } } return new embeddedlucenequery<>(this, queryfactory, namedparameters, parsingresult, parsingresult.getprojections(), makeresultprocessor(rowprocessor), startoffset, maxresults); } else { ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, null, null, sortfields); query indexquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), startoffset, maxresults); string projectionquerystr = syntaxtreeprinter.printtree(parsingresult.gettargetentityname(), parsingresult.getprojectedpaths(), null, null); return new hybridquery(queryfactory, cache, projectionquerystr, null, getobjectfilter(matcher, projectionquerystr, null, null), -1, -1, indexquery); } } else { ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, normalizedwhereclause, null, null, null); query indexquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), -1, -1); string projectionquerystr = syntaxtreeprinter.printtree(parsingresult.gettargetentityname(), parsingresult.getprojectedpaths(), null, sortfields); return new hybridquery(queryfactory, cache, projectionquerystr, null, getobjectfilter(matcher, projectionquerystr, null, null), startoffset, maxresults, indexquery); } } if (expansion == constantbooleanexpr.true) { return new embeddedquery(this, queryfactory, cache, querystring, namedparameters, parsingresult.getprojections(), startoffset, maxresults); } ickleparsingresult<typemetadata> fpr = makefilterparsingresult(parsingresult, expansion, null, null, null); query expandedquery = new embeddedlucenequery<>(this, queryfactory, namedparameters, fpr, null, makeresultprocessor(null), -1, -1); return new hybridquery(queryfactory, cache, querystring, namedparameters, getobjectfilter(matcher, querystring, namedparameters, null), startoffset, maxresults, expandedquery); }","comment":"\/\/ may happen only due to internal programming error\n\/\/ the query is a contradiction, there are no matches\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\n\/\/ deduplicate sort fields\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed \/\/todo [anistor] do we allow aggregation in fulltext queries? \/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\n\/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the lucene way\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\n\/\/ but some projections are duplicated ...\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\n\/\/ some fields are indexed, run a hybrid query","repo":"TomasHofman\/infinispan","code_context_2":"long startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\nif (parsingResult.hasGroupingOrAggregations()) {\nthrow log.queryMustNotUseGroupingOrAggregation(); \/\/ may happen only due to internal programming error\n}\nboolean isFullTextQuery;\n\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\n\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\nSortField[] sortFields = parsingResult.getSortFields();\nif (sortFields != null) {\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\n\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\n\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\n\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\n\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\n\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\n\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);","code_context_10":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\nlong startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\nif (parsingResult.hasGroupingOrAggregations()) {\nthrow log.queryMustNotUseGroupingOrAggregation(); \/\/ may happen only due to internal programming error\n}\nboolean isFullTextQuery;\nif (parsingResult.getWhereClause() != null) {\nisFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\nif (!isIndexed && isFullTextQuery) {\nthrow new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n}\n}\nif (parsingResult.getSortFields() != null) {\nfor (SortField sortField : parsingResult.getSortFields()) {\n\n}\nif (parsingResult.getProjectedPaths() != null) {\nfor (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\n\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\n\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\nPropertyPath<?> p = parsingResult.getProjectedPaths()[i];\nList<Integer> idx = projectionsMap.get(p);\n\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallProjectionsAreStored = false;\n}\n}\nidx.add(i);\n}\n}\nboolean allSortFieldsAreStored = true;\nSortField[] sortFields = parsingResult.getSortFields();\nif (sortFields != null) {\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\n\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\n\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\n\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\nj++;\n\n}\n}\nreturn new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n} else {\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nreturn new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n}\n\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nreturn new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n}","code_context_20":"private BaseQuery buildQueryNoAggregations(QueryFactory queryFactory, String queryString, Map<String, Object> namedParameters,\nlong startOffset, int maxResults, IckleParsingResult<TypeMetadata> parsingResult) {\nif (parsingResult.hasGroupingOrAggregations()) {\nthrow log.queryMustNotUseGroupingOrAggregation(); \/\/ may happen only due to internal programming error\n}\nboolean isFullTextQuery;\nif (parsingResult.getWhereClause() != null) {\nisFullTextQuery = parsingResult.getWhereClause().acceptVisitor(FullTextVisitor.INSTANCE);\nif (!isIndexed && isFullTextQuery) {\nthrow new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n}\n}\nif (parsingResult.getSortFields() != null) {\nfor (SortField sortField : parsingResult.getSortFields()) {\nPropertyPath<?> p = sortField.getPath();\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n}\n}\n}\nif (parsingResult.getProjectedPaths() != null) {\nfor (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n\nthrow new IllegalStateException(\"The cache must be indexed in order to use full-text queries.\");\n}\n}\nif (parsingResult.getSortFields() != null) {\nfor (SortField sortField : parsingResult.getSortFields()) {\nPropertyPath<?> p = sortField.getPath();\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n}\n}\n}\nif (parsingResult.getProjectedPaths() != null) {\nfor (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\nPropertyPath<?> p = parsingResult.getProjectedPaths()[i];\nList<Integer> idx = projectionsMap.get(p);\nif (idx == null) {\nidx = new ArrayList<>();\nprojectionsMap.put(p, idx);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallProjectionsAreStored = false;\n\nif (parsingResult.getSortFields() != null) {\nfor (SortField sortField : parsingResult.getSortFields()) {\nPropertyPath<?> p = sortField.getPath();\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n}\n}\n}\nif (parsingResult.getProjectedPaths() != null) {\nfor (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\nPropertyPath<?> p = parsingResult.getProjectedPaths()[i];\nList<Integer> idx = projectionsMap.get(p);\nif (idx == null) {\nidx = new ArrayList<>();\nprojectionsMap.put(p, idx);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallProjectionsAreStored = false;\n}\n}\nidx.add(i);\n\nPropertyPath<?> p = sortField.getPath();\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeUsedInOrderBy(p.toString());\n}\n}\n}\nif (parsingResult.getProjectedPaths() != null) {\nfor (PropertyPath<?> p : parsingResult.getProjectedPaths()) {\nif (propertyHelper.isRepeatedProperty(parsingResult.getTargetEntityMetadata(), p.asArrayPath())) {\nthrow log.multivaluedPropertyCannotBeProjected(p.asStringPath());\n}\n}\n}\nBooleanExpr normalizedWhereClause = booleanFilterNormalizer.normalize(parsingResult.getWhereClause());\nif (normalizedWhereClause == ConstantBooleanExpr.FALSE) {\n\/\/ the query is a contradiction, there are no matches\nreturn new EmptyResultQuery(queryFactory, cache, queryString, namedParameters, startOffset, maxResults);\n}\n\/\/ if cache is indexed but there is no actual 'where' filter clause and we do have sorting or projections we should still use the index, otherwise just go for a non-indexed fetch-all\nif (!isIndexed || (normalizedWhereClause == null || normalizedWhereClause == ConstantBooleanExpr.TRUE) && parsingResult.getProjections() == null && parsingResult.getSortFields() == null) {\n\/\/ fully non-indexed execution because the filter matches everything or there is no indexing at all\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\nIndexedFieldProvider.FieldIndexingMetadata fieldIndexingMetadata = propertyHelper.getIndexedFieldProvider().get(parsingResult.getTargetEntityMetadata());\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\nPropertyPath<?> p = parsingResult.getProjectedPaths()[i];\nList<Integer> idx = projectionsMap.get(p);\nif (idx == null) {\nidx = new ArrayList<>();\nprojectionsMap.put(p, idx);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallProjectionsAreStored = false;\n}\n}\nidx.add(i);\n}\n}\n\nboolean allProjectionsAreStored = true;\nLinkedHashMap<PropertyPath, List<Integer>> projectionsMap = null;\nif (parsingResult.getProjectedPaths() != null) {\nprojectionsMap = new LinkedHashMap<>();\nfor (int i = 0; i < parsingResult.getProjectedPaths().length; i++) {\nPropertyPath<?> p = parsingResult.getProjectedPaths()[i];\nList<Integer> idx = projectionsMap.get(p);\nif (idx == null) {\nidx = new ArrayList<>();\nprojectionsMap.put(p, idx);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallProjectionsAreStored = false;\n}\n}\nidx.add(i);\n}\n}\nboolean allSortFieldsAreStored = true;\nSortField[] sortFields = parsingResult.getSortFields();\nif (sortFields != null) {\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\n\nidx.add(i);\n}\n}\nboolean allSortFieldsAreStored = true;\nSortField[] sortFields = parsingResult.getSortFields();\nif (sortFields != null) {\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\n\nif (sortFields != null) {\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\nj++;\n}\nRowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\n\n\/\/ deduplicate sort fields\nLinkedHashMap<String, SortField> sortFieldMap = new LinkedHashMap<>();\nfor (SortField sf : sortFields) {\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\nj++;\n}\nRowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\nrowProcessor = inRow -> {\n\nPropertyPath<?> p = sf.getPath();\nString asStringPath = p.asStringPath();\nif (!sortFieldMap.containsKey(asStringPath)) {\nsortFieldMap.put(asStringPath, sf);\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\nj++;\n}\nRowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\nrowProcessor = inRow -> {\nif (projectionProcessor != null) {\ninRow = projectionProcessor.process(inRow);\n}\n\nif (!fieldIndexingMetadata.isStored(p.asArrayPath())) {\nallSortFieldsAreStored = false;\n}\n}\n}\nsortFields = sortFieldMap.values().toArray(new SortField[sortFieldMap.size()]);\n}\n\/\/todo [anistor] do not allow hybrid queries with fulltext. exception, allow a fully indexed query followed by in-memory aggregation. the aggregated or 'having' field should not be analyzed\n\/\/todo [anistor] do we allow aggregation in fulltext queries?\n\/\/todo [anistor] do not allow hybrid fulltext queries. all 'where' fields must be indexed. all projections must be stored.\nBooleShannonExpansion bse = new BooleShannonExpansion(MAX_EXPANSION_COFACTORS, fieldIndexingMetadata);\nBooleanExpr expansion = bse.expand(normalizedWhereClause);\nif (expansion == normalizedWhereClause) { \/\/ identity comparison is intended here!\n\/\/ all involved fields are indexed, so go the Lucene way\nif (allSortFieldsAreStored) {\nif (allProjectionsAreStored) {\n\/\/ all projections are stored, so we can execute the query entirely against the index, and we can also sort using the index\nRowProcessor rowProcessor = null;\nif (parsingResult.getProjectedPaths() != null) {\nif (projectionsMap.size() != parsingResult.getProjectedPaths().length) {\n\/\/ but some projections are duplicated ...\nfinal Class<?>[] projectedTypes = new Class<?>[projectionsMap.size()];\nfinal int[] map = new int[parsingResult.getProjectedPaths().length];\nint j = 0;\nfor (List<Integer> idx : projectionsMap.values()) {\nint i = idx.get(0);\nprojectedTypes[j] = parsingResult.getProjectedTypes()[i];\nfor (int k : idx) {\nmap[k] = j;\n}\nj++;\n}\nRowProcessor projectionProcessor = makeProjectionProcessor(projectedTypes);\nrowProcessor = inRow -> {\nif (projectionProcessor != null) {\ninRow = projectionProcessor.process(inRow);\n}\nObject[] outRow = new Object[map.length];\nfor (int i = 0; i < map.length; i++) {\noutRow[i] = inRow[map[i]];\n}\n\nfor (int i = 0; i < map.length; i++) {\noutRow[i] = inRow[map[i]];\n}\nreturn outRow;\n};\nPropertyPath[] deduplicatedProjection = projectionsMap.keySet().toArray(new PropertyPath[projectionsMap.size()]);\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, deduplicatedProjection, projectedTypes, sortFields);\nreturn new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n} else {\nrowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n}\n}\nreturn new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n} else {\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nreturn new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n}\n\n} else {\nrowProcessor = makeProjectionProcessor(parsingResult.getProjectedTypes());\n}\n}\nreturn new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n} else {\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nreturn new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n}\n\n}\nreturn new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, parsingResult, parsingResult.getProjections(), makeResultProcessor(rowProcessor), startOffset, maxResults);\n} else {\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, sortFields);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), startOffset, maxResults);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, null);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), -1, -1, indexQuery);\n}\n} else {\n\/\/ projections may be stored but some sort fields are not so we need to query the index and then execute in-memory sorting and projecting in a second phase\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, normalizedWhereClause, null, null, null);\nQuery indexQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nString projectionQueryStr = SyntaxTreePrinter.printTree(parsingResult.getTargetEntityName(), parsingResult.getProjectedPaths(), null, sortFields);\nreturn new HybridQuery(queryFactory, cache, projectionQueryStr, null, getObjectFilter(matcher, projectionQueryStr, null, null), startOffset, maxResults, indexQuery);\n}\n}\nif (expansion == ConstantBooleanExpr.TRUE) {\n\/\/ expansion leads to a full non-indexed query or the expansion is too long\/complex\nreturn new EmbeddedQuery(this, queryFactory, cache, queryString, namedParameters, parsingResult.getProjections(), startOffset, maxResults);\n}\n\/\/ some fields are indexed, run a hybrid query\nIckleParsingResult<TypeMetadata> fpr = makeFilterParsingResult(parsingResult, expansion, null, null, null);\nQuery expandedQuery = new EmbeddedLuceneQuery<>(this, queryFactory, namedParameters, fpr, null, makeResultProcessor(null), -1, -1);\nreturn new HybridQuery(queryFactory, cache, queryString, namedParameters, getObjectFilter(matcher, queryString, namedParameters, null), startOffset, maxResults, expandedQuery);\n}","label":[1,0,0,0]}
{"id":448,"original_code":"public static char[][] fill(char contents, int width, int height) {\n        char[][] next = new char[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code":"public static char[][] fill(char contents, int width, int height) {\n        char[][] next = new char[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static char[][] fill(char contents, int width, int height) { char[][] next = new char[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(char[][], char)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static char[][] fill(char contents, int width, int height) {\nchar[][] next = new char[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_10":"public static char[][] fill(char contents, int width, int height) {\nchar[][] next = new char[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_20":"public static char[][] fill(char contents, int width, int height) {\nchar[][] next = new char[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":449,"original_code":"public static float[][] fill(float contents, int width, int height) {\n        float[][] next = new float[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code":"public static float[][] fill(float contents, int width, int height) {\n        float[][] next = new float[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static float[][] fill(float contents, int width, int height) { float[][] next = new float[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(float[][], float)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static float[][] fill(float contents, int width, int height) {\nfloat[][] next = new float[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_10":"public static float[][] fill(float contents, int width, int height) {\nfloat[][] next = new float[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_20":"public static float[][] fill(float contents, int width, int height) {\nfloat[][] next = new float[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":450,"original_code":"public static double[][] fill(double contents, int width, int height) {\n        double[][] next = new double[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code":"public static double[][] fill(double contents, int width, int height) {\n        double[][] next = new double[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static double[][] fill(double contents, int width, int height) { double[][] next = new double[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(double[][], double)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static double[][] fill(double contents, int width, int height) {\ndouble[][] next = new double[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_10":"public static double[][] fill(double contents, int width, int height) {\ndouble[][] next = new double[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_20":"public static double[][] fill(double contents, int width, int height) {\ndouble[][] next = new double[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":451,"original_code":"public static int[][] fill(int contents, int width, int height) {\n        int[][] next = new int[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code":"public static int[][] fill(int contents, int width, int height) {\n        int[][] next = new int[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static int[][] fill(int contents, int width, int height) { int[][] next = new int[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(int[][], int)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static int[][] fill(int contents, int width, int height) {\nint[][] next = new int[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_10":"public static int[][] fill(int contents, int width, int height) {\nint[][] next = new int[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_20":"public static int[][] fill(int contents, int width, int height) {\nint[][] next = new int[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":452,"original_code":"public static byte[][] fill(byte contents, int width, int height) {\n        byte[][] next = new byte[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","code":"public static byte[][] fill(byte contents, int width, int height) {\n        byte[][] next = new byte[width][height];\n        for (int x = 0; x < width; x++) {\n            Arrays.fill(next[x], contents);\n        }\n        return next;\n    }","cleancode":"public static byte[][] fill(byte contents, int width, int height) { byte[][] next = new byte[width][height]; for (int x = 0; x < width; x++) { arrays.fill(next[x], contents); } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(byte[][], byte)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static byte[][] fill(byte contents, int width, int height) {\nbyte[][] next = new byte[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_10":"public static byte[][] fill(byte contents, int width, int height) {\nbyte[][] next = new byte[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","code_context_20":"public static byte[][] fill(byte contents, int width, int height) {\nbyte[][] next = new byte[width][height];\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], contents);\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":453,"original_code":"public static boolean[][] fill(boolean contents, int width, int height) {\n        boolean[][] next = new boolean[width][height];\n        if (contents) {\n            for (int x = 0; x < width; x++) {\n                Arrays.fill(next[x], true);\n            }\n        }\n        return next;\n    }","code":"public static boolean[][] fill(boolean contents, int width, int height) {\n        boolean[][] next = new boolean[width][height];\n        if (contents) {\n            for (int x = 0; x < width; x++) {\n                Arrays.fill(next[x], true);\n            }\n        }\n        return next;\n    }","cleancode":"public static boolean[][] fill(boolean contents, int width, int height) { boolean[][] next = new boolean[width][height]; if (contents) { for (int x = 0; x < width; x++) { arrays.fill(next[x], true); } } return next; }","comment":"\/** * creates a 2d array of the given width and height, filled with entirely with the value contents. * you may want to use {@link #fill(boolean[][], boolean)} to modify an existing 2d array instead. * @param contents the value to fill the array with * @param width the desired width * @param height the desired height * @return a freshly allocated 2d array of the requested dimensions, filled entirely with contents *\/","repo":"SquidPony\/SquidLib","code_context_2":"public static boolean[][] fill(boolean contents, int width, int height) {\nboolean[][] next = new boolean[width][height];\nif (contents) {\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], true);\n}\n}\nreturn next;\n}","code_context_10":"public static boolean[][] fill(boolean contents, int width, int height) {\nboolean[][] next = new boolean[width][height];\nif (contents) {\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], true);\n}\n}\nreturn next;\n}","code_context_20":"public static boolean[][] fill(boolean contents, int width, int height) {\nboolean[][] next = new boolean[width][height];\nif (contents) {\nfor (int x = 0; x < width; x++) {\nArrays.fill(next[x], true);\n}\n}\nreturn next;\n}","label":[1,0,0,0]}
{"id":16885,"original_code":"@JsonGetter(\"limit\")\n    public String getLimit ( ) { \n        return this.limit;\n    }","code":"@JsonGetter(\"limit\")\n    public String getLimit ( ) { \n        return this.limit;\n    }","cleancode":"@jsongetter(\"limit\") public string getlimit ( ) { return this.limit; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"adams-okode\/chirpstack-rest-sdk","code_context_2":"@JsonGetter(\"limit\")\npublic String getLimit ( ) {\nreturn this.limit;\n}","code_context_10":"@JsonGetter(\"limit\")\npublic String getLimit ( ) {\nreturn this.limit;\n}","code_context_20":"@JsonGetter(\"limit\")\npublic String getLimit ( ) {\nreturn this.limit;\n}","label":[0,0,0,0]}
{"id":25078,"original_code":"@Override\n\tprotected void execute(CalculationMonitor monitor){\n\t\t\/\/ import the image data into 1D arrays : TO DO\n\t\tImageDataFloat\tlayersImg = new ImageDataFloat(layersImage.getImageData());\n\t\tImageDataFloat\tintensImg = new ImageDataFloat(intensityImage.getImageData());\n\t\tint nx = layersImg.getRows();\n\t\tint ny = layersImg.getCols();\n\t\tint nz = layersImg.getSlices();\n\t\tint nlayers = layersImg.getComponents()-1;\n\t\tint nxyz = nx*ny*nz;\n\t\tfloat rx = layersImg.getHeader().getDimResolutions()[0];\n\t\tfloat ry = layersImg.getHeader().getDimResolutions()[1];\n\t\tfloat rz = layersImg.getHeader().getDimResolutions()[2];\n\t\tfloat[][] layers = new float[nlayers+1][nxyz];\n\t\tfloat[][][][] buffer4 = layersImg.toArray4d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tlayers[l][xyz] = buffer4[x][y][z][l];\n\t\t}\n\t\tbuffer4 = null;\n\t\tlayersImg = null;\n\t\tfloat[] intensity = new float[nxyz];\n\t\tfloat[][][] buffer3 = intensImg.toArray3d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tintensity[xyz] = buffer3[x][y][z];\n\t\t}\n\t\tbuffer3 = null;\n\t\tintensImg = null;\n\t\t\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\n\t\tboolean[] ctxmask = new boolean[nxyz];\n\t\tif (maskImage.getImageData()!=null) {\n\t\t\tImageDataUByte\tmaskImg = new ImageDataUByte(maskImage.getImageData());\n\t\t\tbyte[][][] bufferbyte = maskImg.toArray3d();\n\t\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n\t\t\t}\n\t\t\tbufferbyte = null;\n\t\t\tmaskImg = null;\n\t\t} else {\n\t\t\tfor (int xyz=0;xyz<nxyz;xyz++) {\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n\t\t\t}\n\t\t}\n\t\t\/\/ main algorithm\n\t\t\/\/ 1. define partial voume for each layer, each voxel\n\t\tfloat[][] pvol = new float[nlayers+1][nxyz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfor (int l=0;l<=nlayers;l++) {\n\t\t\t\t\tpvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ 2. build and invert the GLM for each profile \/ voxel?\n\t\tfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\n\t\tfloat maskval = 1e13f;\n\t\tfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\n\t\tfloat[][][] residual = new float[nx][ny][nz];\n\t\tBitSet sampled = new BitSet(nx*ny*nz);\n\t\tfloat[] profiledist = new float[nx*ny*nz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\n\t\t\t\tint nsample = sampled.size();\n\t\t\t\tif (nsample>=nlayers) {\n\t\t\t\t\tdouble[][] glm = new double[nlayers][nsample];\n\t\t\t\t\tdouble[][] data = new double[nsample][1];\n\t\t\t\t\tint idx = 0;\n\t\t\t\t\tfor (int n=0;n<nsample;n++) {\n\t\t\t\t\t\t\/\/ get the next non-zero value\n\t\t\t\t\t\tidx = sampled.nextSetBit(idx);\n\t\t\t\t\t\t\/\/ build a weighting function based on distance to the original location\n\t\t\t\t\t\tdouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\n\t\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\t\tglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[n][0] = weight*intensity[idx];\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ invert the linear model\n\t\t\t\t\tMatrix mtx = new Matrix(glm);\n\t\t\t\t\tMatrix smp = new Matrix(data);\n\t\t\t\t\tMatrix val = mtx.solve(smp);\n\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\tmapping[x][y][z][l] = (float)val.get(l,0);\n\t\t\t\t\t}\n\t\t\t\t\tMatrix res = mtx.times(val).minus(smp);\n\t\t\t\t\tresidual[x][y][z] = (float)res.normInf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ output\n\t\tString imgname = intensityImage.getImageData().getName();\n\t\tImageDataFloat mapData = new ImageDataFloat(mapping);\t\t\n\t\tmapData.setHeader(layersImage.getImageData().getHeader());\n\t\tmapData.setName(imgname+\"_glmprofiles\");\n\t\tmappedImage.setValue(mapData);\n\t\tmapData = null;\n\t\tmapping = null;\n\t\tImageDataFloat resData = new ImageDataFloat(residual);\t\t\n\t\tresData.setHeader(layersImage.getImageData().getHeader());\n\t\tresData.setName(imgname+\"_glmresidual\");\n\t\tresidualImage.setValue(resData);\n\t\tresData = null;\n\t\tresidual = null;\n\t}","code":"@Override\n\tprotected void execute(CalculationMonitor monitor){\n\t\n\t\tImageDataFloat\tlayersImg = new ImageDataFloat(layersImage.getImageData());\n\t\tImageDataFloat\tintensImg = new ImageDataFloat(intensityImage.getImageData());\n\t\tint nx = layersImg.getRows();\n\t\tint ny = layersImg.getCols();\n\t\tint nz = layersImg.getSlices();\n\t\tint nlayers = layersImg.getComponents()-1;\n\t\tint nxyz = nx*ny*nz;\n\t\tfloat rx = layersImg.getHeader().getDimResolutions()[0];\n\t\tfloat ry = layersImg.getHeader().getDimResolutions()[1];\n\t\tfloat rz = layersImg.getHeader().getDimResolutions()[2];\n\t\tfloat[][] layers = new float[nlayers+1][nxyz];\n\t\tfloat[][][][] buffer4 = layersImg.toArray4d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tlayers[l][xyz] = buffer4[x][y][z][l];\n\t\t}\n\t\tbuffer4 = null;\n\t\tlayersImg = null;\n\t\tfloat[] intensity = new float[nxyz];\n\t\tfloat[][][] buffer3 = intensImg.toArray3d();\n\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\tintensity[xyz] = buffer3[x][y][z];\n\t\t}\n\t\tbuffer3 = null;\n\t\tintensImg = null;\n\t\n\t\tboolean[] ctxmask = new boolean[nxyz];\n\t\tif (maskImage.getImageData()!=null) {\n\t\t\tImageDataUByte\tmaskImg = new ImageDataUByte(maskImage.getImageData());\n\t\t\tbyte[][][] bufferbyte = maskImg.toArray3d();\n\t\t\tfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\n\t\t\t\tint xyz = x+nx*y+nx*ny*z;\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n\t\t\t}\n\t\t\tbufferbyte = null;\n\t\t\tmaskImg = null;\n\t\t} else {\n\t\t\tfor (int xyz=0;xyz<nxyz;xyz++) {\n\t\t\t\tctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tfloat[][] pvol = new float[nlayers+1][nxyz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfor (int l=0;l<=nlayers;l++) {\n\t\t\t\t\tpvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\t\tCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\n\t\tfloat maskval = 1e13f;\n\t\tfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\n\t\tfloat[][][] residual = new float[nx][ny][nz];\n\t\tBitSet sampled = new BitSet(nx*ny*nz);\n\t\tfloat[] profiledist = new float[nx*ny*nz];\n\t\tfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\t\t\tint xyz = x + nx*y + nx*ny*z;\n\t\t\tif (ctxmask[xyz]) {\n\t\t\t\tfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\n\t\t\t\tint nsample = sampled.size();\n\t\t\t\tif (nsample>=nlayers) {\n\t\t\t\t\tdouble[][] glm = new double[nlayers][nsample];\n\t\t\t\t\tdouble[][] data = new double[nsample][1];\n\t\t\t\t\tint idx = 0;\n\t\t\t\t\tfor (int n=0;n<nsample;n++) {\n\t\t\t\t\t\n\t\t\t\t\t\tidx = sampled.nextSetBit(idx);\n\t\t\t\t\t\n\t\t\t\t\t\tdouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\n\t\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\t\tglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata[n][0] = weight*intensity[idx];\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tMatrix mtx = new Matrix(glm);\n\t\t\t\t\tMatrix smp = new Matrix(data);\n\t\t\t\t\tMatrix val = mtx.solve(smp);\n\t\t\t\t\tfor (int l=0;l<nlayers;l++) {\n\t\t\t\t\t\tmapping[x][y][z][l] = (float)val.get(l,0);\n\t\t\t\t\t}\n\t\t\t\t\tMatrix res = mtx.times(val).minus(smp);\n\t\t\t\t\tresidual[x][y][z] = (float)res.normInf();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tString imgname = intensityImage.getImageData().getName();\n\t\tImageDataFloat mapData = new ImageDataFloat(mapping);\t\t\n\t\tmapData.setHeader(layersImage.getImageData().getHeader());\n\t\tmapData.setName(imgname+\"_glmprofiles\");\n\t\tmappedImage.setValue(mapData);\n\t\tmapData = null;\n\t\tmapping = null;\n\t\tImageDataFloat resData = new ImageDataFloat(residual);\t\t\n\t\tresData.setHeader(layersImage.getImageData().getHeader());\n\t\tresData.setName(imgname+\"_glmresidual\");\n\t\tresidualImage.setValue(resData);\n\t\tresData = null;\n\t\tresidual = null;\n\t}","cleancode":"@override protected void execute(calculationmonitor monitor){ imagedatafloat layersimg = new imagedatafloat(layersimage.getimagedata()); imagedatafloat intensimg = new imagedatafloat(intensityimage.getimagedata()); int nx = layersimg.getrows(); int ny = layersimg.getcols(); int nz = layersimg.getslices(); int nlayers = layersimg.getcomponents()-1; int nxyz = nx*ny*nz; float rx = layersimg.getheader().getdimresolutions()[0]; float ry = layersimg.getheader().getdimresolutions()[1]; float rz = layersimg.getheader().getdimresolutions()[2]; float[][] layers = new float[nlayers+1][nxyz]; float[][][][] buffer4 = layersimg.toarray4d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) { int xyz = x+nx*y+nx*ny*z; layers[l][xyz] = buffer4[x][y][z][l]; } buffer4 = null; layersimg = null; float[] intensity = new float[nxyz]; float[][][] buffer3 = intensimg.toarray3d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) { int xyz = x+nx*y+nx*ny*z; intensity[xyz] = buffer3[x][y][z]; } buffer3 = null; intensimg = null; boolean[] ctxmask = new boolean[nxyz]; if (maskimage.getimagedata()!=null) { imagedataubyte maskimg = new imagedataubyte(maskimage.getimagedata()); byte[][][] bufferbyte = maskimg.toarray3d(); for (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) { int xyz = x+nx*y+nx*ny*z; ctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0); } bufferbyte = null; maskimg = null; } else { for (int xyz=0;xyz<nxyz;xyz++) { ctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0); } } float[][] pvol = new float[nlayers+1][nxyz]; for (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) { int xyz = x + nx*y + nx*ny*z; if (ctxmask[xyz]) { for (int l=0;l<=nlayers;l++) { pvol[l][xyz] = partialvolumefromsurface(x, y, z, layers[l], nx, ny, nz); } } } float delta = paramextent.getvalue().floatvalue()\/numerics.min(rx,ry,rz); float stdev = paramstdev.getvalue().floatvalue()\/numerics.min(rx,ry,rz); corticalprofile profile = new corticalprofile(nlayers, nx, ny, nz, rx, ry, rz); float maskval = 1e13f; float[][][][] mapping = new float[nx][ny][nz][nlayers]; float[][][] residual = new float[nx][ny][nz]; bitset sampled = new bitset(nx*ny*nz); float[] profiledist = new float[nx*ny*nz]; for (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) { int xyz = x + nx*y + nx*ny*z; if (ctxmask[xyz]) { findfastmarchingprofileneighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers); int nsample = sampled.size(); if (nsample>=nlayers) { double[][] glm = new double[nlayers][nsample]; double[][] data = new double[nsample][1]; int idx = 0; for (int n=0;n<nsample;n++) { idx = sampled.nextsetbit(idx); double weight = fastmath.exp(-0.5*numerics.square(profiledist[idx]\/stdev)); for (int l=0;l<nlayers;l++) { glm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]); } data[n][0] = weight*intensity[idx]; } matrix mtx = new matrix(glm); matrix smp = new matrix(data); matrix val = mtx.solve(smp); for (int l=0;l<nlayers;l++) { mapping[x][y][z][l] = (float)val.get(l,0); } matrix res = mtx.times(val).minus(smp); residual[x][y][z] = (float)res.norminf(); } } } string imgname = intensityimage.getimagedata().getname(); imagedatafloat mapdata = new imagedatafloat(mapping); mapdata.setheader(layersimage.getimagedata().getheader()); mapdata.setname(imgname+\"_glmprofiles\"); mappedimage.setvalue(mapdata); mapdata = null; mapping = null; imagedatafloat resdata = new imagedatafloat(residual); resdata.setheader(layersimage.getimagedata().getheader()); resdata.setname(imgname+\"_glmresidual\"); residualimage.setvalue(resdata); resdata = null; residual = null; }","comment":"\/\/ import the image data into 1d arrays : to do\n\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\n\/\/ main algorithm \/\/ 1. define partial voume for each layer, each voxel\n\/\/ 2. build and invert the glm for each profile \/ voxel?\n\/\/ get the next non-zero value\n\/\/ build a weighting function based on distance to the original location\n\/\/ invert the linear model\n\/\/ output","repo":"alaurent4\/nighres","code_context_2":"@Override\nprotected void execute(CalculationMonitor monitor){\n\/\/ import the image data into 1D arrays : TO DO\nImageDataFloat layersImg = new ImageDataFloat(layersImage.getImageData());\nImageDataFloat intensImg = new ImageDataFloat(intensityImage.getImageData());\n\nbuffer3 = null;\nintensImg = null;\n\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\nboolean[] ctxmask = new boolean[nxyz];\nif (maskImage.getImageData()!=null) {\n\n}\n}\n\/\/ main algorithm\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\n\n}\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\n\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\n\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\n\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\n\n}\n}\n\/\/ output\nString imgname = intensityImage.getImageData().getName();\nImageDataFloat mapData = new ImageDataFloat(mapping);","code_context_10":"@Override\nprotected void execute(CalculationMonitor monitor){\n\/\/ import the image data into 1D arrays : TO DO\nImageDataFloat layersImg = new ImageDataFloat(layersImage.getImageData());\nImageDataFloat intensImg = new ImageDataFloat(intensityImage.getImageData());\nint nx = layersImg.getRows();\nint ny = layersImg.getCols();\nint nz = layersImg.getSlices();\nint nlayers = layersImg.getComponents()-1;\nint nxyz = nx*ny*nz;\nfloat rx = layersImg.getHeader().getDimResolutions()[0];\nfloat ry = layersImg.getHeader().getDimResolutions()[1];\nfloat rz = layersImg.getHeader().getDimResolutions()[2];\n\nbuffer4 = null;\nlayersImg = null;\nfloat[] intensity = new float[nxyz];\nfloat[][][] buffer3 = intensImg.toArray3d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\nint xyz = x+nx*y+nx*ny*z;\nintensity[xyz] = buffer3[x][y][z];\n}\nbuffer3 = null;\nintensImg = null;\n\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\nboolean[] ctxmask = new boolean[nxyz];\nif (maskImage.getImageData()!=null) {\nImageDataUByte maskImg = new ImageDataUByte(maskImage.getImageData());\nbyte[][][] bufferbyte = maskImg.toArray3d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\nint xyz = x+nx*y+nx*ny*z;\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n}\nbufferbyte = null;\nmaskImg = null;\n\nint xyz = x+nx*y+nx*ny*z;\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n}\nbufferbyte = null;\nmaskImg = null;\n} else {\nfor (int xyz=0;xyz<nxyz;xyz++) {\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n}\n}\n\/\/ main algorithm\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfor (int l=0;l<=nlayers;l++) {\npvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n}\n}\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\n\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfor (int l=0;l<=nlayers;l++) {\npvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n}\n}\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\nfloat maskval = 1e13f;\nfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\nfloat[][][] residual = new float[nx][ny][nz];\nBitSet sampled = new BitSet(nx*ny*nz);\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\n\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\n\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\n\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n}\n\/\/ output\nString imgname = intensityImage.getImageData().getName();\nImageDataFloat mapData = new ImageDataFloat(mapping);\nmapData.setHeader(layersImage.getImageData().getHeader());\nmapData.setName(imgname+\"_glmprofiles\");\nmappedImage.setValue(mapData);\nmapData = null;\nmapping = null;\nImageDataFloat resData = new ImageDataFloat(residual);\nresData.setHeader(layersImage.getImageData().getHeader());\nresData.setName(imgname+\"_glmresidual\");","code_context_20":"@Override\nprotected void execute(CalculationMonitor monitor){\n\/\/ import the image data into 1D arrays : TO DO\nImageDataFloat layersImg = new ImageDataFloat(layersImage.getImageData());\nImageDataFloat intensImg = new ImageDataFloat(intensityImage.getImageData());\nint nx = layersImg.getRows();\nint ny = layersImg.getCols();\nint nz = layersImg.getSlices();\nint nlayers = layersImg.getComponents()-1;\nint nxyz = nx*ny*nz;\nfloat rx = layersImg.getHeader().getDimResolutions()[0];\nfloat ry = layersImg.getHeader().getDimResolutions()[1];\nfloat rz = layersImg.getHeader().getDimResolutions()[2];\nfloat[][] layers = new float[nlayers+1][nxyz];\nfloat[][][][] buffer4 = layersImg.toArray4d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\nint xyz = x+nx*y+nx*ny*z;\nlayers[l][xyz] = buffer4[x][y][z][l];\n}\nbuffer4 = null;\nlayersImg = null;\nfloat[] intensity = new float[nxyz];\nfloat[][][] buffer3 = intensImg.toArray3d();\n\nint nxyz = nx*ny*nz;\nfloat rx = layersImg.getHeader().getDimResolutions()[0];\nfloat ry = layersImg.getHeader().getDimResolutions()[1];\nfloat rz = layersImg.getHeader().getDimResolutions()[2];\nfloat[][] layers = new float[nlayers+1][nxyz];\nfloat[][][][] buffer4 = layersImg.toArray4d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) for (int l=0;l<=nlayers;l++) {\nint xyz = x+nx*y+nx*ny*z;\nlayers[l][xyz] = buffer4[x][y][z][l];\n}\nbuffer4 = null;\nlayersImg = null;\nfloat[] intensity = new float[nxyz];\nfloat[][][] buffer3 = intensImg.toArray3d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\nint xyz = x+nx*y+nx*ny*z;\nintensity[xyz] = buffer3[x][y][z];\n}\nbuffer3 = null;\nintensImg = null;\n\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\nboolean[] ctxmask = new boolean[nxyz];\nif (maskImage.getImageData()!=null) {\nImageDataUByte maskImg = new ImageDataUByte(maskImage.getImageData());\nbyte[][][] bufferbyte = maskImg.toArray3d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\nint xyz = x+nx*y+nx*ny*z;\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n}\nbufferbyte = null;\nmaskImg = null;\n} else {\nfor (int xyz=0;xyz<nxyz;xyz++) {\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n}\n}\n\/\/ main algorithm\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\n\nintensity[xyz] = buffer3[x][y][z];\n}\nbuffer3 = null;\nintensImg = null;\n\/\/ create a mask for all the regions outside of the area where layer 1 is > 0 and layer 2 is < 0\nboolean[] ctxmask = new boolean[nxyz];\nif (maskImage.getImageData()!=null) {\nImageDataUByte maskImg = new ImageDataUByte(maskImage.getImageData());\nbyte[][][] bufferbyte = maskImg.toArray3d();\nfor (int x=0;x<nx;x++) for (int y=0;y<ny;y++) for (int z=0;z<nz;z++) {\nint xyz = x+nx*y+nx*ny*z;\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n}\nbufferbyte = null;\nmaskImg = null;\n} else {\nfor (int xyz=0;xyz<nxyz;xyz++) {\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n}\n}\n\/\/ main algorithm\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfor (int l=0;l<=nlayers;l++) {\npvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n}\n}\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\nfloat maskval = 1e13f;\nfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\nfloat[][][] residual = new float[nx][ny][nz];\nBitSet sampled = new BitSet(nx*ny*nz);\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\n\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0 && bufferbyte[x][y][z]>0);\n}\nbufferbyte = null;\nmaskImg = null;\n} else {\nfor (int xyz=0;xyz<nxyz;xyz++) {\nctxmask[xyz] = (layers[0][xyz]>=0.0 && layers[nlayers][xyz]<=0.0);\n}\n}\n\/\/ main algorithm\n\/\/ 1. define partial voume for each layer, each voxel\nfloat[][] pvol = new float[nlayers+1][nxyz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfor (int l=0;l<=nlayers;l++) {\npvol[l][xyz] = partialVolumeFromSurface(x, y, z, layers[l], nx, ny, nz);\n}\n}\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\nfloat maskval = 1e13f;\nfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\nfloat[][][] residual = new float[nx][ny][nz];\nBitSet sampled = new BitSet(nx*ny*nz);\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\n}\n\/\/ 2. build and invert the GLM for each profile \/ voxel?\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\nfloat maskval = 1e13f;\nfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\nfloat[][][] residual = new float[nx][ny][nz];\nBitSet sampled = new BitSet(nx*ny*nz);\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n}\n\nfloat delta = paramExtent.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nfloat stdev = paramStdev.getValue().floatValue()\/Numerics.min(rx,ry,rz);\nCorticalProfile profile = new CorticalProfile(nlayers, nx, ny, nz, rx, ry, rz);\nfloat maskval = 1e13f;\nfloat[][][][] mapping = new float[nx][ny][nz][nlayers];\nfloat[][][] residual = new float[nx][ny][nz];\nBitSet sampled = new BitSet(nx*ny*nz);\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n}\n\/\/ output\nString imgname = intensityImage.getImageData().getName();\n\nfloat[] profiledist = new float[nx*ny*nz];\nfor (int x=0; x<nx; x++) for (int y=0; y<ny; y++) for (int z = 0; z<nz; z++) {\nint xyz = x + nx*y + nx*ny*z;\nif (ctxmask[xyz]) {\nfindFastMarchingProfileNeighborhood(sampled, profiledist, x,y,z, delta, layers, profile, ctxmask, nx, ny, nz, nlayers);\nint nsample = sampled.size();\nif (nsample>=nlayers) {\ndouble[][] glm = new double[nlayers][nsample];\ndouble[][] data = new double[nsample][1];\nint idx = 0;\nfor (int n=0;n<nsample;n++) {\n\/\/ get the next non-zero value\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n}\n\/\/ output\nString imgname = intensityImage.getImageData().getName();\nImageDataFloat mapData = new ImageDataFloat(mapping);\nmapData.setHeader(layersImage.getImageData().getHeader());\nmapData.setName(imgname+\"_glmprofiles\");\nmappedImage.setValue(mapData);\nmapData = null;\nmapping = null;\nImageDataFloat resData = new ImageDataFloat(residual);\n\nidx = sampled.nextSetBit(idx);\n\/\/ build a weighting function based on distance to the original location\ndouble weight = FastMath.exp(-0.5*Numerics.square(profiledist[idx]\/stdev));\nfor (int l=0;l<nlayers;l++) {\nglm[l][n] = weight*(pvol[l+1][idx]-pvol[l][idx]);\n}\ndata[n][0] = weight*intensity[idx];\n}\n\/\/ invert the linear model\nMatrix mtx = new Matrix(glm);\nMatrix smp = new Matrix(data);\nMatrix val = mtx.solve(smp);\nfor (int l=0;l<nlayers;l++) {\nmapping[x][y][z][l] = (float)val.get(l,0);\n}\nMatrix res = mtx.times(val).minus(smp);\nresidual[x][y][z] = (float)res.normInf();\n}\n}\n}\n\/\/ output\nString imgname = intensityImage.getImageData().getName();\nImageDataFloat mapData = new ImageDataFloat(mapping);\nmapData.setHeader(layersImage.getImageData().getHeader());\nmapData.setName(imgname+\"_glmprofiles\");\nmappedImage.setValue(mapData);\nmapData = null;\nmapping = null;\nImageDataFloat resData = new ImageDataFloat(residual);\nresData.setHeader(layersImage.getImageData().getHeader());\nresData.setName(imgname+\"_glmresidual\");\nresidualImage.setValue(resData);\nresData = null;\nresidual = null;\n}","label":[0,1,0,0]}
{"id":16887,"original_code":"@JsonGetter(\"offset\")\n    public String getOffset ( ) { \n        return this.offset;\n    }","code":"@JsonGetter(\"offset\")\n    public String getOffset ( ) { \n        return this.offset;\n    }","cleancode":"@jsongetter(\"offset\") public string getoffset ( ) { return this.offset; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"adams-okode\/chirpstack-rest-sdk","code_context_2":"@JsonGetter(\"offset\")\npublic String getOffset ( ) {\nreturn this.offset;\n}","code_context_10":"@JsonGetter(\"offset\")\npublic String getOffset ( ) {\nreturn this.offset;\n}","code_context_20":"@JsonGetter(\"offset\")\npublic String getOffset ( ) {\nreturn this.offset;\n}","label":[0,0,0,0]}
{"id":16886,"original_code":"@JsonSetter(\"limit\")\n    public void setLimit (String value) { \n        this.limit = value;\n    }","code":"@JsonSetter(\"limit\")\n    public void setLimit (String value) { \n        this.limit = value;\n    }","cleancode":"@jsonsetter(\"limit\") public void setlimit (string value) { this.limit = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"adams-okode\/chirpstack-rest-sdk","code_context_2":"@JsonSetter(\"limit\")\npublic void setLimit (String value) {\nthis.limit = value;\n}","code_context_10":"@JsonSetter(\"limit\")\npublic void setLimit (String value) {\nthis.limit = value;\n}","code_context_20":"@JsonSetter(\"limit\")\npublic void setLimit (String value) {\nthis.limit = value;\n}","label":[0,0,0,0]}
{"id":16888,"original_code":"@JsonSetter(\"offset\")\n    public void setOffset (String value) { \n        this.offset = value;\n    }","code":"@JsonSetter(\"offset\")\n    public void setOffset (String value) { \n        this.offset = value;\n    }","cleancode":"@jsonsetter(\"offset\") public void setoffset (string value) { this.offset = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"adams-okode\/chirpstack-rest-sdk","code_context_2":"@JsonSetter(\"offset\")\npublic void setOffset (String value) {\nthis.offset = value;\n}","code_context_10":"@JsonSetter(\"offset\")\npublic void setOffset (String value) {\nthis.offset = value;\n}","code_context_20":"@JsonSetter(\"offset\")\npublic void setOffset (String value) {\nthis.offset = value;\n}","label":[0,0,0,0]}
{"id":25180,"original_code":"public static int staticCompare(UUID u1, UUID u2)\n    {\n        \/\/ First: major sorting by types\n        int type = u1.version();\n        int diff = type - u2.version();\n        if (diff != 0) {\n            return diff;\n        }\n        \/\/ Second: for time-based variant, order by time stamp:\n        if (type == UUIDType.TIME_BASED.raw()) {\n            diff = compareULongs(u1.timestamp(), u2.timestamp());\n            if (diff == 0) {\n                \/\/ or if that won't work, by other bits lexically\n                diff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n            }\n        } else {\n            \/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\n            diff = compareULongs(u1.getMostSignificantBits(),\n                    u2.getMostSignificantBits());\n            if (diff == 0) {\n                diff = compareULongs(u1.getLeastSignificantBits(),\n                        u2.getLeastSignificantBits());\n            }\n        }\n        return diff;\n    }","code":"public static int staticCompare(UUID u1, UUID u2)\n    {\n       \n        int type = u1.version();\n        int diff = type - u2.version();\n        if (diff != 0) {\n            return diff;\n        }\n       \n        if (type == UUIDType.TIME_BASED.raw()) {\n            diff = compareULongs(u1.timestamp(), u2.timestamp());\n            if (diff == 0) {\n               \n                diff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n            }\n        } else {\n           \n            diff = compareULongs(u1.getMostSignificantBits(),\n                    u2.getMostSignificantBits());\n            if (diff == 0) {\n                diff = compareULongs(u1.getLeastSignificantBits(),\n                        u2.getLeastSignificantBits());\n            }\n        }\n        return diff;\n    }","cleancode":"public static int staticcompare(uuid u1, uuid u2) { int type = u1.version(); int diff = type - u2.version(); if (diff != 0) { return diff; } if (type == uuidtype.time_based.raw()) { diff = compareulongs(u1.timestamp(), u2.timestamp()); if (diff == 0) { diff = compareulongs(u1.getleastsignificantbits(), u2.getleastsignificantbits()); } } else { diff = compareulongs(u1.getmostsignificantbits(), u2.getmostsignificantbits()); if (diff == 0) { diff = compareulongs(u1.getleastsignificantbits(), u2.getleastsignificantbits()); } } return diff; }","comment":"\/** * static helper method that can be used instead of instantiating comparator * (used by unit tests, can be used by code too) *\/\n\/\/ first: major sorting by types\n\/\/ second: for time-based variant, order by time stamp:\n\/\/ or if that won't work, by other bits lexically\n\/\/ note: java.util.uuids compares with sign extension, imo that's wrong, so:","repo":"andrebrait\/java-uuid-generator","code_context_2":"public static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\n\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\n\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());","code_context_10":"public static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\n\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}","code_context_20":"public static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}\n\npublic static int staticCompare(UUID u1, UUID u2)\n{\n\/\/ First: major sorting by types\nint type = u1.version();\nint diff = type - u2.version();\nif (diff != 0) {\nreturn diff;\n}\n\/\/ Second: for time-based variant, order by time stamp:\nif (type == UUIDType.TIME_BASED.raw()) {\ndiff = compareULongs(u1.timestamp(), u2.timestamp());\nif (diff == 0) {\n\/\/ or if that won't work, by other bits lexically\ndiff = compareULongs(u1.getLeastSignificantBits(), u2.getLeastSignificantBits());\n}\n} else {\n\/\/ note: java.util.UUIDs compares with sign extension, IMO that's wrong, so:\ndiff = compareULongs(u1.getMostSignificantBits(),\nu2.getMostSignificantBits());\nif (diff == 0) {\ndiff = compareULongs(u1.getLeastSignificantBits(),\nu2.getLeastSignificantBits());\n}\n}\nreturn diff;\n}","label":[0,0,0,0]}
{"id":653,"original_code":"public PlayerPathData populateStats() {\n        this.playerEntity = strongholdPath.getPlayerEntity();\n        StrongholdGenerator.Start start = this.strongholdPath.getStart();\n        StrongholdTreeAccessor treeAccessor = (StrongholdTreeAccessor) start;\n        List<StrongholdPathEntry> history = this.strongholdPath.getHistory();\n        ArrayList<StructurePiece> solution = new ArrayList<>();\n        StrongholdGenerator.Piece current = this.strongholdPath.getHistory().get(strongholdPath.getHistory().size() - 1).getCurrentPiece();\n        while (current != null) {\n            solution.add(current);\n            current = (StrongholdGenerator.Piece) treeAccessor.getParents().get(current);\n        }\n        List<StrongholdPathEntry> validEntries = history.stream()\n                .filter(entry -> validateEntryForLoss(strongholdPath, strongholdPath.getNextEntry(entry)))\n                .filter(entry -> !solution.contains(strongholdPath.getNextEntry(entry).getCurrentPiece()) && solution.contains(entry.getCurrentPiece()))\n                .collect(Collectors.toList());\n        List<Pair<StrongholdPathEntry, Double>> losses = new ArrayList<>();\n        validEntries.forEach(strongholdPathEntry -> losses.add(new Pair<>(strongholdPathEntry, loss(strongholdPath, strongholdPath.getNextEntry(strongholdPathEntry), solution))));\n        this.inaccuracies = losses.stream().filter(pair -> pair.getRight() >= INACCURACY_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.mistakes = losses.stream().filter(pair -> pair.getRight() >= MISTAKE_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.blunders = losses.stream().filter(pair -> pair.getRight() >= BLUNDER_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        inaccuracies.removeAll(this.mistakes);\n        mistakes.removeAll(this.blunders);\n        ArrayList<Pair<StrongholdGenerator.Piece, Integer>> rooms = new ArrayList<>();\n        history.forEach(pathEntry -> {\n            Pair<StrongholdGenerator.Piece, Integer> pair = new Pair<>(pathEntry.getCurrentPiece(), pathEntry.getTicksSpentInPiece().get());\n            rooms.add(pair);\n        });\n        return new PlayerPathData(\n                rooms,\n                strongholdPath.getTotalTime(),\n                computeDifficulty(solution),\n                history.stream()\n                        .filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n                        .map(StrongholdPathEntry::getTicksSpentInPiece)\n                        .mapToInt(AtomicInteger::get)\n                        .sum(),\n                \/\/ TODO: don't count entering the first Five-Way\n                (int) history.stream()\n                        .map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n                        .filter(Objects::nonNull)\n                        .map(StrongholdPathEntry::getCurrentPiece)\n                        .filter(solution::contains)\n                        .count(),\n                this.inaccuracies.size(),\n                this.mistakes.size(),\n                this.blunders.size(),\n                (int) history.stream()\n                        .filter(entry -> !(entry.getCurrentPiece() instanceof StrongholdGenerator.PortalRoom))\n                        .filter(entry -> !areAdjacent(entry.getCurrentPiece(), strongholdPath.getNextEntry(entry).getCurrentPiece(), treeAccessor))\n                        .count(),\n                history.size() - 1,\n                history.stream()\n                        .filter(entry -> FEINBERG_AVG_ROOM_TIMES.containsKey(entry.getCurrentPiece().getClass()))\n                        .mapToInt(value -> value.getTicksSpentInPiece().get() - FEINBERG_AVG_ROOM_TIMES.get(value.getCurrentPiece().getClass()))\n                        .sum()\n        );\n    }","code":"public PlayerPathData populateStats() {\n        this.playerEntity = strongholdPath.getPlayerEntity();\n        StrongholdGenerator.Start start = this.strongholdPath.getStart();\n        StrongholdTreeAccessor treeAccessor = (StrongholdTreeAccessor) start;\n        List<StrongholdPathEntry> history = this.strongholdPath.getHistory();\n        ArrayList<StructurePiece> solution = new ArrayList<>();\n        StrongholdGenerator.Piece current = this.strongholdPath.getHistory().get(strongholdPath.getHistory().size() - 1).getCurrentPiece();\n        while (current != null) {\n            solution.add(current);\n            current = (StrongholdGenerator.Piece) treeAccessor.getParents().get(current);\n        }\n        List<StrongholdPathEntry> validEntries = history.stream()\n                .filter(entry -> validateEntryForLoss(strongholdPath, strongholdPath.getNextEntry(entry)))\n                .filter(entry -> !solution.contains(strongholdPath.getNextEntry(entry).getCurrentPiece()) && solution.contains(entry.getCurrentPiece()))\n                .collect(Collectors.toList());\n        List<Pair<StrongholdPathEntry, Double>> losses = new ArrayList<>();\n        validEntries.forEach(strongholdPathEntry -> losses.add(new Pair<>(strongholdPathEntry, loss(strongholdPath, strongholdPath.getNextEntry(strongholdPathEntry), solution))));\n        this.inaccuracies = losses.stream().filter(pair -> pair.getRight() >= INACCURACY_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.mistakes = losses.stream().filter(pair -> pair.getRight() >= MISTAKE_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        this.blunders = losses.stream().filter(pair -> pair.getRight() >= BLUNDER_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\n        inaccuracies.removeAll(this.mistakes);\n        mistakes.removeAll(this.blunders);\n        ArrayList<Pair<StrongholdGenerator.Piece, Integer>> rooms = new ArrayList<>();\n        history.forEach(pathEntry -> {\n            Pair<StrongholdGenerator.Piece, Integer> pair = new Pair<>(pathEntry.getCurrentPiece(), pathEntry.getTicksSpentInPiece().get());\n            rooms.add(pair);\n        });\n        return new PlayerPathData(\n                rooms,\n                strongholdPath.getTotalTime(),\n                computeDifficulty(solution),\n                history.stream()\n                        .filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n                        .map(StrongholdPathEntry::getTicksSpentInPiece)\n                        .mapToInt(AtomicInteger::get)\n                        .sum(),\n               \n                (int) history.stream()\n                        .map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n                        .filter(Objects::nonNull)\n                        .map(StrongholdPathEntry::getCurrentPiece)\n                        .filter(solution::contains)\n                        .count(),\n                this.inaccuracies.size(),\n                this.mistakes.size(),\n                this.blunders.size(),\n                (int) history.stream()\n                        .filter(entry -> !(entry.getCurrentPiece() instanceof StrongholdGenerator.PortalRoom))\n                        .filter(entry -> !areAdjacent(entry.getCurrentPiece(), strongholdPath.getNextEntry(entry).getCurrentPiece(), treeAccessor))\n                        .count(),\n                history.size() - 1,\n                history.stream()\n                        .filter(entry -> FEINBERG_AVG_ROOM_TIMES.containsKey(entry.getCurrentPiece().getClass()))\n                        .mapToInt(value -> value.getTicksSpentInPiece().get() - FEINBERG_AVG_ROOM_TIMES.get(value.getCurrentPiece().getClass()))\n                        .sum()\n        );\n    }","cleancode":"public playerpathdata populatestats() { this.playerentity = strongholdpath.getplayerentity(); strongholdgenerator.start start = this.strongholdpath.getstart(); strongholdtreeaccessor treeaccessor = (strongholdtreeaccessor) start; list<strongholdpathentry> history = this.strongholdpath.gethistory(); arraylist<structurepiece> solution = new arraylist<>(); strongholdgenerator.piece current = this.strongholdpath.gethistory().get(strongholdpath.gethistory().size() - 1).getcurrentpiece(); while (current != null) { solution.add(current); current = (strongholdgenerator.piece) treeaccessor.getparents().get(current); } list<strongholdpathentry> validentries = history.stream() .filter(entry -> validateentryforloss(strongholdpath, strongholdpath.getnextentry(entry))) .filter(entry -> !solution.contains(strongholdpath.getnextentry(entry).getcurrentpiece()) && solution.contains(entry.getcurrentpiece())) .collect(collectors.tolist()); list<pair<strongholdpathentry, double>> losses = new arraylist<>(); validentries.foreach(strongholdpathentry -> losses.add(new pair<>(strongholdpathentry, loss(strongholdpath, strongholdpath.getnextentry(strongholdpathentry), solution)))); this.inaccuracies = losses.stream().filter(pair -> pair.getright() >= inaccuracy_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); this.mistakes = losses.stream().filter(pair -> pair.getright() >= mistake_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); this.blunders = losses.stream().filter(pair -> pair.getright() >= blunder_threshold).map(pair::getleft).map(strongholdpathentry::getcurrentpiece).collect(collectors.tolist()); inaccuracies.removeall(this.mistakes); mistakes.removeall(this.blunders); arraylist<pair<strongholdgenerator.piece, integer>> rooms = new arraylist<>(); history.foreach(pathentry -> { pair<strongholdgenerator.piece, integer> pair = new pair<>(pathentry.getcurrentpiece(), pathentry.getticksspentinpiece().get()); rooms.add(pair); }); return new playerpathdata( rooms, strongholdpath.gettotaltime(), computedifficulty(solution), history.stream() .filter(pathentry -> !solution.contains(pathentry.getcurrentpiece())) .map(strongholdpathentry::getticksspentinpiece) .maptoint(atomicinteger::get) .sum(), (int) history.stream() .map(strongholdpathentry -> strongholdpath.getnextentry(strongholdpathentry)) .filter(objects::nonnull) .map(strongholdpathentry::getcurrentpiece) .filter(solution::contains) .count(), this.inaccuracies.size(), this.mistakes.size(), this.blunders.size(), (int) history.stream() .filter(entry -> !(entry.getcurrentpiece() instanceof strongholdgenerator.portalroom)) .filter(entry -> !areadjacent(entry.getcurrentpiece(), strongholdpath.getnextentry(entry).getcurrentpiece(), treeaccessor)) .count(), history.size() - 1, history.stream() .filter(entry -> feinberg_avg_room_times.containskey(entry.getcurrentpiece().getclass())) .maptoint(value -> value.getticksspentinpiece().get() - feinberg_avg_room_times.get(value.getcurrentpiece().getclass())) .sum() ); }","comment":"\/\/ todo: don't count entering the first five-way","repo":"ScribbleLP\/StrongholdTrainer","code_context_2":".mapToInt(AtomicInteger::get)\n.sum(),\n\/\/ TODO: don't count entering the first Five-Way\n(int) history.stream()\n.map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))","code_context_10":"});\nreturn new PlayerPathData(\nrooms,\nstrongholdPath.getTotalTime(),\ncomputeDifficulty(solution),\nhistory.stream()\n.filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n.map(StrongholdPathEntry::getTicksSpentInPiece)\n.mapToInt(AtomicInteger::get)\n.sum(),\n\/\/ TODO: don't count entering the first Five-Way\n(int) history.stream()\n.map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n.filter(Objects::nonNull)\n.map(StrongholdPathEntry::getCurrentPiece)\n.filter(solution::contains)\n.count(),\nthis.inaccuracies.size(),\nthis.mistakes.size(),\nthis.blunders.size(),\n(int) history.stream()","code_context_20":"validEntries.forEach(strongholdPathEntry -> losses.add(new Pair<>(strongholdPathEntry, loss(strongholdPath, strongholdPath.getNextEntry(strongholdPathEntry), solution))));\nthis.inaccuracies = losses.stream().filter(pair -> pair.getRight() >= INACCURACY_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\nthis.mistakes = losses.stream().filter(pair -> pair.getRight() >= MISTAKE_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\nthis.blunders = losses.stream().filter(pair -> pair.getRight() >= BLUNDER_THRESHOLD).map(Pair::getLeft).map(StrongholdPathEntry::getCurrentPiece).collect(Collectors.toList());\ninaccuracies.removeAll(this.mistakes);\nmistakes.removeAll(this.blunders);\nArrayList<Pair<StrongholdGenerator.Piece, Integer>> rooms = new ArrayList<>();\nhistory.forEach(pathEntry -> {\nPair<StrongholdGenerator.Piece, Integer> pair = new Pair<>(pathEntry.getCurrentPiece(), pathEntry.getTicksSpentInPiece().get());\nrooms.add(pair);\n});\nreturn new PlayerPathData(\nrooms,\nstrongholdPath.getTotalTime(),\ncomputeDifficulty(solution),\nhistory.stream()\n.filter(pathEntry -> !solution.contains(pathEntry.getCurrentPiece()))\n.map(StrongholdPathEntry::getTicksSpentInPiece)\n.mapToInt(AtomicInteger::get)\n.sum(),\n\/\/ TODO: don't count entering the first Five-Way\n(int) history.stream()\n.map(strongholdPathEntry -> strongholdPath.getNextEntry(strongholdPathEntry))\n.filter(Objects::nonNull)\n.map(StrongholdPathEntry::getCurrentPiece)\n.filter(solution::contains)\n.count(),\nthis.inaccuracies.size(),\nthis.mistakes.size(),\nthis.blunders.size(),\n(int) history.stream()\n.filter(entry -> !(entry.getCurrentPiece() instanceof StrongholdGenerator.PortalRoom))\n.filter(entry -> !areAdjacent(entry.getCurrentPiece(), strongholdPath.getNextEntry(entry).getCurrentPiece(), treeAccessor))\n.count(),\nhistory.size() - 1,\nhistory.stream()\n.filter(entry -> FEINBERG_AVG_ROOM_TIMES.containsKey(entry.getCurrentPiece().getClass()))\n.mapToInt(value -> value.getTicksSpentInPiece().get() - FEINBERG_AVG_ROOM_TIMES.get(value.getCurrentPiece().getClass()))\n.sum()\n);\n}","label":[0,1,0,0]}
{"id":17055,"original_code":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\n\t\t\tString reportLink) throws Exception {\n\t\tMimeMessage message = sender.createMimeMessage();\n\t\tMimeMessageHelper helper = new MimeMessageHelper(message);\n\t\tString stud1 = userService.findById(userId1).getfName();\n\t\tString stud2 = userService.findById(userId2).getfName();\n\t\thelper.setTo(\"anubhuti.vyas.28@gmail.com\");\n\t\thelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n\t\t\t\t+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n\t\t\t\t+ reportLink+ \"\/match0.html\");\n\t\t\/\/ to do add link in email\n\t\thelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\n\t\tsender.send(message);\n\t}","code":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\n\t\t\tString reportLink) throws Exception {\n\t\tMimeMessage message = sender.createMimeMessage();\n\t\tMimeMessageHelper helper = new MimeMessageHelper(message);\n\t\tString stud1 = userService.findById(userId1).getfName();\n\t\tString stud2 = userService.findById(userId2).getfName();\n\t\thelper.setTo(\"anubhuti.vyas.28@gmail.com\");\n\t\thelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n\t\t\t\t+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n\t\t\t\t+ reportLink+ \"\/match0.html\");\n\t\n\t\thelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\n\t\tsender.send(message);\n\t}","cleancode":"public void sendemail(string userid1, string userid2, string asgmtname, double score, string recipientmail, string reportlink) throws exception { mimemessage message = sender.createmimemessage(); mimemessagehelper helper = new mimemessagehelper(message); string stud1 = userservice.findbyid(userid1).getfname(); string stud2 = userservice.findbyid(userid2).getfname(); helper.setto(\"anubhuti.vyas.28@gmail.com\"); helper.settext(\"codesniffer found plagiarised submission with similarity score\" + score + \"click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\" + reportlink+ \"\/match0.html\"); helper.setsubject(\"plag detected in \" + asgmtname + \" between \" + stud1 + \" and \" + stud2); sender.send(message); }","comment":"\/** * send an email to given email address * @param userid1 * @param userid2 * @param asgmtname * @param score * @param recipientmail * @param reportlink * @throws exception *\/\n\/\/ to do add link in email","repo":"Stephen3333\/codesniffer","code_context_2":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\nString reportLink) throws Exception {\nMimeMessage message = sender.createMimeMessage();\nMimeMessageHelper helper = new MimeMessageHelper(message);\nString stud1 = userService.findById(userId1).getfName();\nString stud2 = userService.findById(userId2).getfName();\nhelper.setTo(\"anubhuti.vyas.28@gmail.com\");\nhelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);\n}\n\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);","code_context_10":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\nString reportLink) throws Exception {\nMimeMessage message = sender.createMimeMessage();\nMimeMessageHelper helper = new MimeMessageHelper(message);\nString stud1 = userService.findById(userId1).getfName();\nString stud2 = userService.findById(userId2).getfName();\nhelper.setTo(\"anubhuti.vyas.28@gmail.com\");\nhelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);\n}\n\npublic void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\nString reportLink) throws Exception {\nMimeMessage message = sender.createMimeMessage();\nMimeMessageHelper helper = new MimeMessageHelper(message);\nString stud1 = userService.findById(userId1).getfName();\nString stud2 = userService.findById(userId2).getfName();\nhelper.setTo(\"anubhuti.vyas.28@gmail.com\");\nhelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);\n}","code_context_20":"public void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\nString reportLink) throws Exception {\nMimeMessage message = sender.createMimeMessage();\nMimeMessageHelper helper = new MimeMessageHelper(message);\nString stud1 = userService.findById(userId1).getfName();\nString stud2 = userService.findById(userId2).getfName();\nhelper.setTo(\"anubhuti.vyas.28@gmail.com\");\nhelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);\n}\n\npublic void sendEmail(String userId1, String userId2, String asgmtName, double score, String recipientMail,\nString reportLink) throws Exception {\nMimeMessage message = sender.createMimeMessage();\nMimeMessageHelper helper = new MimeMessageHelper(message);\nString stud1 = userService.findById(userId1).getfName();\nString stud2 = userService.findById(userId2).getfName();\nhelper.setTo(\"anubhuti.vyas.28@gmail.com\");\nhelper.setText(\"Codesniffer found plagiarised submission with similarity score\" + score\n+ \"Click the below link to view the full report+\\n\" + \"https:\/\/s3.amazonaws.com\/codesniffer-reports\/\"\n+ reportLink+ \"\/match0.html\");\n\/\/ to do add link in email\nhelper.setSubject(\"Plag detected in \" + asgmtName + \" between \" + stud1 + \" and \" + stud2);\nsender.send(message);\n}","label":[0,1,0,0]}
{"id":17081,"original_code":"@Override\n    public void refresh()\n            throws LoginException, GSSException\n    {\n        \/\/ TODO: do we need to call logout() on the LoginContext?\n        loginContext = new LoginContext(\"\", null, null, new Configuration()\n        {\n            @Override\n            public AppConfigurationEntry[] getAppConfigurationEntry(String name)\n            {\n                ImmutableMap.Builder<String, String> options = ImmutableMap.builder();\n                options.put(\"refreshKrb5Config\", \"true\");\n                options.put(\"doNotPrompt\", \"true\");\n                options.put(\"useKeyTab\", \"true\");\n                if (getBoolean(\"trino.client.debugKerberos\")) {\n                    options.put(\"debug\", \"true\");\n                }\n                keytab.ifPresent(file -> options.put(\"keyTab\", file.getAbsolutePath()));\n                credentialCache.ifPresent(file -> {\n                    options.put(\"ticketCache\", file.getAbsolutePath());\n                    options.put(\"renewTGT\", \"true\");\n                });\n                if (!keytab.isPresent() || credentialCache.isPresent()) {\n                    options.put(\"useTicketCache\", \"true\");\n                }\n                principal.ifPresent(value -> options.put(\"principal\", value));\n                return new AppConfigurationEntry[] {\n                        new AppConfigurationEntry(Krb5LoginModule.class.getName(), REQUIRED, options.buildOrThrow())\n                };\n            }\n        });\n        loginContext.login();\n    }","code":"@Override\n    public void refresh()\n            throws LoginException, GSSException\n    {\n       \n        loginContext = new LoginContext(\"\", null, null, new Configuration()\n        {\n            @Override\n            public AppConfigurationEntry[] getAppConfigurationEntry(String name)\n            {\n                ImmutableMap.Builder<String, String> options = ImmutableMap.builder();\n                options.put(\"refreshKrb5Config\", \"true\");\n                options.put(\"doNotPrompt\", \"true\");\n                options.put(\"useKeyTab\", \"true\");\n                if (getBoolean(\"trino.client.debugKerberos\")) {\n                    options.put(\"debug\", \"true\");\n                }\n                keytab.ifPresent(file -> options.put(\"keyTab\", file.getAbsolutePath()));\n                credentialCache.ifPresent(file -> {\n                    options.put(\"ticketCache\", file.getAbsolutePath());\n                    options.put(\"renewTGT\", \"true\");\n                });\n                if (!keytab.isPresent() || credentialCache.isPresent()) {\n                    options.put(\"useTicketCache\", \"true\");\n                }\n                principal.ifPresent(value -> options.put(\"principal\", value));\n                return new AppConfigurationEntry[] {\n                        new AppConfigurationEntry(Krb5LoginModule.class.getName(), REQUIRED, options.buildOrThrow())\n                };\n            }\n        });\n        loginContext.login();\n    }","cleancode":"@override public void refresh() throws loginexception, gssexception { logincontext = new logincontext(\"\", null, null, new configuration() { @override public appconfigurationentry[] getappconfigurationentry(string name) { immutablemap.builder<string, string> options = immutablemap.builder(); options.put(\"refreshkrb5config\", \"true\"); options.put(\"donotprompt\", \"true\"); options.put(\"usekeytab\", \"true\"); if (getboolean(\"trino.client.debugkerberos\")) { options.put(\"debug\", \"true\"); } keytab.ifpresent(file -> options.put(\"keytab\", file.getabsolutepath())); credentialcache.ifpresent(file -> { options.put(\"ticketcache\", file.getabsolutepath()); options.put(\"renewtgt\", \"true\"); }); if (!keytab.ispresent() || credentialcache.ispresent()) { options.put(\"useticketcache\", \"true\"); } principal.ifpresent(value -> options.put(\"principal\", value)); return new appconfigurationentry[] { new appconfigurationentry(krb5loginmodule.class.getname(), required, options.buildorthrow()) }; } }); logincontext.login(); }","comment":"\/\/ todo: do we need to call logout() on the logincontext?","repo":"SanjayTechGuru\/TRINO","code_context_2":"throws LoginException, GSSException\n{\n\/\/ TODO: do we need to call logout() on the LoginContext?\nloginContext = new LoginContext(\"\", null, null, new Configuration()\n{","code_context_10":"@Override\npublic void refresh()\nthrows LoginException, GSSException\n{\n\/\/ TODO: do we need to call logout() on the LoginContext?\nloginContext = new LoginContext(\"\", null, null, new Configuration()\n{\n@Override\npublic AppConfigurationEntry[] getAppConfigurationEntry(String name)\n{\nImmutableMap.Builder<String, String> options = ImmutableMap.builder();\noptions.put(\"refreshKrb5Config\", \"true\");\noptions.put(\"doNotPrompt\", \"true\");\noptions.put(\"useKeyTab\", \"true\");\nif (getBoolean(\"trino.client.debugKerberos\")) {","code_context_20":"@Override\npublic void refresh()\nthrows LoginException, GSSException\n{\n\/\/ TODO: do we need to call logout() on the LoginContext?\nloginContext = new LoginContext(\"\", null, null, new Configuration()\n{\n@Override\npublic AppConfigurationEntry[] getAppConfigurationEntry(String name)\n{\nImmutableMap.Builder<String, String> options = ImmutableMap.builder();\noptions.put(\"refreshKrb5Config\", \"true\");\noptions.put(\"doNotPrompt\", \"true\");\noptions.put(\"useKeyTab\", \"true\");\nif (getBoolean(\"trino.client.debugKerberos\")) {\noptions.put(\"debug\", \"true\");\n}\nkeytab.ifPresent(file -> options.put(\"keyTab\", file.getAbsolutePath()));\ncredentialCache.ifPresent(file -> {\noptions.put(\"ticketCache\", file.getAbsolutePath());\noptions.put(\"renewTGT\", \"true\");\n});\nif (!keytab.isPresent() || credentialCache.isPresent()) {\noptions.put(\"useTicketCache\", \"true\");\n}","label":[1,0,0,0]}
{"id":17089,"original_code":"@Override\n      public void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\n          throws IOException, InterruptedException {\n        int defCount = 0;\n        refs.clear();\n        \/\/ We only expect two values, a DEF and a reference, but there might be more.\n        for (BytesWritable type : values) {\n          if (type.getLength() == DEF.getLength()) {\n            defCount++;\n          } else {\n            byte[] bytes = new byte[type.getLength()];\n            System.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\n            refs.add(bytes);\n          }\n        }\n        \/\/ TODO check for more than one def, should not happen\n        List<String> refsList = new ArrayList<>(refs.size());\n        String keyString = null;\n        if (defCount == 0 || refs.size() != 1) {\n          for (byte[] ref : refs) {\n            refsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n          }\n          keyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\n              Bytes.getLong(key.getBytes(), 8));\n          LOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n        }\n        if (defCount == 0 && refs.size() > 0) {\n          \/\/ this is bad, found a node that is referenced but not defined. It must have been\n          \/\/ lost, emit some info about this node for debugging purposes.\n          context.write(new Text(keyString), new Text(refsList.toString()));\n          context.getCounter(Counts.UNDEFINED).increment(1);\n        } else if (defCount > 0 && refs.size() == 0) {\n          \/\/ node is defined but not referenced\n          context.write(new Text(keyString), new Text(\"none\"));\n          context.getCounter(Counts.UNREFERENCED).increment(1);\n        } else {\n          if (refs.size() > 1) {\n            if (refsList != null) {\n              context.write(new Text(keyString), new Text(refsList.toString()));\n            }\n            context.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n          }\n          \/\/ node is defined and referenced\n          context.getCounter(Counts.REFERENCED).increment(1);\n        }\n      }","code":"@Override\n      public void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\n          throws IOException, InterruptedException {\n        int defCount = 0;\n        refs.clear();\n       \n        for (BytesWritable type : values) {\n          if (type.getLength() == DEF.getLength()) {\n            defCount++;\n          } else {\n            byte[] bytes = new byte[type.getLength()];\n            System.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\n            refs.add(bytes);\n          }\n        }\n       \n        List<String> refsList = new ArrayList<>(refs.size());\n        String keyString = null;\n        if (defCount == 0 || refs.size() != 1) {\n          for (byte[] ref : refs) {\n            refsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n          }\n          keyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\n              Bytes.getLong(key.getBytes(), 8));\n          LOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n        }\n        if (defCount == 0 && refs.size() > 0) {\n         \n         \n          context.write(new Text(keyString), new Text(refsList.toString()));\n          context.getCounter(Counts.UNDEFINED).increment(1);\n        } else if (defCount > 0 && refs.size() == 0) {\n         \n          context.write(new Text(keyString), new Text(\"none\"));\n          context.getCounter(Counts.UNREFERENCED).increment(1);\n        } else {\n          if (refs.size() > 1) {\n            if (refsList != null) {\n              context.write(new Text(keyString), new Text(refsList.toString()));\n            }\n            context.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n          }\n         \n          context.getCounter(Counts.REFERENCED).increment(1);\n        }\n      }","cleancode":"@override public void reduce(byteswritable key, iterable<byteswritable> values, context context) throws ioexception, interruptedexception { int defcount = 0; refs.clear(); for (byteswritable type : values) { if (type.getlength() == def.getlength()) { defcount++; } else { byte[] bytes = new byte[type.getlength()]; system.arraycopy(type.getbytes(), 0, bytes, 0, type.getlength()); refs.add(bytes); } } list<string> refslist = new arraylist<>(refs.size()); string keystring = null; if (defcount == 0 || refs.size() != 1) { for (byte[] ref : refs) { refslist.add(comma_joiner.join(bytes.getlong(ref), bytes.getlong(ref, 8))); } keystring = comma_joiner.join(bytes.getlong(key.getbytes()), bytes.getlong(key.getbytes(), 8)); log.error(\"linked list error: key = \" + keystring + \" references = \" + refslist); } if (defcount == 0 && refs.size() > 0) { context.write(new text(keystring), new text(refslist.tostring())); context.getcounter(counts.undefined).increment(1); } else if (defcount > 0 && refs.size() == 0) { context.write(new text(keystring), new text(\"none\")); context.getcounter(counts.unreferenced).increment(1); } else { if (refs.size() > 1) { if (refslist != null) { context.write(new text(keystring), new text(refslist.tostring())); } context.getcounter(counts.extrareferences).increment(refs.size() - 1); } context.getcounter(counts.referenced).increment(1); } }","comment":"\/\/ we only expect two values, a def and a reference, but there might be more.\n\/\/ todo check for more than one def, should not happen\n\/\/ this is bad, found a node that is referenced but not defined. it must have been \/\/ lost, emit some info about this node for debugging purposes.\n\/\/ node is defined but not referenced\n\/\/ node is defined and referenced","repo":"YCjia\/kudu","code_context_2":"int defCount = 0;\nrefs.clear();\n\/\/ We only expect two values, a DEF and a reference, but there might be more.\nfor (BytesWritable type : values) {\nif (type.getLength() == DEF.getLength()) {\n\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\n\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\ncontext.getCounter(Counts.REFERENCED).increment(1);\n}","code_context_10":"@Override\npublic void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\nthrows IOException, InterruptedException {\nint defCount = 0;\nrefs.clear();\n\/\/ We only expect two values, a DEF and a reference, but there might be more.\nfor (BytesWritable type : values) {\nif (type.getLength() == DEF.getLength()) {\ndefCount++;\n} else {\nbyte[] bytes = new byte[type.getLength()];\nSystem.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\n\n\/\/ We only expect two values, a DEF and a reference, but there might be more.\nfor (BytesWritable type : values) {\nif (type.getLength() == DEF.getLength()) {\ndefCount++;\n} else {\nbyte[] bytes = new byte[type.getLength()];\nSystem.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\n\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n}\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\n\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n}\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\ncontext.getCounter(Counts.REFERENCED).increment(1);\n}\n}","code_context_20":"@Override\npublic void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\nthrows IOException, InterruptedException {\nint defCount = 0;\nrefs.clear();\n\/\/ We only expect two values, a DEF and a reference, but there might be more.\nfor (BytesWritable type : values) {\nif (type.getLength() == DEF.getLength()) {\ndefCount++;\n} else {\nbyte[] bytes = new byte[type.getLength()];\nSystem.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\n\n@Override\npublic void reduce(BytesWritable key, Iterable<BytesWritable> values, Context context)\nthrows IOException, InterruptedException {\nint defCount = 0;\nrefs.clear();\n\/\/ We only expect two values, a DEF and a reference, but there might be more.\nfor (BytesWritable type : values) {\nif (type.getLength() == DEF.getLength()) {\ndefCount++;\n} else {\nbyte[] bytes = new byte[type.getLength()];\nSystem.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\n\nif (type.getLength() == DEF.getLength()) {\ndefCount++;\n} else {\nbyte[] bytes = new byte[type.getLength()];\nSystem.arraycopy(type.getBytes(), 0, bytes, 0, type.getLength());\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n}\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\ncontext.getCounter(Counts.REFERENCED).increment(1);\n}\n}\n\nrefs.add(bytes);\n}\n}\n\/\/ TODO check for more than one def, should not happen\nList<String> refsList = new ArrayList<>(refs.size());\nString keyString = null;\nif (defCount == 0 || refs.size() != 1) {\nfor (byte[] ref : refs) {\nrefsList.add(COMMA_JOINER.join(Bytes.getLong(ref), Bytes.getLong(ref, 8)));\n}\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n}\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\ncontext.getCounter(Counts.REFERENCED).increment(1);\n}\n}\n\nkeyString = COMMA_JOINER.join(Bytes.getLong(key.getBytes()),\nBytes.getLong(key.getBytes(), 8));\nLOG.error(\"Linked List error: Key = \" + keyString + \" References = \" + refsList);\n}\nif (defCount == 0 && refs.size() > 0) {\n\/\/ this is bad, found a node that is referenced but not defined. It must have been\n\/\/ lost, emit some info about this node for debugging purposes.\ncontext.write(new Text(keyString), new Text(refsList.toString()));\ncontext.getCounter(Counts.UNDEFINED).increment(1);\n} else if (defCount > 0 && refs.size() == 0) {\n\/\/ node is defined but not referenced\ncontext.write(new Text(keyString), new Text(\"none\"));\ncontext.getCounter(Counts.UNREFERENCED).increment(1);\n} else {\nif (refs.size() > 1) {\nif (refsList != null) {\ncontext.write(new Text(keyString), new Text(refsList.toString()));\n}\ncontext.getCounter(Counts.EXTRAREFERENCES).increment(refs.size() - 1);\n}\n\/\/ node is defined and referenced\ncontext.getCounter(Counts.REFERENCED).increment(1);\n}\n}","label":[1,1,0,0]}
{"id":748,"original_code":"public boolean addNewTodo(Request req, Response res)\n    {\n        res.type(\"application\/json\");\n        Object o = JSON.parse(req.body());\n        try {\n            if(o.getClass().equals(BasicDBObject.class))\n            {\n                try {\n                    BasicDBObject dbO = (BasicDBObject) o;\n                    String owner = dbO.getString(\"owner\");\n                    \/\/For some reason age is a string right now, caused by angular.\n                    \/\/This is a problem and should not be this way but here ya go\n                    boolean status = dbO.getBoolean(\"status\");\n                    String body = dbO.getString(\"body\");\n                    String category = dbO.getString(\"category\");\n                    System.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\n                    return todoController.addNewTodo(owner, category, body, status);\n                }\n                catch(NullPointerException e)\n                {\n                    System.err.println(\"A value was malformed or omitted, new todo request failed.\");\n                    return false;\n                }\n            }\n            else\n            {\n                System.err.println(\"Expected BasicDBObject, received \" + o.getClass());\n                return false;\n            }\n        }\n        catch(RuntimeException ree)\n        {\n            ree.printStackTrace();\n            return false;\n        }\n    }","code":"public boolean addNewTodo(Request req, Response res)\n    {\n        res.type(\"application\/json\");\n        Object o = JSON.parse(req.body());\n        try {\n            if(o.getClass().equals(BasicDBObject.class))\n            {\n                try {\n                    BasicDBObject dbO = (BasicDBObject) o;\n                    String owner = dbO.getString(\"owner\");\n                   \n                   \n                    boolean status = dbO.getBoolean(\"status\");\n                    String body = dbO.getString(\"body\");\n                    String category = dbO.getString(\"category\");\n                    System.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\n                    return todoController.addNewTodo(owner, category, body, status);\n                }\n                catch(NullPointerException e)\n                {\n                    System.err.println(\"A value was malformed or omitted, new todo request failed.\");\n                    return false;\n                }\n            }\n            else\n            {\n                System.err.println(\"Expected BasicDBObject, received \" + o.getClass());\n                return false;\n            }\n        }\n        catch(RuntimeException ree)\n        {\n            ree.printStackTrace();\n            return false;\n        }\n    }","cleancode":"public boolean addnewtodo(request req, response res) { res.type(\"application\/json\"); object o = json.parse(req.body()); try { if(o.getclass().equals(basicdbobject.class)) { try { basicdbobject dbo = (basicdbobject) o; string owner = dbo.getstring(\"owner\"); boolean status = dbo.getboolean(\"status\"); string body = dbo.getstring(\"body\"); string category = dbo.getstring(\"category\"); system.err.println(\"adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']'); return todocontroller.addnewtodo(owner, category, body, status); } catch(nullpointerexception e) { system.err.println(\"a value was malformed or omitted, new todo request failed.\"); return false; } } else { system.err.println(\"expected basicdbobject, received \" + o.getclass()); return false; } } catch(runtimeexception ree) { ree.printstacktrace(); return false; } }","comment":"\/**method called from server when the 'api\/todos\/new'endpoint is recieved. * gets specified todo info from request and calls addnewtodo helper method * to append that info to a document * * @param req the http request * @param res the http response * @return a boolean as whether the todo was added successfully or not *\/\n\/\/for some reason age is a string right now, caused by angular. \/\/this is a problem and should not be this way but here ya go","repo":"UMM-CSci-3601-S18\/lab-4-mongo-voyageurs-national-park","code_context_2":"public boolean addNewTodo(Request req, Response res)\n{\nres.type(\"application\/json\");\nObject o = JSON.parse(req.body());\ntry {\nif(o.getClass().equals(BasicDBObject.class))\n{\ntry {\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");\nString category = dbO.getString(\"category\");\nSystem.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\nreturn todoController.addNewTodo(owner, category, body, status);\n}\ncatch(NullPointerException e)\n{\nSystem.err.println(\"A value was malformed or omitted, new todo request failed.\");\nreturn false;\n}\n}\nelse\n{\nSystem.err.println(\"Expected BasicDBObject, received \" + o.getClass());\nreturn false;\n}\n}\ncatch(RuntimeException ree)\n{\nree.printStackTrace();\nreturn false;\n}\n}\n\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");","code_context_10":"public boolean addNewTodo(Request req, Response res)\n{\nres.type(\"application\/json\");\nObject o = JSON.parse(req.body());\ntry {\nif(o.getClass().equals(BasicDBObject.class))\n{\ntry {\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");\nString category = dbO.getString(\"category\");\nSystem.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\nreturn todoController.addNewTodo(owner, category, body, status);\n}\ncatch(NullPointerException e)\n{\nSystem.err.println(\"A value was malformed or omitted, new todo request failed.\");\nreturn false;\n}\n}\nelse\n{\nSystem.err.println(\"Expected BasicDBObject, received \" + o.getClass());\nreturn false;\n}\n}\ncatch(RuntimeException ree)\n{\nree.printStackTrace();\nreturn false;\n}\n}\n\npublic boolean addNewTodo(Request req, Response res)\n{\nres.type(\"application\/json\");\nObject o = JSON.parse(req.body());\ntry {\nif(o.getClass().equals(BasicDBObject.class))\n{\ntry {\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");\nString category = dbO.getString(\"category\");\nSystem.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\nreturn todoController.addNewTodo(owner, category, body, status);\n}\ncatch(NullPointerException e)\n{\nSystem.err.println(\"A value was malformed or omitted, new todo request failed.\");\nreturn false;","code_context_20":"public boolean addNewTodo(Request req, Response res)\n{\nres.type(\"application\/json\");\nObject o = JSON.parse(req.body());\ntry {\nif(o.getClass().equals(BasicDBObject.class))\n{\ntry {\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");\nString category = dbO.getString(\"category\");\nSystem.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\nreturn todoController.addNewTodo(owner, category, body, status);\n}\ncatch(NullPointerException e)\n{\nSystem.err.println(\"A value was malformed or omitted, new todo request failed.\");\nreturn false;\n}\n}\nelse\n{\nSystem.err.println(\"Expected BasicDBObject, received \" + o.getClass());\nreturn false;\n}\n}\ncatch(RuntimeException ree)\n{\nree.printStackTrace();\nreturn false;\n}\n}\n\npublic boolean addNewTodo(Request req, Response res)\n{\nres.type(\"application\/json\");\nObject o = JSON.parse(req.body());\ntry {\nif(o.getClass().equals(BasicDBObject.class))\n{\ntry {\nBasicDBObject dbO = (BasicDBObject) o;\nString owner = dbO.getString(\"owner\");\n\/\/For some reason age is a string right now, caused by angular.\n\/\/This is a problem and should not be this way but here ya go\nboolean status = dbO.getBoolean(\"status\");\nString body = dbO.getString(\"body\");\nString category = dbO.getString(\"category\");\nSystem.err.println(\"Adding new todo [owner=\" + owner + \", category=\" + category + \" body=\" + body + \" status=\" + status + ']');\nreturn todoController.addNewTodo(owner, category, body, status);\n}\ncatch(NullPointerException e)\n{\nSystem.err.println(\"A value was malformed or omitted, new todo request failed.\");\nreturn false;\n}\n}\nelse\n{\nSystem.err.println(\"Expected BasicDBObject, received \" + o.getClass());\nreturn false;\n}\n}\ncatch(RuntimeException ree)\n{","label":[0,0,1,0]}
{"id":25329,"original_code":"public void shutdown() {\n\t\t    try {\n\t\t\t\tLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\n\t\t\t\trunning.set(false);\n\t\t\t\t\/\/ This isn't good, the Jedis object is not thread safe\n\t\t\t\tjedis.disconnect();\n\t\t    } catch (Exception e) {\n\t\t    \tLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n\t\t    }\n\t\t}","code":"public void shutdown() {\n\t\t    try {\n\t\t\t\tLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\n\t\t\t\trunning.set(false);\n\t\t\t\n\t\t\t\tjedis.disconnect();\n\t\t    } catch (Exception e) {\n\t\t    \tLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n\t\t    }\n\t\t}","cleancode":"public void shutdown() { try { logger.info(\"shutting down listener on \" + host + \":\" + port); running.set(false); jedis.disconnect(); } catch (exception e) { logger.error(\"caught exception while shutting down: \" + e.getmessage()); } }","comment":"\/\/ this isn't good, the jedis object is not thread safe","repo":"Samsung\/Spark-CEP","code_context_2":"LOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\nrunning.set(false);\n\/\/ This isn't good, the Jedis object is not thread safe\njedis.disconnect();\n} catch (Exception e) {","code_context_10":"public void shutdown() {\ntry {\nLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\nrunning.set(false);\n\/\/ This isn't good, the Jedis object is not thread safe\njedis.disconnect();\n} catch (Exception e) {\nLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n}\n}","code_context_20":"public void shutdown() {\ntry {\nLOGGER.info(\"Shutting down listener on \" + host + \":\" + port);\nrunning.set(false);\n\/\/ This isn't good, the Jedis object is not thread safe\njedis.disconnect();\n} catch (Exception e) {\nLOGGER.error(\"Caught exception while shutting down: \" + e.getMessage());\n}\n}","label":[1,0,0,0]}
{"id":17260,"original_code":"public int getLineForVertical(int vertical) {\n        int high = getLineCount(), low = -1, guess;\n        while (high - low > 1) {\n            guess = (high + low) \/ 2;\n            if (getLineTop(guess) > vertical)\n                high = guess;\n            else\n                low = guess;\n        }\n        if (low < 0)\n            return 0;\n        else\n            return low;\n    }","code":"public int getLineForVertical(int vertical) {\n        int high = getLineCount(), low = -1, guess;\n        while (high - low > 1) {\n            guess = (high + low) \/ 2;\n            if (getLineTop(guess) > vertical)\n                high = guess;\n            else\n                low = guess;\n        }\n        if (low < 0)\n            return 0;\n        else\n            return low;\n    }","cleancode":"public int getlineforvertical(int vertical) { int high = getlinecount(), low = -1, guess; while (high - low > 1) { guess = (high + low) \/ 2; if (getlinetop(guess) > vertical) high = guess; else low = guess; } if (low < 0) return 0; else return low; }","comment":"\/** * get the line number corresponding to the specified vertical position. * if you ask for a position above 0, you get 0; if you ask for a position * below the bottom of the text, you get the last line. *\/ \/\/ fixme: it may be faster to do a linear search for layouts without many lines.","repo":"VPeruS\/JotaTextEditor","code_context_2":"public int getLineForVertical(int vertical) {\nint high = getLineCount(), low = -1, guess;\nwhile (high - low > 1) {\nguess = (high + low) \/ 2;\nif (getLineTop(guess) > vertical)\nhigh = guess;\nelse\nlow = guess;\n}\nif (low < 0)\nreturn 0;\nelse\nreturn low;\n}","code_context_10":"public int getLineForVertical(int vertical) {\nint high = getLineCount(), low = -1, guess;\nwhile (high - low > 1) {\nguess = (high + low) \/ 2;\nif (getLineTop(guess) > vertical)\nhigh = guess;\nelse\nlow = guess;\n}\nif (low < 0)\nreturn 0;\nelse\nreturn low;\n}","code_context_20":"public int getLineForVertical(int vertical) {\nint high = getLineCount(), low = -1, guess;\nwhile (high - low > 1) {\nguess = (high + low) \/ 2;\nif (getLineTop(guess) > vertical)\nhigh = guess;\nelse\nlow = guess;\n}\nif (low < 0)\nreturn 0;\nelse\nreturn low;\n}","label":[1,0,0,0]}
{"id":9218,"original_code":"@Override\n    public void visitElement(PsiElement element) {\n        if (this.context.skip(element)) {\n            return;\n        }\n        \/\/ TODO: the refactor\n        this.holder.registerProblem(element, this.context.getMessage());\n    }","code":"@Override\n    public void visitElement(PsiElement element) {\n        if (this.context.skip(element)) {\n            return;\n        }\n       \n        this.holder.registerProblem(element, this.context.getMessage());\n    }","cleancode":"@override public void visitelement(psielement element) { if (this.context.skip(element)) { return; } this.holder.registerproblem(element, this.context.getmessage()); }","comment":"\/\/ todo: the refactor","repo":"aarthibl\/intellibot","code_context_2":"return;\n}\n\/\/ TODO: the refactor\nthis.holder.registerProblem(element, this.context.getMessage());\n}","code_context_10":"@Override\npublic void visitElement(PsiElement element) {\nif (this.context.skip(element)) {\nreturn;\n}\n\/\/ TODO: the refactor\nthis.holder.registerProblem(element, this.context.getMessage());\n}","code_context_20":"@Override\npublic void visitElement(PsiElement element) {\nif (this.context.skip(element)) {\nreturn;\n}\n\/\/ TODO: the refactor\nthis.holder.registerProblem(element, this.context.getMessage());\n}","label":[1,0,0,0]}
{"id":9220,"original_code":"private static ConfigurationOptions defaultOptions() {\n        return ConfigurationOptions.defaults()\n                .serializers(SpongeCommon.game().configManager().serializers());\n    }","code":"private static ConfigurationOptions defaultOptions() {\n        return ConfigurationOptions.defaults()\n                .serializers(SpongeCommon.game().configManager().serializers());\n    }","cleancode":"private static configurationoptions defaultoptions() { return configurationoptions.defaults() .serializers(spongecommon.game().configmanager().serializers()); }","comment":"\/\/ todo: do these need to be hooked up for saving as well? currently they just load","repo":"SpongePowered\/Common","code_context_2":"private static ConfigurationOptions defaultOptions() {\nreturn ConfigurationOptions.defaults()\n.serializers(SpongeCommon.game().configManager().serializers());\n}","code_context_10":"private static ConfigurationOptions defaultOptions() {\nreturn ConfigurationOptions.defaults()\n.serializers(SpongeCommon.game().configManager().serializers());\n}","code_context_20":"private static ConfigurationOptions defaultOptions() {\nreturn ConfigurationOptions.defaults()\n.serializers(SpongeCommon.game().configManager().serializers());\n}","label":[1,0,0,0]}
{"id":25606,"original_code":"@Test\n\tpublic void testRetrieveUserByName() {\n\t\tem.getTransaction().begin();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\n\t\tem.getTransaction().commit();\n\t\tList<User> users = null;\n\t\ttry {\n\t\t\t\/\/TODO use .equals() once we ahve overridden appropriate methods\n\t\t\tusers = dao.getUsers();\n\t\t} catch (Throwable th){\n\t\t\tfail(th.getMessage());\n\t\t}\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\n\t\tassertEquals(3, users.size());\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\n\t\t\tassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());\n\t\t\tassertEquals(cal.getTime().toString(), users.get(i).getDate().toString());\n\t\t}\n\t}","code":"@Test\n\tpublic void testRetrieveUserByName() {\n\t\tem.getTransaction().begin();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\n\t\tem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n\t\t\t\t+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\n\t\tem.getTransaction().commit();\n\t\tList<User> users = null;\n\t\ttry {\n\t\t\n\t\t\tusers = dao.getUsers();\n\t\t} catch (Throwable th){\n\t\t\tfail(th.getMessage());\n\t\t}\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\n\t\tassertEquals(3, users.size());\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\n\t\t\tassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());\n\t\t\tassertEquals(cal.getTime().toString(), users.get(i).getDate().toString());\n\t\t}\n\t}","cleancode":"@test public void testretrieveuserbyname() { em.gettransaction().begin(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (1, 'boom1', '1988-09-15', 'test user1');\").executeupdate(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (2, 'boom2', '1988-09-15', 'test user2');\").executeupdate(); em.createnativequery(\"insert into t_users( user_id, name, date_added, description)\" + \" values (3, 'boom3', '1988-09-15', 'test user3');\").executeupdate(); em.gettransaction().commit(); list<user> users = null; try { users = dao.getusers(); } catch (throwable th){ fail(th.getmessage()); } calendar cal = calendar.getinstance(); cal.set(1988, calendar.september, 15, 0, 0, 0); assertequals(3, users.size()); for (int i = 0; i < 3; i++) { assertequals(\"boom\" + users.get(i).getid(), users.get(i).getname()); assertequals(\"test user\" + users.get(i).getid(), users.get(i).getdescription()); assertequals(cal.gettime().tostring(), users.get(i).getdate().tostring()); } }","comment":"\/\/todo use .equals() once we ahve overridden appropriate methods","repo":"andrewflbarnes\/debt-tracker","code_context_2":"List<User> users = null;\ntry {\n\/\/TODO use .equals() once we ahve overridden appropriate methods\nusers = dao.getUsers();\n} catch (Throwable th){","code_context_10":"em.getTransaction().begin();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\nem.getTransaction().commit();\nList<User> users = null;\ntry {\n\/\/TODO use .equals() once we ahve overridden appropriate methods\nusers = dao.getUsers();\n} catch (Throwable th){\nfail(th.getMessage());\n}\nCalendar cal = Calendar.getInstance();\ncal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\nassertEquals(3, users.size());\nfor (int i = 0; i < 3; i++) {\nassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\nassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());","code_context_20":"@Test\npublic void testRetrieveUserByName() {\nem.getTransaction().begin();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (1, 'BOOM1', '1988-09-15', 'TEST USER1');\").executeUpdate();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (2, 'BOOM2', '1988-09-15', 'TEST USER2');\").executeUpdate();\nem.createNativeQuery(\"INSERT INTO t_users( user_id, name, date_added, description)\"\n+ \" VALUES (3, 'BOOM3', '1988-09-15', 'TEST USER3');\").executeUpdate();\nem.getTransaction().commit();\nList<User> users = null;\ntry {\n\/\/TODO use .equals() once we ahve overridden appropriate methods\nusers = dao.getUsers();\n} catch (Throwable th){\nfail(th.getMessage());\n}\nCalendar cal = Calendar.getInstance();\ncal.set(1988, Calendar.SEPTEMBER, 15, 0, 0, 0);\nassertEquals(3, users.size());\nfor (int i = 0; i < 3; i++) {\nassertEquals(\"BOOM\" + users.get(i).getId(), users.get(i).getName());\nassertEquals(\"TEST USER\" + users.get(i).getId(), users.get(i).getDescription());\nassertEquals(cal.getTime().toString(), users.get(i).getDate().toString());\n}\n}","label":[0,1,0,0]}
{"id":1134,"original_code":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\n\t\t\tKeyedBackendSerializationProxy<K> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\n\t\t\tserializationProxy.read(currentStateHandleInView);\n\t\t\t\/\/ check for key serializer compatibility; this also reconfigures the\n\t\t\t\/\/ key serializer to be compatible, if it is required and is possible\n\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\trocksDBKeyedStateBackend.keySerializer)\n\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\n\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t}\n\t\t\tthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\n\t\t\t\tSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\n\t\t\tList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\n\t\t\t\t\tserializationProxy.getStateMetaInfoSnapshots();\n\t\t\tcurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\t\t\t\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\n\t\t\tfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\n\t\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\n\t\t\t\tif (registeredColumn == null) {\n\t\t\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\n\t\t\t\t\t\trestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\n\t\t\t\t\t\trocksDBKeyedStateBackend.columnOptions);\n\t\t\t\t\tRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\n\t\t\t\t\t\t\tnew RegisteredKeyedBackendStateMetaInfo<>(\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateType(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getName(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getNamespaceSerializer(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateSerializer());\n\t\t\t\t\trocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\n\t\t\t\t\tColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\n\t\t\t\t\tregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n\t\t\t\t}\n\t\t\t\tcurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n\t\t\t}\n\t\t}","code":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\n\t\t\tKeyedBackendSerializationProxy<K> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\n\t\t\tserializationProxy.read(currentStateHandleInView);\n\t\t\n\t\t\n\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\trocksDBKeyedStateBackend.keySerializer)\n\t\t\t\t.isRequiresMigration()) {\n\t\t\t\n\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t}\n\t\t\tthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\n\t\t\t\tSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\n\t\t\tList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\n\t\t\t\t\tserializationProxy.getStateMetaInfoSnapshots();\n\t\t\tcurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\t\t\n\t\t\tfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\n\t\t\t\tTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\n\t\t\t\tif (registeredColumn == null) {\n\t\t\t\t\tColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\n\t\t\t\t\t\trestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\n\t\t\t\t\t\trocksDBKeyedStateBackend.columnOptions);\n\t\t\t\t\tRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\n\t\t\t\t\t\t\tnew RegisteredKeyedBackendStateMetaInfo<>(\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateType(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getName(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getNamespaceSerializer(),\n\t\t\t\t\t\t\t\trestoredMetaInfo.getStateSerializer());\n\t\t\t\t\trocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\n\t\t\t\t\tColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\n\t\t\t\t\tregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\n\t\t\t\t\trocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\tcurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n\t\t\t}\n\t\t}","cleancode":"private void restorekvstatemetadata() throws ioexception, statemigrationexception, rocksdbexception { keyedbackendserializationproxy<k> serializationproxy = new keyedbackendserializationproxy<>(rocksdbkeyedstatebackend.usercodeclassloader); serializationproxy.read(currentstatehandleinview); if (compatibilityutil.resolvecompatibilityresult( serializationproxy.getkeyserializer(), unloadabledummytypeserializer.class, serializationproxy.getkeyserializerconfigsnapshot(), rocksdbkeyedstatebackend.keyserializer) .isrequiresmigration()) { throw new statemigrationexception(\"the new key serializer is not compatible to read previous keys. \" + \"aborting now since state migration is currently not available\"); } this.keygroupstreamcompressiondecorator = serializationproxy.isusingkeygroupcompression() ? snappystreamcompressiondecorator.instance : uncompressedstreamcompressiondecorator.instance; list<registeredkeyedbackendstatemetainfo.snapshot<?, ?>> restoredmetainfos = serializationproxy.getstatemetainfosnapshots(); currentstatehandlekvstatecolumnfamilies = new arraylist<>(restoredmetainfos.size()); for (registeredkeyedbackendstatemetainfo.snapshot<?, ?> restoredmetainfo : restoredmetainfos) { tuple2<columnfamilyhandle, registeredkeyedbackendstatemetainfo<?, ?>> registeredcolumn = rocksdbkeyedstatebackend.kvstateinformation.get(restoredmetainfo.getname()); if (registeredcolumn == null) { columnfamilydescriptor columnfamilydescriptor = new columnfamilydescriptor( restoredmetainfo.getname().getbytes(configconstants.default_charset), rocksdbkeyedstatebackend.columnoptions); registeredkeyedbackendstatemetainfo<?, ?> statemetainfo = new registeredkeyedbackendstatemetainfo<>( restoredmetainfo.getstatetype(), restoredmetainfo.getname(), restoredmetainfo.getnamespaceserializer(), restoredmetainfo.getstateserializer()); rocksdbkeyedstatebackend.restoredkvstatemetainfos.put(restoredmetainfo.getname(), restoredmetainfo); columnfamilyhandle columnfamily = rocksdbkeyedstatebackend.db.createcolumnfamily(columnfamilydescriptor); registeredcolumn = new tuple2<columnfamilyhandle, registeredkeyedbackendstatemetainfo<?, ?>>(columnfamily, statemetainfo); rocksdbkeyedstatebackend.kvstateinformation.put(statemetainfo.getname(), registeredcolumn); } else { } currentstatehandlekvstatecolumnfamilies.add(registeredcolumn.f0); } }","comment":"\/** * restore the kv-state \/ columnfamily meta data for all key-groups referenced by the current state handle. * * @throws ioexception * @throws classnotfoundexception * @throws rocksdbexception *\/\n\/\/ check for key serializer compatibility; this also reconfigures the \/\/ key serializer to be compatible, if it is required and is possible\n\/\/ todo replace with state migration; note that key hash codes need to remain the same after migration\n\/\/rocksdbkeyedstatebackend.restoredkvstatemetainfos = new hashmap<>(restoredmetainfos.size());\n\/\/ todo with eager state registration in place, check here for serializer migration strategies","repo":"alpinegizmo\/flink","code_context_2":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n}\n}\n\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\n\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\n\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);","code_context_10":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n}\n}\n\nprivate void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\n\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\n\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\n\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n}\n}","code_context_20":"private void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n}\n}\n\nprivate void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\n\nprivate void restoreKVStateMetaData() throws IOException, StateMigrationException, RocksDBException {\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\n\nKeyedBackendSerializationProxy<K> serializationProxy =\nnew KeyedBackendSerializationProxy<>(rocksDBKeyedStateBackend.userCodeClassLoader);\nserializationProxy.read(currentStateHandleInView);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nrocksDBKeyedStateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nthis.keygroupStreamCompressionDecorator = serializationProxy.isUsingKeyGroupCompression() ?\nSnappyStreamCompressionDecorator.INSTANCE : UncompressedStreamCompressionDecorator.INSTANCE;\nList<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> restoredMetaInfos =\nserializationProxy.getStateMetaInfoSnapshots();\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\n\ncurrentStateHandleKVStateColumnFamilies = new ArrayList<>(restoredMetaInfos.size());\n\/\/rocksDBKeyedStateBackend.restoredKvStateMetaInfos = new HashMap<>(restoredMetaInfos.size());\nfor (RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?> restoredMetaInfo : restoredMetaInfos) {\nTuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>> registeredColumn =\nrocksDBKeyedStateBackend.kvStateInformation.get(restoredMetaInfo.getName());\nif (registeredColumn == null) {\nColumnFamilyDescriptor columnFamilyDescriptor = new ColumnFamilyDescriptor(\nrestoredMetaInfo.getName().getBytes(ConfigConstants.DEFAULT_CHARSET),\nrocksDBKeyedStateBackend.columnOptions);\nRegisteredKeyedBackendStateMetaInfo<?, ?> stateMetaInfo =\nnew RegisteredKeyedBackendStateMetaInfo<>(\nrestoredMetaInfo.getStateType(),\nrestoredMetaInfo.getName(),\nrestoredMetaInfo.getNamespaceSerializer(),\nrestoredMetaInfo.getStateSerializer());\nrocksDBKeyedStateBackend.restoredKvStateMetaInfos.put(restoredMetaInfo.getName(), restoredMetaInfo);\nColumnFamilyHandle columnFamily = rocksDBKeyedStateBackend.db.createColumnFamily(columnFamilyDescriptor);\nregisteredColumn = new Tuple2<ColumnFamilyHandle, RegisteredKeyedBackendStateMetaInfo<?, ?>>(columnFamily, stateMetaInfo);\nrocksDBKeyedStateBackend.kvStateInformation.put(stateMetaInfo.getName(), registeredColumn);\n} else {\n\/\/ TODO with eager state registration in place, check here for serializer migration strategies\n}\ncurrentStateHandleKVStateColumnFamilies.add(registeredColumn.f0);\n}\n}","label":[1,1,0,0]}
{"id":1136,"original_code":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\n\t\t\t\tStreamStateHandle metaStateHandle) throws Exception {\n\t\t\tFSDataInputStream inputStream = null;\n\t\t\ttry {\n\t\t\t\tinputStream = metaStateHandle.openInputStream();\n\t\t\t\tstateBackend.cancelStreamRegistry.registerClosable(inputStream);\n\t\t\t\tKeyedBackendSerializationProxy<T> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\n\t\t\t\tDataInputView in = new DataInputViewStreamWrapper(inputStream);\n\t\t\t\tserializationProxy.read(in);\n\t\t\t\t\/\/ check for key serializer compatibility; this also reconfigures the\n\t\t\t\t\/\/ key serializer to be compatible, if it is required and is possible\n\t\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\t\tstateBackend.keySerializer)\n\t\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\t\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\n\t\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t\t}\n\t\t\t\treturn serializationProxy.getStateMetaInfoSnapshots();\n\t\t\t} finally {\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}","code":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\n\t\t\t\tStreamStateHandle metaStateHandle) throws Exception {\n\t\t\tFSDataInputStream inputStream = null;\n\t\t\ttry {\n\t\t\t\tinputStream = metaStateHandle.openInputStream();\n\t\t\t\tstateBackend.cancelStreamRegistry.registerClosable(inputStream);\n\t\t\t\tKeyedBackendSerializationProxy<T> serializationProxy =\n\t\t\t\t\tnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\n\t\t\t\tDataInputView in = new DataInputViewStreamWrapper(inputStream);\n\t\t\t\tserializationProxy.read(in);\n\t\t\t\n\t\t\t\n\t\t\t\tif (CompatibilityUtil.resolveCompatibilityResult(\n\t\t\t\t\t\tserializationProxy.getKeySerializer(),\n\t\t\t\t\t\tUnloadableDummyTypeSerializer.class,\n\t\t\t\t\t\tserializationProxy.getKeySerializerConfigSnapshot(),\n\t\t\t\t\t\tstateBackend.keySerializer)\n\t\t\t\t\t.isRequiresMigration()) {\n\t\t\t\t\n\t\t\t\t\tthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\t\t\t\t\t\t\"Aborting now since state migration is currently not available\");\n\t\t\t\t}\n\t\t\t\treturn serializationProxy.getStateMetaInfoSnapshots();\n\t\t\t} finally {\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private list<registeredkeyedbackendstatemetainfo.snapshot<?, ?>> readmetadata( streamstatehandle metastatehandle) throws exception { fsdatainputstream inputstream = null; try { inputstream = metastatehandle.openinputstream(); statebackend.cancelstreamregistry.registerclosable(inputstream); keyedbackendserializationproxy<t> serializationproxy = new keyedbackendserializationproxy<>(statebackend.usercodeclassloader); datainputview in = new datainputviewstreamwrapper(inputstream); serializationproxy.read(in); if (compatibilityutil.resolvecompatibilityresult( serializationproxy.getkeyserializer(), unloadabledummytypeserializer.class, serializationproxy.getkeyserializerconfigsnapshot(), statebackend.keyserializer) .isrequiresmigration()) { throw new statemigrationexception(\"the new key serializer is not compatible to read previous keys. \" + \"aborting now since state migration is currently not available\"); } return serializationproxy.getstatemetainfosnapshots(); } finally { if (inputstream != null) { statebackend.cancelstreamregistry.unregisterclosable(inputstream); inputstream.close(); } } }","comment":"\/\/ check for key serializer compatibility; this also reconfigures the \/\/ key serializer to be compatible, if it is required and is possible\n\/\/ todo replace with state migration; note that key hash codes need to remain the same after migration","repo":"alpinegizmo\/flink","code_context_2":"DataInputView in = new DataInputViewStreamWrapper(inputStream);\nserializationProxy.read(in);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\n\nstateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");","code_context_10":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\nStreamStateHandle metaStateHandle) throws Exception {\nFSDataInputStream inputStream = null;\ntry {\ninputStream = metaStateHandle.openInputStream();\nstateBackend.cancelStreamRegistry.registerClosable(inputStream);\nKeyedBackendSerializationProxy<T> serializationProxy =\nnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\nDataInputView in = new DataInputViewStreamWrapper(inputStream);\nserializationProxy.read(in);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nstateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\n\nDataInputView in = new DataInputViewStreamWrapper(inputStream);\nserializationProxy.read(in);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nstateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nreturn serializationProxy.getStateMetaInfoSnapshots();\n} finally {\nif (inputStream != null) {\nstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\ninputStream.close();\n}\n}","code_context_20":"private List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\nStreamStateHandle metaStateHandle) throws Exception {\nFSDataInputStream inputStream = null;\ntry {\ninputStream = metaStateHandle.openInputStream();\nstateBackend.cancelStreamRegistry.registerClosable(inputStream);\nKeyedBackendSerializationProxy<T> serializationProxy =\nnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\nDataInputView in = new DataInputViewStreamWrapper(inputStream);\nserializationProxy.read(in);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nstateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nreturn serializationProxy.getStateMetaInfoSnapshots();\n} finally {\nif (inputStream != null) {\nstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\ninputStream.close();\n}\n}\n}\n\nprivate List<RegisteredKeyedBackendStateMetaInfo.Snapshot<?, ?>> readMetaData(\nStreamStateHandle metaStateHandle) throws Exception {\nFSDataInputStream inputStream = null;\ntry {\ninputStream = metaStateHandle.openInputStream();\nstateBackend.cancelStreamRegistry.registerClosable(inputStream);\nKeyedBackendSerializationProxy<T> serializationProxy =\nnew KeyedBackendSerializationProxy<>(stateBackend.userCodeClassLoader);\nDataInputView in = new DataInputViewStreamWrapper(inputStream);\nserializationProxy.read(in);\n\/\/ check for key serializer compatibility; this also reconfigures the\n\/\/ key serializer to be compatible, if it is required and is possible\nif (CompatibilityUtil.resolveCompatibilityResult(\nserializationProxy.getKeySerializer(),\nUnloadableDummyTypeSerializer.class,\nserializationProxy.getKeySerializerConfigSnapshot(),\nstateBackend.keySerializer)\n.isRequiresMigration()) {\n\/\/ TODO replace with state migration; note that key hash codes need to remain the same after migration\nthrow new StateMigrationException(\"The new key serializer is not compatible to read previous keys. \" +\n\"Aborting now since state migration is currently not available\");\n}\nreturn serializationProxy.getStateMetaInfoSnapshots();\n} finally {\nif (inputStream != null) {\nstateBackend.cancelStreamRegistry.unregisterClosable(inputStream);\ninputStream.close();\n}\n}\n}","label":[1,0,0,0]}
{"id":25762,"original_code":"@Test\n    public void testCreateDbAndTable() throws Exception {\n        \/\/ 1. create connect context\n        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n        \/\/ 2. create database db1\n        String createDbStmtStr = \"create database db1;\";\n        CreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\n        Catalog.getCurrentCatalog().createDb(createDbStmt);\n        System.out.println(Catalog.getCurrentCatalog().getDbNames());\n        \/\/ 3. create table tbl1\n        String createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n                \"'colocate_with' = 'g1');\";\n        CreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\n        Catalog.getCurrentCatalog().createTable(createTableStmt);\n        \/\/ must set replicas' path hash, or the tablet scheduler won't work\n        updateReplicaPathHash();\n        \/\/ 4. get and test the created db and table\n        Database db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\n        Assert.assertNotNull(db);\n        OlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl.readLock();\n        try {\n            Assert.assertNotNull(tbl);\n            System.out.println(tbl.getName());\n            Assert.assertEquals(\"Doris\", tbl.getEngine());\n            Assert.assertEquals(1, tbl.getBaseSchema().size());\n        } finally {\n            tbl.readUnlock();\n        }\n        \/\/ 5. process a schema change job\n        String alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\n        AlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\n        Catalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n        \/\/ 6. check alter job\n        Map<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\n        Assert.assertEquals(1, alterJobs.size());\n        for (AlterJobV2 alterJobV2 : alterJobs.values()) {\n            while (!alterJobV2.getJobState().isFinalState()) {\n                System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\n                Thread.sleep(1000);\n            }\n            System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\n            Assert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n        }\n        OlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl1.readLock();\n        try {\n            Assert.assertEquals(2, tbl1.getBaseSchema().size());\n            String baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\n            Assert.assertEquals(baseIndexName, tbl1.getName());\n            MaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\n            Assert.assertNotNull(indexMeta);\n        } finally {\n            tbl1.readUnlock();\n        }\n        \/\/ 7. query\n        \/\/ TODO: we can not process real query for now. So it has to be a explain query\n        String queryStr = \"explain select * from db1.tbl1\";\n        String a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\n        System.out.println(a);\n        StmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\n        stmtExecutor.execute();\n        Planner planner = stmtExecutor.planner();\n        List<PlanFragment> fragments = planner.getFragments();\n        Assert.assertEquals(2, fragments.size());\n        PlanFragment fragment = fragments.get(1);\n        Assert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\n        Assert.assertEquals(0, fragment.getChildren().size());\n        \/\/ test show backends;\n        BackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\n        ProcResult result = dir.fetchResult();\n        Assert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\n        Assert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\n        Assert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\n                result.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n    }","code":"@Test\n    public void testCreateDbAndTable() throws Exception {\n       \n        ConnectContext ctx = UtFrameUtils.createDefaultCtx();\n       \n        String createDbStmtStr = \"create database db1;\";\n        CreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\n        Catalog.getCurrentCatalog().createDb(createDbStmt);\n        System.out.println(Catalog.getCurrentCatalog().getDbNames());\n       \n        String createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n                \"'colocate_with' = 'g1');\";\n        CreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\n        Catalog.getCurrentCatalog().createTable(createTableStmt);\n       \n        updateReplicaPathHash();\n       \n        Database db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\n        Assert.assertNotNull(db);\n        OlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl.readLock();\n        try {\n            Assert.assertNotNull(tbl);\n            System.out.println(tbl.getName());\n            Assert.assertEquals(\"Doris\", tbl.getEngine());\n            Assert.assertEquals(1, tbl.getBaseSchema().size());\n        } finally {\n            tbl.readUnlock();\n        }\n       \n        String alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\n        AlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\n        Catalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n       \n        Map<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\n        Assert.assertEquals(1, alterJobs.size());\n        for (AlterJobV2 alterJobV2 : alterJobs.values()) {\n            while (!alterJobV2.getJobState().isFinalState()) {\n                System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\n                Thread.sleep(1000);\n            }\n            System.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\n            Assert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n        }\n        OlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\n        tbl1.readLock();\n        try {\n            Assert.assertEquals(2, tbl1.getBaseSchema().size());\n            String baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\n            Assert.assertEquals(baseIndexName, tbl1.getName());\n            MaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\n            Assert.assertNotNull(indexMeta);\n        } finally {\n            tbl1.readUnlock();\n        }\n       \n       \n        String queryStr = \"explain select * from db1.tbl1\";\n        String a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\n        System.out.println(a);\n        StmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\n        stmtExecutor.execute();\n        Planner planner = stmtExecutor.planner();\n        List<PlanFragment> fragments = planner.getFragments();\n        Assert.assertEquals(2, fragments.size());\n        PlanFragment fragment = fragments.get(1);\n        Assert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\n        Assert.assertEquals(0, fragment.getChildren().size());\n       \n        BackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\n        ProcResult result = dir.fetchResult();\n        Assert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\n        Assert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\n        Assert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\n                result.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n    }","cleancode":"@test public void testcreatedbandtable() throws exception { connectcontext ctx = utframeutils.createdefaultctx(); string createdbstmtstr = \"create database db1;\"; createdbstmt createdbstmt = (createdbstmt) utframeutils.parseandanalyzestmt(createdbstmtstr, ctx); catalog.getcurrentcatalog().createdb(createdbstmt); system.out.println(catalog.getcurrentcatalog().getdbnames()); string createtblstmtstr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" + \"'colocate_with' = 'g1');\"; createtablestmt createtablestmt = (createtablestmt) utframeutils.parseandanalyzestmt(createtblstmtstr, ctx); catalog.getcurrentcatalog().createtable(createtablestmt); updatereplicapathhash(); database db = catalog.getcurrentcatalog().getdbnullable(\"default_cluster:db1\"); assert.assertnotnull(db); olaptable tbl = (olaptable) db.gettablenullable(\"tbl1\"); tbl.readlock(); try { assert.assertnotnull(tbl); system.out.println(tbl.getname()); assert.assertequals(\"doris\", tbl.getengine()); assert.assertequals(1, tbl.getbaseschema().size()); } finally { tbl.readunlock(); } string alterstmtstr = \"alter table db1.tbl1 add column k2 int default '1'\"; altertablestmt altertablestmt = (altertablestmt) utframeutils.parseandanalyzestmt(alterstmtstr, ctx); catalog.getcurrentcatalog().getalterinstance().processaltertable(altertablestmt); map<long, alterjobv2> alterjobs = catalog.getcurrentcatalog().getschemachangehandler().getalterjobsv2(); assert.assertequals(1, alterjobs.size()); for (alterjobv2 alterjobv2 : alterjobs.values()) { while (!alterjobv2.getjobstate().isfinalstate()) { system.out.println(\"alter job \" + alterjobv2.getjobid() + \" is running. state: \" + alterjobv2.getjobstate()); thread.sleep(1000); } system.out.println(\"alter job \" + alterjobv2.getjobid() + \" is done. state: \" + alterjobv2.getjobstate()); assert.assertequals(alterjobv2.jobstate.finished, alterjobv2.getjobstate()); } olaptable tbl1 = (olaptable) db.gettablenullable(\"tbl1\"); tbl1.readlock(); try { assert.assertequals(2, tbl1.getbaseschema().size()); string baseindexname = tbl1.getindexnamebyid(tbl.getbaseindexid()); assert.assertequals(baseindexname, tbl1.getname()); materializedindexmeta indexmeta = tbl1.getindexmetabyindexid(tbl1.getbaseindexid()); assert.assertnotnull(indexmeta); } finally { tbl1.readunlock(); } string querystr = \"explain select * from db1.tbl1\"; string a = utframeutils.getsqlplanorerrormsg(ctx, querystr); system.out.println(a); stmtexecutor stmtexecutor = new stmtexecutor(ctx, querystr); stmtexecutor.execute(); planner planner = stmtexecutor.planner(); list<planfragment> fragments = planner.getfragments(); assert.assertequals(2, fragments.size()); planfragment fragment = fragments.get(1); assert.asserttrue(fragment.getplanroot() instanceof olapscannode); assert.assertequals(0, fragment.getchildren().size()); backendsprocdir dir = new backendsprocdir(catalog.getcurrentsysteminfo()); procresult result = dir.fetchresult(); assert.assertequals(backendsprocdir.title_names.size(), result.getcolumnnames().size()); assert.assertequals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getrows().get(0).get(19)); assert.assertequals(\"{\\\"lastsuccessreporttabletstime\\\":\\\"n\/a\\\",\\\"laststreamloadtime\\\":-1}\", result.getrows().get(0).get(backendsprocdir.title_names.size() - 1)); }","comment":"\/\/ 1. create connect context\n\/\/ 2. create database db1\n\/\/ 3. create table tbl1\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\n\/\/ 4. get and test the created db and table\n\/\/ 5. process a schema change job\n\/\/ 6. check alter job\n\/\/ 7. query \/\/ todo: we can not process real query for now. so it has to be a explain query\n\/\/ test show backends;","repo":"WilsonWangCS\/incubator-doris","code_context_2":"@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\n\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\n\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\n\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\n\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\n\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\n\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\n\ntbl1.readUnlock();\n}\n\/\/ 7. query\n\/\/ TODO: we can not process real query for now. So it has to be a explain query\nString queryStr = \"explain select * from db1.tbl1\";\nString a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\n\nAssert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\nAssert.assertEquals(0, fragment.getChildren().size());\n\/\/ test show backends;\nBackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\nProcResult result = dir.fetchResult();","code_context_10":"@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\n\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\n\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\n\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\nwhile (!alterJobV2.getJobState().isFinalState()) {\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\nThread.sleep(1000);\n\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\nwhile (!alterJobV2.getJobState().isFinalState()) {\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\nThread.sleep(1000);\n}\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\nAssert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n}\n\ntbl1.readLock();\ntry {\nAssert.assertEquals(2, tbl1.getBaseSchema().size());\nString baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\nAssert.assertEquals(baseIndexName, tbl1.getName());\nMaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\nAssert.assertNotNull(indexMeta);\n} finally {\ntbl1.readUnlock();\n}\n\/\/ 7. query\n\/\/ TODO: we can not process real query for now. So it has to be a explain query\nString queryStr = \"explain select * from db1.tbl1\";\nString a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\nSystem.out.println(a);\nStmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\nstmtExecutor.execute();\nPlanner planner = stmtExecutor.planner();\nList<PlanFragment> fragments = planner.getFragments();\nAssert.assertEquals(2, fragments.size());\nPlanFragment fragment = fragments.get(1);\nAssert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\n\nString a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\nSystem.out.println(a);\nStmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\nstmtExecutor.execute();\nPlanner planner = stmtExecutor.planner();\nList<PlanFragment> fragments = planner.getFragments();\nAssert.assertEquals(2, fragments.size());\nPlanFragment fragment = fragments.get(1);\nAssert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\nAssert.assertEquals(0, fragment.getChildren().size());\n\/\/ test show backends;\nBackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\nProcResult result = dir.fetchResult();\nAssert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\nAssert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\nAssert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\nresult.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n}","code_context_20":"@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\n\n@Test\npublic void testCreateDbAndTable() throws Exception {\n\/\/ 1. create connect context\nConnectContext ctx = UtFrameUtils.createDefaultCtx();\n\/\/ 2. create database db1\nString createDbStmtStr = \"create database db1;\";\nCreateDbStmt createDbStmt = (CreateDbStmt) UtFrameUtils.parseAndAnalyzeStmt(createDbStmtStr, ctx);\nCatalog.getCurrentCatalog().createDb(createDbStmt);\nSystem.out.println(Catalog.getCurrentCatalog().getDbNames());\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\n\n\/\/ 3. create table tbl1\nString createTblStmtStr = \"create table db1.tbl1(k1 int) distributed by hash(k1) buckets 3 properties('replication_num' = '3',\" +\n\"'colocate_with' = 'g1');\";\nCreateTableStmt createTableStmt = (CreateTableStmt) UtFrameUtils.parseAndAnalyzeStmt(createTblStmtStr, ctx);\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\nwhile (!alterJobV2.getJobState().isFinalState()) {\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\nThread.sleep(1000);\n}\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\nAssert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n}\nOlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl1.readLock();\ntry {\nAssert.assertEquals(2, tbl1.getBaseSchema().size());\nString baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\nAssert.assertEquals(baseIndexName, tbl1.getName());\n\nCatalog.getCurrentCatalog().createTable(createTableStmt);\n\/\/ must set replicas' path hash, or the tablet scheduler won't work\nupdateReplicaPathHash();\n\/\/ 4. get and test the created db and table\nDatabase db = Catalog.getCurrentCatalog().getDbNullable(\"default_cluster:db1\");\nAssert.assertNotNull(db);\nOlapTable tbl = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl.readLock();\ntry {\nAssert.assertNotNull(tbl);\nSystem.out.println(tbl.getName());\nAssert.assertEquals(\"Doris\", tbl.getEngine());\nAssert.assertEquals(1, tbl.getBaseSchema().size());\n} finally {\ntbl.readUnlock();\n}\n\/\/ 5. process a schema change job\nString alterStmtStr = \"alter table db1.tbl1 add column k2 int default '1'\";\nAlterTableStmt alterTableStmt = (AlterTableStmt) UtFrameUtils.parseAndAnalyzeStmt(alterStmtStr, ctx);\nCatalog.getCurrentCatalog().getAlterInstance().processAlterTable(alterTableStmt);\n\/\/ 6. check alter job\nMap<Long, AlterJobV2> alterJobs = Catalog.getCurrentCatalog().getSchemaChangeHandler().getAlterJobsV2();\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\nwhile (!alterJobV2.getJobState().isFinalState()) {\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\nThread.sleep(1000);\n}\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\nAssert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n}\nOlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl1.readLock();\ntry {\nAssert.assertEquals(2, tbl1.getBaseSchema().size());\nString baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\nAssert.assertEquals(baseIndexName, tbl1.getName());\nMaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\nAssert.assertNotNull(indexMeta);\n} finally {\ntbl1.readUnlock();\n\nAssert.assertEquals(1, alterJobs.size());\nfor (AlterJobV2 alterJobV2 : alterJobs.values()) {\nwhile (!alterJobV2.getJobState().isFinalState()) {\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is running. state: \" + alterJobV2.getJobState());\nThread.sleep(1000);\n}\nSystem.out.println(\"alter job \" + alterJobV2.getJobId() + \" is done. state: \" + alterJobV2.getJobState());\nAssert.assertEquals(AlterJobV2.JobState.FINISHED, alterJobV2.getJobState());\n}\nOlapTable tbl1 = (OlapTable) db.getTableNullable(\"tbl1\");\ntbl1.readLock();\ntry {\nAssert.assertEquals(2, tbl1.getBaseSchema().size());\nString baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\nAssert.assertEquals(baseIndexName, tbl1.getName());\nMaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\nAssert.assertNotNull(indexMeta);\n} finally {\ntbl1.readUnlock();\n}\n\/\/ 7. query\n\/\/ TODO: we can not process real query for now. So it has to be a explain query\nString queryStr = \"explain select * from db1.tbl1\";\nString a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\nSystem.out.println(a);\nStmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\nstmtExecutor.execute();\nPlanner planner = stmtExecutor.planner();\nList<PlanFragment> fragments = planner.getFragments();\nAssert.assertEquals(2, fragments.size());\nPlanFragment fragment = fragments.get(1);\nAssert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\nAssert.assertEquals(0, fragment.getChildren().size());\n\/\/ test show backends;\nBackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\nProcResult result = dir.fetchResult();\nAssert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\nAssert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\nAssert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\nresult.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n}\n\nString baseIndexName = tbl1.getIndexNameById(tbl.getBaseIndexId());\nAssert.assertEquals(baseIndexName, tbl1.getName());\nMaterializedIndexMeta indexMeta = tbl1.getIndexMetaByIndexId(tbl1.getBaseIndexId());\nAssert.assertNotNull(indexMeta);\n} finally {\ntbl1.readUnlock();\n}\n\/\/ 7. query\n\/\/ TODO: we can not process real query for now. So it has to be a explain query\nString queryStr = \"explain select * from db1.tbl1\";\nString a = UtFrameUtils.getSQLPlanOrErrorMsg(ctx, queryStr);\nSystem.out.println(a);\nStmtExecutor stmtExecutor = new StmtExecutor(ctx, queryStr);\nstmtExecutor.execute();\nPlanner planner = stmtExecutor.planner();\nList<PlanFragment> fragments = planner.getFragments();\nAssert.assertEquals(2, fragments.size());\nPlanFragment fragment = fragments.get(1);\nAssert.assertTrue(fragment.getPlanRoot() instanceof OlapScanNode);\nAssert.assertEquals(0, fragment.getChildren().size());\n\/\/ test show backends;\nBackendsProcDir dir = new BackendsProcDir(Catalog.getCurrentSystemInfo());\nProcResult result = dir.fetchResult();\nAssert.assertEquals(BackendsProcDir.TITLE_NAMES.size(), result.getColumnNames().size());\nAssert.assertEquals(\"{\\\"location\\\" : \\\"default\\\"}\", result.getRows().get(0).get(19));\nAssert.assertEquals(\"{\\\"lastSuccessReportTabletsTime\\\":\\\"N\/A\\\",\\\"lastStreamLoadTime\\\":-1}\",\nresult.getRows().get(0).get(BackendsProcDir.TITLE_NAMES.size() - 1));\n}","label":[1,0,0,0]}
{"id":17588,"original_code":"private void registerSnapshot () {\n        try {\n            Statement statement = connection.createStatement();\n            \/\/ TODO copy over feed_id and feed_version from source namespace?\n            \/\/ FIXME do the following only on databases that support schemas.\n            \/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\n            statement.execute(\"create schema \" + tablePrefix);\n            \/\/ TODO: Record total snapshot processing time?\n            \/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n            \/\/ feeds table already exists.\n            PreparedStatement insertStatement = connection.prepareStatement(\n                    \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\n            insertStatement.setString(1, tablePrefix);\n            insertStatement.setString(2, feedIdToSnapshot);\n            insertStatement.execute();\n            connection.commit();\n            LOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n        } catch (Exception ex) {\n            LOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\n            DbUtils.closeQuietly(connection);\n        }\n    }","code":"private void registerSnapshot () {\n        try {\n            Statement statement = connection.createStatement();\n           \n           \n           \n            statement.execute(\"create schema \" + tablePrefix);\n           \n           \n           \n            PreparedStatement insertStatement = connection.prepareStatement(\n                    \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\n            insertStatement.setString(1, tablePrefix);\n            insertStatement.setString(2, feedIdToSnapshot);\n            insertStatement.execute();\n            connection.commit();\n            LOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n        } catch (Exception ex) {\n            LOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\n            DbUtils.closeQuietly(connection);\n        }\n    }","cleancode":"private void registersnapshot () { try { statement statement = connection.createstatement(); statement.execute(\"create schema \" + tableprefix); preparedstatement insertstatement = connection.preparestatement( \"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\"); insertstatement.setstring(1, tableprefix); insertstatement.setstring(2, feedidtosnapshot); insertstatement.execute(); connection.commit(); log.info(\"created new snapshot namespace: {}\", insertstatement); } catch (exception ex) { log.error(\"exception while registering snapshot namespace in feeds table: {}\", ex.getmessage()); dbutils.closequietly(connection); } }","comment":"\/** * add a line to the list of loaded feeds to record the snapshot and which feed the snapshot replicates. *\/\n\/\/ todo copy over feed_id and feed_version from source namespace? \/\/ fixme do the following only on databases that support schemas. \/\/ sqlite does not support them. is there any advantage of schemas over flat tables?\n\/\/ todo: record total snapshot processing time? \/\/ simply insert into feeds table (no need for table creation) because making a snapshot presumes that the \/\/ feeds table already exists.","repo":"Wilhansen\/gtfs-lib","code_context_2":"private void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);\n}\n}\n\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");","code_context_10":"private void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);\n}\n}\n\nprivate void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\n\nprivate void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);","code_context_20":"private void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);\n}\n}\n\nprivate void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);\n}\n}\n\nprivate void registerSnapshot () {\ntry {\nStatement statement = connection.createStatement();\n\/\/ TODO copy over feed_id and feed_version from source namespace?\n\/\/ FIXME do the following only on databases that support schemas.\n\/\/ SQLite does not support them. Is there any advantage of schemas over flat tables?\nstatement.execute(\"create schema \" + tablePrefix);\n\/\/ TODO: Record total snapshot processing time?\n\/\/ Simply insert into feeds table (no need for table creation) because making a snapshot presumes that the\n\/\/ feeds table already exists.\nPreparedStatement insertStatement = connection.prepareStatement(\n\"insert into feeds values (?, null, null, null, null, null, current_timestamp, ?)\");\ninsertStatement.setString(1, tablePrefix);\ninsertStatement.setString(2, feedIdToSnapshot);\ninsertStatement.execute();\nconnection.commit();\nLOG.info(\"Created new snapshot namespace: {}\", insertStatement);\n} catch (Exception ex) {\nLOG.error(\"Exception while registering snapshot namespace in feeds table: {}\", ex.getMessage());\nDbUtils.closeQuietly(connection);\n}\n}","label":[1,1,0,0]}
{"id":9474,"original_code":"@Override\n        protected void channelRead0(ChannelHandlerContext ctx,\n                CoapMessage msg) {\n            try {\n                \/\/ Find proper device and raise event.\n                Device targetDevice = ctx.channel().attr(keyDevice).get();\n                if (targetDevice == null) {\n                    throw new InternalServerErrorException(\n                            \"Unable to find device\");\n                }\n                if (msg instanceof CoapRequest) {\n                    onRequestReceived(targetDevice, (CoapRequest) msg);\n                } else if (msg instanceof CoapResponse) {\n                    \/\/ TODO: Re-architecturing required\n                    IRequestChannel reqChannel = ((CoapDevice) targetDevice)\n                            .getRequestChannel();\n                    CoapClient coapClient = (CoapClient) reqChannel;\n                    coapClient.onResponseReceived(msg);\n                }\n            } catch (ServerException e) {\n                ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                        e.getErrorResponse()));\n                Log.f(ctx.channel(), e);\n            } catch (ClientException e) {\n                Log.f(ctx.channel(), e);\n            } catch (Throwable t) {\n                Log.f(ctx.channel(), t);\n                if (msg instanceof CoapRequest) {\n                    ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                            ResponseStatus.INTERNAL_SERVER_ERROR));\n                }\n            }\n        }","code":"@Override\n        protected void channelRead0(ChannelHandlerContext ctx,\n                CoapMessage msg) {\n            try {\n               \n                Device targetDevice = ctx.channel().attr(keyDevice).get();\n                if (targetDevice == null) {\n                    throw new InternalServerErrorException(\n                            \"Unable to find device\");\n                }\n                if (msg instanceof CoapRequest) {\n                    onRequestReceived(targetDevice, (CoapRequest) msg);\n                } else if (msg instanceof CoapResponse) {\n                   \n                    IRequestChannel reqChannel = ((CoapDevice) targetDevice)\n                            .getRequestChannel();\n                    CoapClient coapClient = (CoapClient) reqChannel;\n                    coapClient.onResponseReceived(msg);\n                }\n            } catch (ServerException e) {\n                ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                        e.getErrorResponse()));\n                Log.f(ctx.channel(), e);\n            } catch (ClientException e) {\n                Log.f(ctx.channel(), e);\n            } catch (Throwable t) {\n                Log.f(ctx.channel(), t);\n                if (msg instanceof CoapRequest) {\n                    ctx.writeAndFlush(MessageBuilder.createResponse(msg,\n                            ResponseStatus.INTERNAL_SERVER_ERROR));\n                }\n            }\n        }","cleancode":"@override protected void channelread0(channelhandlercontext ctx, coapmessage msg) { try { device targetdevice = ctx.channel().attr(keydevice).get(); if (targetdevice == null) { throw new internalservererrorexception( \"unable to find device\"); } if (msg instanceof coaprequest) { onrequestreceived(targetdevice, (coaprequest) msg); } else if (msg instanceof coapresponse) { irequestchannel reqchannel = ((coapdevice) targetdevice) .getrequestchannel(); coapclient coapclient = (coapclient) reqchannel; coapclient.onresponsereceived(msg); } } catch (serverexception e) { ctx.writeandflush(messagebuilder.createresponse(msg, e.geterrorresponse())); log.f(ctx.channel(), e); } catch (clientexception e) { log.f(ctx.channel(), e); } catch (throwable t) { log.f(ctx.channel(), t); if (msg instanceof coaprequest) { ctx.writeandflush(messagebuilder.createresponse(msg, responsestatus.internal_server_error)); } } }","comment":"\/\/ find proper device and raise event.\n\/\/ todo: re-architecturing required","repo":"SenthilKumarGS\/TizenRT","code_context_2":"CoapMessage msg) {\ntry {\n\/\/ Find proper device and raise event.\nDevice targetDevice = ctx.channel().attr(keyDevice).get();\nif (targetDevice == null) {\n\nonRequestReceived(targetDevice, (CoapRequest) msg);\n} else if (msg instanceof CoapResponse) {\n\/\/ TODO: Re-architecturing required\nIRequestChannel reqChannel = ((CoapDevice) targetDevice)\n.getRequestChannel();","code_context_10":"@Override\nprotected void channelRead0(ChannelHandlerContext ctx,\nCoapMessage msg) {\ntry {\n\/\/ Find proper device and raise event.\nDevice targetDevice = ctx.channel().attr(keyDevice).get();\nif (targetDevice == null) {\nthrow new InternalServerErrorException(\n\"Unable to find device\");\n}\nif (msg instanceof CoapRequest) {\nonRequestReceived(targetDevice, (CoapRequest) msg);\n} else if (msg instanceof CoapResponse) {\n\/\/ TODO: Re-architecturing required\nIRequestChannel reqChannel = ((CoapDevice) targetDevice)\n\ntry {\n\/\/ Find proper device and raise event.\nDevice targetDevice = ctx.channel().attr(keyDevice).get();\nif (targetDevice == null) {\nthrow new InternalServerErrorException(\n\"Unable to find device\");\n}\nif (msg instanceof CoapRequest) {\nonRequestReceived(targetDevice, (CoapRequest) msg);\n} else if (msg instanceof CoapResponse) {\n\/\/ TODO: Re-architecturing required\nIRequestChannel reqChannel = ((CoapDevice) targetDevice)\n.getRequestChannel();\nCoapClient coapClient = (CoapClient) reqChannel;\ncoapClient.onResponseReceived(msg);\n}\n} catch (ServerException e) {\nctx.writeAndFlush(MessageBuilder.createResponse(msg,\ne.getErrorResponse()));\nLog.f(ctx.channel(), e);\n} catch (ClientException e) {","code_context_20":"@Override\nprotected void channelRead0(ChannelHandlerContext ctx,\nCoapMessage msg) {\ntry {\n\/\/ Find proper device and raise event.\nDevice targetDevice = ctx.channel().attr(keyDevice).get();\nif (targetDevice == null) {\nthrow new InternalServerErrorException(\n\"Unable to find device\");\n}\nif (msg instanceof CoapRequest) {\nonRequestReceived(targetDevice, (CoapRequest) msg);\n} else if (msg instanceof CoapResponse) {\n\/\/ TODO: Re-architecturing required\nIRequestChannel reqChannel = ((CoapDevice) targetDevice)\n.getRequestChannel();\nCoapClient coapClient = (CoapClient) reqChannel;\ncoapClient.onResponseReceived(msg);\n}\n} catch (ServerException e) {\nctx.writeAndFlush(MessageBuilder.createResponse(msg,\ne.getErrorResponse()));\nLog.f(ctx.channel(), e);\n} catch (ClientException e) {\nLog.f(ctx.channel(), e);\n\n@Override\nprotected void channelRead0(ChannelHandlerContext ctx,\nCoapMessage msg) {\ntry {\n\/\/ Find proper device and raise event.\nDevice targetDevice = ctx.channel().attr(keyDevice).get();\nif (targetDevice == null) {\nthrow new InternalServerErrorException(\n\"Unable to find device\");\n}\nif (msg instanceof CoapRequest) {\nonRequestReceived(targetDevice, (CoapRequest) msg);\n} else if (msg instanceof CoapResponse) {\n\/\/ TODO: Re-architecturing required\nIRequestChannel reqChannel = ((CoapDevice) targetDevice)\n.getRequestChannel();\nCoapClient coapClient = (CoapClient) reqChannel;\ncoapClient.onResponseReceived(msg);\n}\n} catch (ServerException e) {\nctx.writeAndFlush(MessageBuilder.createResponse(msg,\ne.getErrorResponse()));\nLog.f(ctx.channel(), e);\n} catch (ClientException e) {\nLog.f(ctx.channel(), e);\n} catch (Throwable t) {\nLog.f(ctx.channel(), t);\nif (msg instanceof CoapRequest) {\nctx.writeAndFlush(MessageBuilder.createResponse(msg,\nResponseStatus.INTERNAL_SERVER_ERROR));\n}\n}\n}","label":[1,0,0,0]}
{"id":9490,"original_code":"public LNode reverseListRec(LNode head)\n    {\n        \/\/ TODO: implement this method\n\t\t  \/*This method takes a reference to the head of a linked list and returns \n        the reference to the head of the linked list in the reversed order.  *\/\n        if(head == null) { return head; }\n        if(head.getLink() == null) { return head; }\n        head.getLink().setLink(head);\n        head.setLink(null);\n        return reverseListRec(head);\n         \/\/ replace this statement with your own return\n    }","code":"public LNode reverseListRec(LNode head)\n    {\n       \n\t\t \n        if(head == null) { return head; }\n        if(head.getLink() == null) { return head; }\n        head.getLink().setLink(head);\n        head.setLink(null);\n        return reverseListRec(head);\n        \n    }","cleancode":"public lnode reverselistrec(lnode head) { if(head == null) { return head; } if(head.getlink() == null) { return head; } head.getlink().setlink(head); head.setlink(null); return reverselistrec(head); }","comment":"\/\/ this method takes a reference to the head of a linked list. \/\/ it returns the reference to the head of the linked list in the reversed order.\n\/\/ todo: implement this method \/*this method takes a reference to the head of a linked list and returns the reference to the head of the linked list in the reversed order. *\/\n\/\/ replace this statement with your own return","repo":"Sailia\/data_structures","code_context_2":"public LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}\n\npublic LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\n\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}","code_context_10":"public LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}\n\npublic LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}\n\npublic LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}","code_context_20":"public LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}\n\npublic LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}\n\npublic LNode reverseListRec(LNode head)\n{\n\/\/ TODO: implement this method\n\/*This method takes a reference to the head of a linked list and returns\nthe reference to the head of the linked list in the reversed order. *\/\nif(head == null) { return head; }\nif(head.getLink() == null) { return head; }\nhead.getLink().setLink(head);\nhead.setLink(null);\nreturn reverseListRec(head);\n\/\/ replace this statement with your own return\n}","label":[0,1,0,0]}
{"id":17706,"original_code":"@SuppressWarnings(\"ParameterName\")\n    public void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n        \/\/ ask the kinematics to determine our swerve command\n        ChassisSpeeds speeds;\n        if (fieldRelative == true) {\n            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n        } else {\n            speeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n        }\n        SwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n        \/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\n        SwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n        \/\/ command each swerve module\n        for (int i = 0; i < modules.length; i++) {\n            modules[i].setDesiredState(swerveModuleStates[i]);\n        }\n        \/\/ report our commands to the dashboard\n        SmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\n        SmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n    }","code":"@SuppressWarnings(\"ParameterName\")\n    public void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n       \n        ChassisSpeeds speeds;\n        if (fieldRelative == true) {\n            speeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n        } else {\n            speeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n        }\n        SwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n       \n        SwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n       \n        for (int i = 0; i < modules.length; i++) {\n            modules[i].setDesiredState(swerveModuleStates[i]);\n        }\n       \n        SmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\n        SmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\n        SmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n    }","cleancode":"@suppresswarnings(\"parametername\") public void drive(double xspeed, double yspeed, double rot, boolean fieldrelative) { chassisspeeds speeds; if (fieldrelative == true) { speeds = chassisspeeds.fromfieldrelativespeeds(xspeed, yspeed, rot, getheading()); } else { speeds = new chassisspeeds(xspeed, yspeed, rot); } swervemodulestate[] swervemodulestates = kinematics.toswervemodulestates(speeds); swervedrivekinematics.desaturatewheelspeeds(swervemodulestates, kmaxspeed); for (int i = 0; i < modules.length; i++) { modules[i].setdesiredstate(swervemodulestates[i]); } smartdashboard.putnumber(\"swervedrive\/xspeed\", xspeed); smartdashboard.putnumber(\"swervedrive\/yspeed\", yspeed); smartdashboard.putnumber(\"swervedrive\/rot\", rot); smartdashboard.putboolean(\"swervedrive\/fieldrelative\", fieldrelative); }","comment":"\/** * method to drive the robot using joystick info. * * @param xspeed speed of the robot in the x direction (forward). * @param yspeed speed of the robot in the y direction (sideways). * @param rot angular rate of the robot. * @param fieldrelative whether the provided x and y speeds are relative to the * field. *\/\n\/\/ ask the kinematics to determine our swerve command\n\/\/ sometime the kinematics spits out too fast of speeds, so this will fix this\n\/\/ command each swerve module\n\/\/ report our commands to the dashboard","repo":"Sammoore15\/Robot2022-2832-altencoderforingestor","code_context_2":"@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\n\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\n\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);","code_context_10":"@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}","code_context_20":"@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}\n\n@SuppressWarnings(\"ParameterName\")\npublic void drive(double xSpeed, double ySpeed, double rot, boolean fieldRelative) {\n\/\/ ask the kinematics to determine our swerve command\nChassisSpeeds speeds;\nif (fieldRelative == true) {\nspeeds = ChassisSpeeds.fromFieldRelativeSpeeds(xSpeed, ySpeed, rot, getHeading());\n} else {\nspeeds = new ChassisSpeeds(xSpeed, ySpeed, rot);\n}\nSwerveModuleState[] swerveModuleStates = kinematics.toSwerveModuleStates(speeds);\n\/\/ sometime the Kinematics spits out too fast of speeds, so this will fix this\nSwerveDriveKinematics.desaturateWheelSpeeds(swerveModuleStates, kMaxSpeed);\n\/\/ command each swerve module\nfor (int i = 0; i < modules.length; i++) {\nmodules[i].setDesiredState(swerveModuleStates[i]);\n}\n\/\/ report our commands to the dashboard\nSmartDashboard.putNumber(\"SwerveDrive\/xSpeed\", xSpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/ySpeed\", ySpeed);\nSmartDashboard.putNumber(\"SwerveDrive\/rot\", rot);\nSmartDashboard.putBoolean(\"SwerveDrive\/fieldRelative\", fieldRelative);\n}","label":[0,0,0,0]}
{"id":1344,"original_code":"private int generateNewTicketNumber() \n    {\n        \/\/TODO: this may take foreever. fix\n        int generated = numberGenerator.next();\n        while(purchased.containsKey(generated)){\n            generated = numberGenerator.next();\n        }\n        return generated;\n    }","code":"private int generateNewTicketNumber() \n    {\n       \n        int generated = numberGenerator.next();\n        while(purchased.containsKey(generated)){\n            generated = numberGenerator.next();\n        }\n        return generated;\n    }","cleancode":"private int generatenewticketnumber() { int generated = numbergenerator.next(); while(purchased.containskey(generated)){ generated = numbergenerator.next(); } return generated; }","comment":"\/\/todo: this may take foreever. fix","repo":"aha0x0x\/LotteryApplication","code_context_2":"private int generateNewTicketNumber()\n{\n\/\/TODO: this may take foreever. fix\nint generated = numberGenerator.next();\nwhile(purchased.containsKey(generated)){","code_context_10":"private int generateNewTicketNumber()\n{\n\/\/TODO: this may take foreever. fix\nint generated = numberGenerator.next();\nwhile(purchased.containsKey(generated)){\ngenerated = numberGenerator.next();\n}\nreturn generated;\n}","code_context_20":"private int generateNewTicketNumber()\n{\n\/\/TODO: this may take foreever. fix\nint generated = numberGenerator.next();\nwhile(purchased.containsKey(generated)){\ngenerated = numberGenerator.next();\n}\nreturn generated;\n}","label":[0,0,1,0]}
{"id":17729,"original_code":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n    {\n        \/\/ prepare the layout parameters for the EditText\n        \/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\n        LayoutParams layoutParams = new GridLayout.LayoutParams();\n        layoutParams.width = LayoutParams.WRAP_CONTENT;\n        layoutParams.height = LayoutParams.WRAP_CONTENT;\n        \/\/ set the row and column in the correct location of the Sudoku Board\n        layoutParams.rowSpec = GridLayout.spec(row);\n        layoutParams.columnSpec = GridLayout.spec(col);\n        \/\/ set the layout params and add the EditText to the GridLayout parent\n        _text.setLayoutParams(layoutParams);\n        parent.addView(_text);\n    }","code":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n    {\n       \n       \n        LayoutParams layoutParams = new GridLayout.LayoutParams();\n        layoutParams.width = LayoutParams.WRAP_CONTENT;\n        layoutParams.height = LayoutParams.WRAP_CONTENT;\n       \n        layoutParams.rowSpec = GridLayout.spec(row);\n        layoutParams.columnSpec = GridLayout.spec(col);\n       \n        _text.setLayoutParams(layoutParams);\n        parent.addView(_text);\n    }","cleancode":"public void setparentatrowandcolumn(gridlayout parent, int row, int col) { layoutparams layoutparams = new gridlayout.layoutparams(); layoutparams.width = layoutparams.wrap_content; layoutparams.height = layoutparams.wrap_content; layoutparams.rowspec = gridlayout.spec(row); layoutparams.columnspec = gridlayout.spec(col); _text.setlayoutparams(layoutparams); parent.addview(_text); }","comment":"\/** * place the cell within the grid layout at the specified row and column. * * @param parent - the cell's parent * @param row - the row that the cell will be set at * @param col - the column that the cell will be set at *\/\n\/\/ prepare the layout parameters for the edittext \/\/ todo: consider caching the layout params and only changing the spec row and spec column\n\/\/ set the row and column in the correct location of the sudoku board\n\/\/ set the layout params and add the edittext to the gridlayout parent","repo":"SnoBoarder\/Sudoku-Solver","code_context_2":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\n\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);","code_context_10":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}","code_context_20":"public void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}\n\npublic void setParentAtRowAndColumn(GridLayout parent, int row, int col)\n{\n\/\/ prepare the layout parameters for the EditText\n\/\/ TODO: Consider caching the layout params and only changing the spec row and spec column\nLayoutParams layoutParams = new GridLayout.LayoutParams();\nlayoutParams.width = LayoutParams.WRAP_CONTENT;\nlayoutParams.height = LayoutParams.WRAP_CONTENT;\n\/\/ set the row and column in the correct location of the Sudoku Board\nlayoutParams.rowSpec = GridLayout.spec(row);\nlayoutParams.columnSpec = GridLayout.spec(col);\n\/\/ set the layout params and add the EditText to the GridLayout parent\n_text.setLayoutParams(layoutParams);\nparent.addView(_text);\n}","label":[0,1,0,0]}
{"id":34188,"original_code":"public void testZKSMFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\")};\n\t\tEncryptedInteger c = new EncryptedInteger(new BigInteger(\"10\"), pub);\n\t\tBigInteger r = c.set(new BigInteger(\"10\"));\n\t\tint msgIndex = 2;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code":"public void testZKSMFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\")};\n\t\tEncryptedInteger c = new EncryptedInteger(new BigInteger(\"10\"), pub);\n\t\tBigInteger r = c.set(new BigInteger(\"10\"));\n\t\tint msgIndex = 2;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmfalse() throws zksetmembershipexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\")}; encryptedinteger c = new encryptedinteger(new biginteger(\"10\"), pub); biginteger r = c.set(new biginteger(\"10\")); int msgindex = 2; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","comment":"\/\/ todo: this could actually be true with low probability","repo":"SoftwareEngineeringToolDemos\/type-inference","code_context_2":"BigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_10":"BigInteger r = c.set(new BigInteger(\"10\"));\nint msgIndex = 2;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_20":"public void testZKSMFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\nBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"),\nnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\")};\nEncryptedInteger c = new EncryptedInteger(new BigInteger(\"10\"), pub);\nBigInteger r = c.set(new BigInteger(\"10\"));\nint msgIndex = 2;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","label":[0,0,1,0]}
{"id":34189,"original_code":"public void testZKSMSingleMemberSetFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\")};\n\t\tEncryptedInteger c = new EncryptedInteger(BigInteger.ONE, pub);\n\t\tBigInteger r = c.set(BigInteger.ONE);\n\t\tint msgIndex = 0;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code":"public void testZKSMSingleMemberSetFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\")};\n\t\tEncryptedInteger c = new EncryptedInteger(BigInteger.ONE, pub);\n\t\tBigInteger r = c.set(BigInteger.ONE);\n\t\tint msgIndex = 0;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmsinglemembersetfalse() throws zksetmembershipexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\")}; encryptedinteger c = new encryptedinteger(biginteger.one, pub); biginteger r = c.set(biginteger.one); int msgindex = 0; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","comment":"\/\/ todo: this could actually be true with low probability","repo":"SoftwareEngineeringToolDemos\/type-inference","code_context_2":"BigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_10":"BigInteger r = c.set(BigInteger.ONE);\nint msgIndex = 0;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_20":"public void testZKSMSingleMemberSetFalse() throws ZKSetMembershipException, BigIntegerClassNotValid {\nBigInteger[] theSet = {new BigInteger(\"0\")};\nEncryptedInteger c = new EncryptedInteger(BigInteger.ONE, pub);\nBigInteger r = c.set(BigInteger.ONE);\nint msgIndex = 0;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","label":[0,0,1,0]}
{"id":34190,"original_code":"public void testZKSMAddTrue() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code":"public void testZKSMAddTrue() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmaddtrue() throws zksetmembershipexception, publickeysnotequalexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\"), new biginteger(\"6\")}; encryptedinteger c1 = new encryptedinteger(new biginteger(\"2\"), pub); biginteger r1 = c1.set(new biginteger(\"2\")); encryptedinteger c2 = new encryptedinteger(new biginteger(\"3\"), pub); biginteger r2 = c2.set(new biginteger(\"3\")); encryptedinteger c = c1.add(c2); biginteger r = r1.multiply(r2).mod(this.pub.getnsquared()); int msgindex = 5; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","comment":"\/\/ todo: this could actually be true with low probability","repo":"SoftwareEngineeringToolDemos\/type-inference","code_context_2":"BigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_10":"BigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\nint msgIndex = 5;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_20":"public void testZKSMAddTrue() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\nBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"),\nnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\nnew BigInteger(\"6\")};\nEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\nBigInteger r1 = c1.set(new BigInteger(\"2\"));\nEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\nBigInteger r2 = c2.set(new BigInteger(\"3\"));\nEncryptedInteger c = c1.add(c2);\nBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\nint msgIndex = 5;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","label":[0,0,1,0]}
{"id":34191,"original_code":"public void testZKSMManyOperations() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n\t\t}\n\t}","code":"public void testZKSMManyOperations() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\n\t\tBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"), \n\t\t\t\tnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\n\t\t\t\tnew BigInteger(\"6\")};\n\t\tEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\n\t\tBigInteger r1 = c1.set(new BigInteger(\"2\"));\n\t\tEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\n\t\tBigInteger r2 = c2.set(new BigInteger(\"3\"));\n\t\tEncryptedInteger c = c1.add(c2);\n\t\tBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\n\t\tint msgIndex = 5;\n\t\tfor (int i=0; i<10; i++) {\n\t\t\tZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\n\t\t\tBigInteger[] uVals = prover.genCommitments();\n\t\t\tZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\n\t\t\tBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\n\t\t\tprover.computeResponse(e, r);\n\t\t\tBigInteger[] eVals = prover.getEs();\n\t\t\tBigInteger[] vVals = prover.getVs();\n\t\t\tassertFalse(verifier.checkResponse(eVals, vVals));\n\t\t}\n\t}","cleancode":"public void testzksmmanyoperations() throws zksetmembershipexception, publickeysnotequalexception, bigintegerclassnotvalid { biginteger[] theset = {new biginteger(\"0\"), new biginteger(\"1\"), new biginteger(\"2\"), new biginteger(\"3\"), new biginteger(\"4\"), new biginteger(\"6\")}; encryptedinteger c1 = new encryptedinteger(new biginteger(\"2\"), pub); biginteger r1 = c1.set(new biginteger(\"2\")); encryptedinteger c2 = new encryptedinteger(new biginteger(\"3\"), pub); biginteger r2 = c2.set(new biginteger(\"3\")); encryptedinteger c = c1.add(c2); biginteger r = r1.multiply(r2).mod(this.pub.getnsquared()); int msgindex = 5; for (int i=0; i<10; i++) { zksetmembershipprover prover = new zksetmembershipprover(pub, theset, msgindex, c); biginteger[] uvals = prover.gencommitments(); zksetmembershipverifier verifier = new zksetmembershipverifier(pub, c, uvals, theset); biginteger e = verifier.genchallenge(new biginteger(\"128\")); prover.computeresponse(e, r); biginteger[] evals = prover.getes(); biginteger[] vvals = prover.getvs(); assertfalse(verifier.checkresponse(evals, vvals)); } }","comment":"\/\/ todo: this could actually be true with low probability","repo":"SoftwareEngineeringToolDemos\/type-inference","code_context_2":"BigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_10":"BigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\nint msgIndex = 5;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","code_context_20":"public void testZKSMManyOperations() throws ZKSetMembershipException, PublicKeysNotEqualException, BigIntegerClassNotValid {\nBigInteger[] theSet = {new BigInteger(\"0\"), new BigInteger(\"1\"),\nnew BigInteger(\"2\"), new BigInteger(\"3\"), new BigInteger(\"4\"),\nnew BigInteger(\"6\")};\nEncryptedInteger c1 = new EncryptedInteger(new BigInteger(\"2\"), pub);\nBigInteger r1 = c1.set(new BigInteger(\"2\"));\nEncryptedInteger c2 = new EncryptedInteger(new BigInteger(\"3\"), pub);\nBigInteger r2 = c2.set(new BigInteger(\"3\"));\nEncryptedInteger c = c1.add(c2);\nBigInteger r = r1.multiply(r2).mod(this.pub.getNSquared());\nint msgIndex = 5;\nfor (int i=0; i<10; i++) {\nZKSetMembershipProver prover = new ZKSetMembershipProver(pub, theSet, msgIndex, c);\nBigInteger[] uVals = prover.genCommitments();\nZKSetMembershipVerifier verifier = new ZKSetMembershipVerifier(pub, c, uVals, theSet);\nBigInteger e = verifier.genChallenge(new BigInteger(\"128\"));\nprover.computeResponse(e, r);\nBigInteger[] eVals = prover.getEs();\nBigInteger[] vVals = prover.getVs();\nassertFalse(verifier.checkResponse(eVals, vVals)); \/\/ TODO: This could actually be true with low probability\n}\n}","label":[0,0,1,0]}
{"id":34311,"original_code":"private void assertTestSummary() {\n    int fails = testResult.fails().size();\n    int errors = testResult.errors().size();\n    int succeeds = testResult.succeeds().size();\n    int testCount = fails + errors + succeeds;\n    if (testMode.isJ2cl()) {\n      \/\/ Like Junit4, J2CL always counts errors as failures\n      fails += errors;\n      errors = 0;\n      \/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\n      testCount = 1;\n      \/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\n      assertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n    }\n    if (fails + errors > 0) {\n      assertTestSummaryForFailure(fails, errors, testCount);\n    } else {\n      assertTestSummaryForSuccess(testCount);\n    }\n  }","code":"private void assertTestSummary() {\n    int fails = testResult.fails().size();\n    int errors = testResult.errors().size();\n    int succeeds = testResult.succeeds().size();\n    int testCount = fails + errors + succeeds;\n    if (testMode.isJ2cl()) {\n     \n      fails += errors;\n      errors = 0;\n     \n      testCount = 1;\n     \n      assertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n    }\n    if (fails + errors > 0) {\n      assertTestSummaryForFailure(fails, errors, testCount);\n    } else {\n      assertTestSummaryForSuccess(testCount);\n    }\n  }","cleancode":"private void asserttestsummary() { int fails = testresult.fails().size(); int errors = testresult.errors().size(); int succeeds = testresult.succeeds().size(); int testcount = fails + errors + succeeds; if (testmode.isj2cl()) { fails += errors; errors = 0; testcount = 1; assertthat(consolelogs.stream().filter(x -> x.contains(\": passed\"))).hassize(succeeds); } if (fails + errors > 0) { asserttestsummaryforfailure(fails, errors, testcount); } else { asserttestsummaryforsuccess(testcount); } }","comment":"\/\/ like junit4, j2cl always counts errors as failures\n\/\/ todo(b\/32608089): jsunit_test does not report number of tests correctly\n\/\/ since total number of tests cannot be asserted; ensure nummber of succeeds is correct.","repo":"VishrutMehta\/j2cl","code_context_2":"int testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\n\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}","code_context_10":"private void assertTestSummary() {\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\n\nprivate void assertTestSummary() {\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\nassertTestSummaryForSuccess(testCount);\n}\n}\n\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\nassertTestSummaryForSuccess(testCount);\n}\n}","code_context_20":"private void assertTestSummary() {\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\nassertTestSummaryForSuccess(testCount);\n}\n}\n\nprivate void assertTestSummary() {\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\nassertTestSummaryForSuccess(testCount);\n}\n}\n\nprivate void assertTestSummary() {\nint fails = testResult.fails().size();\nint errors = testResult.errors().size();\nint succeeds = testResult.succeeds().size();\nint testCount = fails + errors + succeeds;\nif (testMode.isJ2cl()) {\n\/\/ Like Junit4, J2CL always counts errors as failures\nfails += errors;\nerrors = 0;\n\/\/ TODO(b\/32608089): jsunit_test does not report number of tests correctly\ntestCount = 1;\n\/\/ Since total number of tests cannot be asserted; ensure nummber of succeeds is correct.\nassertThat(consoleLogs.stream().filter(x -> x.contains(\": PASSED\"))).hasSize(succeeds);\n}\nif (fails + errors > 0) {\nassertTestSummaryForFailure(fails, errors, testCount);\n} else {\nassertTestSummaryForSuccess(testCount);\n}\n}","label":[0,0,1,0]}
{"id":18084,"original_code":"public boolean connect(long timeoutMs) {\n        if (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\n        long startMs = System.currentTimeMillis();\n        long endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\n        long currentTime = startMs;\n        Throwable lastError = null;\n        int attempt = 0;\n        while (currentTime <= endMs) {\n            currentTime = System.currentTimeMillis();\n            if (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\n            if (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\n            try {\n                connect();\n                return true;\n            } catch (Exception e) {\n                Exceptions.propagateIfFatal(e);\n                if (!terminated.get() && shouldRetryOn(e)) {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\n                    lastError = e;\n                } else {\n                    throw Exceptions.propagate(e);\n                }\n            }\n            attempt++;\n        }\n        LOG.warn(\"unable to connect to JMX url: \"+url, lastError);\n        return false;\n    }","code":"public boolean connect(long timeoutMs) {\n        if (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\n        long startMs = System.currentTimeMillis();\n        long endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\n        long currentTime = startMs;\n        Throwable lastError = null;\n        int attempt = 0;\n        while (currentTime <= endMs) {\n            currentTime = System.currentTimeMillis();\n            if (attempt != 0) sleep(100);\n            if (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\n            try {\n                connect();\n                return true;\n            } catch (Exception e) {\n                Exceptions.propagateIfFatal(e);\n                if (!terminated.get() && shouldRetryOn(e)) {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\n                    lastError = e;\n                } else {\n                    throw Exceptions.propagate(e);\n                }\n            }\n            attempt++;\n        }\n        LOG.warn(\"unable to connect to JMX url: \"+url, lastError);\n        return false;\n    }","cleancode":"public boolean connect(long timeoutms) { if (log.isdebugenabled()) log.debug(\"connecting to jmx url: {} ({})\", url, ((timeoutms == -1) ? \"indefinitely\" : timeoutms+\"ms timeout\")); long startms = system.currenttimemillis(); long endms = (timeoutms == -1) ? long.max_value : (startms + timeoutms); long currenttime = startms; throwable lasterror = null; int attempt = 0; while (currenttime <= endms) { currenttime = system.currenttimemillis(); if (attempt != 0) sleep(100); if (log.istraceenabled()) log.trace(\"trying connection to {} at time {}\", url, currenttime); try { connect(); return true; } catch (exception e) { exceptions.propagateiffatal(e); if (!terminated.get() && shouldretryon(e)) { if (log.isdebugenabled()) log.debug(\"attempt {} failed connecting to {} ({})\", new object[] {attempt + 1, url, e.getmessage()}); lasterror = e; } else { throw exceptions.propagate(e); } } attempt++; } log.warn(\"unable to connect to jmx url: \"+url, lasterror); return false; }","comment":"\/** * continuously attempts to connect for at least the indicated amount of time; or indefinitely if -1. this method * is useful when you are not sure if the system you are trying to connect to already is up and running. * * this method doesn't throw an exception, but returns true on success, false otherwise. * * todo: what happens if already connected? * * @param timeoutms * @return *\/\n\/\/sleep 100 to prevent thrashing and facilitate interruption","repo":"YYTVicky\/brooklyn-server","code_context_2":"public boolean connect(long timeoutMs) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\nlong startMs = System.currentTimeMillis();\nlong endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\nlong currentTime = startMs;\nThrowable lastError = null;\nint attempt = 0;\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {\nconnect();\nreturn true;\n} catch (Exception e) {\nExceptions.propagateIfFatal(e);\nif (!terminated.get() && shouldRetryOn(e)) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\nlastError = e;\n} else {\nthrow Exceptions.propagate(e);\n}\n}\nattempt++;\n}\nLOG.warn(\"unable to connect to JMX url: \"+url, lastError);\nreturn false;\n}\n\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {","code_context_10":"public boolean connect(long timeoutMs) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\nlong startMs = System.currentTimeMillis();\nlong endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\nlong currentTime = startMs;\nThrowable lastError = null;\nint attempt = 0;\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {\nconnect();\nreturn true;\n} catch (Exception e) {\nExceptions.propagateIfFatal(e);\nif (!terminated.get() && shouldRetryOn(e)) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\nlastError = e;\n} else {\nthrow Exceptions.propagate(e);\n}\n}\nattempt++;\n}\nLOG.warn(\"unable to connect to JMX url: \"+url, lastError);\nreturn false;\n}\n\npublic boolean connect(long timeoutMs) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\nlong startMs = System.currentTimeMillis();\nlong endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\nlong currentTime = startMs;\nThrowable lastError = null;\nint attempt = 0;\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {\nconnect();\nreturn true;\n} catch (Exception e) {\nExceptions.propagateIfFatal(e);\nif (!terminated.get() && shouldRetryOn(e)) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\nlastError = e;\n} else {","code_context_20":"public boolean connect(long timeoutMs) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\nlong startMs = System.currentTimeMillis();\nlong endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\nlong currentTime = startMs;\nThrowable lastError = null;\nint attempt = 0;\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {\nconnect();\nreturn true;\n} catch (Exception e) {\nExceptions.propagateIfFatal(e);\nif (!terminated.get() && shouldRetryOn(e)) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\nlastError = e;\n} else {\nthrow Exceptions.propagate(e);\n}\n}\nattempt++;\n}\nLOG.warn(\"unable to connect to JMX url: \"+url, lastError);\nreturn false;\n}\n\npublic boolean connect(long timeoutMs) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Connecting to JMX URL: {} ({})\", url, ((timeoutMs == -1) ? \"indefinitely\" : timeoutMs+\"ms timeout\"));\nlong startMs = System.currentTimeMillis();\nlong endMs = (timeoutMs == -1) ? Long.MAX_VALUE : (startMs + timeoutMs);\nlong currentTime = startMs;\nThrowable lastError = null;\nint attempt = 0;\nwhile (currentTime <= endMs) {\ncurrentTime = System.currentTimeMillis();\nif (attempt != 0) sleep(100); \/\/sleep 100 to prevent thrashing and facilitate interruption\nif (LOG.isTraceEnabled()) LOG.trace(\"trying connection to {} at time {}\", url, currentTime);\ntry {\nconnect();\nreturn true;\n} catch (Exception e) {\nExceptions.propagateIfFatal(e);\nif (!terminated.get() && shouldRetryOn(e)) {\nif (LOG.isDebugEnabled()) LOG.debug(\"Attempt {} failed connecting to {} ({})\", new Object[] {attempt + 1, url, e.getMessage()});\nlastError = e;\n} else {\nthrow Exceptions.propagate(e);\n}\n}\nattempt++;\n}\nLOG.warn(\"unable to connect to JMX url: \"+url, lastError);\nreturn false;\n}","label":[1,0,0,0]}
{"id":34588,"original_code":"public String toString(int indentFactor) {\n        try {\n            StringWriter w = new StringWriter();\n            synchronized (w.getBuffer()) {\n                return this.write(w, indentFactor, 0).toString();\n            }\n        }\n        catch (Exception e) {\n            \/\/there is no conceivable exception that can come out of this, but throw something\n            \/\/just in case.   Want the signature to not have exception in it.\n            throw new RuntimeException(\"Can not serialize JSONObject????\", e);\n        }\n    }","code":"public String toString(int indentFactor) {\n        try {\n            StringWriter w = new StringWriter();\n            synchronized (w.getBuffer()) {\n                return this.write(w, indentFactor, 0).toString();\n            }\n        }\n        catch (Exception e) {\n           \n           \n            throw new RuntimeException(\"Can not serialize JSONObject????\", e);\n        }\n    }","cleancode":"public string tostring(int indentfactor) { try { stringwriter w = new stringwriter(); synchronized (w.getbuffer()) { return this.write(w, indentfactor, 0).tostring(); } } catch (exception e) { throw new runtimeexception(\"can not serialize jsonobject????\", e); } }","comment":"\/** * make a json text string representation of this jsonobject. * think carefully before using this method! do you really need * a string in memory? since json is used as a data transport format * normally you are going to write the string out to some destination. * it is far more efficient to use the <code>write<\/code> operation * on this object directly. think about it: you have a tree of json * objects in memory. this method will make a copy of all that data * into a single string -- a second copy of the data in memory. * if all you are going to do is to write that string out to a file, * then use the write method to stream it directly to the file. * if you are going to send the data from a server to client browser, * the write directly to the output stream. this reduces memory usage. * sometimes you really do need a string, so the method is provided, * but use it sparingly. * <\/p><p> * the json is produced indented by an indentfactor amount specified. * if you specify zero indent, the output will be all on a single line. * the elements are alphabetized only if an indent is specified. * <\/p><p> * warning: this method assumes that the data structure is acyclical. * an exception will be thrown if you have a cycle. * * @param indentfactor the number of spaces to add to each level of * indentation. * @return a printable, displayable, portable, transmittable * representation of the object, beginning * with <code>{<\/code>&nbsp;<small>(left brace)<\/small> and ending * with <code>}<\/code>&nbsp;<small>(right brace)<\/small>. * @throws jsonexception if the object contains an invalid number. *\/\n\/\/there is no conceivable exception that can come out of this, but throw something \/\/just in case. want the signature to not have exception in it.","repo":"agilepro\/purple","code_context_2":"public String toString(int indentFactor) {\ntry {\nStringWriter w = new StringWriter();\nsynchronized (w.getBuffer()) {\nreturn this.write(w, indentFactor, 0).toString();\n}\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}\n}\n\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}","code_context_10":"public String toString(int indentFactor) {\ntry {\nStringWriter w = new StringWriter();\nsynchronized (w.getBuffer()) {\nreturn this.write(w, indentFactor, 0).toString();\n}\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}\n}\n\npublic String toString(int indentFactor) {\ntry {\nStringWriter w = new StringWriter();\nsynchronized (w.getBuffer()) {\nreturn this.write(w, indentFactor, 0).toString();\n}\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}\n}","code_context_20":"public String toString(int indentFactor) {\ntry {\nStringWriter w = new StringWriter();\nsynchronized (w.getBuffer()) {\nreturn this.write(w, indentFactor, 0).toString();\n}\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}\n}\n\npublic String toString(int indentFactor) {\ntry {\nStringWriter w = new StringWriter();\nsynchronized (w.getBuffer()) {\nreturn this.write(w, indentFactor, 0).toString();\n}\n}\ncatch (Exception e) {\n\/\/there is no conceivable exception that can come out of this, but throw something\n\/\/just in case. Want the signature to not have exception in it.\nthrow new RuntimeException(\"Can not serialize JSONObject????\", e);\n}\n}","label":[0,0,0,0]}
{"id":18326,"original_code":"private void validate() throws IllegalStateException {\n      Set<DateComponentOrdering> orderings = Sets.newHashSet();\n      if(preferred != null) {\n        orderings.add(preferred.getOrdering());\n      }\n      for(DateTimeParser parser : otherParsers) {\n        if(!orderings.add(parser.getOrdering())) {\n          throw new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n                  \"[\" + parser.getOrdering() + \"]\");\n        }\n      }\n    }","code":"private void validate() throws IllegalStateException {\n      Set<DateComponentOrdering> orderings = Sets.newHashSet();\n      if(preferred != null) {\n        orderings.add(preferred.getOrdering());\n      }\n      for(DateTimeParser parser : otherParsers) {\n        if(!orderings.add(parser.getOrdering())) {\n          throw new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n                  \"[\" + parser.getOrdering() + \"]\");\n        }\n      }\n    }","cleancode":"private void validate() throws illegalstateexception { set<datecomponentordering> orderings = sets.newhashset(); if(preferred != null) { orderings.add(preferred.getordering()); } for(datetimeparser parser : otherparsers) { if(!orderings.add(parser.getordering())) { throw new illegalstateexception(\"datecomponentordering can only be used once in a datetimemultiparser.\" + \"[\" + parser.getordering() + \"]\"); } } }","comment":"\/** * ensure the builder is used with content we expect. * currently (this could change) we should only have one datetimeparser per datecomponentordering. *\/","repo":"adam-collins\/parsers","code_context_2":"private void validate() throws IllegalStateException {\nSet<DateComponentOrdering> orderings = Sets.newHashSet();\nif(preferred != null) {\norderings.add(preferred.getOrdering());\n}\nfor(DateTimeParser parser : otherParsers) {\nif(!orderings.add(parser.getOrdering())) {\nthrow new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n\"[\" + parser.getOrdering() + \"]\");\n}\n}\n}","code_context_10":"private void validate() throws IllegalStateException {\nSet<DateComponentOrdering> orderings = Sets.newHashSet();\nif(preferred != null) {\norderings.add(preferred.getOrdering());\n}\nfor(DateTimeParser parser : otherParsers) {\nif(!orderings.add(parser.getOrdering())) {\nthrow new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n\"[\" + parser.getOrdering() + \"]\");\n}\n}\n}","code_context_20":"private void validate() throws IllegalStateException {\nSet<DateComponentOrdering> orderings = Sets.newHashSet();\nif(preferred != null) {\norderings.add(preferred.getOrdering());\n}\nfor(DateTimeParser parser : otherParsers) {\nif(!orderings.add(parser.getOrdering())) {\nthrow new IllegalStateException(\"DateComponentOrdering can only be used once in a DateTimeMultiParser.\" +\n\"[\" + parser.getOrdering() + \"]\");\n}\n}\n}","label":[1,0,0,0]}
{"id":18370,"original_code":"public static String getEnumName(String fieldName ) {\n\t\t\/\/Later TODO\n\t\t\/\/return super.getEnumName(fieldName);\n\t\treturn null;\n\t}","code":"public static String getEnumName(String fieldName ) {\n\t\n\t\n\t\treturn null;\n\t}","cleancode":"public static string getenumname(string fieldname ) { return null; }","comment":"\/\/later todo \/\/return super.getenumname(fieldname);","repo":"aloklal99\/apache-ranger","code_context_2":"public static String getEnumName(String fieldName ) {\n\/\/Later TODO\n\/\/return super.getEnumName(fieldName);\nreturn null;\n}","code_context_10":"public static String getEnumName(String fieldName ) {\n\/\/Later TODO\n\/\/return super.getEnumName(fieldName);\nreturn null;\n}","code_context_20":"public static String getEnumName(String fieldName ) {\n\/\/Later TODO\n\/\/return super.getEnumName(fieldName);\nreturn null;\n}","label":[0,1,0,0]}
{"id":18422,"original_code":"public static StatsValues createStatsValues(StatsField statsField) {\n    final SchemaField sf = statsField.getSchemaField();\n    if (null == sf) {\n      \/\/ function stats\n      return new NumericStatsValues(statsField);\n    }\n    final FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\n    if (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\n      DateStatsValues statsValues = new DateStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedDateStatsValues(statsValues, statsField);\n      }\n      return statsValues;\n    } else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\n      NumericStatsValues statsValue = new NumericStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedNumericStatsValues(statsValue, statsField);\n      }\n      return statsValue;\n    } else if (StrField.class.isInstance(fieldType)) {\n      return new StringStatsValues(statsField);\n    } else if (AbstractEnumField.class.isInstance(fieldType)) {\n      return new EnumStatsValues(statsField);\n    } else {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST,\n          \"Field type \" + fieldType + \" is not currently supported\");\n    }\n  }","code":"public static StatsValues createStatsValues(StatsField statsField) {\n    final SchemaField sf = statsField.getSchemaField();\n    if (null == sf) {\n     \n      return new NumericStatsValues(statsField);\n    }\n    final FieldType fieldType = sf.getType();\n    if (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\n      DateStatsValues statsValues = new DateStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedDateStatsValues(statsValues, statsField);\n      }\n      return statsValues;\n    } else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\n      NumericStatsValues statsValue = new NumericStatsValues(statsField);\n      if (sf.multiValued()) {\n        return new SortedNumericStatsValues(statsValue, statsField);\n      }\n      return statsValue;\n    } else if (StrField.class.isInstance(fieldType)) {\n      return new StringStatsValues(statsField);\n    } else if (AbstractEnumField.class.isInstance(fieldType)) {\n      return new EnumStatsValues(statsField);\n    } else {\n      throw new SolrException(\n          SolrException.ErrorCode.BAD_REQUEST,\n          \"Field type \" + fieldType + \" is not currently supported\");\n    }\n  }","cleancode":"public static statsvalues createstatsvalues(statsfield statsfield) { final schemafield sf = statsfield.getschemafield(); if (null == sf) { return new numericstatsvalues(statsfield); } final fieldtype fieldtype = sf.gettype(); if (triedatefield.class.isinstance(fieldtype) || datepointfield.class.isinstance(fieldtype)) { datestatsvalues statsvalues = new datestatsvalues(statsfield); if (sf.multivalued()) { return new sorteddatestatsvalues(statsvalues, statsfield); } return statsvalues; } else if (triefield.class.isinstance(fieldtype) || pointfield.class.isinstance(fieldtype)) { numericstatsvalues statsvalue = new numericstatsvalues(statsfield); if (sf.multivalued()) { return new sortednumericstatsvalues(statsvalue, statsfield); } return statsvalue; } else if (strfield.class.isinstance(fieldtype)) { return new stringstatsvalues(statsfield); } else if (abstractenumfield.class.isinstance(fieldtype)) { return new enumstatsvalues(statsfield); } else { throw new solrexception( solrexception.errorcode.bad_request, \"field type \" + fieldtype + \" is not currently supported\"); } }","comment":"\/** * creates an instance of statsvalues which supports values from the specified {@link statsfield} * * @param statsfield {@link statsfield} whose statistics will be created by the resulting {@link * statsvalues} * @return instance of {@link statsvalues} that will create statistics from values from the * specified {@link statsfield} *\/\n\/\/ function stats\n\/\/ todo: allow fieldtype to provide impl.","repo":"ackepenek\/solr","code_context_2":"public static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);\n}\nreturn statsValue;\n} else if (StrField.class.isInstance(fieldType)) {\nreturn new StringStatsValues(statsField);\n} else if (AbstractEnumField.class.isInstance(fieldType)) {\nreturn new EnumStatsValues(statsField);\n} else {\nthrow new SolrException(\nSolrException.ErrorCode.BAD_REQUEST,\n\"Field type \" + fieldType + \" is not currently supported\");\n}\n}\n\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\n\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);","code_context_10":"public static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);\n}\nreturn statsValue;\n} else if (StrField.class.isInstance(fieldType)) {\nreturn new StringStatsValues(statsField);\n} else if (AbstractEnumField.class.isInstance(fieldType)) {\nreturn new EnumStatsValues(statsField);\n} else {\nthrow new SolrException(\nSolrException.ErrorCode.BAD_REQUEST,\n\"Field type \" + fieldType + \" is not currently supported\");\n}\n}\n\npublic static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\n\npublic static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);","code_context_20":"public static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);\n}\nreturn statsValue;\n} else if (StrField.class.isInstance(fieldType)) {\nreturn new StringStatsValues(statsField);\n} else if (AbstractEnumField.class.isInstance(fieldType)) {\nreturn new EnumStatsValues(statsField);\n} else {\nthrow new SolrException(\nSolrException.ErrorCode.BAD_REQUEST,\n\"Field type \" + fieldType + \" is not currently supported\");\n}\n}\n\npublic static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);\n}\nreturn statsValue;\n} else if (StrField.class.isInstance(fieldType)) {\nreturn new StringStatsValues(statsField);\n} else if (AbstractEnumField.class.isInstance(fieldType)) {\nreturn new EnumStatsValues(statsField);\n} else {\n\npublic static StatsValues createStatsValues(StatsField statsField) {\nfinal SchemaField sf = statsField.getSchemaField();\nif (null == sf) {\n\/\/ function stats\nreturn new NumericStatsValues(statsField);\n}\nfinal FieldType fieldType = sf.getType(); \/\/ TODO: allow FieldType to provide impl.\nif (TrieDateField.class.isInstance(fieldType) || DatePointField.class.isInstance(fieldType)) {\nDateStatsValues statsValues = new DateStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedDateStatsValues(statsValues, statsField);\n}\nreturn statsValues;\n} else if (TrieField.class.isInstance(fieldType) || PointField.class.isInstance(fieldType)) {\nNumericStatsValues statsValue = new NumericStatsValues(statsField);\nif (sf.multiValued()) {\nreturn new SortedNumericStatsValues(statsValue, statsField);\n}\nreturn statsValue;\n} else if (StrField.class.isInstance(fieldType)) {\nreturn new StringStatsValues(statsField);\n} else if (AbstractEnumField.class.isInstance(fieldType)) {\nreturn new EnumStatsValues(statsField);\n} else {\nthrow new SolrException(\nSolrException.ErrorCode.BAD_REQUEST,\n\"Field type \" + fieldType + \" is not currently supported\");","label":[0,1,0,0]}
{"id":18424,"original_code":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\n        this.setSelected(entry, true);\n    }","code":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\n        this.setSelected(entry, true);\n    }","cleancode":"public void setselected(@nullable packlistwidget.packentry entry) { this.setselected(entry, true); }","comment":"\/\/ todo: incompatible packs warning","repo":"VanillaImprovements\/VVDownloader","code_context_2":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\nthis.setSelected(entry, true);\n}","code_context_10":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\nthis.setSelected(entry, true);\n}","code_context_20":"public void setSelected(@Nullable PackListWidget.PackEntry entry) {\nthis.setSelected(entry, true);\n}","label":[0,1,0,0]}
{"id":2045,"original_code":"synchronized ImmutableList<JobEvent> getActiveEvents() {\n    ImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\n    for (String id : activeJobIds) {\n      JobEvent p = eventsByJobId.get(id);\n      assert p != null;\n      builder.add(p);\n    }\n    return builder.build();\n  }","code":"synchronized ImmutableList<JobEvent> getActiveEvents() {\n    ImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\n    for (String id : activeJobIds) {\n      JobEvent p = eventsByJobId.get(id);\n      assert p != null;\n      builder.add(p);\n    }\n    return builder.build();\n  }","cleancode":"synchronized immutablelist<jobevent> getactiveevents() { immutablelist.builder<jobevent> builder = immutablelist.builder(); for (string id : activejobids) { jobevent p = eventsbyjobid.get(id); assert p != null; builder.add(p); } return builder.build(); }","comment":"\/** * returns an event indicating the current status of each active job, in the order they were * submitted. * todo: hook this up. *\/","repo":"TeamSPoon\/CYC_JRTL_with_CommonLisp_OLD","code_context_2":"synchronized ImmutableList<JobEvent> getActiveEvents() {\nImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\nfor (String id : activeJobIds) {\nJobEvent p = eventsByJobId.get(id);\nassert p != null;\nbuilder.add(p);\n}\nreturn builder.build();\n}","code_context_10":"synchronized ImmutableList<JobEvent> getActiveEvents() {\nImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\nfor (String id : activeJobIds) {\nJobEvent p = eventsByJobId.get(id);\nassert p != null;\nbuilder.add(p);\n}\nreturn builder.build();\n}","code_context_20":"synchronized ImmutableList<JobEvent> getActiveEvents() {\nImmutableList.Builder<JobEvent> builder = ImmutableList.builder();\nfor (String id : activeJobIds) {\nJobEvent p = eventsByJobId.get(id);\nassert p != null;\nbuilder.add(p);\n}\nreturn builder.build();\n}","label":[1,0,0,0]}
{"id":18433,"original_code":"private VdsmVm appendStatistics(VdsmVm vm, V1VirtualMachineInstance vmi) {\n        VmStatistics statistics = new VmStatistics();\n        statistics.setId(vm.getId());\n        DateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\n        if (creationTimestampDate != null) {\n            DateTime now = DateTime.now();\n            Seconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\n            statistics.setElapsedTime((double) seconds.getSeconds());\n        }\n        PrometheusClient promClient = getPrometheusClient();\n        if (promClient != null) {\n            \/\/ FIXME: Kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total CPU time,\n            \/\/ so we are setting it here only as system time, which is wrong.\n            statistics.setCpuSys(\n                    promClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n            );\n        }\n        return vm.setVmStatistics(statistics)\n                .setDiskStatistics(Collections.emptyList())\n                .setVmJobs(Collections.emptyList());\n    }","code":"private VdsmVm appendStatistics(VdsmVm vm, V1VirtualMachineInstance vmi) {\n        VmStatistics statistics = new VmStatistics();\n        statistics.setId(vm.getId());\n        DateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\n        if (creationTimestampDate != null) {\n            DateTime now = DateTime.now();\n            Seconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\n            statistics.setElapsedTime((double) seconds.getSeconds());\n        }\n        PrometheusClient promClient = getPrometheusClient();\n        if (promClient != null) {\n           \n           \n            statistics.setCpuSys(\n                    promClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n            );\n        }\n        return vm.setVmStatistics(statistics)\n                .setDiskStatistics(Collections.emptyList())\n                .setVmJobs(Collections.emptyList());\n    }","cleancode":"private vdsmvm appendstatistics(vdsmvm vm, v1virtualmachineinstance vmi) { vmstatistics statistics = new vmstatistics(); statistics.setid(vm.getid()); datetime creationtimestampdate = vmi.getmetadata().getcreationtimestamp(); if (creationtimestampdate != null) { datetime now = datetime.now(); seconds seconds = seconds.secondsbetween(creationtimestampdate, now); statistics.setelapsedtime((double) seconds.getseconds()); } prometheusclient promclient = getprometheusclient(); if (promclient != null) { statistics.setcpusys( promclient.getvmicpuusage(vmi.getmetadata().getname(), vmi.getmetadata().getnamespace()) ); } return vm.setvmstatistics(statistics) .setdiskstatistics(collections.emptylist()) .setvmjobs(collections.emptylist()); }","comment":"\/\/ fixme: kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total cpu time, \/\/ so we are setting it here only as system time, which is wrong.","repo":"StevenCode\/ovirt-engine","code_context_2":"PrometheusClient promClient = getPrometheusClient();\nif (promClient != null) {\n\/\/ FIXME: Kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total CPU time,\n\/\/ so we are setting it here only as system time, which is wrong.\nstatistics.setCpuSys(\npromClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())","code_context_10":"VmStatistics statistics = new VmStatistics();\nstatistics.setId(vm.getId());\nDateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\nif (creationTimestampDate != null) {\nDateTime now = DateTime.now();\nSeconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\nstatistics.setElapsedTime((double) seconds.getSeconds());\n}\nPrometheusClient promClient = getPrometheusClient();\nif (promClient != null) {\n\/\/ FIXME: Kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total CPU time,\n\/\/ so we are setting it here only as system time, which is wrong.\nstatistics.setCpuSys(\npromClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n);\n}\nreturn vm.setVmStatistics(statistics)\n.setDiskStatistics(Collections.emptyList())\n.setVmJobs(Collections.emptyList());\n}","code_context_20":"private VdsmVm appendStatistics(VdsmVm vm, V1VirtualMachineInstance vmi) {\nVmStatistics statistics = new VmStatistics();\nstatistics.setId(vm.getId());\nDateTime creationTimestampDate = vmi.getMetadata().getCreationTimestamp();\nif (creationTimestampDate != null) {\nDateTime now = DateTime.now();\nSeconds seconds = Seconds.secondsBetween(creationTimestampDate, now);\nstatistics.setElapsedTime((double) seconds.getSeconds());\n}\nPrometheusClient promClient = getPrometheusClient();\nif (promClient != null) {\n\/\/ FIXME: Kubevirt currently have only kubevirt_vmi_vcpu_seconds, which is total CPU time,\n\/\/ so we are setting it here only as system time, which is wrong.\nstatistics.setCpuSys(\npromClient.getVmiCpuUsage(vmi.getMetadata().getName(), vmi.getMetadata().getNamespace())\n);\n}\nreturn vm.setVmStatistics(statistics)\n.setDiskStatistics(Collections.emptyList())\n.setVmJobs(Collections.emptyList());\n}","label":[0,0,1,0]}
{"id":18456,"original_code":"@Test \n    @Ignore(\"dbpedia is not reliable\")\n    public void testDBPedia() throws Exception {\n        testResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n    }","code":"@Test \n    @Ignore(\"dbpedia is not reliable\")\n    public void testDBPedia() throws Exception {\n        testResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n    }","cleancode":"@test @ignore(\"dbpedia is not reliable\") public void testdbpedia() throws exception { testresource(dbpedia, \"dbpedia-berlin.sparql\" ); }","comment":"\/** * this method tests accessing the dbpedia linked data service, which uses virtuoso and delivers rdf\/xml as * well as text\/turtle. * * @throws exception * @todo find a better way to deal with errors actually in the services and not in the code *\/","repo":"YYTVicky\/marmotta","code_context_2":"@Test\n@Ignore(\"dbpedia is not reliable\")\npublic void testDBPedia() throws Exception {\ntestResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n}","code_context_10":"@Test\n@Ignore(\"dbpedia is not reliable\")\npublic void testDBPedia() throws Exception {\ntestResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n}","code_context_20":"@Test\n@Ignore(\"dbpedia is not reliable\")\npublic void testDBPedia() throws Exception {\ntestResource(DBPEDIA, \"dbpedia-berlin.sparql\" );\n}","label":[1,0,0,0]}
{"id":34925,"original_code":"@Test\n    public void canCompleteItself() throws IOException {\n        String jid = queue.put(\"Foo\", null, null);\n        queue.pop().complete(); \/\/ TODO: this test passes even when this line is removed\n        Assert.assertEquals(\"complete\", client.getJob(jid).getState());\n    }","code":"@Test\n    public void canCompleteItself() throws IOException {\n        String jid = queue.put(\"Foo\", null, null);\n        queue.pop().complete();\n        Assert.assertEquals(\"complete\", client.getJob(jid).getState());\n    }","cleancode":"@test public void cancompleteitself() throws ioexception { string jid = queue.put(\"foo\", null, null); queue.pop().complete(); assert.assertequals(\"complete\", client.getjob(jid).getstate()); }","comment":"\/\/ todo: this test passes even when this line is removed","repo":"Zimbra\/qless-java","code_context_2":"public void canCompleteItself() throws IOException {\nString jid = queue.put(\"Foo\", null, null);\nqueue.pop().complete(); \/\/ TODO: this test passes even when this line is removed\nAssert.assertEquals(\"complete\", client.getJob(jid).getState());\n}","code_context_10":"@Test\npublic void canCompleteItself() throws IOException {\nString jid = queue.put(\"Foo\", null, null);\nqueue.pop().complete(); \/\/ TODO: this test passes even when this line is removed\nAssert.assertEquals(\"complete\", client.getJob(jid).getState());\n}","code_context_20":"@Test\npublic void canCompleteItself() throws IOException {\nString jid = queue.put(\"Foo\", null, null);\nqueue.pop().complete(); \/\/ TODO: this test passes even when this line is removed\nAssert.assertEquals(\"complete\", client.getJob(jid).getState());\n}","label":[0,0,0,1]}
{"id":18643,"original_code":"@Override\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\n        if (affectedControllerId.equals(source.getControllerId())) {\n            Card card = game.getCard(objectId);\n            MageObject sourceObject = source.getSourceObject(game);\n            if (card != null && !card.isLand() && sourceObject != null) {\n                UUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\n                if (exileId != null) {\n                    ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\n                    if (exileZone != null && exileZone.contains(objectId)) {\n                        if (game.getTurnNum() == turnNumber) {\n                            if (!exileZone.contains(cardId)) {\n                                \/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect\n                                \/\/ TODO: Handle if card was cast\/removed from exile with effect from another card.\n                                \/\/       If so, this effect could prevent player from casting although they should be able to use it\n                                return false;\n                            }\n                        }\n                        this.turnNumber = game.getTurnNum();\n                        this.cardId = objectId;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","code":"@Override\n    public boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\n        if (affectedControllerId.equals(source.getControllerId())) {\n            Card card = game.getCard(objectId);\n            MageObject sourceObject = source.getSourceObject(game);\n            if (card != null && !card.isLand() && sourceObject != null) {\n                UUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\n                if (exileId != null) {\n                    ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\n                    if (exileZone != null && exileZone.contains(objectId)) {\n                        if (game.getTurnNum() == turnNumber) {\n                            if (!exileZone.contains(cardId)) {\n                               \n                               \n                               \n                                return false;\n                            }\n                        }\n                        this.turnNumber = game.getTurnNum();\n                        this.cardId = objectId;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }","cleancode":"@override public boolean applies(uuid objectid, ability source, uuid affectedcontrollerid, game game) { if (affectedcontrollerid.equals(source.getcontrollerid())) { card card = game.getcard(objectid); mageobject sourceobject = source.getsourceobject(game); if (card != null && !card.island() && sourceobject != null) { uuid exileid = cardutil.getexilezoneid(game, source.getsourceid(), source.getsourceobjectzonechangecounter()); if (exileid != null) { exilezone exilezone = game.getstate().getexile().getexilezone(exileid); if (exilezone != null && exilezone.contains(objectid)) { if (game.getturnnum() == turnnumber) { if (!exilezone.contains(cardid)) { return false; } } this.turnnumber = game.getturnnum(); this.cardid = objectid; return true; } } } } return false; }","comment":"\/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect \/\/ todo: handle if card was cast\/removed from exile with effect from another card. \/\/ if so, this effect could prevent player from casting although they should be able to use it","repo":"amc8391\/mage","code_context_2":"if (game.getTurnNum() == turnNumber) {\nif (!exileZone.contains(cardId)) {\n\/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect\n\/\/ TODO: Handle if card was cast\/removed from exile with effect from another card.\n\/\/ If so, this effect could prevent player from casting although they should be able to use it\nreturn false;\n}","code_context_10":"if (affectedControllerId.equals(source.getControllerId())) {\nCard card = game.getCard(objectId);\nMageObject sourceObject = source.getSourceObject(game);\nif (card != null && !card.isLand() && sourceObject != null) {\nUUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\nif (exileId != null) {\nExileZone exileZone = game.getState().getExile().getExileZone(exileId);\nif (exileZone != null && exileZone.contains(objectId)) {\nif (game.getTurnNum() == turnNumber) {\nif (!exileZone.contains(cardId)) {\n\/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect\n\/\/ TODO: Handle if card was cast\/removed from exile with effect from another card.\n\/\/ If so, this effect could prevent player from casting although they should be able to use it\nreturn false;\n}\n}\nthis.turnNumber = game.getTurnNum();\nthis.cardId = objectId;\nreturn true;\n}\n}\n}\n}","code_context_20":"@Override\npublic boolean applies(UUID objectId, Ability source, UUID affectedControllerId, Game game) {\nif (affectedControllerId.equals(source.getControllerId())) {\nCard card = game.getCard(objectId);\nMageObject sourceObject = source.getSourceObject(game);\nif (card != null && !card.isLand() && sourceObject != null) {\nUUID exileId = CardUtil.getExileZoneId(game, source.getSourceId(), source.getSourceObjectZoneChangeCounter());\nif (exileId != null) {\nExileZone exileZone = game.getState().getExile().getExileZone(exileId);\nif (exileZone != null && exileZone.contains(objectId)) {\nif (game.getTurnNum() == turnNumber) {\nif (!exileZone.contains(cardId)) {\n\/\/ last checked card this turn is no longer exiled, so you can't cast another with this effect\n\/\/ TODO: Handle if card was cast\/removed from exile with effect from another card.\n\/\/ If so, this effect could prevent player from casting although they should be able to use it\nreturn false;\n}\n}\nthis.turnNumber = game.getTurnNum();\nthis.cardId = objectId;\nreturn true;\n}\n}\n}\n}\nreturn false;\n}","label":[0,0,1,0]}
{"id":2359,"original_code":"public static String getFilePathDiskCache(final String key) {\n        if (sDiskLruCache == null) {\n            return null;\n        }\n        \/\/ This violates encapsulation but there is no convenience method to get a filename from\n        \/\/ DiskLruCache. Filename was derived from private class method Entry#getCleanFile\n        \/\/ in DiskLruCache.java\n        return sDiskLruCache.getDirectory()\n                + File.separator\n                + createValidDiskCacheKey(key)\n                + \".\"\n                + DISK_CACHE_INDEX;\n    }","code":"public static String getFilePathDiskCache(final String key) {\n        if (sDiskLruCache == null) {\n            return null;\n        }\n       \n       \n       \n        return sDiskLruCache.getDirectory()\n                + File.separator\n                + createValidDiskCacheKey(key)\n                + \".\"\n                + DISK_CACHE_INDEX;\n    }","cleancode":"public static string getfilepathdiskcache(final string key) { if (sdisklrucache == null) { return null; } return sdisklrucache.getdirectory() + file.separator + createvaliddiskcachekey(key) + \".\" + disk_cache_index; }","comment":"\/\/ this violates encapsulation but there is no convenience method to get a filename from \/\/ disklrucache. filename was derived from private class method entry#getcleanfile \/\/ in disklrucache.java","repo":"SinnerSchraderMobileMirrors\/mopub-android-sdk","code_context_2":"return null;\n}\n\/\/ This violates encapsulation but there is no convenience method to get a filename from\n\/\/ DiskLruCache. Filename was derived from private class method Entry#getCleanFile\n\/\/ in DiskLruCache.java\nreturn sDiskLruCache.getDirectory()\n+ File.separator","code_context_10":"public static String getFilePathDiskCache(final String key) {\nif (sDiskLruCache == null) {\nreturn null;\n}\n\/\/ This violates encapsulation but there is no convenience method to get a filename from\n\/\/ DiskLruCache. Filename was derived from private class method Entry#getCleanFile\n\/\/ in DiskLruCache.java\nreturn sDiskLruCache.getDirectory()\n+ File.separator\n+ createValidDiskCacheKey(key)\n+ \".\"\n+ DISK_CACHE_INDEX;\n}","code_context_20":"public static String getFilePathDiskCache(final String key) {\nif (sDiskLruCache == null) {\nreturn null;\n}\n\/\/ This violates encapsulation but there is no convenience method to get a filename from\n\/\/ DiskLruCache. Filename was derived from private class method Entry#getCleanFile\n\/\/ in DiskLruCache.java\nreturn sDiskLruCache.getDirectory()\n+ File.separator\n+ createValidDiskCacheKey(key)\n+ \".\"\n+ DISK_CACHE_INDEX;\n}","label":[1,0,0,0]}
{"id":18861,"original_code":"private void setUpViews() {\n        glucometerAttribution = findViewById(R.id.glucometerAttribution);\n        glucometerImg = findViewById(R.id.glucometerImg);\n        insertStripText = findViewById(R.id.insertStripText);\n        upArrow = findViewById(R.id.upArrow);\n        droplet = findViewById(R.id.dropletImg);\n        attributionText = findViewById(R.id.attributionText);\n        placeBloodSweatImg = findViewById(R.id.placeBloodSweatImg);\n        placeBloodSweatText = findViewById(R.id.placeBloodSweatText);\n        waitForReadingText = findViewById(R.id.waitForReadingText);\n        progressBar = findViewById(R.id.progressBar);\n        unitsText = findViewById(R.id.unitsText);\n        glucoseLevelText = findViewById(R.id.glucoseLevelText);\n        descriptionTxt = findViewById(R.id.descriptionTxt);\n        detailsBtn = findViewById(R.id.detailsBtn);\n        anotherReadingBtn = findViewById(R.id.anotherReadingBtn);\n        showBtn = findViewById(R.id.button7);\n        dippedBtn = findViewById(R.id.button6);\n        stripBtn = findViewById(R.id.button8);\n        startButton = findViewById(R.id.btnStripInserted);\n        rgMode = findViewById(R.id.rgMode);\n        rbBlood = findViewById(R.id.rbBlood);\n        rbSweat = findViewById(R.id.rbSweat);\n        rb_mg_dL = findViewById(R.id.rb_mg_dL);\n        rb_mmol_L = findViewById(R.id.rb_mmol_L);\n        glucometerSwitch = findViewById(R.id.glucometerSwitch);\n        rgUnits = findViewById(R.id.rgUnits);\n        startButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!rbSweat.isChecked() && !rbBlood.isChecked()) {\n                    Toast.makeText(GlucometerActivity.this, \"Please select a mode\", Toast.LENGTH_SHORT).show();\n                }\n                else {\n                    instance.sendDataToArduino(\"start\");\n                    instance.setReading(true);\n                    glucometerSwitch.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    startButton.setEnabled(false);\n                    glucometerImg.setVisibility(View.VISIBLE);\n                    glucometerAttribution.setVisibility(View.VISIBLE);\n                    insertStripText.setVisibility(View.VISIBLE);\n                    upArrow.setVisibility(View.VISIBLE);\n                }\n            }\n        });\n        rgMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rbBlood:\n                        instance.sendDataToArduino(\"Blood\");\n                        droplet.setColorFilter(Color.parseColor(\"#F44336\"));\n                        placeBloodSweatText.setText(\"Place blood on the test strip\");\n                        break;\n                    case R.id.rbSweat:\n                        instance.sendDataToArduino(\"Sweat\");\n                        droplet.setColorFilter(Color.parseColor(\"#1b95e0\"));\n                        placeBloodSweatText.setText(\"Place sweat on the test strip\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        glucometerSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (isChecked){\n                    instance.sendDataToArduino(\"G_on\");\n                    viewDelay();\n                }else {\n                    instance.sendDataToArduino(\"G_off\");\n                    startButton.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    glucometerSwitch.setEnabled(false);\n                    viewHandler = new Handler();\n                    Runnable delay = new Runnable() {\n                        @Override\n                        public void run() {\n                            glucometerSwitch.setEnabled(true);\n                        }\n                    };\n                    viewHandler.postDelayed(delay, 1000);\n                }\n            }\n        });\n        rgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rb_mg_dL:\n                        \/\/TODO Display readings in mg\/dL\n                        unitsText.setText(\"mg\/dL\");\n                        break;\n                    case R.id.rb_mmol_L:\n                        \/\/TODO Display readings in mmol\/L\n                        unitsText.setText(\"mmol\/L\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        detailsBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                \/\/Move to new activity\n                Intent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n                startActivity(intent);\n            }\n        });\n        anotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setReading(false);\n                glucometerSwitch.setEnabled(true);\n                rbBlood.setEnabled(true);\n                rbSweat.setEnabled(true);\n                rb_mg_dL.setEnabled(true);\n                rb_mmol_L.setEnabled(true);\n                startButton.setEnabled(true);\n                instance.setStringData(null);\n                instance.setCommand(null);\n                unitsText.setVisibility(View.INVISIBLE);\n                glucoseLevelText.setVisibility(View.INVISIBLE);\n                descriptionTxt.setVisibility(View.INVISIBLE);\n                detailsBtn.setVisibility(View.INVISIBLE);\n                anotherReadingBtn.setVisibility(View.INVISIBLE);\n            }\n        });\n        showBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"show\");\n            }\n        });\n        stripBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"strip\");\n            }\n        });\n        dippedBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"dipped\");\n            }\n        });\n    }","code":"private void setUpViews() {\n        glucometerAttribution = findViewById(R.id.glucometerAttribution);\n        glucometerImg = findViewById(R.id.glucometerImg);\n        insertStripText = findViewById(R.id.insertStripText);\n        upArrow = findViewById(R.id.upArrow);\n        droplet = findViewById(R.id.dropletImg);\n        attributionText = findViewById(R.id.attributionText);\n        placeBloodSweatImg = findViewById(R.id.placeBloodSweatImg);\n        placeBloodSweatText = findViewById(R.id.placeBloodSweatText);\n        waitForReadingText = findViewById(R.id.waitForReadingText);\n        progressBar = findViewById(R.id.progressBar);\n        unitsText = findViewById(R.id.unitsText);\n        glucoseLevelText = findViewById(R.id.glucoseLevelText);\n        descriptionTxt = findViewById(R.id.descriptionTxt);\n        detailsBtn = findViewById(R.id.detailsBtn);\n        anotherReadingBtn = findViewById(R.id.anotherReadingBtn);\n        showBtn = findViewById(R.id.button7);\n        dippedBtn = findViewById(R.id.button6);\n        stripBtn = findViewById(R.id.button8);\n        startButton = findViewById(R.id.btnStripInserted);\n        rgMode = findViewById(R.id.rgMode);\n        rbBlood = findViewById(R.id.rbBlood);\n        rbSweat = findViewById(R.id.rbSweat);\n        rb_mg_dL = findViewById(R.id.rb_mg_dL);\n        rb_mmol_L = findViewById(R.id.rb_mmol_L);\n        glucometerSwitch = findViewById(R.id.glucometerSwitch);\n        rgUnits = findViewById(R.id.rgUnits);\n        startButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!rbSweat.isChecked() && !rbBlood.isChecked()) {\n                    Toast.makeText(GlucometerActivity.this, \"Please select a mode\", Toast.LENGTH_SHORT).show();\n                }\n                else {\n                    instance.sendDataToArduino(\"start\");\n                    instance.setReading(true);\n                    glucometerSwitch.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    startButton.setEnabled(false);\n                    glucometerImg.setVisibility(View.VISIBLE);\n                    glucometerAttribution.setVisibility(View.VISIBLE);\n                    insertStripText.setVisibility(View.VISIBLE);\n                    upArrow.setVisibility(View.VISIBLE);\n                }\n            }\n        });\n        rgMode.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rbBlood:\n                        instance.sendDataToArduino(\"Blood\");\n                        droplet.setColorFilter(Color.parseColor(\"#F44336\"));\n                        placeBloodSweatText.setText(\"Place blood on the test strip\");\n                        break;\n                    case R.id.rbSweat:\n                        instance.sendDataToArduino(\"Sweat\");\n                        droplet.setColorFilter(Color.parseColor(\"#1b95e0\"));\n                        placeBloodSweatText.setText(\"Place sweat on the test strip\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        glucometerSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (isChecked){\n                    instance.sendDataToArduino(\"G_on\");\n                    viewDelay();\n                }else {\n                    instance.sendDataToArduino(\"G_off\");\n                    startButton.setEnabled(false);\n                    rbBlood.setEnabled(false);\n                    rbSweat.setEnabled(false);\n                    rb_mg_dL.setEnabled(false);\n                    rb_mmol_L.setEnabled(false);\n                    glucometerSwitch.setEnabled(false);\n                    viewHandler = new Handler();\n                    Runnable delay = new Runnable() {\n                        @Override\n                        public void run() {\n                            glucometerSwitch.setEnabled(true);\n                        }\n                    };\n                    viewHandler.postDelayed(delay, 1000);\n                }\n            }\n        });\n        rgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(RadioGroup group, int checkedId) {\n                switch (checkedId) {\n                    case R.id.rb_mg_dL:\n                       \n                        unitsText.setText(\"mg\/dL\");\n                        break;\n                    case R.id.rb_mmol_L:\n                       \n                        unitsText.setText(\"mmol\/L\");\n                        break;\n                }\n                viewDelay();\n            }\n        });\n        detailsBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n               \n                Intent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\n                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\n                startActivity(intent);\n            }\n        });\n        anotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setReading(false);\n                glucometerSwitch.setEnabled(true);\n                rbBlood.setEnabled(true);\n                rbSweat.setEnabled(true);\n                rb_mg_dL.setEnabled(true);\n                rb_mmol_L.setEnabled(true);\n                startButton.setEnabled(true);\n                instance.setStringData(null);\n                instance.setCommand(null);\n                unitsText.setVisibility(View.INVISIBLE);\n                glucoseLevelText.setVisibility(View.INVISIBLE);\n                descriptionTxt.setVisibility(View.INVISIBLE);\n                detailsBtn.setVisibility(View.INVISIBLE);\n                anotherReadingBtn.setVisibility(View.INVISIBLE);\n            }\n        });\n        showBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"show\");\n            }\n        });\n        stripBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"strip\");\n            }\n        });\n        dippedBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                instance.setCommand(\"dipped\");\n            }\n        });\n    }","cleancode":"private void setupviews() { glucometerattribution = findviewbyid(r.id.glucometerattribution); glucometerimg = findviewbyid(r.id.glucometerimg); insertstriptext = findviewbyid(r.id.insertstriptext); uparrow = findviewbyid(r.id.uparrow); droplet = findviewbyid(r.id.dropletimg); attributiontext = findviewbyid(r.id.attributiontext); placebloodsweatimg = findviewbyid(r.id.placebloodsweatimg); placebloodsweattext = findviewbyid(r.id.placebloodsweattext); waitforreadingtext = findviewbyid(r.id.waitforreadingtext); progressbar = findviewbyid(r.id.progressbar); unitstext = findviewbyid(r.id.unitstext); glucoseleveltext = findviewbyid(r.id.glucoseleveltext); descriptiontxt = findviewbyid(r.id.descriptiontxt); detailsbtn = findviewbyid(r.id.detailsbtn); anotherreadingbtn = findviewbyid(r.id.anotherreadingbtn); showbtn = findviewbyid(r.id.button7); dippedbtn = findviewbyid(r.id.button6); stripbtn = findviewbyid(r.id.button8); startbutton = findviewbyid(r.id.btnstripinserted); rgmode = findviewbyid(r.id.rgmode); rbblood = findviewbyid(r.id.rbblood); rbsweat = findviewbyid(r.id.rbsweat); rb_mg_dl = findviewbyid(r.id.rb_mg_dl); rb_mmol_l = findviewbyid(r.id.rb_mmol_l); glucometerswitch = findviewbyid(r.id.glucometerswitch); rgunits = findviewbyid(r.id.rgunits); startbutton.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { if (!rbsweat.ischecked() && !rbblood.ischecked()) { toast.maketext(glucometeractivity.this, \"please select a mode\", toast.length_short).show(); } else { instance.senddatatoarduino(\"start\"); instance.setreading(true); glucometerswitch.setenabled(false); rbblood.setenabled(false); rbsweat.setenabled(false); rb_mg_dl.setenabled(false); rb_mmol_l.setenabled(false); startbutton.setenabled(false); glucometerimg.setvisibility(view.visible); glucometerattribution.setvisibility(view.visible); insertstriptext.setvisibility(view.visible); uparrow.setvisibility(view.visible); } } }); rgmode.setoncheckedchangelistener(new radiogroup.oncheckedchangelistener() { @override public void oncheckedchanged(radiogroup group, int checkedid) { switch (checkedid) { case r.id.rbblood: instance.senddatatoarduino(\"blood\"); droplet.setcolorfilter(color.parsecolor(\"#f44336\")); placebloodsweattext.settext(\"place blood on the test strip\"); break; case r.id.rbsweat: instance.senddatatoarduino(\"sweat\"); droplet.setcolorfilter(color.parsecolor(\"#1b95e0\")); placebloodsweattext.settext(\"place sweat on the test strip\"); break; } viewdelay(); } }); glucometerswitch.setoncheckedchangelistener(new compoundbutton.oncheckedchangelistener() { @override public void oncheckedchanged(compoundbutton buttonview, boolean ischecked) { if (ischecked){ instance.senddatatoarduino(\"g_on\"); viewdelay(); }else { instance.senddatatoarduino(\"g_off\"); startbutton.setenabled(false); rbblood.setenabled(false); rbsweat.setenabled(false); rb_mg_dl.setenabled(false); rb_mmol_l.setenabled(false); glucometerswitch.setenabled(false); viewhandler = new handler(); runnable delay = new runnable() { @override public void run() { glucometerswitch.setenabled(true); } }; viewhandler.postdelayed(delay, 1000); } } }); rgunits.setoncheckedchangelistener(new radiogroup.oncheckedchangelistener() { @override public void oncheckedchanged(radiogroup group, int checkedid) { switch (checkedid) { case r.id.rb_mg_dl: unitstext.settext(\"mg\/dl\"); break; case r.id.rb_mmol_l: unitstext.settext(\"mmol\/l\"); break; } viewdelay(); } }); detailsbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { intent intent = new intent(glucometeractivity.this, glucosereadingdetailsactivity.class); intent.addflags(intent.flag_activity_no_animation); startactivity(intent); } }); anotherreadingbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setreading(false); glucometerswitch.setenabled(true); rbblood.setenabled(true); rbsweat.setenabled(true); rb_mg_dl.setenabled(true); rb_mmol_l.setenabled(true); startbutton.setenabled(true); instance.setstringdata(null); instance.setcommand(null); unitstext.setvisibility(view.invisible); glucoseleveltext.setvisibility(view.invisible); descriptiontxt.setvisibility(view.invisible); detailsbtn.setvisibility(view.invisible); anotherreadingbtn.setvisibility(view.invisible); } }); showbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"show\"); } }); stripbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"strip\"); } }); dippedbtn.setonclicklistener(new view.onclicklistener() { @override public void onclick(view v) { instance.setcommand(\"dipped\"); } }); }","comment":"\/\/todo display readings in mg\/dl\n\/\/todo display readings in mmol\/l\n\/\/move to new activity","repo":"W6WM9M\/VitalityMeter","code_context_2":"switch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\n\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\nIntent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);","code_context_10":"};\nviewHandler.postDelayed(delay, 1000);\n}\n}\n});\nrgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n@Override\npublic void onCheckedChanged(RadioGroup group, int checkedId) {\nswitch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\n\n});\nrgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n@Override\npublic void onCheckedChanged(RadioGroup group, int checkedId) {\nswitch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\ndetailsBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\n\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\ndetailsBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\nIntent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\nstartActivity(intent);\n}\n});\nanotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\ninstance.setReading(false);\nglucometerSwitch.setEnabled(true);","code_context_20":"rbSweat.setEnabled(false);\nrb_mg_dL.setEnabled(false);\nrb_mmol_L.setEnabled(false);\nglucometerSwitch.setEnabled(false);\nviewHandler = new Handler();\nRunnable delay = new Runnable() {\n@Override\npublic void run() {\nglucometerSwitch.setEnabled(true);\n}\n};\nviewHandler.postDelayed(delay, 1000);\n}\n}\n});\nrgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n@Override\npublic void onCheckedChanged(RadioGroup group, int checkedId) {\nswitch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\ndetailsBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\nIntent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\nstartActivity(intent);\n}\n});\nanotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n\nviewHandler = new Handler();\nRunnable delay = new Runnable() {\n@Override\npublic void run() {\nglucometerSwitch.setEnabled(true);\n}\n};\nviewHandler.postDelayed(delay, 1000);\n}\n}\n});\nrgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n@Override\npublic void onCheckedChanged(RadioGroup group, int checkedId) {\nswitch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\ndetailsBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\nIntent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\nstartActivity(intent);\n}\n});\nanotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\ninstance.setReading(false);\nglucometerSwitch.setEnabled(true);\n\n});\nrgUnits.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() {\n@Override\npublic void onCheckedChanged(RadioGroup group, int checkedId) {\nswitch (checkedId) {\ncase R.id.rb_mg_dL:\n\/\/TODO Display readings in mg\/dL\nunitsText.setText(\"mg\/dL\");\nbreak;\ncase R.id.rb_mmol_L:\n\/\/TODO Display readings in mmol\/L\nunitsText.setText(\"mmol\/L\");\nbreak;\n}\nviewDelay();\n}\n});\ndetailsBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\n\/\/Move to new activity\nIntent intent = new Intent(GlucometerActivity.this, GlucoseReadingDetailsActivity.class);\nintent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);\nstartActivity(intent);\n}\n});\nanotherReadingBtn.setOnClickListener(new View.OnClickListener() {\n@Override\npublic void onClick(View v) {\ninstance.setReading(false);\nglucometerSwitch.setEnabled(true);\nrbBlood.setEnabled(true);\nrbSweat.setEnabled(true);\nrb_mg_dL.setEnabled(true);\nrb_mmol_L.setEnabled(true);\nstartButton.setEnabled(true);\ninstance.setStringData(null);\ninstance.setCommand(null);\nunitsText.setVisibility(View.INVISIBLE);\nglucoseLevelText.setVisibility(View.INVISIBLE);\ndescriptionTxt.setVisibility(View.INVISIBLE);","label":[0,1,0,0]}
{"id":10671,"original_code":"public void render(SpriteBatch batch) {\n        viewport.apply();\n        batch.setProjectionMatrix(viewport.getCamera().combined);\n        batch.begin();\n        \/\/ TODO: Draw a game over message\n        \/\/ Feel free to get more creative with this screen. Perhaps you could cover the screen in enemy robots?\n        float timeElapsed = Utils.secondsSince(startTime);\n        int enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\n        for (int i = 0; i < enemiesToShow; i++){\n            Enemy enemy = enemies.get(i);\n            enemy.update(0);\n            enemy.render(batch);\n        }\n        font.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\n        batch.end();\n    }","code":"public void render(SpriteBatch batch) {\n        viewport.apply();\n        batch.setProjectionMatrix(viewport.getCamera().combined);\n        batch.begin();\n       \n       \n        float timeElapsed = Utils.secondsSince(startTime);\n        int enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\n        for (int i = 0; i < enemiesToShow; i++){\n            Enemy enemy = enemies.get(i);\n            enemy.update(0);\n            enemy.render(batch);\n        }\n        font.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\n        batch.end();\n    }","cleancode":"public void render(spritebatch batch) { viewport.apply(); batch.setprojectionmatrix(viewport.getcamera().combined); batch.begin(); float timeelapsed = utils.secondssince(starttime); int enemiestoshow = (int) (constants.enemy_count * (timeelapsed \/ constants.level_end_duration)); for (int i = 0; i < enemiestoshow; i++){ enemy enemy = enemies.get(i); enemy.update(0); enemy.render(batch); } font.draw(batch, constants.game_over_message, viewport.getworldwidth() \/ 2, viewport.getworldheight() \/ 2.5f, 0, align.center, false); batch.end(); }","comment":"\/\/ todo: draw a game over message \/\/ feel free to get more creative with this screen. perhaps you could cover the screen in enemy robots?","repo":"Sceptres\/ud406","code_context_2":"batch.setProjectionMatrix(viewport.getCamera().combined);\nbatch.begin();\n\/\/ TODO: Draw a game over message\n\/\/ Feel free to get more creative with this screen. Perhaps you could cover the screen in enemy robots?\nfloat timeElapsed = Utils.secondsSince(startTime);\nint enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));","code_context_10":"public void render(SpriteBatch batch) {\nviewport.apply();\nbatch.setProjectionMatrix(viewport.getCamera().combined);\nbatch.begin();\n\/\/ TODO: Draw a game over message\n\/\/ Feel free to get more creative with this screen. Perhaps you could cover the screen in enemy robots?\nfloat timeElapsed = Utils.secondsSince(startTime);\nint enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\nfor (int i = 0; i < enemiesToShow; i++){\nEnemy enemy = enemies.get(i);\nenemy.update(0);\nenemy.render(batch);\n}\nfont.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\nbatch.end();\n}","code_context_20":"public void render(SpriteBatch batch) {\nviewport.apply();\nbatch.setProjectionMatrix(viewport.getCamera().combined);\nbatch.begin();\n\/\/ TODO: Draw a game over message\n\/\/ Feel free to get more creative with this screen. Perhaps you could cover the screen in enemy robots?\nfloat timeElapsed = Utils.secondsSince(startTime);\nint enemiesToShow = (int) (Constants.ENEMY_COUNT * (timeElapsed \/ Constants.LEVEL_END_DURATION));\nfor (int i = 0; i < enemiesToShow; i++){\nEnemy enemy = enemies.get(i);\nenemy.update(0);\nenemy.render(batch);\n}\nfont.draw(batch, Constants.GAME_OVER_MESSAGE, viewport.getWorldWidth() \/ 2, viewport.getWorldHeight() \/ 2.5f, 0, Align.center, false);\nbatch.end();\n}","label":[0,1,0,0]}
{"id":2527,"original_code":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\n        return Language.i18n(locale, base + \".\" +  enumToGet.name().toLowerCase());\n    }","code":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\n        return Language.i18n(locale, base + \".\" +  enumToGet.name().toLowerCase());\n    }","cleancode":"public static <t extends enum> string getenumi18n(locale locale, string base, t enumtoget) { return language.i18n(locale, base + \".\" + enumtoget.name().tolowercase()); }","comment":"\/\/ todo: doc","repo":"TortleWortle\/CascadeBot","code_context_2":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\nreturn Language.i18n(locale, base + \".\" + enumToGet.name().toLowerCase());\n}","code_context_10":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\nreturn Language.i18n(locale, base + \".\" + enumToGet.name().toLowerCase());\n}","code_context_20":"public static <T extends Enum> String getEnumI18n(Locale locale, String base, T enumToGet) {\nreturn Language.i18n(locale, base + \".\" + enumToGet.name().toLowerCase());\n}","label":[0,0,0,0]}
{"id":10747,"original_code":"public JsonObject setMaxComments(int comments){\n        JsonObject result = new JsonObject();\n        if( dbServices.setMaxCommentsPerVideo(comments)) {\n            result.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n        }\n        else\n            result.addProperty(\"error\",\"Failed to set max comments per video\");\n        return result;\n    }","code":"public JsonObject setMaxComments(int comments){\n        JsonObject result = new JsonObject();\n        if( dbServices.setMaxCommentsPerVideo(comments)) {\n            result.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n        }\n        else\n            result.addProperty(\"error\",\"Failed to set max comments per video\");\n        return result;\n    }","cleancode":"public jsonobject setmaxcomments(int comments){ jsonobject result = new jsonobject(); if( dbservices.setmaxcommentspervideo(comments)) { result.addproperty(\"msg\", \"max comments to collect for each video is now: \" + comments); } else result.addproperty(\"error\",\"failed to set max comments per video\"); return result; }","comment":"\/** * todo need implementation i think * @param comments * @return *\/","repo":"UCY-LINC-LAB\/YouTube-Twitter-Analysis","code_context_2":"public JsonObject setMaxComments(int comments){\nJsonObject result = new JsonObject();\nif( dbServices.setMaxCommentsPerVideo(comments)) {\nresult.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n}\nelse\nresult.addProperty(\"error\",\"Failed to set max comments per video\");\nreturn result;\n}","code_context_10":"public JsonObject setMaxComments(int comments){\nJsonObject result = new JsonObject();\nif( dbServices.setMaxCommentsPerVideo(comments)) {\nresult.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n}\nelse\nresult.addProperty(\"error\",\"Failed to set max comments per video\");\nreturn result;\n}","code_context_20":"public JsonObject setMaxComments(int comments){\nJsonObject result = new JsonObject();\nif( dbServices.setMaxCommentsPerVideo(comments)) {\nresult.addProperty(\"msg\", \"Max comments to collect for each video is now: \" + comments);\n}\nelse\nresult.addProperty(\"error\",\"Failed to set max comments per video\");\nreturn result;\n}","label":[0,1,0,0]}
{"id":2557,"original_code":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\n    OzoneConfiguration conf = new OzoneConfiguration();\n    \/\/ TODO: If you don't have OM HA configured, change the following as appropriate.\n    conf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\n    if (disableChecksum)\n      conf.set(\"ozone.client.checksum.type\", \"NONE\");\n    return OzoneClientFactory.getRpcClient(conf);\n  }","code":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\n    OzoneConfiguration conf = new OzoneConfiguration();\n   \n    conf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\n    if (disableChecksum)\n      conf.set(\"ozone.client.checksum.type\", \"NONE\");\n    return OzoneClientFactory.getRpcClient(conf);\n  }","cleancode":"static ozoneclient getozoneclient(boolean secure) throws ioexception { ozoneconfiguration conf = new ozoneconfiguration(); conf.set(\"ozone.om.address\", \"9.29.173.57:9862\"); if (disablechecksum) conf.set(\"ozone.client.checksum.type\", \"none\"); return ozoneclientfactory.getrpcclient(conf); }","comment":"\/\/ todo: if you don't have om ha configured, change the following as appropriate.","repo":"SincereXIA\/ozonerpc2","code_context_2":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\nOzoneConfiguration conf = new OzoneConfiguration();\n\/\/ TODO: If you don't have OM HA configured, change the following as appropriate.\nconf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\nif (disableChecksum)","code_context_10":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\nOzoneConfiguration conf = new OzoneConfiguration();\n\/\/ TODO: If you don't have OM HA configured, change the following as appropriate.\nconf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\nif (disableChecksum)\nconf.set(\"ozone.client.checksum.type\", \"NONE\");\nreturn OzoneClientFactory.getRpcClient(conf);\n}","code_context_20":"static OzoneClient getOzoneClient(boolean secure) throws IOException {\nOzoneConfiguration conf = new OzoneConfiguration();\n\/\/ TODO: If you don't have OM HA configured, change the following as appropriate.\nconf.set(\"ozone.om.address\", \"9.29.173.57:9862\");\nif (disableChecksum)\nconf.set(\"ozone.client.checksum.type\", \"NONE\");\nreturn OzoneClientFactory.getRpcClient(conf);\n}","label":[1,0,0,0]}
{"id":10797,"original_code":"@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\n\tST_field_t info;\n\tfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\n    boolean flip;\n    int len;\n    CString textbuf;\t\t\/* temp buffer for storing labels *\/\n\tint sides = BOTTOM | RIGHT | TOP | LEFT;\n\t\/* Always use rankdir to determine how records are laid out *\/\n\tflip = NOT(GD_realflip(agraphof(n)));\n\tZ.z().reclblp = ND_label(n).text;\n    len = strlen(Z.z().reclblp);\n    \/* For some forgotten reason, an empty label is parsed into a space, so\n     * we need at least two bytes in textbuf.\n     *\/\n     len = MAX(len, 1);\n     textbuf = CString.gmalloc(len + 1);\n    if (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ \tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ \treclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ \tinfo = parse_reclbl(n, flip, NOT(0), textbuf);\n    }\n    Memory.free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));;\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ \tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ \t\t\tagerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ \t}\n    } else {\n\tsz.x = MAX(info.size.x, sz.x);\n\tsz.y = MAX(info.size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\n    ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.));\t\/* FIXME - is this still true:    suspected to introduce ronding error - see Kluge below *\/\n    pos_reclbl(info, ul, sides);\n    ND_width(n, PS2INCH(info.size.x));\n    ND_height(n, PS2INCH(info.size.y + 1));\t\/* Kluge!!  +1 to fix rounding diff between layout and rendering \n\t\t\t\t\t\t   otherwise we can get -1 coords in output *\/\n    ND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","code":"@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\n\tST_field_t info;\n\tfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\n    boolean flip;\n    int len;\n    CString textbuf;\t\n\tint sides = BOTTOM | RIGHT | TOP | LEFT;\n\n\tflip = NOT(GD_realflip(agraphof(n)));\n\tZ.z().reclblp = ND_label(n).text;\n    len = strlen(Z.z().reclblp);\n   \n     len = MAX(len, 1);\n     textbuf = CString.gmalloc(len + 1);\n    if (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\");\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\");\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\");\n    }\n    Memory.free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));;\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\");\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\");\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\");\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\");\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\");\n    } else {\n\tsz.x = MAX(info.size.x, sz.x);\n\tsz.y = MAX(info.size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\n    ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.));\n    pos_reclbl(info, ul, sides);\n    ND_width(n, PS2INCH(info.size.x));\n    ND_height(n, PS2INCH(info.size.y + 1));\n    ND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","cleancode":"@unused @doc(\"init 'record' node\") @reviewed(when = \"02\/12\/2020\") @original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\") public static void record_init(st_agnode_s n) { entering(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\"); try { st_field_t info; final st_pointf ul = new st_pointf(), sz = new st_pointf(); boolean flip; int len; cstring textbuf; int sides = bottom | right | top | left; flip = not(gd_realflip(agraphof(n))); z.z().reclblp = nd_label(n).text; len = strlen(z.z().reclblp); len = max(len, 1); textbuf = cstring.gmalloc(len + 1); if (n(info = parse_reclbl(n, flip, not(0), textbuf))) { unsupported(\"7iezaksu9hyxhmv3r4cp4o529\"); unsupported(\"8f1id7rqm71svssnxbjo0uwcu\"); unsupported(\"2wv3zfqhq53941rwk4vu9p9th\"); } memory.free(textbuf); size_reclbl(n, info); sz.x = points(nd_width(n));; sz.y = points(nd_height(n)); if (mapbool(late_string(n, z.z().n_fixed, new cstring(\"false\")))) { unsupported(\"8iu51xbtntpdf5sc00g91djym\"); unsupported(\"4vs5u30jzsrn6fpjd327xjf7r\"); unsupported(\"7k6yytek9nu1ihxix2880667g\"); unsupported(\"bnetqzovnscxile7ao44kc0qd\"); unsupported(\"flupwh3kosf3fkhkxllllt1\"); } else { sz.x = max(info.size.x, sz.x); sz.y = max(info.size.y, sz.y); } resize_reclbl(info, sz, mapbool(late_string(n, z.z().n_nojustify, new cstring(\"false\")))); ul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); pos_reclbl(info, ul, sides); nd_width(n, ps2inch(info.size.x)); nd_height(n, ps2inch(info.size.y + 1)); nd_shape_info(n, info); } finally { leaving(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\"); } }","comment":"\/* temp buffer for storing labels *\/\n\/* always use rankdir to determine how records are laid out *\/\n\/* for some forgotten reason, an empty label is parsed into a space, so * we need at least two bytes in textbuf. *\/\n\/\/ agerr(agerr, \"bad label format %s\\n\", nd_label(n)->text);\n\/\/ reclblp = \"\\\\n\";\n\/\/ info = parse_reclbl(n, flip, not(0), textbuf);\n\/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\/\/ \/* should check that the record really won't fit, e.g., there may be no text.\n\/\/ agerr(agwarn, \"node '%s' size may be too small\\n\", agnameof(n));\n\/\/ *\/\n\/\/ }\n\/* fixme - is this still true: suspected to introduce ronding error - see kluge below *\/\n\/* kluge!! +1 to fix rounding diff between layout and rendering otherwise we can get -1 coords in output *\/","repo":"SandraBSofiaH\/Final-UMldoclet","code_context_2":"boolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\n\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\n\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\n\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\n\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\n\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\n\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\n\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\n\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\n\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\n\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {","code_context_10":"@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\n\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\n\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\n\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\n\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\n\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\n\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\n\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\n\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\n\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\n\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","code_context_20":"@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\n\n@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\n\n@Unused\n@Doc(\"Init 'record' node\")\n@Reviewed(when = \"02\/12\/2020\")\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n\n@Original(version=\"2.38.0\", path=\"lib\/common\/shapes.c\", name=\"record_init\", key=\"h2lcuthzwljbcjwdeidw1jiv\", definition=\"static void record_init(node_t * n)\")\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\n\npublic static void record_init(ST_Agnode_s n) {\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\n\nENTERING(\"h2lcuthzwljbcjwdeidw1jiv\",\"record_init\");\ntry {\nST_field_t info;\nfinal ST_pointf ul = new ST_pointf(), sz = new ST_pointf();\nboolean flip;\nint len;\nCString textbuf; \/* temp buffer for storing labels *\/\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\n\nint sides = BOTTOM | RIGHT | TOP | LEFT;\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\n\/* Always use rankdir to determine how records are laid out *\/\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nflip = NOT(GD_realflip(agraphof(n)));\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nZ.z().reclblp = ND_label(n).text;\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nlen = strlen(Z.z().reclblp);\n\/* For some forgotten reason, an empty label is parsed into a space, so\n* we need at least two bytes in textbuf.\n*\/\nlen = MAX(len, 1);\ntextbuf = CString.gmalloc(len + 1);\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nif (N(info = parse_reclbl(n, flip, NOT(0), textbuf))) {\nUNSUPPORTED(\"7iezaksu9hyxhmv3r4cp4o529\"); \/\/ agerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\nUNSUPPORTED(\"8f1id7rqm71svssnxbjo0uwcu\"); \/\/ reclblp = \"\\\\N\";\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}\n\nUNSUPPORTED(\"2wv3zfqhq53941rwk4vu9p9th\"); \/\/ info = parse_reclbl(n, flip, NOT(0), textbuf);\n}\nMemory.free(textbuf);\nsize_reclbl(n, info);\nsz.x = POINTS(ND_width(n));;\nsz.y = POINTS(ND_height(n));\nif (mapbool(late_string(n, Z.z().N_fixed, new CString(\"false\")))) {\nUNSUPPORTED(\"8iu51xbtntpdf5sc00g91djym\"); \/\/ if ((sz.x < info->size.x) || (sz.y < info->size.y)) {\nUNSUPPORTED(\"4vs5u30jzsrn6fpjd327xjf7r\"); \/\/ \/* should check that the record really won't fit, e.g., there may be no text.\nUNSUPPORTED(\"7k6yytek9nu1ihxix2880667g\"); \/\/ agerr(AGWARN, \"node '%s' size may be too small\\n\", agnameof(n));\nUNSUPPORTED(\"bnetqzovnscxile7ao44kc0qd\"); \/\/ *\/\nUNSUPPORTED(\"flupwh3kosf3fkhkxllllt1\"); \/\/ }\n} else {\nsz.x = MAX(info.size.x, sz.x);\nsz.y = MAX(info.size.y, sz.y);\n}\nresize_reclbl(info, sz, mapbool(late_string(n, Z.z().N_nojustify, new CString(\"false\"))));\nul.___(pointfof(-sz.x \/ 2., sz.y \/ 2.)); \/* FIXME - is this still true: suspected to introduce ronding error - see Kluge below *\/\npos_reclbl(info, ul, sides);\nND_width(n, PS2INCH(info.size.x));\nND_height(n, PS2INCH(info.size.y + 1)); \/* Kluge!! +1 to fix rounding diff between layout and rendering\notherwise we can get -1 coords in output *\/\nND_shape_info(n, info);\n} finally {\nLEAVING(\"h2lcuthzwljbcjwdeidw1jiv\",\"poly_init\");\n}\n}","label":[1,1,1,0]}
{"id":19017,"original_code":"private Table buildHeader() {\n        Skin skin = getSkin();\n        SquareButton ffBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        ffBack.flipHorizontal();\n        playBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        playBack.flipHorizontal();\n        play = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        SquareButton ffForward = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        repeatBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-repeat\"), true);\n        newBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-new\"));\n        newBtn.getIconCell().padTop(2).padLeft(1);\n        SquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\n        upBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        upBtn.flipVertical();\n        downBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        downBtn.flipVertical(); downBtn.flipHorizontal();\n        Table header = new Table();\n        header.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\n        Table topPart = new Table();\n        Table bottomPart = new Table();\n        topPart.add(ffBack).padLeft(6).left();\n        \/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\n        topPart.add(play).padLeft(6).left();\n        topPart.add(ffForward).padLeft(6).left();\n        topPart.add(repeatBtn).padLeft(6).left();\n        topPart.add().growX().minWidth(20);\n        topPart.add(upBtn).padRight(6).right();\n        topPart.add(downBtn).padRight(10).right();\n        topPart.add(newBtn).right().padRight(6);\n        topPart.add(deleteBtn).right().padRight(6);\n        topActionCell = topPart.add().right();\n        typeLabel = new Label(\"Items\", skin);\n        typeLabel.setColor(ColorLibrary.FONT_GRAY);\n        bottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\n        header.add(topPart).height(33).padBottom(1).growX().row();\n        header.add(bottomPart).height(16).growX().row();\n        \/**\n         * Build header actions\n         *\/\n        ffBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n            }\n        });\n        ffForward.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);\n            }\n        });\n        playBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.rewind);\n            }\n        });\n        play.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.play);\n            }\n        });\n        repeatBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.toggleLoop);\n            }\n        });\n        deleteBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.deleteSelection);\n            }\n        });\n        newBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.newItem);\n            }\n        });\n        upBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.up);\n            }\n        });\n        downBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.down);\n            }\n        });\n        return header;\n    }","code":"private Table buildHeader() {\n        Skin skin = getSkin();\n        SquareButton ffBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        ffBack.flipHorizontal();\n        playBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        playBack.flipHorizontal();\n        play = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\n        SquareButton ffForward = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\n        repeatBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-repeat\"), true);\n        newBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-new\"));\n        newBtn.getIconCell().padTop(2).padLeft(1);\n        SquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\n        upBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        upBtn.flipVertical();\n        downBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\n        downBtn.flipVertical(); downBtn.flipHorizontal();\n        Table header = new Table();\n        header.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\n        Table topPart = new Table();\n        Table bottomPart = new Table();\n        topPart.add(ffBack).padLeft(6).left();\n       \n        topPart.add(play).padLeft(6).left();\n        topPart.add(ffForward).padLeft(6).left();\n        topPart.add(repeatBtn).padLeft(6).left();\n        topPart.add().growX().minWidth(20);\n        topPart.add(upBtn).padRight(6).right();\n        topPart.add(downBtn).padRight(10).right();\n        topPart.add(newBtn).right().padRight(6);\n        topPart.add(deleteBtn).right().padRight(6);\n        topActionCell = topPart.add().right();\n        typeLabel = new Label(\"Items\", skin);\n        typeLabel.setColor(ColorLibrary.FONT_GRAY);\n        bottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\n        header.add(topPart).height(33).padBottom(1).growX().row();\n        header.add(bottomPart).height(16).growX().row();\n       \n        ffBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n            }\n        });\n        ffForward.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);\n            }\n        });\n        playBack.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.rewind);\n            }\n        });\n        play.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.play);\n            }\n        });\n        repeatBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.toggleLoop);\n            }\n        });\n        deleteBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.deleteSelection);\n            }\n        });\n        newBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.newItem);\n            }\n        });\n        upBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.up);\n            }\n        });\n        downBtn.addListener(new ClickListener() {\n            @Override\n            public void clicked(InputEvent event, float x, float y) {\n                timeline.onActionButtonClicked(TimelineListener.Type.down);\n            }\n        });\n        return header;\n    }","cleancode":"private table buildheader() { skin skin = getskin(); squarebutton ffback = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-ff\")); ffback.fliphorizontal(); playback = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\"), true); playback.fliphorizontal(); play = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\"), true); squarebutton ffforward = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-ff\")); repeatbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-repeat\"), true); newbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-new\")); newbtn.geticoncell().padtop(2).padleft(1); squarebutton deletebtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-delete\")); upbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\")); upbtn.flipvertical(); downbtn = new squarebutton(skin, skin.getdrawable(\"timeline-btn-icon-play\")); downbtn.flipvertical(); downbtn.fliphorizontal(); table header = new table(); header.setbackground(skin.getdrawable(\"timeline-top-bar-bg\")); table toppart = new table(); table bottompart = new table(); toppart.add(ffback).padleft(6).left(); toppart.add(play).padleft(6).left(); toppart.add(ffforward).padleft(6).left(); toppart.add(repeatbtn).padleft(6).left(); toppart.add().growx().minwidth(20); toppart.add(upbtn).padright(6).right(); toppart.add(downbtn).padright(10).right(); toppart.add(newbtn).right().padright(6); toppart.add(deletebtn).right().padright(6); topactioncell = toppart.add().right(); typelabel = new label(\"items\", skin); typelabel.setcolor(colorlibrary.font_gray); bottompart.add(typelabel).padbottom(2).padleft(5).left().expandx(); header.add(toppart).height(33).padbottom(1).growx().row(); header.add(bottompart).height(16).growx().row(); ffback.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.skiptostart); } }); ffforward.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.skiptoend); } }); playback.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.rewind); } }); play.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.play); } }); repeatbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.toggleloop); } }); deletebtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.deleteselection); } }); newbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.newitem); } }); upbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.up); } }); downbtn.addlistener(new clicklistener() { @override public void clicked(inputevent event, float x, float y) { timeline.onactionbuttonclicked(timelinelistener.type.down); } }); return header; }","comment":"\/\/toppart.add(playback).padleft(6).left(); \/\/ todo: add this back when we can support\n\/** * build header actions *\/","repo":"TheSenPie\/talos","code_context_2":"Table bottomPart = new Table();\ntopPart.add(ffBack).padLeft(6).left();\n\/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\ntopPart.add(play).padLeft(6).left();\ntopPart.add(ffForward).padLeft(6).left();\n\nheader.add(topPart).height(33).padBottom(1).growX().row();\nheader.add(bottomPart).height(16).growX().row();\n\/**\n* Build header actions\n*\/\nffBack.addListener(new ClickListener() {\n@Override","code_context_10":"SquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\nupBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\nupBtn.flipVertical();\ndownBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\ndownBtn.flipVertical(); downBtn.flipHorizontal();\nTable header = new Table();\nheader.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\nTable topPart = new Table();\nTable bottomPart = new Table();\ntopPart.add(ffBack).padLeft(6).left();\n\/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\ntopPart.add(play).padLeft(6).left();\ntopPart.add(ffForward).padLeft(6).left();\ntopPart.add(repeatBtn).padLeft(6).left();\ntopPart.add().growX().minWidth(20);\ntopPart.add(upBtn).padRight(6).right();\ntopPart.add(downBtn).padRight(10).right();\ntopPart.add(newBtn).right().padRight(6);\ntopPart.add(deleteBtn).right().padRight(6);\ntopActionCell = topPart.add().right();\ntypeLabel = new Label(\"Items\", skin);\n\ntopPart.add(upBtn).padRight(6).right();\ntopPart.add(downBtn).padRight(10).right();\ntopPart.add(newBtn).right().padRight(6);\ntopPart.add(deleteBtn).right().padRight(6);\ntopActionCell = topPart.add().right();\ntypeLabel = new Label(\"Items\", skin);\ntypeLabel.setColor(ColorLibrary.FONT_GRAY);\nbottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\nheader.add(topPart).height(33).padBottom(1).growX().row();\nheader.add(bottomPart).height(16).growX().row();\n\/**\n* Build header actions\n*\/\nffBack.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\ntimeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n}\n});\nffForward.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\ntimeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);","code_context_20":"Skin skin = getSkin();\nSquareButton ffBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\nffBack.flipHorizontal();\nplayBack = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\nplayBack.flipHorizontal();\nplay = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"), true);\nSquareButton ffForward = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-ff\"));\nrepeatBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-repeat\"), true);\nnewBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-new\"));\nnewBtn.getIconCell().padTop(2).padLeft(1);\nSquareButton deleteBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-delete\"));\nupBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\nupBtn.flipVertical();\ndownBtn = new SquareButton(skin, skin.getDrawable(\"timeline-btn-icon-play\"));\ndownBtn.flipVertical(); downBtn.flipHorizontal();\nTable header = new Table();\nheader.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\nTable topPart = new Table();\nTable bottomPart = new Table();\ntopPart.add(ffBack).padLeft(6).left();\n\/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\ntopPart.add(play).padLeft(6).left();\ntopPart.add(ffForward).padLeft(6).left();\ntopPart.add(repeatBtn).padLeft(6).left();\ntopPart.add().growX().minWidth(20);\ntopPart.add(upBtn).padRight(6).right();\ntopPart.add(downBtn).padRight(10).right();\ntopPart.add(newBtn).right().padRight(6);\ntopPart.add(deleteBtn).right().padRight(6);\ntopActionCell = topPart.add().right();\ntypeLabel = new Label(\"Items\", skin);\ntypeLabel.setColor(ColorLibrary.FONT_GRAY);\nbottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\nheader.add(topPart).height(33).padBottom(1).growX().row();\nheader.add(bottomPart).height(16).growX().row();\n\/**\n* Build header actions\n*\/\nffBack.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\n\nTable header = new Table();\nheader.setBackground(skin.getDrawable(\"timeline-top-bar-bg\"));\nTable topPart = new Table();\nTable bottomPart = new Table();\ntopPart.add(ffBack).padLeft(6).left();\n\/\/topPart.add(playBack).padLeft(6).left(); \/\/ TODO: add this back when we can support\ntopPart.add(play).padLeft(6).left();\ntopPart.add(ffForward).padLeft(6).left();\ntopPart.add(repeatBtn).padLeft(6).left();\ntopPart.add().growX().minWidth(20);\ntopPart.add(upBtn).padRight(6).right();\ntopPart.add(downBtn).padRight(10).right();\ntopPart.add(newBtn).right().padRight(6);\ntopPart.add(deleteBtn).right().padRight(6);\ntopActionCell = topPart.add().right();\ntypeLabel = new Label(\"Items\", skin);\ntypeLabel.setColor(ColorLibrary.FONT_GRAY);\nbottomPart.add(typeLabel).padBottom(2).padLeft(5).left().expandX();\nheader.add(topPart).height(33).padBottom(1).growX().row();\nheader.add(bottomPart).height(16).growX().row();\n\/**\n* Build header actions\n*\/\nffBack.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\ntimeline.onActionButtonClicked(TimelineListener.Type.skipToStart);\n}\n});\nffForward.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\ntimeline.onActionButtonClicked(TimelineListener.Type.skipToEnd);\n}\n});\nplayBack.addListener(new ClickListener() {\n@Override\npublic void clicked(InputEvent event, float x, float y) {\ntimeline.onActionButtonClicked(TimelineListener.Type.rewind);\n}\n});\nplay.addListener(new ClickListener() {\n@Override","label":[0,1,0,0]}
{"id":10974,"original_code":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    BufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\n    INDArray image = loader.asMatrix(buffImg);\n    \/\/ TODO: we should consider the model as not only the model, but also the\n    \/\/ input transforms\n    \/\/ for that model.\n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    log.info(\"Complete with output from vgg16..\");\n    \/\/ TODO: return a more native datastructure!\n    \/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n    \/\/ log.info(\"Image Predictions: {}\", predictions);\n    return decodeVGG16Predictions(output[0]);\n  }","code":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    BufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\n    INDArray image = loader.asMatrix(buffImg);\n   \n   \n   \n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    log.info(\"Complete with output from vgg16..\");\n   \n   \n   \n    return decodeVGG16Predictions(output[0]);\n  }","cleancode":"public map<string, double> classifyimagevgg16(iplimage iplimage) throws ioexception { nativeimageloader loader = new nativeimageloader(224, 224, 3); bufferedimage buffimg = opencv.tobufferedimage(iplimage); indarray image = loader.asmatrix(buffimg); datanormalization scaler = new vgg16imagepreprocessor(); scaler.transform(image); indarray[] output = vgg16.output(false, image); log.info(\"complete with output from vgg16..\"); return decodevgg16predictions(output[0]); }","comment":"\/\/ todo: we should consider the model as not only the model, but also the \/\/ input transforms \/\/ for that model.\n\/\/ todo: return a more native datastructure! \/\/ string predictions = trainedmodels.vgg16.decodepredictions(output[0]); \/\/ log.info(\"image predictions: {}\", predictions);","repo":"ShaunHolt\/myrobotlab","code_context_2":"BufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\nINDArray image = loader.asMatrix(buffImg);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\n\nINDArray[] output = vgg16.output(false, image);\nlog.info(\"Complete with output from vgg16..\");\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","code_context_10":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nBufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\nINDArray image = loader.asMatrix(buffImg);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\nlog.info(\"Complete with output from vgg16..\");\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}\n\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nBufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\nINDArray image = loader.asMatrix(buffImg);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\nlog.info(\"Complete with output from vgg16..\");\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","code_context_20":"public Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nBufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\nINDArray image = loader.asMatrix(buffImg);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\nlog.info(\"Complete with output from vgg16..\");\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}\n\npublic Map<String, Double> classifyImageVGG16(IplImage iplImage) throws IOException {\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nBufferedImage buffImg = OpenCV.toBufferedImage(iplImage);\nINDArray image = loader.asMatrix(buffImg);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\nlog.info(\"Complete with output from vgg16..\");\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","label":[1,0,0,0]}
{"id":10975,"original_code":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\n    File file = new File(filename);\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    INDArray image = loader.asMatrix(file);\n    \/\/ TODO: we should consider the model as not only the model, but also the\n    \/\/ input transforms\n    \/\/ for that model.\n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n    \/\/ TODO: return a more native datastructure!\n    \/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n    \/\/ log.info(\"Image Predictions: {}\", predictions);\n    return decodeVGG16Predictions(output[0]);\n  }","code":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\n    File file = new File(filename);\n    NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\n    INDArray image = loader.asMatrix(file);\n   \n   \n   \n    DataNormalization scaler = new VGG16ImagePreProcessor();\n    scaler.transform(image);\n    INDArray[] output = vgg16.output(false, image);\n   \n   \n   \n    return decodeVGG16Predictions(output[0]);\n  }","cleancode":"public map<string, double> classifyimagefilevgg16(string filename) throws ioexception { file file = new file(filename); nativeimageloader loader = new nativeimageloader(224, 224, 3); indarray image = loader.asmatrix(file); datanormalization scaler = new vgg16imagepreprocessor(); scaler.transform(image); indarray[] output = vgg16.output(false, image); return decodevgg16predictions(output[0]); }","comment":"\/\/ todo: we should consider the model as not only the model, but also the \/\/ input transforms \/\/ for that model.\n\/\/ todo: return a more native datastructure! \/\/ string predictions = trainedmodels.vgg16.decodepredictions(output[0]); \/\/ log.info(\"image predictions: {}\", predictions);","repo":"ShaunHolt\/myrobotlab","code_context_2":"NativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\n\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","code_context_10":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\nFile file = new File(filename);\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}\n\npublic Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\nFile file = new File(filename);\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","code_context_20":"public Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\nFile file = new File(filename);\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}\n\npublic Map<String, Double> classifyImageFileVGG16(String filename) throws IOException {\nFile file = new File(filename);\nNativeImageLoader loader = new NativeImageLoader(224, 224, 3);\nINDArray image = loader.asMatrix(file);\n\/\/ TODO: we should consider the model as not only the model, but also the\n\/\/ input transforms\n\/\/ for that model.\nDataNormalization scaler = new VGG16ImagePreProcessor();\nscaler.transform(image);\nINDArray[] output = vgg16.output(false, image);\n\/\/ TODO: return a more native datastructure!\n\/\/ String predictions = TrainedModels.VGG16.decodePredictions(output[0]);\n\/\/ log.info(\"Image Predictions: {}\", predictions);\nreturn decodeVGG16Predictions(output[0]);\n}","label":[1,0,0,0]}
{"id":10994,"original_code":"private long getReservedCacheSize(String uuid) {\n        \/\/ TODO: Revisit the cache size after running more storage tests.\n        \/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n        \/\/       StorageStatsManager, because this is ignoring the cache...\n        StorageManager storageManager = getSystemService(StorageManager.class);\n        long freeBytes = 0;\n        if (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\n            freeBytes = Environment.getDataDirectory().getUsableSpace();\n        } else {\n            final VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\n            freeBytes = vol.getPath().getUsableSpace();\n        }\n        return Math.round(freeBytes * CACHE_RESERVE_RATIO);\n    }","code":"private long getReservedCacheSize(String uuid) {\n       \n       \n       \n        StorageManager storageManager = getSystemService(StorageManager.class);\n        long freeBytes = 0;\n        if (uuid == StorageManager.UUID_PRIVATE_INTERNAL) {\n            freeBytes = Environment.getDataDirectory().getUsableSpace();\n        } else {\n            final VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\n            freeBytes = vol.getPath().getUsableSpace();\n        }\n        return Math.round(freeBytes * CACHE_RESERVE_RATIO);\n    }","cleancode":"private long getreservedcachesize(string uuid) { storagemanager storagemanager = getsystemservice(storagemanager.class); long freebytes = 0; if (uuid == storagemanager.uuid_private_internal) { freebytes = environment.getdatadirectory().getusablespace(); } else { final volumeinfo vol = storagemanager.findvolumebyuuid(uuid); freebytes = vol.getpath().getusablespace(); } return math.round(freebytes * cache_reserve_ratio); }","comment":"\/\/ todo: revisit the cache size after running more storage tests. \/\/ todo: figure out how to ensure extservices has the permissions to call \/\/ storagestatsmanager, because this is ignoring the cache...\n\/\/ regular equals because of null","repo":"Y-D-Lu\/rr_frameworks_base","code_context_2":"private long getReservedCacheSize(String uuid) {\n\/\/ TODO: Revisit the cache size after running more storage tests.\n\/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n\/\/ StorageStatsManager, because this is ignoring the cache...\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\n\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\nif (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\nfreeBytes = Environment.getDataDirectory().getUsableSpace();\n} else {","code_context_10":"private long getReservedCacheSize(String uuid) {\n\/\/ TODO: Revisit the cache size after running more storage tests.\n\/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n\/\/ StorageStatsManager, because this is ignoring the cache...\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\nif (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\nfreeBytes = Environment.getDataDirectory().getUsableSpace();\n} else {\nfinal VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\nfreeBytes = vol.getPath().getUsableSpace();\n}\nreturn Math.round(freeBytes * CACHE_RESERVE_RATIO);\n}\n\nprivate long getReservedCacheSize(String uuid) {\n\/\/ TODO: Revisit the cache size after running more storage tests.\n\/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n\/\/ StorageStatsManager, because this is ignoring the cache...\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\nif (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\nfreeBytes = Environment.getDataDirectory().getUsableSpace();\n} else {\nfinal VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\nfreeBytes = vol.getPath().getUsableSpace();\n}\nreturn Math.round(freeBytes * CACHE_RESERVE_RATIO);\n}","code_context_20":"private long getReservedCacheSize(String uuid) {\n\/\/ TODO: Revisit the cache size after running more storage tests.\n\/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n\/\/ StorageStatsManager, because this is ignoring the cache...\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\nif (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\nfreeBytes = Environment.getDataDirectory().getUsableSpace();\n} else {\nfinal VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\nfreeBytes = vol.getPath().getUsableSpace();\n}\nreturn Math.round(freeBytes * CACHE_RESERVE_RATIO);\n}\n\nprivate long getReservedCacheSize(String uuid) {\n\/\/ TODO: Revisit the cache size after running more storage tests.\n\/\/ TODO: Figure out how to ensure ExtServices has the permissions to call\n\/\/ StorageStatsManager, because this is ignoring the cache...\nStorageManager storageManager = getSystemService(StorageManager.class);\nlong freeBytes = 0;\nif (uuid == StorageManager.UUID_PRIVATE_INTERNAL) { \/\/ regular equals because of null\nfreeBytes = Environment.getDataDirectory().getUsableSpace();\n} else {\nfinal VolumeInfo vol = storageManager.findVolumeByUuid(uuid);\nfreeBytes = vol.getPath().getUsableSpace();\n}\nreturn Math.round(freeBytes * CACHE_RESERVE_RATIO);\n}","label":[1,0,0,0]}
{"id":11115,"original_code":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\n                                                    String body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\n        List<String> toList = toEmails;\n        List<String> ccList = ccEmails;\n        if (toEmails.size() <= 0) {\n            if (ccEmails.size() <= 0) {\n                \/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n                \/\/ a draft email with the subject (and no recipients).\n                throw new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n            }\n            \/\/ Email app does not work with no \"to\" recipient.  Move all 'cc' to 'to'\n            \/\/ in this case.\n            toList = ccEmails;\n            ccList = null;\n        }\n        \/\/ Use the event title as the email subject (prepended with 'Re: ').\n        String subject = null;\n        if (eventTitle != null) {\n            subject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n        }\n        \/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n        \/\/ the picker to show apps like text messaging, which does not make sense\n        \/\/ for email addresses.  We put all data in the URI instead of using the extra\n        \/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n        \/\/ those (though gmail does).\n        Uri.Builder uriBuilder = new Uri.Builder();\n        uriBuilder.scheme(\"mailto\");\n        \/\/ We will append the first email to the 'mailto' field later (because the\n        \/\/ current state of the Email app requires it).  Add the remaining 'to' values\n        \/\/ here.  When the email codebase is updated, we can simplify this.\n        if (toList.size() > 1) {\n            for (int i = 1; i < toList.size(); i++) {\n                \/\/ The Email app requires repeated parameter settings instead of\n                \/\/ a single comma-separated list.\n                uriBuilder.appendQueryParameter(\"to\", toList.get(i));\n            }\n        }\n        \/\/ Add the subject parameter.\n        if (subject != null) {\n            uriBuilder.appendQueryParameter(\"subject\", subject);\n        }\n        \/\/ Add the subject parameter.\n        if (body != null) {\n            uriBuilder.appendQueryParameter(\"body\", body);\n        }\n        \/\/ Add the cc parameters.\n        if (ccList != null && ccList.size() > 0) {\n            for (String email : ccList) {\n                uriBuilder.appendQueryParameter(\"cc\", email);\n            }\n        }\n        \/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n        \/\/ doesn't seem to have a way to do this.\n        String uri = uriBuilder.toString();\n        if (uri.startsWith(\"mailto:\")) {\n            StringBuilder builder = new StringBuilder(uri);\n            builder.insert(7, Uri.encode(toList.get(0)));\n            uri = builder.toString();\n        }\n        \/\/ Start the email intent.  Email from the account of the calendar owner in case there\n        \/\/ are multiple email accounts.\n        Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\n        emailIntent.putExtra(\"fromAccountString\", ownerAccount);\n        \/\/ Workaround a Email bug that overwrites the body with this intent extra.  If not\n        \/\/ set, it clears the body.\n        if (body != null) {\n            emailIntent.putExtra(Intent.EXTRA_TEXT, body);\n        }\n        return Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n    }","code":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\n                                                    String body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\n        List<String> toList = toEmails;\n        List<String> ccList = ccEmails;\n        if (toEmails.size() <= 0) {\n            if (ccEmails.size() <= 0) {\n               \n               \n                throw new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n            }\n           \n           \n            toList = ccEmails;\n            ccList = null;\n        }\n       \n        String subject = null;\n        if (eventTitle != null) {\n            subject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n        }\n       \n       \n       \n       \n       \n        Uri.Builder uriBuilder = new Uri.Builder();\n        uriBuilder.scheme(\"mailto\");\n       \n       \n       \n        if (toList.size() > 1) {\n            for (int i = 1; i < toList.size(); i++) {\n               \n               \n                uriBuilder.appendQueryParameter(\"to\", toList.get(i));\n            }\n        }\n       \n        if (subject != null) {\n            uriBuilder.appendQueryParameter(\"subject\", subject);\n        }\n       \n        if (body != null) {\n            uriBuilder.appendQueryParameter(\"body\", body);\n        }\n       \n        if (ccList != null && ccList.size() > 0) {\n            for (String email : ccList) {\n                uriBuilder.appendQueryParameter(\"cc\", email);\n            }\n        }\n       \n       \n        String uri = uriBuilder.toString();\n        if (uri.startsWith(\"mailto:\")) {\n            StringBuilder builder = new StringBuilder(uri);\n            builder.insert(7, Uri.encode(toList.get(0)));\n            uri = builder.toString();\n        }\n       \n       \n        Intent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\n        emailIntent.putExtra(\"fromAccountString\", ownerAccount);\n       \n       \n        if (body != null) {\n            emailIntent.putExtra(Intent.EXTRA_TEXT, body);\n        }\n        return Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n    }","cleancode":"public static intent createemailattendeesintent(resources resources, string eventtitle, string body, list<string> toemails, list<string> ccemails, string owneraccount) { list<string> tolist = toemails; list<string> cclist = ccemails; if (toemails.size() <= 0) { if (ccemails.size() <= 0) { throw new illegalargumentexception(\"both toemails and ccemails are empty.\"); } tolist = ccemails; cclist = null; } string subject = null; if (eventtitle != null) { subject = resources.getstring(r.string.email_subject_prefix) + eventtitle; } uri.builder uribuilder = new uri.builder(); uribuilder.scheme(\"mailto\"); if (tolist.size() > 1) { for (int i = 1; i < tolist.size(); i++) { uribuilder.appendqueryparameter(\"to\", tolist.get(i)); } } if (subject != null) { uribuilder.appendqueryparameter(\"subject\", subject); } if (body != null) { uribuilder.appendqueryparameter(\"body\", body); } if (cclist != null && cclist.size() > 0) { for (string email : cclist) { uribuilder.appendqueryparameter(\"cc\", email); } } string uri = uribuilder.tostring(); if (uri.startswith(\"mailto:\")) { stringbuilder builder = new stringbuilder(uri); builder.insert(7, uri.encode(tolist.get(0))); uri = builder.tostring(); } intent emailintent = new intent(intent.action_sendto, uri.parse(uri)); emailintent.putextra(\"fromaccountstring\", owneraccount); if (body != null) { emailintent.putextra(intent.extra_text, body); } return intent.createchooser(emailintent, resources.getstring(r.string.email_picker_label)); }","comment":"\/** * create an intent for emailing attendees of an event. * * @param resources the resources for translating strings. * @param eventtitle the title of the event to use as the email subject. * @param body the default text for the email body. * @param toemails the list of emails for the 'to' line. * @param ccemails the list of emails for the 'cc' line. * @param owneraccount the owner account to use as the email sender. *\/\n\/\/ todo: return a send intent if no one to email to, to at least populate \/\/ a draft email with the subject (and no recipients).\n\/\/ email app does not work with no \"to\" recipient. move all 'cc' to 'to' \/\/ in this case.\n\/\/ use the event title as the email subject (prepended with 're: ').\n\/\/ use the sendto intent with a 'mailto' uri, because using send will cause \/\/ the picker to show apps like text messaging, which does not make sense \/\/ for email addresses. we put all data in the uri instead of using the extra \/\/ intent fields (ie. extra_cc, etc) because some email apps might not handle \/\/ those (though gmail does).\n\/\/ we will append the first email to the 'mailto' field later (because the \/\/ current state of the email app requires it). add the remaining 'to' values \/\/ here. when the email codebase is updated, we can simplify this.\n\/\/ the email app requires repeated parameter settings instead of \/\/ a single comma-separated list.\n\/\/ add the subject parameter.\n\/\/ add the subject parameter.\n\/\/ add the cc parameters.\n\/\/ insert the first email after 'mailto:' in the uri manually since uri.builder \/\/ doesn't seem to have a way to do this.\n\/\/ start the email intent. email from the account of the calendar owner in case there \/\/ are multiple email accounts.\n\/\/ workaround a email bug that overwrites the body with this intent extra. if not \/\/ set, it clears the body.","repo":"Shusshu\/Android-RecurrencePicker","code_context_2":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\n\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\n\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\n\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);","code_context_10":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\n\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\n\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\n\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\n\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}","code_context_20":"public static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n\npublic static Intent createEmailAttendeesIntent(Resources resources, String eventTitle,\nString body, List<String> toEmails, List<String> ccEmails, String ownerAccount) {\nList<String> toList = toEmails;\nList<String> ccList = ccEmails;\nif (toEmails.size() <= 0) {\nif (ccEmails.size() <= 0) {\n\/\/ TODO: Return a SEND intent if no one to email to, to at least populate\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\n\/\/ a draft email with the subject (and no recipients).\nthrow new IllegalArgumentException(\"Both toEmails and ccEmails are empty.\");\n}\n\/\/ Email app does not work with no \"to\" recipient. Move all 'cc' to 'to'\n\/\/ in this case.\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n\ntoList = ccEmails;\nccList = null;\n}\n\/\/ Use the event title as the email subject (prepended with 'Re: ').\nString subject = null;\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\n\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n\nif (eventTitle != null) {\nsubject = resources.getString(R.string.email_subject_prefix) + eventTitle;\n}\n\/\/ Use the SENDTO intent with a 'mailto' URI, because using SEND will cause\n\/\/ the picker to show apps like text messaging, which does not make sense\n\/\/ for email addresses. We put all data in the URI instead of using the extra\n\/\/ Intent fields (ie. EXTRA_CC, etc) because some email apps might not handle\n\/\/ those (though gmail does).\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n\nUri.Builder uriBuilder = new Uri.Builder();\nuriBuilder.scheme(\"mailto\");\n\/\/ We will append the first email to the 'mailto' field later (because the\n\/\/ current state of the Email app requires it). Add the remaining 'to' values\n\/\/ here. When the email codebase is updated, we can simplify this.\nif (toList.size() > 1) {\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\n\nfor (int i = 1; i < toList.size(); i++) {\n\/\/ The Email app requires repeated parameter settings instead of\n\/\/ a single comma-separated list.\nuriBuilder.appendQueryParameter(\"to\", toList.get(i));\n}\n}\n\/\/ Add the subject parameter.\nif (subject != null) {\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\nuriBuilder.appendQueryParameter(\"subject\", subject);\n}\n\/\/ Add the subject parameter.\nif (body != null) {\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}\n\nuriBuilder.appendQueryParameter(\"body\", body);\n}\n\/\/ Add the cc parameters.\nif (ccList != null && ccList.size() > 0) {\nfor (String email : ccList) {\nuriBuilder.appendQueryParameter(\"cc\", email);\n}\n}\n\/\/ Insert the first email after 'mailto:' in the URI manually since Uri.Builder\n\/\/ doesn't seem to have a way to do this.\nString uri = uriBuilder.toString();\nif (uri.startsWith(\"mailto:\")) {\nStringBuilder builder = new StringBuilder(uri);\nbuilder.insert(7, Uri.encode(toList.get(0)));\nuri = builder.toString();\n}\n\/\/ Start the email intent. Email from the account of the calendar owner in case there\n\/\/ are multiple email accounts.\nIntent emailIntent = new Intent(Intent.ACTION_SENDTO, Uri.parse(uri));\nemailIntent.putExtra(\"fromAccountString\", ownerAccount);\n\/\/ Workaround a Email bug that overwrites the body with this intent extra. If not\n\/\/ set, it clears the body.\nif (body != null) {\nemailIntent.putExtra(Intent.EXTRA_TEXT, body);\n}\nreturn Intent.createChooser(emailIntent, resources.getString(R.string.email_picker_label));\n}","label":[0,1,1,0]}
{"id":11181,"original_code":"@NotNull\n    public abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","code":"@NotNull\n    public abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","cleancode":"@notnull public abstract biome getbiome(@notnull worldinfo worldinfo, int x, int y, int z);","comment":"\/** * return the biome which should be present at the provided location. * <p> * notes: * <p> * this method <b>must<\/b> be completely thread safe and able to handle * multiple concurrent callers. * <p> * this method should only return biomes which are present in the list * returned by {@link #getbiomes(worldinfo)} * <p> * this method should <b>never<\/b> return {@link biome#custom}. * * @param worldinfo the world info of the world the biome will be used for * @param x the x-coordinate from world origin * @param y the y-coordinate from world origin * @param z the z-coordinate from world origin * @return biome for the given location *\/","repo":"abcd1234-byte\/spigot2","code_context_2":"@NotNull\npublic abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","code_context_10":"@NotNull\npublic abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","code_context_20":"@NotNull\npublic abstract Biome getBiome(@NotNull WorldInfo worldInfo, int x, int y, int z);","label":[0,1,0,0]}
{"id":3159,"original_code":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\n    if (type.isArray())\n      return; \/\/ TODO: Array types not supported yet ...\n    if (dynamicFieldSuffix == null) {\n      dynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n      \/\/ treat strings with multiple terms as text only if using the default!\n      if (\"_s\".equals(dynamicFieldSuffix)) {\n        String str = (String)value;\n        if (str.indexOf(\" \") != -1)\n          dynamicFieldSuffix = \"_t\";\n      }\n    }\n    if (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\n      doc.addField(fieldName + dynamicFieldSuffix, value);\n  }","code":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\n    if (type.isArray())\n      return;\n    if (dynamicFieldSuffix == null) {\n      dynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n     \n      if (\"_s\".equals(dynamicFieldSuffix)) {\n        String str = (String)value;\n        if (str.indexOf(\" \") != -1)\n          dynamicFieldSuffix = \"_t\";\n      }\n    }\n    if (dynamicFieldSuffix != null)\n      doc.addField(fieldName + dynamicFieldSuffix, value);\n  }","cleancode":"private static void addfield(solrinputdocument doc, string fieldname, object value, class type, string dynamicfieldsuffix) { if (type.isarray()) return; if (dynamicfieldsuffix == null) { dynamicfieldsuffix = getdefaultdynamicfieldmapping(type); if (\"_s\".equals(dynamicfieldsuffix)) { string str = (string)value; if (str.indexof(\" \") != -1) dynamicfieldsuffix = \"_t\"; } } if (dynamicfieldsuffix != null) doc.addfield(fieldname + dynamicfieldsuffix, value); }","comment":"\/\/ todo: array types not supported yet ...\n\/\/ treat strings with multiple terms as text only if using the default!\n\/\/ don't auto-map if we don't have a type","repo":"Stratio\/spark-solr","code_context_2":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\n\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}","code_context_10":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\n\nprivate static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}\n\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}","code_context_20":"private static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}\n\nprivate static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}\n\nprivate static void addField(SolrInputDocument doc, String fieldName, Object value, Class type, String dynamicFieldSuffix) {\nif (type.isArray())\nreturn; \/\/ TODO: Array types not supported yet ...\nif (dynamicFieldSuffix == null) {\ndynamicFieldSuffix = getDefaultDynamicFieldMapping(type);\n\/\/ treat strings with multiple terms as text only if using the default!\nif (\"_s\".equals(dynamicFieldSuffix)) {\nString str = (String)value;\nif (str.indexOf(\" \") != -1)\ndynamicFieldSuffix = \"_t\";\n}\n}\nif (dynamicFieldSuffix != null) \/\/ don't auto-map if we don't have a type\ndoc.addField(fieldName + dynamicFieldSuffix, value);\n}","label":[1,0,0,0]}
{"id":11407,"original_code":"protected Path getRealPath2(TVFSAbstractPath path) {\n\t\tList<String> list = new ArrayList<>();\n\t\tfor (String s : path.path) {\n\t\t\tlist.add(s);\n\t\t}\n\t\tPath p;\n\t\tif (list.isEmpty()) {\n\t\t\t\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\n\t\t\tp = fileSystem.getRootPath();\n\t\t} else {\n\t\t\tString first = \"\";\n\t\t\tString others[] = null;\n\/\/\t\t\tif (list.size() >= 1) {\n\/\/\t\t\t\tfirst = list.get(0);\n\/\/\t\t\t}\n\/\/\t\t\tif (list.size() > 1) {\n\/\/\t\t\t\tothers = new String[list.size() - 1];\n\/\/\n\/\/\t\t\t\tfor (int i = 1; i < list.size(); i++) {\n\/\/\t\t\t\t\tothers[i - 1] = list.get(i);\n\/\/\t\t\t\t}\n\/\/\t\t\t}\n\t\t\t\/\/if (others == null) {\n\t\t\tp = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\t\t\t\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/\t\t\t} else {\n\/\/\t\t\t\tp = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/\t\t\t}\n\t\t}\n\t\treturn p;\n\t}","code":"protected Path getRealPath2(TVFSAbstractPath path) {\n\t\tList<String> list = new ArrayList<>();\n\t\tfor (String s : path.path) {\n\t\t\tlist.add(s);\n\t\t}\n\t\tPath p;\n\t\tif (list.isEmpty()) {\n\t\t\n\t\t\tp = fileSystem.getRootPath();\n\t\t} else {\n\t\t\tString first = \"\";\n\t\t\tString others[] = null;\n\t\t\n\t\t\tp = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\t\t\n\t\t}\n\t\treturn p;\n\t}","cleancode":"protected path getrealpath2(tvfsabstractpath path) { list<string> list = new arraylist<>(); for (string s : path.path) { list.add(s); } path p; if (list.isempty()) { p = filesystem.getrootpath(); } else { string first = \"\"; string others[] = null; p = filesystem.getrootpath().resolve(list.stream().collect(collectors.joining(filesystem.getseparator()))); } return p; }","comment":"\/\/ todo: voir comment le nommer. voir si le deplacer dans une autre classe\n\/\/p = virtualfs.gettvfilesystem().getpath(virtualfs.getname().getname());\n\/\/ if (list.size() >= 1) { \/\/ first = list.get(0); \/\/ } \/\/ if (list.size() > 1) { \/\/ others = new string[list.size() - 1]; \/\/ \/\/ for (int i = 1; i < list.size(); i++) { \/\/ others[i - 1] = list.get(i); \/\/ } \/\/ } \/\/if (others == null) {\n\/\/p = virtualfs.gettvfilesystem().getpath(virtualfs.getname().getname(),first); \/\/ } else { \/\/ p = virtualfs.gettvfilesystem().getpath(first, others); \/\/ }","repo":"abarhub\/tinyvfs","code_context_2":"protected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}\n\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\n\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;","code_context_10":"protected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}\n\nprotected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}\n\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}","code_context_20":"protected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}\n\nprotected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n\nprotected Path getRealPath2(TVFSAbstractPath path) {\nList<String> list = new ArrayList<>();\nfor (String s : path.path) {\nlist.add(s);\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}\n\n}\nPath p;\nif (list.isEmpty()) {\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName());\np = fileSystem.getRootPath();\n} else {\nString first = \"\";\nString others[] = null;\n\/\/ if (list.size() >= 1) {\n\/\/ first = list.get(0);\n\/\/ }\n\/\/ if (list.size() > 1) {\n\/\/ others = new String[list.size() - 1];\n\/\/\n\/\/ for (int i = 1; i < list.size(); i++) {\n\/\/ others[i - 1] = list.get(i);\n\/\/ }\n\/\/ }\n\/\/if (others == null) {\np = fileSystem.getRootPath().resolve(list.stream().collect(Collectors.joining(fileSystem.getSeparator())));\n\/\/p = virtualFS.getTvFileSystem().getPath(virtualFS.getName().getName(),first);\n\/\/ } else {\n\/\/ p = virtualFS.getTvFileSystem().getPath(first, others);\n\/\/ }\n}\nreturn p;\n}","label":[1,0,0,0]}
{"id":11482,"original_code":"@Override\n    public void populateGui()\n    {\n        \/\/ Filler\n        this.getFiller();\n        \/\/ Items\n        for (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n        {\n            \/\/ Args\n            Material material = entry.getKey();\n            int startAmount = entry.getValue();\n            double startValue = plugin.getCollectorManager().value(collector, material);\n            List<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\n            List<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n            \/\/ Add\n            this.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n            {\n                \/\/ Cancel\n                event.setCancelled(true);\n                \/\/ Args\n                Player player = (Player) event.getWhoClicked();\n                int amount = collector.getMaterialAmount(material);\n                double total = plugin.getCollectorManager().sell(collector, material);\n                \/\/ Check\n                if (total == 0.0d)\n                {\n                    \/\/ TODO: Make it so collectors don't pick up items which can't be sold\n                    return;\n                }\n                \/\/ Deposit & Inform\n                plugin.getMoneyManager().pay(player.getUniqueId(), total);\n                String message = plugin.getConfig().getString(\"messages.material-sold\");\n                if (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n                \/\/ Update\n                this.update();\n            }));\n        }\n        \/\/ Navigation\n        this.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\n        this.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n    }","code":"@Override\n    public void populateGui()\n    {\n       \n        this.getFiller();\n       \n        for (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n        {\n           \n            Material material = entry.getKey();\n            int startAmount = entry.getValue();\n            double startValue = plugin.getCollectorManager().value(collector, material);\n            List<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\n            List<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n           \n            this.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n            {\n               \n                event.setCancelled(true);\n               \n                Player player = (Player) event.getWhoClicked();\n                int amount = collector.getMaterialAmount(material);\n                double total = plugin.getCollectorManager().sell(collector, material);\n               \n                if (total == 0.0d)\n                {\n                   \n                    return;\n                }\n               \n                plugin.getMoneyManager().pay(player.getUniqueId(), total);\n                String message = plugin.getConfig().getString(\"messages.material-sold\");\n                if (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n               \n                this.update();\n            }));\n        }\n       \n        this.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\n        this.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n    }","cleancode":"@override public void populategui() { this.getfiller(); for (map.entry<material, integer> entry : collector.getcontents().entryset()) { material material = entry.getkey(); int startamount = entry.getvalue(); double startvalue = plugin.getcollectormanager().value(collector, material); list<string> lore = color.color(plugin.getconfig().getstringlist(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", string.format(\"%,d\", startamount)).replace(\"%value%\", string.format(\"%,.1f\", startvalue))).collect(collectors.tolist())); list<component> components = lore.stream().map(component::text).collect(collectors.tolist()); this.additem(itembuilder.from(material).name(component.text(this.getnicedenumstring(material.name()))).lore(components).asguiitem(event -> { event.setcancelled(true); player player = (player) event.getwhoclicked(); int amount = collector.getmaterialamount(material); double total = plugin.getcollectormanager().sell(collector, material); if (total == 0.0d) { return; } plugin.getmoneymanager().pay(player.getuniqueid(), total); string message = plugin.getconfig().getstring(\"messages.material-sold\"); if (message != null && !message.isempty()) player.sendmessage(color.color(message.replace(\"%amount%\", string.format(\"%,d\", amount)).replace(\"%material%\", this.getnicedenumstring(material.name())).replace(\"%total%\", string.format(\"%.1f\", total)))); this.update(); })); } this.setitem(3, 3, itembuilder.from(material.arrow).name(component.text(color.color(\"previous\"))).asguiitem(event -> this.previous())); this.setitem(3, 7, itembuilder.from(material.arrow).name(component.text(color.color(\"next\"))).asguiitem(event -> this.next())); }","comment":"\/\/ filler\n\/\/ items\n\/\/ args\n\/\/ add\n\/\/ cancel\n\/\/ args\n\/\/ check\n\/\/ todo: make it so collectors don't pick up items which can't be sold\n\/\/ deposit & inform\n\/\/ update\n\/\/ navigation","repo":"Workinq\/AsyncCollectors","code_context_2":"public void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\n\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\n\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\n\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\n\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\n\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));","code_context_10":"@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\n\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}\n\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}","code_context_20":"@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\n\n@Override\npublic void populateGui()\n{\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\n\/\/ Filler\nthis.getFiller();\n\/\/ Items\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}\n\nfor (Map.Entry<Material, Integer> entry : collector.getContents().entrySet())\n{\n\/\/ Args\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}\n\nMaterial material = entry.getKey();\nint startAmount = entry.getValue();\ndouble startValue = plugin.getCollectorManager().value(collector, material);\nList<String> lore = Color.color(plugin.getConfig().getStringList(\"guis.contents.item.lore\").stream().map(text -> text.replace(\"%amount%\", String.format(\"%,d\", startAmount)).replace(\"%value%\", String.format(\"%,.1f\", startValue))).collect(Collectors.toList()));\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}\n\nList<Component> components = lore.stream().map(Component::text).collect(Collectors.toList());\n\/\/ Add\nthis.addItem(ItemBuilder.from(material).name(Component.text(this.getNicedEnumString(material.name()))).lore(components).asGuiItem(event ->\n{\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}\n\n\/\/ Cancel\nevent.setCancelled(true);\n\/\/ Args\nPlayer player = (Player) event.getWhoClicked();\nint amount = collector.getMaterialAmount(material);\ndouble total = plugin.getCollectorManager().sell(collector, material);\n\/\/ Check\nif (total == 0.0d)\n{\n\/\/ TODO: Make it so collectors don't pick up items which can't be sold\nreturn;\n}\n\/\/ Deposit & Inform\nplugin.getMoneyManager().pay(player.getUniqueId(), total);\nString message = plugin.getConfig().getString(\"messages.material-sold\");\nif (message != null && !message.isEmpty()) player.sendMessage(Color.color(message.replace(\"%amount%\", String.format(\"%,d\", amount)).replace(\"%material%\", this.getNicedEnumString(material.name())).replace(\"%total%\", String.format(\"%.1f\", total))));\n\/\/ Update\nthis.update();\n}));\n}\n\/\/ Navigation\nthis.setItem(3, 3, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Previous\"))).asGuiItem(event -> this.previous()));\nthis.setItem(3, 7, ItemBuilder.from(Material.ARROW).name(Component.text(Color.color(\"Next\"))).asGuiItem(event -> this.next()));\n}","label":[0,1,0,0]}
{"id":3400,"original_code":"protected List<String> updateProvisioning(Map<String, File> artifacts, Provisioner provisionService) throws Exception {\n        ResourceInstaller resourceInstaller = provisionService.getResourceInstaller();\n        Map<ResourceIdentity, Resource> installedResources = getInstalledResources(provisionService);\n        Map<Requirement, Resource> requirements = new HashMap<Requirement, Resource>();\n        Set<Map.Entry<String, File>> entries = artifacts.entrySet();\n        List<Resource> resourcesToInstall = new ArrayList<Resource>();\n        List<String> resourceUrisInstalled = new ArrayList<String>();\n        updateStatus(\"installing\", null, null);\n        for (Map.Entry<String, File> entry : entries) {\n            String name = entry.getKey();\n            File file = entry.getValue();\n            String coords = name;\n            int idx = coords.lastIndexOf(':');\n            if (idx > 0) {\n                coords = name.substring(idx + 1);\n            }\n            \/\/ lets switch to gravia's mvn coordinates\n            coords = coords.replace('\/', ':');\n            MavenCoordinates mvnCoords = parse(coords);\n            URL url = file.toURI().toURL();\n            if (url == null) {\n                LOGGER.warn(\"Could not find URL for file \" + file);\n                continue;\n            }\n            \/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\n            boolean isShared = !isWar(name, file);\n            Resource resource = findMavenResource(mvnCoords, url, isShared);\n            if (resource == null) {\n                LOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n            } else {\n                ResourceIdentity identity = resource.getIdentity();\n                Resource oldResource = installedResources.remove(identity);\n                if (oldResource == null && !resourcehandleMap.containsKey(identity)) {\n                    if (isShared) {\n                        \/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n                        \/\/ which breaks the tests ;)\n                        LOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                    } else {\n                        LOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                        resourcesToInstall.add(resource);\n                        resourceUrisInstalled.add(name);\n                    }\n                }\n            }\n        }\n        for (Resource installedResource : installedResources.values()) {\n            ResourceIdentity identity = installedResource.getIdentity();\n            ResourceHandle resourceHandle = resourcehandleMap.get(identity);\n            if (resourceHandle == null) {\n                \/\/ TODO should not really happen when we can ask about the installed Resources\n                LOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n            } else {\n                LOGGER.info(\"Uninstalling \" + installedResource);\n                resourceHandle.uninstall();\n                resourcehandleMap.remove(identity);\n                LOGGER.info(\"Uninstalled \" + installedResource);\n            }\n        }\n        if (resourcesToInstall.size() > 0) {\n            LOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");\n            Set<ResourceHandle> resourceHandles = new LinkedHashSet<>();\n            ResourceInstaller.Context context = new DefaultInstallerContext(resourcesToInstall, requirements);\n            for (Resource resource : resourcesToInstall) {\n                resourceHandles.add(resourceInstaller.installResource(context, resource));\n            }\n            LOGGER.info(\"Got \" + resourceHandles.size() + \" resource handle(s)\");\n            for (ResourceHandle resourceHandle : resourceHandles) {\n                resourcehandleMap.put(resourceHandle.getResource().getIdentity(), resourceHandle);\n            }\n        }\n        return resourceUrisInstalled;\n    }","code":"protected List<String> updateProvisioning(Map<String, File> artifacts, Provisioner provisionService) throws Exception {\n        ResourceInstaller resourceInstaller = provisionService.getResourceInstaller();\n        Map<ResourceIdentity, Resource> installedResources = getInstalledResources(provisionService);\n        Map<Requirement, Resource> requirements = new HashMap<Requirement, Resource>();\n        Set<Map.Entry<String, File>> entries = artifacts.entrySet();\n        List<Resource> resourcesToInstall = new ArrayList<Resource>();\n        List<String> resourceUrisInstalled = new ArrayList<String>();\n        updateStatus(\"installing\", null, null);\n        for (Map.Entry<String, File> entry : entries) {\n            String name = entry.getKey();\n            File file = entry.getValue();\n            String coords = name;\n            int idx = coords.lastIndexOf(':');\n            if (idx > 0) {\n                coords = name.substring(idx + 1);\n            }\n           \n            coords = coords.replace('\/', ':');\n            MavenCoordinates mvnCoords = parse(coords);\n            URL url = file.toURI().toURL();\n            if (url == null) {\n                LOGGER.warn(\"Could not find URL for file \" + file);\n                continue;\n            }\n           \n            boolean isShared = !isWar(name, file);\n            Resource resource = findMavenResource(mvnCoords, url, isShared);\n            if (resource == null) {\n                LOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n            } else {\n                ResourceIdentity identity = resource.getIdentity();\n                Resource oldResource = installedResources.remove(identity);\n                if (oldResource == null && !resourcehandleMap.containsKey(identity)) {\n                    if (isShared) {\n                       \n                       \n                        LOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                    } else {\n                        LOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n                        resourcesToInstall.add(resource);\n                        resourceUrisInstalled.add(name);\n                    }\n                }\n            }\n        }\n        for (Resource installedResource : installedResources.values()) {\n            ResourceIdentity identity = installedResource.getIdentity();\n            ResourceHandle resourceHandle = resourcehandleMap.get(identity);\n            if (resourceHandle == null) {\n               \n                LOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n            } else {\n                LOGGER.info(\"Uninstalling \" + installedResource);\n                resourceHandle.uninstall();\n                resourcehandleMap.remove(identity);\n                LOGGER.info(\"Uninstalled \" + installedResource);\n            }\n        }\n        if (resourcesToInstall.size() > 0) {\n            LOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");\n            Set<ResourceHandle> resourceHandles = new LinkedHashSet<>();\n            ResourceInstaller.Context context = new DefaultInstallerContext(resourcesToInstall, requirements);\n            for (Resource resource : resourcesToInstall) {\n                resourceHandles.add(resourceInstaller.installResource(context, resource));\n            }\n            LOGGER.info(\"Got \" + resourceHandles.size() + \" resource handle(s)\");\n            for (ResourceHandle resourceHandle : resourceHandles) {\n                resourcehandleMap.put(resourceHandle.getResource().getIdentity(), resourceHandle);\n            }\n        }\n        return resourceUrisInstalled;\n    }","cleancode":"protected list<string> updateprovisioning(map<string, file> artifacts, provisioner provisionservice) throws exception { resourceinstaller resourceinstaller = provisionservice.getresourceinstaller(); map<resourceidentity, resource> installedresources = getinstalledresources(provisionservice); map<requirement, resource> requirements = new hashmap<requirement, resource>(); set<map.entry<string, file>> entries = artifacts.entryset(); list<resource> resourcestoinstall = new arraylist<resource>(); list<string> resourceurisinstalled = new arraylist<string>(); updatestatus(\"installing\", null, null); for (map.entry<string, file> entry : entries) { string name = entry.getkey(); file file = entry.getvalue(); string coords = name; int idx = coords.lastindexof(':'); if (idx > 0) { coords = name.substring(idx + 1); } coords = coords.replace('\/', ':'); mavencoordinates mvncoords = parse(coords); url url = file.touri().tourl(); if (url == null) { logger.warn(\"could not find url for file \" + file); continue; } boolean isshared = !iswar(name, file); resource resource = findmavenresource(mvncoords, url, isshared); if (resource == null) { logger.warn(\"could not find resource for \" + mvncoords + \" and \" + url); } else { resourceidentity identity = resource.getidentity(); resource oldresource = installedresources.remove(identity); if (oldresource == null && !resourcehandlemap.containskey(identity)) { if (isshared) { logger.debug(\"todo not installing \" + (isshared ? \"shared\" : \"non-shared\") + \" resource: \" + identity); } else { logger.info(\"installing \" + (isshared ? \"shared\" : \"non-shared\") + \" resource: \" + identity); resourcestoinstall.add(resource); resourceurisinstalled.add(name); } } } } for (resource installedresource : installedresources.values()) { resourceidentity identity = installedresource.getidentity(); resourcehandle resourcehandle = resourcehandlemap.get(identity); if (resourcehandle == null) { logger.warn(\"todo: cannot uninstall \" + installedresource + \" as we have no handle!\"); } else { logger.info(\"uninstalling \" + installedresource); resourcehandle.uninstall(); resourcehandlemap.remove(identity); logger.info(\"uninstalled \" + installedresource); } } if (resourcestoinstall.size() > 0) { logger.info(\"installing \" + resourcestoinstall.size() + \" resource(s)\"); set<resourcehandle> resourcehandles = new linkedhashset<>(); resourceinstaller.context context = new defaultinstallercontext(resourcestoinstall, requirements); for (resource resource : resourcestoinstall) { resourcehandles.add(resourceinstaller.installresource(context, resource)); } logger.info(\"got \" + resourcehandles.size() + \" resource handle(s)\"); for (resourcehandle resourcehandle : resourcehandles) { resourcehandlemap.put(resourcehandle.getresource().getidentity(), resourcehandle); } } return resourceurisinstalled; }","comment":"\/\/ lets switch to gravia's mvn coordinates\n\/\/ todo lets just detect wars for now for servlet engines - how do we decide on wildfly?\n\/\/ todo lest not deploy shared stuff for now since bundles throw an exception when trying to stop them \/\/ which breaks the tests ;)\n\/\/ todo should not really happen when we can ask about the installed resources","repo":"WillemJiang\/fabric8","code_context_2":"coords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\n\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\n\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n} else {\n\nResourceHandle resourceHandle = resourcehandleMap.get(identity);\nif (resourceHandle == null) {\n\/\/ TODO should not really happen when we can ask about the installed Resources\nLOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n} else {","code_context_10":"List<String> resourceUrisInstalled = new ArrayList<String>();\nupdateStatus(\"installing\", null, null);\nfor (Map.Entry<String, File> entry : entries) {\nString name = entry.getKey();\nFile file = entry.getValue();\nString coords = name;\nint idx = coords.lastIndexOf(':');\nif (idx > 0) {\ncoords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\nURL url = file.toURI().toURL();\nif (url == null) {\nLOGGER.warn(\"Could not find URL for file \" + file);\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\n\ncoords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\nURL url = file.toURI().toURL();\nif (url == null) {\nLOGGER.warn(\"Could not find URL for file \" + file);\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\nif (resource == null) {\nLOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\nif (resource == null) {\nLOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n} else {\nLOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\nresourcesToInstall.add(resource);\nresourceUrisInstalled.add(name);\n}\n}\n}\n}\nfor (Resource installedResource : installedResources.values()) {\n\nresourcesToInstall.add(resource);\nresourceUrisInstalled.add(name);\n}\n}\n}\n}\nfor (Resource installedResource : installedResources.values()) {\nResourceIdentity identity = installedResource.getIdentity();\nResourceHandle resourceHandle = resourcehandleMap.get(identity);\nif (resourceHandle == null) {\n\/\/ TODO should not really happen when we can ask about the installed Resources\nLOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n} else {\nLOGGER.info(\"Uninstalling \" + installedResource);\nresourceHandle.uninstall();\nresourcehandleMap.remove(identity);\nLOGGER.info(\"Uninstalled \" + installedResource);\n}\n}\nif (resourcesToInstall.size() > 0) {\nLOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");","code_context_20":"protected List<String> updateProvisioning(Map<String, File> artifacts, Provisioner provisionService) throws Exception {\nResourceInstaller resourceInstaller = provisionService.getResourceInstaller();\nMap<ResourceIdentity, Resource> installedResources = getInstalledResources(provisionService);\nMap<Requirement, Resource> requirements = new HashMap<Requirement, Resource>();\nSet<Map.Entry<String, File>> entries = artifacts.entrySet();\nList<Resource> resourcesToInstall = new ArrayList<Resource>();\nList<String> resourceUrisInstalled = new ArrayList<String>();\nupdateStatus(\"installing\", null, null);\nfor (Map.Entry<String, File> entry : entries) {\nString name = entry.getKey();\nFile file = entry.getValue();\nString coords = name;\nint idx = coords.lastIndexOf(':');\nif (idx > 0) {\ncoords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\nURL url = file.toURI().toURL();\nif (url == null) {\nLOGGER.warn(\"Could not find URL for file \" + file);\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\nif (resource == null) {\nLOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n\nSet<Map.Entry<String, File>> entries = artifacts.entrySet();\nList<Resource> resourcesToInstall = new ArrayList<Resource>();\nList<String> resourceUrisInstalled = new ArrayList<String>();\nupdateStatus(\"installing\", null, null);\nfor (Map.Entry<String, File> entry : entries) {\nString name = entry.getKey();\nFile file = entry.getValue();\nString coords = name;\nint idx = coords.lastIndexOf(':');\nif (idx > 0) {\ncoords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\nURL url = file.toURI().toURL();\nif (url == null) {\nLOGGER.warn(\"Could not find URL for file \" + file);\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\nif (resource == null) {\nLOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n} else {\nLOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\nresourcesToInstall.add(resource);\nresourceUrisInstalled.add(name);\n}\n}\n}\n}\n\ncoords = name.substring(idx + 1);\n}\n\/\/ lets switch to gravia's mvn coordinates\ncoords = coords.replace('\/', ':');\nMavenCoordinates mvnCoords = parse(coords);\nURL url = file.toURI().toURL();\nif (url == null) {\nLOGGER.warn(\"Could not find URL for file \" + file);\ncontinue;\n}\n\/\/ TODO lets just detect wars for now for servlet engines - how do we decide on WildFly?\nboolean isShared = !isWar(name, file);\nResource resource = findMavenResource(mvnCoords, url, isShared);\nif (resource == null) {\nLOGGER.warn(\"Could not find resource for \" + mvnCoords + \" and \" + url);\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n} else {\nLOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\nresourcesToInstall.add(resource);\nresourceUrisInstalled.add(name);\n}\n}\n}\n}\nfor (Resource installedResource : installedResources.values()) {\nResourceIdentity identity = installedResource.getIdentity();\nResourceHandle resourceHandle = resourcehandleMap.get(identity);\nif (resourceHandle == null) {\n\/\/ TODO should not really happen when we can ask about the installed Resources\nLOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n} else {\nLOGGER.info(\"Uninstalling \" + installedResource);\nresourceHandle.uninstall();\nresourcehandleMap.remove(identity);\nLOGGER.info(\"Uninstalled \" + installedResource);\n\n} else {\nResourceIdentity identity = resource.getIdentity();\nResource oldResource = installedResources.remove(identity);\nif (oldResource == null && !resourcehandleMap.containsKey(identity)) {\nif (isShared) {\n\/\/ TODO lest not deploy shared stuff for now since bundles throw an exception when trying to stop them\n\/\/ which breaks the tests ;)\nLOGGER.debug(\"TODO not installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\n} else {\nLOGGER.info(\"Installing \" + (isShared ? \"shared\" : \"non-shared\") + \" resource: \" + identity);\nresourcesToInstall.add(resource);\nresourceUrisInstalled.add(name);\n}\n}\n}\n}\nfor (Resource installedResource : installedResources.values()) {\nResourceIdentity identity = installedResource.getIdentity();\nResourceHandle resourceHandle = resourcehandleMap.get(identity);\nif (resourceHandle == null) {\n\/\/ TODO should not really happen when we can ask about the installed Resources\nLOGGER.warn(\"TODO: Cannot uninstall \" + installedResource + \" as we have no handle!\");\n} else {\nLOGGER.info(\"Uninstalling \" + installedResource);\nresourceHandle.uninstall();\nresourcehandleMap.remove(identity);\nLOGGER.info(\"Uninstalled \" + installedResource);\n}\n}\nif (resourcesToInstall.size() > 0) {\nLOGGER.info(\"Installing \" + resourcesToInstall.size() + \" resource(s)\");\nSet<ResourceHandle> resourceHandles = new LinkedHashSet<>();\nResourceInstaller.Context context = new DefaultInstallerContext(resourcesToInstall, requirements);\nfor (Resource resource : resourcesToInstall) {\nresourceHandles.add(resourceInstaller.installResource(context, resource));\n}\nLOGGER.info(\"Got \" + resourceHandles.size() + \" resource handle(s)\");\nfor (ResourceHandle resourceHandle : resourceHandles) {\nresourcehandleMap.put(resourceHandle.getResource().getIdentity(), resourceHandle);\n}\n}","label":[1,0,0,0]}
{"id":3401,"original_code":"private static MavenCoordinates parse(String coordinates) {\n        MavenCoordinates result;\n        String[] parts = coordinates.split(\":\");\n        if (parts.length == 3) {\n            result =  MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n        } else if (parts.length == 4) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n        } else if (parts.length == 5) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n        } else {\n            throw new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n        }\n        return result;\n    }","code":"private static MavenCoordinates parse(String coordinates) {\n        MavenCoordinates result;\n        String[] parts = coordinates.split(\":\");\n        if (parts.length == 3) {\n            result =  MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n        } else if (parts.length == 4) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n        } else if (parts.length == 5) {\n            result = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n        } else {\n            throw new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n        }\n        return result;\n    }","cleancode":"private static mavencoordinates parse(string coordinates) { mavencoordinates result; string[] parts = coordinates.split(\":\"); if (parts.length == 3) { result = mavencoordinates.create(parts[0], parts[1], parts[2], null, null); } else if (parts.length == 4) { result = mavencoordinates.create(parts[0], parts[1], parts[2], parts[3], null); } else if (parts.length == 5) { result = mavencoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]); } else { throw new illegalargumentexception(\"invalid coordinates: \" + coordinates); } return result; }","comment":"\/\/todo: this needs to be fixed at gravia","repo":"WillemJiang\/fabric8","code_context_2":"private static MavenCoordinates parse(String coordinates) {\nMavenCoordinates result;\nString[] parts = coordinates.split(\":\");\nif (parts.length == 3) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n} else if (parts.length == 4) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n} else if (parts.length == 5) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n} else {\nthrow new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n}\nreturn result;\n}","code_context_10":"private static MavenCoordinates parse(String coordinates) {\nMavenCoordinates result;\nString[] parts = coordinates.split(\":\");\nif (parts.length == 3) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n} else if (parts.length == 4) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n} else if (parts.length == 5) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n} else {\nthrow new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n}\nreturn result;\n}","code_context_20":"private static MavenCoordinates parse(String coordinates) {\nMavenCoordinates result;\nString[] parts = coordinates.split(\":\");\nif (parts.length == 3) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], null, null);\n} else if (parts.length == 4) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], null);\n} else if (parts.length == 5) {\nresult = MavenCoordinates.create(parts[0], parts[1], parts[2], parts[3], parts[4]);\n} else {\nthrow new IllegalArgumentException(\"Invalid coordinates: \" + coordinates);\n}\nreturn result;\n}","label":[0,0,1,0]}
{"id":19814,"original_code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonentry() throws datamodelexception { }","comment":"\/** * validates the data on entering the corresponding parse tree node. * * @throws datamodelexception a violation of data model rules *\/\n\/\/ todo auto-generated method stub, to be implemented by parser","repo":"airlenet\/yang-maven-plugin","code_context_2":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_10":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_20":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","label":[0,1,0,0]}
{"id":19815,"original_code":"@Override\n    public void validateDataOnExit()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code":"@Override\n    public void validateDataOnExit()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonexit() throws datamodelexception { }","comment":"\/** * validates the data on exiting the corresponding parse tree node. * * @throws datamodelexception a violation of data model rules *\/\n\/\/ todo auto-generated method stub, to be implemented by parser","repo":"airlenet\/yang-maven-plugin","code_context_2":"@Override\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_10":"@Override\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_20":"@Override\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnExit()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","label":[0,1,0,0]}
{"id":19923,"original_code":"@OnClick(R.id.btn_meter_set_minus)\n    void decreaseLevel() {\n        if (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\n            return;\n        }\n        mLevelToSet--;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n        \/\/TODO send setting level frame and change shared prefs and display\n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","code":"@OnClick(R.id.btn_meter_set_minus)\n    void decreaseLevel() {\n        if (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\n            return;\n        }\n        mLevelToSet--;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n       \n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","cleancode":"@onclick(r.id.btn_meter_set_minus) void decreaselevel() { if (mleveltoset == channels.chn_min_value_of_everything) { return; } mleveltoset--; mtextviewlevel.settext(string.format(locale.us, \"%1$d\", mleveltoset)); updatelevelforprefsandviewandsendframe(mleveltoset); islevelzero(); }","comment":"\/\/todo send setting level frame and change shared prefs and display","repo":"SirdarYangK\/SirdarYKCode","code_context_2":"mLevelToSet--;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();","code_context_10":"@OnClick(R.id.btn_meter_set_minus)\nvoid decreaseLevel() {\nif (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\nreturn;\n}\nmLevelToSet--;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();\n}","code_context_20":"@OnClick(R.id.btn_meter_set_minus)\nvoid decreaseLevel() {\nif (mLevelToSet == Channels.CHN_MIN_VALUE_OF_EVERYTHING) {\nreturn;\n}\nmLevelToSet--;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();\n}","label":[0,1,0,0]}
{"id":19924,"original_code":"@OnClick(R.id.btn_meter_set_plus)\n    void increaseLevel() {\n        if (mLevelToSet == Channels.CHN_MAX_LEVEL) {\n            return;\n        }\n        mLevelToSet++;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n        \/\/TODO send setting level frame and change shared prefs and display\n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","code":"@OnClick(R.id.btn_meter_set_plus)\n    void increaseLevel() {\n        if (mLevelToSet == Channels.CHN_MAX_LEVEL) {\n            return;\n        }\n        mLevelToSet++;\n        mTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n       \n        updateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\n        isLevelZero();\n    }","cleancode":"@onclick(r.id.btn_meter_set_plus) void increaselevel() { if (mleveltoset == channels.chn_max_level) { return; } mleveltoset++; mtextviewlevel.settext(string.format(locale.us, \"%1$d\", mleveltoset)); updatelevelforprefsandviewandsendframe(mleveltoset); islevelzero(); }","comment":"\/\/todo send setting level frame and change shared prefs and display","repo":"SirdarYangK\/SirdarYKCode","code_context_2":"mLevelToSet++;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();","code_context_10":"@OnClick(R.id.btn_meter_set_plus)\nvoid increaseLevel() {\nif (mLevelToSet == Channels.CHN_MAX_LEVEL) {\nreturn;\n}\nmLevelToSet++;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();\n}","code_context_20":"@OnClick(R.id.btn_meter_set_plus)\nvoid increaseLevel() {\nif (mLevelToSet == Channels.CHN_MAX_LEVEL) {\nreturn;\n}\nmLevelToSet++;\nmTextViewLevel.setText(String.format(Locale.US, \"%1$d\", mLevelToSet));\n\/\/TODO send setting level frame and change shared prefs and display\nupdateLevelForPrefsAndViewAndSendFrame(mLevelToSet);\nisLevelZero();\n}","label":[0,1,0,0]}
{"id":3700,"original_code":"@Override\n    public AJoinPoint insertBeginImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\t\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\t\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\n\tCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\t\/\/ return node;\n\t\/\/ TODO: Consider returning newStmt instead\n\treturn CxxJoinpoints.create(newStmt);\n    }","code":"@Override\n    public AJoinPoint insertBeginImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\n\n\tCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\n\n\treturn CxxJoinpoints.create(newStmt);\n    }","cleancode":"@override public ajoinpoint insertbeginimpl(ajoinpoint node) { stmt newstmt = clavanodes.tostmt(node.getnode()); cxxactions.insertstmt(\"before\", scope, newstmt, getweaverengine()); return cxxjoinpoints.create(newstmt); }","comment":"\/\/ preconditions.checkargument(node.getnode() instanceof stmt, \/\/ \"expected input of action scope.insertentry to be a stmt joinpoint\");\n\/\/ return node; \/\/ todo: consider returning newstmt instead","repo":"TheNunoGomes\/clava","code_context_2":"public AJoinPoint insertBeginImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n}","code_context_10":"@Override\npublic AJoinPoint insertBeginImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n}\n\n@Override\npublic AJoinPoint insertBeginImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n}","code_context_20":"@Override\npublic AJoinPoint insertBeginImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n}\n\n@Override\npublic AJoinPoint insertBeginImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(node.getNode() instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEntry to be a Stmt joinpoint\");\nCxxActions.insertStmt(\"before\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n}","label":[1,0,0,0]}
{"id":3701,"original_code":"@Override\n    public AJoinPoint insertEndImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\t\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\t\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\t\/\/ node.getJoinPointType());\n\tCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\t\/\/ return node;\n\t\/\/ TODO: Consider returning newStmt instead\n\treturn CxxJoinpoints.create(newStmt);\n\t\/*\n\t * List<? extends AStatement> statements = selectStatements(); if\n\t * (statements.isEmpty()) { throw new\n\t * RuntimeException(\"Not yet implemented when scope is empty\"); }\n\t * \n\t * Stmt newStmt =\n\t * CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n\t * \n\t * insertImpl(position, newStmt);\n\t * \n\t * \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n\t * this);\n\t *\/\n    }","code":"@Override\n    public AJoinPoint insertEndImpl(AJoinPoint node) {\n\tStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\n\n\n\tCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\n\n\treturn CxxJoinpoints.create(newStmt);\n\n    }","cleancode":"@override public ajoinpoint insertendimpl(ajoinpoint node) { stmt newstmt = clavanodes.tostmt(node.getnode()); cxxactions.insertstmt(\"after\", scope, newstmt, getweaverengine()); return cxxjoinpoints.create(newstmt); }","comment":"\/\/ preconditions.checkargument(newstmt instanceof stmt, \/\/ \"expected input of action scope.insertend to be a stmt joinpoint, is a \" + \/\/ node.getjoinpointtype());\n\/\/ return node; \/\/ todo: consider returning newstmt instead\n\/* * list<? extends astatement> statements = selectstatements(); if * (statements.isempty()) { throw new * runtimeexception(\"not yet implemented when scope is empty\"); } * * stmt newstmt = * cxxactions.getvalidstatement(collectionutils.last(statements).getnode()); * * insertimpl(position, newstmt); * * \/\/ body becomes the parent of this statement return new cxxstatement(newstmt, * this); *\/","repo":"TheNunoGomes\/clava","code_context_2":"public AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n*\n* \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n* this);\n*\/\n}","code_context_10":"@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n\n@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n\n@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n*\n* \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n* this);\n*\/\n}","code_context_20":"@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n*\n* \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n* this);\n*\/\n}\n\n@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n*\n* \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n* this);\n*\/\n}\n\n@Override\npublic AJoinPoint insertEndImpl(AJoinPoint node) {\nStmt newStmt = ClavaNodes.toStmt(node.getNode());\n\/\/ Preconditions.checkArgument(newStmt instanceof Stmt,\n\/\/ \"Expected input of action scope.insertEnd to be a Stmt joinpoint, is a \" +\n\/\/ node.getJoinPointType());\nCxxActions.insertStmt(\"after\", scope, newStmt, getWeaverEngine());\n\/\/ return node;\n\/\/ TODO: Consider returning newStmt instead\nreturn CxxJoinpoints.create(newStmt);\n\/*\n* List<? extends AStatement> statements = selectStatements(); if\n* (statements.isEmpty()) { throw new\n* RuntimeException(\"Not yet implemented when scope is empty\"); }\n*\n* Stmt newStmt =\n* CxxActions.getValidStatement(CollectionUtils.last(statements).getNode());\n*\n* insertImpl(position, newStmt);\n*\n* \/\/ Body becomes the parent of this statement return new CxxStatement(newStmt,\n* this);\n*\/\n}","label":[1,0,0,0]}
{"id":12023,"original_code":"public void update(long fps) {\n        if (paddleMoving == LEFT) {\n            \/\/ to fix Paddle going off the Screen\n            if (x >= -MYscreenDPI \/ 10)\n                \/\/ Decrement position\n                x = x - paddleSpeed \/ fps;\n        }\n        if (paddleMoving == RIGHT) {\n            \/\/ to fix Paddle going off the Screen\n            if (x <= scrX - length - MYscreenDPI \/ 14)\n                \/\/ Increment position\n                x = x + paddleSpeed \/ fps;\n        }\n        \/\/ Apply the New position\n        rect.left = x;\n        rect.right = x + length;\n    }","code":"public void update(long fps) {\n        if (paddleMoving == LEFT) {\n           \n            if (x >= -MYscreenDPI \/ 10)\n               \n                x = x - paddleSpeed \/ fps;\n        }\n        if (paddleMoving == RIGHT) {\n           \n            if (x <= scrX - length - MYscreenDPI \/ 14)\n               \n                x = x + paddleSpeed \/ fps;\n        }\n       \n        rect.left = x;\n        rect.right = x + length;\n    }","cleancode":"public void update(long fps) { if (paddlemoving == left) { if (x >= -myscreendpi \/ 10) x = x - paddlespeed \/ fps; } if (paddlemoving == right) { if (x <= scrx - length - myscreendpi \/ 14) x = x + paddlespeed \/ fps; } rect.left = x; rect.right = x + length; }","comment":"\/\/ this update method will be called from update in breakoutview \/\/ it determines if the paddle needs to move and changes the coordinates \/\/ contained in rect if necessary\n\/\/ to fix paddle going off the screen\n\/\/ decrement position\n\/\/ to fix paddle going off the screen\n\/\/ increment position\n\/\/ apply the new position","repo":"Shuffler\/Breakout-Android-Game","code_context_2":"public void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\n\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\n\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;","code_context_10":"public void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}","code_context_20":"public void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}\n\npublic void update(long fps) {\nif (paddleMoving == LEFT) {\n\/\/ to fix Paddle going off the Screen\nif (x >= -MYscreenDPI \/ 10)\n\/\/ Decrement position\nx = x - paddleSpeed \/ fps;\n}\nif (paddleMoving == RIGHT) {\n\/\/ to fix Paddle going off the Screen\nif (x <= scrX - length - MYscreenDPI \/ 14)\n\/\/ Increment position\nx = x + paddleSpeed \/ fps;\n}\n\/\/ Apply the New position\nrect.left = x;\nrect.right = x + length;\n}","label":[0,0,1,0]}
{"id":20364,"original_code":"@JsonGetter(\"action\")\n    public ApplicationActionTypeEnum getAction ( ) { \n        return this.action;\n    }","code":"@JsonGetter(\"action\")\n    public ApplicationActionTypeEnum getAction ( ) { \n        return this.action;\n    }","cleancode":"@jsongetter(\"action\") public applicationactiontypeenum getaction ( ) { return this.action; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"agaveplatform\/java-sdk","code_context_2":"@JsonGetter(\"action\")\npublic ApplicationActionTypeEnum getAction ( ) {\nreturn this.action;\n}","code_context_10":"@JsonGetter(\"action\")\npublic ApplicationActionTypeEnum getAction ( ) {\nreturn this.action;\n}","code_context_20":"@JsonGetter(\"action\")\npublic ApplicationActionTypeEnum getAction ( ) {\nreturn this.action;\n}","label":[0,0,0,0]}
{"id":20365,"original_code":"@JsonSetter(\"action\")\n    private void setAction (ApplicationActionTypeEnum value) { \n        this.action = value;\n    }","code":"@JsonSetter(\"action\")\n    private void setAction (ApplicationActionTypeEnum value) { \n        this.action = value;\n    }","cleancode":"@jsonsetter(\"action\") private void setaction (applicationactiontypeenum value) { this.action = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"agaveplatform\/java-sdk","code_context_2":"@JsonSetter(\"action\")\nprivate void setAction (ApplicationActionTypeEnum value) {\nthis.action = value;\n}","code_context_10":"@JsonSetter(\"action\")\nprivate void setAction (ApplicationActionTypeEnum value) {\nthis.action = value;\n}","code_context_20":"@JsonSetter(\"action\")\nprivate void setAction (ApplicationActionTypeEnum value) {\nthis.action = value;\n}","label":[0,0,0,0]}
{"id":12178,"original_code":"public static String generateFunction(){\n    \tList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n    \t\/* TODO Need to find alternative for this\n    \tDataMapperRoot rootDiagram =  (DataMapperRoot)DataMapperDiagramEditor.getInstance().getDiagram().getElement();\n    \tTreeNode inputTreeNode = rootDiagram.getInput().getTreeNode().get(0);\n    \tTreeNode outputTreeNode = rootDiagram.getOutput().getTreeNode().get(0);\n    \tString input = inputTreeNode.getName();\n\t\tString output = outputTreeNode.getName();\n\t\tString functionStart = \"function map_S_\"+input+\"_S_\"+output+\"(\" + input + \", \" + output + \"){\\n\";\n\t\tString functionReturn = \"return \" + output + \";\\n\";\n\t\tJsFunction mainFunction = new JsFunction(0);\n\t\tmainFunction.setFunctionStart(functionStart);\n\t\tmainFunction.setFunctionReturn(functionReturn);\n\t\tdmcFunctions.add(mainFunction);\n\t\tList<JsFunction> innerFunctions = getFunctionForTheTreeNode(rootDiagram.getInput().getTreeNode(), dmcFunctions, 0, null);\n\t\tmainFunction.getFunctions().addAll(innerFunctions);\n\t\t*\/\n\t\tString documentString = \"\";\n\t\tfor (JsFunction func : dmcFunctions) {\n\t\t\tdocumentString += func.toString() + \"\\n\\n\";\n\t\t}\n\t\treturn documentString;\n    }","code":"public static String generateFunction(){\n    \tList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n    \n\t\tString documentString = \"\";\n\t\tfor (JsFunction func : dmcFunctions) {\n\t\t\tdocumentString += func.toString() + \"\\n\\n\";\n\t\t}\n\t\treturn documentString;\n    }","cleancode":"public static string generatefunction(){ list<jsfunction> dmcfunctions = new arraylist<jsfunction>(); string documentstring = \"\"; for (jsfunction func : dmcfunctions) { documentstring += func.tostring() + \"\\n\\n\"; } return documentstring; }","comment":"\/* todo need to find alternative for this datamapperroot rootdiagram = (datamapperroot)datamapperdiagrameditor.getinstance().getdiagram().getelement(); treenode inputtreenode = rootdiagram.getinput().gettreenode().get(0); treenode outputtreenode = rootdiagram.getoutput().gettreenode().get(0); string input = inputtreenode.getname(); string output = outputtreenode.getname(); string functionstart = \"function map_s_\"+input+\"_s_\"+output+\"(\" + input + \", \" + output + \"){\\n\"; string functionreturn = \"return \" + output + \";\\n\"; jsfunction mainfunction = new jsfunction(0); mainfunction.setfunctionstart(functionstart); mainfunction.setfunctionreturn(functionreturn); dmcfunctions.add(mainfunction); list<jsfunction> innerfunctions = getfunctionforthetreenode(rootdiagram.getinput().gettreenode(), dmcfunctions, 0, null); mainfunction.getfunctions().addall(innerfunctions); *\/","repo":"SanojPunchihewa\/devstudio-tooling-esb","code_context_2":"public static String generateFunction(){\nList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n\/* TODO Need to find alternative for this\nDataMapperRoot rootDiagram = (DataMapperRoot)DataMapperDiagramEditor.getInstance().getDiagram().getElement();\nTreeNode inputTreeNode = rootDiagram.getInput().getTreeNode().get(0);\nTreeNode outputTreeNode = rootDiagram.getOutput().getTreeNode().get(0);\nString input = inputTreeNode.getName();\nString output = outputTreeNode.getName();\nString functionStart = \"function map_S_\"+input+\"_S_\"+output+\"(\" + input + \", \" + output + \"){\\n\";\nString functionReturn = \"return \" + output + \";\\n\";\nJsFunction mainFunction = new JsFunction(0);\nmainFunction.setFunctionStart(functionStart);\nmainFunction.setFunctionReturn(functionReturn);\ndmcFunctions.add(mainFunction);\nList<JsFunction> innerFunctions = getFunctionForTheTreeNode(rootDiagram.getInput().getTreeNode(), dmcFunctions, 0, null);\nmainFunction.getFunctions().addAll(innerFunctions);\n*\/\nString documentString = \"\";\nfor (JsFunction func : dmcFunctions) {","code_context_10":"public static String generateFunction(){\nList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n\/* TODO Need to find alternative for this\nDataMapperRoot rootDiagram = (DataMapperRoot)DataMapperDiagramEditor.getInstance().getDiagram().getElement();\nTreeNode inputTreeNode = rootDiagram.getInput().getTreeNode().get(0);\nTreeNode outputTreeNode = rootDiagram.getOutput().getTreeNode().get(0);\nString input = inputTreeNode.getName();\nString output = outputTreeNode.getName();\nString functionStart = \"function map_S_\"+input+\"_S_\"+output+\"(\" + input + \", \" + output + \"){\\n\";\nString functionReturn = \"return \" + output + \";\\n\";\nJsFunction mainFunction = new JsFunction(0);\nmainFunction.setFunctionStart(functionStart);\nmainFunction.setFunctionReturn(functionReturn);\ndmcFunctions.add(mainFunction);\nList<JsFunction> innerFunctions = getFunctionForTheTreeNode(rootDiagram.getInput().getTreeNode(), dmcFunctions, 0, null);\nmainFunction.getFunctions().addAll(innerFunctions);\n*\/\nString documentString = \"\";\nfor (JsFunction func : dmcFunctions) {\ndocumentString += func.toString() + \"\\n\\n\";\n}\nreturn documentString;\n}","code_context_20":"public static String generateFunction(){\nList<JsFunction> dmcFunctions = new ArrayList<JsFunction>();\n\/* TODO Need to find alternative for this\nDataMapperRoot rootDiagram = (DataMapperRoot)DataMapperDiagramEditor.getInstance().getDiagram().getElement();\nTreeNode inputTreeNode = rootDiagram.getInput().getTreeNode().get(0);\nTreeNode outputTreeNode = rootDiagram.getOutput().getTreeNode().get(0);\nString input = inputTreeNode.getName();\nString output = outputTreeNode.getName();\nString functionStart = \"function map_S_\"+input+\"_S_\"+output+\"(\" + input + \", \" + output + \"){\\n\";\nString functionReturn = \"return \" + output + \";\\n\";\nJsFunction mainFunction = new JsFunction(0);\nmainFunction.setFunctionStart(functionStart);\nmainFunction.setFunctionReturn(functionReturn);\ndmcFunctions.add(mainFunction);\nList<JsFunction> innerFunctions = getFunctionForTheTreeNode(rootDiagram.getInput().getTreeNode(), dmcFunctions, 0, null);\nmainFunction.getFunctions().addAll(innerFunctions);\n*\/\nString documentString = \"\";\nfor (JsFunction func : dmcFunctions) {\ndocumentString += func.toString() + \"\\n\\n\";\n}\nreturn documentString;\n}","label":[1,0,0,0]}
{"id":12258,"original_code":"public void postPutAll(final DistributedPutAllOperation putAllOp,\n      final VersionedObjectList successfulPuts, final LocalRegion region) {\n    \/\/ TODO: TX: add support for batching using performOp as for other\n    \/\/ update operations; add cacheWrite flag support for proper writer\n    \/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\n    markDirty();\n    if (isSnapshot()) {\n      addAffectedRegion(region);\n      region.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\n      return;\n    }\n    if (region.getPartitionAttributes() != null) {\n      \/\/ use PutAllPRMessage that already handles transactions\n      region.postPutAllSend(putAllOp, this, successfulPuts);\n    }\n    else {\n      try {\n        final PutAllEntryData[] data = putAllOp.putAllData;\n        final EntryEventImpl event = putAllOp.getBaseEvent();\n        final RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\n            data, data.length, event.isPossibleDuplicate(), null, this);\n        \/\/ process on self first\n        if (region.getDataPolicy().withStorage()) {\n          msg.doLocalPutAll(region, event, putAllOp, successfulPuts,\n              region.getMyId(), false \/* sendReply *\/);\n        }\n        addAffectedRegion(region);\n        if (region.getScope().isDistributed()) {\n          \/\/ distribute if required\n          msg.distribute(event);\n        }\n      } catch (RemoteOperationException roe) {\n        throw new TransactionDataNodeHasDepartedException(roe);\n      }\n    }\n  }","code":"public void postPutAll(final DistributedPutAllOperation putAllOp,\n      final VersionedObjectList successfulPuts, final LocalRegion region) {\n   \n   \n   \n    markDirty();\n    if (isSnapshot()) {\n      addAffectedRegion(region);\n      region.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\n      return;\n    }\n    if (region.getPartitionAttributes() != null) {\n     \n      region.postPutAllSend(putAllOp, this, successfulPuts);\n    }\n    else {\n      try {\n        final PutAllEntryData[] data = putAllOp.putAllData;\n        final EntryEventImpl event = putAllOp.getBaseEvent();\n        final RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\n            data, data.length, event.isPossibleDuplicate(), null, this);\n       \n        if (region.getDataPolicy().withStorage()) {\n          msg.doLocalPutAll(region, event, putAllOp, successfulPuts,\n              region.getMyId(), false);\n        }\n        addAffectedRegion(region);\n        if (region.getScope().isDistributed()) {\n         \n          msg.distribute(event);\n        }\n      } catch (RemoteOperationException roe) {\n        throw new TransactionDataNodeHasDepartedException(roe);\n      }\n    }\n  }","cleancode":"public void postputall(final distributedputalloperation putallop, final versionedobjectlist successfulputs, final localregion region) { markdirty(); if (issnapshot()) { addaffectedregion(region); region.getshareddataview().postputall(putallop, successfulputs, region); return; } if (region.getpartitionattributes() != null) { region.postputallsend(putallop, this, successfulputs); } else { try { final putallentrydata[] data = putallop.putalldata; final entryeventimpl event = putallop.getbaseevent(); final remoteputallmessage msg = new remoteputallmessage(event, null, data, data.length, event.ispossibleduplicate(), null, this); if (region.getdatapolicy().withstorage()) { msg.dolocalputall(region, event, putallop, successfulputs, region.getmyid(), false); } addaffectedregion(region); if (region.getscope().isdistributed()) { msg.distribute(event); } } catch (remoteoperationexception roe) { throw new transactiondatanodehasdepartedexception(roe); } } }","comment":"\/** * @see internaldataview#postputall(distributedputalloperation, * versionedobjectlist, localregion) *\/\n\/\/ todo: tx: add support for batching using performop as for other \/\/ update operations; add cachewrite flag support for proper writer \/\/ invocation like in other ops; also support for normal\/preloaded regions?\n\/\/ use putallprmessage that already handles transactions\n\/\/ process on self first\n\/* sendreply *\/\n\/\/ distribute if required","repo":"SnappyDataInc\/snappy-store","code_context_2":"public void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}\n\npublic void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\n\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\n\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\n\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\n\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}","code_context_10":"public void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}\n\npublic void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\n\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\n\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\n\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}","code_context_20":"public void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}\n\npublic void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n\npublic void postPutAll(final DistributedPutAllOperation putAllOp,\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n\nfinal VersionedObjectList successfulPuts, final LocalRegion region) {\n\/\/ TODO: TX: add support for batching using performOp as for other\n\/\/ update operations; add cacheWrite flag support for proper writer\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}\n\n\/\/ invocation like in other ops; also support for NORMAL\/PRELOADED regions?\nmarkDirty();\nif (isSnapshot()) {\naddAffectedRegion(region);\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}\n\nregion.getSharedDataView().postPutAll(putAllOp, successfulPuts, region);\nreturn;\n}\nif (region.getPartitionAttributes() != null) {\n\/\/ use PutAllPRMessage that already handles transactions\nregion.postPutAllSend(putAllOp, this, successfulPuts);\n}\nelse {\ntry {\nfinal PutAllEntryData[] data = putAllOp.putAllData;\nfinal EntryEventImpl event = putAllOp.getBaseEvent();\nfinal RemotePutAllMessage msg = new RemotePutAllMessage(event, null,\ndata, data.length, event.isPossibleDuplicate(), null, this);\n\/\/ process on self first\nif (region.getDataPolicy().withStorage()) {\nmsg.doLocalPutAll(region, event, putAllOp, successfulPuts,\nregion.getMyId(), false \/* sendReply *\/);\n}\naddAffectedRegion(region);\nif (region.getScope().isDistributed()) {\n\/\/ distribute if required\nmsg.distribute(event);\n}\n} catch (RemoteOperationException roe) {\nthrow new TransactionDataNodeHasDepartedException(roe);\n}\n}\n}","label":[0,1,0,0]}
{"id":12419,"original_code":"public static void layoutInit() {\n        Dimension dimension = new Dimension(560, 320);\n        if (OperatingSystem.getCurrent() == OperatingSystem.MACOS) {\n            dimension.setSize(dimension.getWidth() * PopupBase.MACOS_WIDTH_SCALE, dimension.getHeight());\n        }\n        FRAME.setPreferredSize(dimension);\n        LOG_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(LogFrame.class)) {\n                new LogFrame();\n            } else {\n                PopupBase.getAlive(LogFrame.class).reopen();\n            }\n        });\n        JS_BTN.addActionListener((e) -> {\n            MainJDEC.IS_ENABLED.setSelected(false);\n            MainJDEC.IS_ENABLED.setEnabled(false);\n            if (!PopupBase.isAlive(JoystickFrame.class)) {\n                new JoystickFrame();\n            } else {\n                PopupBase.getAlive(JoystickFrame.class).reopen();\n            }\n        });\n        STATS_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(StatsFrame.class)) {\n                new StatsFrame();\n            } else {\n                PopupBase.getAlive(StatsFrame.class).reopen();\n            }\n        });\n        NT_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(NTFrame.class)) {\n                NT_FRAME = new NTFrame();\n            } else {\n                PopupBase.getAlive(NTFrame.class).reopen();\n            }\n        });\n        USB_CONNECT.addActionListener((e) -> {\n            Thread reload = new Thread() {\n                @Override\n                public void run() {\n                    NetworkReloader.reloadRio(Protocol.UDP);\n                    NetworkReloader.reloadRio(Protocol.TCP);\n                    super.run();\n                    interrupt();\n                }\n            };\n            reload.start();\n        });\n        RESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n        \/\/TODO remove after testing\n        TEAM_NUMBER.setText(\"localhost\");\n        TEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\n        IS_ENABLED.setEnabled(false);\n        GlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n                .addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n                .addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\n        GBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\n        base.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\n        base.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\n        base.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));\n        base.clone().setPos(0, 2, 1, 1).build(IS_ENABLED);\n        base.clone().setPos(1, 2, 1, 1).build(ROBOT_DRIVE_MODE);\n        base.clone().setPos(0, 3, 2, 1).setFill(GridBagConstraints.NONE).build(new JLabel(\"Alliance Station\"));\n        base.clone().setPos(0, 4, 1, 1).build(ALLIANCE_NUM);\n        base.clone().setPos(1, 4, 1, 1).build(ALLIANCE_COLOR);\n        endr.clone().setPos(0, 5, 1, 1).build(new JLabel(\"Team Number:\"));\n        base.clone().setPos(1, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(TEAM_NUMBER);\n        endr.clone().setPos(0, 6, 1, 1).build(new JLabel(\"Game Data:\"));\n        base.clone().setPos(1, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(GAME_DATA);\n        endr.clone().setPos(0, 7, 1, 1).build(new JLabel(\"Protocol Year:\"));\n        base.clone().setPos(1, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(PROTOCOL_YEAR);\n        base.clone().setPos(2, 2, 2, 1).build(RESTART_CODE_BTN);\n        base.clone().setPos(2, 3, 2, 1).build(RESTART_ROBO_RIO_BTN);\n        base.clone().setPos(2, 4, 2, 1).build(ESTOP_BTN);\n        base.clone().setPos(2, 5, 1, 1).build(JS_BTN);\n        base.clone().setPos(3, 5, 1, 1).build(STATS_BTN);\n        base.clone().setPos(2, 6, 1, 1).build(NT_BTN);\n        base.clone().setPos(3, 6, 1, 1).build(LOG_BTN);\n        base.clone().setPos(2, 7, 1, 1).build(FMS_CONNECT);\n        base.clone().setPos(3, 7, 1, 1).build(USB_CONNECT);\n        base.clone().setPos(4, 2, 2, 1).setFill(GridBagConstraints.NONE).build(BAT_VOLTAGE);\n        endr.clone().setPos(4, 3, 1, 1).build(new JLabel(\"Robot:\"));\n        base.clone().setPos(5, 3, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CONNECTION_STATUS);\n        endr.clone().setPos(4, 4, 1, 1).build(new JLabel(\"Code: \"));\n        base.clone().setPos(5, 4, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CODE_STATUS);\n        endr.clone().setPos(4, 5, 1, 1).build(new JLabel(\"EStop: \"));\n        base.clone().setPos(5, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ESTOP_STATUS);\n        endr.clone().setPos(4, 6, 1, 1).build(new JLabel(\"FMS: \"));\n        base.clone().setPos(5, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(FMS_CONNECTION_STATUS);\n        endr.clone().setPos(4, 7, 1, 1).build(new JLabel(\"Time: \"));\n        base.clone().setPos(5, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(MATCH_TIME);\n    }","code":"public static void layoutInit() {\n        Dimension dimension = new Dimension(560, 320);\n        if (OperatingSystem.getCurrent() == OperatingSystem.MACOS) {\n            dimension.setSize(dimension.getWidth() * PopupBase.MACOS_WIDTH_SCALE, dimension.getHeight());\n        }\n        FRAME.setPreferredSize(dimension);\n        LOG_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(LogFrame.class)) {\n                new LogFrame();\n            } else {\n                PopupBase.getAlive(LogFrame.class).reopen();\n            }\n        });\n        JS_BTN.addActionListener((e) -> {\n            MainJDEC.IS_ENABLED.setSelected(false);\n            MainJDEC.IS_ENABLED.setEnabled(false);\n            if (!PopupBase.isAlive(JoystickFrame.class)) {\n                new JoystickFrame();\n            } else {\n                PopupBase.getAlive(JoystickFrame.class).reopen();\n            }\n        });\n        STATS_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(StatsFrame.class)) {\n                new StatsFrame();\n            } else {\n                PopupBase.getAlive(StatsFrame.class).reopen();\n            }\n        });\n        NT_BTN.addActionListener((e) -> {\n            if (!PopupBase.isAlive(NTFrame.class)) {\n                NT_FRAME = new NTFrame();\n            } else {\n                PopupBase.getAlive(NTFrame.class).reopen();\n            }\n        });\n        USB_CONNECT.addActionListener((e) -> {\n            Thread reload = new Thread() {\n                @Override\n                public void run() {\n                    NetworkReloader.reloadRio(Protocol.UDP);\n                    NetworkReloader.reloadRio(Protocol.TCP);\n                    super.run();\n                    interrupt();\n                }\n            };\n            reload.start();\n        });\n        RESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n       \n        TEAM_NUMBER.setText(\"localhost\");\n        TEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\n        IS_ENABLED.setEnabled(false);\n        GlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n                .addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n                .addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\n        GBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\n        base.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\n        base.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\n        base.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));\n        base.clone().setPos(0, 2, 1, 1).build(IS_ENABLED);\n        base.clone().setPos(1, 2, 1, 1).build(ROBOT_DRIVE_MODE);\n        base.clone().setPos(0, 3, 2, 1).setFill(GridBagConstraints.NONE).build(new JLabel(\"Alliance Station\"));\n        base.clone().setPos(0, 4, 1, 1).build(ALLIANCE_NUM);\n        base.clone().setPos(1, 4, 1, 1).build(ALLIANCE_COLOR);\n        endr.clone().setPos(0, 5, 1, 1).build(new JLabel(\"Team Number:\"));\n        base.clone().setPos(1, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(TEAM_NUMBER);\n        endr.clone().setPos(0, 6, 1, 1).build(new JLabel(\"Game Data:\"));\n        base.clone().setPos(1, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(GAME_DATA);\n        endr.clone().setPos(0, 7, 1, 1).build(new JLabel(\"Protocol Year:\"));\n        base.clone().setPos(1, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(PROTOCOL_YEAR);\n        base.clone().setPos(2, 2, 2, 1).build(RESTART_CODE_BTN);\n        base.clone().setPos(2, 3, 2, 1).build(RESTART_ROBO_RIO_BTN);\n        base.clone().setPos(2, 4, 2, 1).build(ESTOP_BTN);\n        base.clone().setPos(2, 5, 1, 1).build(JS_BTN);\n        base.clone().setPos(3, 5, 1, 1).build(STATS_BTN);\n        base.clone().setPos(2, 6, 1, 1).build(NT_BTN);\n        base.clone().setPos(3, 6, 1, 1).build(LOG_BTN);\n        base.clone().setPos(2, 7, 1, 1).build(FMS_CONNECT);\n        base.clone().setPos(3, 7, 1, 1).build(USB_CONNECT);\n        base.clone().setPos(4, 2, 2, 1).setFill(GridBagConstraints.NONE).build(BAT_VOLTAGE);\n        endr.clone().setPos(4, 3, 1, 1).build(new JLabel(\"Robot:\"));\n        base.clone().setPos(5, 3, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CONNECTION_STATUS);\n        endr.clone().setPos(4, 4, 1, 1).build(new JLabel(\"Code: \"));\n        base.clone().setPos(5, 4, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ROBOT_CODE_STATUS);\n        endr.clone().setPos(4, 5, 1, 1).build(new JLabel(\"EStop: \"));\n        base.clone().setPos(5, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(ESTOP_STATUS);\n        endr.clone().setPos(4, 6, 1, 1).build(new JLabel(\"FMS: \"));\n        base.clone().setPos(5, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(FMS_CONNECTION_STATUS);\n        endr.clone().setPos(4, 7, 1, 1).build(new JLabel(\"Time: \"));\n        base.clone().setPos(5, 7, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(MATCH_TIME);\n    }","cleancode":"public static void layoutinit() { dimension dimension = new dimension(560, 320); if (operatingsystem.getcurrent() == operatingsystem.macos) { dimension.setsize(dimension.getwidth() * popupbase.macos_width_scale, dimension.getheight()); } frame.setpreferredsize(dimension); log_btn.addactionlistener((e) -> { if (!popupbase.isalive(logframe.class)) { new logframe(); } else { popupbase.getalive(logframe.class).reopen(); } }); js_btn.addactionlistener((e) -> { mainjdec.is_enabled.setselected(false); mainjdec.is_enabled.setenabled(false); if (!popupbase.isalive(joystickframe.class)) { new joystickframe(); } else { popupbase.getalive(joystickframe.class).reopen(); } }); stats_btn.addactionlistener((e) -> { if (!popupbase.isalive(statsframe.class)) { new statsframe(); } else { popupbase.getalive(statsframe.class).reopen(); } }); nt_btn.addactionlistener((e) -> { if (!popupbase.isalive(ntframe.class)) { nt_frame = new ntframe(); } else { popupbase.getalive(ntframe.class).reopen(); } }); usb_connect.addactionlistener((e) -> { thread reload = new thread() { @override public void run() { networkreloader.reloadrio(protocol.udp); networkreloader.reloadrio(protocol.tcp); super.run(); interrupt(); } }; reload.start(); }); restart_code_btn.addactionlistener(e -> is_enabled.setselected(false)); team_number.settext(\"localhost\"); team_number.getdocument().adddocumentlistener(new teamnumlistener()); is_enabled.setenabled(false); globalscreen.addnativekeylistener(globalkeylistener.instance .addkeyevent(nativekeyevent.vc_enter, () -> mainjdec.is_enabled.setselected(false)) .addkeyevent(nativekeyevent.vc_space, mainjdec.estop_btn::doclick)); gbcpanelbuilder endr = base.clone().setanchor(gridbagconstraints.line_end).setfill(gridbagconstraints.none); base.clone().setpos(0, 0, 6, 1).setfill(gridbagconstraints.none).build(title); base.clone().setpos(0, 1, 6, 1).setfill(gridbagconstraints.none).build(link); base.clone().setpos(5, 0, 1, 2).setfill(gridbagconstraints.none).build(new jlabel(new imageicon(mainframe.icon_min))); base.clone().setpos(0, 2, 1, 1).build(is_enabled); base.clone().setpos(1, 2, 1, 1).build(robot_drive_mode); base.clone().setpos(0, 3, 2, 1).setfill(gridbagconstraints.none).build(new jlabel(\"alliance station\")); base.clone().setpos(0, 4, 1, 1).build(alliance_num); base.clone().setpos(1, 4, 1, 1).build(alliance_color); endr.clone().setpos(0, 5, 1, 1).build(new jlabel(\"team number:\")); base.clone().setpos(1, 5, 1, 1).setanchor(gridbagconstraints.line_start).build(team_number); endr.clone().setpos(0, 6, 1, 1).build(new jlabel(\"game data:\")); base.clone().setpos(1, 6, 1, 1).setanchor(gridbagconstraints.line_start).build(game_data); endr.clone().setpos(0, 7, 1, 1).build(new jlabel(\"protocol year:\")); base.clone().setpos(1, 7, 1, 1).setanchor(gridbagconstraints.line_start).build(protocol_year); base.clone().setpos(2, 2, 2, 1).build(restart_code_btn); base.clone().setpos(2, 3, 2, 1).build(restart_robo_rio_btn); base.clone().setpos(2, 4, 2, 1).build(estop_btn); base.clone().setpos(2, 5, 1, 1).build(js_btn); base.clone().setpos(3, 5, 1, 1).build(stats_btn); base.clone().setpos(2, 6, 1, 1).build(nt_btn); base.clone().setpos(3, 6, 1, 1).build(log_btn); base.clone().setpos(2, 7, 1, 1).build(fms_connect); base.clone().setpos(3, 7, 1, 1).build(usb_connect); base.clone().setpos(4, 2, 2, 1).setfill(gridbagconstraints.none).build(bat_voltage); endr.clone().setpos(4, 3, 1, 1).build(new jlabel(\"robot:\")); base.clone().setpos(5, 3, 1, 1).setanchor(gridbagconstraints.line_start).build(robot_connection_status); endr.clone().setpos(4, 4, 1, 1).build(new jlabel(\"code: \")); base.clone().setpos(5, 4, 1, 1).setanchor(gridbagconstraints.line_start).build(robot_code_status); endr.clone().setpos(4, 5, 1, 1).build(new jlabel(\"estop: \")); base.clone().setpos(5, 5, 1, 1).setanchor(gridbagconstraints.line_start).build(estop_status); endr.clone().setpos(4, 6, 1, 1).build(new jlabel(\"fms: \")); base.clone().setpos(5, 6, 1, 1).setanchor(gridbagconstraints.line_start).build(fms_connection_status); endr.clone().setpos(4, 7, 1, 1).build(new jlabel(\"time: \")); base.clone().setpos(5, 7, 1, 1).setanchor(gridbagconstraints.line_start).build(match_time); }","comment":"\/\/todo remove after testing","repo":"Tecbot3158\/open-ds","code_context_2":"});\nRESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n\/\/TODO remove after testing\nTEAM_NUMBER.setText(\"localhost\");\nTEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());","code_context_10":"public void run() {\nNetworkReloader.reloadRio(Protocol.UDP);\nNetworkReloader.reloadRio(Protocol.TCP);\nsuper.run();\ninterrupt();\n}\n};\nreload.start();\n});\nRESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n\/\/TODO remove after testing\nTEAM_NUMBER.setText(\"localhost\");\nTEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\nIS_ENABLED.setEnabled(false);\nGlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n.addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n.addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\nGBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\nbase.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\nbase.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\nbase.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));","code_context_20":"NT_BTN.addActionListener((e) -> {\nif (!PopupBase.isAlive(NTFrame.class)) {\nNT_FRAME = new NTFrame();\n} else {\nPopupBase.getAlive(NTFrame.class).reopen();\n}\n});\nUSB_CONNECT.addActionListener((e) -> {\nThread reload = new Thread() {\n@Override\npublic void run() {\nNetworkReloader.reloadRio(Protocol.UDP);\nNetworkReloader.reloadRio(Protocol.TCP);\nsuper.run();\ninterrupt();\n}\n};\nreload.start();\n});\nRESTART_CODE_BTN.addActionListener(e -> IS_ENABLED.setSelected(false));\n\/\/TODO remove after testing\nTEAM_NUMBER.setText(\"localhost\");\nTEAM_NUMBER.getDocument().addDocumentListener(new TeamNumListener());\nIS_ENABLED.setEnabled(false);\nGlobalScreen.addNativeKeyListener(GlobalKeyListener.INSTANCE\n.addKeyEvent(NativeKeyEvent.VC_ENTER, () -> MainJDEC.IS_ENABLED.setSelected(false))\n.addKeyEvent(NativeKeyEvent.VC_SPACE, MainJDEC.ESTOP_BTN::doClick));\nGBCPanelBuilder endr = base.clone().setAnchor(GridBagConstraints.LINE_END).setFill(GridBagConstraints.NONE);\nbase.clone().setPos(0, 0, 6, 1).setFill(GridBagConstraints.NONE).build(TITLE);\nbase.clone().setPos(0, 1, 6, 1).setFill(GridBagConstraints.NONE).build(LINK);\nbase.clone().setPos(5, 0, 1, 2).setFill(GridBagConstraints.NONE).build(new JLabel(new ImageIcon(MainFrame.ICON_MIN)));\nbase.clone().setPos(0, 2, 1, 1).build(IS_ENABLED);\nbase.clone().setPos(1, 2, 1, 1).build(ROBOT_DRIVE_MODE);\nbase.clone().setPos(0, 3, 2, 1).setFill(GridBagConstraints.NONE).build(new JLabel(\"Alliance Station\"));\nbase.clone().setPos(0, 4, 1, 1).build(ALLIANCE_NUM);\nbase.clone().setPos(1, 4, 1, 1).build(ALLIANCE_COLOR);\nendr.clone().setPos(0, 5, 1, 1).build(new JLabel(\"Team Number:\"));\nbase.clone().setPos(1, 5, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(TEAM_NUMBER);\nendr.clone().setPos(0, 6, 1, 1).build(new JLabel(\"Game Data:\"));\nbase.clone().setPos(1, 6, 1, 1).setAnchor(GridBagConstraints.LINE_START).build(GAME_DATA);\nendr.clone().setPos(0, 7, 1, 1).build(new JLabel(\"Protocol Year:\"));","label":[1,0,0,0]}
{"id":20824,"original_code":"public static String[] getStorageDirectories(boolean includePrimary)\n    {\n        final Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n        \/\/ Final set of paths\n        final Set<String> rv = new HashSet<String>();\n        \/\/ Primary physical SD-CARD (not emulated)\n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n        \/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n        \/\/ Primary emulated SD-CARD\n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if(includePrimary) {\n            if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n                \/\/ Device has physical external storage; use plain paths.\n                if (TextUtils.isEmpty(rawExternalStorage)) {\n                    \/\/ EXTERNAL_STORAGE undefined; falling back to default.\n                    rv.add(\"\/storage\/sdcard0\");\n                } else {\n                    rv.add(rawExternalStorage);\n                }\n            } else {\n                \/\/ Device has emulated storage; external storage paths should have\n                \/\/ userId burned into them.\n                final String rawUserId;\n                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n                    rawUserId = \"\";\n                } else {\n                    final String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\n                    final String[] folders = DIR_SEPARATOR.split(path);\n                    final String lastFolder = folders[folders.length - 1];\n                    boolean isDigit = false;\n                    try {\n                        Integer.valueOf(lastFolder);\n                        isDigit = true;\n                    } catch (NumberFormatException ignored) {\n                    }\n                    rawUserId = isDigit ? lastFolder : \"\";\n                }\n                \/\/ \/storage\/emulated\/0[1,2,...]\n                if (TextUtils.isEmpty(rawUserId)) {\n                    rv.add(rawEmulatedStorageTarget);\n                } else {\n                    rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n                }\n            }\n        }\n        \/\/ Add all secondary storages\n        if(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n        {\n            \/\/ All Secondary SD-CARDs splited into array\n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        return rv.toArray(new String[0]);\n    }","code":"public static String[] getStorageDirectories(boolean includePrimary)\n    {\n        final Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n       \n        final Set<String> rv = new HashSet<String>();\n       \n        final String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n       \n        final String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n       \n        final String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\n        if(includePrimary) {\n            if (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n               \n                if (TextUtils.isEmpty(rawExternalStorage)) {\n                   \n                    rv.add(\"\/storage\/sdcard0\");\n                } else {\n                    rv.add(rawExternalStorage);\n                }\n            } else {\n               \n               \n                final String rawUserId;\n                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n                    rawUserId = \"\";\n                } else {\n                    final String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\n                    final String[] folders = DIR_SEPARATOR.split(path);\n                    final String lastFolder = folders[folders.length - 1];\n                    boolean isDigit = false;\n                    try {\n                        Integer.valueOf(lastFolder);\n                        isDigit = true;\n                    } catch (NumberFormatException ignored) {\n                    }\n                    rawUserId = isDigit ? lastFolder : \"\";\n                }\n               \n                if (TextUtils.isEmpty(rawUserId)) {\n                    rv.add(rawEmulatedStorageTarget);\n                } else {\n                    rv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n                }\n            }\n        }\n       \n        if(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n        {\n           \n            final String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\n            Collections.addAll(rv, rawSecondaryStorages);\n        }\n        return rv.toArray(new String[0]);\n    }","cleancode":"public static string[] getstoragedirectories(boolean includeprimary) { final pattern dir_separator = pattern.compile(\"\/\"); final set<string> rv = new hashset<string>(); final string rawexternalstorage = system.getenv(\"external_storage\"); final string rawsecondarystoragesstr = system.getenv(\"secondary_storage\"); final string rawemulatedstoragetarget = system.getenv(\"emulated_storage_target\"); if(includeprimary) { if (textutils.isempty(rawemulatedstoragetarget)) { if (textutils.isempty(rawexternalstorage)) { rv.add(\"\/storage\/sdcard0\"); } else { rv.add(rawexternalstorage); } } else { final string rawuserid; if (build.version.sdk_int < build.version_codes.jelly_bean_mr1) { rawuserid = \"\"; } else { final string path = android.os.environment.getexternalstoragedirectory().getabsolutepath(); final string[] folders = dir_separator.split(path); final string lastfolder = folders[folders.length - 1]; boolean isdigit = false; try { integer.valueof(lastfolder); isdigit = true; } catch (numberformatexception ignored) { } rawuserid = isdigit ? lastfolder : \"\"; } if (textutils.isempty(rawuserid)) { rv.add(rawemulatedstoragetarget); } else { rv.add(rawemulatedstoragetarget + file.separator + rawuserid); } } } if(!textutils.isempty(rawsecondarystoragesstr)) { final string[] rawsecondarystorages = rawsecondarystoragesstr.split(file.pathseparator); collections.addall(rv, rawsecondarystorages); } return rv.toarray(new string[0]); }","comment":"\/** * returns all available sd-cards in the system (include emulated) * * warning: hack! based on android source code of version 4.3 (api 18) * because there is no standart way to get it. * todo: test on future android versions 4.4+ * * @return paths to all available sd-cards in the system (include emulated) *\/\n\/\/ final set of paths\n\/\/ primary physical sd-card (not emulated)\n\/\/ all secondary sd-cards (all exclude primary) separated by \":\"\n\/\/ primary emulated sd-card\n\/\/ device has physical external storage; use plain paths.\n\/\/ external_storage undefined; falling back to default.\n\/\/ device has emulated storage; external storage paths should have \/\/ userid burned into them.\n\/\/ \/storage\/emulated\/0[1,2,...]\n\/\/ add all secondary storages\n\/\/ all secondary sd-cards splited into array","repo":"acestream\/acestream-android-sdk","code_context_2":"public static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\n\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\n\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\n\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\n\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\n\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\n\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);","code_context_10":"public static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\n\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\n\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}","code_context_20":"public static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n\npublic static String[] getStorageDirectories(boolean includePrimary)\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\n\n{\nfinal Pattern DIR_SEPARATOR = Pattern.compile(\"\/\");\n\/\/ Final set of paths\nfinal Set<String> rv = new HashSet<String>();\n\/\/ Primary physical SD-CARD (not emulated)\nfinal String rawExternalStorage = System.getenv(\"EXTERNAL_STORAGE\");\n\/\/ All Secondary SD-CARDs (all exclude primary) separated by \":\"\nfinal String rawSecondaryStoragesStr = System.getenv(\"SECONDARY_STORAGE\");\n\/\/ Primary emulated SD-CARD\nfinal String rawEmulatedStorageTarget = System.getenv(\"EMULATED_STORAGE_TARGET\");\nif(includePrimary) {\nif (TextUtils.isEmpty(rawEmulatedStorageTarget)) {\n\/\/ Device has physical external storage; use plain paths.\nif (TextUtils.isEmpty(rawExternalStorage)) {\n\/\/ EXTERNAL_STORAGE undefined; falling back to default.\nrv.add(\"\/storage\/sdcard0\");\n} else {\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n\nrv.add(rawExternalStorage);\n}\n} else {\n\/\/ Device has emulated storage; external storage paths should have\n\/\/ userId burned into them.\nfinal String rawUserId;\nif (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {\nrawUserId = \"\";\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\n} else {\nfinal String path = android.os.Environment.getExternalStorageDirectory().getAbsolutePath();\nfinal String[] folders = DIR_SEPARATOR.split(path);\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}\n\nfinal String lastFolder = folders[folders.length - 1];\nboolean isDigit = false;\ntry {\nInteger.valueOf(lastFolder);\nisDigit = true;\n} catch (NumberFormatException ignored) {\n}\nrawUserId = isDigit ? lastFolder : \"\";\n}\n\/\/ \/storage\/emulated\/0[1,2,...]\nif (TextUtils.isEmpty(rawUserId)) {\nrv.add(rawEmulatedStorageTarget);\n} else {\nrv.add(rawEmulatedStorageTarget + File.separator + rawUserId);\n}\n}\n}\n\/\/ Add all secondary storages\nif(!TextUtils.isEmpty(rawSecondaryStoragesStr))\n{\n\/\/ All Secondary SD-CARDs splited into array\nfinal String[] rawSecondaryStorages = rawSecondaryStoragesStr.split(File.pathSeparator);\nCollections.addAll(rv, rawSecondaryStorages);\n}\nreturn rv.toArray(new String[0]);\n}","label":[0,0,0,1]}
{"id":20869,"original_code":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\n        HttpEntity<Object> entity = new HttpEntity<>(args, headers);\n        ResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            System.out.println(response.getBody());\n        } else {\n            System.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n        }\n    }","code":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\n        HttpEntity<Object> entity = new HttpEntity<>(args, headers);\n        ResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\n        if (response.getStatusCode().is2xxSuccessful()) {\n            System.out.println(response.getBody());\n        } else {\n            System.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n        }\n    }","cleancode":"private void execute(object args, string url, httpheaders headers, httpmethod method) { httpentity<object> entity = new httpentity<>(args, headers); responseentity<object> response = resttemplate.exchange(url, method, entity, object.class); if (response.getstatuscode().is2xxsuccessful()) { system.out.println(response.getbody()); } else { system.out.println(\"error! \" + response.getstatuscode().name() + \": \" + response.getbody()); } }","comment":"\/\/ todo error handling, 429 handling","repo":"TONY-All\/Hangar","code_context_2":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\nHttpEntity<Object> entity = new HttpEntity<>(args, headers);\nResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\nif (response.getStatusCode().is2xxSuccessful()) {\nSystem.out.println(response.getBody());\n} else {\nSystem.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n}\n}","code_context_10":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\nHttpEntity<Object> entity = new HttpEntity<>(args, headers);\nResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\nif (response.getStatusCode().is2xxSuccessful()) {\nSystem.out.println(response.getBody());\n} else {\nSystem.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n}\n}","code_context_20":"private void execute(Object args, String url, HttpHeaders headers, HttpMethod method) {\nHttpEntity<Object> entity = new HttpEntity<>(args, headers);\nResponseEntity<Object> response = restTemplate.exchange(url, method, entity, Object.class);\nif (response.getStatusCode().is2xxSuccessful()) {\nSystem.out.println(response.getBody());\n} else {\nSystem.out.println(\"error! \" + response.getStatusCode().name() + \": \" + response.getBody());\n}\n}","label":[0,0,1,0]}
{"id":20888,"original_code":"private static void LoadSpriteTables()\n\t{\n\t\t\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\t\t\/\/final FileList files = files_win;\n\t\tfinal String[] files = files_win;\n\t\tint load_index;\n\t\tint i;\n\t\t\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\n\t\tLoadGrfIndexed(files[0], trg1idx, 0);\n\t\tSpriteCache.DupSprite(  2, 130); \/\/ non-breaking space medium\n\t\tSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\n\t\tSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\n\t\tload_index = 4793;\n\t\t\/\/ TODO why start from 1?\n\t\t\/\/for (i = 1; files.basic[i].filename != null; i++) {\n\t\tfor (i = 1; files[i] != null; i++) {\n\t\t\tload_index += LoadGrfFile(files[i], load_index, i);\n\t\t}\n\t\tif (_sprite_page_to_load != 0) {\n\t\t\tLoadGrfIndexed(\n\t\t\t\t\tfiles_landscape[_sprite_page_to_load - 1],\n\t\t\t\t\t\/\/files.landscape[_sprite_page_to_load - 1].filename,\n\t\t\t\t\t_landscape_spriteindexes[_sprite_page_to_load - 1],\n\t\t\t\t\ti++\n\t\t\t\t\t);\n\t\t}\n\t\tassert(load_index == Sprites.SPR_CANALS_BASE);\n\t\tload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_SLOPES_BASE);\n\t\t\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\n\t\tLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\n\t\tload_index = Sprites.SPR_AUTORAIL_BASE;\n\t\tload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_OPENTTD_BASE);\n\t\tLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\n\t\tload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\t\t\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason. \n\t\t\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\t\t\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\t\t\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\t\t\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\t\t\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\t\t\/\/ TODO make deep copy??\n\t\t\/\/Global._engine_info =  EngineTables2.orig_engine_info;\n\t\t\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_engine_info, 0, \n\t\t\t\tGlobal._engine_info, 0, Global._engine_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_rail_vehicle_info , 0, \n\t\t\t\tGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_ship_vehicle_info, 0, \n\t\t\t\tGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_aircraft_vehicle_info, 0, \n\t\t\t\tGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_road_vehicle_info, 0, \n\t\t\t\tGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\n\t\tBridge.loadOrigBridges();\n\t\t\/\/ Unload sprite group data\n\t\tEngine.UnloadWagonOverrides();\n\t\tEngine.UnloadCustomEngineSprites();\n\t\tEngine.UnloadCustomEngineNames();\n\t\t\/\/ Reset price base data\n\t\tEconomy.ResetPriceBaseMultipliers();\n\t\t\/\/ TODO was called from LoadNewGRF \n\t\tGRFFile.ResetNewGRFData();\n\t\tGRFFile.LoadNewGRF(load_index, i);\n\t}","code":"private static void LoadSpriteTables()\n\t{\n\t\n\t\n\t\tfinal String[] files = files_win;\n\t\tint load_index;\n\t\tint i;\n\t\n\t\tLoadGrfIndexed(files[0], trg1idx, 0);\n\t\tSpriteCache.DupSprite(  2, 130);\n\t\tSpriteCache.DupSprite(226, 354);\n\t\tSpriteCache.DupSprite(450, 578);\n\t\tload_index = 4793;\n\t\n\t\n\t\tfor (i = 1; files[i] != null; i++) {\n\t\t\tload_index += LoadGrfFile(files[i], load_index, i);\n\t\t}\n\t\tif (_sprite_page_to_load != 0) {\n\t\t\tLoadGrfIndexed(\n\t\t\t\t\tfiles_landscape[_sprite_page_to_load - 1],\n\t\t\t\t\n\t\t\t\t\t_landscape_spriteindexes[_sprite_page_to_load - 1],\n\t\t\t\t\ti++\n\t\t\t\t\t);\n\t\t}\n\t\tassert(load_index == Sprites.SPR_CANALS_BASE);\n\t\tload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_SLOPES_BASE);\n\t\n\t\tLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\n\t\tload_index = Sprites.SPR_AUTORAIL_BASE;\n\t\tload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\n\t\tassert(load_index == Sprites.SPR_OPENTTD_BASE);\n\t\tLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\n\t\tload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_engine_info, 0, \n\t\t\t\tGlobal._engine_info, 0, Global._engine_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_rail_vehicle_info , 0, \n\t\t\t\tGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_ship_vehicle_info, 0, \n\t\t\t\tGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_aircraft_vehicle_info, 0, \n\t\t\t\tGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\n\t\tSystem.arraycopy(\n\t\t\t\tEngineTables2.orig_road_vehicle_info, 0, \n\t\t\t\tGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\n\t\tBridge.loadOrigBridges();\n\t\n\t\tEngine.UnloadWagonOverrides();\n\t\tEngine.UnloadCustomEngineSprites();\n\t\tEngine.UnloadCustomEngineNames();\n\t\n\t\tEconomy.ResetPriceBaseMultipliers();\n\t\n\t\tGRFFile.ResetNewGRFData();\n\t\tGRFFile.LoadNewGRF(load_index, i);\n\t}","cleancode":"private static void loadspritetables() { final string[] files = files_win; int load_index; int i; loadgrfindexed(files[0], trg1idx, 0); spritecache.dupsprite( 2, 130); spritecache.dupsprite(226, 354); spritecache.dupsprite(450, 578); load_index = 4793; for (i = 1; files[i] != null; i++) { load_index += loadgrffile(files[i], load_index, i); } if (_sprite_page_to_load != 0) { loadgrfindexed( files_landscape[_sprite_page_to_load - 1], _landscape_spriteindexes[_sprite_page_to_load - 1], i++ ); } assert(load_index == sprites.spr_canals_base); load_index += loadgrffile(\"canalsw.grf\", load_index, i++); assert(load_index == sprites.spr_slopes_base); loadgrfindexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++); load_index = sprites.spr_autorail_base; load_index += loadgrffile(\"autorail.grf\", load_index, i++); assert(load_index == sprites.spr_openttd_base); loadgrfindexed(\"openttd.grf\", _openttd_grf_indexes, i++); load_index = sprites.spr_openttd_base + openttd_sprites_count; system.arraycopy( enginetables2.orig_engine_info, 0, global._engine_info, 0, global._engine_info.length ); system.arraycopy( enginetables2.orig_rail_vehicle_info , 0, global._rail_vehicle_info, 0, global._rail_vehicle_info.length ); system.arraycopy( enginetables2.orig_ship_vehicle_info, 0, global._ship_vehicle_info, 0, global._ship_vehicle_info.length ); system.arraycopy( enginetables2.orig_aircraft_vehicle_info, 0, global._aircraft_vehicle_info, 0, global._aircraft_vehicle_info.length ); system.arraycopy( enginetables2.orig_road_vehicle_info, 0, global._road_vehicle_info, 0, global._road_vehicle_info.length ); bridge.loadorigbridges(); engine.unloadwagonoverrides(); engine.unloadcustomenginesprites(); engine.unloadcustomenginenames(); economy.resetpricebasemultipliers(); grffile.resetnewgrfdata(); grffile.loadnewgrf(load_index, i); }","comment":"\/\/private static boolean _use_dos_palette = false;\n\/\/final filelist files = _use_dos_palette ? files_dos : files_win; \/\/final filelist files = files_win;\n\/\/loadgrfindexed(files.basic[0].filename, trg1idx, 0);\n\/\/ non-breaking space medium\n\/\/ non-breaking space tiny\n\/\/ non-breaking space large\n\/\/ todo why start from 1? \/\/for (i = 1; files.basic[i].filename != null; i++) {\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n\/\/ todo loadgrfindexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\n\/\/ [dz] wrong place, but it was in loadnewgrf for some reason. \/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info)); \/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info)); \/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info)); \/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info)); \/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info)); \/\/ todo make deep copy?? \/\/global._engine_info = enginetables2.orig_engine_info; \/\/for( engineinfo ei : enginetables2.orig_engine_info )\n\/\/ unload sprite group data\n\/\/ reset price base data\n\/\/ todo was called from loadnewgrf","repo":"alexey-lukyanenko\/jdrive","code_context_2":"private static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\n\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\n\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\n\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\n\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\n\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\n\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\n\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);","code_context_10":"private static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\n\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\n\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}","code_context_20":"private static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\n\nprivate static void LoadSpriteTables()\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\n\n{\n\/\/final FileList files = _use_dos_palette ? files_dos : files_win;\n\/\/final FileList files = files_win;\nfinal String[] files = files_win;\nint load_index;\nint i;\n\/\/LoadGrfIndexed(files.basic[0].filename, trg1idx, 0);\nLoadGrfIndexed(files[0], trg1idx, 0);\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\nSpriteCache.DupSprite( 2, 130); \/\/ non-breaking space medium\nSpriteCache.DupSprite(226, 354); \/\/ non-breaking space tiny\nSpriteCache.DupSprite(450, 578); \/\/ non-breaking space large\nload_index = 4793;\n\/\/ TODO why start from 1?\n\/\/for (i = 1; files.basic[i].filename != null; i++) {\nfor (i = 1; files[i] != null; i++) {\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\n\nload_index += LoadGrfFile(files[i], load_index, i);\n}\nif (_sprite_page_to_load != 0) {\nLoadGrfIndexed(\nfiles_landscape[_sprite_page_to_load - 1],\n\/\/files.landscape[_sprite_page_to_load - 1].filename,\n_landscape_spriteindexes[_sprite_page_to_load - 1],\ni++\n);\n}\nassert(load_index == Sprites.SPR_CANALS_BASE);\nload_index += LoadGrfFile(\"canalsw.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_SLOPES_BASE);\n\/\/ TODO LoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_opt.landscape], i++);\nLoadGrfIndexed(\"trkfoundw.grf\", _slopes_spriteindexes[_sprite_page_to_load], i++);\nload_index = Sprites.SPR_AUTORAIL_BASE;\nload_index += LoadGrfFile(\"autorail.grf\", load_index, i++);\nassert(load_index == Sprites.SPR_OPENTTD_BASE);\nLoadGrfIndexed(\"openttd.grf\", _openttd_grf_indexes, i++);\nload_index = Sprites.SPR_OPENTTD_BASE + OPENTTD_SPRITES_COUNT;\n\/\/ [dz] wrong place, but it was in LoadNewGRF for some reason.\n\/\/memcpy(&_engine_info, &orig_engine_info, sizeof(orig_engine_info));\n\/\/memcpy(&_rail_vehicle_info, &orig_rail_vehicle_info, sizeof(orig_rail_vehicle_info));\n\/\/memcpy(&_ship_vehicle_info, &orig_ship_vehicle_info, sizeof(orig_ship_vehicle_info));\n\/\/memcpy(&_aircraft_vehicle_info, &orig_aircraft_vehicle_info, sizeof(orig_aircraft_vehicle_info));\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\n\/\/memcpy(&_road_vehicle_info, &orig_road_vehicle_info, sizeof(orig_road_vehicle_info));\n\/\/ TODO make deep copy??\n\/\/Global._engine_info = EngineTables2.orig_engine_info;\n\/\/for( EngineInfo ei : EngineTables2.orig_engine_info )\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nSystem.arraycopy(\nEngineTables2.orig_engine_info, 0,\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}\n\nGlobal._engine_info, 0, Global._engine_info.length );\nSystem.arraycopy(\nEngineTables2.orig_rail_vehicle_info , 0,\nGlobal._rail_vehicle_info, 0, Global._rail_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_ship_vehicle_info, 0,\nGlobal._ship_vehicle_info, 0, Global._ship_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_aircraft_vehicle_info, 0,\nGlobal._aircraft_vehicle_info, 0, Global._aircraft_vehicle_info.length );\nSystem.arraycopy(\nEngineTables2.orig_road_vehicle_info, 0,\nGlobal._road_vehicle_info, 0, Global._road_vehicle_info.length );\nBridge.loadOrigBridges();\n\/\/ Unload sprite group data\nEngine.UnloadWagonOverrides();\nEngine.UnloadCustomEngineSprites();\nEngine.UnloadCustomEngineNames();\n\/\/ Reset price base data\nEconomy.ResetPriceBaseMultipliers();\n\/\/ TODO was called from LoadNewGRF\nGRFFile.ResetNewGRFData();\nGRFFile.LoadNewGRF(load_index, i);\n}","label":[1,1,0,0]}
{"id":13084,"original_code":"@Override\n    public void addContentView(View view) {\n        \/\/todo add you childView to rootView , Usually not youself  layout the View!\n        addView(view);\n    }","code":"@Override\n    public void addContentView(View view) {\n       \n        addView(view);\n    }","cleancode":"@override public void addcontentview(view view) { addview(view); }","comment":"\/\/todo add you childview to rootview , usually not youself layout the view!","repo":"Tamicer\/FilterBar","code_context_2":"@Override\npublic void addContentView(View view) {\n\/\/todo add you childView to rootView , Usually not youself layout the View!\naddView(view);\n}","code_context_10":"@Override\npublic void addContentView(View view) {\n\/\/todo add you childView to rootView , Usually not youself layout the View!\naddView(view);\n}","code_context_20":"@Override\npublic void addContentView(View view) {\n\/\/todo add you childView to rootView , Usually not youself layout the View!\naddView(view);\n}","label":[0,1,0,0]}
{"id":13100,"original_code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n            \/\/ todo change the file location\/name according to your needs\n            File futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[4096];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        Log.d(\"writeResponseBodyToDisk\", \"file download: \" + fileSizeDownloaded + \" of \" + fileSize);\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n           \n            File futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[4096];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        Log.d(\"writeResponseBodyToDisk\", \"file download: \" + fileSizeDownloaded + \" of \" + fileSize);\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","cleancode":"private boolean writeresponsebodytodisk(responsebody body) { try { file futurestudioiconfile = new file(getexternalfilesdir(null) + file.separator + nombreeditar + \".jpg\"); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[4096]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { log.d(\"writeresponsebodytodisk\", \"file download: \" + filesizedownloaded + \" of \" + filesize); break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) { return false; } finally { if (inputstream != null) { inputstream.close(); } if (outputstream != null) { outputstream.close(); } } } catch (ioexception e) { return false; } }","comment":"\/\/ todo change the file location\/name according to your needs","repo":"UNIZAR-30226-2021-14\/Front-end","code_context_2":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\nInputStream inputStream = null;","code_context_10":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\nInputStream inputStream = null;\nOutputStream outputStream = null;\ntry {\nbyte[] fileReader = new byte[4096];\nlong fileSize = body.contentLength();\nlong fileSizeDownloaded = 0;\ninputStream = body.byteStream();\noutputStream = new FileOutputStream(futureStudioIconFile);\nwhile (true) {","code_context_20":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(getExternalFilesDir(null) + File.separator + nombreEditar + \".jpg\");\nInputStream inputStream = null;\nOutputStream outputStream = null;\ntry {\nbyte[] fileReader = new byte[4096];\nlong fileSize = body.contentLength();\nlong fileSizeDownloaded = 0;\ninputStream = body.byteStream();\noutputStream = new FileOutputStream(futureStudioIconFile);\nwhile (true) {\nint read = inputStream.read(fileReader);\nif (read == -1) {\nLog.d(\"writeResponseBodyToDisk\", \"file download: \" + fileSizeDownloaded + \" of \" + fileSize);\nbreak;\n}\noutputStream.write(fileReader, 0, read);\nfileSizeDownloaded += read;\n}\noutputStream.flush();\nreturn true;","label":[1,0,0,0]}
{"id":13511,"original_code":"@Override\n    public GraphStageLogic createLogic(Attributes attr) throws Exception {\n        JsonParser parser = new JsonParser();\n        return new GraphStageLogic(shape) {\n            {\n                setHandler(out, new AbstractOutHandler() {\n                    @Override\n                    public void onPull() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                });\n                setHandler(in, new AbstractInHandler() {\n                    @Override\n                    public void onPush() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        ByteString bytes = grab(in);\n                        \/\/ TODO either PR ByteBuffer support into actson, or sneaky-access the underlying byte array fields here\n                        for (ByteBuffer b: bytes.getByteBuffers()) {\n                            byte[] buf= new byte[b.remaining()];\n                            b.get(buf, 0, b.remaining());\n                            int i = 0;\n                            while (i < buf.length) {\n                              i += parser.getFeeder().feed(buf, i, buf.length - i);\n                              parseInto(events);\n                            }\n                        }\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                    public void onUpstreamFinish() throws Exception {\n                        parser.getFeeder().done();\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        emitMultiple(out, events.iterator());\n                        complete(out);\n                    }\n                });\n            }\n            private void parseInto(List<JSONEvent> events) {\n                Option<JSONEvent> evt = next();\n                while (evt.isDefined()) {\n                    events.add(evt.get());\n                    evt = next();\n                }\n            };\n            private Option<JSONEvent> next() {\n                switch(parser.nextEvent()) {\n                case JsonEvent.END_ARRAY: return some(JSONEvent.END_ARRAY);\n                case JsonEvent.END_OBJECT: return some(JSONEvent.END_OBJECT);\n                case JsonEvent.ERROR: throw new IllegalArgumentException(\"There was a parse error at around character \" + parser.getParsedCharacterCount());\n                case JsonEvent.EOF: return none();\n                case JsonEvent.FIELD_NAME: return some(new JSONEvent.FieldName(parser.getCurrentString()));\n                case JsonEvent.NEED_MORE_INPUT: return none();\n                case JsonEvent.START_ARRAY: return some(JSONEvent.START_ARRAY);\n                case JsonEvent.START_OBJECT: return some(JSONEvent.START_OBJECT);\n                case JsonEvent.VALUE_DOUBLE: return some(new JSONEvent.NumericValue(String.valueOf(parser.getCurrentDouble())));\n                case JsonEvent.VALUE_FALSE: return some(JSONEvent.FALSE);\n                case JsonEvent.VALUE_INT: return some(new JSONEvent.NumericValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_NULL: return some(JSONEvent.NULL);\n                case JsonEvent.VALUE_STRING: return some(new JSONEvent.StringValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_TRUE: return some(JSONEvent.TRUE);\n                default: throw new UnsupportedOperationException(\"Unexpected event in JSON parser\");\n                }\n            }\n        };\n    }","code":"@Override\n    public GraphStageLogic createLogic(Attributes attr) throws Exception {\n        JsonParser parser = new JsonParser();\n        return new GraphStageLogic(shape) {\n            {\n                setHandler(out, new AbstractOutHandler() {\n                    @Override\n                    public void onPull() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                });\n                setHandler(in, new AbstractInHandler() {\n                    @Override\n                    public void onPush() throws Exception {\n                        List<JSONEvent> events = new ArrayList<>();\n                        ByteString bytes = grab(in);\n                       \n                        for (ByteBuffer b: bytes.getByteBuffers()) {\n                            byte[] buf= new byte[b.remaining()];\n                            b.get(buf, 0, b.remaining());\n                            int i = 0;\n                            while (i < buf.length) {\n                              i += parser.getFeeder().feed(buf, i, buf.length - i);\n                              parseInto(events);\n                            }\n                        }\n                        if (events.isEmpty()) {\n                            pull(in);\n                        } else {\n                            emitMultiple(out, events.iterator());\n                        }\n                    }\n                    public void onUpstreamFinish() throws Exception {\n                        parser.getFeeder().done();\n                        List<JSONEvent> events = new ArrayList<>();\n                        parseInto(events);\n                        emitMultiple(out, events.iterator());\n                        complete(out);\n                    }\n                });\n            }\n            private void parseInto(List<JSONEvent> events) {\n                Option<JSONEvent> evt = next();\n                while (evt.isDefined()) {\n                    events.add(evt.get());\n                    evt = next();\n                }\n            };\n            private Option<JSONEvent> next() {\n                switch(parser.nextEvent()) {\n                case JsonEvent.END_ARRAY: return some(JSONEvent.END_ARRAY);\n                case JsonEvent.END_OBJECT: return some(JSONEvent.END_OBJECT);\n                case JsonEvent.ERROR: throw new IllegalArgumentException(\"There was a parse error at around character \" + parser.getParsedCharacterCount());\n                case JsonEvent.EOF: return none();\n                case JsonEvent.FIELD_NAME: return some(new JSONEvent.FieldName(parser.getCurrentString()));\n                case JsonEvent.NEED_MORE_INPUT: return none();\n                case JsonEvent.START_ARRAY: return some(JSONEvent.START_ARRAY);\n                case JsonEvent.START_OBJECT: return some(JSONEvent.START_OBJECT);\n                case JsonEvent.VALUE_DOUBLE: return some(new JSONEvent.NumericValue(String.valueOf(parser.getCurrentDouble())));\n                case JsonEvent.VALUE_FALSE: return some(JSONEvent.FALSE);\n                case JsonEvent.VALUE_INT: return some(new JSONEvent.NumericValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_NULL: return some(JSONEvent.NULL);\n                case JsonEvent.VALUE_STRING: return some(new JSONEvent.StringValue(parser.getCurrentString()));\n                case JsonEvent.VALUE_TRUE: return some(JSONEvent.TRUE);\n                default: throw new UnsupportedOperationException(\"Unexpected event in JSON parser\");\n                }\n            }\n        };\n    }","cleancode":"@override public graphstagelogic createlogic(attributes attr) throws exception { jsonparser parser = new jsonparser(); return new graphstagelogic(shape) { { sethandler(out, new abstractouthandler() { @override public void onpull() throws exception { list<jsonevent> events = new arraylist<>(); parseinto(events); if (events.isempty()) { pull(in); } else { emitmultiple(out, events.iterator()); } } }); sethandler(in, new abstractinhandler() { @override public void onpush() throws exception { list<jsonevent> events = new arraylist<>(); bytestring bytes = grab(in); for (bytebuffer b: bytes.getbytebuffers()) { byte[] buf= new byte[b.remaining()]; b.get(buf, 0, b.remaining()); int i = 0; while (i < buf.length) { i += parser.getfeeder().feed(buf, i, buf.length - i); parseinto(events); } } if (events.isempty()) { pull(in); } else { emitmultiple(out, events.iterator()); } } public void onupstreamfinish() throws exception { parser.getfeeder().done(); list<jsonevent> events = new arraylist<>(); parseinto(events); emitmultiple(out, events.iterator()); complete(out); } }); } private void parseinto(list<jsonevent> events) { option<jsonevent> evt = next(); while (evt.isdefined()) { events.add(evt.get()); evt = next(); } }; private option<jsonevent> next() { switch(parser.nextevent()) { case jsonevent.end_array: return some(jsonevent.end_array); case jsonevent.end_object: return some(jsonevent.end_object); case jsonevent.error: throw new illegalargumentexception(\"there was a parse error at around character \" + parser.getparsedcharactercount()); case jsonevent.eof: return none(); case jsonevent.field_name: return some(new jsonevent.fieldname(parser.getcurrentstring())); case jsonevent.need_more_input: return none(); case jsonevent.start_array: return some(jsonevent.start_array); case jsonevent.start_object: return some(jsonevent.start_object); case jsonevent.value_double: return some(new jsonevent.numericvalue(string.valueof(parser.getcurrentdouble()))); case jsonevent.value_false: return some(jsonevent.false); case jsonevent.value_int: return some(new jsonevent.numericvalue(parser.getcurrentstring())); case jsonevent.value_null: return some(jsonevent.null); case jsonevent.value_string: return some(new jsonevent.stringvalue(parser.getcurrentstring())); case jsonevent.value_true: return some(jsonevent.true); default: throw new unsupportedoperationexception(\"unexpected event in json parser\"); } } }; }","comment":"\/\/ todo either pr bytebuffer support into actson, or sneaky-access the underlying byte array fields here","repo":"alar17\/ts-reaktive","code_context_2":"List<JSONEvent> events = new ArrayList<>();\nByteString bytes = grab(in);\n\/\/ TODO either PR ByteBuffer support into actson, or sneaky-access the underlying byte array fields here\nfor (ByteBuffer b: bytes.getByteBuffers()) {\nbyte[] buf= new byte[b.remaining()];","code_context_10":"} else {\nemitMultiple(out, events.iterator());\n}\n}\n});\nsetHandler(in, new AbstractInHandler() {\n@Override\npublic void onPush() throws Exception {\nList<JSONEvent> events = new ArrayList<>();\nByteString bytes = grab(in);\n\/\/ TODO either PR ByteBuffer support into actson, or sneaky-access the underlying byte array fields here\nfor (ByteBuffer b: bytes.getByteBuffers()) {\nbyte[] buf= new byte[b.remaining()];\nb.get(buf, 0, b.remaining());\nint i = 0;\nwhile (i < buf.length) {\ni += parser.getFeeder().feed(buf, i, buf.length - i);\nparseInto(events);\n}\n}\nif (events.isEmpty()) {","code_context_20":"JsonParser parser = new JsonParser();\nreturn new GraphStageLogic(shape) {\n{\nsetHandler(out, new AbstractOutHandler() {\n@Override\npublic void onPull() throws Exception {\nList<JSONEvent> events = new ArrayList<>();\nparseInto(events);\nif (events.isEmpty()) {\npull(in);\n} else {\nemitMultiple(out, events.iterator());\n}\n}\n});\nsetHandler(in, new AbstractInHandler() {\n@Override\npublic void onPush() throws Exception {\nList<JSONEvent> events = new ArrayList<>();\nByteString bytes = grab(in);\n\/\/ TODO either PR ByteBuffer support into actson, or sneaky-access the underlying byte array fields here\nfor (ByteBuffer b: bytes.getByteBuffers()) {\nbyte[] buf= new byte[b.remaining()];\nb.get(buf, 0, b.remaining());\nint i = 0;\nwhile (i < buf.length) {\ni += parser.getFeeder().feed(buf, i, buf.length - i);\nparseInto(events);\n}\n}\nif (events.isEmpty()) {\npull(in);\n} else {\nemitMultiple(out, events.iterator());\n}\n}\npublic void onUpstreamFinish() throws Exception {\nparser.getFeeder().done();\nList<JSONEvent> events = new ArrayList<>();\nparseInto(events);\nemitMultiple(out, events.iterator());","label":[1,0,0,0]}
{"id":13714,"original_code":"private void annotateInferredType(Tree tree, AnnotatedTypeMirror type) {\n        switch (tree.getKind()) {\n        case NEW_ARRAY:\n        case NEW_CLASS:\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(tree), type);\n            break;\n        case METHOD:\n            ExecutableElement methodElt = TreeUtils.elementFromDeclaration(\n                    (MethodTree) tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(methodElt), type);\n            break;\n        case TYPE_CAST:\n            if (!checker.isAnnotated(type)) {\n                Tree t = tree;\n                while (t.getKind() == Kind.TYPE_CAST) {\n                    t = ((TypeCastTree) t).getExpression();\n                    if (t instanceof ExpressionTree)\n                        t = TreeUtils.skipParens((ExpressionTree) t);\n                }\n                AnnotatedTypeMirror castType = getAnnotatedType(t);\n                InferenceUtils.assignAnnotations(type, castType);\n            }\n            break;\n        case METHOD_INVOCATION:\n            if (type.getKind() != TypeKind.VOID) {\n                MethodInvocationTree miTree = (MethodInvocationTree) tree;\n                ExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\n                ExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\n                if (ElementUtils.isStatic(iMethodElt)) {\n\/\/                    System.out.println(\"WARN: be supported in SFlowVisitor\");\n                } else {\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    AnnotatedTypeMirror rcvType = null;\n                    if (rcvTree != null) {\n                        \/\/ like x = y.m(z);\n                        rcvType = getAnnotatedType(rcvTree); \n                    } else if (currentMethod != null) {\n                        rcvType = getAnnotatedType(currentMethod).getReceiverType();\n                    }\n                    if (rcvType != null) {\n                        \/\/ Do viewpoint adaptation\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(\n                            rcvType.getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n                    }\n                }\n            }\n            break;\n        case VARIABLE:\n            \/\/ TODO: Consider using viewpoint adaptation\n            VariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n            \/\/ If there is an initialization for field, we need adapt it from \n            \/\/ ClassTree type\n            if (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\n                ClassTree classTree = this.getVisitorState().getClassTree();\n                TypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\n                AnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\n                InferenceMain.getInstance().getCurrentExtractor()\n                    .annotateInferredType(getIdentifier(classElt), defConstructorType);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n                        .getAnnotations(), type.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            }\n            break;\n        case IDENTIFIER:\n            Element idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n            \/\/ We don't want to annotate CLASS type\n            if (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\n                InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n                \/\/ May need viewpoint adaptation if it is a field\n\t\t\t\tif (idElt.getKind() == ElementKind.FIELD) {\n\t\t\t\t\t\/\/ We need to adapt it from PoV of THIS\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    if (currentMethod != null) {\n\t\t\t\t\t\tAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n\t\t\t\t\t\t\t\t.getReceiverType().getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\/\/ This happen in the static initializer \n                        \/\/ ignore\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n            break;\n        case ARRAY_ACCESS:\n            \/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2. \n            ArrayAccessTree aTree = (ArrayAccessTree) tree;\n            ExpressionTree aExpr = aTree.getExpression();\n            AnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\n            assert aExprType.getKind() == TypeKind.ARRAY;\n            Set<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n                    .getComponentType().getAnnotations();\n            Set<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\n                    aExprType.getAnnotations(), componentAnnos);\n            if (!adaptedAnnos.isEmpty()) {\n                type.clearAnnotations();\n                type.addAnnotations(adaptedAnnos);\n            }\n            break;\t\n        case MEMBER_SELECT:\n            \/\/ WEI: added on Aug 2\n            \/\/ WEI: Remove the above line, also considering remove the \n            \/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\n            MemberSelectTree mTree = (MemberSelectTree) tree;\n            Element fieldElt = TreeUtils.elementFromUse(mTree);\n            if (checker.isAccessOuterThis(mTree)) {\n                \/\/ If it is like Body.this\n                \/\/ FIXME:\n                MethodTree methodTree = this.getVisitorState().getMethodTree();\n                if (methodTree != null) {\n                    ExecutableElement currentMethodElt = TreeUtils\n                            .elementFromDeclaration(methodTree);\n                    Element outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\n                    Reference inferredRef = null;\n                    if (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n                    } else {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n                    }\n                    if (inferredRef != null)\n                        InferenceUtils.annotateReferenceType(type, \n                                ((ExecutableReference) inferredRef).getReceiverRef());\n                    else\n                        System.err.println(\"WARN: Cannot annotate \" + mTree);\n                }\n            } else if (!fieldElt.getSimpleName().contentEquals(\"super\")\n                    && fieldElt.getKind() == ElementKind.FIELD\n                    && !ElementUtils.isStatic(fieldElt)\n                    && checker.isAnnotated(type)\n                    ) {\n                \/\/ Do viewpoint adaptation\n                ExpressionTree expr = mTree.getExpression();\n                AnnotatedTypeMirror exprType = getAnnotatedType(expr);\n                AnnotatedTypeMirror fieldType = getAnnotatedType(fieldElt);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(\n                        exprType.getAnnotations(),\n                        fieldType.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            } else if (!checker.isAnnotated(type) \n                    && fieldElt.getSimpleName().contentEquals(\"class\"))\n                type.addAnnotation(checker.BOTTOM);\n            break;\n        default: \n            if(!checker.isAnnotated(type)) {\n                if (tree instanceof UnaryTree) {\n                    AnnotatedTypeMirror aType = getAnnotatedType(\n                            ((UnaryTree) tree).getExpression());\n                    InferenceUtils.assignAnnotations(type, aType);\n                } else if (tree instanceof BinaryTree && !checker.isAnnotated(type)) {\n                    ExpressionTree left = ((BinaryTree)tree).getLeftOperand();\n                    ExpressionTree right = ((BinaryTree)tree).getRightOperand();\n                    AnnotatedTypeMirror leftType = getAnnotatedType(left);\n                    AnnotatedTypeMirror rightType = getAnnotatedType(right);\n                    Set<AnnotationMirror> leftSet = leftType.getAnnotations();\n                    Set<AnnotationMirror> rightSet = rightType.getAnnotations();\n                    Set<AnnotationMirror> set = qualHierarchy.leastUpperBound(leftSet, rightSet);\n                    type.addAnnotations(set);\n                }\n            }\n        }\n    }","code":"private void annotateInferredType(Tree tree, AnnotatedTypeMirror type) {\n        switch (tree.getKind()) {\n        case NEW_ARRAY:\n        case NEW_CLASS:\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(tree), type);\n            break;\n        case METHOD:\n            ExecutableElement methodElt = TreeUtils.elementFromDeclaration(\n                    (MethodTree) tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(methodElt), type);\n            break;\n        case TYPE_CAST:\n            if (!checker.isAnnotated(type)) {\n                Tree t = tree;\n                while (t.getKind() == Kind.TYPE_CAST) {\n                    t = ((TypeCastTree) t).getExpression();\n                    if (t instanceof ExpressionTree)\n                        t = TreeUtils.skipParens((ExpressionTree) t);\n                }\n                AnnotatedTypeMirror castType = getAnnotatedType(t);\n                InferenceUtils.assignAnnotations(type, castType);\n            }\n            break;\n        case METHOD_INVOCATION:\n            if (type.getKind() != TypeKind.VOID) {\n                MethodInvocationTree miTree = (MethodInvocationTree) tree;\n                ExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\n                ExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\n                if (ElementUtils.isStatic(iMethodElt)) {\n                } else {\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    AnnotatedTypeMirror rcvType = null;\n                    if (rcvTree != null) {\n                       \n                        rcvType = getAnnotatedType(rcvTree); \n                    } else if (currentMethod != null) {\n                        rcvType = getAnnotatedType(currentMethod).getReceiverType();\n                    }\n                    if (rcvType != null) {\n                       \n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(\n                            rcvType.getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n                    }\n                }\n            }\n            break;\n        case VARIABLE:\n           \n            VariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\n            InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n           \n           \n            if (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\n                ClassTree classTree = this.getVisitorState().getClassTree();\n                TypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\n                AnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\n                InferenceMain.getInstance().getCurrentExtractor()\n                    .annotateInferredType(getIdentifier(classElt), defConstructorType);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n                        .getAnnotations(), type.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            }\n            break;\n        case IDENTIFIER:\n            Element idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n           \n            if (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\n                InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n               \n\t\t\t\tif (idElt.getKind() == ElementKind.FIELD) {\n\t\t\t\t\n                    ExecutableElement currentMethod = getCurrentMethodElt();\n                    if (currentMethod != null) {\n\t\t\t\t\t\tAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\n\t\t\t\t\t\tSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n\t\t\t\t\t\t\t\t.getReceiverType().getAnnotations(), type.getAnnotations());\n\t\t\t\t\t\tif (!set.isEmpty()) {\n\t\t\t\t\t\t\ttype.clearAnnotations();\n\t\t\t\t\t\t\ttype.addAnnotations(set);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\n                       \n\t\t\t\t\t}\n\t\t\t\t}\n            }\n            break;\n        case ARRAY_ACCESS:\n           \n            ArrayAccessTree aTree = (ArrayAccessTree) tree;\n            ExpressionTree aExpr = aTree.getExpression();\n            AnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\n            assert aExprType.getKind() == TypeKind.ARRAY;\n            Set<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n                    .getComponentType().getAnnotations();\n            Set<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\n                    aExprType.getAnnotations(), componentAnnos);\n            if (!adaptedAnnos.isEmpty()) {\n                type.clearAnnotations();\n                type.addAnnotations(adaptedAnnos);\n            }\n            break;\t\n        case MEMBER_SELECT:\n           \n           \n           \n            MemberSelectTree mTree = (MemberSelectTree) tree;\n            Element fieldElt = TreeUtils.elementFromUse(mTree);\n            if (checker.isAccessOuterThis(mTree)) {\n               \n               \n                MethodTree methodTree = this.getVisitorState().getMethodTree();\n                if (methodTree != null) {\n                    ExecutableElement currentMethodElt = TreeUtils\n                            .elementFromDeclaration(methodTree);\n                    Element outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\n                    Reference inferredRef = null;\n                    if (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n                    } else {\n                        inferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n                    }\n                    if (inferredRef != null)\n                        InferenceUtils.annotateReferenceType(type, \n                                ((ExecutableReference) inferredRef).getReceiverRef());\n                    else\n                        System.err.println(\"WARN: Cannot annotate \" + mTree);\n                }\n            } else if (!fieldElt.getSimpleName().contentEquals(\"super\")\n                    && fieldElt.getKind() == ElementKind.FIELD\n                    && !ElementUtils.isStatic(fieldElt)\n                    && checker.isAnnotated(type)\n                    ) {\n               \n                ExpressionTree expr = mTree.getExpression();\n                AnnotatedTypeMirror exprType = getAnnotatedType(expr);\n                AnnotatedTypeMirror fieldType = getAnnotatedType(fieldElt);\n                Set<AnnotationMirror> set = checker.adaptFieldSet(\n                        exprType.getAnnotations(),\n                        fieldType.getAnnotations());\n                if (!set.isEmpty()) {\n                    type.clearAnnotations();\n                    type.addAnnotations(set);\n                }\n            } else if (!checker.isAnnotated(type) \n                    && fieldElt.getSimpleName().contentEquals(\"class\"))\n                type.addAnnotation(checker.BOTTOM);\n            break;\n        default: \n            if(!checker.isAnnotated(type)) {\n                if (tree instanceof UnaryTree) {\n                    AnnotatedTypeMirror aType = getAnnotatedType(\n                            ((UnaryTree) tree).getExpression());\n                    InferenceUtils.assignAnnotations(type, aType);\n                } else if (tree instanceof BinaryTree && !checker.isAnnotated(type)) {\n                    ExpressionTree left = ((BinaryTree)tree).getLeftOperand();\n                    ExpressionTree right = ((BinaryTree)tree).getRightOperand();\n                    AnnotatedTypeMirror leftType = getAnnotatedType(left);\n                    AnnotatedTypeMirror rightType = getAnnotatedType(right);\n                    Set<AnnotationMirror> leftSet = leftType.getAnnotations();\n                    Set<AnnotationMirror> rightSet = rightType.getAnnotations();\n                    Set<AnnotationMirror> set = qualHierarchy.leastUpperBound(leftSet, rightSet);\n                    type.addAnnotations(set);\n                }\n            }\n        }\n    }","cleancode":"private void annotateinferredtype(tree tree, annotatedtypemirror type) { switch (tree.getkind()) { case new_array: case new_class: inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(tree), type); break; case method: executableelement methodelt = treeutils.elementfromdeclaration( (methodtree) tree); inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(methodelt), type); break; case type_cast: if (!checker.isannotated(type)) { tree t = tree; while (t.getkind() == kind.type_cast) { t = ((typecasttree) t).getexpression(); if (t instanceof expressiontree) t = treeutils.skipparens((expressiontree) t); } annotatedtypemirror casttype = getannotatedtype(t); inferenceutils.assignannotations(type, casttype); } break; case method_invocation: if (type.getkind() != typekind.void) { methodinvocationtree mitree = (methodinvocationtree) tree; executableelement imethodelt = treeutils.elementfromuse(mitree); expressiontree rcvtree = inferenceutils.getreceivertree(mitree); if (elementutils.isstatic(imethodelt)) { } else { executableelement currentmethod = getcurrentmethodelt(); annotatedtypemirror rcvtype = null; if (rcvtree != null) { rcvtype = getannotatedtype(rcvtree); } else if (currentmethod != null) { rcvtype = getannotatedtype(currentmethod).getreceivertype(); } if (rcvtype != null) { set<annotationmirror> set = checker.adaptfieldset( rcvtype.getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } } } break; case variable: variableelement varelt = treeutils.elementfromdeclaration((variabletree)tree); inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(varelt), type); if (varelt.getkind().isfield() && !elementutils.isstatic(varelt)) { classtree classtree = this.getvisitorstate().getclasstree(); typeelement classelt = treeutils.elementfromdeclaration(classtree); annotateddeclaredtype defconstructortype = getannotatedtype(classelt); inferencemain.getinstance().getcurrentextractor() .annotateinferredtype(getidentifier(classelt), defconstructortype); set<annotationmirror> set = checker.adaptfieldset(defconstructortype .getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } break; case identifier: element idelt = treeutils.elementfromuse((identifiertree) tree); if (idelt.getkind() != elementkind.class && idelt.getkind() != elementkind.interface) { inferencemain.getinstance().getcurrentextractor().annotateinferredtype(getidentifier(idelt), type); if (idelt.getkind() == elementkind.field) { executableelement currentmethod = getcurrentmethodelt(); if (currentmethod != null) { annotatedexecutabletype methodtype = getannotatedtype(currentmethod); set<annotationmirror> set = checker.adaptfieldset(methodtype .getreceivertype().getannotations(), type.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } else { } } } break; case array_access: arrayaccesstree atree = (arrayaccesstree) tree; expressiontree aexpr = atree.getexpression(); annotatedtypemirror aexprtype = getannotatedtype(aexpr); assert aexprtype.getkind() == typekind.array; set<annotationmirror> componentannos = ((annotatedarraytype) aexprtype) .getcomponenttype().getannotations(); set<annotationmirror> adaptedannos = checker.adaptfieldset( aexprtype.getannotations(), componentannos); if (!adaptedannos.isempty()) { type.clearannotations(); type.addannotations(adaptedannos); } break; case member_select: memberselecttree mtree = (memberselecttree) tree; element fieldelt = treeutils.elementfromuse(mtree); if (checker.isaccessouterthis(mtree)) { methodtree methodtree = this.getvisitorstate().getmethodtree(); if (methodtree != null) { executableelement currentmethodelt = treeutils .elementfromdeclaration(methodtree); element outerelt = checker.getouterthiselement(mtree, currentmethodelt); reference inferredref = null; if (outerelt != null && outerelt.getkind() == elementkind.method) { inferredref = inferencemain.getinstance().getcurrentextractor().getinferredreference(getidentifier(outerelt)); } else { inferredref = inferencemain.getinstance().getcurrentextractor().getinferredreference(getidentifier(currentmethodelt)); } if (inferredref != null) inferenceutils.annotatereferencetype(type, ((executablereference) inferredref).getreceiverref()); else system.err.println(\"warn: cannot annotate \" + mtree); } } else if (!fieldelt.getsimplename().contentequals(\"super\") && fieldelt.getkind() == elementkind.field && !elementutils.isstatic(fieldelt) && checker.isannotated(type) ) { expressiontree expr = mtree.getexpression(); annotatedtypemirror exprtype = getannotatedtype(expr); annotatedtypemirror fieldtype = getannotatedtype(fieldelt); set<annotationmirror> set = checker.adaptfieldset( exprtype.getannotations(), fieldtype.getannotations()); if (!set.isempty()) { type.clearannotations(); type.addannotations(set); } } else if (!checker.isannotated(type) && fieldelt.getsimplename().contentequals(\"class\")) type.addannotation(checker.bottom); break; default: if(!checker.isannotated(type)) { if (tree instanceof unarytree) { annotatedtypemirror atype = getannotatedtype( ((unarytree) tree).getexpression()); inferenceutils.assignannotations(type, atype); } else if (tree instanceof binarytree && !checker.isannotated(type)) { expressiontree left = ((binarytree)tree).getleftoperand(); expressiontree right = ((binarytree)tree).getrightoperand(); annotatedtypemirror lefttype = getannotatedtype(left); annotatedtypemirror righttype = getannotatedtype(right); set<annotationmirror> leftset = lefttype.getannotations(); set<annotationmirror> rightset = righttype.getannotations(); set<annotationmirror> set = qualhierarchy.leastupperbound(leftset, rightset); type.addannotations(set); } } } }","comment":"\/\/ system.out.println(\"warn: be supported in sflowvisitor\");\n\/\/ like x = y.m(z);\n\/\/ do viewpoint adaptation\n\/\/ todo: consider using viewpoint adaptation\n\/\/ if there is an initialization for field, we need adapt it from \/\/ classtree type\n\/\/ we don't want to annotate class type\n\/\/ may need viewpoint adaptation if it is a field\n\/\/ we need to adapt it from pov of this\n\/\/ this happen in the static initializer \/\/ ignore\n\/\/ wei: move from reimannotatedtypefactory on aug 2.\n\/\/ wei: added on aug 2 \/\/ wei: remove the above line, also considering remove the \/\/ tree.getkind() == kind.member_select in the \"default\" case\n\/\/ if it is like body.this \/\/ fixme:\n\/\/ do viewpoint adaptation","repo":"SoftwareEngineeringToolDemos\/type-inference","code_context_2":"ExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\n\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\n\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\n\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\n\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\n\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\n\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\n\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\n\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\/\/ If it is like Body.this\n\/\/ FIXME:\nMethodTree methodTree = this.getVisitorState().getMethodTree();\nif (methodTree != null) {\n\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());","code_context_10":"AnnotatedTypeMirror castType = getAnnotatedType(t);\nInferenceUtils.assignAnnotations(type, castType);\n}\nbreak;\ncase METHOD_INVOCATION:\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\n\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\n\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\n\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\n\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\n\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\n\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\n\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\/\/ If it is like Body.this\n\/\/ FIXME:\nMethodTree methodTree = this.getVisitorState().getMethodTree();\nif (methodTree != null) {\nExecutableElement currentMethodElt = TreeUtils\n.elementFromDeclaration(methodTree);\nElement outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\n\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\/\/ If it is like Body.this\n\/\/ FIXME:\nMethodTree methodTree = this.getVisitorState().getMethodTree();\nif (methodTree != null) {\nExecutableElement currentMethodElt = TreeUtils\n.elementFromDeclaration(methodTree);\nElement outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\nReference inferredRef = null;\nif (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n} else {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;","code_context_20":"InferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(methodElt), type);\nbreak;\ncase TYPE_CAST:\nif (!checker.isAnnotated(type)) {\nTree t = tree;\nwhile (t.getKind() == Kind.TYPE_CAST) {\nt = ((TypeCastTree) t).getExpression();\nif (t instanceof ExpressionTree)\nt = TreeUtils.skipParens((ExpressionTree) t);\n}\nAnnotatedTypeMirror castType = getAnnotatedType(t);\nInferenceUtils.assignAnnotations(type, castType);\n}\nbreak;\ncase METHOD_INVOCATION:\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\n\nwhile (t.getKind() == Kind.TYPE_CAST) {\nt = ((TypeCastTree) t).getExpression();\nif (t instanceof ExpressionTree)\nt = TreeUtils.skipParens((ExpressionTree) t);\n}\nAnnotatedTypeMirror castType = getAnnotatedType(t);\nInferenceUtils.assignAnnotations(type, castType);\n}\nbreak;\ncase METHOD_INVOCATION:\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\nInferenceUtils.assignAnnotations(type, castType);\n}\nbreak;\ncase METHOD_INVOCATION:\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\n\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\n\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\n\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\n\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);\nInferenceMain.getInstance().getCurrentExtractor()\n.annotateInferredType(getIdentifier(classElt), defConstructorType);\nSet<AnnotationMirror> set = checker.adaptFieldSet(defConstructorType\n.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\n\n}\nbreak;\ncase IDENTIFIER:\nElement idElt = TreeUtils.elementFromUse((IdentifierTree) tree);\n\/\/ We don't want to annotate CLASS type\nif (idElt.getKind() != ElementKind.CLASS && idElt.getKind() != ElementKind.INTERFACE) {\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(idElt), type);\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\n\/\/ May need viewpoint adaptation if it is a field\nif (idElt.getKind() == ElementKind.FIELD) {\n\/\/ We need to adapt it from PoV of THIS\nExecutableElement currentMethod = getCurrentMethodElt();\nif (currentMethod != null) {\nAnnotatedExecutableType methodType = getAnnotatedType(currentMethod);\nSet<AnnotationMirror> set = checker.adaptFieldSet(methodType\n.getReceiverType().getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n} else {\n\/\/ This happen in the static initializer\n\/\/ ignore\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\n}\n}\n}\nbreak;\ncase ARRAY_ACCESS:\n\/\/ WEI: move from ReimAnnotatedTypeFactory on Aug 2.\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\/\/ If it is like Body.this\n\/\/ FIXME:\nMethodTree methodTree = this.getVisitorState().getMethodTree();\nif (methodTree != null) {\nExecutableElement currentMethodElt = TreeUtils\n.elementFromDeclaration(methodTree);\nElement outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\nReference inferredRef = null;\nif (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n} else {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n}\nif (inferredRef != null)\nInferenceUtils.annotateReferenceType(type,\n((ExecutableReference) inferredRef).getReceiverRef());\nelse\n\nArrayAccessTree aTree = (ArrayAccessTree) tree;\nExpressionTree aExpr = aTree.getExpression();\nAnnotatedTypeMirror aExprType = getAnnotatedType(aExpr);\nassert aExprType.getKind() == TypeKind.ARRAY;\nSet<AnnotationMirror> componentAnnos = ((AnnotatedArrayType) aExprType)\n.getComponentType().getAnnotations();\nSet<AnnotationMirror> adaptedAnnos = checker.adaptFieldSet(\naExprType.getAnnotations(), componentAnnos);\nif (!adaptedAnnos.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(adaptedAnnos);\n}\nbreak;\ncase MEMBER_SELECT:\n\/\/ WEI: added on Aug 2\n\/\/ WEI: Remove the above line, also considering remove the\n\/\/ tree.getKind() == Kind.MEMBER_SELECT in the \"default\" case\nMemberSelectTree mTree = (MemberSelectTree) tree;\nElement fieldElt = TreeUtils.elementFromUse(mTree);\nif (checker.isAccessOuterThis(mTree)) {\n\/\/ If it is like Body.this\n\/\/ FIXME:\nMethodTree methodTree = this.getVisitorState().getMethodTree();\nif (methodTree != null) {\nExecutableElement currentMethodElt = TreeUtils\n.elementFromDeclaration(methodTree);\nElement outerElt = checker.getOuterThisElement(mTree, currentMethodElt);\nReference inferredRef = null;\nif (outerElt != null && outerElt.getKind() == ElementKind.METHOD) {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(outerElt));\n} else {\ninferredRef = InferenceMain.getInstance().getCurrentExtractor().getInferredReference(getIdentifier(currentMethodElt));\n}\nif (inferredRef != null)\nInferenceUtils.annotateReferenceType(type,\n((ExecutableReference) inferredRef).getReceiverRef());\nelse\nSystem.err.println(\"WARN: Cannot annotate \" + mTree);\n}\n} else if (!fieldElt.getSimpleName().contentEquals(\"super\")\n&& fieldElt.getKind() == ElementKind.FIELD\n&& !ElementUtils.isStatic(fieldElt)\n\nInferenceUtils.assignAnnotations(type, castType);\n}\nbreak;\ncase METHOD_INVOCATION:\nif (type.getKind() != TypeKind.VOID) {\nMethodInvocationTree miTree = (MethodInvocationTree) tree;\nExecutableElement iMethodElt = TreeUtils.elementFromUse(miTree);\nExpressionTree rcvTree = InferenceUtils.getReceiverTree(miTree);\nif (ElementUtils.isStatic(iMethodElt)) {\n\/\/ System.out.println(\"WARN: be supported in SFlowVisitor\");\n} else {\nExecutableElement currentMethod = getCurrentMethodElt();\nAnnotatedTypeMirror rcvType = null;\nif (rcvTree != null) {\n\/\/ like x = y.m(z);\nrcvType = getAnnotatedType(rcvTree);\n} else if (currentMethod != null) {\nrcvType = getAnnotatedType(currentMethod).getReceiverType();\n}\nif (rcvType != null) {\n\/\/ Do viewpoint adaptation\nSet<AnnotationMirror> set = checker.adaptFieldSet(\nrcvType.getAnnotations(), type.getAnnotations());\nif (!set.isEmpty()) {\ntype.clearAnnotations();\ntype.addAnnotations(set);\n}\n}\n}\n}\nbreak;\ncase VARIABLE:\n\/\/ TODO: Consider using viewpoint adaptation\nVariableElement varElt = TreeUtils.elementFromDeclaration((VariableTree)tree);\nInferenceMain.getInstance().getCurrentExtractor().annotateInferredType(getIdentifier(varElt), type);\n\/\/ If there is an initialization for field, we need adapt it from\n\/\/ ClassTree type\nif (varElt.getKind().isField() && !ElementUtils.isStatic(varElt)) {\nClassTree classTree = this.getVisitorState().getClassTree();\nTypeElement classElt = TreeUtils.elementFromDeclaration(classTree);\nAnnotatedDeclaredType defConstructorType = getAnnotatedType(classElt);","label":[1,0,1,0]}
{"id":13884,"original_code":"private boolean isPasswordValid(String password) {\n        \/\/TODO: Replace this with your own logic\n        return password.length() > 5;\n    }","code":"private boolean isPasswordValid(String password) {\n       \n        return password.length() > 5;\n    }","cleancode":"private boolean ispasswordvalid(string password) { return password.length() > 5; }","comment":"\/\/todo: replace this with your own logic","repo":"ShivamPokhriyal\/Custom-UI-Sample","code_context_2":"private boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 5;\n}","code_context_10":"private boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 5;\n}","code_context_20":"private boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 5;\n}","label":[1,0,0,0]}
{"id":30271,"original_code":"private List<String> commonLinkAndCompileFlagsForClang(\n      ObjcProvider provider, ObjcConfiguration objcConfiguration,\n      AppleConfiguration appleConfiguration) {\n    ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    Platform platform = appleConfiguration.getSingleArchPlatform();\n    switch (platform) {\n      case IOS_SIMULATOR:\n        builder.add(\"-mios-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case IOS_DEVICE:\n        builder.add(\"-miphoneos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case WATCHOS_SIMULATOR:\n        \/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n        \/\/ version.\n        builder.add(\"-mwatchos-simulator-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case WATCHOS_DEVICE:\n        \/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n        \/\/ version.\n        builder.add(\"-mwatchos-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case TVOS_SIMULATOR:\n        builder.add(\"-mtvos-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case TVOS_DEVICE:\n        builder.add(\"-mtvos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unhandled platform \" + platform);\n    }\n    if (objcConfiguration.generateDsym()) {\n      builder.add(\"-g\");\n    }\n    return builder\n        .add(\"-arch\", appleConfiguration.getSingleArchitecture())\n        .add(\"-isysroot\", AppleToolchain.sdkDir())\n        \/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n        .addAll(commonFrameworkFlags(provider, appleConfiguration))\n        .build();\n  }","code":"private List<String> commonLinkAndCompileFlagsForClang(\n      ObjcProvider provider, ObjcConfiguration objcConfiguration,\n      AppleConfiguration appleConfiguration) {\n    ImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\n    Platform platform = appleConfiguration.getSingleArchPlatform();\n    switch (platform) {\n      case IOS_SIMULATOR:\n        builder.add(\"-mios-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case IOS_DEVICE:\n        builder.add(\"-miphoneos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case WATCHOS_SIMULATOR:\n       \n       \n        builder.add(\"-mwatchos-simulator-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case WATCHOS_DEVICE:\n       \n       \n        builder.add(\"-mwatchos-version-min=\"\n            + appleConfiguration.getSdkVersionForPlatform(platform));\n        break;\n      case TVOS_SIMULATOR:\n        builder.add(\"-mtvos-simulator-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      case TVOS_DEVICE:\n        builder.add(\"-mtvos-version-min=\"\n            + appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\"Unhandled platform \" + platform);\n    }\n    if (objcConfiguration.generateDsym()) {\n      builder.add(\"-g\");\n    }\n    return builder\n        .add(\"-arch\", appleConfiguration.getSingleArchitecture())\n        .add(\"-isysroot\", AppleToolchain.sdkDir())\n       \n        .addAll(commonFrameworkFlags(provider, appleConfiguration))\n        .build();\n  }","cleancode":"private list<string> commonlinkandcompileflagsforclang( objcprovider provider, objcconfiguration objcconfiguration, appleconfiguration appleconfiguration) { immutablelist.builder<string> builder = new immutablelist.builder<>(); platform platform = appleconfiguration.getsinglearchplatform(); switch (platform) { case ios_simulator: builder.add(\"-mios-simulator-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case ios_device: builder.add(\"-miphoneos-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case watchos_simulator: builder.add(\"-mwatchos-simulator-version-min=\" + appleconfiguration.getsdkversionforplatform(platform)); break; case watchos_device: builder.add(\"-mwatchos-version-min=\" + appleconfiguration.getsdkversionforplatform(platform)); break; case tvos_simulator: builder.add(\"-mtvos-simulator-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; case tvos_device: builder.add(\"-mtvos-version-min=\" + appleconfiguration.getminimumosforplatformtype(platform.gettype())); break; default: throw new illegalargumentexception(\"unhandled platform \" + platform); } if (objcconfiguration.generatedsym()) { builder.add(\"-g\"); } return builder .add(\"-arch\", appleconfiguration.getsinglearchitecture()) .add(\"-isysroot\", appletoolchain.sdkdir()) .addall(commonframeworkflags(provider, appleconfiguration)) .build(); }","comment":"\/** * returns a list of clang flags used for all link and compile actions executed through clang. *\/\n\/\/ todo(bazel-team): use the value from --watchos-minimum-os instead of tying to the sdk \/\/ version.\n\/\/ todo(bazel-team): use the value from --watchos-minimum-os instead of tying to the sdk \/\/ version.\n\/\/ todo(bazel-team): pass framework search paths to xcodegen.","repo":"Tingbopku\/tingbo1","code_context_2":"private List<String> commonLinkAndCompileFlagsForClang(\nObjcProvider provider, ObjcConfiguration objcConfiguration,\nAppleConfiguration appleConfiguration) {\nImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\nPlatform platform = appleConfiguration.getSingleArchPlatform();\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\nif (objcConfiguration.generateDsym()) {\nbuilder.add(\"-g\");\n}\nreturn builder\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();\n}\n\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\n\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\n\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();","code_context_10":"private List<String> commonLinkAndCompileFlagsForClang(\nObjcProvider provider, ObjcConfiguration objcConfiguration,\nAppleConfiguration appleConfiguration) {\nImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\nPlatform platform = appleConfiguration.getSingleArchPlatform();\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\nif (objcConfiguration.generateDsym()) {\nbuilder.add(\"-g\");\n}\nreturn builder\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();\n}\n\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\n\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\n\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\nif (objcConfiguration.generateDsym()) {\nbuilder.add(\"-g\");\n}\nreturn builder\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();\n}","code_context_20":"private List<String> commonLinkAndCompileFlagsForClang(\nObjcProvider provider, ObjcConfiguration objcConfiguration,\nAppleConfiguration appleConfiguration) {\nImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\nPlatform platform = appleConfiguration.getSingleArchPlatform();\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\nif (objcConfiguration.generateDsym()) {\nbuilder.add(\"-g\");\n}\nreturn builder\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();\n}\n\nprivate List<String> commonLinkAndCompileFlagsForClang(\nObjcProvider provider, ObjcConfiguration objcConfiguration,\nAppleConfiguration appleConfiguration) {\nImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\nPlatform platform = appleConfiguration.getSingleArchPlatform();\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\n\nprivate List<String> commonLinkAndCompileFlagsForClang(\nObjcProvider provider, ObjcConfiguration objcConfiguration,\nAppleConfiguration appleConfiguration) {\nImmutableList.Builder<String> builder = new ImmutableList.Builder<>();\nPlatform platform = appleConfiguration.getSingleArchPlatform();\nswitch (platform) {\ncase IOS_SIMULATOR:\nbuilder.add(\"-mios-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase IOS_DEVICE:\nbuilder.add(\"-miphoneos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase WATCHOS_SIMULATOR:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-simulator-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase WATCHOS_DEVICE:\n\/\/ TODO(bazel-team): Use the value from --watchos-minimum-os instead of tying to the SDK\n\/\/ version.\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\n\nbuilder.add(\"-mwatchos-version-min=\"\n+ appleConfiguration.getSdkVersionForPlatform(platform));\nbreak;\ncase TVOS_SIMULATOR:\nbuilder.add(\"-mtvos-simulator-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ncase TVOS_DEVICE:\nbuilder.add(\"-mtvos-version-min=\"\n+ appleConfiguration.getMinimumOsForPlatformType(platform.getType()));\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"Unhandled platform \" + platform);\n}\nif (objcConfiguration.generateDsym()) {\nbuilder.add(\"-g\");\n}\nreturn builder\n.add(\"-arch\", appleConfiguration.getSingleArchitecture())\n.add(\"-isysroot\", AppleToolchain.sdkDir())\n\/\/ TODO(bazel-team): Pass framework search paths to Xcodegen.\n.addAll(commonFrameworkFlags(provider, appleConfiguration))\n.build();\n}","label":[1,1,0,0]}
{"id":22098,"original_code":"@Override\n        public void onClick(DialogInterface dialog, int which) {\n            \/\/ User clicked OK button\n            int[] inputs = new int[playerManager.getSelectedPlayerCount()];\n            \/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\n            for (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\n                int index = getPlayerIndex(i);\n                EditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n                \/\/verify input\n                int input;\n                try {\n                    input = Integer.parseInt(editText.getText().toString());\n                } catch (NumberFormatException nfe) {\n                    Toast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                inputs[index] = input;\n            }\n            \/\/validate results\n            int totalValue = 0;\n            for (int value : inputs) {\n                if (value < 0) {\n                    Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                totalValue += value;\n            }\n            if (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\n                Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\n                toast.show();\n                return;\n            }\n            \/\/save results\n            \/\/todo: save playerID with input field for better code quality\n            Map<Long, Integer> inputMap = new HashMap<>();\n            for (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\n                inputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n            }\n            \/\/if this entry is score, update views && activate next round\n            if (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\n                gameScoreManager.enterScores(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                headerManager.updateScores();\n                rowManager.updateScores();\n                changeButtonVisibility(ButtonVisible.NONE);\n                if (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\n                    nextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n                }\n            } else {\n                gameScoreManager.enterPredictions(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                rowManager.updatePredictions();\n                changeButtonVisibility(ButtonVisible.SCORE);\n            }\n            \/\/change buttons\n            changeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n        }","code":"@Override\n        public void onClick(DialogInterface dialog, int which) {\n           \n            int[] inputs = new int[playerManager.getSelectedPlayerCount()];\n           \n            for (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\n                int index = getPlayerIndex(i);\n                EditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n               \n                int input;\n                try {\n                    input = Integer.parseInt(editText.getText().toString());\n                } catch (NumberFormatException nfe) {\n                    Toast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                inputs[index] = input;\n            }\n           \n            int totalValue = 0;\n            for (int value : inputs) {\n                if (value < 0) {\n                    Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\n                    toast.show();\n                    return;\n                }\n                totalValue += value;\n            }\n            if (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\n                Toast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\n                toast.show();\n                return;\n            }\n           \n           \n            Map<Long, Integer> inputMap = new HashMap<>();\n            for (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\n                inputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n            }\n           \n            if (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\n                gameScoreManager.enterScores(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                headerManager.updateScores();\n                rowManager.updateScores();\n                changeButtonVisibility(ButtonVisible.NONE);\n                if (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\n                    nextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n                }\n            } else {\n                gameScoreManager.enterPredictions(inputMap);\n                PersistenceManager.getInstance().saveGame(gameScoreManager);\n                rowManager.updatePredictions();\n                changeButtonVisibility(ButtonVisible.SCORE);\n            }\n           \n            changeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n        }","cleancode":"@override public void onclick(dialoginterface dialog, int which) { int[] inputs = new int[playermanager.getselectedplayercount()]; for (int i = startingplayer; i < playermanager.getselectedplayercount() + startingplayer; i++) { int index = getplayerindex(i); edittext edittext = (edittext) ((linearlayout) linearlayout.getchildat(i - startingplayer)).getchildat(3); int input; try { input = integer.parseint(edittext.gettext().tostring()); } catch (numberformatexception nfe) { toast toast = toast.maketext(context, \"invalid input\", toast.length_short); toast.show(); return; } inputs[index] = input; } int totalvalue = 0; for (int value : inputs) { if (value < 0) { toast toast = toast.maketext(context, context.getresources().getstring(r.string.invalid_number), toast.length_short); toast.show(); return; } totalvalue += value; } if (gamescoremanager.getnextentrytype() == readonlygamescoremanager.entrytype.score && totalvalue != gamescoremanager.getcardcount(gamescoremanager.getround())) { toast toast = toast.maketext(context, context.getresources().getstring(r.string.invalid_score), toast.length_long); toast.show(); return; } map<long, integer> inputmap = new hashmap<>(); for (int i = 0; i < playermanager.getselectedplayercount(); i++) { inputmap.put(playermanager.getselectedplayers()[i], inputs[i]); } if (gamescoremanager.getnextentrytype() == gamescoremanager.entrytype.score) { gamescoremanager.enterscores(inputmap); persistencemanager.getinstance().savegame(gamescoremanager); headermanager.updatescores(); rowmanager.updatescores(); changebuttonvisibility(buttonvisible.none); if (gamescoremanager.getround() != gamescoremanager.getamountofrounds()) { nextround.changebuttonvisibility(buttonvisible.predict); } } else { gamescoremanager.enterpredictions(inputmap); persistencemanager.getinstance().savegame(gamescoremanager); rowmanager.updatepredictions(); changebuttonvisibility(buttonvisible.score); } changebuttonvisibility(gamescoremanager.getnextentrytype() == readonlygamescoremanager.entrytype.score ? buttonvisible.score : buttonvisible.none); }","comment":"\/\/ user clicked ok button\n\/\/starts at startingplayer, since input list starts at startingplayer\n\/\/verify input\n\/\/validate results\n\/\/save results \/\/todo: save playerid with input field for better code quality\n\/\/if this entry is score, update views && activate next round\n\/\/change buttons","repo":"ThaChillera\/CardScore","code_context_2":"@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\n\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\n\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\n\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\n\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\n\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\n\nchangeButtonVisibility(ButtonVisible.SCORE);\n}\n\/\/change buttons\nchangeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n}","code_context_10":"@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\n\n@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\n\n@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\nif (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\n\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\nif (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\ntoast.show();\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nheaderManager.updateScores();\nrowManager.updateScores();\n\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\ntoast.show();\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nheaderManager.updateScores();\nrowManager.updateScores();\nchangeButtonVisibility(ButtonVisible.NONE);\nif (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\nnextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n}\n} else {\n\nchangeButtonVisibility(ButtonVisible.NONE);\nif (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\nnextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n}\n} else {\ngameScoreManager.enterPredictions(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nrowManager.updatePredictions();\nchangeButtonVisibility(ButtonVisible.SCORE);\n}\n\/\/change buttons\nchangeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n}","code_context_20":"@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\n\n@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\n\n@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\n\n@Override\npublic void onClick(DialogInterface dialog, int which) {\n\/\/ User clicked OK button\nint[] inputs = new int[playerManager.getSelectedPlayerCount()];\n\/\/starts at STARTINGPLAYER, since input list starts at STARTINGPLAYER\nfor (int i = STARTINGPLAYER; i < playerManager.getSelectedPlayerCount() + STARTINGPLAYER; i++) {\nint index = getPlayerIndex(i);\nEditText editText = (EditText) ((LinearLayout) linearLayout.getChildAt(i - STARTINGPLAYER)).getChildAt(3);\n\/\/verify input\nint input;\ntry {\ninput = Integer.parseInt(editText.getText().toString());\n} catch (NumberFormatException nfe) {\nToast toast = Toast.makeText(CONTEXT, \"Invalid input\", Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\nif (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\ntoast.show();\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\ntoast.show();\nreturn;\n}\ninputs[index] = input;\n}\n\/\/validate results\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\nif (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\ntoast.show();\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nheaderManager.updateScores();\nrowManager.updateScores();\nchangeButtonVisibility(ButtonVisible.NONE);\nif (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\nnextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n}\n} else {\ngameScoreManager.enterPredictions(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nrowManager.updatePredictions();\nchangeButtonVisibility(ButtonVisible.SCORE);\n}\n\nint totalValue = 0;\nfor (int value : inputs) {\nif (value < 0) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_number), Toast.LENGTH_SHORT);\ntoast.show();\nreturn;\n}\ntotalValue += value;\n}\nif (gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE && totalValue != gameScoreManager.getCardCount(gameScoreManager.getRound())) {\nToast toast = Toast.makeText(CONTEXT, CONTEXT.getResources().getString(R.string.invalid_score), Toast.LENGTH_LONG);\ntoast.show();\nreturn;\n}\n\/\/save results\n\/\/todo: save playerID with input field for better code quality\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nheaderManager.updateScores();\nrowManager.updateScores();\nchangeButtonVisibility(ButtonVisible.NONE);\nif (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\nnextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n}\n} else {\ngameScoreManager.enterPredictions(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nrowManager.updatePredictions();\nchangeButtonVisibility(ButtonVisible.SCORE);\n}\n\/\/change buttons\nchangeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n}\n\nMap<Long, Integer> inputMap = new HashMap<>();\nfor (int i = 0; i < playerManager.getSelectedPlayerCount(); i++) {\ninputMap.put(playerManager.getSelectedPlayers()[i], inputs[i]);\n}\n\/\/if this entry is score, update views && activate next round\nif (gameScoreManager.getNextEntryType() == GameScoreManager.EntryType.SCORE) {\ngameScoreManager.enterScores(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nheaderManager.updateScores();\nrowManager.updateScores();\nchangeButtonVisibility(ButtonVisible.NONE);\nif (gameScoreManager.getRound() != gameScoreManager.getAmountOfRounds()) {\nnextRound.changeButtonVisibility(ButtonVisible.PREDICT);\n}\n} else {\ngameScoreManager.enterPredictions(inputMap);\nPersistenceManager.getInstance().saveGame(gameScoreManager);\nrowManager.updatePredictions();\nchangeButtonVisibility(ButtonVisible.SCORE);\n}\n\/\/change buttons\nchangeButtonVisibility(gameScoreManager.getNextEntryType() == ReadOnlyGameScoreManager.EntryType.SCORE ? ButtonVisible.SCORE : ButtonVisible.NONE);\n}","label":[0,1,0,0]}
{"id":22436,"original_code":"@Override\n    public void prepareForSave(KualiDocumentEvent event) {\n        \/\/ TODO Auto-generated method stub\n        \/\/ first populate, then call super\n        if (event instanceof AttributedContinuePurapEvent) {\n            SpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n        }\n        if(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\n            this.setVendorPaymentTermsCode(null);\n        }\n        super.prepareForSave(event);\n        try {\n            if (this.proformaIndicator && !this.immediatePaymentIndicator) {\n                this.setImmediatePaymentIndicator(true);\n            }\n            LOG.debug(\"###########Inside OleInvoiceDocument \" + \"repareForSave###########\");\n            List<OleInvoiceItem> items = new ArrayList<OleInvoiceItem>();\n            items = this.getItems();\n            Iterator iterator = items.iterator();\n            HashMap dataMap = new HashMap();\n            String titleId;\n            while (iterator.hasNext()) {\n                LOG.debug(\"###########inside prepareForSave item loop###########\");\n                Object object = iterator.next();\n                if (object instanceof OleInvoiceItem) {\n                    LOG.debug(\"###########inside prepareForSave ole payment request item###########\");\n                    OleInvoiceItem singleItem = (OleInvoiceItem) object;\n                    if (StringUtils.isNotBlank(this.invoiceCurrencyType)) {\n                        this.setInvoiceCurrencyTypeId(new Long(this.getInvoiceCurrencyType()));\n                        String currencyType = SpringContext.getBean(OleInvoiceService.class).getCurrencyType(this.getInvoiceCurrencyType());\n                        if (StringUtils.isNotBlank(currencyType)) {\n                            if(!currencyType.equalsIgnoreCase(OleSelectConstant.CURRENCY_TYPE_NAME)) {\n                                if (StringUtils.isNotBlank(this.getInvoiceCurrencyExchangeRate())) {\n                                    try {\n                                        Double.parseDouble(this.getInvoiceCurrencyExchangeRate());\n                                        singleItem.setItemExchangeRate(new KualiDecimal(this.getInvoiceCurrencyExchangeRate()));\n                                        singleItem.setExchangeRate(this.getInvoiceCurrencyExchangeRate());\n                                    }\n                                    catch (NumberFormatException nfe) {\n                                        throw new RuntimeException(\"Invalid Exchange Rate\", nfe);\n                                    }\n                                }   else {\n                                    BigDecimal exchangeRate = SpringContext.getBean(OleInvoiceService.class).getExchangeRate(this.getInvoiceCurrencyType()).getExchangeRate();\n                                    this.setInvoiceCurrencyExchangeRate(exchangeRate.toString());\n                                    singleItem.setItemExchangeRate(new KualiDecimal(exchangeRate));\n                                    singleItem.setExchangeRate(exchangeRate.toString());\n                                }\n                                this.setVendorInvoiceAmount(this.getForeignVendorInvoiceAmount() != null ?\n                                        new KualiDecimal(this.getForeignVendorInvoiceAmount().divide(new BigDecimal(singleItem.getExchangeRate()), 4, RoundingMode.HALF_UP)) : null);\n                            }\n                        }\n                    }\n                    setItemDescription(singleItem);\n                    Map<String, String> copyCriteria = new HashMap<String, String>();\n                    if (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\n                        copyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\n                        List<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\n                        if (copies.size() > 0) {\n                            List<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\n                            for (OleCopy copy : copies) {\n                                OLEPaidCopy paidCopy = new OLEPaidCopy();\n                                paidCopy.setCopyId(copy.getCopyId());\n                                paidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\n                                paidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n                                \/\/copy.getOlePaidCopies().add(paidCopy);\n                                paidCopies.add(paidCopy);\n                            }\n                            getBusinessObjectService().save(paidCopies);\n                            singleItem.setPaidCopies(paidCopies);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);\n            throw new RuntimeException(e);\n        }\n    }","code":"@Override\n    public void prepareForSave(KualiDocumentEvent event) {\n       \n       \n        if (event instanceof AttributedContinuePurapEvent) {\n            SpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n        }\n        if(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\n            this.setVendorPaymentTermsCode(null);\n        }\n        super.prepareForSave(event);\n        try {\n            if (this.proformaIndicator && !this.immediatePaymentIndicator) {\n                this.setImmediatePaymentIndicator(true);\n            }\n            LOG.debug(\"###########Inside OleInvoiceDocument \" + \"repareForSave###########\");\n            List<OleInvoiceItem> items = new ArrayList<OleInvoiceItem>();\n            items = this.getItems();\n            Iterator iterator = items.iterator();\n            HashMap dataMap = new HashMap();\n            String titleId;\n            while (iterator.hasNext()) {\n                LOG.debug(\"###########inside prepareForSave item loop###########\");\n                Object object = iterator.next();\n                if (object instanceof OleInvoiceItem) {\n                    LOG.debug(\"###########inside prepareForSave ole payment request item###########\");\n                    OleInvoiceItem singleItem = (OleInvoiceItem) object;\n                    if (StringUtils.isNotBlank(this.invoiceCurrencyType)) {\n                        this.setInvoiceCurrencyTypeId(new Long(this.getInvoiceCurrencyType()));\n                        String currencyType = SpringContext.getBean(OleInvoiceService.class).getCurrencyType(this.getInvoiceCurrencyType());\n                        if (StringUtils.isNotBlank(currencyType)) {\n                            if(!currencyType.equalsIgnoreCase(OleSelectConstant.CURRENCY_TYPE_NAME)) {\n                                if (StringUtils.isNotBlank(this.getInvoiceCurrencyExchangeRate())) {\n                                    try {\n                                        Double.parseDouble(this.getInvoiceCurrencyExchangeRate());\n                                        singleItem.setItemExchangeRate(new KualiDecimal(this.getInvoiceCurrencyExchangeRate()));\n                                        singleItem.setExchangeRate(this.getInvoiceCurrencyExchangeRate());\n                                    }\n                                    catch (NumberFormatException nfe) {\n                                        throw new RuntimeException(\"Invalid Exchange Rate\", nfe);\n                                    }\n                                }   else {\n                                    BigDecimal exchangeRate = SpringContext.getBean(OleInvoiceService.class).getExchangeRate(this.getInvoiceCurrencyType()).getExchangeRate();\n                                    this.setInvoiceCurrencyExchangeRate(exchangeRate.toString());\n                                    singleItem.setItemExchangeRate(new KualiDecimal(exchangeRate));\n                                    singleItem.setExchangeRate(exchangeRate.toString());\n                                }\n                                this.setVendorInvoiceAmount(this.getForeignVendorInvoiceAmount() != null ?\n                                        new KualiDecimal(this.getForeignVendorInvoiceAmount().divide(new BigDecimal(singleItem.getExchangeRate()), 4, RoundingMode.HALF_UP)) : null);\n                            }\n                        }\n                    }\n                    setItemDescription(singleItem);\n                    Map<String, String> copyCriteria = new HashMap<String, String>();\n                    if (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\n                        copyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\n                        List<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\n                        if (copies.size() > 0) {\n                            List<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\n                            for (OleCopy copy : copies) {\n                                OLEPaidCopy paidCopy = new OLEPaidCopy();\n                                paidCopy.setCopyId(copy.getCopyId());\n                                paidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\n                                paidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n                               \n                                paidCopies.add(paidCopy);\n                            }\n                            getBusinessObjectService().save(paidCopies);\n                            singleItem.setPaidCopies(paidCopies);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);\n            throw new RuntimeException(e);\n        }\n    }","cleancode":"@override public void prepareforsave(kualidocumentevent event) { if (event instanceof attributedcontinuepurapevent) { springcontext.getbean(oleinvoiceservice.class).populateinvoice(this); } if(this.getvendorpaymenttermscode() != null && this.getvendorpaymenttermscode().isempty()) { this.setvendorpaymenttermscode(null); } super.prepareforsave(event); try { if (this.proformaindicator && !this.immediatepaymentindicator) { this.setimmediatepaymentindicator(true); } log.debug(\"###########inside oleinvoicedocument \" + \"repareforsave###########\"); list<oleinvoiceitem> items = new arraylist<oleinvoiceitem>(); items = this.getitems(); iterator iterator = items.iterator(); hashmap datamap = new hashmap(); string titleid; while (iterator.hasnext()) { log.debug(\"###########inside prepareforsave item loop###########\"); object object = iterator.next(); if (object instanceof oleinvoiceitem) { log.debug(\"###########inside prepareforsave ole payment request item###########\"); oleinvoiceitem singleitem = (oleinvoiceitem) object; if (stringutils.isnotblank(this.invoicecurrencytype)) { this.setinvoicecurrencytypeid(new long(this.getinvoicecurrencytype())); string currencytype = springcontext.getbean(oleinvoiceservice.class).getcurrencytype(this.getinvoicecurrencytype()); if (stringutils.isnotblank(currencytype)) { if(!currencytype.equalsignorecase(oleselectconstant.currency_type_name)) { if (stringutils.isnotblank(this.getinvoicecurrencyexchangerate())) { try { double.parsedouble(this.getinvoicecurrencyexchangerate()); singleitem.setitemexchangerate(new kualidecimal(this.getinvoicecurrencyexchangerate())); singleitem.setexchangerate(this.getinvoicecurrencyexchangerate()); } catch (numberformatexception nfe) { throw new runtimeexception(\"invalid exchange rate\", nfe); } } else { bigdecimal exchangerate = springcontext.getbean(oleinvoiceservice.class).getexchangerate(this.getinvoicecurrencytype()).getexchangerate(); this.setinvoicecurrencyexchangerate(exchangerate.tostring()); singleitem.setitemexchangerate(new kualidecimal(exchangerate)); singleitem.setexchangerate(exchangerate.tostring()); } this.setvendorinvoiceamount(this.getforeignvendorinvoiceamount() != null ? new kualidecimal(this.getforeignvendorinvoiceamount().divide(new bigdecimal(singleitem.getexchangerate()), 4, roundingmode.half_up)) : null); } } } setitemdescription(singleitem); map<string, string> copycriteria = new hashmap<string, string>(); if (singleitem.getpaidcopies().size() <= 0 && singleitem.getpoitemidentifier() != null && (this.getpurapdocumentidentifier() != null && singleitem.getitemidentifier() != null)) { copycriteria.put(\"poitemid\", singleitem.getpoitemidentifier().tostring()); list<olecopy> copies = (list<olecopy>) getbusinessobjectservice().findmatching(olecopy.class, copycriteria); if (copies.size() > 0) { list<olepaidcopy> paidcopies = new arraylist<olepaidcopy>(); for (olecopy copy : copies) { olepaidcopy paidcopy = new olepaidcopy(); paidcopy.setcopyid(copy.getcopyid()); paidcopy.setinvoiceitemid(this.getpurapdocumentidentifier()); paidcopy.setinvoiceidentifier(singleitem.getitemidentifier()); paidcopies.add(paidcopy); } getbusinessobjectservice().save(paidcopies); singleitem.setpaidcopies(paidcopies); } } } } } catch (exception e) { log.error(\"exception during prepareforsave() in oleinvoicedocument\", e); throw new runtimeexception(e); } }","comment":"\/\/ todo auto-generated method stub \/\/ first populate, then call super\n\/\/copy.getolepaidcopies().add(paidcopy);","repo":"VU-libtech\/OLE-INST","code_context_2":"@Override\npublic void prepareForSave(KualiDocumentEvent event) {\n\/\/ TODO Auto-generated method stub\n\/\/ first populate, then call super\nif (event instanceof AttributedContinuePurapEvent) {\nSpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n\npaidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\npaidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n\/\/copy.getOlePaidCopies().add(paidCopy);\npaidCopies.add(paidCopy);\n}","code_context_10":"@Override\npublic void prepareForSave(KualiDocumentEvent event) {\n\/\/ TODO Auto-generated method stub\n\/\/ first populate, then call super\nif (event instanceof AttributedContinuePurapEvent) {\nSpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n}\nif(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\nthis.setVendorPaymentTermsCode(null);\n}\nsuper.prepareForSave(event);\ntry {\nif (this.proformaIndicator && !this.immediatePaymentIndicator) {\nthis.setImmediatePaymentIndicator(true);\n\nif (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\ncopyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\nList<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\nif (copies.size() > 0) {\nList<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\nfor (OleCopy copy : copies) {\nOLEPaidCopy paidCopy = new OLEPaidCopy();\npaidCopy.setCopyId(copy.getCopyId());\npaidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\npaidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n\/\/copy.getOlePaidCopies().add(paidCopy);\npaidCopies.add(paidCopy);\n}\ngetBusinessObjectService().save(paidCopies);\nsingleItem.setPaidCopies(paidCopies);\n}\n}\n}\n}\n} catch (Exception e) {\nLOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);","code_context_20":"@Override\npublic void prepareForSave(KualiDocumentEvent event) {\n\/\/ TODO Auto-generated method stub\n\/\/ first populate, then call super\nif (event instanceof AttributedContinuePurapEvent) {\nSpringContext.getBean(OleInvoiceService.class).populateInvoice(this);\n}\nif(this.getVendorPaymentTermsCode() != null && this.getVendorPaymentTermsCode().isEmpty()) {\nthis.setVendorPaymentTermsCode(null);\n}\nsuper.prepareForSave(event);\ntry {\nif (this.proformaIndicator && !this.immediatePaymentIndicator) {\nthis.setImmediatePaymentIndicator(true);\n}\nLOG.debug(\"###########Inside OleInvoiceDocument \" + \"repareForSave###########\");\nList<OleInvoiceItem> items = new ArrayList<OleInvoiceItem>();\nitems = this.getItems();\nIterator iterator = items.iterator();\nHashMap dataMap = new HashMap();\nString titleId;\nwhile (iterator.hasNext()) {\nLOG.debug(\"###########inside prepareForSave item loop###########\");\nObject object = iterator.next();\n\nsingleItem.setItemExchangeRate(new KualiDecimal(exchangeRate));\nsingleItem.setExchangeRate(exchangeRate.toString());\n}\nthis.setVendorInvoiceAmount(this.getForeignVendorInvoiceAmount() != null ?\nnew KualiDecimal(this.getForeignVendorInvoiceAmount().divide(new BigDecimal(singleItem.getExchangeRate()), 4, RoundingMode.HALF_UP)) : null);\n}\n}\n}\nsetItemDescription(singleItem);\nMap<String, String> copyCriteria = new HashMap<String, String>();\nif (singleItem.getPaidCopies().size() <= 0 && singleItem.getPoItemIdentifier() != null && (this.getPurapDocumentIdentifier() != null && singleItem.getItemIdentifier() != null)) {\ncopyCriteria.put(\"poItemId\", singleItem.getPoItemIdentifier().toString());\nList<OleCopy> copies = (List<OleCopy>) getBusinessObjectService().findMatching(OleCopy.class, copyCriteria);\nif (copies.size() > 0) {\nList<OLEPaidCopy> paidCopies = new ArrayList<OLEPaidCopy>();\nfor (OleCopy copy : copies) {\nOLEPaidCopy paidCopy = new OLEPaidCopy();\npaidCopy.setCopyId(copy.getCopyId());\npaidCopy.setInvoiceItemId(this.getPurapDocumentIdentifier());\npaidCopy.setInvoiceIdentifier(singleItem.getItemIdentifier());\n\/\/copy.getOlePaidCopies().add(paidCopy);\npaidCopies.add(paidCopy);\n}\ngetBusinessObjectService().save(paidCopies);\nsingleItem.setPaidCopies(paidCopies);\n}\n}\n}\n}\n} catch (Exception e) {\nLOG.error(\"Exception during prepareForSave() in OleInvoiceDocument\", e);\nthrow new RuntimeException(e);\n}\n}","label":[0,1,0,0]}
{"id":14444,"original_code":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\n        this.fpp = filterablePagingProvider;\n        this.fcp = filterableCountProvider;\n        \/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\n        piggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\n            private static final long serialVersionUID = 1027614132444478021L;\n            @Override\n            public List<T> findEntities(int firstRow) {\n                return fpp.findEntities(firstRow,\n                        getCurrentFilter());\n            }\n        },\n                new LazyList.CountProvider() {\n            private static final long serialVersionUID = -7339189124024626177L;\n            @Override\n            public int size() {\n                return fcp.size(getCurrentFilter());\n            }\n        }, pageLength);\n        setBic(new DummyFilterableListContainer<T>(getType(),\n                piggybackLazyList));\n        getSelect().setContainerDataSource(getBic());\n    }","code":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\n        this.fpp = filterablePagingProvider;\n        this.fcp = filterableCountProvider;\n       \n        piggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\n            private static final long serialVersionUID = 1027614132444478021L;\n            @Override\n            public List<T> findEntities(int firstRow) {\n                return fpp.findEntities(firstRow,\n                        getCurrentFilter());\n            }\n        },\n                new LazyList.CountProvider() {\n            private static final long serialVersionUID = -7339189124024626177L;\n            @Override\n            public int size() {\n                return fcp.size(getCurrentFilter());\n            }\n        }, pageLength);\n        setBic(new DummyFilterableListContainer<T>(getType(),\n                piggybackLazyList));\n        getSelect().setContainerDataSource(getBic());\n    }","cleancode":"public void loadfrom(filterablepagingprovider<t> filterablepagingprovider, filterablecountprovider filterablecountprovider, int pagelength) { this.fpp = filterablepagingprovider; this.fcp = filterablecountprovider; piggybacklazylist = new lazylist<>(new lazylist.pagingprovider<t>() { private static final long serialversionuid = 1027614132444478021l; @override public list<t> findentities(int firstrow) { return fpp.findentities(firstrow, getcurrentfilter()); } }, new lazylist.countprovider() { private static final long serialversionuid = -7339189124024626177l; @override public int size() { return fcp.size(getcurrentfilter()); } }, pagelength); setbic(new dummyfilterablelistcontainer<t>(gettype(), piggybacklazylist)); getselect().setcontainerdatasource(getbic()); }","comment":"\/** * set a new strategies how to load options. * * @param filterablepagingprovider the paging provider that gives the actual * options in pages * @param filterablecountprovider the count provider to give the total about * of options with current filter * @param pagelength the length of the pages that component should use to * access providers *\/\n\/\/ need to re-create the piggybacklist & set container, some refactoring should be done here","repo":"andreika63\/viritin","code_context_2":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;\n@Override\npublic List<T> findEntities(int firstRow) {\nreturn fpp.findEntities(firstRow,\ngetCurrentFilter());\n}\n},\nnew LazyList.CountProvider() {\nprivate static final long serialVersionUID = -7339189124024626177L;\n@Override\npublic int size() {\nreturn fcp.size(getCurrentFilter());\n}\n}, pageLength);\nsetBic(new DummyFilterableListContainer<T>(getType(),\npiggybackLazyList));\ngetSelect().setContainerDataSource(getBic());\n}\n\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;","code_context_10":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;\n@Override\npublic List<T> findEntities(int firstRow) {\nreturn fpp.findEntities(firstRow,\ngetCurrentFilter());\n}\n},\nnew LazyList.CountProvider() {\nprivate static final long serialVersionUID = -7339189124024626177L;\n@Override\npublic int size() {\nreturn fcp.size(getCurrentFilter());\n}\n}, pageLength);\nsetBic(new DummyFilterableListContainer<T>(getType(),\npiggybackLazyList));\ngetSelect().setContainerDataSource(getBic());\n}\n\npublic void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;\n@Override\npublic List<T> findEntities(int firstRow) {\nreturn fpp.findEntities(firstRow,\ngetCurrentFilter());\n}\n},\nnew LazyList.CountProvider() {\nprivate static final long serialVersionUID = -7339189124024626177L;","code_context_20":"public void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;\n@Override\npublic List<T> findEntities(int firstRow) {\nreturn fpp.findEntities(firstRow,\ngetCurrentFilter());\n}\n},\nnew LazyList.CountProvider() {\nprivate static final long serialVersionUID = -7339189124024626177L;\n@Override\npublic int size() {\nreturn fcp.size(getCurrentFilter());\n}\n}, pageLength);\nsetBic(new DummyFilterableListContainer<T>(getType(),\npiggybackLazyList));\ngetSelect().setContainerDataSource(getBic());\n}\n\npublic void loadFrom(FilterablePagingProvider<T> filterablePagingProvider, FilterableCountProvider filterableCountProvider, int pageLength) {\nthis.fpp = filterablePagingProvider;\nthis.fcp = filterableCountProvider;\n\/\/ Need to re-create the piggybackList & set container, some refactoring should be done here\npiggybackLazyList = new LazyList<>(new LazyList.PagingProvider<T>() {\nprivate static final long serialVersionUID = 1027614132444478021L;\n@Override\npublic List<T> findEntities(int firstRow) {\nreturn fpp.findEntities(firstRow,\ngetCurrentFilter());\n}\n},\nnew LazyList.CountProvider() {\nprivate static final long serialVersionUID = -7339189124024626177L;\n@Override\npublic int size() {\nreturn fcp.size(getCurrentFilter());\n}\n}, pageLength);\nsetBic(new DummyFilterableListContainer<T>(getType(),\npiggybackLazyList));\ngetSelect().setContainerDataSource(getBic());\n}","label":[1,0,0,0]}
{"id":22702,"original_code":"public CompraEntity find(Long compraId) {\n    LOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\n    return em.find(CompraEntity.class, compraId);\n}","code":"public CompraEntity find(Long compraId) {\n    LOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\n    return em.find(CompraEntity.class, compraId);\n}","cleancode":"public compraentity find(long compraid) { logger.log(level.info, \"buscando compra con el id={0}\", compraid); return em.find(compraentity.class, compraid); }","comment":"\/** * metodo para buscar una compra (read) * @param compraid, id de la compra a buscar * @return la compra con el id ingresado por parametro *\/","repo":"Uniandes-isis2603\/s2_Boletas","code_context_2":"public CompraEntity find(Long compraId) {\nLOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\nreturn em.find(CompraEntity.class, compraId);\n}","code_context_10":"public CompraEntity find(Long compraId) {\nLOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\nreturn em.find(CompraEntity.class, compraId);\n}","code_context_20":"public CompraEntity find(Long compraId) {\nLOGGER.log(Level.INFO, \"Buscando compra con el id={0}\", compraId);\nreturn em.find(CompraEntity.class, compraId);\n}","label":[0,1,0,0]}
{"id":22714,"original_code":"public Dialog onCreateDialog(int dialogId){\n\t\tDialog dialog = null;\n\t\ttry{\n\t\t\t\/\/Log.v(TAG, \"onCreateDialog() called\");\n\t\t\tif (mManagedDialogs == null) {\n\t\t\t\tmManagedDialogs = new SparseArray<Dialog>();\n\t\t\t}\n\t\t\tswitch(dialogId){\n\t\t\t\tcase DIALOG_DELETE_ATTACHMENT_ID:\n\t\t\t\t\tdialog = new AlertDialog.Builder(mActivity)\n\t\t\t        .setTitle(R.string.dialog_confirmDelete)\n\t\t\t        .setIcon(android.R.drawable.ic_dialog_alert)\n\t\t\t        .setMessage(R.string.dialog_areYouSure)\n\t\t\t        .setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\n\t\t\t    \t\tpublic void onClick(DialogInterface dialog, int whichButton){\n\t\t\t    \t\t\ttry{\n\t\t\t    \t\t\t\tif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\n\t\t\t    \t\t\t\t\tif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\n\t\t\t    \t\t\t\t\t\tErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n\t\t\t    \t\t\t\t\t}\n\t\t\t    \t\t\t\t\t\/\/ Notify the ListAdapter that it's cursor needs refreshing\n\t\t\t    \t\t\t\t\tnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n\t\t\t    \t\t\t\t}\n\t\t\t    \t\t\t}catch(HandledException h){ \/\/ Ignore.\n\t\t\t    \t\t\t}catch(Exception exp){\n\t\t\t    \t\t\t\tLog.e(TAG, \"ERR000FD\", exp);\n\t\t\t    \t\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n\t\t\t    \t\t\t}\n\t\t\t    \t\t}\n\t\t\t    \t})\n\t\t\t        .setNegativeButton(R.string.button_no, null)\n\t\t\t    \t.create();\n\t\t            mManagedDialogs.put(dialogId, dialog);\n\t\t            break;\n\t\t\t} \n\t\t}catch(HandledException h){ \/\/ Ignore.\n\t\t}catch(Exception exp){\n\t\t\tLog.e(TAG, \"ERR000FC\", exp);\n\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n\t\t}\n\t\treturn dialog;\n\t}","code":"public Dialog onCreateDialog(int dialogId){\n\t\tDialog dialog = null;\n\t\ttry{\n\t\t\n\t\t\tif (mManagedDialogs == null) {\n\t\t\t\tmManagedDialogs = new SparseArray<Dialog>();\n\t\t\t}\n\t\t\tswitch(dialogId){\n\t\t\t\tcase DIALOG_DELETE_ATTACHMENT_ID:\n\t\t\t\t\tdialog = new AlertDialog.Builder(mActivity)\n\t\t\t        .setTitle(R.string.dialog_confirmDelete)\n\t\t\t        .setIcon(android.R.drawable.ic_dialog_alert)\n\t\t\t        .setMessage(R.string.dialog_areYouSure)\n\t\t\t        .setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){\n\t\t\t    \t\tpublic void onClick(DialogInterface dialog, int whichButton){\n\t\t\t    \t\t\ttry{\n\t\t\t    \t\t\t\tif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\n\t\t\t    \t\t\t\t\tif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\n\t\t\t    \t\t\t\t\t\tErrorUtil.notifyUser(mActivity);\n\t\t\t    \t\t\t\t\t}\n\t\t\t    \t\t\t\t\n\t\t\t    \t\t\t\t\tnotifyDataSetChanged();\n\t\t\t    \t\t\t\t}\n\t\t\t    \t\t\t}catch(HandledException h){\n\t\t\t    \t\t\t}catch(Exception exp){\n\t\t\t    \t\t\t\tLog.e(TAG, \"ERR000FD\", exp);\n\t\t\t    \t\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n\t\t\t    \t\t\t}\n\t\t\t    \t\t}\n\t\t\t    \t})\n\t\t\t        .setNegativeButton(R.string.button_no, null)\n\t\t\t    \t.create();\n\t\t            mManagedDialogs.put(dialogId, dialog);\n\t\t            break;\n\t\t\t} \n\t\t}catch(HandledException h){\n\t\t}catch(Exception exp){\n\t\t\tLog.e(TAG, \"ERR000FC\", exp);\n\t\t\tErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n\t\t}\n\t\treturn dialog;\n\t}","cleancode":"public dialog oncreatedialog(int dialogid){ dialog dialog = null; try{ if (mmanageddialogs == null) { mmanageddialogs = new sparsearray<dialog>(); } switch(dialogid){ case dialog_delete_attachment_id: dialog = new alertdialog.builder(mactivity) .settitle(r.string.dialog_confirmdelete) .seticon(android.r.drawable.ic_dialog_alert) .setmessage(r.string.dialog_areyousure) .setpositivebutton(r.string.button_yes, new android.content.dialoginterface.onclicklistener(){ public void onclick(dialoginterface dialog, int whichbutton){ try{ if( whichbutton == android.content.dialoginterface.button_positive){ if( !completableutil.delete(mactivity, mattachmenturi) ){ errorutil.notifyuser(mactivity); } notifydatasetchanged(); } }catch(handledexception h){ }catch(exception exp){ log.e(tag, \"err000fd\", exp); errorutil.handleexceptionnotifyuser(\"err000fd\", exp, mactivity); } } }) .setnegativebutton(r.string.button_no, null) .create(); mmanageddialogs.put(dialogid, dialog); break; } }catch(handledexception h){ }catch(exception exp){ log.e(tag, \"err000fc\", exp); errorutil.handleexceptionnotifyuser(\"err000fc\", exp, mactivity); } return dialog; }","comment":"\/\/ todo: !! delete key should also delete this attachment.\n\/\/log.v(tag, \"oncreatedialog() called\");\n\/\/ todo: !!! make handler implement the dialoginterface.onclicklistener.\n\/\/ error already handled, so just notify user.\n\/\/ notify the listadapter that it's cursor needs refreshing\n\/\/ todo: !! isn't this a hack to get around the normal observer thing? no, not always. sometimes data changes in the db record that the uri refers to and it isn't really a change to the attachment record.\n\/\/ ignore.\n\/\/ ignore.","repo":"SpencerRiddering\/flingtap-done","code_context_2":"public Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}\n\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\n\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\n\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\n\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);","code_context_10":"public Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}\n\npublic Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\n\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\n\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;","code_context_20":"public Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}\n\npublic Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n\npublic Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n\npublic Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n\npublic Dialog onCreateDialog(int dialogId){\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n\nDialog dialog = null;\ntry{\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}\n\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}\n\n\/\/Log.v(TAG, \"onCreateDialog() called\");\nif (mManagedDialogs == null) {\nmManagedDialogs = new SparseArray<Dialog>();\n}\nswitch(dialogId){\ncase DIALOG_DELETE_ATTACHMENT_ID:\ndialog = new AlertDialog.Builder(mActivity)\n.setTitle(R.string.dialog_confirmDelete)\n.setIcon(android.R.drawable.ic_dialog_alert)\n.setMessage(R.string.dialog_areYouSure)\n.setPositiveButton(R.string.button_yes, new android.content.DialogInterface.OnClickListener(){ \/\/ TODO: !!! Make handler implement the DialogInterface.OnClickListener.\npublic void onClick(DialogInterface dialog, int whichButton){\ntry{\nif( whichButton == android.content.DialogInterface.BUTTON_POSITIVE){\nif( !CompletableUtil.delete(mActivity, mAttachmentUri) ){\nErrorUtil.notifyUser(mActivity); \/\/ Error already handled, so just notify user.\n}\n\/\/ Notify the ListAdapter that it's cursor needs refreshing\nnotifyDataSetChanged(); \/\/ TODO: !! Isn't this a hack to get around the normal observer thing? NO, not always. Sometimes data changes in the db record that the URI refers to and it isn't really a change to the attachment record.\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FD\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FD\", exp, mActivity);\n}\n}\n})\n.setNegativeButton(R.string.button_no, null)\n.create();\nmManagedDialogs.put(dialogId, dialog);\nbreak;\n}\n}catch(HandledException h){ \/\/ Ignore.\n}catch(Exception exp){\nLog.e(TAG, \"ERR000FC\", exp);\nErrorUtil.handleExceptionNotifyUser(\"ERR000FC\", exp, mActivity);\n}\nreturn dialog;\n}","label":[1,1,0,0]}
{"id":30955,"original_code":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\n\tpublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\n\t\t\tHttpServletRequest req, RedirectAttributes flash) {\n\t\tlogger.info(\"contactar-anunciante\");\n\t\tInteger id = Integer.parseInt(req.getParameter(\"id\"));\n\t\ttry {\n\t\t\tVehiculo veh = vehiculoService.findById(id);\n\t\t\tString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\t\t\t\/\/ Email message\n\t\t\tSimpleMailMessage shareEmail = new SimpleMailMessage();\n\t\t\tshareEmail.setTo(email);\n\t\t\tshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\n\t\t\tshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n\t\t\t\t\t+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n\t\t\t\t\t+ id);\n\t\t\temailService.sendEmail(shareEmail);\n\t\t\tmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\n\t\t\tlogger.info(\"Email enviado correctamente\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"redirect:\/anuncio\/detalle\/\" + id;\n\t}","code":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\n\tpublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\n\t\t\tHttpServletRequest req, RedirectAttributes flash) {\n\t\tlogger.info(\"contactar-anunciante\");\n\t\tInteger id = Integer.parseInt(req.getParameter(\"id\"));\n\t\ttry {\n\t\t\tVehiculo veh = vehiculoService.findById(id);\n\t\t\tString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\t\t\n\t\t\tSimpleMailMessage shareEmail = new SimpleMailMessage();\n\t\t\tshareEmail.setTo(email);\n\t\t\tshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\n\t\t\tshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n\t\t\t\t\t+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n\t\t\t\t\t+ id);\n\t\t\temailService.sendEmail(shareEmail);\n\t\t\tmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\n\t\t\tlogger.info(\"Email enviado correctamente\");\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn \"redirect:\/anuncio\/detalle\/\" + id;\n\t}","cleancode":"@requestmapping(value = \"\/shareanuncio\", method = requestmethod.post) public string shareanuncio(@requestparam(\"email\") string email, model model, authentication authentication, httpservletrequest req, redirectattributes flash) { logger.info(\"contactar-anunciante\"); integer id = integer.parseint(req.getparameter(\"id\")); try { vehiculo veh = vehiculoservice.findbyid(id); string appurl = req.getscheme() + \":\/\/\" + req.getservername() + \":\" + req.getserverport(); simplemailmessage shareemail = new simplemailmessage(); shareemail.setto(email); shareemail.setsubject(\"coches: un amigo te recomienda este anuncio\"); shareemail.settext(\"\u00a1hola!\\n\" + \"un amigo se ha acordado de ti al ver este anuncio \" + veh.getmarca() + \" y cree que te puede interesar.\" + \"\\n\u00bftienes curiosidad?\\n\" + appurl + \"\/anuncio\/detalle\/\" + id); emailservice.sendemail(shareemail); model.addattribute(\"emailsend\", \"el correo se envio correctamente\"); logger.info(\"email enviado correctamente\"); } catch (exception e) { e.printstacktrace(); } return \"redirect:\/anuncio\/detalle\/\" + id; }","comment":"\/** * metodo para compartir el anuncio a traves del email * * @param email * @param model * @param authentication * @param req * @param flash * @return *\/\n\/\/ email message","repo":"adriancice\/adrian-pfm","code_context_2":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\npublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\nHttpServletRequest req, RedirectAttributes flash) {\nlogger.info(\"contactar-anunciante\");\nInteger id = Integer.parseInt(req.getParameter(\"id\"));\ntry {\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);\nshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\nshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n+ id);\nemailService.sendEmail(shareEmail);\nmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\nlogger.info(\"Email enviado correctamente\");\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn \"redirect:\/anuncio\/detalle\/\" + id;\n}\n\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);","code_context_10":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\npublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\nHttpServletRequest req, RedirectAttributes flash) {\nlogger.info(\"contactar-anunciante\");\nInteger id = Integer.parseInt(req.getParameter(\"id\"));\ntry {\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);\nshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\nshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n+ id);\nemailService.sendEmail(shareEmail);\nmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\nlogger.info(\"Email enviado correctamente\");\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn \"redirect:\/anuncio\/detalle\/\" + id;\n}\n\n@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\npublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\nHttpServletRequest req, RedirectAttributes flash) {\nlogger.info(\"contactar-anunciante\");\nInteger id = Integer.parseInt(req.getParameter(\"id\"));\ntry {\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);\nshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\nshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n+ id);\nemailService.sendEmail(shareEmail);\nmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\nlogger.info(\"Email enviado correctamente\");\n} catch (Exception e) {","code_context_20":"@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\npublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\nHttpServletRequest req, RedirectAttributes flash) {\nlogger.info(\"contactar-anunciante\");\nInteger id = Integer.parseInt(req.getParameter(\"id\"));\ntry {\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);\nshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\nshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n+ id);\nemailService.sendEmail(shareEmail);\nmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\nlogger.info(\"Email enviado correctamente\");\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn \"redirect:\/anuncio\/detalle\/\" + id;\n}\n\n@RequestMapping(value = \"\/shareAnuncio\", method = RequestMethod.POST)\npublic String shareAnuncio(@RequestParam(\"email\") String email, Model model, Authentication authentication,\nHttpServletRequest req, RedirectAttributes flash) {\nlogger.info(\"contactar-anunciante\");\nInteger id = Integer.parseInt(req.getParameter(\"id\"));\ntry {\nVehiculo veh = vehiculoService.findById(id);\nString appUrl = req.getScheme() + \":\/\/\" + req.getServerName() + \":\" + req.getServerPort();\n\/\/ Email message\nSimpleMailMessage shareEmail = new SimpleMailMessage();\nshareEmail.setTo(email);\nshareEmail.setSubject(\"Coches: Un amigo te recomienda este anuncio\");\nshareEmail.setText(\"\u00a1Hola!\\n\" + \"Un amigo se ha acordado de ti al ver este anuncio \" + veh.getMarca()\n+ \" y cree que te puede interesar.\" + \"\\n\u00bfTienes curiosidad?\\n\" + appUrl + \"\/anuncio\/detalle\/\"\n+ id);\nemailService.sendEmail(shareEmail);\nmodel.addAttribute(\"emailSend\", \"El correo se envio correctamente\");\nlogger.info(\"Email enviado correctamente\");\n} catch (Exception e) {\ne.printStackTrace();\n}\nreturn \"redirect:\/anuncio\/detalle\/\" + id;\n}","label":[0,0,0,0]}
{"id":14663,"original_code":"private void initShape() {\n        \/\/ TODO: these could be optimised\n        float cx = dim * 0.5f;\n        float cy = dim * 0.5f + 1;\n        float r  = (dim - 3) * 0.5f;\n        float rh = r * 0.4f;\n        for (int i = 0; i < 10; i++) {\n            double ang = Math.PI\/180 * (i * 36 - 90);\n            float ri   = i % 2 == 0 ? r : rh;\n            float x    = (float) Math.cos(ang) * ri + cx;\n            float y    = (float) Math.sin(ang) * ri + cy;\n            if (i == 0) {\n                gp.moveTo(x, y);\n            } else {\n                gp.lineTo(x, y);\n            }\n        }\n        gp.closePath();\n    }","code":"private void initShape() {\n       \n        float cx = dim * 0.5f;\n        float cy = dim * 0.5f + 1;\n        float r  = (dim - 3) * 0.5f;\n        float rh = r * 0.4f;\n        for (int i = 0; i < 10; i++) {\n            double ang = Math.PI\/180 * (i * 36 - 90);\n            float ri   = i % 2 == 0 ? r : rh;\n            float x    = (float) Math.cos(ang) * ri + cx;\n            float y    = (float) Math.sin(ang) * ri + cy;\n            if (i == 0) {\n                gp.moveTo(x, y);\n            } else {\n                gp.lineTo(x, y);\n            }\n        }\n        gp.closePath();\n    }","cleancode":"private void initshape() { float cx = dim * 0.5f; float cy = dim * 0.5f + 1; float r = (dim - 3) * 0.5f; float rh = r * 0.4f; for (int i = 0; i < 10; i++) { double ang = math.pi\/180 * (i * 36 - 90); float ri = i % 2 == 0 ? r : rh; float x = (float) math.cos(ang) * ri + cx; float y = (float) math.sin(ang) * ri + cy; if (i == 0) { gp.moveto(x, y); } else { gp.lineto(x, y); } } gp.closepath(); }","comment":"\/\/ todo: these could be optimised","repo":"Sciss\/Rating","code_context_2":"private void initShape() {\n\/\/ TODO: these could be optimised\nfloat cx = dim * 0.5f;\nfloat cy = dim * 0.5f + 1;","code_context_10":"private void initShape() {\n\/\/ TODO: these could be optimised\nfloat cx = dim * 0.5f;\nfloat cy = dim * 0.5f + 1;\nfloat r = (dim - 3) * 0.5f;\nfloat rh = r * 0.4f;\nfor (int i = 0; i < 10; i++) {\ndouble ang = Math.PI\/180 * (i * 36 - 90);\nfloat ri = i % 2 == 0 ? r : rh;\nfloat x = (float) Math.cos(ang) * ri + cx;\nfloat y = (float) Math.sin(ang) * ri + cy;\nif (i == 0) {","code_context_20":"private void initShape() {\n\/\/ TODO: these could be optimised\nfloat cx = dim * 0.5f;\nfloat cy = dim * 0.5f + 1;\nfloat r = (dim - 3) * 0.5f;\nfloat rh = r * 0.4f;\nfor (int i = 0; i < 10; i++) {\ndouble ang = Math.PI\/180 * (i * 36 - 90);\nfloat ri = i % 2 == 0 ? r : rh;\nfloat x = (float) Math.cos(ang) * ri + cx;\nfloat y = (float) Math.sin(ang) * ri + cy;\nif (i == 0) {\ngp.moveTo(x, y);\n} else {\ngp.lineTo(x, y);\n}\n}\ngp.closePath();\n}","label":[1,0,0,0]}
{"id":22873,"original_code":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n        \/\/ TODO Insert code for assignment 5.2.a\n        for(Rectangle rectangle:rectangles){\n            if(rectangle.getX() < this.gridRectangle.getX() ||\n               rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n               rectangle.getY() < this.gridRectangle.getY() ||\n               rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n            ){\n                throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n            }\n            int startX = (int)transformX(rectangle.getX());\n            int startY = (int)transformY(rectangle.getY());\n            int endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\n            if(endX == this.GRID_RESOLUTION_X){\n                endX = this.GRID_RESOLUTION_X - 1;\n            }\n            int endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\n            if(endY == this.GRID_RESOLUTION_Y){\n                endY = this.GRID_RESOLUTION_Y - 1;\n            }\n            for(int i = startX; i <= endX; i++){\n                for(int j = startY; j<=endY; j++){\n                    map[j][i].add(rectangle);\n                }\n            }\n        }\n    }","code":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n       \n        for(Rectangle rectangle:rectangles){\n            if(rectangle.getX() < this.gridRectangle.getX() ||\n               rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n               rectangle.getY() < this.gridRectangle.getY() ||\n               rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n            ){\n                throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n            }\n            int startX = (int)transformX(rectangle.getX());\n            int startY = (int)transformY(rectangle.getY());\n            int endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\n            if(endX == this.GRID_RESOLUTION_X){\n                endX = this.GRID_RESOLUTION_X - 1;\n            }\n            int endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\n            if(endY == this.GRID_RESOLUTION_Y){\n                endY = this.GRID_RESOLUTION_Y - 1;\n            }\n            for(int i = startX; i <= endX; i++){\n                for(int j = startY; j<=endY; j++){\n                    map[j][i].add(rectangle);\n                }\n            }\n        }\n    }","cleancode":"private void fillcollisionmap(set<rectangle> rectangles) throws collisionmapoutofboundsexception { for(rectangle rectangle:rectangles){ if(rectangle.getx() < this.gridrectangle.getx() || rectangle.getx() + rectangle.getwidth() > this.gridrectangle.getx() + this.gridrectangle.getwidth() || rectangle.gety() < this.gridrectangle.gety() || rectangle.gety() + rectangle.getheight() > this.gridrectangle.gety() + this.gridrectangle.getheight() ){ throw new collisionmapoutofboundsexception(\"a rectangle is out of the bounds of this rectangle\"); } int startx = (int)transformx(rectangle.getx()); int starty = (int)transformy(rectangle.gety()); int endx = (int)transformx(rectangle.getx() + rectangle.getwidth()); if(endx == this.grid_resolution_x){ endx = this.grid_resolution_x - 1; } int endy = (int)transformy(rectangle.gety() + rectangle.getheight()); if(endy == this.grid_resolution_y){ endy = this.grid_resolution_y - 1; } for(int i = startx; i <= endx; i++){ for(int j = starty; j<=endy; j++){ map[j][i].add(rectangle); } } } }","comment":"\/** * fill this collision map with a set of rectangles. a rectangle is added to a * cell if it overlaps with it (that includes just touching it). afterwards, * each cell of the collision map should contain all rectangles that cover the * cell. * * @param rectangles is a set of rectangles to insert, it must be != null * @throws collisionmapoutofboundsexception if a rectangle is out of the bounds * of this rectangle *\/\n\/\/ todo insert code for assignment 5.2.a","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","code_context_2":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\nif(endX == this.GRID_RESOLUTION_X){\nendX = this.GRID_RESOLUTION_X - 1;\n}\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\nif(endY == this.GRID_RESOLUTION_Y){\nendY = this.GRID_RESOLUTION_Y - 1;\n}\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nmap[j][i].add(rectangle);\n}\n}\n}\n}\n\nprivate void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||","code_context_10":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\nif(endX == this.GRID_RESOLUTION_X){\nendX = this.GRID_RESOLUTION_X - 1;\n}\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\nif(endY == this.GRID_RESOLUTION_Y){\nendY = this.GRID_RESOLUTION_Y - 1;\n}\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nmap[j][i].add(rectangle);\n}\n}\n}\n}\n\nprivate void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());","code_context_20":"private void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\nif(endX == this.GRID_RESOLUTION_X){\nendX = this.GRID_RESOLUTION_X - 1;\n}\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\nif(endY == this.GRID_RESOLUTION_Y){\nendY = this.GRID_RESOLUTION_Y - 1;\n}\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nmap[j][i].add(rectangle);\n}\n}\n}\n}\n\nprivate void fillCollisionMap(Set<Rectangle> rectangles) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.a\nfor(Rectangle rectangle:rectangles){\nif(rectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth());\nif(endX == this.GRID_RESOLUTION_X){\nendX = this.GRID_RESOLUTION_X - 1;\n}\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight());\nif(endY == this.GRID_RESOLUTION_Y){\nendY = this.GRID_RESOLUTION_Y - 1;\n}\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){","label":[0,1,0,0]}
{"id":22874,"original_code":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n        \/\/ TODO Insert code for assignment 5.2.b\n        if(\n                rectangle.getX() < this.gridRectangle.getX() ||\n                rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n                rectangle.getY() < this.gridRectangle.getY() ||\n                rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n        ){\n            throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n        }\n        Set<Rectangle> rectangleSet = new HashSet<>();\n        int startX = (int)transformX(rectangle.getX());\n        int startY = (int)transformY(rectangle.getY());\n        int endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\n        int endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\n        for(int i = startX; i <= endX; i++){\n            for(int j = startY; j<=endY; j++){\n                for(Rectangle re :map[j][i]){\n                    rectangleSet.add(re);\n                }\n            }\n        }\n        return rectangleSet;\n    }","code":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n       \n        if(\n                rectangle.getX() < this.gridRectangle.getX() ||\n                rectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\n                rectangle.getY() < this.gridRectangle.getY() ||\n                rectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n        ){\n            throw new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n        }\n        Set<Rectangle> rectangleSet = new HashSet<>();\n        int startX = (int)transformX(rectangle.getX());\n        int startY = (int)transformY(rectangle.getY());\n        int endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\n        int endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\n        for(int i = startX; i <= endX; i++){\n            for(int j = startY; j<=endY; j++){\n                for(Rectangle re :map[j][i]){\n                    rectangleSet.add(re);\n                }\n            }\n        }\n        return rectangleSet;\n    }","cleancode":"private set<rectangle> getcollisioncandidates(final rectangle rectangle) throws collisionmapoutofboundsexception { if( rectangle.getx() < this.gridrectangle.getx() || rectangle.getx() + rectangle.getwidth() > this.gridrectangle.getx() + this.gridrectangle.getwidth() || rectangle.gety() < this.gridrectangle.gety() || rectangle.gety() + rectangle.getheight() > this.gridrectangle.gety() + this.gridrectangle.getheight() ){ throw new collisionmapoutofboundsexception(\"a rectangle is out of the bounds of this rectangle\"); } set<rectangle> rectangleset = new hashset<>(); int startx = (int)transformx(rectangle.getx()); int starty = (int)transformy(rectangle.gety()); int endx = (int)transformx(rectangle.getx() + rectangle.getwidth()) + 1; int endy = (int)transformy(rectangle.gety() + rectangle.getheight()) + 1; for(int i = startx; i <= endx; i++){ for(int j = starty; j<=endy; j++){ for(rectangle re :map[j][i]){ rectangleset.add(re); } } } return rectangleset; }","comment":"\/** * given a rectangle, this method returns a set of potential colliding * rectangles (rectangles in the same cells). * * @param rectangle the rectangle to test overlap with must be != null * @return a set with all rectangles that possibly overlap with rectangle * @throws collisionmapoutofboundsexception if the rectangle is out of the * bounding box for this collisionmap *\/\n\/\/ todo insert code for assignment 5.2.b","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","code_context_2":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nSet<Rectangle> rectangleSet = new HashSet<>();\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nfor(Rectangle re :map[j][i]){\nrectangleSet.add(re);\n}\n}\n}\nreturn rectangleSet;\n}\n\nprivate Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||","code_context_10":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nSet<Rectangle> rectangleSet = new HashSet<>();\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nfor(Rectangle re :map[j][i]){\nrectangleSet.add(re);\n}\n}\n}\nreturn rectangleSet;\n}\n\nprivate Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nSet<Rectangle> rectangleSet = new HashSet<>();\nint startX = (int)transformX(rectangle.getX());","code_context_20":"private Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nSet<Rectangle> rectangleSet = new HashSet<>();\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nfor(Rectangle re :map[j][i]){\nrectangleSet.add(re);\n}\n}\n}\nreturn rectangleSet;\n}\n\nprivate Set<Rectangle> getCollisionCandidates(final Rectangle rectangle) throws CollisionMapOutOfBoundsException {\n\/\/ TODO Insert code for assignment 5.2.b\nif(\nrectangle.getX() < this.gridRectangle.getX() ||\nrectangle.getX() + rectangle.getWidth() > this.gridRectangle.getX() + this.gridRectangle.getWidth() ||\nrectangle.getY() < this.gridRectangle.getY() ||\nrectangle.getY() + rectangle.getHeight() > this.gridRectangle.getY() + this.gridRectangle.getHeight()\n){\nthrow new CollisionMapOutOfBoundsException(\"a rectangle is out of the bounds of this rectangle\");\n}\nSet<Rectangle> rectangleSet = new HashSet<>();\nint startX = (int)transformX(rectangle.getX());\nint startY = (int)transformY(rectangle.getY());\nint endX = (int)transformX(rectangle.getX() + rectangle.getWidth()) + 1;\nint endY = (int)transformY(rectangle.getY() + rectangle.getHeight()) + 1;\nfor(int i = startX; i <= endX; i++){\nfor(int j = startY; j<=endY; j++){\nfor(Rectangle re :map[j][i]){\nrectangleSet.add(re);\n}\n}\n}","label":[0,1,0,0]}
{"id":22875,"original_code":"public boolean collide(final Rectangle rectangle) {\n        \/\/ TODO Insert code for assignment 5.2.c\n        if(rectangle == null){\n            throw new IllegalArgumentException(\"rectangle is null\");\n        }\n        boolean flag = false;\n        try{\n            Set<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\n            for(Rectangle re:rectangleSet){\n                if(re.intersects(rectangle)){\n                    flag = true;\n                }\n            }\n        }catch (Exception e){\n            System.out.println(e.getMessage());\n        }finally {\n            return flag;\n        }\n    }","code":"public boolean collide(final Rectangle rectangle) {\n       \n        if(rectangle == null){\n            throw new IllegalArgumentException(\"rectangle is null\");\n        }\n        boolean flag = false;\n        try{\n            Set<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\n            for(Rectangle re:rectangleSet){\n                if(re.intersects(rectangle)){\n                    flag = true;\n                }\n            }\n        }catch (Exception e){\n            System.out.println(e.getMessage());\n        }finally {\n            return flag;\n        }\n    }","cleancode":"public boolean collide(final rectangle rectangle) { if(rectangle == null){ throw new illegalargumentexception(\"rectangle is null\"); } boolean flag = false; try{ set<rectangle> rectangleset = this.getcollisioncandidates(rectangle); for(rectangle re:rectangleset){ if(re.intersects(rectangle)){ flag = true; } } }catch (exception e){ system.out.println(e.getmessage()); }finally { return flag; } }","comment":"\/** * check if the given rectangle collides with rectangles in the * {@link collisionmap}. * * @param rectangle the rectangle to check for collision * @return true if the given rectangle intersects one of the rectangles in the * collision map. * @throws illegalargumentexception if rectangle is null *\/\n\/\/ todo insert code for assignment 5.2.c","repo":"SiyuChen1\/Datenstrukturen-und-Algorithmen-SS21","code_context_2":"public boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");\n}\nboolean flag = false;\ntry{\nSet<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\nfor(Rectangle re:rectangleSet){\nif(re.intersects(rectangle)){\nflag = true;\n}\n}\n}catch (Exception e){\nSystem.out.println(e.getMessage());\n}finally {\nreturn flag;\n}\n}\n\npublic boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");","code_context_10":"public boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");\n}\nboolean flag = false;\ntry{\nSet<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\nfor(Rectangle re:rectangleSet){\nif(re.intersects(rectangle)){\nflag = true;\n}\n}\n}catch (Exception e){\nSystem.out.println(e.getMessage());\n}finally {\nreturn flag;\n}\n}\n\npublic boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");\n}\nboolean flag = false;\ntry{\nSet<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\nfor(Rectangle re:rectangleSet){\nif(re.intersects(rectangle)){\nflag = true;\n}","code_context_20":"public boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");\n}\nboolean flag = false;\ntry{\nSet<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\nfor(Rectangle re:rectangleSet){\nif(re.intersects(rectangle)){\nflag = true;\n}\n}\n}catch (Exception e){\nSystem.out.println(e.getMessage());\n}finally {\nreturn flag;\n}\n}\n\npublic boolean collide(final Rectangle rectangle) {\n\/\/ TODO Insert code for assignment 5.2.c\nif(rectangle == null){\nthrow new IllegalArgumentException(\"rectangle is null\");\n}\nboolean flag = false;\ntry{\nSet<Rectangle> rectangleSet = this.getCollisionCandidates(rectangle);\nfor(Rectangle re:rectangleSet){\nif(re.intersects(rectangle)){\nflag = true;\n}\n}\n}catch (Exception e){\nSystem.out.println(e.getMessage());\n}finally {\nreturn flag;\n}\n}","label":[0,1,0,0]}
{"id":14690,"original_code":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\n        Objects.requireNonNull(inputNames);\n        this.inputNames = inputNames;\n        return this;\n    }","code":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\n        Objects.requireNonNull(inputNames);\n        this.inputNames = inputNames;\n        return this;\n    }","cleancode":"public mapperbuilder withinputnames(iterable<string> inputnames) { objects.requirenonnull(inputnames); this.inputnames = inputnames; return this; }","comment":"\/\/ todo: 8\/11\/20 defensively copy all collections and check for nulls?","repo":"andbi-redpill\/datasonnet-mapper","code_context_2":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\nObjects.requireNonNull(inputNames);\nthis.inputNames = inputNames;\nreturn this;\n}","code_context_10":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\nObjects.requireNonNull(inputNames);\nthis.inputNames = inputNames;\nreturn this;\n}","code_context_20":"public MapperBuilder withInputNames(Iterable<String> inputNames) {\nObjects.requireNonNull(inputNames);\nthis.inputNames = inputNames;\nreturn this;\n}","label":[0,1,0,0]}
{"id":14723,"original_code":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\n\t\t\tGestorDatosComponentes gestorDatos) {\n\t\t\/\/ Id de usuario\n\t\tInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\t\t\/\/ Usuarios concurrentes\n\t\tString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\t\t\n\t\tInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\t\t\/\/ Tiempo\n\t\tString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\t\t\n\t\tInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\t\t\/\/ Resoluci\u00f3n\n\t\tString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\t\t\n\t\tInteger intIdResolution = Integer.valueOf(strIdResolution);\n\t\t\/\/ Disponibilidad\n\t\tBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\t\t\n\t\tInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\n\t\tFloat precioTotal = null;\n\t\tif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\n\t\t\tprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\n\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\n\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\n\t\t}else{\n\t\t\tif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\n\t\t\t\tFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\t\t\n\t\t\t}else{\n\t\t\t\tFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\n\t\t\t\tFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\n\t\t\t}\n\t\t}\n\t\t\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\t\t\/\/ entre ficheros de varias configuraciones\n\t\ttry {\n\t\t\tString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\n\t\t\tString resultadoAcuerdo = \"noAgreement\";\n\t\t\tif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\t\t\t\t\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\n\t\t\t\tString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\t\t\t\t\/\/ NVPDecoder object is created\n\t\t\t\tNVPDecoder resultValues = new NVPDecoder();\n\t\t\t\t\/\/ decode method of NVPDecoder will parse the request and decode the\n\t\t\t\t\/\/ name and value pair\n\t\t\t\tresultValues.decode(ppresponse);\n\t\t\t\t\/\/ checks for Acknowledgement and redirects accordingly to display\n\t\t\t\t\/\/ error messages\n\t\t\t\tString strAck = resultValues.get(\"ACK\");\n\t\t\t\tif (strAck != null\n\t\t\t\t\t\t&& !(strAck.equals(\"Success\") || strAck\n\t\t\t\t\t\t\t\t.equals(\"SuccessWithWarning\"))) {\n\t\t\t\t\t\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\t\t\t\t\n\t\t\t\t\tresultadoAcuerdo = \"noAgreement\";\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\n\t\t\t\t\tString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\n\t\t\t\t\tif(status.compareToIgnoreCase(\"Active\")==0){\n\t\t\t\t\t\tresultadoAcuerdo = \"agreement\";\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\n\t\t\tString idAlert = \"alertInfoUploadProduction\";\n\t\t\tif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\t\t\t\tidAlert = \"alertInfoBillingAgreement\";\n\t\t\t\t\/\/ Mostrar mensaje \u00e9xito\n\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\n\t\t\t\t\t\tgetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\t\t\t\t\n\t\t\t}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\n\t\t\t\tIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\n\t\t\t\tString mensaje = salida[0].getString(\"FIONEG003010\");\n\t\t\t\t\/\/ Mostrar alert informando al usuario del problema\t\t\t\t\n\t\t\t\tif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\t\t\t\t\t\/\/ Mostrar mensaje \u00e9xito\n\t\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t\/\/ Mostrar mensaje error\n\t\t\t\t\t\/\/ Asignar t\u00edtulo y contenido adecuado\n\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\/\/ Cerramos la ventana de confirmaci\u00f3n\n\t\t\tgestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\t\t\t\/\/ Cerramos el di\u00e1logo de precios\n\t\t\tgestorEstados.closeModalAlert(\"dialogoPrecios\");\n\t\t} catch (FactoriaDatosException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (PersistenciaException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (FawnaInvokerException e) {\n\t\t\t\/\/ TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}catch(PayPalException ppEx){\t\t\t\t\n\t\t\tppEx.printStackTrace();\n\t\t}\t\t\n\t}","code":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\n\t\t\tGestorDatosComponentes gestorDatos) {\n\t\n\t\tInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\t\n\t\tString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\t\t\n\t\tInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\t\n\t\tString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\t\t\n\t\tInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\t\t\tString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\t\t\n\t\tInteger intIdResolution = Integer.valueOf(strIdResolution);\n\t\n\t\tBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\t\t\n\t\tInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\n\t\tFloat precioTotal = null;\n\t\tif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\n\t\t\tprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\n\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\n\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\n\t\t}else{\n\t\t\tif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\n\t\t\t\tFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\t\t\t\t\n\t\t\t}else{\n\t\t\t\tFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\n\t\t\t\tFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\n\t\t\t\tBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\n\t\t\t\tbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\t\t\t\tprecioTotal = bidPrecioTotal.floatValue();\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\n\t\t\tString resultadoAcuerdo = \"noAgreement\";\n\t\t\tif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\t\t\t\n\t\t\t\tString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\t\t\t\n\t\t\t\tNVPDecoder resultValues = new NVPDecoder();\n\t\t\t\n\t\t\t\n\t\t\t\tresultValues.decode(ppresponse);\n\t\t\t\n\t\t\t\n\t\t\t\tString strAck = resultValues.get(\"ACK\");\n\t\t\t\tif (strAck != null\n\t\t\t\t\t\t&& !(strAck.equals(\"Success\") || strAck\n\t\t\t\t\t\t\t\t.equals(\"SuccessWithWarning\"))) {\n\t\t\t\t\t\t\t\tresultadoAcuerdo = \"noAgreement\";\n\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\n\t\t\t\t\tif(status.compareToIgnoreCase(\"Active\")==0){\n\t\t\t\t\t\tresultadoAcuerdo = \"agreement\";\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\tString idAlert = \"alertInfoUploadProduction\";\n\t\t\tif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\t\t\t\tidAlert = \"alertInfoBillingAgreement\";\n\t\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\n\t\t\t\t\t\tgetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\t\t\t\t\n\t\t\t}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0)\n\t\t\t\tIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\n\t\t\t\tString mensaje = salida[0].getString(\"FIONEG003010\");\n\t\t\t\n\t\t\t\tif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\t\t\t\t\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\n\t\t\t\t\t\t\t\t\thandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\n\t\t\t\t\t\t\tgetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\t\tgestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\t\t\t\t\tgestorEstados.closeModalAlert(\"dialogoPrecios\");\n\t\t} catch (FactoriaDatosException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (PersistenciaException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t} catch (FawnaInvokerException e) {\n\t\t\n\t\t\te.printStackTrace();\n\t\t}catch(PayPalException ppEx){\t\t\t\t\n\t\t\tppEx.printStackTrace();\n\t\t}\t\t\n\t}","cleancode":"public void procesarajaxchangelistener(gestorestadocomponentes gestorestados, gestordatoscomponentes gestordatos) { integer intcodusuario = contextutils.getuseridasinteger(); string strnumusersconcurrentes = (string)gestordatos.getvalue(\"numusuariosconcu\"); integer intnumuserconcurrentes = integer.valueof(strnumusersconcurrentes); string stridunidadtiempo = (string)gestordatos.getvalue(\"idunidadtiempo\"); integer intidunidadtiempo = integer.valueof(stridunidadtiempo); string stridresolution = (string)gestordatos.getvalue(\"resolution\"); integer intidresolution = integer.valueof(stridresolution); boolean highavailability = (boolean)gestordatos.getvalue(\"checkavailability\"); integer inthighavailability = highavailability?new integer(1):new integer(0); float preciototal = null; if(gestordatos.getvalue(\"preciototal\") != null && !\"\".equals(gestordatos.getvalue(\"preciototal\")) && !\"0.0\".equals(gestordatos.getvalue(\"preciototal\"))){ preciototal = (float)gestordatos.getvalue(\"preciototal\"); bigdecimal bidpreciototal = new bigdecimal(preciototal); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); }else{ if(gestordatos.getvalue(\"preciototaltiempo\") != null && !\"\".equals(gestordatos.getvalue(\"preciototaltiempo\")) & !\"0.0\".equals(gestordatos.getvalue(\"preciototaltiempo\"))){ float preciototaltiempo = (float)gestordatos.getvalue(\"preciototaltiempo\"); bigdecimal bidpreciototal = new bigdecimal(preciototaltiempo); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); }else{ float preciototaluso = (float)gestordatos.getvalue(\"preciototaluso\"); float preciohosting = (float)gestordatos.getvalue(\"preciototalhosting\"); bigdecimal bidpreciototal = new bigdecimal(preciototaluso+preciohosting); bidpreciototal = bidpreciototal.setscale(2, roundingmode.half_even); preciototal = bidpreciototal.floatvalue(); } } try { string billingagreementid = helpercontext.getinstance().getvaluecontext(\"secure_user_billing_agreement_id\"); string resultadoacuerdo = \"noagreement\"; if(billingagreementid != null && !\"\".equals(billingagreementid)){ string ppresponse = paypalutilities.getinstance().baupdate(billingagreementid); nvpdecoder resultvalues = new nvpdecoder(); resultvalues.decode(ppresponse); string strack = resultvalues.get(\"ack\"); if (strack != null && !(strack.equals(\"success\") || strack .equals(\"successwithwarning\"))) { resultadoacuerdo = \"noagreement\"; } else { string status = resultvalues.get(\"billingagreementstatus\"); if(status.comparetoignorecase(\"active\")==0){ resultadoacuerdo = \"agreement\"; } } } string idalert = \"alertinfouploadproduction\"; if(resultadoacuerdo.comparetoignorecase(\"noagreement\")==0){ idalert = \"alertinfobillingagreement\"; handlemodalalert(gestordatos, gestorestados, idalert, \"info\", getmessage(\"fiona.alertbillagreement.cabecerapanel.valor\", \"billing agreement needed!\"), getmessage(\"fiona.alertbillagreement.mensajeok.valor\", \"you need to sign a new billing agreement!!\"), \"\", \"\"); }else if(resultadoacuerdo.comparetoignorecase(\"agreement\")==0) icontexto[] salida = invokeuploadtoproduction(intcodusuario, null,intnumuserconcurrentes,intidunidadtiempo, intidresolution,inthighavailability, preciototal); string mensaje = salida[0].getstring(\"fioneg003010\"); if(mensaje.comparetoignorecase(\"ok\")==0){ handlemodalalert(gestordatos, gestorestados, idalert, \"info\", getmessage(\"fiona.alertuploadprodok.cabecerapanel.valor\", \"success!\"), getmessage(\"fiona.alertuploadprodok.mensajeok.valor\", \"request completed!!\"), \"\", \"\"); }else{ handlemodalalert(gestordatos, gestorestados, idalert, \"error\", getmessage(\"fiona.alertuploadprodok.cabecerapanelerror.valor\", \"error!\"), getmessage(\"fiona.alertuploadprodok.mensajeerror.valor\", \"something went wrong...\"), \"\", \"\"); } } gestorestados.closemodalalert(\"alertuploadconfirm\"); gestorestados.closemodalalert(\"dialogoprecios\"); } catch (factoriadatosexception e) { e.printstacktrace(); } catch (persistenciaexception e) { e.printstacktrace(); } catch (fawnainvokerexception e) { e.printstacktrace(); }catch(paypalexception ppex){ ppex.printstacktrace(); } }","comment":"\/\/ id de usuario\n\/\/ usuarios concurrentes\n\/\/ tiempo\n\/\/ resoluci\u00f3n\n\/\/ disponibilidad\n\/\/ todo cambiar el segundo par\u00e1metro cuando podamos distinguir \/\/ entre ficheros de varias configuraciones\n\/\/ hacemos llamada a paypal para comprobar el estado del acuerdo\n\/\/ nvpdecoder object is created\n\/\/ decode method of nvpdecoder will parse the request and decode the \/\/ name and value pair\n\/\/ checks for acknowledgement and redirects accordingly to display \/\/ error messages\n\/\/ todo: indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\n\/\/ en este punto todo ha ido bien as\u00ed que obtenemos el status\n\/\/ comprobaci\u00f3n del resultado del check del acuerdo\n\/\/ mostrar mensaje \u00e9xito \/\/ asignar t\u00edtulo y contenido adecuado\n\/\/ acuerdo activo\n\/\/ mostrar alert informando al usuario del problema\n\/\/ mostrar mensaje \u00e9xito \/\/ asignar t\u00edtulo y contenido adecuado\n\/\/ mostrar mensaje error \/\/ asignar t\u00edtulo y contenido adecuado\n\/\/ cerramos la ventana de confirmaci\u00f3n\n\/\/ cerramos el di\u00e1logo de precios\n\/\/ todo auto-generated catch block\n\/\/ todo auto-generated catch block\n\/\/ todo auto-generated catch block","repo":"adele-robots\/fiona","code_context_2":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\n\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\n\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\n\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\n\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\n\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\n\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {","code_context_10":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\n\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\n\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\n\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\n\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\n\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\n\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\n\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}","code_context_20":"public void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\n\npublic void procesarAjaxChangeListener(GestorEstadoComponentes gestorEstados,\nGestorDatosComponentes gestorDatos) {\n\/\/ Id de usuario\nInteger intCodUsuario = ContextUtils.getUserIdAsInteger();\n\/\/ Usuarios concurrentes\nString strNumUsersConcurrentes = (String)gestorDatos.getValue(\"numUsuariosConcu\");\nInteger intNumUserConcurrentes = Integer.valueOf(strNumUsersConcurrentes);\n\/\/ Tiempo\nString strIdUnidadTiempo = (String)gestorDatos.getValue(\"idUnidadTiempo\");\nInteger intIdUnidadTiempo = Integer.valueOf(strIdUnidadTiempo);\n\/\/ Resoluci\u00f3n\nString strIdResolution = (String)gestorDatos.getValue(\"resolution\");\nInteger intIdResolution = Integer.valueOf(strIdResolution);\n\/\/ Disponibilidad\nBoolean highAvailability = (Boolean)gestorDatos.getValue(\"checkAvailability\");\nInteger intHighAvailability = highAvailability?new Integer(1):new Integer(0);\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n\nFloat precioTotal = null;\nif(gestorDatos.getValue(\"precioTotal\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotal\")) && !\"0.0\".equals(gestorDatos.getValue(\"precioTotal\"))){\nprecioTotal = (Float)gestorDatos.getValue(\"precioTotal\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotal);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\n}else{\nif(gestorDatos.getValue(\"precioTotalTiempo\") != null && !\"\".equals(gestorDatos.getValue(\"precioTotalTiempo\")) & !\"0.0\".equals(gestorDatos.getValue(\"precioTotalTiempo\"))){\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n\nFloat precioTotalTiempo = (Float)gestorDatos.getValue(\"precioTotalTiempo\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalTiempo);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}else{\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\n\nFloat precioTotalUso = (Float)gestorDatos.getValue(\"precioTotalUso\");\nFloat precioHosting = (Float)gestorDatos.getValue(\"precioTotalHosting\");\nBigDecimal bidPrecioTotal = new BigDecimal(precioTotalUso+precioHosting);\nbidPrecioTotal = bidPrecioTotal.setScale(2, RoundingMode.HALF_EVEN);\nprecioTotal = bidPrecioTotal.floatValue();\n}\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\n\n}\n\/\/ TODO cambiar el segundo par\u00e1metro cuando podamos distinguir\n\/\/ entre ficheros de varias configuraciones\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\ntry {\nString billingAgreementId = HelperContext.getInstance().getValueContext(\"SECURE_USER_BILLING_AGREEMENT_ID\");\nString resultadoAcuerdo = \"noAgreement\";\nif(billingAgreementId != null && !\"\".equals(billingAgreementId)){\n\/\/ Hacemos llamada a Paypal para comprobar el estado del acuerdo\nString ppresponse = PaypalUtilities.getInstance().baUpdate(billingAgreementId);\n\/\/ NVPDecoder object is created\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\nNVPDecoder resultValues = new NVPDecoder();\n\/\/ decode method of NVPDecoder will parse the request and decode the\n\/\/ name and value pair\nresultValues.decode(ppresponse);\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\n\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\n\/\/ checks for Acknowledgement and redirects accordingly to display\n\/\/ error messages\nString strAck = resultValues.get(\"ACK\");\nif (strAck != null\n&& !(strAck.equals(\"Success\") || strAck\n.equals(\"SuccessWithWarning\"))) {\n\/\/ TODO: Indicar al usuario que el acuerdo previo ha sido cancelado y ser\u00e1 necesaria la creaci\u00f3n de uno nuevo\nresultadoAcuerdo = \"noAgreement\";\n} else {\n\/\/ En este punto todo ha ido bien as\u00ed que obtenemos el status\nString status = resultValues.get(\"BILLINGAGREEMENTSTATUS\");\nif(status.compareToIgnoreCase(\"Active\")==0){\nresultadoAcuerdo = \"agreement\";\n}\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\n}\n}\n\/\/ Comprobaci\u00f3n del resultado del check del acuerdo\nString idAlert = \"alertInfoUploadProduction\";\nif(resultadoAcuerdo.compareToIgnoreCase(\"noAgreement\")==0){\nidAlert = \"alertInfoBillingAgreement\";\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n}\n\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertBillAgreement.cabeceraPanel.valor\", \"Billing agreement needed!\"),\ngetMessage(\"FIONA.alertBillAgreement.mensajeOK.valor\", \"You need to sign a new billing agreement!!\"), \"\", \"\");\n}else if(resultadoAcuerdo.compareToIgnoreCase(\"agreement\")==0){\/\/ Acuerdo activo\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n}\n\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n}\n\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n}\n\nIContexto[] salida = invokeUploadToProduction(intCodUsuario, null,intNumUserConcurrentes,intIdUnidadTiempo, intIdResolution,intHighAvailability, precioTotal);\nString mensaje = salida[0].getString(\"FIONEG003010\");\n\/\/ Mostrar alert informando al usuario del problema\nif(mensaje.compareToIgnoreCase(\"OK\")==0){\n\/\/ Mostrar mensaje \u00e9xito\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"info\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanel.valor\", \"Success!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeOK.valor\", \"Request completed!!\"), \"\", \"\");\n}else{\n\/\/ Mostrar mensaje error\n\/\/ Asignar t\u00edtulo y contenido adecuado\nhandleModalAlert(gestorDatos, gestorEstados, idAlert, \"error\", getMessage(\"FIONA.alertUploadProdOk.cabeceraPanelError.valor\", \"Error!\"),\ngetMessage(\"FIONA.alertUploadProdOk.mensajeError.valor\", \"Something went wrong...\"), \"\", \"\");\n}\n}\n\/\/ Cerramos la ventana de confirmaci\u00f3n\ngestorEstados.closeModalAlert(\"alertUploadConfirm\");\n\/\/ Cerramos el di\u00e1logo de precios\ngestorEstados.closeModalAlert(\"dialogoPrecios\");\n} catch (FactoriaDatosException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (PersistenciaException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n} catch (FawnaInvokerException e) {\n\/\/ TODO Auto-generated catch block\ne.printStackTrace();\n}catch(PayPalException ppEx){\nppEx.printStackTrace();\n}\n}","label":[1,1,0,0]}
{"id":14725,"original_code":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\t\t\/\/ TODO: fix this so the label is a child of the Lane or Pool.\n\t\t\/\/ There's a problem with Resize Feature if the label is a direct child of Lane\/Pool.\n\t\treturn (ContainerShape) ownerPE.eContainer();\n\t}","code":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\t\n\t\n\t\treturn (ContainerShape) ownerPE.eContainer();\n\t}","cleancode":"protected containershape gettargetcontainer(pictogramelement ownerpe) { return (containershape) ownerpe.econtainer(); }","comment":"\/\/ todo: fix this so the label is a child of the lane or pool. \/\/ there's a problem with resize feature if the label is a direct child of lane\/pool.","repo":"alfa-ryano\/org.eclipse.bpmn2-modeler","code_context_2":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\/\/ TODO: fix this so the label is a child of the Lane or Pool.\n\/\/ There's a problem with Resize Feature if the label is a direct child of Lane\/Pool.\nreturn (ContainerShape) ownerPE.eContainer();\n}","code_context_10":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\/\/ TODO: fix this so the label is a child of the Lane or Pool.\n\/\/ There's a problem with Resize Feature if the label is a direct child of Lane\/Pool.\nreturn (ContainerShape) ownerPE.eContainer();\n}","code_context_20":"protected ContainerShape getTargetContainer(PictogramElement ownerPE) {\n\/\/ TODO: fix this so the label is a child of the Lane or Pool.\n\/\/ There's a problem with Resize Feature if the label is a direct child of Lane\/Pool.\nreturn (ContainerShape) ownerPE.eContainer();\n}","label":[1,0,0,0]}
{"id":31226,"original_code":"@ReactMethod\n    public void issue( \/\/ TODO: alternatively we can just take a json string here and pass that directly to the ffi for librgb\n            int alloc_coins,\n            String alloc_outpoint,\n            String network,\n            String ticker,\n            String name,\n            String description,\n            int precision,\n            Promise promise) {\n        try {\n            final Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();\n            final OutpointCoins allocation = new OutpointCoins((long) alloc_coins, alloc_outpoint);\n            runtime.issue(network, ticker, name, description, precision, Arrays.asList(allocation), new HashSet<OutpointCoins>(), null, null);\n            WritableMap map = Arguments.createMap();\n            promise.resolve(map);\n        } catch (Exception e) {\n            promise.reject(e);\n        }\n    }","code":"@ReactMethod\n    public void issue(\n            int alloc_coins,\n            String alloc_outpoint,\n            String network,\n            String ticker,\n            String name,\n            String description,\n            int precision,\n            Promise promise) {\n        try {\n            final Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();\n            final OutpointCoins allocation = new OutpointCoins((long) alloc_coins, alloc_outpoint);\n            runtime.issue(network, ticker, name, description, precision, Arrays.asList(allocation), new HashSet<OutpointCoins>(), null, null);\n            WritableMap map = Arguments.createMap();\n            promise.resolve(map);\n        } catch (Exception e) {\n            promise.reject(e);\n        }\n    }","cleancode":"@reactmethod public void issue( int alloc_coins, string alloc_outpoint, string network, string ticker, string name, string description, int precision, promise promise) { try { final runtime runtime = ((mainapplication) getcurrentactivity().getapplication()).getruntime(); final outpointcoins allocation = new outpointcoins((long) alloc_coins, alloc_outpoint); runtime.issue(network, ticker, name, description, precision, arrays.aslist(allocation), new hashset<outpointcoins>(), null, null); writablemap map = arguments.createmap(); promise.resolve(map); } catch (exception e) { promise.reject(e); } }","comment":"\/\/ todo: alternatively we can just take a json string here and pass that directly to the ffi for librgb","repo":"alexeyneu\/rgb-sdk","code_context_2":"@ReactMethod\npublic void issue( \/\/ TODO: alternatively we can just take a json string here and pass that directly to the ffi for librgb\nint alloc_coins,\nString alloc_outpoint,","code_context_10":"@ReactMethod\npublic void issue( \/\/ TODO: alternatively we can just take a json string here and pass that directly to the ffi for librgb\nint alloc_coins,\nString alloc_outpoint,\nString network,\nString ticker,\nString name,\nString description,\nint precision,\nPromise promise) {\ntry {\nfinal Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();","code_context_20":"@ReactMethod\npublic void issue( \/\/ TODO: alternatively we can just take a json string here and pass that directly to the ffi for librgb\nint alloc_coins,\nString alloc_outpoint,\nString network,\nString ticker,\nString name,\nString description,\nint precision,\nPromise promise) {\ntry {\nfinal Runtime runtime = ((MainApplication) getCurrentActivity().getApplication()).getRuntime();\nfinal OutpointCoins allocation = new OutpointCoins((long) alloc_coins, alloc_outpoint);\nruntime.issue(network, ticker, name, description, precision, Arrays.asList(allocation), new HashSet<OutpointCoins>(), null, null);\nWritableMap map = Arguments.createMap();\npromise.resolve(map);\n} catch (Exception e) {\npromise.reject(e);\n}\n}","label":[1,0,0,0]}
{"id":31251,"original_code":"public static void main(String[] args){\n        \/*\n            Write a program to add a score of 100 to \n            the the array scores.\n        *\/\n        int[] scores = {88,91,80,78,95};\n        System.out.println(\"Current scores are: \" + Arrays.toString(scores));\n        \/\/TODO 1: Write code to make a new array that can hold a new score\n        int[] temp = new int[scores.length + 1];\n        for(int i = 0; i<scores.length; i++){\n            temp[i] = scores[i];\n        }\n        temp[temp.length -1] = 100;\n        scores = temp;\n        \/\/ ... code to add should stay above this line\n        System.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n        \/\/TODO 2: Next, write code to remove the first value from the scores\n        int[] temp2 = new int[scores.length -1];\n        for(int i = 1; i < scores.length; i++){\n            temp2[i-1] = scores[i];\n        }\n        \/\/ ... code to remove should stay above this line\n        System.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n        \/\/TODO 3: Implement the methods below\n        int[] arr2 = makeCopyOf(scores);\n        \/\/System.out.println(\"Copy of scores looks like: \" + scores);\n    }","code":"public static void main(String[] args){\n       \n        int[] scores = {88,91,80,78,95};\n        System.out.println(\"Current scores are: \" + Arrays.toString(scores));\n       \n        int[] temp = new int[scores.length + 1];\n        for(int i = 0; i<scores.length; i++){\n            temp[i] = scores[i];\n        }\n        temp[temp.length -1] = 100;\n        scores = temp;\n       \n        System.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n       \n        int[] temp2 = new int[scores.length -1];\n        for(int i = 1; i < scores.length; i++){\n            temp2[i-1] = scores[i];\n        }\n       \n        System.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n       \n        int[] arr2 = makeCopyOf(scores);\n       \n    }","cleancode":"public static void main(string[] args){ int[] scores = {88,91,80,78,95}; system.out.println(\"current scores are: \" + arrays.tostring(scores)); int[] temp = new int[scores.length + 1]; for(int i = 0; i<scores.length; i++){ temp[i] = scores[i]; } temp[temp.length -1] = 100; scores = temp; system.out.println(\"after 'adding' score: \" + arrays.tostring(scores)); int[] temp2 = new int[scores.length -1]; for(int i = 1; i < scores.length; i++){ temp2[i-1] = scores[i]; } system.out.println(\"after 'remove' scores are: \" + arrays.tostring(scores)); int[] arr2 = makecopyof(scores); }","comment":"\/* write a program to add a score of 100 to the the array scores. *\/\n\/\/todo 1: write code to make a new array that can hold a new score\n\/\/ ... code to add should stay above this line\n\/\/todo 2: next, write code to remove the first value from the scores\n\/\/ ... code to remove should stay above this line\n\/\/todo 3: implement the methods below\n\/\/system.out.println(\"copy of scores looks like: \" + scores);","repo":"SwettSoquelHS\/think-java-notswett","code_context_2":"public static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\n\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\n\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\n\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\n\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}","code_context_10":"public static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\n\npublic static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\n\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}","code_context_20":"public static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\npublic static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\npublic static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\npublic static void main(String[] args){\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\n\/*\nWrite a program to add a score of 100 to\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\nthe the array scores.\n*\/\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}\n\nint[] scores = {88,91,80,78,95};\nSystem.out.println(\"Current scores are: \" + Arrays.toString(scores));\n\/\/TODO 1: Write code to make a new array that can hold a new score\nint[] temp = new int[scores.length + 1];\nfor(int i = 0; i<scores.length; i++){\ntemp[i] = scores[i];\n}\ntemp[temp.length -1] = 100;\nscores = temp;\n\/\/ ... code to add should stay above this line\nSystem.out.println(\"After 'adding' score: \" + Arrays.toString(scores));\n\/\/TODO 2: Next, write code to remove the first value from the scores\nint[] temp2 = new int[scores.length -1];\nfor(int i = 1; i < scores.length; i++){\ntemp2[i-1] = scores[i];\n}\n\/\/ ... code to remove should stay above this line\nSystem.out.println(\"After 'remove' scores are: \" + Arrays.toString(scores));\n\/\/TODO 3: Implement the methods below\nint[] arr2 = makeCopyOf(scores);\n\/\/System.out.println(\"Copy of scores looks like: \" + scores);\n}","label":[0,1,0,0]}
{"id":23212,"original_code":"@Override\n    protected void setup(VaadinRequest request) {\n        addComponent(new ProgressIndicator() {\n            {\n                registerRpc(new ProgressIndicatorServerRpc() {\n                    @Override\n                    public void poll() {\n                        \/\/ System.out.println(\"Pausing poll request\");\n                        try {\n                            \/\/ Make the XHR request last longer to make it\n                            \/\/ easier to click the link at the right moment.\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        \/\/ System.out.println(\"Continuing poll request\");\n                    }\n                });\n                setPollingInterval(3000);\n            }\n        });\n        \/\/ Hacky URLs that are might not work in all deployment scenarios\n        addComponent(new Link(\"Navigate away\", new ExternalResource(\n                \"slowRequestHandler\")));\n        addComponent(new Link(\"Start download\", new ExternalResource(\n                \"slowRequestHandler?download\")));\n    }","code":"@Override\n    protected void setup(VaadinRequest request) {\n        addComponent(new ProgressIndicator() {\n            {\n                registerRpc(new ProgressIndicatorServerRpc() {\n                    @Override\n                    public void poll() {\n                       \n                        try {\n                           \n                           \n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                       \n                    }\n                });\n                setPollingInterval(3000);\n            }\n        });\n       \n        addComponent(new Link(\"Navigate away\", new ExternalResource(\n                \"slowRequestHandler\")));\n        addComponent(new Link(\"Start download\", new ExternalResource(\n                \"slowRequestHandler?download\")));\n    }","cleancode":"@override protected void setup(vaadinrequest request) { addcomponent(new progressindicator() { { registerrpc(new progressindicatorserverrpc() { @override public void poll() { try { thread.sleep(1000); } catch (interruptedexception e) { e.printstacktrace(); } } }); setpollinginterval(3000); } }); addcomponent(new link(\"navigate away\", new externalresource( \"slowrequesthandler\"))); addcomponent(new link(\"start download\", new externalresource( \"slowrequesthandler?download\"))); }","comment":"\/\/ system.out.println(\"pausing poll request\");\n\/\/ make the xhr request last longer to make it \/\/ easier to click the link at the right moment.\n\/\/ system.out.println(\"continuing poll request\");\n\/\/ hacky urls that are might not work in all deployment scenarios","repo":"allanim\/vaadin","code_context_2":"@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\n\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\n\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));","code_context_10":"@Override\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\n\n@Override\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n}","code_context_20":"@Override\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n}\n\n@Override\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n}\n\n@Override\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n}\n\nprotected void setup(VaadinRequest request) {\naddComponent(new ProgressIndicator() {\n{\nregisterRpc(new ProgressIndicatorServerRpc() {\n@Override\npublic void poll() {\n\/\/ System.out.println(\"Pausing poll request\");\ntry {\n\/\/ Make the XHR request last longer to make it\n\/\/ easier to click the link at the right moment.\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\/\/ System.out.println(\"Continuing poll request\");\n}\n});\nsetPollingInterval(3000);\n}\n});\n\/\/ Hacky URLs that are might not work in all deployment scenarios\naddComponent(new Link(\"Navigate away\", new ExternalResource(\n\"slowRequestHandler\")));\naddComponent(new Link(\"Start download\", new ExternalResource(\n\"slowRequestHandler?download\")));\n}","label":[0,0,1,0]}
{"id":23397,"original_code":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\n        boolean alreadyRemaped=false;\n        final String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\n        if(charGlyph!=null){\n            final int newRawInt=currentFontData.getDiffChar(charGlyph);\n            if(newRawInt!=-1){\n                glyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\n                glyphData.setDisplayValue(String.valueOf((char)newRawInt));\n                \/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n                \/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n                \/\/this is a sanity check to fix this mapping issue\n            }else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\n                final int altValue=StandardFonts.getAdobeMap(charGlyph);\n                \/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n                \/\/which breaks code further down so we reject this value\n                if(altValue>-1) {\n                    glyphData.setRawInt(altValue);\n                    glyphData.set(String.valueOf((char) altValue));\n                    alreadyRemaped = true;\n                }\n            }\n        }\n        return alreadyRemaped;\n    }","code":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\n        boolean alreadyRemaped=false;\n        final String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\n        if(charGlyph!=null){\n            final int newRawInt=currentFontData.getDiffChar(charGlyph);\n            if(newRawInt!=-1){\n                glyphData.setRawInt(newRawInt);\n                glyphData.setDisplayValue(String.valueOf((char)newRawInt));\n               \n               \n               \n            }else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\n                final int altValue=StandardFonts.getAdobeMap(charGlyph);\n               \n               \n                if(altValue>-1) {\n                    glyphData.setRawInt(altValue);\n                    glyphData.set(String.valueOf((char) altValue));\n                    alreadyRemaped = true;\n                }\n            }\n        }\n        return alreadyRemaped;\n    }","cleancode":"static boolean remapglyph(pdffont currentfontdata, glyphdata glyphdata){ boolean alreadyremaped=false; final string charglyph= currentfontdata.getmappedchar(glyphdata.getrawint(), false); if(charglyph!=null){ final int newrawint=currentfontdata.getdiffchar(charglyph); if(newrawint!=-1){ glyphdata.setrawint(newrawint); glyphdata.setdisplayvalue(string.valueof((char)newrawint)); }else if(!glyphdata.getdisplayvalue().isempty() && glyphdata.getdisplayvalue().charat(0)<32){ final int altvalue=standardfonts.getadobemap(charglyph); if(altvalue>-1) { glyphdata.setrawint(altvalue); glyphdata.set(string.valueof((char) altvalue)); alreadyremaped = true; } } } return alreadyremaped; }","comment":"\/\/only reassign if not -1 as messes up code further down\n\/\/fix for pdfdata\/sample_pdfs_html\/general-july2012\/klar--men-aldri-ferdig_dacecc.pdf \/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct \/\/this is a sanity check to fix this mapping issue\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-may2014\/18147.pdf \/\/which breaks code further down so we reject this value","repo":"UprootStaging\/maven-OpenViewerFX-src","code_context_2":"final int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);","code_context_10":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\nboolean alreadyRemaped=false;\nfinal String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\n\nstatic boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\nboolean alreadyRemaped=false;\nfinal String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\nglyphData.set(String.valueOf((char) altValue));\nalreadyRemaped = true;\n}\n}\n\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\nglyphData.set(String.valueOf((char) altValue));\nalreadyRemaped = true;\n}\n}\n}\nreturn alreadyRemaped;\n}","code_context_20":"static boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\nboolean alreadyRemaped=false;\nfinal String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\nglyphData.set(String.valueOf((char) altValue));\nalreadyRemaped = true;\n}\n}\n}\nreturn alreadyRemaped;\n}\n\nstatic boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\nboolean alreadyRemaped=false;\nfinal String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\nglyphData.set(String.valueOf((char) altValue));\nalreadyRemaped = true;\n}\n}\n}\nreturn alreadyRemaped;\n}\n\nstatic boolean remapGlyph(PdfFont currentFontData, GlyphData glyphData){\nboolean alreadyRemaped=false;\nfinal String charGlyph= currentFontData.getMappedChar(glyphData.getRawInt(), false);\nif(charGlyph!=null){\nfinal int newRawInt=currentFontData.getDiffChar(charGlyph);\nif(newRawInt!=-1){\nglyphData.setRawInt(newRawInt); \/\/only reassign if not -1 as messes up code further down\nglyphData.setDisplayValue(String.valueOf((char)newRawInt));\n\/\/fix for PDFdata\/sample_pdfs_html\/general-July2012\/klar--men-aldri-ferdig_dacecc.pdf\n\/\/in some examples the unicode table is wrong and maps the character into this odd range, but the glyph is always correct\n\/\/this is a sanity check to fix this mapping issue\n}else if(!glyphData.getDisplayValue().isEmpty() && glyphData.getDisplayValue().charAt(0)<32){\nfinal int altValue=StandardFonts.getAdobeMap(charGlyph);\n\/\/this test can return -1 for invalid value as in sample_pdfs_html\/general-May2014\/18147.pdf\n\/\/which breaks code further down so we reject this value\nif(altValue>-1) {\nglyphData.setRawInt(altValue);\nglyphData.set(String.valueOf((char) altValue));\nalreadyRemaped = true;\n}\n}\n}\nreturn alreadyRemaped;\n}","label":[0,0,1,0]}
{"id":31695,"original_code":"@Override\n    @Nonnull\n    public MutableVfsItem getMutableItem(RepoPath repoPath) {\n        \/\/TORE: [by YS] should be storing repo once interfaces refactoring is done\n        LocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\n        if (localRepo != null) {\n            MutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\n            if (mutableFsItem != null) {\n                return mutableFsItem;\n            }\n        }\n        throw new ItemNotFoundRuntimeException(repoPath);\n    }","code":"@Override\n    @Nonnull\n    public MutableVfsItem getMutableItem(RepoPath repoPath) {\n       \n        LocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\n        if (localRepo != null) {\n            MutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\n            if (mutableFsItem != null) {\n                return mutableFsItem;\n            }\n        }\n        throw new ItemNotFoundRuntimeException(repoPath);\n    }","cleancode":"@override @nonnull public mutablevfsitem getmutableitem(repopath repopath) { localrepo localrepo = localorcachedrepositorybykey(repopath.getrepokey()); if (localrepo != null) { mutablevfsitem mutablefsitem = localrepo.getmutablefsitem(repopath); if (mutablefsitem != null) { return mutablefsitem; } } throw new itemnotfoundruntimeexception(repopath); }","comment":"\/\/tore: [by ys] should be storing repo once interfaces refactoring is done","repo":"alancnet\/artifactory","code_context_2":"@Nonnull\npublic MutableVfsItem getMutableItem(RepoPath repoPath) {\n\/\/TORE: [by YS] should be storing repo once interfaces refactoring is done\nLocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\nif (localRepo != null) {","code_context_10":"@Override\n@Nonnull\npublic MutableVfsItem getMutableItem(RepoPath repoPath) {\n\/\/TORE: [by YS] should be storing repo once interfaces refactoring is done\nLocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\nif (localRepo != null) {\nMutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\nif (mutableFsItem != null) {\nreturn mutableFsItem;\n}\n}\nthrow new ItemNotFoundRuntimeException(repoPath);\n}","code_context_20":"@Override\n@Nonnull\npublic MutableVfsItem getMutableItem(RepoPath repoPath) {\n\/\/TORE: [by YS] should be storing repo once interfaces refactoring is done\nLocalRepo localRepo = localOrCachedRepositoryByKey(repoPath.getRepoKey());\nif (localRepo != null) {\nMutableVfsItem mutableFsItem = localRepo.getMutableFsItem(repoPath);\nif (mutableFsItem != null) {\nreturn mutableFsItem;\n}\n}\nthrow new ItemNotFoundRuntimeException(repoPath);\n}","label":[1,0,0,0]}
{"id":15371,"original_code":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\n    container.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    SootMethod target = ie.getMethod();\n    target.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    \/*\n     * This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n     * definition of invokespecial.\n     *\/\n    if (\"<init>\".equals(target.getName()) || target.isPrivate()) {\n      return target;\n    } else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\n      return resolveConcreteDispatch(container.getDeclaringClass(), target);\n    } else {\n      return target;\n    }\n  }","code":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\n    container.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n    SootMethod target = ie.getMethod();\n    target.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n   \n    if (\"<init>\".equals(target.getName()) || target.isPrivate()) {\n      return target;\n    } else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\n      return resolveConcreteDispatch(container.getDeclaringClass(), target);\n    } else {\n      return target;\n    }\n  }","cleancode":"public sootmethod resolvespecialdispatch(specialinvokeexpr ie, sootmethod container) { container.getdeclaringclass().checklevel(sootclass.hierarchy); sootmethod target = ie.getmethod(); target.getdeclaringclass().checklevel(sootclass.hierarchy); if (\"<init>\".equals(target.getname()) || target.isprivate()) { return target; } else if (isclasssubclassof(target.getdeclaringclass(), container.getdeclaringclass())) { return resolveconcretedispatch(container.getdeclaringclass(), target); } else { return target; } }","comment":"\/** returns the target for the given specialinvokeexpr. *\/\n\/* * this is a bizarre condition! hopefully the implementation is correct. see vm spec, 2nd edition, chapter 6, in the * definition of invokespecial. *\/","repo":"UCLA-SEAL\/JShrink","code_context_2":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\ncontainer.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;\n} else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\nreturn resolveConcreteDispatch(container.getDeclaringClass(), target);\n} else {\nreturn target;\n}\n}\n\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;","code_context_10":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\ncontainer.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;\n} else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\nreturn resolveConcreteDispatch(container.getDeclaringClass(), target);\n} else {\nreturn target;\n}\n}\n\npublic SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\ncontainer.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;\n} else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\nreturn resolveConcreteDispatch(container.getDeclaringClass(), target);\n} else {\nreturn target;\n}\n}","code_context_20":"public SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\ncontainer.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;\n} else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\nreturn resolveConcreteDispatch(container.getDeclaringClass(), target);\n} else {\nreturn target;\n}\n}\n\npublic SootMethod resolveSpecialDispatch(SpecialInvokeExpr ie, SootMethod container) {\ncontainer.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\nSootMethod target = ie.getMethod();\ntarget.getDeclaringClass().checkLevel(SootClass.HIERARCHY);\n\/*\n* This is a bizarre condition! Hopefully the implementation is correct. See VM Spec, 2nd Edition, Chapter 6, in the\n* definition of invokespecial.\n*\/\nif (\"<init>\".equals(target.getName()) || target.isPrivate()) {\nreturn target;\n} else if (isClassSubclassOf(target.getDeclaringClass(), container.getDeclaringClass())) {\nreturn resolveConcreteDispatch(container.getDeclaringClass(), target);\n} else {\nreturn target;\n}\n}","label":[1,0,0,0]}
{"id":15595,"original_code":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int dataPointId) {\n\t\t\/\/ TODO: how to identify the correct device if there are several devices in the\n\t\t\/\/ list?\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\t\t\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\t\tfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\n\t\treturn knxComObjects;\n\t}","code":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int dataPointId) {\n\t\n\t\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\t\n\t\tfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\n\t\treturn knxComObjects;\n\t}","cleancode":"public static list<knxcomobject> retrievecomobjectlistbydatapointid(final knxproject knxproject, final int datapointid) { final knxdeviceinstance knxdeviceinstance = knxproject.getdeviceinstances().get(0); final list<knxcomobject> knxcomobjects = knxdeviceinstance.getcomobjects().values().stream() .filter(c -> c.getnumber() == datapointid).filter(c -> c.isgroupobject()).collect(collectors.tolist()); return knxcomobjects; }","comment":"\/\/ todo: how to identify the correct device if there are several devices in the \/\/ list?\n\/\/ todo: maybe create a map from datapoint id to comobject????","repo":"Thewbi\/knx_meister","code_context_2":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\nfinal int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\nfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());","code_context_10":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\nfinal int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\nfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\nreturn knxComObjects;\n}\n\npublic static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\nfinal int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\nfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\nreturn knxComObjects;\n}","code_context_20":"public static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\nfinal int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\nfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\nreturn knxComObjects;\n}\n\npublic static List<KNXComObject> retrieveComObjectListByDatapointId(final KNXProject knxProject,\nfinal int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(0);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\nfinal List<KNXComObject> knxComObjects = knxDeviceInstance.getComObjects().values().stream()\n.filter(c -> c.getNumber() == dataPointId).filter(c -> c.isGroupObject()).collect(Collectors.toList());\nreturn knxComObjects;\n}","label":[1,0,0,0]}
{"id":15596,"original_code":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int deviceIndex, final int dataPointId) {\n\t\t\/\/ TODO: how to identify the correct device if there are several devices in the\n\t\t\/\/ list?\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\t\t\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\t\t\/\/ @formatter:off\n\t\treturn knxDeviceInstance\n\t\t\t\t.getComObjects()\n\t\t\t\t.values()\n\t\t\t\t.stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId)\n\t\t\t\t.filter(c -> c.isGroupObject())\n\t\t\t\t.findFirst();\n\t\t\/\/ @formatter:on\n\t}","code":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\n\t\t\tfinal int deviceIndex, final int dataPointId) {\n\t\n\t\n\t\tfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\t\n\t\n\t\treturn knxDeviceInstance\n\t\t\t\t.getComObjects()\n\t\t\t\t.values()\n\t\t\t\t.stream()\n\t\t\t\t.filter(c -> c.getNumber() == dataPointId)\n\t\t\t\t.filter(c -> c.isGroupObject())\n\t\t\t\t.findFirst();\n\t\n\t}","cleancode":"public static optional<knxcomobject> retrievecomobjectbydatapointid(final knxproject knxproject, final int deviceindex, final int datapointid) { final knxdeviceinstance knxdeviceinstance = knxproject.getdeviceinstances().get(deviceindex); return knxdeviceinstance .getcomobjects() .values() .stream() .filter(c -> c.getnumber() == datapointid) .filter(c -> c.isgroupobject()) .findfirst(); }","comment":"\/\/ todo: how to identify the correct device if there are several devices in the \/\/ list?\n\/\/ todo: maybe create a map from datapoint id to comobject???? \/\/ @formatter:off\n\/\/ @formatter:on","repo":"Thewbi\/knx_meister","code_context_2":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}","code_context_10":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\npublic static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}\n\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}","code_context_20":"public static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}\n\npublic static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}\n\npublic static Optional<KNXComObject> retrieveComObjectByDatapointId(final KNXProject knxProject,\nfinal int deviceIndex, final int dataPointId) {\n\/\/ TODO: how to identify the correct device if there are several devices in the\n\/\/ list?\nfinal KNXDeviceInstance knxDeviceInstance = knxProject.getDeviceInstances().get(deviceIndex);\n\/\/ TODO: maybe create a map from datapoint id to ComObject????\n\/\/ @formatter:off\nreturn knxDeviceInstance\n.getComObjects()\n.values()\n.stream()\n.filter(c -> c.getNumber() == dataPointId)\n.filter(c -> c.isGroupObject())\n.findFirst();\n\/\/ @formatter:on\n}","label":[1,0,0,0]}
{"id":23864,"original_code":"private Expression _buildExpression() {\n    \t\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\n    \tExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n    \t\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n    \t\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\n    \tPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n    \t\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\n    \tMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n    \t\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\n    \twhile (_formulaVarMatcher.find()) {\n    \t\t\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\n    \t\tfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n    \t\t\t\/\/ Set ith match from regex as a variable in the formula expression builder\n    \t\t\t_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n    \t\t}\n    \t}\n    \t\/\/ Once regex stuff is done and variables are set, properly build the expression.\n    \tExpression _formulaExpression = _formulaExpressionBuilder.build();\n    \treturn _formulaExpression;\n    }","code":"private Expression _buildExpression() {\n    \n    \tExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n    \n    \n    \tPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n    \n    \tMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n    \n    \twhile (_formulaVarMatcher.find()) {\n    \t\n    \t\tfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n    \t\t\n    \t\t\t_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n    \t\t}\n    \t}\n    \n    \tExpression _formulaExpression = _formulaExpressionBuilder.build();\n    \treturn _formulaExpression;\n    }","cleancode":"private expression _buildexpression() { expressionbuilder _formulaexpressionbuilder = new expressionbuilder(this._formulaequation); pattern _formularegex = new pattern.compile(\"\\s?_[a-za-z0-9_]*_\\s?\"); matcher _formulavarmatcher = new _formularegex.matcher(this._formulaequation); while (_formulavarmatcher.find()) { for (int i=1; i<=_formulavarmatcher.groupcount(); i++) { _formulaexpressionbuilder.variable(_formulavarmatcher.group(i)); } } expression _formulaexpression = _formulaexpressionbuilder.build(); return _formulaexpression; }","comment":"\/** * a method to build an exp4j expression for a formula object, * given that a valid formula equation was input by the configuration file. * @throws an exception if _formulaequation cannot be parsed. * @return ? *\/ \/\/todo: add exceptions for nulls, bad ins, w.e.\n\/\/ make base exp4j expressionbuilder using _formulaequation string as input\n\/\/ setup regex pattern we want to use to isolate formula variables from _formulaequation string \/\/ ==in terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? dunno, probably not, would be interesting though\n\/\/ make a matcher to get the variables out of the formula equation string given, using above pattern\n\/\/ while regex matcher can find matching values, set them as variables in exp4j expressionbuilder\n\/\/ while index i, starting at 1, is less than matcher.groupcount(), which inherently does not include groupcount(0)\n\/\/ set ith match from regex as a variable in the formula expression builder\n\/\/ once regex stuff is done and variables are set, properly build the expression.","repo":"ambedrake\/UniversalAuthenticatedReportGenerator","code_context_2":"private Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\n\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\n\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\n\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;","code_context_10":"private Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}","code_context_20":"private Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}\n\nprivate Expression _buildExpression() {\n\/\/ Make base Exp4j ExpressionBuilder using _formulaEquation string as input\nExpressionBuilder _formulaExpressionBuilder = new ExpressionBuilder(this._formulaEquation);\n\/\/ Setup regex pattern we want to use to isolate formula variables from _formulaEquation string\n\/\/ ==In terms of modularity, should we keep the regex string we use as a field for formulas that can be changed by config? Dunno, probably not, would be interesting though\nPattern _formulaRegex = new Pattern.compile(\"\\s?_[a-zA-z0-9_]*_\\s?\");\n\/\/ Make a matcher to get the variables out of the formula equation string given, using above pattern\nMatcher _formulaVarMatcher = new _formulaRegex.matcher(this._formulaEquation);\n\/\/ While regex matcher can find matching values, set them as variables in exp4j expressionbuilder\nwhile (_formulaVarMatcher.find()) {\n\/\/ While index i, starting at 1, is less than matcher.groupCount(), which inherently does not include groupCount(0)\nfor (int i=1; i<=_formulaVarMatcher.groupCount(); i++) {\n\/\/ Set ith match from regex as a variable in the formula expression builder\n_formulaExpressionBuilder.variable(_formulaVarMatcher.group(i));\n}\n}\n\/\/ Once regex stuff is done and variables are set, properly build the expression.\nExpression _formulaExpression = _formulaExpressionBuilder.build();\nreturn _formulaExpression;\n}","label":[0,1,0,0]}
{"id":32072,"original_code":"private void craftRecipe( Recipe<?> currentRecipe)\n    {\n        if (currentRecipe != null && this.canAcceptRecipeOutput(currentRecipe))\n        {\n            ItemStack inputStack = this.inventory.get(0);\n            ItemStack outputStack = this.inventory.get(2);\n            ItemStack recipeResultStack = currentRecipe.getOutput();\n            int resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\n            if (outputStack.isEmpty())\n            {\n                ItemStack newResultStack = recipeResultStack.copy();\n                newResultStack.setAmount(resultCount);\n                this.inventory.set(2, newResultStack);\n            }\n            else if (outputStack.getItem() == recipeResultStack.getItem())\n            {\n                \/\/ TODO: WHAT HAPPENS IF FINAL COUNT IS 63 AND WE SMELT DOUBLE?\n                outputStack.addAmount(resultCount);\n            }\n            if (!this.world.isClient)\n                this.setLastRecipe(currentRecipe);\n            if (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n            {\n                this.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n            }\n            inputStack.subtractAmount(1);\n        }\n    }","code":"private void craftRecipe( Recipe<?> currentRecipe)\n    {\n        if (currentRecipe != null && this.canAcceptRecipeOutput(currentRecipe))\n        {\n            ItemStack inputStack = this.inventory.get(0);\n            ItemStack outputStack = this.inventory.get(2);\n            ItemStack recipeResultStack = currentRecipe.getOutput();\n            int resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\n            if (outputStack.isEmpty())\n            {\n                ItemStack newResultStack = recipeResultStack.copy();\n                newResultStack.setAmount(resultCount);\n                this.inventory.set(2, newResultStack);\n            }\n            else if (outputStack.getItem() == recipeResultStack.getItem())\n            {\n               \n                outputStack.addAmount(resultCount);\n            }\n            if (!this.world.isClient)\n                this.setLastRecipe(currentRecipe);\n            if (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n            {\n                this.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n            }\n            inputStack.subtractAmount(1);\n        }\n    }","cleancode":"private void craftrecipe( recipe<?> currentrecipe) { if (currentrecipe != null && this.canacceptrecipeoutput(currentrecipe)) { itemstack inputstack = this.inventory.get(0); itemstack outputstack = this.inventory.get(2); itemstack reciperesultstack = currentrecipe.getoutput(); int resultcount = world.random.nextint(100) < dupechance100 ? 2 : 1; if (outputstack.isempty()) { itemstack newresultstack = reciperesultstack.copy(); newresultstack.setamount(resultcount); this.inventory.set(2, newresultstack); } else if (outputstack.getitem() == reciperesultstack.getitem()) { outputstack.addamount(resultcount); } if (!this.world.isclient) this.setlastrecipe(currentrecipe); if (inputstack.getitem() == blocks.wet_sponge.getitem() && !((itemstack) this.inventory.get(1)).isempty() && ((itemstack) this.inventory.get(1)).getitem() == items.bucket) { this.inventory.set(1, new itemstack(items.water_bucket)); } inputstack.subtractamount(1); } }","comment":"\/\/ todo: what happens if final count is 63 and we smelt double?","repo":"XuyuEre\/fabric-furnaces","code_context_2":"else if (outputStack.getItem() == recipeResultStack.getItem())\n{\n\/\/ TODO: WHAT HAPPENS IF FINAL COUNT IS 63 AND WE SMELT DOUBLE?\noutputStack.addAmount(resultCount);\n}","code_context_10":"ItemStack recipeResultStack = currentRecipe.getOutput();\nint resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\nif (outputStack.isEmpty())\n{\nItemStack newResultStack = recipeResultStack.copy();\nnewResultStack.setAmount(resultCount);\nthis.inventory.set(2, newResultStack);\n}\nelse if (outputStack.getItem() == recipeResultStack.getItem())\n{\n\/\/ TODO: WHAT HAPPENS IF FINAL COUNT IS 63 AND WE SMELT DOUBLE?\noutputStack.addAmount(resultCount);\n}\nif (!this.world.isClient)\nthis.setLastRecipe(currentRecipe);\nif (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n{\nthis.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n}\ninputStack.subtractAmount(1);\n}","code_context_20":"private void craftRecipe( Recipe<?> currentRecipe)\n{\nif (currentRecipe != null && this.canAcceptRecipeOutput(currentRecipe))\n{\nItemStack inputStack = this.inventory.get(0);\nItemStack outputStack = this.inventory.get(2);\nItemStack recipeResultStack = currentRecipe.getOutput();\nint resultCount = world.random.nextInt(100) < dupeChance100 ? 2 : 1;\nif (outputStack.isEmpty())\n{\nItemStack newResultStack = recipeResultStack.copy();\nnewResultStack.setAmount(resultCount);\nthis.inventory.set(2, newResultStack);\n}\nelse if (outputStack.getItem() == recipeResultStack.getItem())\n{\n\/\/ TODO: WHAT HAPPENS IF FINAL COUNT IS 63 AND WE SMELT DOUBLE?\noutputStack.addAmount(resultCount);\n}\nif (!this.world.isClient)\nthis.setLastRecipe(currentRecipe);\nif (inputStack.getItem() == Blocks.WET_SPONGE.getItem() && !((ItemStack) this.inventory.get(1)).isEmpty() && ((ItemStack) this.inventory.get(1)).getItem() == Items.BUCKET)\n{\nthis.inventory.set(1, new ItemStack(Items.WATER_BUCKET));\n}\ninputStack.subtractAmount(1);\n}\n}","label":[1,0,0,0]}
{"id":7716,"original_code":"public void mergeSort(Card[] cardArray)\n    {\n        \/\/ TODO: implement this method (in an iterative way)\n    }","code":"public void mergeSort(Card[] cardArray)\n    {\n       \n    }","cleancode":"public void mergesort(card[] cardarray) { }","comment":"\/\/ merge sort\n\/\/ todo: implement this method (in an iterative way)","repo":"Sailia\/data_structures","code_context_2":"public void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}\n\npublic void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}","code_context_10":"public void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}\n\npublic void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}","code_context_20":"public void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}\n\npublic void mergeSort(Card[] cardArray)\n{\n\/\/ TODO: implement this method (in an iterative way)\n}","label":[0,1,0,0]}
{"id":7891,"original_code":"@Test\n    public void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\n        when(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\n        when(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\n        when(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\n        ResultActions results = mockMvc\n                .perform(\n                    get(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n                .andDo(print());\n        results\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andExpect(jsonPath(\"$.*\").isArray())\n                .andExpect(jsonPath(\"$.*\",hasSize(4)))\n                .andReturn();\n    }","code":"@Test\n    public void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\n        when(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\n        when(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\n        when(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\n        ResultActions results = mockMvc\n                .perform(\n                    get(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n                .andDo(print());\n        results\n                .andExpect(status().isOk())\n                .andExpect(content().contentType(MediaType.APPLICATION_JSON))\n                .andExpect(jsonPath(\"$.*\").isArray())\n                .andExpect(jsonPath(\"$.*\",hasSize(4)))\n                .andReturn();\n    }","cleancode":"@test public void findallsubcomments_for_comment_returns_collection_status_isfound() throws exception{ when(commentservice.findcommentsbycommentparentid(anyint())).thenreturn(arrays.aslist(comments)); when(userservice.finduserbyid(anyint())).thenreturn(optional.of(user)); when(commentlikeservice.checkifcommentisliked(any(comment.class), any(user.class))).thenreturn(true); resultactions results = mockmvc .perform( get(\"\/microblogging\/v1\/comment\/2?requesteduserid=1\")) .anddo(print()); results .andexpect(status().isok()) .andexpect(content().contenttype(mediatype.application_json)) .andexpect(jsonpath(\"$.*\").isarray()) .andexpect(jsonpath(\"$.*\",hassize(4))) .andreturn(); }","comment":"\/\/todo @test if findcommentsbypostid_returns_postid_not_found","repo":"Yarulika\/Microblogging","code_context_2":"@Test\npublic void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\nwhen(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\nwhen(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\nwhen(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\nResultActions results = mockMvc\n.perform(\nget(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n.andDo(print());\nresults\n.andExpect(status().isOk())\n.andExpect(content().contentType(MediaType.APPLICATION_JSON))\n.andExpect(jsonPath(\"$.*\").isArray())\n.andExpect(jsonPath(\"$.*\",hasSize(4)))\n.andReturn();\n}","code_context_10":"@Test\npublic void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\nwhen(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\nwhen(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\nwhen(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\nResultActions results = mockMvc\n.perform(\nget(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n.andDo(print());\nresults\n.andExpect(status().isOk())\n.andExpect(content().contentType(MediaType.APPLICATION_JSON))\n.andExpect(jsonPath(\"$.*\").isArray())\n.andExpect(jsonPath(\"$.*\",hasSize(4)))\n.andReturn();\n}","code_context_20":"@Test\npublic void findAllSubComments_for_comment_returns_collection_status_isFound() throws Exception{\nwhen(commentService.findCommentsByCommentParentId(anyInt())).thenReturn(Arrays.asList(comments));\nwhen(userService.findUserById(anyInt())).thenReturn(Optional.of(user));\nwhen(commentLikeService.checkIfCommentIsLiked(any(Comment.class), any(User.class))).thenReturn(true);\nResultActions results = mockMvc\n.perform(\nget(\"\/microblogging\/v1\/comment\/2?requestedUserId=1\"))\n.andDo(print());\nresults\n.andExpect(status().isOk())\n.andExpect(content().contentType(MediaType.APPLICATION_JSON))\n.andExpect(jsonPath(\"$.*\").isArray())\n.andExpect(jsonPath(\"$.*\",hasSize(4)))\n.andReturn();\n}","label":[0,0,0,1]}
{"id":16097,"original_code":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n\t{\n\t\tFileHandler fileHandler = null; \n\t\ttry\n\t\t{\n\t\t\tTool tool = getTool();\n\t\t\tfileHandler = tool.getToolResource().getFileHandler();\n\t\t\tString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\n\t\t\tList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\t\t\t\/*\n\t\t\tlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" + \n\t\t\t\tlist.size() + \" files.\");\n\t\t\t*\/\n\t\t\treturn list;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (fileHandler != null)\n\t\t\t{\n\t\t\t\tfileHandler.close();\n\t\t\t}\n\t\t}\n\t}","code":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n\t{\n\t\tFileHandler fileHandler = null; \n\t\ttry\n\t\t{\n\t\t\tTool tool = getTool();\n\t\t\tfileHandler = tool.getToolResource().getFileHandler();\n\t\t\tString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\n\t\t\tList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\t\t\n\t\t\treturn list;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (fileHandler != null)\n\t\t\t{\n\t\t\t\tfileHandler.close();\n\t\t\t}\n\t\t}\n\t}","cleancode":"public list<filehandler.fileattributes> listworkingdirectory() throws ioexception, exception { filehandler filehandler = null; try { tool tool = gettool(); filehandler = tool.gettoolresource().getfilehandler(); string workingdirectory = tool.gettoolresource().getworkingdirectory(task.getjobhandle()); list<filehandler.fileattributes> list = filehandler.list(workingdirectory); return list; } finally { if (filehandler != null) { filehandler.close(); } } }","comment":"\/* returns a list of filenames (just the filename, not the path) in working directory. todo: currently this skips over subdirs. this will throw an ioexception exception if the working directory is deleted (or possibly if a file is removed) while this method is executing. *\/\n\/* log.debug(\"in listworkingdirectory, directory is \" + workingdirectory + \" and there are \" + list.size() + \" files.\"); *\/","repo":"SciGaP\/DEPRECATED-Cipres-Airavata-POC","code_context_2":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n{\nFileHandler fileHandler = null;\ntry\n{\nTool tool = getTool();\nfileHandler = tool.getToolResource().getFileHandler();\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}\nfinally\n{\nif (fileHandler != null)\n{\nfileHandler.close();\n}\n}\n}\n\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}","code_context_10":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n{\nFileHandler fileHandler = null;\ntry\n{\nTool tool = getTool();\nfileHandler = tool.getToolResource().getFileHandler();\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}\nfinally\n{\nif (fileHandler != null)\n{\nfileHandler.close();\n}\n}\n}\n\npublic List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n{\nFileHandler fileHandler = null;\ntry\n{\nTool tool = getTool();\nfileHandler = tool.getToolResource().getFileHandler();\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}\nfinally\n{\nif (fileHandler != null)\n{\nfileHandler.close();\n}\n}\n}","code_context_20":"public List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n{\nFileHandler fileHandler = null;\ntry\n{\nTool tool = getTool();\nfileHandler = tool.getToolResource().getFileHandler();\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}\nfinally\n{\nif (fileHandler != null)\n{\nfileHandler.close();\n}\n}\n}\n\npublic List<FileHandler.FileAttributes> listWorkingDirectory() throws IOException, Exception\n{\nFileHandler fileHandler = null;\ntry\n{\nTool tool = getTool();\nfileHandler = tool.getToolResource().getFileHandler();\nString workingDirectory = tool.getToolResource().getWorkingDirectory(task.getJobHandle());\nList<FileHandler.FileAttributes> list = fileHandler.list(workingDirectory);\n\/*\nlog.debug(\"In listWorkingDirectory, directory is \" + workingDirectory + \" and there are \" +\nlist.size() + \" files.\");\n*\/\nreturn list;\n}\nfinally\n{\nif (fileHandler != null)\n{\nfileHandler.close();\n}\n}\n}","label":[1,0,0,0]}
{"id":8012,"original_code":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n    {\n        IResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(), \n                NamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\n        InstructionList callInContext = new InstructionList();\n        callInContext.addInstruction(ABCConstants.OP_getlocal1);\n        callInContext.addInstruction(ABCConstants.OP_getlocal2);\n        callInContext.addInstruction(ABCConstants.OP_getlocal3);\n        callInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\n        callInContext.addInstruction(ABCConstants.OP_getlocal, 4);\n        Label callInContextReturnVoid = new Label();\n        callInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        callInContext.labelNext(callInContextReturnVoid);\n        \/\/ TODO This should be OP_returnvoid, but the Boolean default value\n        \/\/ for the 'returns' parameter isn't defaulting to true.\n        \/\/ Fix this after CMP-936 is fixed.\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        ImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n                .add(new Name(IASLanguageConstants.Function))\n                .add(new Name(IASLanguageConstants.Object))\n                .add(new Name(IASLanguageConstants.Array))\n                .add(new Name(IASLanguageConstants.Boolean))\n                .build();\n        classGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null, \n                Collections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n    }","code":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n    {\n        IResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(), \n                NamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\n        InstructionList callInContext = new InstructionList();\n        callInContext.addInstruction(ABCConstants.OP_getlocal1);\n        callInContext.addInstruction(ABCConstants.OP_getlocal2);\n        callInContext.addInstruction(ABCConstants.OP_getlocal3);\n        callInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\n        callInContext.addInstruction(ABCConstants.OP_getlocal, 4);\n        Label callInContextReturnVoid = new Label();\n        callInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        callInContext.labelNext(callInContextReturnVoid);\n       \n       \n       \n        callInContext.addInstruction(ABCConstants.OP_returnvalue);\n        ImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n                .add(new Name(IASLanguageConstants.Function))\n                .add(new Name(IASLanguageConstants.Object))\n                .add(new Name(IASLanguageConstants.Array))\n                .add(new Name(IASLanguageConstants.Boolean))\n                .build();\n        classGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null, \n                Collections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n    }","cleancode":"protected final void codegencallincontextmethod(classgeneratorhelper classgen, boolean isoverride) { iresolvedqualifiersreference applyreference = referencefactory.resolvedqualifierqualifiedreference(royaleproject.getworkspace(), namespacedefinition.getas3namespacedefinition(), \"apply\"); instructionlist callincontext = new instructionlist(); callincontext.addinstruction(abcconstants.op_getlocal1); callincontext.addinstruction(abcconstants.op_getlocal2); callincontext.addinstruction(abcconstants.op_getlocal3); callincontext.addinstruction(abcconstants.op_callproperty, new object[] {applyreference.getmname(), 2}); callincontext.addinstruction(abcconstants.op_getlocal, 4); label callincontextreturnvoid = new label(); callincontext.addinstruction(abcconstants.op_iffalse, callincontextreturnvoid); callincontext.addinstruction(abcconstants.op_returnvalue); callincontext.labelnext(callincontextreturnvoid); callincontext.addinstruction(abcconstants.op_returnvalue); immutablelist<name> callincontextparams = new immutablelist.builder<name>() .add(new name(iaslanguageconstants.function)) .add(new name(iaslanguageconstants.object)) .add(new name(iaslanguageconstants.array)) .add(new name(iaslanguageconstants.boolean)) .build(); classgen.additraitsmethod(new name(\"callincontext\"), callincontextparams, null, collections.<object> singletonlist(boolean.true), false, true, isoverride, callincontext); }","comment":"\/** * codegen iflexmodulefactory.callincontext(); * * public final override function callincontext(fn:function, thisarg:object, argarray:array, returns:boolean=true) : * * { * var ret : * = fn.apply(thisarg, argarray); * if (returns) return ret; * return; * } * * @param classgen * @param isoverride true if the generated method overrides a base class * method, false otherwise. *\/\n\/\/ todo this should be op_returnvoid, but the boolean default value \/\/ for the 'returns' parameter isn't defaulting to true. \/\/ fix this after cmp-936 is fixed.","repo":"alinakazi\/apache-royale-0.9.8-bin-js-swf","code_context_2":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n{\nIResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(),\nNamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\nInstructionList callInContext = new InstructionList();\ncallInContext.addInstruction(ABCConstants.OP_getlocal1);\ncallInContext.addInstruction(ABCConstants.OP_getlocal2);\ncallInContext.addInstruction(ABCConstants.OP_getlocal3);\ncallInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\ncallInContext.addInstruction(ABCConstants.OP_getlocal, 4);\nLabel callInContextReturnVoid = new Label();\ncallInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n.add(new Name(IASLanguageConstants.Function))\n.add(new Name(IASLanguageConstants.Object))\n.add(new Name(IASLanguageConstants.Array))\n.add(new Name(IASLanguageConstants.Boolean))\n.build();\nclassGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null,\nCollections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n}\n\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()","code_context_10":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n{\nIResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(),\nNamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\nInstructionList callInContext = new InstructionList();\ncallInContext.addInstruction(ABCConstants.OP_getlocal1);\ncallInContext.addInstruction(ABCConstants.OP_getlocal2);\ncallInContext.addInstruction(ABCConstants.OP_getlocal3);\ncallInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\ncallInContext.addInstruction(ABCConstants.OP_getlocal, 4);\nLabel callInContextReturnVoid = new Label();\ncallInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n.add(new Name(IASLanguageConstants.Function))\n.add(new Name(IASLanguageConstants.Object))\n.add(new Name(IASLanguageConstants.Array))\n.add(new Name(IASLanguageConstants.Boolean))\n.build();\nclassGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null,\nCollections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n}\n\nInstructionList callInContext = new InstructionList();\ncallInContext.addInstruction(ABCConstants.OP_getlocal1);\ncallInContext.addInstruction(ABCConstants.OP_getlocal2);\ncallInContext.addInstruction(ABCConstants.OP_getlocal3);\ncallInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\ncallInContext.addInstruction(ABCConstants.OP_getlocal, 4);\nLabel callInContextReturnVoid = new Label();\ncallInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n.add(new Name(IASLanguageConstants.Function))\n.add(new Name(IASLanguageConstants.Object))\n.add(new Name(IASLanguageConstants.Array))\n.add(new Name(IASLanguageConstants.Boolean))\n.build();\nclassGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null,\nCollections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n}","code_context_20":"protected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n{\nIResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(),\nNamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\nInstructionList callInContext = new InstructionList();\ncallInContext.addInstruction(ABCConstants.OP_getlocal1);\ncallInContext.addInstruction(ABCConstants.OP_getlocal2);\ncallInContext.addInstruction(ABCConstants.OP_getlocal3);\ncallInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\ncallInContext.addInstruction(ABCConstants.OP_getlocal, 4);\nLabel callInContextReturnVoid = new Label();\ncallInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n.add(new Name(IASLanguageConstants.Function))\n.add(new Name(IASLanguageConstants.Object))\n.add(new Name(IASLanguageConstants.Array))\n.add(new Name(IASLanguageConstants.Boolean))\n.build();\nclassGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null,\nCollections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n}\n\nprotected final void codegenCallInContextMethod(ClassGeneratorHelper classGen, boolean isOverride)\n{\nIResolvedQualifiersReference applyReference = ReferenceFactory.resolvedQualifierQualifiedReference(royaleProject.getWorkspace(),\nNamespaceDefinition.getAS3NamespaceDefinition(), \"apply\");\nInstructionList callInContext = new InstructionList();\ncallInContext.addInstruction(ABCConstants.OP_getlocal1);\ncallInContext.addInstruction(ABCConstants.OP_getlocal2);\ncallInContext.addInstruction(ABCConstants.OP_getlocal3);\ncallInContext.addInstruction(ABCConstants.OP_callproperty, new Object[] {applyReference.getMName(), 2});\ncallInContext.addInstruction(ABCConstants.OP_getlocal, 4);\nLabel callInContextReturnVoid = new Label();\ncallInContext.addInstruction(ABCConstants.OP_iffalse, callInContextReturnVoid);\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\ncallInContext.labelNext(callInContextReturnVoid);\n\/\/ TODO This should be OP_returnvoid, but the Boolean default value\n\/\/ for the 'returns' parameter isn't defaulting to true.\n\/\/ Fix this after CMP-936 is fixed.\ncallInContext.addInstruction(ABCConstants.OP_returnvalue);\nImmutableList<Name> callInContextParams = new ImmutableList.Builder<Name>()\n.add(new Name(IASLanguageConstants.Function))\n.add(new Name(IASLanguageConstants.Object))\n.add(new Name(IASLanguageConstants.Array))\n.add(new Name(IASLanguageConstants.Boolean))\n.build();\nclassGen.addITraitsMethod(new Name(\"callInContext\"), callInContextParams, null,\nCollections.<Object> singletonList(Boolean.TRUE), false, true, isOverride, callInContext);\n}","label":[1,0,0,0]}
{"id":16242,"original_code":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total();        \/\/ TODO add your handling code here:\n    }","code":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\n    }","cleancode":"private void rhkeyreleased(java.awt.event.keyevent evt) { }","comment":"\/\/gen-first:event_rhkeyreleased\n\/\/ calc_total(); \/\/ todo add your handling code here:","repo":"ajpro-byte\/ClinicMGMT","code_context_2":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}\n\nprivate void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}","code_context_10":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}\n\nprivate void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}","code_context_20":"private void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}\n\nprivate void rhKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_rhKeyReleased\n\/\/ calc_total(); \/\/ TODO add your handling code here:\n}","label":[0,1,0,0]}
{"id":16243,"original_code":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n \/\/calc_total();        \/\/ TODO add your handling code here:\n if (ri.isEnabled()==true){\n calc_total();\n }else{\n }\n    }","code":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\n if (ri.isEnabled()==true){\n calc_total();\n }else{\n }\n    }","cleancode":"private void rikeyreleased(java.awt.event.keyevent evt) { if (ri.isenabled()==true){ calc_total(); }else{ } }","comment":"\/\/gen-first:event_rikeyreleased\n\/\/calc_total(); \/\/ todo add your handling code here:","repo":"ajpro-byte\/ClinicMGMT","code_context_2":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\n\nprivate void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\ncalc_total();","code_context_10":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\ncalc_total();\n}else{\n}\n}\n\nprivate void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\ncalc_total();\n}else{\n}\n}","code_context_20":"private void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\ncalc_total();\n}else{\n}\n}\n\nprivate void riKeyReleased(java.awt.event.KeyEvent evt) {\/\/GEN-FIRST:event_riKeyReleased\n\/\/calc_total(); \/\/ TODO add your handling code here:\nif (ri.isEnabled()==true){\ncalc_total();\n}else{\n}\n}","label":[0,1,0,0]}

{"id":22,"original_code":"public boolean usesRegs() {\n        \/\/ FIXME: this is almost certainly boned.  a Reg could appear in the\n        \/\/ address expressions.\n        for (int i=0;i<rhs().length;++i) {\n            if (usesDirectly(i) && rhs()[i] instanceof Reg) {\n                return true;\n            }\n        }\n        if (opcode.form().implicitUses(head().code()).length!=0) {\n            return true;\n        }\n        return false;\n    }","code":"public boolean usesRegs() {\n       \n       \n        for (int i=0;i<rhs().length;++i) {\n            if (usesDirectly(i) && rhs()[i] instanceof Reg) {\n                return true;\n            }\n        }\n        if (opcode.form().implicitUses(head().code()).length!=0) {\n            return true;\n        }\n        return false;\n    }","cleancode":"public boolean usesregs() { for (int i=0;i<rhs().length;++i) { if (usesdirectly(i) && rhs()[i] instanceof reg) { return true; } } if (opcode.form().implicituses(head().code()).length!=0) { return true; } return false; }","comment":"\/\/ fixme: this is almost certainly boned. a reg could appear in the \/\/ address expressions.","repo":"mihirlibran\/cse605","code_context_2":"public boolean usesRegs() {\n\/\/ FIXME: this is almost certainly boned. a Reg could appear in the\n\/\/ address expressions.\nfor (int i=0;i<rhs().length;++i) {\nif (usesDirectly(i) && rhs()[i] instanceof Reg) {","code_context_10":"public boolean usesRegs() {\n\/\/ FIXME: this is almost certainly boned. a Reg could appear in the\n\/\/ address expressions.\nfor (int i=0;i<rhs().length;++i) {\nif (usesDirectly(i) && rhs()[i] instanceof Reg) {\nreturn true;\n}\n}\nif (opcode.form().implicitUses(head().code()).length!=0) {\nreturn true;\n}\nreturn false;\n}","code_context_20":"public boolean usesRegs() {\n\/\/ FIXME: this is almost certainly boned. a Reg could appear in the\n\/\/ address expressions.\nfor (int i=0;i<rhs().length;++i) {\nif (usesDirectly(i) && rhs()[i] instanceof Reg) {\nreturn true;\n}\n}\nif (opcode.form().implicitUses(head().code()).length!=0) {\nreturn true;\n}\nreturn false;\n}","label":[0,0,1,0]}
{"id":83,"original_code":"@Test\n    public void parseNegativeIntegerLiteral(\n    ) throws ExpressionException {\n        LineSpecifier ls = new LineSpecifier(0, 10);\n        Locale locale = new Locale(ls, 10);\n        ExpressionParser parser = new ExpressionParser(\"-14458\", locale);\n        Expression exp = parser.parse(new Assembler.Builder().build());\n        assertEquals(2, exp._items.size());\n        ExpressionItem item0 = exp._items.get(0);\n        assertTrue(item0 instanceof OperatorItem);\n\/\/        Operator op = ((OperatorItem) item0)._operator; \/\/  TODO check this value if we can, somehow\n        ExpressionItem item1 = exp._items.get(1);\n        assertTrue(item1 instanceof ValueItem);\n        Value v1 = ((ValueItem)item1)._value;\n        assertTrue(v1 instanceof IntegerValue);\n        assertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n    }","code":"@Test\n    public void parseNegativeIntegerLiteral(\n    ) throws ExpressionException {\n        LineSpecifier ls = new LineSpecifier(0, 10);\n        Locale locale = new Locale(ls, 10);\n        ExpressionParser parser = new ExpressionParser(\"-14458\", locale);\n        Expression exp = parser.parse(new Assembler.Builder().build());\n        assertEquals(2, exp._items.size());\n        ExpressionItem item0 = exp._items.get(0);\n        assertTrue(item0 instanceof OperatorItem);\n        ExpressionItem item1 = exp._items.get(1);\n        assertTrue(item1 instanceof ValueItem);\n        Value v1 = ((ValueItem)item1)._value;\n        assertTrue(v1 instanceof IntegerValue);\n        assertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n    }","cleancode":"@test public void parsenegativeintegerliteral( ) throws expressionexception { linespecifier ls = new linespecifier(0, 10); locale locale = new locale(ls, 10); expressionparser parser = new expressionparser(\"-14458\", locale); expression exp = parser.parse(new assembler.builder().build()); assertequals(2, exp._items.size()); expressionitem item0 = exp._items.get(0); asserttrue(item0 instanceof operatoritem); expressionitem item1 = exp._items.get(1); asserttrue(item1 instanceof valueitem); value v1 = ((valueitem)item1)._value; asserttrue(v1 instanceof integervalue); assertequals(14458l, ((integervalue)v1)._value.get().longvalue()); }","comment":"\/\/ operator op = ((operatoritem) item0)._operator; \/\/ todo check this value if we can, somehow","repo":"kduncan99\/em2200-java","code_context_2":"ExpressionItem item0 = exp._items.get(0);\nassertTrue(item0 instanceof OperatorItem);\n\/\/ Operator op = ((OperatorItem) item0)._operator; \/\/ TODO check this value if we can, somehow\nExpressionItem item1 = exp._items.get(1);\nassertTrue(item1 instanceof ValueItem);","code_context_10":"@Test\npublic void parseNegativeIntegerLiteral(\n) throws ExpressionException {\nLineSpecifier ls = new LineSpecifier(0, 10);\nLocale locale = new Locale(ls, 10);\nExpressionParser parser = new ExpressionParser(\"-14458\", locale);\nExpression exp = parser.parse(new Assembler.Builder().build());\nassertEquals(2, exp._items.size());\nExpressionItem item0 = exp._items.get(0);\nassertTrue(item0 instanceof OperatorItem);\n\/\/ Operator op = ((OperatorItem) item0)._operator; \/\/ TODO check this value if we can, somehow\nExpressionItem item1 = exp._items.get(1);\nassertTrue(item1 instanceof ValueItem);\nValue v1 = ((ValueItem)item1)._value;\nassertTrue(v1 instanceof IntegerValue);\nassertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n}","code_context_20":"@Test\npublic void parseNegativeIntegerLiteral(\n) throws ExpressionException {\nLineSpecifier ls = new LineSpecifier(0, 10);\nLocale locale = new Locale(ls, 10);\nExpressionParser parser = new ExpressionParser(\"-14458\", locale);\nExpression exp = parser.parse(new Assembler.Builder().build());\nassertEquals(2, exp._items.size());\nExpressionItem item0 = exp._items.get(0);\nassertTrue(item0 instanceof OperatorItem);\n\/\/ Operator op = ((OperatorItem) item0)._operator; \/\/ TODO check this value if we can, somehow\nExpressionItem item1 = exp._items.get(1);\nassertTrue(item1 instanceof ValueItem);\nValue v1 = ((ValueItem)item1)._value;\nassertTrue(v1 instanceof IntegerValue);\nassertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n}","label":[1,0,0,0]}
{"id":118,"original_code":"@Override\n    public void onLocationChanged(Location location) {\n        mLocation = location;\n        if (mLocation != null) {\n            \/\/ Bug report: cached GeoPoint is being returned as the first value.\n            \/\/ Wait for the 2nd value to be returned, which is hopefully not cached?\n            ++mLocationCount;\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") lat: \" +\n                    mLocation.getLatitude() + \" long: \" +\n                    mLocation.getLongitude() + \" acc: \" +\n                    mLocation.getAccuracy());\n            if (mLocationCount > 1) {\n                mLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\n                        mLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\n                if (mLocation.getAccuracy() <= mLocationAccuracy) {\n                    returnLocation();\n                }\n            }\n        } else {\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") null location\");\n        }\n    }","code":"@Override\n    public void onLocationChanged(Location location) {\n        mLocation = location;\n        if (mLocation != null) {\n           \n           \n            ++mLocationCount;\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") lat: \" +\n                    mLocation.getLatitude() + \" long: \" +\n                    mLocation.getLongitude() + \" acc: \" +\n                    mLocation.getAccuracy());\n            if (mLocationCount > 1) {\n                mLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\n                        mLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\n                if (mLocation.getAccuracy() <= mLocationAccuracy) {\n                    returnLocation();\n                }\n            }\n        } else {\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") null location\");\n        }\n    }","cleancode":"@override public void onlocationchanged(location location) { mlocation = location; if (mlocation != null) { ++mlocationcount; infologger.geolog(\"geopointactivity: \" + system.currenttimemillis() + \" onlocationchanged(\" + mlocationcount + \") lat: \" + mlocation.getlatitude() + \" long: \" + mlocation.getlongitude() + \" acc: \" + mlocation.getaccuracy()); if (mlocationcount > 1) { mlocationdialog.setmessage(getstring(r.string.location_provider_accuracy, mlocation.getprovider(), truncatedouble(mlocation.getaccuracy()))); if (mlocation.getaccuracy() <= mlocationaccuracy) { returnlocation(); } } } else { infologger.geolog(\"geopointactivity: \" + system.currenttimemillis() + \" onlocationchanged(\" + mlocationcount + \") null location\"); } }","comment":"\/\/ bug report: cached geopoint is being returned as the first value. \/\/ wait for the 2nd value to be returned, which is hopefully not cached?","repo":"jorgepsendziuk\/novo_coletor","code_context_2":"mLocation = location;\nif (mLocation != null) {\n\/\/ Bug report: cached GeoPoint is being returned as the first value.\n\/\/ Wait for the 2nd value to be returned, which is hopefully not cached?\n++mLocationCount;\nInfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +","code_context_10":"@Override\npublic void onLocationChanged(Location location) {\nmLocation = location;\nif (mLocation != null) {\n\/\/ Bug report: cached GeoPoint is being returned as the first value.\n\/\/ Wait for the 2nd value to be returned, which is hopefully not cached?\n++mLocationCount;\nInfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n\" onLocationChanged(\" + mLocationCount + \") lat: \" +\nmLocation.getLatitude() + \" long: \" +\nmLocation.getLongitude() + \" acc: \" +\nmLocation.getAccuracy());\nif (mLocationCount > 1) {\nmLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\nmLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\nif (mLocation.getAccuracy() <= mLocationAccuracy) {","code_context_20":"@Override\npublic void onLocationChanged(Location location) {\nmLocation = location;\nif (mLocation != null) {\n\/\/ Bug report: cached GeoPoint is being returned as the first value.\n\/\/ Wait for the 2nd value to be returned, which is hopefully not cached?\n++mLocationCount;\nInfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n\" onLocationChanged(\" + mLocationCount + \") lat: \" +\nmLocation.getLatitude() + \" long: \" +\nmLocation.getLongitude() + \" acc: \" +\nmLocation.getAccuracy());\nif (mLocationCount > 1) {\nmLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\nmLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\nif (mLocation.getAccuracy() <= mLocationAccuracy) {\nreturnLocation();\n}\n}\n} else {\nInfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n\" onLocationChanged(\" + mLocationCount + \") null location\");\n}\n}","label":[0,0,1,0]}
{"id":32955,"original_code":"@Deprecated\n    public FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\n        Yaml yaml = new Yaml();\n        LinkedHashMap swaggerFile =  yaml.load(FileUtils.openInputStream(spec));\n        String groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\n        String artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\n        String artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\n        String groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\n        StringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\n        artifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\n        CodegenConfigurator configurator = new CodegenConfigurator();\n        String artifactId = artifactIdSb.toString();\n        initializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\n        configurator.setArtifactVersionApi(artifactVersionApi);\n        return getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n    }","code":"@Deprecated\n    public FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\n        Yaml yaml = new Yaml();\n        LinkedHashMap swaggerFile =  yaml.load(FileUtils.openInputStream(spec));\n        String groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\n        String artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\n        String artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\n        String groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\n        StringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\n        artifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\n        CodegenConfigurator configurator = new CodegenConfigurator();\n        String artifactId = artifactIdSb.toString();\n        initializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\n        configurator.setArtifactVersionApi(artifactVersionApi);\n        return getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n    }","cleancode":"@deprecated public filedatasource generatepythonimpl(file spec, string artifactname, string groupid, string artifactversion, string implemname) throws exception { yaml yaml = new yaml(); linkedhashmap swaggerfile = yaml.load(fileutils.openinputstream(spec)); string groupidapi = getpropinswaggerfile(swaggerfile, \"x-groupid\"); string artifactnameapi = getpropinswaggerfile(swaggerfile, \"x-artifactname\"); string artifactversionapi = getpropinswaggerfile(swaggerfile, \"version\"); string groupname = groupid.substring(groupid.lastindexof('.') + 1); stringbuilder artifactidsb = new stringbuilder().append(groupname).append(\"-\").append(artifactnameapi).append(\"-\"); artifactidsb.append(artifactname.replaceall(\"-\",\"\")); codegenconfigurator configurator = new codegenconfigurator(); string artifactid = artifactidsb.tostring(); initializeconfigurator(spec, \"kathrapython\", artifactnameapi, groupidapi, artifactversion, \"implem\", artifactid, configurator); configurator.setartifactversionapi(artifactversionapi); return getfiledatasource(spec, \"implem\", artifactidsb, artifactid, configurator); }","comment":"\/** * this thingy is crazy !! upgrading or improvements are forbidden ! coded to * ce truc est legacy de ouf !! alors on arr\u00eate les conneries et plus de nouveaux dev dessus ! * * @param spec * @param artifactname * @param groupid * @param artifactversion * @param implemname * @return * @throws exception *\/","repo":"kathra-project\/kathra-codegen-swagger","code_context_2":"@Deprecated\npublic FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\nYaml yaml = new Yaml();\nLinkedHashMap swaggerFile = yaml.load(FileUtils.openInputStream(spec));\nString groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\nString artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\nString artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\nString groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\nStringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\nartifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\nCodegenConfigurator configurator = new CodegenConfigurator();\nString artifactId = artifactIdSb.toString();\ninitializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\nconfigurator.setArtifactVersionApi(artifactVersionApi);\nreturn getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n}","code_context_10":"@Deprecated\npublic FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\nYaml yaml = new Yaml();\nLinkedHashMap swaggerFile = yaml.load(FileUtils.openInputStream(spec));\nString groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\nString artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\nString artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\nString groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\nStringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\nartifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\nCodegenConfigurator configurator = new CodegenConfigurator();\nString artifactId = artifactIdSb.toString();\ninitializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\nconfigurator.setArtifactVersionApi(artifactVersionApi);\nreturn getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n}","code_context_20":"@Deprecated\npublic FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\nYaml yaml = new Yaml();\nLinkedHashMap swaggerFile = yaml.load(FileUtils.openInputStream(spec));\nString groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\nString artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\nString artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\nString groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\nStringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\nartifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\nCodegenConfigurator configurator = new CodegenConfigurator();\nString artifactId = artifactIdSb.toString();\ninitializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\nconfigurator.setArtifactVersionApi(artifactVersionApi);\nreturn getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n}","label":[1,0,0,0]}
{"id":16627,"original_code":"public void checkList()\n\t{\n\t\tif(observed.size() != cachedSize)\n\t\t{\n\t\t\tcachedSize = observed.size();\n\t\t\tlistUpdated();\n\t\t}\n\t}","code":"public void checkList()\n\t{\n\t\tif(observed.size() != cachedSize)\n\t\t{\n\t\t\tcachedSize = observed.size();\n\t\t\tlistUpdated();\n\t\t}\n\t}","cleancode":"public void checklist() { if(observed.size() != cachedsize) { cachedsize = observed.size(); listupdated(); } }","comment":"\/\/todo: this could fail if an equals number of additions and removals happened within one second.","repo":"justin-espedal\/polydes","code_context_2":"public void checkList()\n{\nif(observed.size() != cachedSize)\n{\ncachedSize = observed.size();\nlistUpdated();\n}\n}","code_context_10":"public void checkList()\n{\nif(observed.size() != cachedSize)\n{\ncachedSize = observed.size();\nlistUpdated();\n}\n}","code_context_20":"public void checkList()\n{\nif(observed.size() != cachedSize)\n{\ncachedSize = observed.size();\nlistUpdated();\n}\n}","label":[0,0,1,0]}
{"id":16754,"original_code":"@Override\n        public boolean isReferenceTo(PsiElement psiElement) {\n            if(!(psiElement instanceof PhpNamedElement)) {\n                return false;\n            }\n            String text = getElement().getText();\n            if(StringUtils.isBlank(text)) {\n                return false;\n            }\n            PsiElement namespace = element.getPrevSibling();\n            if(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n                \/\/ @TODO: namespace not supported\n                return false;\n            }\n            String classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\n            if(classByContext != null) {\n                return StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n                    .equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n            }\n            return false;\n        }","code":"@Override\n        public boolean isReferenceTo(PsiElement psiElement) {\n            if(!(psiElement instanceof PhpNamedElement)) {\n                return false;\n            }\n            String text = getElement().getText();\n            if(StringUtils.isBlank(text)) {\n                return false;\n            }\n            PsiElement namespace = element.getPrevSibling();\n            if(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n               \n                return false;\n            }\n            String classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\n            if(classByContext != null) {\n                return StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n                    .equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n            }\n            return false;\n        }","cleancode":"@override public boolean isreferenceto(psielement psielement) { if(!(psielement instanceof phpnamedelement)) { return false; } string text = getelement().gettext(); if(stringutils.isblank(text)) { return false; } psielement namespace = element.getprevsibling(); if(phppsiutil.isoftype(namespace, phpdoctokentypes.doc_namespace)) { return false; } string classbycontext = phpelementsutil.getfqnforclassnamebycontext(element, text); if(classbycontext != null) { return stringutils.stripstart(((phpnamedelement) psielement).getfqn(), \"\\\\\") .equalsignorecase(stringutils.stripstart(fqn, \"\\\\\")); } return false; }","comment":"\/** * attach element identify name to class of \"use\" usage * * @param psielement phpclass used in \"use\" statement *\/\n\/\/ @todo: namespace not supported","repo":"meyerbaptiste\/idea-php-annotation-plugin","code_context_2":"@Override\npublic boolean isReferenceTo(PsiElement psiElement) {\nif(!(psiElement instanceof PhpNamedElement)) {\nreturn false;\n}\nString text = getElement().getText();\nif(StringUtils.isBlank(text)) {\nreturn false;\n}\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}\nString classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\nif(classByContext != null) {\nreturn StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n.equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n}\nreturn false;\n}\n\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}","code_context_10":"@Override\npublic boolean isReferenceTo(PsiElement psiElement) {\nif(!(psiElement instanceof PhpNamedElement)) {\nreturn false;\n}\nString text = getElement().getText();\nif(StringUtils.isBlank(text)) {\nreturn false;\n}\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}\nString classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\nif(classByContext != null) {\nreturn StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n.equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n}\nreturn false;\n}\n\npublic boolean isReferenceTo(PsiElement psiElement) {\nif(!(psiElement instanceof PhpNamedElement)) {\nreturn false;\n}\nString text = getElement().getText();\nif(StringUtils.isBlank(text)) {\nreturn false;\n}\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}\nString classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\nif(classByContext != null) {\nreturn StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n.equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n}\nreturn false;\n}","code_context_20":"@Override\npublic boolean isReferenceTo(PsiElement psiElement) {\nif(!(psiElement instanceof PhpNamedElement)) {\nreturn false;\n}\nString text = getElement().getText();\nif(StringUtils.isBlank(text)) {\nreturn false;\n}\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}\nString classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\nif(classByContext != null) {\nreturn StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n.equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n}\nreturn false;\n}\n\n@Override\npublic boolean isReferenceTo(PsiElement psiElement) {\nif(!(psiElement instanceof PhpNamedElement)) {\nreturn false;\n}\nString text = getElement().getText();\nif(StringUtils.isBlank(text)) {\nreturn false;\n}\nPsiElement namespace = element.getPrevSibling();\nif(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n\/\/ @TODO: namespace not supported\nreturn false;\n}\nString classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\nif(classByContext != null) {\nreturn StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n.equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n}\nreturn false;\n}","label":[0,1,0,0]}
{"id":16808,"original_code":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\n        MDCBuilder.buildMdcContext(stack);\n        String environmentCrn = stack.getEnvironmentCrn();\n        Multimap<String, String> warnings = ArrayListMultimap.create();\n        try {\n            FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n            UsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\n            stateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\n            retrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\n            if (options.isFullSync()) {\n                \/\/ TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\n                if (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\n                    cloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\n                    LOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n                }\n                if (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\n                    try {\n                        sudoRuleService.setupSudoRule(stack, freeIpaClient);\n                    } catch (Exception e) {\n                        warnings.put(stack.getEnvironmentCrn(), e.getMessage());\n                        LOGGER.error(\"{} failed for environment '{}'.\", ADD_SUDO_RULES, stack.getEnvironmentCrn(), e);\n                    }\n                    LOGGER.debug(\"Finished {}.\", ADD_SUDO_RULES);\n                }\n            }\n            return toSyncStatusDetail(environmentCrn, warnings);\n        } catch (TimeoutException e) {\n            LOGGER.warn(\"Timed out while synchronizing environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, \"Timed out\", warnings);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to synchronize environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, e.getLocalizedMessage(), warnings);\n        }\n    }","code":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\n        MDCBuilder.buildMdcContext(stack);\n        String environmentCrn = stack.getEnvironmentCrn();\n        Multimap<String, String> warnings = ArrayListMultimap.create();\n        try {\n            FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n            UsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\n            stateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\n            retrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\n            if (options.isFullSync()) {\n               \n                if (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\n                    cloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\n                    LOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n                }\n                if (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\n                    try {\n                        sudoRuleService.setupSudoRule(stack, freeIpaClient);\n                    } catch (Exception e) {\n                        warnings.put(stack.getEnvironmentCrn(), e.getMessage());\n                        LOGGER.error(\"{} failed for environment '{}'.\", ADD_SUDO_RULES, stack.getEnvironmentCrn(), e);\n                    }\n                    LOGGER.debug(\"Finished {}.\", ADD_SUDO_RULES);\n                }\n            }\n            return toSyncStatusDetail(environmentCrn, warnings);\n        } catch (TimeoutException e) {\n            LOGGER.warn(\"Timed out while synchronizing environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, \"Timed out\", warnings);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to synchronize environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, e.getLocalizedMessage(), warnings);\n        }\n    }","cleancode":"public syncstatusdetail synchronizestack(stack stack, umsusersstate umsusersstate, usersyncoptions options) { mdcbuilder.buildmdccontext(stack); string environmentcrn = stack.getenvironmentcrn(); multimap<string, string> warnings = arraylistmultimap.create(); try { freeipaclient freeipaclient = freeipaclientfactory.getfreeipaclientforstack(stack); usersstatedifference usersstatedifferencebeforesync = compareumsandfreeipa(umsusersstate, options, freeipaclient); stateapplier.applydifference(umsusersstate, environmentcrn, warnings, usersstatedifferencebeforesync, options, freeipaclient); retrysyncifbatchcallhaswarnings(stack, umsusersstate, warnings, options, freeipaclient, usersstatedifferencebeforesync); if (options.isfullsync()) { if (entitlementservice.cloudidentitymappingenabled(stack.getaccountid())) { logger.debug(\"starting {} ...\", sync_cloud_identities); cloudidentitysyncservice.synccloudidentities(stack, umsusersstate, warnings::put); logger.debug(\"finished {}.\", sync_cloud_identities); } if (entitlementservice.isenvironmentprivilegeduserenabled(stack.getaccountid())) { logger.debug(\"starting {} ...\", add_sudo_rules); try { sudoruleservice.setupsudorule(stack, freeipaclient); } catch (exception e) { warnings.put(stack.getenvironmentcrn(), e.getmessage()); logger.error(\"{} failed for environment '{}'.\", add_sudo_rules, stack.getenvironmentcrn(), e); } logger.debug(\"finished {}.\", add_sudo_rules); } } return tosyncstatusdetail(environmentcrn, warnings); } catch (timeoutexception e) { logger.warn(\"timed out while synchronizing environment {}\", environmentcrn, e); return syncstatusdetail.fail(environmentcrn, \"timed out\", warnings); } catch (exception e) { logger.warn(\"failed to synchronize environment {}\", environmentcrn, e); return syncstatusdetail.fail(environmentcrn, e.getlocalizedmessage(), warnings); } }","comment":"\/\/ todo for now we only sync cloud ids during full sync. we should eventually allow more granular syncs (actor level and group level sync).","repo":"mdvtlp\/cloudbreak","code_context_2":"retrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\nif (options.isFullSync()) {\n\/\/ TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\nif (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\nLOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);","code_context_10":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\nMDCBuilder.buildMdcContext(stack);\nString environmentCrn = stack.getEnvironmentCrn();\nMultimap<String, String> warnings = ArrayListMultimap.create();\ntry {\nFreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\nUsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\nstateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\nretrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\nif (options.isFullSync()) {\n\/\/ TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\nif (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\nLOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\ncloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\nLOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n}\nif (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\nLOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\ntry {\nsudoRuleService.setupSudoRule(stack, freeIpaClient);\n} catch (Exception e) {","code_context_20":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\nMDCBuilder.buildMdcContext(stack);\nString environmentCrn = stack.getEnvironmentCrn();\nMultimap<String, String> warnings = ArrayListMultimap.create();\ntry {\nFreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\nUsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\nstateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\nretrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\nif (options.isFullSync()) {\n\/\/ TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\nif (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\nLOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\ncloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\nLOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n}\nif (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\nLOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\ntry {\nsudoRuleService.setupSudoRule(stack, freeIpaClient);\n} catch (Exception e) {\nwarnings.put(stack.getEnvironmentCrn(), e.getMessage());\nLOGGER.error(\"{} failed for environment '{}'.\", ADD_SUDO_RULES, stack.getEnvironmentCrn(), e);\n}\nLOGGER.debug(\"Finished {}.\", ADD_SUDO_RULES);\n}\n}\nreturn toSyncStatusDetail(environmentCrn, warnings);\n} catch (TimeoutException e) {\nLOGGER.warn(\"Timed out while synchronizing environment {}\", environmentCrn, e);\nreturn SyncStatusDetail.fail(environmentCrn, \"Timed out\", warnings);","label":[0,1,0,0]}
{"id":25017,"original_code":"public static String obtainProcessID() {\n\t\t\/\/get process id\n\t\tString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\n\t\tString pid = pname.split(\"@\")[0];\n\t\t\/\/ TODO: change this as soon as we switch to a java version >= 9\n\t\t\/\/ import java.lang.ProcessHandle;\n\t\t\/\/ pid = ProcessHandle.current().pid();\n\t\treturn pid;\n\t}","code":"public static String obtainProcessID() {\n\t\n\t\tString pname = ManagementFactory.getRuntimeMXBean().getName();\n\t\tString pid = pname.split(\"@\")[0];\n\t\n\t\n\t\n\t\treturn pid;\n\t}","cleancode":"public static string obtainprocessid() { string pname = managementfactory.getruntimemxbean().getname(); string pid = pname.split(\"@\")[0]; return pid; }","comment":"\/\/get process id\n\/\/pid@hostname\n\/\/ todo: change this as soon as we switch to a java version >= 9 \/\/ import java.lang.processhandle; \/\/ pid = processhandle.current().pid();","repo":"mgd-hin\/systemds","code_context_2":"public static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\npublic static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}","code_context_10":"public static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}\n\npublic static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}\n\npublic static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}","code_context_20":"public static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}\n\npublic static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}\n\npublic static String obtainProcessID() {\n\/\/get process id\nString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\nString pid = pname.split(\"@\")[0];\n\/\/ TODO: change this as soon as we switch to a java version >= 9\n\/\/ import java.lang.ProcessHandle;\n\/\/ pid = ProcessHandle.current().pid();\nreturn pid;\n}","label":[1,0,0,0]}
{"id":16892,"original_code":"public static LeXeMerger build(String pathToMergeSchema) {\n        if (builder == null) {\n            builder = new GenericLexemeBuilder();\n        }\n        return builder.build(pathToMergeSchema);\n    }","code":"public static LeXeMerger build(String pathToMergeSchema) {\n        if (builder == null) {\n            builder = new GenericLexemeBuilder();\n        }\n        return builder.build(pathToMergeSchema);\n    }","cleancode":"public static lexemerger build(string pathtomergeschema) { if (builder == null) { builder = new genericlexemebuilder(); } return builder.build(pathtomergeschema); }","comment":"\/** * @param pathtomergeschema * string path to the mergeschema to be used on this document. note: will in future builds * replaced by pathtomergeschemas which leads to a directory containing mergeschemas for every * used namespace. * * if <b>null<\/b> the default mergeschemas will be used * @author sholzer (12.03.2015) * @return a lexemerger *\/","repo":"maybeec\/lexeme","code_context_2":"public static LeXeMerger build(String pathToMergeSchema) {\nif (builder == null) {\nbuilder = new GenericLexemeBuilder();\n}\nreturn builder.build(pathToMergeSchema);\n}","code_context_10":"public static LeXeMerger build(String pathToMergeSchema) {\nif (builder == null) {\nbuilder = new GenericLexemeBuilder();\n}\nreturn builder.build(pathToMergeSchema);\n}","code_context_20":"public static LeXeMerger build(String pathToMergeSchema) {\nif (builder == null) {\nbuilder = new GenericLexemeBuilder();\n}\nreturn builder.build(pathToMergeSchema);\n}","label":[0,0,0,0]}
{"id":16946,"original_code":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\n                                          String controlFileName,\n                                          String testGroupID,\n                                          String oneTestID,\n                                          Map<String, ServiceResult> serviceResultsMap,\n                                          boolean param_autoDeletePOSTS,\n                                          Dump dump,\n                                          String protoHostPortParam,\n                                          AuthsMap defaultAuths,\n                                          List<String> reportsList,\n                                          String reportsDir)\n                                          throws Exception {\n        \/\/Internally, we maintain two collections of ServiceResult:\n        \/\/  the first is the return value of this method.\n        \/\/  the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\n        List<ServiceResult> results = new ArrayList<ServiceResult>();\n        XmlReplayReport report = new XmlReplayReport(reportsDir);\n        String controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\n        org.dom4j.Document document;\n        document = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\n        if (document==null){\n            throw new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n        }\n        String protoHostPort;\n        if (Tools.isEmpty(protoHostPortParam)){\n            protoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\n            System.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n        } else {\n            protoHostPort = protoHostPortParam;\n        }\n        if (Tools.isEmpty(protoHostPort)){\n            throw new Exception(\"XmlReplay control file must have a protoHostPort element\");\n        }\n        String authsMapINFO;\n        AuthsMap authsMap = readAuths(document);\n        if (authsMap.map.size()==0){\n            authsMap = defaultAuths;\n            authsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n        } else {\n            authsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n        }\n        report.addTestGroup(testGroupID, controlFileName);   \/\/controlFileName is just the short name, without the full path.\n        String xmlReplayHeader = \"========================================================================\"\n                          +\"\\r\\nXmlReplay running:\"\n                          +\"\\r\\n   controlFile: \"+ (new File(controlFile).getCanonicalPath())\n                          +\"\\r\\n   protoHostPort: \"+protoHostPort\n                          +\"\\r\\n   testGroup: \"+testGroupID\n                          + (Tools.notEmpty(oneTestID) ? \"\\r\\n   oneTestID: \"+oneTestID : \"\")\n                          +\"\\r\\n   AuthsMap: \"+authsMapINFO\n                          +\"\\r\\n   param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n                          +\"\\r\\n   Dump info: \"+dump\n                          +\"\\r\\n========================================================================\"\n                          +\"\\r\\n\";\n        report.addRunInfo(xmlReplayHeader);\n        System.out.println(xmlReplayHeader);\n        String autoDeletePOSTS = \"\";\n        List<Node> testgroupNodes;\n        if (Tools.notEmpty(testGroupID)){\n            testgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n        } else {\n            testgroupNodes = document.selectNodes(\"\/\/testGroup\");\n        }\n        JexlEngine jexl = new JexlEngine();   \/\/ Used for expression language expansion from uri field.\n        XmlReplayEval evalStruct = new XmlReplayEval();\n        evalStruct.serviceResultsMap = serviceResultsMap;\n        evalStruct.jexl = jexl;\n        for (Node testgroup : testgroupNodes) {\n            XmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext();  \/\/Get a new JexlContext for each test group.\n            evalStruct.jc = jc;\n            autoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\n            List<Node> tests;\n            if (Tools.notEmpty(oneTestID)){\n                tests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n            } else {\n                tests = testgroup.selectNodes(\"test\");\n            }\n            String authForTest = \"\";\n            int testElementIndex = -1;\n            for (Node testNode : tests) {\n                long startTime = System.currentTimeMillis();\n                try {\n                    testElementIndex++;\n                    String testID = testNode.valueOf(\"@ID\");\n                    \/\/\n                    \/\/ Figure out if we will auto delete resources\n                    boolean autoDelete = param_autoDeletePOSTS;\n                    String autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\n                    if (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\n                    \tautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n                    }\n                    String testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\n                    String method = testNode.valueOf(\"method\");\n                    String contentType = testNode.valueOf(\"contentType\");\n                    String uri = testNode.valueOf(\"uri\");\n                    String fullURL = Tools.glue(protoHostPort, \"\/\", uri);\n                    if (contentType == null || contentType.equals(\"\")) {\n                        contentType = XmlReplayTransport.APPLICATION_XML;\n                    }\n                    String currentAuthForTest = null;\n                    String authIDForTest = testNode.valueOf(\"@auth\");\n                    if (Tools.notEmpty(authIDForTest)){\n                        currentAuthForTest = authsMap.map.get(authIDForTest);\n                    }\n                    else {\n                        String tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\n                        if (Tools.notEmpty(tokenAuthExpression)){\n                            currentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n                        }\n                    }\n                    if (Tools.notEmpty(currentAuthForTest)){\n                        authForTest = currentAuthForTest; \/\/else just run with current from last loop;\n                    }\n                    if (Tools.isEmpty(authForTest)){\n                        authForTest = defaultAuths.getDefaultAuth();\n                    }\n                    if (uri.indexOf(\"$\")>-1){\n                        uri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n                    }\n                    fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    List<Integer> expectedCodes = new ArrayList<Integer>();\n                    String expectedCodesStr = testNode.valueOf(\"expectedCodes\");\n                    if (Tools.notEmpty(expectedCodesStr)){\n                         String[] codesArray = expectedCodesStr.split(\",\");\n                         for (String code : codesArray){\n                             expectedCodes.add(new Integer(code.trim()));\n                         }\n                    }\n                    Node responseNode = testNode.selectSingleNode(\"response\");\n                    PartsStruct expectedResponseParts = null;\n                    if (responseNode!=null){\n                        expectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n                        \/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n                    }\n                    ServiceResult serviceResult;\n                    boolean isPOST = method.equalsIgnoreCase(\"POST\");\n                    boolean isPUT =  method.equalsIgnoreCase(\"PUT\");\n                    if ( isPOST || isPUT ) {\n                        PartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\n                        if (Tools.notEmpty(parts.overrideTestID)) {\n                            testID = parts.overrideTestID;\n                        }\n                        if (isPOST){\n                            String csid = CSIDfromTestID(testNode, serviceResultsMap);\n                            if (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n                        } else if (isPUT) {\n                            uri = fromTestID(uri, testNode, serviceResultsMap);\n                        }\n                        \/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n                        \/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\n                        Map<String,String> vars = null;\n                        if (parts.varsList.size()>0){\n                            vars = parts.varsList.get(0);\n                        }\n                        serviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\n                        serviceResult.autoDelete = autoDelete;\n                        if (vars!=null) {\n                            serviceResult.addVars(vars);\n                        }\n                        results.add(serviceResult);\n                        \/\/if (isPOST){\n                            serviceResultsMap.put(testID, serviceResult);      \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n                        \/\/}\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    } else if (method.equalsIgnoreCase(\"DELETE\")){\n                        String fromTestID = testNode.valueOf(\"fromTestID\");\n                        ServiceResult pr = serviceResultsMap.get(fromTestID);\n                        if (pr!=null){\n                            serviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\n                            serviceResult.fromTestID = fromTestID;\n                            if (expectedCodes.size()>0){\n                                serviceResult.expectedCodes = expectedCodes;\n                            }\n                            results.add(serviceResult);\n                            if (serviceResult.codeInSuccessRange(serviceResult.responseCode)){  \/\/gotExpectedResult depends on serviceResult.expectedCodes.\n                                serviceResultsMap.remove(fromTestID);\n                            }\n                        } else {\n                            if (Tools.notEmpty(fromTestID)){\n                                serviceResult = new ServiceResult();\n                                serviceResult.responseCode = 0;\n                                serviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\n                                System.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n                            } else {\n                                serviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n                            }\n                            serviceResult.fromTestID = fromTestID;\n                            results.add(serviceResult);\n                        }\n                    } else if (method.equalsIgnoreCase(\"GET\")){\n                        fullURL = fromTestID(fullURL, testNode, serviceResultsMap);\n                        serviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else if (method.equalsIgnoreCase(\"LIST\")){\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                        String listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\n                        serviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else {\n                        throw new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n                    }\n                    serviceResult.testID = testID;\n                    serviceResult.fullURL = fullURL;\n                    serviceResult.auth = authForTest;\n                    serviceResult.method = method;\n                    if (expectedCodes.size()>0){\n                        serviceResult.expectedCodes = expectedCodes;\n                    }\n                    if (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\n                    if (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\n                    Node expectedLevel = testNode.selectSingleNode(\"response\/expected\");\n                    if (expectedLevel!=null){\n                        String level = expectedLevel.valueOf(\"@level\");\n                        serviceResult.payloadStrictness = level;\n                    }\n                    \/\/=====================================================\n                    \/\/  ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n                    \/\/=====================================================\n                    boolean hasError = false;\n                    String vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\n                    if (Tools.notEmpty(vError)){\n                        serviceResult.error = vError;\n                        serviceResult.failureReason = \" : VALIDATION ERROR; \";\n                        hasError = true;\n                    }\n                    if (hasError == false){\n                        hasError = ! serviceResult.gotExpectedResult();\n                    }\n                    boolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\n                    String serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\n                    String leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\n                    report.addTestResult(serviceResult);\n                    if (   (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n                        || (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full)         ){\n                        System.out.println(\"\\r\\n#---------------------#\");\n                    }\n                    System.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\n                    if (dump.payloads || (doingAuto&&hasError) ) {\n                        if (Tools.notBlank(serviceResult.requestPayload)){\n                            System.out.println(\"\\r\\n========== request payload ===============\");\n                            System.out.println(serviceResult.requestPayload);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                    if (dump.payloads || (doingAuto&&hasError)) {\n                        if (Tools.notBlank(serviceResult.result)){\n                            System.out.println(\"\\r\\n========== response payload ==============\");\n                            System.out.println(serviceResult.result);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                } catch (Throwable t) {\n                    String msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\n                    System.out.println(msg);\n                    System.out.println(Tools.getStackTrace(t));\n                    ServiceResult serviceResult = new ServiceResult();\n                    serviceResult.error = msg;\n                    serviceResult.failureReason = \" : SYSTEM ERROR; \";\n                    results.add(serviceResult);\n                }\n            }\n            if (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\n                autoDelete(serviceResultsMap, \"default\", 0);\n            }\n        }\n        \/\/=== Now spit out the HTML report file ===\n        File m = new File(controlFileName);\n        String localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\n        String reportName = localName+'-'+testGroupID+\".html\";\n        File resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\n        if (resultFile!=null) {\n            String toc = report.getTOC(reportName);\n            reportsList.add(toc);\n        }\n        \/\/================================\n        return results;\n    }","code":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\n                                          String controlFileName,\n                                          String testGroupID,\n                                          String oneTestID,\n                                          Map<String, ServiceResult> serviceResultsMap,\n                                          boolean param_autoDeletePOSTS,\n                                          Dump dump,\n                                          String protoHostPortParam,\n                                          AuthsMap defaultAuths,\n                                          List<String> reportsList,\n                                          String reportsDir)\n                                          throws Exception {\n       \n       \n       \n        List<ServiceResult> results = new ArrayList<ServiceResult>();\n        XmlReplayReport report = new XmlReplayReport(reportsDir);\n        String controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\n        org.dom4j.Document document;\n        document = getDocument(controlFile);\n        if (document==null){\n            throw new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n        }\n        String protoHostPort;\n        if (Tools.isEmpty(protoHostPortParam)){\n            protoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\n            System.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n        } else {\n            protoHostPort = protoHostPortParam;\n        }\n        if (Tools.isEmpty(protoHostPort)){\n            throw new Exception(\"XmlReplay control file must have a protoHostPort element\");\n        }\n        String authsMapINFO;\n        AuthsMap authsMap = readAuths(document);\n        if (authsMap.map.size()==0){\n            authsMap = defaultAuths;\n            authsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n        } else {\n            authsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n        }\n        report.addTestGroup(testGroupID, controlFileName);  \n        String xmlReplayHeader = \"========================================================================\"\n                          +\"\\r\\nXmlReplay running:\"\n                          +\"\\r\\n   controlFile: \"+ (new File(controlFile).getCanonicalPath())\n                          +\"\\r\\n   protoHostPort: \"+protoHostPort\n                          +\"\\r\\n   testGroup: \"+testGroupID\n                          + (Tools.notEmpty(oneTestID) ? \"\\r\\n   oneTestID: \"+oneTestID : \"\")\n                          +\"\\r\\n   AuthsMap: \"+authsMapINFO\n                          +\"\\r\\n   param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n                          +\"\\r\\n   Dump info: \"+dump\n                          +\"\\r\\n========================================================================\"\n                          +\"\\r\\n\";\n        report.addRunInfo(xmlReplayHeader);\n        System.out.println(xmlReplayHeader);\n        String autoDeletePOSTS = \"\";\n        List<Node> testgroupNodes;\n        if (Tools.notEmpty(testGroupID)){\n            testgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n        } else {\n            testgroupNodes = document.selectNodes(\"\/\/testGroup\");\n        }\n        JexlEngine jexl = new JexlEngine();  \n        XmlReplayEval evalStruct = new XmlReplayEval();\n        evalStruct.serviceResultsMap = serviceResultsMap;\n        evalStruct.jexl = jexl;\n        for (Node testgroup : testgroupNodes) {\n            XmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys()\n            evalStruct.jc = jc;\n            autoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\n            List<Node> tests;\n            if (Tools.notEmpty(oneTestID)){\n                tests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n            } else {\n                tests = testgroup.selectNodes(\"test\");\n            }\n            String authForTest = \"\";\n            int testElementIndex = -1;\n            for (Node testNode : tests) {\n                long startTime = System.currentTimeMillis();\n                try {\n                    testElementIndex++;\n                    String testID = testNode.valueOf(\"@ID\");\n                   \n                   \n                    boolean autoDelete = param_autoDeletePOSTS;\n                    String autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\n                    if (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\n                    \tautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n                    }\n                    String testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\n                    String method = testNode.valueOf(\"method\");\n                    String contentType = testNode.valueOf(\"contentType\");\n                    String uri = testNode.valueOf(\"uri\");\n                    String fullURL = Tools.glue(protoHostPort, \"\/\", uri);\n                    if (contentType == null || contentType.equals(\"\")) {\n                        contentType = XmlReplayTransport.APPLICATION_XML;\n                    }\n                    String currentAuthForTest = null;\n                    String authIDForTest = testNode.valueOf(\"@auth\");\n                    if (Tools.notEmpty(authIDForTest)){\n                        currentAuthForTest = authsMap.map.get(authIDForTest);\n                    }\n                    else {\n                        String tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\n                        if (Tools.notEmpty(tokenAuthExpression)){\n                            currentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n                        }\n                    }\n                    if (Tools.notEmpty(currentAuthForTest)){\n                        authForTest = currentAuthForTest;\n                    }\n                    if (Tools.isEmpty(authForTest)){\n                        authForTest = defaultAuths.getDefaultAuth();\n                    }\n                    if (uri.indexOf(\"$\")>-1){\n                        uri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n                    }\n                    fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    List<Integer> expectedCodes = new ArrayList<Integer>();\n                    String expectedCodesStr = testNode.valueOf(\"expectedCodes\");\n                    if (Tools.notEmpty(expectedCodesStr)){\n                         String[] codesArray = expectedCodesStr.split(\",\");\n                         for (String code : codesArray){\n                             expectedCodes.add(new Integer(code.trim()));\n                         }\n                    }\n                    Node responseNode = testNode.selectSingleNode(\"response\");\n                    PartsStruct expectedResponseParts = null;\n                    if (responseNode!=null){\n                        expectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n                       \n                    }\n                    ServiceResult serviceResult;\n                    boolean isPOST = method.equalsIgnoreCase(\"POST\");\n                    boolean isPUT =  method.equalsIgnoreCase(\"PUT\");\n                    if ( isPOST || isPUT ) {\n                        PartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\n                        if (Tools.notEmpty(parts.overrideTestID)) {\n                            testID = parts.overrideTestID;\n                        }\n                        if (isPOST){\n                            String csid = CSIDfromTestID(testNode, serviceResultsMap);\n                            if (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n                        } else if (isPUT) {\n                            uri = fromTestID(uri, testNode, serviceResultsMap);\n                        }\n                       \n                       \n                        Map<String,String> vars = null;\n                        if (parts.varsList.size()>0){\n                            vars = parts.varsList.get(0);\n                        }\n                        serviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\n                        serviceResult.autoDelete = autoDelete;\n                        if (vars!=null) {\n                            serviceResult.addVars(vars);\n                        }\n                        results.add(serviceResult);\n                       \n                            serviceResultsMap.put(testID, serviceResult);     \n                       \n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    } else if (method.equalsIgnoreCase(\"DELETE\")){\n                        String fromTestID = testNode.valueOf(\"fromTestID\");\n                        ServiceResult pr = serviceResultsMap.get(fromTestID);\n                        if (pr!=null){\n                            serviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\n                            serviceResult.fromTestID = fromTestID;\n                            if (expectedCodes.size()>0){\n                                serviceResult.expectedCodes = expectedCodes;\n                            }\n                            results.add(serviceResult);\n                            if (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \n                                serviceResultsMap.remove(fromTestID);\n                            }\n                        } else {\n                            if (Tools.notEmpty(fromTestID)){\n                                serviceResult = new ServiceResult();\n                                serviceResult.responseCode = 0;\n                                serviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\n                                System.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n                            } else {\n                                serviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n                            }\n                            serviceResult.fromTestID = fromTestID;\n                            results.add(serviceResult);\n                        }\n                    } else if (method.equalsIgnoreCase(\"GET\")){\n                        fullURL = fromTestID(fullURL, testNode, serviceResultsMap);\n                        serviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else if (method.equalsIgnoreCase(\"LIST\")){\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                        String listQueryParams = \"\";\n                        serviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else {\n                        throw new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n                    }\n                    serviceResult.testID = testID;\n                    serviceResult.fullURL = fullURL;\n                    serviceResult.auth = authForTest;\n                    serviceResult.method = method;\n                    if (expectedCodes.size()>0){\n                        serviceResult.expectedCodes = expectedCodes;\n                    }\n                    if (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\n                    if (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\n                    Node expectedLevel = testNode.selectSingleNode(\"response\/expected\");\n                    if (expectedLevel!=null){\n                        String level = expectedLevel.valueOf(\"@level\");\n                        serviceResult.payloadStrictness = level;\n                    }\n                   \n                   \n                   \n                    boolean hasError = false;\n                    String vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\n                    if (Tools.notEmpty(vError)){\n                        serviceResult.error = vError;\n                        serviceResult.failureReason = \" : VALIDATION ERROR; \";\n                        hasError = true;\n                    }\n                    if (hasError == false){\n                        hasError = ! serviceResult.gotExpectedResult();\n                    }\n                    boolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\n                    String serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\n                    String leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\n                    report.addTestResult(serviceResult);\n                    if (   (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n                        || (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full)         ){\n                        System.out.println(\"\\r\\n#---------------------#\");\n                    }\n                    System.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\n                    if (dump.payloads || (doingAuto&&hasError) ) {\n                        if (Tools.notBlank(serviceResult.requestPayload)){\n                            System.out.println(\"\\r\\n========== request payload ===============\");\n                            System.out.println(serviceResult.requestPayload);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                    if (dump.payloads || (doingAuto&&hasError)) {\n                        if (Tools.notBlank(serviceResult.result)){\n                            System.out.println(\"\\r\\n========== response payload ==============\");\n                            System.out.println(serviceResult.result);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                } catch (Throwable t) {\n                    String msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\n                    System.out.println(msg);\n                    System.out.println(Tools.getStackTrace(t));\n                    ServiceResult serviceResult = new ServiceResult();\n                    serviceResult.error = msg;\n                    serviceResult.failureReason = \" : SYSTEM ERROR; \";\n                    results.add(serviceResult);\n                }\n            }\n            if (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\n                autoDelete(serviceResultsMap, \"default\", 0);\n            }\n        }\n       \n        File m = new File(controlFileName);\n        String localName = m.getName()\n        String reportName = localName+'-'+testGroupID+\".html\";\n        File resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\n        if (resultFile!=null) {\n            String toc = report.getTOC(reportName);\n            reportsList.add(toc);\n        }\n       \n        return results;\n    }","cleancode":"public static list<serviceresult> runxmlreplayfile(string xmlreplaybasedir, string controlfilename, string testgroupid, string onetestid, map<string, serviceresult> serviceresultsmap, boolean param_autodeleteposts, dump dump, string protohostportparam, authsmap defaultauths, list<string> reportslist, string reportsdir) throws exception { list<serviceresult> results = new arraylist<serviceresult>(); xmlreplayreport report = new xmlreplayreport(reportsdir); string controlfile = tools.glue(xmlreplaybasedir, \"\/\", controlfilename); org.dom4j.document document; document = getdocument(controlfile); if (document==null){ throw new filenotfoundexception(\"xmlreplay control file (\"+controlfilename+\") not found in basedir: \"+xmlreplaybasedir+\" exiting test.\"); } string protohostport; if (tools.isempty(protohostportparam)){ protohostport = document.selectsinglenode(\"\/xmlreplay\/protohostport\").gettext().trim(); system.out.println(\"deprecated: using protohostport ('\"+protohostport+\"') from xmlreplay file ('\"+controlfile+\"'), not master.\"); } else { protohostport = protohostportparam; } if (tools.isempty(protohostport)){ throw new exception(\"xmlreplay control file must have a protohostport element\"); } string authsmapinfo; authsmap authsmap = readauths(document); if (authsmap.map.size()==0){ authsmap = defaultauths; authsmapinfo = \"using defaultauths from master file: \"+defaultauths; } else { authsmapinfo = \"using authsmap from control file: \"+authsmap; } report.addtestgroup(testgroupid, controlfilename); string xmlreplayheader = \"========================================================================\" +\"\\r\\nxmlreplay running:\" +\"\\r\\n controlfile: \"+ (new file(controlfile).getcanonicalpath()) +\"\\r\\n protohostport: \"+protohostport +\"\\r\\n testgroup: \"+testgroupid + (tools.notempty(onetestid) ? \"\\r\\n onetestid: \"+onetestid : \"\") +\"\\r\\n authsmap: \"+authsmapinfo +\"\\r\\n param_autodeleteposts: \"+param_autodeleteposts +\"\\r\\n dump info: \"+dump +\"\\r\\n========================================================================\" +\"\\r\\n\"; report.addruninfo(xmlreplayheader); system.out.println(xmlreplayheader); string autodeleteposts = \"\"; list<node> testgroupnodes; if (tools.notempty(testgroupid)){ testgroupnodes = document.selectnodes(\"\/\/testgroup[@id='\"+testgroupid+\"']\"); } else { testgroupnodes = document.selectnodes(\"\/\/testgroup\"); } jexlengine jexl = new jexlengine(); xmlreplayeval evalstruct = new xmlreplayeval(); evalstruct.serviceresultsmap = serviceresultsmap; evalstruct.jexl = jexl; for (node testgroup : testgroupnodes) { xmlreplayeval.mapcontextwkeys jc = new xmlreplayeval.mapcontextwkeys() evalstruct.jc = jc; autodeleteposts = testgroup.valueof(\"@autodeleteposts\"); list<node> tests; if (tools.notempty(onetestid)){ tests = testgroup.selectnodes(\"test[@id='\"+onetestid+\"']\"); } else { tests = testgroup.selectnodes(\"test\"); } string authfortest = \"\"; int testelementindex = -1; for (node testnode : tests) { long starttime = system.currenttimemillis(); try { testelementindex++; string testid = testnode.valueof(\"@id\"); boolean autodelete = param_autodeleteposts; string autodeletevalue = testnode.valueof(\"@autodeleteposts\"); if (autodeletevalue != null && !autodeletevalue.trim().isempty()) { autodelete = boolean.valueof(autodeletevalue).booleanvalue(); } string testidlabel = tools.notempty(testid) ? (testgroupid+'.'+testid) : (testgroupid+'.'+testelementindex); string method = testnode.valueof(\"method\"); string contenttype = testnode.valueof(\"contenttype\"); string uri = testnode.valueof(\"uri\"); string fullurl = tools.glue(protohostport, \"\/\", uri); if (contenttype == null || contenttype.equals(\"\")) { contenttype = xmlreplaytransport.application_xml; } string currentauthfortest = null; string authidfortest = testnode.valueof(\"@auth\"); if (tools.notempty(authidfortest)){ currentauthfortest = authsmap.map.get(authidfortest); } else { string tokenauthexpression = testnode.valueof(\"@tokenauth\"); if (tools.notempty(tokenauthexpression)){ currentauthfortest = \"bearer \" + evalstruct.eval(tokenauthexpression, serviceresultsmap, null, jexl, jc); } } if (tools.notempty(currentauthfortest)){ authfortest = currentauthfortest; } if (tools.isempty(authfortest)){ authfortest = defaultauths.getdefaultauth(); } if (uri.indexof(\"$\")>-1){ uri = evalstruct.eval(uri, serviceresultsmap, null, jexl, jc); } fullurl = fixupfullurl(fullurl, protohostport, uri); list<integer> expectedcodes = new arraylist<integer>(); string expectedcodesstr = testnode.valueof(\"expectedcodes\"); if (tools.notempty(expectedcodesstr)){ string[] codesarray = expectedcodesstr.split(\",\"); for (string code : codesarray){ expectedcodes.add(new integer(code.trim())); } } node responsenode = testnode.selectsinglenode(\"response\"); partsstruct expectedresponseparts = null; if (responsenode!=null){ expectedresponseparts = partsstruct.readparts(responsenode, testid, xmlreplaybasedir); } serviceresult serviceresult; boolean ispost = method.equalsignorecase(\"post\"); boolean isput = method.equalsignorecase(\"put\"); if ( ispost || isput ) { partsstruct parts = partsstruct.readparts(testnode, testid, xmlreplaybasedir); if (tools.notempty(parts.overridetestid)) { testid = parts.overridetestid; } if (ispost){ string csid = csidfromtestid(testnode, serviceresultsmap); if (tools.notempty(csid)) uri = tools.glue(uri, \"\/\", csid+\"\/items\/\"); } else if (isput) { uri = fromtestid(uri, testnode, serviceresultsmap); } map<string,string> vars = null; if (parts.varslist.size()>0){ vars = parts.varslist.get(0); } serviceresult = xmlreplaytransport.dopost_putfromxml(parts.responsefilename, vars, protohostport, uri, method, contenttype, evalstruct, authfortest, testidlabel); serviceresult.autodelete = autodelete; if (vars!=null) { serviceresult.addvars(vars); } results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); fullurl = fixupfullurl(fullurl, protohostport, uri); } else if (method.equalsignorecase(\"delete\")){ string fromtestid = testnode.valueof(\"fromtestid\"); serviceresult pr = serviceresultsmap.get(fromtestid); if (pr!=null){ serviceresult = xmlreplaytransport.dodelete(pr.deleteurl, authfortest, testidlabel, fromtestid); serviceresult.fromtestid = fromtestid; if (expectedcodes.size()>0){ serviceresult.expectedcodes = expectedcodes; } results.add(serviceresult); if (serviceresult.codeinsuccessrange(serviceresult.responsecode)){ serviceresultsmap.remove(fromtestid); } } else { if (tools.notempty(fromtestid)){ serviceresult = new serviceresult(); serviceresult.responsecode = 0; serviceresult.error = \"id not found in element fromtestid: \"+fromtestid; system.err.println(\"****\\r\\nserviceresult: \"+serviceresult.error+\". skipping test. full url: \"+fullurl); } else { serviceresult = xmlreplaytransport.dodelete(fullurl, authfortest, testid, fromtestid); } serviceresult.fromtestid = fromtestid; results.add(serviceresult); } } else if (method.equalsignorecase(\"get\")){ fullurl = fromtestid(fullurl, testnode, serviceresultsmap); serviceresult = xmlreplaytransport.doget(fullurl, authfortest, testidlabel); results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); } else if (method.equalsignorecase(\"list\")){ fullurl = fixupfullurl(fullurl, protohostport, uri); string listqueryparams = \"\"; serviceresult = xmlreplaytransport.dolist(fullurl, listqueryparams, authfortest, testidlabel); results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); } else { throw new exception(\"http method not supported by xmlreplay: \"+method); } serviceresult.testid = testid; serviceresult.fullurl = fullurl; serviceresult.auth = authfortest; serviceresult.method = method; if (expectedcodes.size()>0){ serviceresult.expectedcodes = expectedcodes; } if (tools.isempty(serviceresult.testid)) serviceresult.testid = testidlabel; if (tools.isempty(serviceresult.testgroupid)) serviceresult.testgroupid = testgroupid; node expectedlevel = testnode.selectsinglenode(\"response\/expected\"); if (expectedlevel!=null){ string level = expectedlevel.valueof(\"@level\"); serviceresult.payloadstrictness = level; } boolean haserror = false; string verror = validateresponse(serviceresult, serviceresultsmap, expectedresponseparts, evalstruct); if (tools.notempty(verror)){ serviceresult.error = verror; serviceresult.failurereason = \" : validation error; \"; haserror = true; } if (haserror == false){ haserror = ! serviceresult.gotexpectedresult(); } boolean doingauto = (dump.dumpserviceresult == serviceresult.dump_options.auto); string serviceresultrow = serviceresult.dump(dump.dumpserviceresult, haserror)+\"; time:\"+(system.currenttimemillis()-starttime); string leader = (dump.dumpserviceresult == serviceresult.dump_options.detailed) ? \"xmlreplay:\"+testidlabel+\": \": \"\"; report.addtestresult(serviceresult); if ( (dump.dumpserviceresult == serviceresult.dump_options.detailed) || (dump.dumpserviceresult == serviceresult.dump_options.full) ){ system.out.println(\"\\r\\n#---------------------#\"); } system.out.println(timestring()+\" \"+leader+serviceresultrow+\"\\r\\n\"); if (dump.payloads || (doingauto&&haserror) ) { if (tools.notblank(serviceresult.requestpayload)){ system.out.println(\"\\r\\n========== request payload ===============\"); system.out.println(serviceresult.requestpayload); system.out.println(\"==========================================\\r\\n\"); } } if (dump.payloads || (doingauto&&haserror)) { if (tools.notblank(serviceresult.result)){ system.out.println(\"\\r\\n========== response payload ==============\"); system.out.println(serviceresult.result); system.out.println(\"==========================================\\r\\n\"); } } } catch (throwable t) { string msg = \"error: xmlreplay experienced an error in a test node: \"+testnode+\" throwable: \"+t; system.out.println(msg); system.out.println(tools.getstacktrace(t)); serviceresult serviceresult = new serviceresult(); serviceresult.error = msg; serviceresult.failurereason = \" : system error; \"; results.add(serviceresult); } } if (tools.istrue(autodeleteposts) && param_autodeleteposts){ autodelete(serviceresultsmap, \"default\", 0); } } file m = new file(controlfilename); string localname = m.getname() string reportname = localname+'-'+testgroupid+\".html\"; file resultfile = report.savereport(xmlreplaybasedir, reportsdir, reportname); if (resultfile!=null) { string toc = report.gettoc(reportname); reportslist.add(toc); } return results; }","comment":"\/\/================= runxmlreplayfile ======================================================\n\/\/internally, we maintain two collections of serviceresult: \/\/ the first is the return value of this method. \/\/ the second is the serviceresultsmap, which is used for keeping track of csids created by posts, for later reference by delete, etc.\n\/\/will check full path first, then checks relative to pwd.\n\/\/controlfilename is just the short name, without the full path.\n\/\/ used for expression language expansion from uri field.\n\/\/mapcontext(); \/\/get a new jexlcontext for each test group.\n\/\/ \/\/ figure out if we will auto delete resources\n\/\/else just run with current from last loop;\n\/\/system.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedresponseparts);\n\/\/vars only make sense in two contexts: post\/put, because you are submitting another file with internal expressions, \/\/ and in <response> nodes. for get, delete, there is no payload, so all the urls with potential expressions are right there in the testnode.\n\/\/if (ispost){\n\/\/puts do not return a location, so don't add puts to serviceresultsmap.\n\/\/}\n\/\/gotexpectedresult depends on serviceresult.expectedcodes.\n\/\/todo: empty for now, later may pick up from xml control file.\n\/\/===================================================== \/\/ all validation for all requests is done here: \/\/=====================================================\n\/\/=== now spit out the html report file ===\n\/\/don't instantiate, just use file to extract file name without directory.\n\/\/================================","repo":"litchfieldhistoricalsociety\/services","code_context_2":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\nfor (Node testNode : tests) {\nlong startTime = System.currentTimeMillis();\ntry {\ntestElementIndex++;\nString testID = testNode.valueOf(\"@ID\");\n\/\/\n\/\/ Figure out if we will auto delete resources\nboolean autoDelete = param_autoDeletePOSTS;\nString autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\nif (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\nautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n}\nString testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\nString method = testNode.valueOf(\"method\");\nString contentType = testNode.valueOf(\"contentType\");\nString uri = testNode.valueOf(\"uri\");\nString fullURL = Tools.glue(protoHostPort, \"\/\", uri);\nif (contentType == null || contentType.equals(\"\")) {\ncontentType = XmlReplayTransport.APPLICATION_XML;\n}\nString currentAuthForTest = null;\nString authIDForTest = testNode.valueOf(\"@auth\");\nif (Tools.notEmpty(authIDForTest)){\ncurrentAuthForTest = authsMap.map.get(authIDForTest);\n}\nelse {\nString tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\nif (Tools.notEmpty(tokenAuthExpression)){\ncurrentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n}\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n}\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\nboolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\nString serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\nString leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\nreport.addTestResult(serviceResult);\nif ( (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n|| (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full) ){\nSystem.out.println(\"\\r\\n#---------------------#\");\n}\nSystem.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\nif (dump.payloads || (doingAuto&&hasError) ) {\nif (Tools.notBlank(serviceResult.requestPayload)){\nSystem.out.println(\"\\r\\n========== request payload ===============\");\nSystem.out.println(serviceResult.requestPayload);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\nif (dump.payloads || (doingAuto&&hasError)) {\nif (Tools.notBlank(serviceResult.result)){\nSystem.out.println(\"\\r\\n========== response payload ==============\");\nSystem.out.println(serviceResult.result);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\n} catch (Throwable t) {\nString msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\nSystem.out.println(msg);\nSystem.out.println(Tools.getStackTrace(t));\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\n\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\n\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\n\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\n\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\n\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\n\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\n\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\n\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\n\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\n\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\n\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\n\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\n\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================","code_context_10":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\nfor (Node testNode : tests) {\nlong startTime = System.currentTimeMillis();\ntry {\ntestElementIndex++;\nString testID = testNode.valueOf(\"@ID\");\n\/\/\n\/\/ Figure out if we will auto delete resources\nboolean autoDelete = param_autoDeletePOSTS;\nString autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\nif (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\nautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n}\nString testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\nString method = testNode.valueOf(\"method\");\nString contentType = testNode.valueOf(\"contentType\");\nString uri = testNode.valueOf(\"uri\");\nString fullURL = Tools.glue(protoHostPort, \"\/\", uri);\nif (contentType == null || contentType.equals(\"\")) {\ncontentType = XmlReplayTransport.APPLICATION_XML;\n}\nString currentAuthForTest = null;\nString authIDForTest = testNode.valueOf(\"@auth\");\nif (Tools.notEmpty(authIDForTest)){\ncurrentAuthForTest = authsMap.map.get(authIDForTest);\n}\nelse {\nString tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\nif (Tools.notEmpty(tokenAuthExpression)){\ncurrentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n}\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n}\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\nboolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\nString serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\nString leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\nreport.addTestResult(serviceResult);\nif ( (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n|| (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full) ){\nSystem.out.println(\"\\r\\n#---------------------#\");\n}\nSystem.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\nif (dump.payloads || (doingAuto&&hasError) ) {\nif (Tools.notBlank(serviceResult.requestPayload)){\nSystem.out.println(\"\\r\\n========== request payload ===============\");\nSystem.out.println(serviceResult.requestPayload);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\nif (dump.payloads || (doingAuto&&hasError)) {\nif (Tools.notBlank(serviceResult.result)){\nSystem.out.println(\"\\r\\n========== response payload ==============\");\nSystem.out.println(serviceResult.result);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\n} catch (Throwable t) {\nString msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\nSystem.out.println(msg);\nSystem.out.println(Tools.getStackTrace(t));\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\n\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\n\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\n\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\n\nif (Tools.notEmpty(authIDForTest)){\ncurrentAuthForTest = authsMap.map.get(authIDForTest);\n}\nelse {\nString tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\nif (Tools.notEmpty(tokenAuthExpression)){\ncurrentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n}\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\n\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\n\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\n\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\n\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\n\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\n\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){","code_context_20":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\nfor (Node testNode : tests) {\nlong startTime = System.currentTimeMillis();\ntry {\ntestElementIndex++;\nString testID = testNode.valueOf(\"@ID\");\n\/\/\n\/\/ Figure out if we will auto delete resources\nboolean autoDelete = param_autoDeletePOSTS;\nString autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\nif (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\nautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n}\nString testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\nString method = testNode.valueOf(\"method\");\nString contentType = testNode.valueOf(\"contentType\");\nString uri = testNode.valueOf(\"uri\");\nString fullURL = Tools.glue(protoHostPort, \"\/\", uri);\nif (contentType == null || contentType.equals(\"\")) {\ncontentType = XmlReplayTransport.APPLICATION_XML;\n}\nString currentAuthForTest = null;\nString authIDForTest = testNode.valueOf(\"@auth\");\nif (Tools.notEmpty(authIDForTest)){\ncurrentAuthForTest = authsMap.map.get(authIDForTest);\n}\nelse {\nString tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\nif (Tools.notEmpty(tokenAuthExpression)){\ncurrentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n}\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n}\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\nboolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\nString serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\nString leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\nreport.addTestResult(serviceResult);\nif ( (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n|| (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full) ){\nSystem.out.println(\"\\r\\n#---------------------#\");\n}\nSystem.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\nif (dump.payloads || (doingAuto&&hasError) ) {\nif (Tools.notBlank(serviceResult.requestPayload)){\nSystem.out.println(\"\\r\\n========== request payload ===============\");\nSystem.out.println(serviceResult.requestPayload);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\nif (dump.payloads || (doingAuto&&hasError)) {\nif (Tools.notBlank(serviceResult.result)){\nSystem.out.println(\"\\r\\n========== response payload ==============\");\nSystem.out.println(serviceResult.result);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\n} catch (Throwable t) {\nString msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\nSystem.out.println(msg);\nSystem.out.println(Tools.getStackTrace(t));\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\npublic static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\n\npublic static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\nAuthsMap authsMap = readAuths(document);\nif (authsMap.map.size()==0){\nauthsMap = defaultAuths;\nauthsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n} else {\nauthsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n}\nreport.addTestGroup(testGroupID, controlFileName); \/\/controlFileName is just the short name, without the full path.\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\n\nString xmlReplayHeader = \"========================================================================\"\n+\"\\r\\nXmlReplay running:\"\n+\"\\r\\n controlFile: \"+ (new File(controlFile).getCanonicalPath())\n+\"\\r\\n protoHostPort: \"+protoHostPort\n+\"\\r\\n testGroup: \"+testGroupID\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\nfor (Node testNode : tests) {\nlong startTime = System.currentTimeMillis();\ntry {\ntestElementIndex++;\nString testID = testNode.valueOf(\"@ID\");\n\n+ (Tools.notEmpty(oneTestID) ? \"\\r\\n oneTestID: \"+oneTestID : \"\")\n+\"\\r\\n AuthsMap: \"+authsMapINFO\n+\"\\r\\n param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n+\"\\r\\n Dump info: \"+dump\n+\"\\r\\n========================================================================\"\n+\"\\r\\n\";\nreport.addRunInfo(xmlReplayHeader);\nSystem.out.println(xmlReplayHeader);\nString autoDeletePOSTS = \"\";\nList<Node> testgroupNodes;\nif (Tools.notEmpty(testGroupID)){\ntestgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n} else {\ntestgroupNodes = document.selectNodes(\"\/\/testGroup\");\n}\nJexlEngine jexl = new JexlEngine(); \/\/ Used for expression language expansion from uri field.\nXmlReplayEval evalStruct = new XmlReplayEval();\nevalStruct.serviceResultsMap = serviceResultsMap;\nevalStruct.jexl = jexl;\nfor (Node testgroup : testgroupNodes) {\nXmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext(); \/\/Get a new JexlContext for each test group.\nevalStruct.jc = jc;\nautoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\nList<Node> tests;\nif (Tools.notEmpty(oneTestID)){\ntests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n} else {\ntests = testgroup.selectNodes(\"test\");\n}\nString authForTest = \"\";\nint testElementIndex = -1;\nfor (Node testNode : tests) {\nlong startTime = System.currentTimeMillis();\ntry {\ntestElementIndex++;\nString testID = testNode.valueOf(\"@ID\");\n\/\/\n\/\/ Figure out if we will auto delete resources\nboolean autoDelete = param_autoDeletePOSTS;\nString autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\nif (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\n\npublic static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\nString controlFileName,\nString testGroupID,\nString oneTestID,\nMap<String, ServiceResult> serviceResultsMap,\nboolean param_autoDeletePOSTS,\nDump dump,\nString protoHostPortParam,\nAuthsMap defaultAuths,\nList<String> reportsList,\nString reportsDir)\nthrows Exception {\n\/\/Internally, we maintain two collections of ServiceResult:\n\/\/ the first is the return value of this method.\n\/\/ the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\nList<ServiceResult> results = new ArrayList<ServiceResult>();\nXmlReplayReport report = new XmlReplayReport(reportsDir);\nString controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\norg.dom4j.Document document;\ndocument = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\nif (document==null){\nthrow new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n}\nString protoHostPort;\nif (Tools.isEmpty(protoHostPortParam)){\nprotoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\nSystem.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n} else {\nprotoHostPort = protoHostPortParam;\n}\nif (Tools.isEmpty(protoHostPort)){\nthrow new Exception(\"XmlReplay control file must have a protoHostPort element\");\n}\nString authsMapINFO;\n\nString testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\nString method = testNode.valueOf(\"method\");\nString contentType = testNode.valueOf(\"contentType\");\nString uri = testNode.valueOf(\"uri\");\nString fullURL = Tools.glue(protoHostPort, \"\/\", uri);\nif (contentType == null || contentType.equals(\"\")) {\ncontentType = XmlReplayTransport.APPLICATION_XML;\n}\nString currentAuthForTest = null;\nString authIDForTest = testNode.valueOf(\"@auth\");\nif (Tools.notEmpty(authIDForTest)){\ncurrentAuthForTest = authsMap.map.get(authIDForTest);\n}\nelse {\nString tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\nif (Tools.notEmpty(tokenAuthExpression)){\ncurrentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n}\n}\nif (Tools.notEmpty(currentAuthForTest)){\nauthForTest = currentAuthForTest; \/\/else just run with current from last loop;\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\n}\nif (Tools.isEmpty(authForTest)){\nauthForTest = defaultAuths.getDefaultAuth();\n}\nif (uri.indexOf(\"$\")>-1){\nuri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nList<Integer> expectedCodes = new ArrayList<Integer>();\nString expectedCodesStr = testNode.valueOf(\"expectedCodes\");\nif (Tools.notEmpty(expectedCodesStr)){\nString[] codesArray = expectedCodesStr.split(\",\");\nfor (String code : codesArray){\nexpectedCodes.add(new Integer(code.trim()));\n}\n}\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n\nNode responseNode = testNode.selectSingleNode(\"response\");\nPartsStruct expectedResponseParts = null;\nif (responseNode!=null){\nexpectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n\/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n}\nServiceResult serviceResult;\nboolean isPOST = method.equalsIgnoreCase(\"POST\");\nboolean isPUT = method.equalsIgnoreCase(\"PUT\");\nif ( isPOST || isPUT ) {\nPartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\nif (Tools.notEmpty(parts.overrideTestID)) {\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\n\ntestID = parts.overrideTestID;\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\n\n}\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\n\nif (isPOST){\nString csid = CSIDfromTestID(testNode, serviceResultsMap);\nif (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n} else if (isPUT) {\nuri = fromTestID(uri, testNode, serviceResultsMap);\n}\n\/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n\/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\nMap<String,String> vars = null;\nif (parts.varsList.size()>0){\nvars = parts.varsList.get(0);\n}\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n\nserviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\nserviceResult.autoDelete = autoDelete;\nif (vars!=null) {\nserviceResult.addVars(vars);\n}\nresults.add(serviceResult);\n\/\/if (isPOST){\nserviceResultsMap.put(testID, serviceResult); \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n\/\/}\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\n} else if (method.equalsIgnoreCase(\"DELETE\")){\nString fromTestID = testNode.valueOf(\"fromTestID\");\nServiceResult pr = serviceResultsMap.get(fromTestID);\nif (pr!=null){\nserviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\nserviceResult.fromTestID = fromTestID;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nresults.add(serviceResult);\nif (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \/\/gotExpectedResult depends on serviceResult.expectedCodes.\nserviceResultsMap.remove(fromTestID);\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n}\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\n\n}\n} else {\nif (Tools.notEmpty(fromTestID)){\nserviceResult = new ServiceResult();\nserviceResult.responseCode = 0;\nserviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\nSystem.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n} else {\nserviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n}\nserviceResult.fromTestID = fromTestID;\nresults.add(serviceResult);\n}\n} else if (method.equalsIgnoreCase(\"GET\")){\nfullURL = fromTestID(fullURL, testNode, serviceResultsMap);\nserviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else if (method.equalsIgnoreCase(\"LIST\")){\nfullURL = fixupFullURL(fullURL, protoHostPort, uri);\nString listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\nboolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\nString serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\nString leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\nreport.addTestResult(serviceResult);\nif ( (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n|| (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full) ){\nSystem.out.println(\"\\r\\n#---------------------#\");\n}\nSystem.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\nif (dump.payloads || (doingAuto&&hasError) ) {\n\nif (Tools.notBlank(serviceResult.result)){\nSystem.out.println(\"\\r\\n========== response payload ==============\");\nSystem.out.println(serviceResult.result);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\n} catch (Throwable t) {\nString msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\nSystem.out.println(msg);\nSystem.out.println(Tools.getStackTrace(t));\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\nSystem.out.println(serviceResult.result);\nSystem.out.println(\"==========================================\\r\\n\");\n}\n}\n} catch (Throwable t) {\nString msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\nSystem.out.println(msg);\nSystem.out.println(Tools.getStackTrace(t));\nServiceResult serviceResult = new ServiceResult();\nserviceResult.error = msg;\nserviceResult.failureReason = \" : SYSTEM ERROR; \";\nresults.add(serviceResult);\n}\n}\nif (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\nautoDelete(serviceResultsMap, \"default\", 0);\n}\n}\n\/\/=== Now spit out the HTML report file ===\nFile m = new File(controlFileName);\nString localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\nString reportName = localName+'-'+testGroupID+\".html\";\nFile resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\nif (resultFile!=null) {\nString toc = report.getTOC(reportName);\nreportsList.add(toc);\n}\n\/\/================================\nreturn results;\n}\n\nserviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\nresults.add(serviceResult);\nserviceResultsMap.put(testID, serviceResult);\n} else {\nthrow new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n}\nserviceResult.testID = testID;\nserviceResult.fullURL = fullURL;\nserviceResult.auth = authForTest;\nserviceResult.method = method;\nif (expectedCodes.size()>0){\nserviceResult.expectedCodes = expectedCodes;\n}\nif (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\nif (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\nNode expectedLevel = testNode.selectSingleNode(\"response\/expected\");\nif (expectedLevel!=null){\nString level = expectedLevel.valueOf(\"@level\");\nserviceResult.payloadStrictness = level;\n}\n\/\/=====================================================\n\/\/ ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n\/\/=====================================================\nboolean hasError = false;\nString vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\nif (Tools.notEmpty(vError)){\nserviceResult.error = vError;\nserviceResult.failureReason = \" : VALIDATION ERROR; \";\nhasError = true;\n}\nif (hasError == false){\nhasError = ! serviceResult.gotExpectedResult();\n}\nboolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\nString serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\nString leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\nreport.addTestResult(serviceResult);\nif ( (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n|| (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full) ){\nSystem.out.println(\"\\r\\n#---------------------#\");\n}","label":[1,0,0,0]}
{"id":25235,"original_code":"@Test\n    public void positionalConstructors() throws Exception {\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\n        String cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\n        assertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n        \/\/ These go through a different code path:\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        \/* TODO casting arrays is not yet supported:\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n        *\/\n        \/* TODO tuple assignment is not yet supported:\n        assertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n        *\/\n    }","code":"@Test\n    public void positionalConstructors() throws Exception {\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\n        String cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\n        assertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n       \n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n       \n       \n    }","cleancode":"@test public void positionalconstructors() throws exception { assertrejected(new proxywhitelist(), \"new java.lang.boolean java.lang.string\", \"['true'] as boolean\"); assertevaluate(new staticwhitelist(\"new java.lang.boolean java.lang.string\"), true, \"['true'] as boolean\"); string cc = \"staticmethod org.kohsuke.groovy.sandbox.impl.checker checkedcast java.lang.class java.lang.object boolean boolean boolean\"; assertrejected(new staticwhitelist(cc), \"new java.lang.boolean java.lang.string\", \"boolean x = ['true']; x\"); assertevaluate(new staticwhitelist(cc, \"new java.lang.boolean java.lang.string\"), true, \"boolean x = ['true']; x\"); assertrejected(new proxywhitelist(), \"new java.util.treemap java.util.map\", \"[k: 1] as treemap\"); assertevaluate(new staticwhitelist(\"new java.util.treemap java.util.map\"), collections.singletonmap(\"k\", 1), \"[k: 1] as treemap\"); assertrejected(new staticwhitelist(cc), \"new java.util.treemap java.util.map\", \"treemap x = [k: 1]; x\"); assertevaluate(new staticwhitelist(cc, \"new java.util.treemap java.util.map\"), collections.singletonmap(\"k\", 1), \"treemap x = [k: 1]; x\"); assertevaluate(new proxywhitelist(), arrays.aslist(1), \"[1] as linkedlist\"); assertevaluate(new proxywhitelist(), arrays.aslist(\"v\"), \"['v'] as linkedlist\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(1), \"linkedlist x = [1]; x\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"linkedlist x = ['v']; x\"); assertevaluate(new proxywhitelist(), arrays.aslist(1), \"int[] a = [1]; a as linkedlist\"); assertevaluate(new proxywhitelist(), arrays.aslist(\"v\"), \"string[] a = ['v']; a as linkedlist\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"string[] a = ['v']; linkedlist x = a; x\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"string[] a = ['v']; linkedlist x = a; x\"); }","comment":"\/\/ @issue(\"security-580\")\n\/\/ these go through a different code path:\n\/* todo casting arrays is not yet supported: assertrejected(new staticwhitelist(cc), \"new java.lang.boolean java.lang.string\", \"string[] a = ['true']; boolean x = a; x\"); assertevaluate(new staticwhitelist(cc, \"new java.lang.boolean java.lang.string\"), true, \"string[] a = ['true']; boolean x = a; x\"); assertrejected(new proxywhitelist(), \"new java.lang.boolean java.lang.string\", \"string[] a = ['true']; a as boolean\"); assertevaluate(new staticwhitelist(\"new java.lang.boolean java.lang.string\"), true, \"string[] a = ['true']; a as boolean\"); *\/\n\/* todo tuple assignment is not yet supported: assertrejected(new proxywhitelist(), \"new java.util.linkedlist java.util.collection\", \"string[] a = ['v']; def (linkedlist x, int y) = [a, 1]; x\"); assertevaluate(new staticwhitelist(\"new java.util.linkedlist java.util.collection\"), arrays.aslist(\"v\"), \"string[] a = ['v']; def (linkedlist x, int y) = [a, 1]; x\"); *\/","repo":"maheshp\/gocd-groovy-dsl-config-plugin","code_context_2":"@Test\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\n\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}","code_context_10":"@Test\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\n\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}","code_context_20":"@Test\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\n@Test\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\n@Test\npublic void positionalConstructors() throws Exception {\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\nString cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}\n\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\nassertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\nassertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\nassertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n\/\/ These go through a different code path:\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\nassertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\nassertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n\/* TODO casting arrays is not yet supported:\nassertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\nassertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\nassertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\nassertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n*\/\n\/* TODO tuple assignment is not yet supported:\nassertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\nassertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n*\/\n}","label":[1,1,0,0]}
{"id":685,"original_code":"public static final int testElementParsing (\n            final PrintStream out, final BufferedReader in, final String ... args)\n    {\n        final String    ans=getval(out, in, \"use owner document y\/[n]\/q\");\n        if (isQuit(ans))\n            return 0;\n        Document    owner=null;\n        if ((ans != null) && (ans.length() > 0) && ('y' == Character.toLowerCase(ans.charAt(0))))\n        {\n            try\n            {\n                owner = DOMUtils.createDefaultDocument();\n            }\n            catch(ParserConfigurationException e)\n            {\n                System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n            }\n        }\n        final int    nErr=testElementParsing(out, in, owner, args);\n        if (owner != null)\n        {\n            \/\/ TODO show resulting document\n        }\n        return nErr;\n    }","code":"public static final int testElementParsing (\n            final PrintStream out, final BufferedReader in, final String ... args)\n    {\n        final String    ans=getval(out, in, \"use owner document y\/[n]\/q\");\n        if (isQuit(ans))\n            return 0;\n        Document    owner=null;\n        if ((ans != null) && (ans.length() > 0) && ('y' == Character.toLowerCase(ans.charAt(0))))\n        {\n            try\n            {\n                owner = DOMUtils.createDefaultDocument();\n            }\n            catch(ParserConfigurationException e)\n            {\n                System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n            }\n        }\n        final int    nErr=testElementParsing(out, in, owner, args);\n        if (owner != null)\n        {\n           \n        }\n        return nErr;\n    }","cleancode":"public static final int testelementparsing ( final printstream out, final bufferedreader in, final string ... args) { final string ans=getval(out, in, \"use owner document y\/[n]\/q\"); if (isquit(ans)) return 0; document owner=null; if ((ans != null) && (ans.length() > 0) && ('y' == character.tolowercase(ans.charat(0)))) { try { owner = domutils.createdefaultdocument(); } catch(parserconfigurationexception e) { system.err.println(e.getclass().getname() + \": \" + e.getmessage()); } } final int nerr=testelementparsing(out, in, owner, args); if (owner != null) { } return nerr; }","comment":"\/\/ todo show resulting document","repo":"lgoldstein\/communitychest","code_context_2":"if (owner != null)\n{\n\/\/ TODO show resulting document\n}\nreturn nErr;","code_context_10":"owner = DOMUtils.createDefaultDocument();\n}\ncatch(ParserConfigurationException e)\n{\nSystem.err.println(e.getClass().getName() + \": \" + e.getMessage());\n}\n}\nfinal int nErr=testElementParsing(out, in, owner, args);\nif (owner != null)\n{\n\/\/ TODO show resulting document\n}\nreturn nErr;\n}","code_context_20":"final PrintStream out, final BufferedReader in, final String ... args)\n{\nfinal String ans=getval(out, in, \"use owner document y\/[n]\/q\");\nif (isQuit(ans))\nreturn 0;\nDocument owner=null;\nif ((ans != null) && (ans.length() > 0) && ('y' == Character.toLowerCase(ans.charAt(0))))\n{\ntry\n{\nowner = DOMUtils.createDefaultDocument();\n}\ncatch(ParserConfigurationException e)\n{\nSystem.err.println(e.getClass().getName() + \": \" + e.getMessage());\n}\n}\nfinal int nErr=testElementParsing(out, in, owner, args);\nif (owner != null)\n{\n\/\/ TODO show resulting document\n}\nreturn nErr;\n}","label":[0,1,0,0]}
{"id":33498,"original_code":"@SuppressWarnings(\"fallthrough\")\n    @Override\n    public Token<CppTokenId> nextToken() {\n        while (true) {\n            \/\/ special handling for escaped lines\n            if (lastTokenEndedByEscapedLine > 0) {\n                int c = read(false);\n                lastTokenEndedByEscapedLine--;\n                assert c == '\\\\' : \"there must be \\\\\";\n                c = read(false);\n                assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\n                if (c == '\\r') {\n                    lastTokenEndedByEscapedLine--;\n                    if (input.consumeNewline()) {\n                        lastTokenEndedByEscapedLine--;\n                    }\n                    return token(CppTokenId.ESCAPED_LINE);\n                } else {\n                    lastTokenEndedByEscapedLine--;\n                    return token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n                }\n            } else {\n                int c = read(true);\n                \/\/ if read of the first char caused skipping escaped line\n                \/\/ do we need to backup and create escaped lines first?\n                switch (c) {\n                    case '\"': {\n                        Token<CppTokenId> out = finishDblQuote();\n                        assert out != null : \"not handled dobule quote\";\n                        return out;\n                    }\n                    case '\\'': {\/\/ char literal\n                        Token<CppTokenId> out = finishSingleQuote();\n                        assert out != null : \"not handled single quote\";\n                        return out;\n                    }\n                    case '#': {\n                        Token<CppTokenId> out = finishSharp();\n                        assert out != null : \"not handled #\";\n                        return out;\n                    }\n                    case '\/':\n                        switch (read(true)) {\n                            case '\/': \/\/ in single-line or doxygen comment\n                            {\n                                Token<CppTokenId> out = finishLineComment(true);\n                                assert out != null : \"not handled \/\/\";\n                                return out;\n                            }\n                            case '=': \/\/ found \/=\n                                return token(CppTokenId.SLASHEQ);\n                            case '*': \/\/ in multi-line or doxygen comment\n                            {\n                                Token<CppTokenId> out = finishBlockComment(true);\n                                assert out != null : \"not handled \/*\";\n                                return out;\n                            }\n                        } \/\/ end of switch()\n                        backup(1);\n                        return token(CppTokenId.SLASH);\n                    case '=':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.EQEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.EQ);\n                    case '>':\n                        switch (read(true)) {\n                            case '>': \/\/ >>\n                                if (read(true) == '=') {\n                                    return token(CppTokenId.GTGTEQ);\n                                }\n                                backup(1);\n                                return token(CppTokenId.GTGT);\n                            case '=': \/\/ >=\n                                return token(CppTokenId.GTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.GT);\n                    case '<': {\n                        Token<CppTokenId> out = finishLT();\n                        assert out != null : \"not handled '<'\";\n                        return out;\n                    }\n                    case '+':\n                        switch (read(true)) {\n                            case '+':\n                                return token(CppTokenId.PLUSPLUS);\n                            case '=':\n                                return token(CppTokenId.PLUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.PLUS);\n                    case '-':\n                        switch (read(true)) {\n                            case '-':\n                                return token(CppTokenId.MINUSMINUS);\n                            case '>':\n                                if (read(true) == '*') {\n                                    return token(CppTokenId.ARROWMBR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.ARROW);\n                            case '=':\n                                return token(CppTokenId.MINUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.MINUS);\n                    case '*':\n                        switch (read(true)) {\n                            case '\/': \/\/ invalid comment end - *\/ or int*\/* *\/\n                                if (read(true) == '*') {\n                                    backup(2);\n                                    return token(CppTokenId.STAR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.INVALID_COMMENT_END);\n                            case '=':\n                                return token(CppTokenId.STAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.STAR);\n                    case '|':\n                        switch (read(true)) {\n                            case '|':\n                                return token(CppTokenId.BARBAR);\n                            case '=':\n                                return token(CppTokenId.BAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.BAR);\n                    case '&':\n                        switch (read(true)) {\n                            case '&':\n                                return token(CppTokenId.AMPAMP);\n                            case '=':\n                                return token(CppTokenId.AMPEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.AMP);\n                    case '%': {\n                        Token<CppTokenId> out = finishPercent();\n                        assert out != null : \"not handled %\";\n                        return out;\n                    }\n                    case '^':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.CARETEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.CARET);\n                    case '!':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.NOTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.NOT);\n                    case '.':\n                        if ((c = read(true)) == '.') {\n                            if (read(true) == '.') { \/\/ ellipsis ...\n                                return token(CppTokenId.ELLIPSIS);\n                            } else {\n                                input.backup(2);\n                            }\n                        } else if ('0' <= c && c <= '9') { \/\/ float literal\n                            return finishNumberLiteral(read(true), true);\n                        } else if (c == '*') {\n                            return token(CppTokenId.DOTMBR);\n                        } else {\n                            backup(1);\n                        }\n                        return token(CppTokenId.DOT);\n                    case ':':\n                        if (read(true) == ':') {\n                            return token(CppTokenId.SCOPE);\n                        }\n                        backup(1);\n                        return token(CppTokenId.COLON);\n                    case '~':\n                        return token(CppTokenId.TILDE);\n                    case ',':\n                        return token(CppTokenId.COMMA);\n                    case ';':\n                        return token(CppTokenId.SEMICOLON);\n                    case '?':\n                        return token(CppTokenId.QUESTION);\n                    case '(':\n                        return token(CppTokenId.LPAREN);\n                    case ')':\n                        return token(CppTokenId.RPAREN);\n                    case '[':\n                        return token(CppTokenId.LBRACKET);\n                    case ']':\n                        return token(CppTokenId.RBRACKET);\n                    case '{':\n                        return token(CppTokenId.LBRACE);\n                    case '}':\n                        return token(CppTokenId.RBRACE);\n                    case '`':\n                        return token(CppTokenId.GRAVE_ACCENT);\n                    case '@':\n                        return token(CppTokenId.AT);\n                    case '0': \/\/ in a number literal\n                        c = read(true);\n                        if (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\n                                c == 'b' || c == 'B' ) { \/\/ in bianry literal\n                            boolean inFraction = false;\n                            while (true) {\n                                switch (read(true)) {\n                                    case '0':\n                                    case '1':\n                                    case '2':\n                                    case '3':\n                                    case '4':\n                                    case '5':\n                                    case '6':\n                                    case '7':\n                                    case '8':\n                                    case '9':\n                                    case 'a':\n                                    case 'b':\n                                    case 'c':\n                                    case 'd':\n                                    case 'e':\n                                    case 'f':\n                                    case 'A':\n                                    case 'B':\n                                    case 'C':\n                                    case 'D':\n                                    case 'E':\n                                    case 'F':\n                                        break;\n                                    case '.': \/\/ hex float literal\n                                        if (!inFraction) {\n                                            inFraction = true;\n                                        } else { \/\/ two dots in the float literal\n                                            return token(CppTokenId.FLOAT_LITERAL_INVALID);\n                                        }\n                                        break;\n                                    case 'l':\n                                    case 'L': \/\/ 0x1234l or 0x1234L\n                                        return finishLongLiteral(read(true));\n                                    case 'p':\n                                    case 'P': \/\/ binary exponent\n                                        return finishFloatExponent();\n                                    case 'u':\n                                    case 'U':\n                                        return finishUnsignedLiteral(read(true));\n                                    default:\n                                        backup(1);\n                                        \/\/ if float then before mandatory binary exponent => invalid\n                                        return token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n                                                : CppTokenId.INT_LITERAL);\n                                }\n                            } \/\/ end of while(true)\n                        }\n                        return finishNumberLiteral(c, false);\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        return finishNumberLiteral(read(true), false);\n                    case '\\\\':\n                        return token(CppTokenId.BACK_SLASH);\n                    case '\\r':\n                        consumeNewline();\n                        return token(CppTokenId.NEW_LINE);\n                    case '\\n':\n                        return token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n                    \/\/ All Character.isWhitespace(c) below 0x80 follow\n                    \/\/ ['\\t' - '\\f'] and [0x1c - ' ']\n                    case '\\t':\n                    case 0x0b:\n                    case '\\f':\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n                        return finishWhitespace();\n                    case ' ':\n                        c = read(true);\n                        if (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\n                            backup(1);\n                            return token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n                        }\n                        return finishWhitespace();\n                    case EOF:\n                        if (isTokenSplittedByEscapedLine()) {\n                            backup(1);\n                            assert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\n                            break;\n                        }\n                        return null;\n                    case '$':\n                        \/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/                        return token(CppTokenId.DOLLAR);\n                    default:\n                        c = translateSurrogates(c);\n                        if (CndLexerUtilities.isCppIdentifierStart(c)) {\n                            if (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\n                                int next = read(true);\n                                boolean raw_string = (c == 'R');\n                                if (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n                                    \/\/ uR, UR or LR\n                                    raw_string = true;\n                                    next = read(true);\n                                } else if (next == '8' && c == 'u') {\n                                    \/\/ u8\n                                    next = read(true);\n                                    if (next == 'R') {\n                                        \/\/ u8R\n                                        raw_string = true;\n                                        next = read(true);\n                                    }\n                                }\n                                if (next == '\"') {\n                                    \/\/ string with L\/U\/u\/R prefixes\n                                    Token<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\n                                    assert out != null : \"not handled dobule quote\";\n                                    return out;\n                                } else if (next == '\\'' && !raw_string) {\n                                    \/\/ char with L or U\/u prefix\n                                    Token<CppTokenId> out = finishSingleQuote();\n                                    assert out != null : \"not handled single quote\";\n                                    return out;\n                                } else {\n                                    backup(1);\n                                }\n                            }\n                            if (c == 'E') {\n                                if(isExecSQL(c)) {\n                                    Token<CppTokenId> out = finishExecSQL();\n                                    assert out != null : \"not handled exec sql\";\n                                    return out;\n                                }\n                            }\n                            return keywordOrIdentifier(c);\n                        }\n                        if (Character.isWhitespace(c)) {\n                            return finishWhitespace();\n                        }\n                        \/\/ Invalid char\n                        return token(CppTokenId.ERROR);\n                }\n            } \/\/ end of switch (c)\n        } \/\/ end of while(true)\n    }","code":"@SuppressWarnings(\"fallthrough\")\n    @Override\n    public Token<CppTokenId> nextToken() {\n        while (true) {\n           \n            if (lastTokenEndedByEscapedLine > 0) {\n                int c = read(false);\n                lastTokenEndedByEscapedLine--;\n                assert c == '\\\\' : \"there must be \\\\\";\n                c = read(false);\n                assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\n                if (c == '\\r') {\n                    lastTokenEndedByEscapedLine--;\n                    if (input.consumeNewline()) {\n                        lastTokenEndedByEscapedLine--;\n                    }\n                    return token(CppTokenId.ESCAPED_LINE);\n                } else {\n                    lastTokenEndedByEscapedLine--;\n                    return token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE);\n                }\n            } else {\n                int c = read(true);\n               \n               \n                switch (c) {\n                    case '\"': {\n                        Token<CppTokenId> out = finishDblQuote();\n                        assert out != null : \"not handled dobule quote\";\n                        return out;\n                    }\n                    case '\\'': \n                        Token<CppTokenId> out = finishSingleQuote();\n                        assert out != null : \"not handled single quote\";\n                        return out;\n                    }\n                    case '#': {\n                        Token<CppTokenId> out = finishSharp();\n                        assert out != null : \"not handled #\";\n                        return out;\n                    }\n                    case '\/':\n                        switch (read(true)) {\n                            case '\/':\n                            {\n                                Token<CppTokenId> out = finishLineComment(true);\n                                assert out != null : \"not handled \/\/\";\n                                return out;\n                            }\n                            case '=':\n                                return token(CppTokenId.SLASHEQ);\n                            case '*':\n                            {\n                                Token<CppTokenId> out = finishBlockComment(true);\n                                assert out != null : \"not handled \/*\";\n                                return out;\n                            }\n                        }\n                        backup(1);\n                        return token(CppTokenId.SLASH);\n                    case '=':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.EQEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.EQ);\n                    case '>':\n                        switch (read(true)) {\n                            case '>':\n                                if (read(true) == '=') {\n                                    return token(CppTokenId.GTGTEQ);\n                                }\n                                backup(1);\n                                return token(CppTokenId.GTGT);\n                            case '=':\n                                return token(CppTokenId.GTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.GT);\n                    case '<': {\n                        Token<CppTokenId> out = finishLT();\n                        assert out != null : \"not handled '<'\";\n                        return out;\n                    }\n                    case '+':\n                        switch (read(true)) {\n                            case '+':\n                                return token(CppTokenId.PLUSPLUS);\n                            case '=':\n                                return token(CppTokenId.PLUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.PLUS);\n                    case '-':\n                        switch (read(true)) {\n                            case '-':\n                                return token(CppTokenId.MINUSMINUS);\n                            case '>':\n                                if (read(true) == '*') {\n                                    return token(CppTokenId.ARROWMBR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.ARROW);\n                            case '=':\n                                return token(CppTokenId.MINUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.MINUS);\n                    case '*':\n                        switch (read(true)) {\n                            case '\/':\n                                if (read(true) == '*') {\n                                    backup(2);\n                                    return token(CppTokenId.STAR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.INVALID_COMMENT_END);\n                            case '=':\n                                return token(CppTokenId.STAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.STAR);\n                    case '|':\n                        switch (read(true)) {\n                            case '|':\n                                return token(CppTokenId.BARBAR);\n                            case '=':\n                                return token(CppTokenId.BAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.BAR);\n                    case '&':\n                        switch (read(true)) {\n                            case '&':\n                                return token(CppTokenId.AMPAMP);\n                            case '=':\n                                return token(CppTokenId.AMPEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.AMP);\n                    case '%': {\n                        Token<CppTokenId> out = finishPercent();\n                        assert out != null : \"not handled %\";\n                        return out;\n                    }\n                    case '^':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.CARETEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.CARET);\n                    case '!':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.NOTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.NOT);\n                    case '.':\n                        if ((c = read(true)) == '.') {\n                            if (read(true) == '.') {\n                                return token(CppTokenId.ELLIPSIS);\n                            } else {\n                                input.backup(2);\n                            }\n                        } else if ('0' <= c && c <= '9') {\n                            return finishNumberLiteral(read(true), true);\n                        } else if (c == '*') {\n                            return token(CppTokenId.DOTMBR);\n                        } else {\n                            backup(1);\n                        }\n                        return token(CppTokenId.DOT);\n                    case ':':\n                        if (read(true) == ':') {\n                            return token(CppTokenId.SCOPE);\n                        }\n                        backup(1);\n                        return token(CppTokenId.COLON);\n                    case '~':\n                        return token(CppTokenId.TILDE);\n                    case ',':\n                        return token(CppTokenId.COMMA);\n                    case ';':\n                        return token(CppTokenId.SEMICOLON);\n                    case '?':\n                        return token(CppTokenId.QUESTION);\n                    case '(':\n                        return token(CppTokenId.LPAREN);\n                    case ')':\n                        return token(CppTokenId.RPAREN);\n                    case '[':\n                        return token(CppTokenId.LBRACKET);\n                    case ']':\n                        return token(CppTokenId.RBRACKET);\n                    case '{':\n                        return token(CppTokenId.LBRACE);\n                    case '}':\n                        return token(CppTokenId.RBRACE);\n                    case '`':\n                        return token(CppTokenId.GRAVE_ACCENT);\n                    case '@':\n                        return token(CppTokenId.AT);\n                    case '0':\n                        c = read(true);\n                        if (c == 'x' || c == 'X' ||\n                                c == 'b' || c == 'B' ) {\n                            boolean inFraction = false;\n                            while (true) {\n                                switch (read(true)) {\n                                    case '0':\n                                    case '1':\n                                    case '2':\n                                    case '3':\n                                    case '4':\n                                    case '5':\n                                    case '6':\n                                    case '7':\n                                    case '8':\n                                    case '9':\n                                    case 'a':\n                                    case 'b':\n                                    case 'c':\n                                    case 'd':\n                                    case 'e':\n                                    case 'f':\n                                    case 'A':\n                                    case 'B':\n                                    case 'C':\n                                    case 'D':\n                                    case 'E':\n                                    case 'F':\n                                        break;\n                                    case '.':\n                                        if (!inFraction) {\n                                            inFraction = true;\n                                        } else {\n                                            return token(CppTokenId.FLOAT_LITERAL_INVALID);\n                                        }\n                                        break;\n                                    case 'l':\n                                    case 'L':\n                                        return finishLongLiteral(read(true));\n                                    case 'p':\n                                    case 'P':\n                                        return finishFloatExponent();\n                                    case 'u':\n                                    case 'U':\n                                        return finishUnsignedLiteral(read(true));\n                                    default:\n                                        backup(1);\n                                       \n                                        return token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n                                                : CppTokenId.INT_LITERAL);\n                                }\n                            }\n                        }\n                        return finishNumberLiteral(c, false);\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        return finishNumberLiteral(read(true), false);\n                    case '\\\\':\n                        return token(CppTokenId.BACK_SLASH);\n                    case '\\r':\n                        consumeNewline();\n                        return token(CppTokenId.NEW_LINE);\n                    case '\\n':\n                        return token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE);\n                   \n                   \n                    case '\\t':\n                    case 0x0b:\n                    case '\\f':\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n                        return finishWhitespace();\n                    case ' ':\n                        c = read(true);\n                        if (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') {\n                            backup(1);\n                            return token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE);\n                        }\n                        return finishWhitespace();\n                    case EOF:\n                        if (isTokenSplittedByEscapedLine()) {\n                            backup(1);\n                            assert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\n                            break;\n                        }\n                        return null;\n                    case '$':\n                       \n                    default:\n                        c = translateSurrogates(c);\n                        if (CndLexerUtilities.isCppIdentifierStart(c)) {\n                            if (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\n                                int next = read(true);\n                                boolean raw_string = (c == 'R');\n                                if (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n                                   \n                                    raw_string = true;\n                                    next = read(true);\n                                } else if (next == '8' && c == 'u') {\n                                   \n                                    next = read(true);\n                                    if (next == 'R') {\n                                       \n                                        raw_string = true;\n                                        next = read(true);\n                                    }\n                                }\n                                if (next == '\"') {\n                                   \n                                    Token<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\n                                    assert out != null : \"not handled dobule quote\";\n                                    return out;\n                                } else if (next == '\\'' && !raw_string) {\n                                   \n                                    Token<CppTokenId> out = finishSingleQuote();\n                                    assert out != null : \"not handled single quote\";\n                                    return out;\n                                } else {\n                                    backup(1);\n                                }\n                            }\n                            if (c == 'E') {\n                                if(isExecSQL(c)) {\n                                    Token<CppTokenId> out = finishExecSQL();\n                                    assert out != null : \"not handled exec sql\";\n                                    return out;\n                                }\n                            }\n                            return keywordOrIdentifier(c);\n                        }\n                        if (Character.isWhitespace(c)) {\n                            return finishWhitespace();\n                        }\n                       \n                        return token(CppTokenId.ERROR);\n                }\n            }\n        }\n    }","cleancode":"@suppresswarnings(\"fallthrough\") @override public token<cpptokenid> nexttoken() { while (true) { if (lasttokenendedbyescapedline > 0) { int c = read(false); lasttokenendedbyescapedline--; assert c == '\\\\' : \"there must be \\\\\"; c = read(false); assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\"; if (c == '\\r') { lasttokenendedbyescapedline--; if (input.consumenewline()) { lasttokenendedbyescapedline--; } return token(cpptokenid.escaped_line); } else { lasttokenendedbyescapedline--; return token(cpptokenid.escaped_line, \"\\\\\\n\", parttype.complete); } } else { int c = read(true); switch (c) { case '\"': { token<cpptokenid> out = finishdblquote(); assert out != null : \"not handled dobule quote\"; return out; } case '\\'': token<cpptokenid> out = finishsinglequote(); assert out != null : \"not handled single quote\"; return out; } case '#': { token<cpptokenid> out = finishsharp(); assert out != null : \"not handled #\"; return out; } case '\/': switch (read(true)) { case '\/': { token<cpptokenid> out = finishlinecomment(true); assert out != null : \"not handled \/\/\"; return out; } case '=': return token(cpptokenid.slasheq); case '*': { token<cpptokenid> out = finishblockcomment(true); assert out != null : \"not handled \/*\"; return out; } } backup(1); return token(cpptokenid.slash); case '=': if (read(true) == '=') { return token(cpptokenid.eqeq); } backup(1); return token(cpptokenid.eq); case '>': switch (read(true)) { case '>': if (read(true) == '=') { return token(cpptokenid.gtgteq); } backup(1); return token(cpptokenid.gtgt); case '=': return token(cpptokenid.gteq); } backup(1); return token(cpptokenid.gt); case '<': { token<cpptokenid> out = finishlt(); assert out != null : \"not handled '<'\"; return out; } case '+': switch (read(true)) { case '+': return token(cpptokenid.plusplus); case '=': return token(cpptokenid.pluseq); } backup(1); return token(cpptokenid.plus); case '-': switch (read(true)) { case '-': return token(cpptokenid.minusminus); case '>': if (read(true) == '*') { return token(cpptokenid.arrowmbr); } backup(1); return token(cpptokenid.arrow); case '=': return token(cpptokenid.minuseq); } backup(1); return token(cpptokenid.minus); case '*': switch (read(true)) { case '\/': if (read(true) == '*') { backup(2); return token(cpptokenid.star); } backup(1); return token(cpptokenid.invalid_comment_end); case '=': return token(cpptokenid.stareq); } backup(1); return token(cpptokenid.star); case '|': switch (read(true)) { case '|': return token(cpptokenid.barbar); case '=': return token(cpptokenid.bareq); } backup(1); return token(cpptokenid.bar); case '&': switch (read(true)) { case '&': return token(cpptokenid.ampamp); case '=': return token(cpptokenid.ampeq); } backup(1); return token(cpptokenid.amp); case '%': { token<cpptokenid> out = finishpercent(); assert out != null : \"not handled %\"; return out; } case '^': if (read(true) == '=') { return token(cpptokenid.careteq); } backup(1); return token(cpptokenid.caret); case '!': if (read(true) == '=') { return token(cpptokenid.noteq); } backup(1); return token(cpptokenid.not); case '.': if ((c = read(true)) == '.') { if (read(true) == '.') { return token(cpptokenid.ellipsis); } else { input.backup(2); } } else if ('0' <= c && c <= '9') { return finishnumberliteral(read(true), true); } else if (c == '*') { return token(cpptokenid.dotmbr); } else { backup(1); } return token(cpptokenid.dot); case ':': if (read(true) == ':') { return token(cpptokenid.scope); } backup(1); return token(cpptokenid.colon); case '~': return token(cpptokenid.tilde); case ',': return token(cpptokenid.comma); case ';': return token(cpptokenid.semicolon); case '?': return token(cpptokenid.question); case '(': return token(cpptokenid.lparen); case ')': return token(cpptokenid.rparen); case '[': return token(cpptokenid.lbracket); case ']': return token(cpptokenid.rbracket); case '{': return token(cpptokenid.lbrace); case '}': return token(cpptokenid.rbrace); case '`': return token(cpptokenid.grave_accent); case '@': return token(cpptokenid.at); case '0': c = read(true); if (c == 'x' || c == 'x' || c == 'b' || c == 'b' ) { boolean infraction = false; while (true) { switch (read(true)) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': break; case '.': if (!infraction) { infraction = true; } else { return token(cpptokenid.float_literal_invalid); } break; case 'l': case 'l': return finishlongliteral(read(true)); case 'p': case 'p': return finishfloatexponent(); case 'u': case 'u': return finishunsignedliteral(read(true)); default: backup(1); return token(infraction ? cpptokenid.float_literal_invalid : cpptokenid.int_literal); } } } return finishnumberliteral(c, false); case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return finishnumberliteral(read(true), false); case '\\\\': return token(cpptokenid.back_slash); case '\\r': consumenewline(); return token(cpptokenid.new_line); case '\\n': return token(cpptokenid.new_line, \"\\n\", parttype.complete); case '\\t': case 0x0b: case '\\f': case 0x1c: case 0x1d: case 0x1e: case 0x1f: return finishwhitespace(); case ' ': c = read(true); if (c == eof || !character.iswhitespace(c) || c == '\\n' || c == '\\r') { backup(1); return token(cpptokenid.whitespace, \" \", parttype.complete); } return finishwhitespace(); case eof: if (istokensplittedbyescapedline()) { backup(1); assert lasttokenendedbyescapedline > 0 : \"lasttokenendedbyescapedline is \" + lasttokenendedbyescapedline; break; } return null; case '$': default: c = translatesurrogates(c); if (cndlexerutilities.iscppidentifierstart(c)) { if (c == 'l' || c == 'u' || c == 'u' || c == 'r') { int next = read(true); boolean raw_string = (c == 'r'); if (next == 'r' && (c == 'u' || c == 'u' || c == 'l')) { raw_string = true; next = read(true); } else if (next == '8' && c == 'u') { next = read(true); if (next == 'r') { raw_string = true; next = read(true); } } if (next == '\"') { token<cpptokenid> out = raw_string ? finishrawstring() : finishdblquote(); assert out != null : \"not handled dobule quote\"; return out; } else if (next == '\\'' && !raw_string) { token<cpptokenid> out = finishsinglequote(); assert out != null : \"not handled single quote\"; return out; } else { backup(1); } } if (c == 'e') { if(isexecsql(c)) { token<cpptokenid> out = finishexecsql(); assert out != null : \"not handled exec sql\"; return out; } } return keywordoridentifier(c); } if (character.iswhitespace(c)) { return finishwhitespace(); } return token(cpptokenid.error); } } } }","comment":"\/\/ special handling for escaped lines\n\/\/ noi18n\n\/\/ if read of the first char caused skipping escaped line \/\/ do we need to backup and create escaped lines first?\n\/\/ char literal\n\/\/ in single-line or doxygen comment\n\/\/ found \/=\n\/\/ in multi-line or doxygen comment\n\/\/ end of switch()\n\/\/ >>\n\/\/ >=\n\/\/ invalid comment end - *\/ or int*\/* *\/\n\/\/ ellipsis ...\n\/\/ float literal\n\/\/ in a number literal\n\/\/ in hexadecimal (possibly floating-point) literal\n\/\/ in bianry literal\n\/\/ hex float literal\n\/\/ two dots in the float literal\n\/\/ 0x1234l or 0x1234l\n\/\/ binary exponent\n\/\/ if float then before mandatory binary exponent => invalid\n\/\/ end of while(true)\n\/\/ noi18n\n\/\/ all character.iswhitespace(c) below 0x80 follow \/\/ ['\\t' - '\\f'] and [0x1c - ' ']\n\/\/ return single space as flyweight token\n\/\/ noi18n\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers \/\/ return token(cpptokenid.dollar);\n\/\/ ur, ur or lr\n\/\/ u8\n\/\/ u8r\n\/\/ string with l\/u\/u\/r prefixes\n\/\/ char with l or u\/u prefix\n\/\/ invalid char\n\/\/ end of switch (c)\n\/\/ end of while(true)","repo":"leginee\/netbeans","code_context_2":"public Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\n\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\n\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\n\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\n\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\n\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\n\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\n\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\n\ncase '*':\nswitch (read(true)) {\ncase '\/': \/\/ invalid comment end - *\/ or int*\/* *\/\nif (read(true) == '*') {\nbackup(2);\n\ncase '.':\nif ((c = read(true)) == '.') {\nif (read(true) == '.') { \/\/ ellipsis ...\nreturn token(CppTokenId.ELLIPSIS);\n} else {\n\ninput.backup(2);\n}\n} else if ('0' <= c && c <= '9') { \/\/ float literal\nreturn finishNumberLiteral(read(true), true);\n} else if (c == '*') {\n\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\n\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\n\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\n\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\n\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\n\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\n\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\n\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\n\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow\n\/\/ ['\\t' - '\\f'] and [0x1c - ' ']\ncase '\\t':\ncase 0x0b:\n\ncase ' ':\nc = read(true);\nif (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\nbackup(1);\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\n\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\n\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\n\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\n\nreturn finishWhitespace();\n}\n\/\/ Invalid char\nreturn token(CppTokenId.ERROR);\n}\n\nreturn token(CppTokenId.ERROR);\n}\n} \/\/ end of switch (c)\n} \/\/ end of while(true)\n}\n\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);","code_context_10":"@SuppressWarnings(\"fallthrough\")\n@Override\npublic Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\n\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\n\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\n\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\n\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\n\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GT);\n\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GT);\ncase '<': {\nToken<CppTokenId> out = finishLT();\nassert out != null : \"not handled '<'\";\nreturn out;\n}\ncase '+':\n\n}\nbackup(1);\nreturn token(CppTokenId.ARROW);\ncase '=':\nreturn token(CppTokenId.MINUSEQ);\n}\nbackup(1);\nreturn token(CppTokenId.MINUS);\ncase '*':\nswitch (read(true)) {\ncase '\/': \/\/ invalid comment end - *\/ or int*\/* *\/\nif (read(true) == '*') {\nbackup(2);\nreturn token(CppTokenId.STAR);\n}\nbackup(1);\nreturn token(CppTokenId.INVALID_COMMENT_END);\ncase '=':\nreturn token(CppTokenId.STAREQ);\n}\nbackup(1);\n\nbackup(1);\nreturn token(CppTokenId.CARET);\ncase '!':\nif (read(true) == '=') {\nreturn token(CppTokenId.NOTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.NOT);\ncase '.':\nif ((c = read(true)) == '.') {\nif (read(true) == '.') { \/\/ ellipsis ...\nreturn token(CppTokenId.ELLIPSIS);\n} else {\ninput.backup(2);\n}\n} else if ('0' <= c && c <= '9') { \/\/ float literal\nreturn finishNumberLiteral(read(true), true);\n} else if (c == '*') {\nreturn token(CppTokenId.DOTMBR);\n} else {\nbackup(1);\n\n}\nbackup(1);\nreturn token(CppTokenId.NOT);\ncase '.':\nif ((c = read(true)) == '.') {\nif (read(true) == '.') { \/\/ ellipsis ...\nreturn token(CppTokenId.ELLIPSIS);\n} else {\ninput.backup(2);\n}\n} else if ('0' <= c && c <= '9') { \/\/ float literal\nreturn finishNumberLiteral(read(true), true);\n} else if (c == '*') {\nreturn token(CppTokenId.DOTMBR);\n} else {\nbackup(1);\n}\nreturn token(CppTokenId.DOT);\ncase ':':\nif (read(true) == ':') {\nreturn token(CppTokenId.SCOPE);\n\ncase ']':\nreturn token(CppTokenId.RBRACKET);\ncase '{':\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\n\ncase '{':\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\n\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\n\ncase 'd':\ncase 'e':\ncase 'f':\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\n\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\n\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\n\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\n\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\n\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n\ncase '8':\ncase '9':\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\nreturn token(CppTokenId.NEW_LINE);\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow\n\/\/ ['\\t' - '\\f'] and [0x1c - ' ']\ncase '\\t':\ncase 0x0b:\ncase '\\f':\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\ncase 0x1f:\nreturn finishWhitespace();\ncase ' ':\nc = read(true);\n\ncase '\\t':\ncase 0x0b:\ncase '\\f':\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\ncase 0x1f:\nreturn finishWhitespace();\ncase ' ':\nc = read(true);\nif (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\nbackup(1);\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\n\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\n\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\nToken<CppTokenId> out = finishExecSQL();\n\nToken<CppTokenId> out = finishExecSQL();\nassert out != null : \"not handled exec sql\";\nreturn out;\n}\n}\nreturn keywordOrIdentifier(c);\n}\nif (Character.isWhitespace(c)) {\nreturn finishWhitespace();\n}\n\/\/ Invalid char\nreturn token(CppTokenId.ERROR);\n}\n} \/\/ end of switch (c)\n} \/\/ end of while(true)\n}\n\n}\n}\nreturn keywordOrIdentifier(c);\n}\nif (Character.isWhitespace(c)) {\nreturn finishWhitespace();\n}\n\/\/ Invalid char\nreturn token(CppTokenId.ERROR);\n}\n} \/\/ end of switch (c)\n} \/\/ end of while(true)\n}\n\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':","code_context_20":"@SuppressWarnings(\"fallthrough\")\n@Override\npublic Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\n\n@SuppressWarnings(\"fallthrough\")\n@Override\npublic Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\n\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\n\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\n\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\n\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n}\ncase '\/':\nswitch (read(true)) {\ncase '\/': \/\/ in single-line or doxygen comment\n{\nToken<CppTokenId> out = finishLineComment(true);\nassert out != null : \"not handled \/\/\";\nreturn out;\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\nbackup(1);\n\n}\ncase '=': \/\/ found \/=\nreturn token(CppTokenId.SLASHEQ);\ncase '*': \/\/ in multi-line or doxygen comment\n{\nToken<CppTokenId> out = finishBlockComment(true);\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GT);\ncase '<': {\nToken<CppTokenId> out = finishLT();\nassert out != null : \"not handled '<'\";\nreturn out;\n}\ncase '+':\nswitch (read(true)) {\ncase '+':\nreturn token(CppTokenId.PLUSPLUS);\ncase '=':\n\nassert out != null : \"not handled \/*\";\nreturn out;\n}\n} \/\/ end of switch()\nbackup(1);\nreturn token(CppTokenId.SLASH);\ncase '=':\nif (read(true) == '=') {\nreturn token(CppTokenId.EQEQ);\n}\nbackup(1);\nreturn token(CppTokenId.EQ);\ncase '>':\nswitch (read(true)) {\ncase '>': \/\/ >>\nif (read(true) == '=') {\nreturn token(CppTokenId.GTGTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GTGT);\ncase '=': \/\/ >=\nreturn token(CppTokenId.GTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.GT);\ncase '<': {\nToken<CppTokenId> out = finishLT();\nassert out != null : \"not handled '<'\";\nreturn out;\n}\ncase '+':\nswitch (read(true)) {\ncase '+':\nreturn token(CppTokenId.PLUSPLUS);\ncase '=':\nreturn token(CppTokenId.PLUSEQ);\n}\nbackup(1);\nreturn token(CppTokenId.PLUS);\ncase '-':\nswitch (read(true)) {\n\n}\nbackup(1);\nreturn token(CppTokenId.PLUS);\ncase '-':\nswitch (read(true)) {\ncase '-':\nreturn token(CppTokenId.MINUSMINUS);\ncase '>':\nif (read(true) == '*') {\nreturn token(CppTokenId.ARROWMBR);\n}\nbackup(1);\nreturn token(CppTokenId.ARROW);\ncase '=':\nreturn token(CppTokenId.MINUSEQ);\n}\nbackup(1);\nreturn token(CppTokenId.MINUS);\ncase '*':\nswitch (read(true)) {\ncase '\/': \/\/ invalid comment end - *\/ or int*\/* *\/\nif (read(true) == '*') {\nbackup(2);\nreturn token(CppTokenId.STAR);\n}\nbackup(1);\nreturn token(CppTokenId.INVALID_COMMENT_END);\ncase '=':\nreturn token(CppTokenId.STAREQ);\n}\nbackup(1);\nreturn token(CppTokenId.STAR);\ncase '|':\nswitch (read(true)) {\ncase '|':\nreturn token(CppTokenId.BARBAR);\ncase '=':\nreturn token(CppTokenId.BAREQ);\n}\nbackup(1);\nreturn token(CppTokenId.BAR);\n\nreturn token(CppTokenId.AMP);\ncase '%': {\nToken<CppTokenId> out = finishPercent();\nassert out != null : \"not handled %\";\nreturn out;\n}\ncase '^':\nif (read(true) == '=') {\nreturn token(CppTokenId.CARETEQ);\n}\nbackup(1);\nreturn token(CppTokenId.CARET);\ncase '!':\nif (read(true) == '=') {\nreturn token(CppTokenId.NOTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.NOT);\ncase '.':\nif ((c = read(true)) == '.') {\nif (read(true) == '.') { \/\/ ellipsis ...\nreturn token(CppTokenId.ELLIPSIS);\n} else {\ninput.backup(2);\n}\n} else if ('0' <= c && c <= '9') { \/\/ float literal\nreturn finishNumberLiteral(read(true), true);\n} else if (c == '*') {\nreturn token(CppTokenId.DOTMBR);\n} else {\nbackup(1);\n}\nreturn token(CppTokenId.DOT);\ncase ':':\nif (read(true) == ':') {\nreturn token(CppTokenId.SCOPE);\n}\nbackup(1);\nreturn token(CppTokenId.COLON);\ncase '~':\nreturn token(CppTokenId.TILDE);\n\n}\ncase '^':\nif (read(true) == '=') {\nreturn token(CppTokenId.CARETEQ);\n}\nbackup(1);\nreturn token(CppTokenId.CARET);\ncase '!':\nif (read(true) == '=') {\nreturn token(CppTokenId.NOTEQ);\n}\nbackup(1);\nreturn token(CppTokenId.NOT);\ncase '.':\nif ((c = read(true)) == '.') {\nif (read(true) == '.') { \/\/ ellipsis ...\nreturn token(CppTokenId.ELLIPSIS);\n} else {\ninput.backup(2);\n}\n} else if ('0' <= c && c <= '9') { \/\/ float literal\nreturn finishNumberLiteral(read(true), true);\n} else if (c == '*') {\nreturn token(CppTokenId.DOTMBR);\n} else {\nbackup(1);\n}\nreturn token(CppTokenId.DOT);\ncase ':':\nif (read(true) == ':') {\nreturn token(CppTokenId.SCOPE);\n}\nbackup(1);\nreturn token(CppTokenId.COLON);\ncase '~':\nreturn token(CppTokenId.TILDE);\ncase ',':\nreturn token(CppTokenId.COMMA);\ncase ';':\nreturn token(CppTokenId.SEMICOLON);\ncase '?':\n\ncase ';':\nreturn token(CppTokenId.SEMICOLON);\ncase '?':\nreturn token(CppTokenId.QUESTION);\ncase '(':\nreturn token(CppTokenId.LPAREN);\ncase ')':\nreturn token(CppTokenId.RPAREN);\ncase '[':\nreturn token(CppTokenId.LBRACKET);\ncase ']':\nreturn token(CppTokenId.RBRACKET);\ncase '{':\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\ncase 'a':\ncase 'b':\ncase 'c':\ncase 'd':\n\ncase '?':\nreturn token(CppTokenId.QUESTION);\ncase '(':\nreturn token(CppTokenId.LPAREN);\ncase ')':\nreturn token(CppTokenId.RPAREN);\ncase '[':\nreturn token(CppTokenId.LBRACKET);\ncase ']':\nreturn token(CppTokenId.RBRACKET);\ncase '{':\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\ncase 'a':\ncase 'b':\ncase 'c':\ncase 'd':\ncase 'e':\ncase 'f':\n\nreturn token(CppTokenId.QUESTION);\ncase '(':\nreturn token(CppTokenId.LPAREN);\ncase ')':\nreturn token(CppTokenId.RPAREN);\ncase '[':\nreturn token(CppTokenId.LBRACKET);\ncase ']':\nreturn token(CppTokenId.RBRACKET);\ncase '{':\nreturn token(CppTokenId.LBRACE);\ncase '}':\nreturn token(CppTokenId.RBRACE);\ncase '`':\nreturn token(CppTokenId.GRAVE_ACCENT);\ncase '@':\nreturn token(CppTokenId.AT);\ncase '0': \/\/ in a number literal\nc = read(true);\nif (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\nc == 'b' || c == 'B' ) { \/\/ in bianry literal\nboolean inFraction = false;\nwhile (true) {\nswitch (read(true)) {\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\ncase 'a':\ncase 'b':\ncase 'c':\ncase 'd':\ncase 'e':\ncase 'f':\ncase 'A':\n\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\ncase 'a':\ncase 'b':\ncase 'c':\ncase 'd':\ncase 'e':\ncase 'f':\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n\ncase '6':\ncase '7':\ncase '8':\ncase '9':\ncase 'a':\ncase 'b':\ncase 'c':\ncase 'd':\ncase 'e':\ncase 'f':\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\n\ncase 'b':\ncase 'c':\ncase 'd':\ncase 'e':\ncase 'f':\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\n\ncase 'e':\ncase 'f':\ncase 'A':\ncase 'B':\ncase 'C':\ncase 'D':\ncase 'E':\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\n\ncase 'F':\nbreak;\ncase '.': \/\/ hex float literal\nif (!inFraction) {\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\n\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\nreturn token(CppTokenId.NEW_LINE);\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow\n\n@SuppressWarnings(\"fallthrough\")\n@Override\npublic Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\nreturn token(CppTokenId.NEW_LINE);\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow\n\/\/ ['\\t' - '\\f'] and [0x1c - ' ']\ncase '\\t':\ncase 0x0b:\ncase '\\f':\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\ncase 0x1f:\nreturn finishWhitespace();\ncase ' ':\nc = read(true);\nif (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\nbackup(1);\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\nreturn token(CppTokenId.NEW_LINE);\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow\n\/\/ ['\\t' - '\\f'] and [0x1c - ' ']\ncase '\\t':\ncase 0x0b:\ncase '\\f':\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\ncase 0x1f:\nreturn finishWhitespace();\ncase ' ':\nc = read(true);\nif (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\nbackup(1);\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\n\n@SuppressWarnings(\"fallthrough\")\n@Override\npublic Token<CppTokenId> nextToken() {\nwhile (true) {\n\/\/ special handling for escaped lines\nif (lastTokenEndedByEscapedLine > 0) {\nint c = read(false);\nlastTokenEndedByEscapedLine--;\nassert c == '\\\\' : \"there must be \\\\\";\nc = read(false);\nassert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\nif (c == '\\r') {\nlastTokenEndedByEscapedLine--;\nif (input.consumeNewline()) {\nlastTokenEndedByEscapedLine--;\n}\nreturn token(CppTokenId.ESCAPED_LINE);\n} else {\nlastTokenEndedByEscapedLine--;\nreturn token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n}\n} else {\nint c = read(true);\n\/\/ if read of the first char caused skipping escaped line\n\/\/ do we need to backup and create escaped lines first?\nswitch (c) {\ncase '\"': {\nToken<CppTokenId> out = finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n}\ncase '\\'': {\/\/ char literal\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n}\ncase '#': {\nToken<CppTokenId> out = finishSharp();\nassert out != null : \"not handled #\";\nreturn out;\n\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\ncase 0x1f:\nreturn finishWhitespace();\ncase ' ':\nc = read(true);\nif (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\nbackup(1);\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\nreturn token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n}\nreturn finishWhitespace();\ncase EOF:\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\n\nif (isTokenSplittedByEscapedLine()) {\nbackup(1);\nassert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n\nbreak;\n}\nreturn null;\ncase '$':\n\/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/ return token(CppTokenId.DOLLAR);\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\n\ndefault:\nc = translateSurrogates(c);\nif (CndLexerUtilities.isCppIdentifierStart(c)) {\nif (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\nint next = read(true);\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\nToken<CppTokenId> out = finishExecSQL();\nassert out != null : \"not handled exec sql\";\nreturn out;\n}\n}\nreturn keywordOrIdentifier(c);\n\nboolean raw_string = (c == 'R');\nif (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n\/\/ uR, UR or LR\nraw_string = true;\nnext = read(true);\n} else if (next == '8' && c == 'u') {\n\/\/ u8\nnext = read(true);\nif (next == 'R') {\n\/\/ u8R\nraw_string = true;\nnext = read(true);\n}\n}\nif (next == '\"') {\n\/\/ string with L\/U\/u\/R prefixes\nToken<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\nassert out != null : \"not handled dobule quote\";\nreturn out;\n} else if (next == '\\'' && !raw_string) {\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\nToken<CppTokenId> out = finishExecSQL();\nassert out != null : \"not handled exec sql\";\nreturn out;\n}\n}\nreturn keywordOrIdentifier(c);\n}\nif (Character.isWhitespace(c)) {\nreturn finishWhitespace();\n}\n\/\/ Invalid char\n\n\/\/ char with L or U\/u prefix\nToken<CppTokenId> out = finishSingleQuote();\nassert out != null : \"not handled single quote\";\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\nToken<CppTokenId> out = finishExecSQL();\nassert out != null : \"not handled exec sql\";\nreturn out;\n}\n}\nreturn keywordOrIdentifier(c);\n}\nif (Character.isWhitespace(c)) {\nreturn finishWhitespace();\n}\n\/\/ Invalid char\nreturn token(CppTokenId.ERROR);\n}\n} \/\/ end of switch (c)\n} \/\/ end of while(true)\n}\n\nreturn out;\n} else {\nbackup(1);\n}\n}\nif (c == 'E') {\nif(isExecSQL(c)) {\nToken<CppTokenId> out = finishExecSQL();\nassert out != null : \"not handled exec sql\";\nreturn out;\n}\n}\nreturn keywordOrIdentifier(c);\n}\nif (Character.isWhitespace(c)) {\nreturn finishWhitespace();\n}\n\/\/ Invalid char\nreturn token(CppTokenId.ERROR);\n}\n} \/\/ end of switch (c)\n} \/\/ end of while(true)\n}\n\ninFraction = true;\n} else { \/\/ two dots in the float literal\nreturn token(CppTokenId.FLOAT_LITERAL_INVALID);\n}\nbreak;\ncase 'l':\ncase 'L': \/\/ 0x1234l or 0x1234L\nreturn finishLongLiteral(read(true));\ncase 'p':\ncase 'P': \/\/ binary exponent\nreturn finishFloatExponent();\ncase 'u':\ncase 'U':\nreturn finishUnsignedLiteral(read(true));\ndefault:\nbackup(1);\n\/\/ if float then before mandatory binary exponent => invalid\nreturn token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n: CppTokenId.INT_LITERAL);\n}\n} \/\/ end of while(true)\n}\nreturn finishNumberLiteral(c, false);\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn finishNumberLiteral(read(true), false);\ncase '\\\\':\nreturn token(CppTokenId.BACK_SLASH);\ncase '\\r':\nconsumeNewline();\nreturn token(CppTokenId.NEW_LINE);\ncase '\\n':\nreturn token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n\/\/ All Character.isWhitespace(c) below 0x80 follow","label":[1,0,0,0]}
{"id":25373,"original_code":"protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNode() {\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String separator, @NonNls @NotNull String value,\n                                      boolean hasChildren) {\n            setPresentation(icon, type, separator, value, null, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value,\n                                      @Nullable NotNullFunction<String, String> valuePresenter, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setGroupingPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean expand) {\n            setPresentation(icon, value, valuePresenter, true);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean hasChildren) {\n            doSetPresentation(icon, null, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value, @Nullable final NotNullFunction<String, String> valuePresenter, final boolean hasChildren) {\n            doSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n          }\n          private void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              public void run() {\n                doShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n              }\n            });\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, value, hasChildren);\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, separator, value, hasChildren);\n          }\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n            \/\/todo[nik] implement?\n          }\n          public boolean isObsolete() {\n            \/\/todo[nik]\n            return false;\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","code":"protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNode() {\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String separator, @NonNls @NotNull String value,\n                                      boolean hasChildren) {\n            setPresentation(icon, type, separator, value, null, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value,\n                                      @Nullable NotNullFunction<String, String> valuePresenter, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setGroupingPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean expand) {\n            setPresentation(icon, value, valuePresenter, true);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean hasChildren) {\n            doSetPresentation(icon, null, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value, @Nullable final NotNullFunction<String, String> valuePresenter, final boolean hasChildren) {\n            doSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n          }\n          private void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              public void run() {\n                doShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n              }\n            });\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, value, hasChildren);\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, separator, value, hasChildren);\n          }\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n           \n          }\n          public boolean isObsolete() {\n           \n            return false;\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","cleancode":"protected void evaluateandshowhint() { myevaluator.evaluate(myexpression, new xevaluationcallbackbase() { public void evaluated(@notnull final xvalue result) { result.computepresentation(new xvaluenode() { @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string value, boolean haschildren) { setpresentation(icon, type, xdebuggeruiconstants.eq_text, value, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string separator, @nonnls @notnull string value, boolean haschildren) { setpresentation(icon, type, separator, value, null, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string value, @nullable notnullfunction<string, string> valuepresenter, boolean haschildren) { setpresentation(icon, type, xdebuggeruiconstants.eq_text, value, valuepresenter, haschildren); } @override public void setgroupingpresentation(@nullable icon icon, @nonnls @nullable string value, @nullable xvaluepresenter valuepresenter, boolean expand) { setpresentation(icon, value, valuepresenter, true); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string value, @nullable xvaluepresenter valuepresenter, boolean haschildren) { dosetpresentation(icon, null, xdebuggeruiconstants.eq_text, value, valuepresenter, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @notnull final string value, @nullable final notnullfunction<string, string> valuepresenter, final boolean haschildren) { dosetpresentation(icon, type, separator, value, valuepresenter == null ? null : new xvaluepresenteradapter(valuepresenter), haschildren); } private void dosetpresentation(@nullable icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @nullable final string value, @nullable final xvaluepresenter valuepresenter, final boolean haschildren) { appuiutil.invokeonedt(new runnable() { public void run() { doshowhint(result, separator, value, type, valuepresenter == null ? xvaluenodeimpl.default_value_presenter : valuepresenter, haschildren); } }); } public void setpresentation(@nonnls final string name, @nullable final icon icon, @nonnls @nullable final string type, @nonnls @notnull final string value, final boolean haschildren) { setpresentation(icon, type, value, haschildren); } public void setpresentation(@nonnls final string name, @nullable final icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @notnull final string value, final boolean haschildren) { setpresentation(icon, type, separator, value, haschildren); } public void setfullvalueevaluator(@notnull xfullvalueevaluator fullvalueevaluator) { } public boolean isobsolete() { return false; } }, xvalueplace.tooltip); } public void erroroccurred(@notnull final string errormessage) { log.debug(\"cannot evaluate '\" + myexpression + \"':\" + errormessage); } }, myexpressionposition); }","comment":"\/\/todo[nik] implement?\n\/\/todo[nik]","repo":"liveqmock\/platform-tools-idea","code_context_2":"}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {\n\n}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {","code_context_10":"public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, value, hasChildren);\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, separator, value, hasChildren);\n}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {\n\/\/todo[nik]\nreturn false;\n}\n}, XValuePlace.TOOLTIP);\n}\npublic void errorOccurred(@NotNull final String errorMessage) {\nLOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n}\n\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, value, hasChildren);\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, separator, value, hasChildren);\n}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {\n\/\/todo[nik]\nreturn false;\n}\n}, XValuePlace.TOOLTIP);\n}\npublic void errorOccurred(@NotNull final String errorMessage) {\nLOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n}","code_context_20":"doSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n}\nprivate void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\nAppUIUtil.invokeOnEdt(new Runnable() {\npublic void run() {\ndoShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n}\n});\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, value, hasChildren);\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, separator, value, hasChildren);\n}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {\n\/\/todo[nik]\nreturn false;\n}\n}, XValuePlace.TOOLTIP);\n}\npublic void errorOccurred(@NotNull final String errorMessage) {\nLOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n}\n}, myExpressionPosition);\n}\n\ndoSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n}\nprivate void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\nAppUIUtil.invokeOnEdt(new Runnable() {\npublic void run() {\ndoShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n}\n});\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, value, hasChildren);\n}\npublic void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n@NonNls @NotNull final String value,\nfinal boolean hasChildren) {\nsetPresentation(icon, type, separator, value, hasChildren);\n}\npublic void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n\/\/todo[nik] implement?\n}\npublic boolean isObsolete() {\n\/\/todo[nik]\nreturn false;\n}\n}, XValuePlace.TOOLTIP);\n}\npublic void errorOccurred(@NotNull final String errorMessage) {\nLOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n}\n}, myExpressionPosition);\n}","label":[0,1,0,0]}
{"id":25388,"original_code":"@DB\n    private Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\n                                       boolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\n                                       final long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\n                                       final Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\n        final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\n        final DataCenterVO zone = _dcDao.findById(zoneId);\n        \/\/ this method supports only guest network creation\n        if (ntwkOff.getTrafficType() != TrafficType.Guest) {\n            s_logger.warn(\"Only guest networks can be created using this method\");\n            return null;\n        }\n        final boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n        \/\/check resource limits\n        if (updateResourceCount) {\n            _resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n        }\n        \/\/ Validate network offering\n        if (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n            \/\/ see NetworkOfferingVO\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\n            ex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\n            throw ex;\n        }\n        \/\/ Validate physical network\n        if (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n            \/\/ see PhysicalNetworkVO.java\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n            ex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\n            throw ex;\n        }\n        boolean ipv6 = false;\n        if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n            ipv6 = true;\n        }\n        \/\/ Validate zone\n        if (zone.getNetworkType() == NetworkType.Basic) {\n            \/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\n            if (aclType == null || aclType != ACLType.Domain) {\n                throw new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n            }\n            \/\/ Only one guest network is supported in Basic zone\n            final List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\n            if (!guestNetworks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n            }\n            \/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\n            if (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\n                throw new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n                        + Service.SourceNat.getName() + \" service are allowed\");\n            }\n            if (domainId == null || domainId != Domain.ROOT_DOMAIN) {\n                throw new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n            }\n            if (subdomainAccess == null) {\n                subdomainAccess = true;\n            } else if (!subdomainAccess) {\n                throw new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n            }\n            if (vlanId == null) {\n                vlanId = Vlan.UNTAGGED;\n            } else {\n                if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                    throw new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n                }\n            }\n        } else if (zone.getNetworkType() == NetworkType.Advanced) {\n            if (zone.isSecurityGroupEnabled()) {\n                if (isolatedPvlan != null) {\n                    throw new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n                }\n                \/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n                \/\/ enabled zone\n                if (ntwkOff.getGuestType() != GuestType.Shared) {\n                    throw new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n                }\n                if (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\n                    throw new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n                }\n            }\n            \/\/don't allow eip\/elb networks in Advance zone\n            if (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\n                throw new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n            }\n        }\n        if (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\n            throw new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n        }\n        \/\/TODO(VXLAN): Support VNI specified\n        \/\/ VlanId can be specified only when network offering supports it\n        final boolean vlanSpecified = vlanId != null;\n        if (vlanSpecified != ntwkOff.isSpecifyVlan()) {\n            if (vlanSpecified) {\n                throw new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n            } else {\n                throw new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n            }\n        }\n        if (vlanSpecified) {\n            URI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n            \/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\n            URI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n            \/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\n            if (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n                    _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (! UuidUtils.validateUUID(vlanId)){\n                \/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\n                if (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\n                    if (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else {\n                        final List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n                        \/\/for the network that is created as part of private gateway,\n                        \/\/the vnet is not coming from the data center vnet table, so the list can be empty\n                        if (!dcVnets.isEmpty()) {\n                            final DataCenterVnetVO dcVnet = dcVnets.get(0);\n                            \/\/ Fail network creation if specified vlan is dedicated to a different account\n                            if (dcVnet.getAccountGuestVlanMapId() != null) {\n                                final Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\n                                final AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\n                                if (map.getAccountId() != owner.getAccountId()) {\n                                    throw new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n                                }\n                                \/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n                            } else {\n                                final List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\n                                if (maps != null && !maps.isEmpty()) {\n                                    final int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\n                                    final int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\n                                    if (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\n                                        throw new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n                                                + owner.getAccountName());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    \/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n                    \/\/ shared network with same Vlan ID in the zone\n                    if (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\n                        throw new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n                    }\n                }\n            }\n        }\n        \/\/ If networkDomain is not specified, take it from the global configuration\n        if (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\n            final Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\n                    Service.Dns);\n            final String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\n            if (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\n                if (networkDomain != null) {\n                    \/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\n                    throw new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n                }\n            } else {\n                if (networkDomain == null) {\n                    \/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\n                    if (aclType == ACLType.Domain) {\n                        networkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n                    } else if (aclType == ACLType.Account) {\n                        networkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n                    }\n                    \/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\n                    if (networkDomain == null) {\n                        networkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n                    }\n                } else {\n                    \/\/ validate network domain\n                    if (!NetUtils.verifyDomainName(networkDomain)) {\n                        throw new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n                                + \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                                + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n                    }\n                }\n            }\n        }\n        \/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n        \/\/ limitation, remove after we introduce support for multiple ip ranges\n        \/\/ with different Cidrs for the same Shared network\n        final boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n                && ntwkOff.getTrafficType() == TrafficType.Guest\n                && (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n                && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\n        if (cidr == null && ip6Cidr == null && cidrRequired) {\n            if (ntwkOff.getGuestType() == GuestType.Shared) {\n                throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n            } else {\n                throw new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n            }\n        }\n        checkL2OfferingServices(ntwkOff);\n        \/\/ No cidr can be specified in Basic zone\n        if (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\n            throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n        }\n        \/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\n        if (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\n            if (!NetUtils.validateGuestCidr(cidr)) {\n                throw new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n            }\n        }\n        final String networkDomainFinal = networkDomain;\n        final String vlanIdFinal = vlanId;\n        final Boolean subdomainAccessFinal = subdomainAccess;\n        final Network network = Transaction.execute(new TransactionCallback<Network>() {\n            @Override\n            public Network doInTransaction(final TransactionStatus status) {\n                Long physicalNetworkId = null;\n                if (pNtwk != null) {\n                    physicalNetworkId = pNtwk.getId();\n                }\n                final DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\n                final NetworkVO userNetwork = new NetworkVO();\n                userNetwork.setNetworkDomain(networkDomainFinal);\n                if (cidr != null && gateway != null) {\n                    userNetwork.setCidr(cidr);\n                    userNetwork.setGateway(gateway);\n                }\n                if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n                    userNetwork.setIp6Cidr(ip6Cidr);\n                    userNetwork.setIp6Gateway(ip6Gateway);\n                }\n                if (externalId != null) {\n                    userNetwork.setExternalId(externalId);\n                }\n                if (StringUtils.isNotBlank(routerIp)) {\n                    userNetwork.setRouterIp(routerIp);\n                }\n                if (StringUtils.isNotBlank(routerIpv6)) {\n                    userNetwork.setRouterIpv6(routerIpv6);\n                }\n                if (vlanIdFinal != null) {\n                    if (isolatedPvlan == null) {\n                        URI uri = null;\n                        if (UuidUtils.validateUUID(vlanIdFinal)){\n                            \/\/Logical router's UUID provided as VLAN_ID\n                            userNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n                        } else {\n                            uri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n                        }\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n                                \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        if (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                        } else {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                        }\n                    } else {\n                        if (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            throw new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n                        }\n                        URI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with primary vlan \" + vlanIdFinal +\n                                    \" and secondary vlan \" + isolatedPvlan + \" type \" + isolatedPvlanType +\n                                    \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        userNetwork.setBroadcastDomainType(BroadcastDomainType.Pvlan);\n                        userNetwork.setPvlanType(isolatedPvlanType);\n                    }\n                }\n                final List<? extends Network> networks = setupNetwork(owner, ntwkOff, userNetwork, plan, name, displayText, true, domainId, aclType, subdomainAccessFinal, vpcId,\n                        isDisplayNetworkEnabled);\n                Network network = null;\n                if (networks == null || networks.isEmpty()) {\n                    throw new CloudRuntimeException(\"Fail to create a network\");\n                } else {\n                    if (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\n                        Network defaultGuestNetwork = networks.get(0);\n                        for (final Network nw : networks) {\n                            if (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\n                                defaultGuestNetwork = nw;\n                            }\n                        }\n                        network = defaultGuestNetwork;\n                    } else {\n                        \/\/ For shared network\n                        network = networks.get(0);\n                    }\n                }\n                if (updateResourceCount) {\n                    _resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n                }\n                return network;\n            }\n        });\n        CallContext.current().setEventDetails(\"Network Id: \" + network.getId());\n        CallContext.current().putContextParameter(Network.class, network.getUuid());\n        return network;\n    }","code":"@DB\n    private Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\n                                       boolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\n                                       final long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\n                                       final Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\n        final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\n        final DataCenterVO zone = _dcDao.findById(zoneId);\n       \n        if (ntwkOff.getTrafficType() != TrafficType.Guest) {\n            s_logger.warn(\"Only guest networks can be created using this method\");\n            return null;\n        }\n        final boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n       \n        if (updateResourceCount) {\n            _resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n        }\n       \n        if (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n           \n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\n            ex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\n            throw ex;\n        }\n       \n        if (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n           \n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n            ex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\n            throw ex;\n        }\n        boolean ipv6 = false;\n        if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n            ipv6 = true;\n        }\n       \n        if (zone.getNetworkType() == NetworkType.Basic) {\n           \n            if (aclType == null || aclType != ACLType.Domain) {\n                throw new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n            }\n           \n            final List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\n            if (!guestNetworks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n            }\n           \n            if (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\n                throw new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n                        + Service.SourceNat.getName() + \" service are allowed\");\n            }\n            if (domainId == null || domainId != Domain.ROOT_DOMAIN) {\n                throw new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n            }\n            if (subdomainAccess == null) {\n                subdomainAccess = true;\n            } else if (!subdomainAccess) {\n                throw new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n            }\n            if (vlanId == null) {\n                vlanId = Vlan.UNTAGGED;\n            } else {\n                if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                    throw new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n                }\n            }\n        } else if (zone.getNetworkType() == NetworkType.Advanced) {\n            if (zone.isSecurityGroupEnabled()) {\n                if (isolatedPvlan != null) {\n                    throw new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n                }\n               \n               \n                if (ntwkOff.getGuestType() != GuestType.Shared) {\n                    throw new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n                }\n                if (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\n                    throw new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n                }\n            }\n           \n            if (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\n                throw new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n            }\n        }\n        if (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\n            throw new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n        }\n       \n       \n        final boolean vlanSpecified = vlanId != null;\n        if (vlanSpecified != ntwkOff.isSpecifyVlan()) {\n            if (vlanSpecified) {\n                throw new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n            } else {\n                throw new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n            }\n        }\n        if (vlanSpecified) {\n            URI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n           \n            URI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n           \n            if (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n                    _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (! UuidUtils.validateUUID(vlanId)){\n               \n                if (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\n                    if (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else {\n                        final List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n                       \n                       \n                        if (!dcVnets.isEmpty()) {\n                            final DataCenterVnetVO dcVnet = dcVnets.get(0);\n                           \n                            if (dcVnet.getAccountGuestVlanMapId() != null) {\n                                final Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\n                                final AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\n                                if (map.getAccountId() != owner.getAccountId()) {\n                                    throw new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n                                }\n                               \n                            } else {\n                                final List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\n                                if (maps != null && !maps.isEmpty()) {\n                                    final int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\n                                    final int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\n                                    if (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\n                                        throw new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n                                                + owner.getAccountName());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                   \n                   \n                    if (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\n                        throw new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n                    }\n                }\n            }\n        }\n       \n        if (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\n            final Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\n                    Service.Dns);\n            final String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\n            if (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\n                if (networkDomain != null) {\n                   \n                    throw new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n                }\n            } else {\n                if (networkDomain == null) {\n                   \n                    if (aclType == ACLType.Domain) {\n                        networkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n                    } else if (aclType == ACLType.Account) {\n                        networkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n                    }\n                   \n                    if (networkDomain == null) {\n                        networkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n                    }\n                } else {\n                   \n                    if (!NetUtils.verifyDomainName(networkDomain)) {\n                        throw new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n                                + \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                                + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n                    }\n                }\n            }\n        }\n       \n       \n       \n        final boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n                && ntwkOff.getTrafficType() == TrafficType.Guest\n                && (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n                && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\n        if (cidr == null && ip6Cidr == null && cidrRequired) {\n            if (ntwkOff.getGuestType() == GuestType.Shared) {\n                throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n            } else {\n                throw new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n            }\n        }\n        checkL2OfferingServices(ntwkOff);\n       \n        if (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\n            throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n        }\n       \n        if (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\n            if (!NetUtils.validateGuestCidr(cidr)) {\n                throw new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n            }\n        }\n        final String networkDomainFinal = networkDomain;\n        final String vlanIdFinal = vlanId;\n        final Boolean subdomainAccessFinal = subdomainAccess;\n        final Network network = Transaction.execute(new TransactionCallback<Network>() {\n            @Override\n            public Network doInTransaction(final TransactionStatus status) {\n                Long physicalNetworkId = null;\n                if (pNtwk != null) {\n                    physicalNetworkId = pNtwk.getId();\n                }\n                final DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\n                final NetworkVO userNetwork = new NetworkVO();\n                userNetwork.setNetworkDomain(networkDomainFinal);\n                if (cidr != null && gateway != null) {\n                    userNetwork.setCidr(cidr);\n                    userNetwork.setGateway(gateway);\n                }\n                if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n                    userNetwork.setIp6Cidr(ip6Cidr);\n                    userNetwork.setIp6Gateway(ip6Gateway);\n                }\n                if (externalId != null) {\n                    userNetwork.setExternalId(externalId);\n                }\n                if (StringUtils.isNotBlank(routerIp)) {\n                    userNetwork.setRouterIp(routerIp);\n                }\n                if (StringUtils.isNotBlank(routerIpv6)) {\n                    userNetwork.setRouterIpv6(routerIpv6);\n                }\n                if (vlanIdFinal != null) {\n                    if (isolatedPvlan == null) {\n                        URI uri = null;\n                        if (UuidUtils.validateUUID(vlanIdFinal)){\n                           \n                            userNetwork.setVlanIdAsUUID(vlanIdFinal);\n                        } else {\n                            uri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n                        }\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n                                \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        if (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                        } else {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                        }\n                    } else {\n                        if (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            throw new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n                        }\n                        URI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with primary vlan \" + vlanIdFinal +\n                                    \" and secondary vlan \" + isolatedPvlan + \" type \" + isolatedPvlanType +\n                                    \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        userNetwork.setBroadcastDomainType(BroadcastDomainType.Pvlan);\n                        userNetwork.setPvlanType(isolatedPvlanType);\n                    }\n                }\n                final List<? extends Network> networks = setupNetwork(owner, ntwkOff, userNetwork, plan, name, displayText, true, domainId, aclType, subdomainAccessFinal, vpcId,\n                        isDisplayNetworkEnabled);\n                Network network = null;\n                if (networks == null || networks.isEmpty()) {\n                    throw new CloudRuntimeException(\"Fail to create a network\");\n                } else {\n                    if (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\n                        Network defaultGuestNetwork = networks.get(0);\n                        for (final Network nw : networks) {\n                            if (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\n                                defaultGuestNetwork = nw;\n                            }\n                        }\n                        network = defaultGuestNetwork;\n                    } else {\n                       \n                        network = networks.get(0);\n                    }\n                }\n                if (updateResourceCount) {\n                    _resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n                }\n                return network;\n            }\n        });\n        CallContext.current().setEventDetails(\"Network Id: \" + network.getId());\n        CallContext.current().putContextParameter(Network.class, network.getUuid());\n        return network;\n    }","cleancode":"@db private network createguestnetwork(final long networkofferingid, final string name, final string displaytext, final string gateway, final string cidr, string vlanid, boolean bypassvlanoverlapcheck, string networkdomain, final account owner, final long domainid, final physicalnetwork pntwk, final long zoneid, final acltype acltype, boolean subdomainaccess, final long vpcid, final string ip6gateway, final string ip6cidr, final boolean isdisplaynetworkenabled, final string isolatedpvlan, network.pvlantype isolatedpvlantype, string externalid, final boolean isprivatenetwork, string routerip, string routeripv6) throws concurrentoperationexception, insufficientcapacityexception, resourceallocationexception { final networkofferingvo ntwkoff = _networkofferingdao.findbyid(networkofferingid); final datacentervo zone = _dcdao.findbyid(zoneid); if (ntwkoff.gettraffictype() != traffictype.guest) { s_logger.warn(\"only guest networks can be created using this method\"); return null; } final boolean updateresourcecount = resourcecountneedsupdate(ntwkoff, acltype); if (updateresourcecount) { _resourcelimitmgr.checkresourcelimit(owner, resourcetype.network, isdisplaynetworkenabled); } if (ntwkoff.getstate() != networkoffering.state.enabled) { final invalidparametervalueexception ex = new invalidparametervalueexception(\"can't use specified network offering id as its state is not \" + networkoffering.state.enabled); ex.addproxyobject(ntwkoff.getuuid(), \"networkofferingid\"); throw ex; } if (pntwk.getstate() != physicalnetwork.state.enabled) { final invalidparametervalueexception ex = new invalidparametervalueexception(\"specified physical network id is\" + \" in incorrect state:\" + pntwk.getstate()); ex.addproxyobject(pntwk.getuuid(), \"physicalnetworkid\"); throw ex; } boolean ipv6 = false; if (stringutils.isnoneblank(ip6gateway, ip6cidr)) { ipv6 = true; } if (zone.getnetworktype() == networktype.basic) { if (acltype == null || acltype != acltype.domain) { throw new invalidparametervalueexception(\"only acltype=domain can be specified for network creation in basic zone\"); } final list<networkvo> guestnetworks = _networksdao.listbyzoneandtraffictype(zone.getid(), traffictype.guest); if (!guestnetworks.isempty()) { throw new invalidparametervalueexception(\"can't have more than one guest network in zone with network type \" + networktype.basic); } if (!(ntwkoff.getguesttype() == guesttype.shared && !_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat))) { throw new invalidparametervalueexception(\"for zone of type \" + networktype.basic + \" only offerings of \" + \"guesttype \" + guesttype.shared + \" with disabled \" + service.sourcenat.getname() + \" service are allowed\"); } if (domainid == null || domainid != domain.root_domain) { throw new invalidparametervalueexception(\"guest network in basic zone should be dedicated to root domain\"); } if (subdomainaccess == null) { subdomainaccess = true; } else if (!subdomainaccess) { throw new invalidparametervalueexception(\"subdomain access should be set to true for the\" + \" guest network in the basic zone\"); } if (vlanid == null) { vlanid = vlan.untagged; } else { if (!vlanid.equalsignorecase(vlan.untagged)) { throw new invalidparametervalueexception(\"only vlan \" + vlan.untagged + \" can be created in \" + \"the zone of type \" + networktype.basic); } } } else if (zone.getnetworktype() == networktype.advanced) { if (zone.issecuritygroupenabled()) { if (isolatedpvlan != null) { throw new invalidparametervalueexception(\"isolated private vlan is not supported with security group!\"); } if (ntwkoff.getguesttype() != guesttype.shared) { throw new invalidparametervalueexception(\"only shared guest network can be created in security group enabled zone\"); } if (_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat)) { throw new invalidparametervalueexception(\"service sourcenat is not allowed in security group enabled zone\"); } } if (ntwkoff.iselasticip() || ntwkoff.iselasticlb()) { throw new invalidparametervalueexception(\"elastic ip and elastic lb services are supported in zone of type \" + networktype.basic); } } if (ipv6 && netutils.getip6cidrsize(ip6cidr) != 64) { throw new invalidparametervalueexception(\"ipv6 subnet should be exactly 64-bits in size\"); } final boolean vlanspecified = vlanid != null; if (vlanspecified != ntwkoff.isspecifyvlan()) { if (vlanspecified) { throw new invalidparametervalueexception(\"can't specify vlan; corresponding offering says specifyvlan=false\"); } else { throw new invalidparametervalueexception(\"vlan has to be specified; corresponding offering says specifyvlan=true\"); } } if (vlanspecified) { uri uri = encodevlanidintobroadcasturi(vlanid, pntwk); uri secondaryuri = stringutils.isnotblank(isolatedpvlan) ? broadcastdomaintype.fromstring(isolatedpvlan) : null; if (!(bypassvlanoverlapcheck && ntwkoff.getguesttype() == guesttype.shared) && _dcdao.findvnet(zoneid, pntwk.getid(), broadcastdomaintype.getvalue(uri)).size() > 0) { throw new invalidparametervalueexception(\"the vlan tag to use for new guest network, \" + vlanid + \" is already being used for dynamic vlan allocation for the guest network in zone \" + zone.getname()); } if (secondaryuri != null && !(bypassvlanoverlapcheck && ntwkoff.getguesttype() == guesttype.shared) && _dcdao.findvnet(zoneid, pntwk.getid(), broadcastdomaintype.getvalue(secondaryuri)).size() > 0) { throw new invalidparametervalueexception(\"the vlan tag for isolated pvlan \" + isolatedpvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \" + zone.getname()); } if (! uuidutils.validateuuid(vlanid)){ if (!hasguestbypassvlanoverlapcheck(bypassvlanoverlapcheck, ntwkoff, isprivatenetwork)) { if (_networksdao.listbyzoneanduriandguesttype(zoneid, uri.tostring(), null).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + vlanid + \" already exists or overlaps with other network vlans in zone \" + zoneid); } else if (secondaryuri != null && _networksdao.listbyzoneanduriandguesttype(zoneid, secondaryuri.tostring(), null).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + isolatedpvlan + \" already exists or overlaps with other network vlans in zone \" + zoneid); } else { final list<datacentervnetvo> dcvnets = _datacentervnetdao.findvnet(zoneid, broadcastdomaintype.getvalue(uri)); if (!dcvnets.isempty()) { final datacentervnetvo dcvnet = dcvnets.get(0); if (dcvnet.getaccountguestvlanmapid() != null) { final long accountguestvlanmapid = dcvnet.getaccountguestvlanmapid(); final accountguestvlanmapvo map = _accountguestvlanmapdao.findbyid(accountguestvlanmapid); if (map.getaccountid() != owner.getaccountid()) { throw new invalidparametervalueexception(\"vlan \" + vlanid + \" is dedicated to a different account\"); } } else { final list<accountguestvlanmapvo> maps = _accountguestvlanmapdao.listaccountguestvlanmapsbyaccount(owner.getaccountid()); if (maps != null && !maps.isempty()) { final int vnetsallocatedtoaccount = _datacentervnetdao.countvnetsallocatedtoaccount(zoneid, owner.getaccountid()); final int vnetsdedicatedtoaccount = _datacentervnetdao.countvnetsdedicatedtoaccount(zoneid, owner.getaccountid()); if (vnetsallocatedtoaccount < vnetsdedicatedtoaccount) { throw new invalidparametervalueexception(\"specified vlan \" + vlanid + \" doesn't belong\" + \" to the vlan range dedicated to the owner \" + owner.getaccountname()); } } } } } } else { if (!bypassvlanoverlapcheck && _networksdao.listbyzoneanduriandguesttype(zoneid, uri.tostring(), guesttype.isolated).size() > 0 ) { throw new invalidparametervalueexception(\"there is an existing isolated\/shared network that overlaps with vlan id:\" + vlanid + \" in zone \" + zoneid); } } } } if (_networkmodel.areservicessupportedbynetworkoffering(networkofferingid, service.dns)) { final map<network.capability, string> dnscapabilities = _networkmodel.getnetworkofferingservicecapabilities(_entitymgr.findbyid(networkoffering.class, networkofferingid), service.dns); final string isupdatednssupported = dnscapabilities.get(capability.allowdnssuffixmodification); if (isupdatednssupported == null || !boolean.valueof(isupdatednssupported)) { if (networkdomain != null) { throw new invalidparametervalueexception(\"domain name change is not supported by network offering id=\" + networkofferingid + \" in zone id=\" + zoneid); } } else { if (networkdomain == null) { if (acltype == acltype.domain) { networkdomain = _networkmodel.getdomainnetworkdomain(domainid, zoneid); } else if (acltype == acltype.account) { networkdomain = _networkmodel.getaccountnetworkdomain(owner.getid(), zoneid); } if (networkdomain == null) { networkdomain = \"cs\" + long.tohexstring(owner.getid()) + guestdomainsuffix.valuein(zoneid); } } else { if (!netutils.verifydomainname(networkdomain)) { throw new invalidparametervalueexception(\"invalid network domain. total length shouldn't exceed 190 chars. each domain \" + \"label must be between 1 and 63 characters long, can contain ascii letters 'a' through 'z', the digits '0' through '9', \" + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\"); } } } } final boolean cidrrequired = zone.getnetworktype() == networktype.advanced && ntwkoff.gettraffictype() == traffictype.guest && (ntwkoff.getguesttype() == guesttype.shared || (ntwkoff.getguesttype() == guesttype.isolated && !_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat))); if (cidr == null && ip6cidr == null && cidrrequired) { if (ntwkoff.getguesttype() == guesttype.shared) { throw new invalidparametervalueexception(\"startip\/endip\/gateway\/netmask are required when create network of\" + \" type \" + network.guesttype.shared); } else { throw new invalidparametervalueexception(\"gateway\/netmask are required when create network of\" + \" type \" + guesttype.isolated + \" with service \" + service.sourcenat.getname() + \" disabled\"); } } checkl2offeringservices(ntwkoff); if (zone.getnetworktype() == networktype.basic && cidr != null) { throw new invalidparametervalueexception(\"startip\/endip\/gateway\/netmask can't be specified for zone of type \" + networktype.basic); } if (cidr != null && ntwkoff.getguesttype() == network.guesttype.isolated && ntwkoff.gettraffictype() == traffictype.guest) { if (!netutils.validateguestcidr(cidr)) { throw new invalidparametervalueexception(\"virtual guest cidr \" + cidr + \" is not rfc 1918 or 6598 compliant\"); } } final string networkdomainfinal = networkdomain; final string vlanidfinal = vlanid; final boolean subdomainaccessfinal = subdomainaccess; final network network = transaction.execute(new transactioncallback<network>() { @override public network dointransaction(final transactionstatus status) { long physicalnetworkid = null; if (pntwk != null) { physicalnetworkid = pntwk.getid(); } final datacenterdeployment plan = new datacenterdeployment(zoneid, null, null, null, null, physicalnetworkid); final networkvo usernetwork = new networkvo(); usernetwork.setnetworkdomain(networkdomainfinal); if (cidr != null && gateway != null) { usernetwork.setcidr(cidr); usernetwork.setgateway(gateway); } if (stringutils.isnoneblank(ip6gateway, ip6cidr)) { usernetwork.setip6cidr(ip6cidr); usernetwork.setip6gateway(ip6gateway); } if (externalid != null) { usernetwork.setexternalid(externalid); } if (stringutils.isnotblank(routerip)) { usernetwork.setrouterip(routerip); } if (stringutils.isnotblank(routeripv6)) { usernetwork.setrouteripv6(routeripv6); } if (vlanidfinal != null) { if (isolatedpvlan == null) { uri uri = null; if (uuidutils.validateuuid(vlanidfinal)){ usernetwork.setvlanidasuuid(vlanidfinal); } else { uri = encodevlanidintobroadcasturi(vlanidfinal, pntwk); } if (_networksdao.listbyphysicalnetworkpvlan(physicalnetworkid, uri.tostring()).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + vlanidfinal + \" already exists or overlaps with other network pvlans in zone \" + zoneid); } usernetwork.setbroadcasturi(uri); if (!vlanidfinal.equalsignorecase(vlan.untagged)) { usernetwork.setbroadcastdomaintype(broadcastdomaintype.vlan); } else { usernetwork.setbroadcastdomaintype(broadcastdomaintype.native); } } else { if (vlanidfinal.equalsignorecase(vlan.untagged)) { throw new invalidparametervalueexception(\"cannot support pvlan with untagged primary vlan!\"); } uri uri = netutils.generateuriforpvlan(vlanidfinal, isolatedpvlan, isolatedpvlantype.tostring()); if (_networksdao.listbyphysicalnetworkpvlan(physicalnetworkid, uri.tostring(), isolatedpvlantype).size() > 0) { throw new invalidparametervalueexception(\"network with primary vlan \" + vlanidfinal + \" and secondary vlan \" + isolatedpvlan + \" type \" + isolatedpvlantype + \" already exists or overlaps with other network pvlans in zone \" + zoneid); } usernetwork.setbroadcasturi(uri); usernetwork.setbroadcastdomaintype(broadcastdomaintype.pvlan); usernetwork.setpvlantype(isolatedpvlantype); } } final list<? extends network> networks = setupnetwork(owner, ntwkoff, usernetwork, plan, name, displaytext, true, domainid, acltype, subdomainaccessfinal, vpcid, isdisplaynetworkenabled); network network = null; if (networks == null || networks.isempty()) { throw new cloudruntimeexception(\"fail to create a network\"); } else { if (networks.size() > 0 && networks.get(0).getguesttype() == network.guesttype.isolated && networks.get(0).gettraffictype() == traffictype.guest) { network defaultguestnetwork = networks.get(0); for (final network nw : networks) { if (nw.getcidr() != null && nw.getcidr().equals(zone.getguestnetworkcidr())) { defaultguestnetwork = nw; } } network = defaultguestnetwork; } else { network = networks.get(0); } } if (updateresourcecount) { _resourcelimitmgr.incrementresourcecount(owner.getid(), resourcetype.network, isdisplaynetworkenabled); } return network; } }); callcontext.current().seteventdetails(\"network id: \" + network.getid()); callcontext.current().putcontextparameter(network.class, network.getuuid()); return network; }","comment":"\/\/ this method supports only guest network creation\n\/\/check resource limits\n\/\/ validate network offering\n\/\/ see networkofferingvo\n\/\/ validate physical network\n\/\/ see physicalnetworkvo.java\n\/\/ validate zone\n\/\/ in basic zone the network should have acltype=domain, domainid=1, subdomainaccess=true\n\/\/ only one guest network is supported in basic zone\n\/\/ if zone is basic, only shared network offerings w\/o source nat service are allowed\n\/\/ only account specific isolated network with sourcenat service disabled are allowed in security group \/\/ enabled zone\n\/\/don't allow eip\/elb networks in advance zone\n\/\/todo(vxlan): support vni specified \/\/ vlanid can be specified only when network offering supports it\n\/\/ aux: generate secondary uri for secondary vlan id (if provided) for performing checks\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\n\/\/ for isolated and l2 networks, don't allow to create network with vlan that already exists in the zone\n\/\/for the network that is created as part of private gateway, \/\/the vnet is not coming from the data center vnet table, so the list can be empty\n\/\/ fail network creation if specified vlan is dedicated to a different account\n\/\/ fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n\/\/ don't allow to creating shared network with given vlan id, if there already exists a isolated network or \/\/ shared network with same vlan id in the zone\n\/\/ if networkdomain is not specified, take it from the global configuration\n\/\/ tbd: networkofferingid and zoneid. send uuids instead.\n\/\/ 1) get networkdomain from the corresponding account\/domain\/zone\n\/\/ 2) if null, generate networkdomain using domain suffix from the global config variables\n\/\/ validate network domain\n\/\/ in advance zone cidr for shared networks and isolated networks w\/o source nat service can't be null - 2.2.x \/\/ limitation, remove after we introduce support for multiple ip ranges \/\/ with different cidrs for the same shared network\n\/\/ no cidr can be specified in basic zone\n\/\/ check if cidr is rfc1918 compliant if the network is guest isolated for ipv4\n\/\/logical router's uuid provided as vlan_id\n\/\/set transient field\n\/\/ for shared network","repo":"leolleeooleo\/cloudstack","code_context_2":"final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\n\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\n\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\n\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\n\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\n\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\n\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\n\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n\nthrow new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\n\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\n\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\n\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\n\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\n\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\n\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\n\nURI uri = null;\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\n\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\nuri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n\nnetwork = defaultGuestNetwork;\n} else {\n\/\/ For shared network\nnetwork = networks.get(0);\n}","code_context_10":"@DB\nprivate Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\nboolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\n\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\n\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\n\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n} else if (!subdomainAccess) {\n\n} else {\nif (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n}\n}\n} else if (zone.getNetworkType() == NetworkType.Advanced) {\nif (zone.isSecurityGroupEnabled()) {\nif (isolatedPvlan != null) {\nthrow new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n}\nif (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\nthrow new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n}\nif (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\nthrow new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\n\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\n\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\n\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n}\n}\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\n\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\n\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\nthrow new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n}\n}\nfinal String networkDomainFinal = networkDomain;\n\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\nthrow new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n}\n}\nfinal String networkDomainFinal = networkDomain;\nfinal String vlanIdFinal = vlanId;\nfinal Boolean subdomainAccessFinal = subdomainAccess;\nfinal Network network = Transaction.execute(new TransactionCallback<Network>() {\n@Override\n\nif (StringUtils.isNotBlank(routerIp)) {\nuserNetwork.setRouterIp(routerIp);\n}\nif (StringUtils.isNotBlank(routerIpv6)) {\nuserNetwork.setRouterIpv6(routerIpv6);\n}\nif (vlanIdFinal != null) {\nif (isolatedPvlan == null) {\nURI uri = null;\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\nuri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n}\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n\" already exists or overlaps with other network pvlans in zone \" + zoneId);\n}\nuserNetwork.setBroadcastUri(uri);\nif (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n\nuserNetwork.setRouterIp(routerIp);\n}\nif (StringUtils.isNotBlank(routerIpv6)) {\nuserNetwork.setRouterIpv6(routerIpv6);\n}\nif (vlanIdFinal != null) {\nif (isolatedPvlan == null) {\nURI uri = null;\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\nuri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n}\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n\" already exists or overlaps with other network pvlans in zone \" + zoneId);\n}\nuserNetwork.setBroadcastUri(uri);\nif (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n\n} else {\nif (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\nNetwork defaultGuestNetwork = networks.get(0);\nfor (final Network nw : networks) {\nif (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\ndefaultGuestNetwork = nw;\n}\n}\nnetwork = defaultGuestNetwork;\n} else {\n\/\/ For shared network\nnetwork = networks.get(0);\n}\n}\nif (updateResourceCount) {\n_resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n}\nreturn network;\n}\n});\nCallContext.current().setEventDetails(\"Network Id: \" + network.getId());","code_context_20":"@DB\nprivate Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\nboolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n\n@DB\nprivate Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\nboolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n\n@DB\nprivate Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\nboolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\n\n@DB\nprivate Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\nboolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\nfinal long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n\nfinal Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\nfinal NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n\nfinal DataCenterVO zone = _dcDao.findById(zoneId);\n\/\/ this method supports only guest network creation\nif (ntwkOff.getTrafficType() != TrafficType.Guest) {\ns_logger.warn(\"Only guest networks can be created using this method\");\nreturn null;\n}\nfinal boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n\/\/check resource limits\nif (updateResourceCount) {\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\n\n_resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n}\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n\n\/\/ Validate network offering\nif (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n\/\/ see NetworkOfferingVO\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n} else if (!subdomainAccess) {\nthrow new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n\nex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\nthrow ex;\n}\n\/\/ Validate physical network\nif (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n} else if (!subdomainAccess) {\nthrow new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n}\nif (vlanId == null) {\nvlanId = Vlan.UNTAGGED;\n} else {\n\n\/\/ see PhysicalNetworkVO.java\nfinal InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\nex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\nthrow ex;\n}\nboolean ipv6 = false;\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nipv6 = true;\n}\n\/\/ Validate zone\nif (zone.getNetworkType() == NetworkType.Basic) {\n\/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\nif (aclType == null || aclType != ACLType.Domain) {\nthrow new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n}\n\/\/ Only one guest network is supported in Basic zone\nfinal List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\nif (!guestNetworks.isEmpty()) {\nthrow new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n}\n\/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\nif (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\nthrow new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n+ Service.SourceNat.getName() + \" service are allowed\");\n}\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n} else if (!subdomainAccess) {\nthrow new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n}\nif (vlanId == null) {\nvlanId = Vlan.UNTAGGED;\n} else {\nif (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n}\n}\n} else if (zone.getNetworkType() == NetworkType.Advanced) {\n\nif (domainId == null || domainId != Domain.ROOT_DOMAIN) {\nthrow new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n}\nif (subdomainAccess == null) {\nsubdomainAccess = true;\n} else if (!subdomainAccess) {\nthrow new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n}\nif (vlanId == null) {\nvlanId = Vlan.UNTAGGED;\n} else {\nif (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n}\n}\n} else if (zone.getNetworkType() == NetworkType.Advanced) {\nif (zone.isSecurityGroupEnabled()) {\nif (isolatedPvlan != null) {\nthrow new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n}\nif (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\nthrow new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\n\nvlanId = Vlan.UNTAGGED;\n} else {\nif (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n}\n}\n} else if (zone.getNetworkType() == NetworkType.Advanced) {\nif (zone.isSecurityGroupEnabled()) {\nif (isolatedPvlan != null) {\nthrow new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n}\nif (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\nthrow new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\n\nif (isolatedPvlan != null) {\nthrow new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n}\n\/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n\/\/ enabled zone\nif (ntwkOff.getGuestType() != GuestType.Shared) {\nthrow new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n}\nif (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\nthrow new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n}\n}\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n\n\/\/don't allow eip\/elb networks in Advance zone\nif (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\nthrow new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n}\n}\nif (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\nthrow new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n}\n\/\/TODO(VXLAN): Support VNI specified\n\/\/ VlanId can be specified only when network offering supports it\nfinal boolean vlanSpecified = vlanId != null;\nif (vlanSpecified != ntwkOff.isSpecifyVlan()) {\nif (vlanSpecified) {\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\n\nthrow new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n} else {\nthrow new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n}\n}\nif (vlanSpecified) {\nURI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n\/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\n\nURI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n\/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\nif (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n\n+ zone.getName());\n}\nif (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n_dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\nthrow new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n+ zone.getName());\n}\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n}\n}\n}\n\nif (! UuidUtils.validateUUID(vlanId)){\n\/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\nif (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\nif (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n} else {\nfinal List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n\/\/for the network that is created as part of private gateway,\n\/\/the vnet is not coming from the data center vnet table, so the list can be empty\nif (!dcVnets.isEmpty()) {\nfinal DataCenterVnetVO dcVnet = dcVnets.get(0);\n\/\/ Fail network creation if specified vlan is dedicated to a different account\nif (dcVnet.getAccountGuestVlanMapId() != null) {\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n}\n}\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n\nfinal Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\nfinal AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\nif (map.getAccountId() != owner.getAccountId()) {\nthrow new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n}\n\/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n} else {\nfinal List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n}\n}\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\n\nif (maps != null && !maps.isEmpty()) {\nfinal int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\nfinal int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\nif (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\nthrow new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n+ owner.getAccountName());\n}\n}\n}\n}\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n\n}\n}\n}\n}\n} else {\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n\n\/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n\/\/ shared network with same Vlan ID in the zone\nif (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\nthrow new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n}\n}\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\n}\n}\n\/\/ If networkDomain is not specified, take it from the global configuration\nif (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\nfinal Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\n\nService.Dns);\nfinal String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\nif (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\nif (networkDomain != null) {\n\/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\nthrow new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n}\n} else {\nif (networkDomain == null) {\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n\n\/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\nif (aclType == ACLType.Domain) {\nnetworkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n} else if (aclType == ACLType.Account) {\nnetworkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n}\n\/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\nif (networkDomain == null) {\nnetworkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n}\n} else {\n\/\/ validate network domain\nif (!NetUtils.verifyDomainName(networkDomain)) {\nthrow new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n+ \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\nthrow new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n\n+ \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n}\n}\n}\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\nthrow new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n}\n}\nfinal String networkDomainFinal = networkDomain;\nfinal String vlanIdFinal = vlanId;\nfinal Boolean subdomainAccessFinal = subdomainAccess;\nfinal Network network = Transaction.execute(new TransactionCallback<Network>() {\n@Override\npublic Network doInTransaction(final TransactionStatus status) {\nLong physicalNetworkId = null;\nif (pNtwk != null) {\nphysicalNetworkId = pNtwk.getId();\n}\nfinal DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\n\n}\n\/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n\/\/ limitation, remove after we introduce support for multiple ip ranges\n\/\/ with different Cidrs for the same Shared network\nfinal boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n&& ntwkOff.getTrafficType() == TrafficType.Guest\n&& (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n&& !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\nif (cidr == null && ip6Cidr == null && cidrRequired) {\nif (ntwkOff.getGuestType() == GuestType.Shared) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n} else {\nthrow new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n}\n}\ncheckL2OfferingServices(ntwkOff);\n\/\/ No cidr can be specified in Basic zone\nif (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\nthrow new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n}\n\/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\nif (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\nif (!NetUtils.validateGuestCidr(cidr)) {\nthrow new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n}\n}\nfinal String networkDomainFinal = networkDomain;\nfinal String vlanIdFinal = vlanId;\nfinal Boolean subdomainAccessFinal = subdomainAccess;\nfinal Network network = Transaction.execute(new TransactionCallback<Network>() {\n@Override\npublic Network doInTransaction(final TransactionStatus status) {\nLong physicalNetworkId = null;\nif (pNtwk != null) {\nphysicalNetworkId = pNtwk.getId();\n}\nfinal DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\nfinal NetworkVO userNetwork = new NetworkVO();\nuserNetwork.setNetworkDomain(networkDomainFinal);\nif (cidr != null && gateway != null) {\nuserNetwork.setCidr(cidr);\n\nuserNetwork.setCidr(cidr);\nuserNetwork.setGateway(gateway);\n}\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nuserNetwork.setIp6Cidr(ip6Cidr);\nuserNetwork.setIp6Gateway(ip6Gateway);\n}\nif (externalId != null) {\nuserNetwork.setExternalId(externalId);\n}\nif (StringUtils.isNotBlank(routerIp)) {\nuserNetwork.setRouterIp(routerIp);\n}\nif (StringUtils.isNotBlank(routerIpv6)) {\nuserNetwork.setRouterIpv6(routerIpv6);\n}\nif (vlanIdFinal != null) {\nif (isolatedPvlan == null) {\nURI uri = null;\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\nuri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n}\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n\" already exists or overlaps with other network pvlans in zone \" + zoneId);\n}\nuserNetwork.setBroadcastUri(uri);\nif (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n} else {\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n}\n} else {\nif (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n}\nURI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\n\nuserNetwork.setGateway(gateway);\n}\nif (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\nuserNetwork.setIp6Cidr(ip6Cidr);\nuserNetwork.setIp6Gateway(ip6Gateway);\n}\nif (externalId != null) {\nuserNetwork.setExternalId(externalId);\n}\nif (StringUtils.isNotBlank(routerIp)) {\nuserNetwork.setRouterIp(routerIp);\n}\nif (StringUtils.isNotBlank(routerIpv6)) {\nuserNetwork.setRouterIpv6(routerIpv6);\n}\nif (vlanIdFinal != null) {\nif (isolatedPvlan == null) {\nURI uri = null;\nif (UuidUtils.validateUUID(vlanIdFinal)){\n\/\/Logical router's UUID provided as VLAN_ID\nuserNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n} else {\nuri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n}\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n\" already exists or overlaps with other network pvlans in zone \" + zoneId);\n}\nuserNetwork.setBroadcastUri(uri);\nif (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n} else {\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n}\n} else {\nif (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\nthrow new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n}\nURI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\nif (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\nthrow new InvalidParameterValueException(\"Network with primary vlan \" + vlanIdFinal +\n\nuserNetwork.setBroadcastUri(uri);\nuserNetwork.setBroadcastDomainType(BroadcastDomainType.Pvlan);\nuserNetwork.setPvlanType(isolatedPvlanType);\n}\n}\nfinal List<? extends Network> networks = setupNetwork(owner, ntwkOff, userNetwork, plan, name, displayText, true, domainId, aclType, subdomainAccessFinal, vpcId,\nisDisplayNetworkEnabled);\nNetwork network = null;\nif (networks == null || networks.isEmpty()) {\nthrow new CloudRuntimeException(\"Fail to create a network\");\n} else {\nif (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\nNetwork defaultGuestNetwork = networks.get(0);\nfor (final Network nw : networks) {\nif (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\ndefaultGuestNetwork = nw;\n}\n}\nnetwork = defaultGuestNetwork;\n} else {\n\/\/ For shared network\nnetwork = networks.get(0);\n}\n}\nif (updateResourceCount) {\n_resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n}\nreturn network;\n}\n});\nCallContext.current().setEventDetails(\"Network Id: \" + network.getId());\nCallContext.current().putContextParameter(Network.class, network.getUuid());\nreturn network;\n}","label":[1,1,0,0]}
{"id":25403,"original_code":"public static String domToString(Document document) {\n\t\tSource source = new DOMSource(document);\n\t\ttry {\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\n\t\t\ttransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\n\t\t\tStringWriter sw=new StringWriter();\n            StreamResult resultStream = new StreamResult(sw);\n            transformer.transform(source, resultStream);\n            return sw.toString();\n\t\t} catch (TransformerException e) {\n\t\t\treturn e.toString();\n\t\t}\n\t}","code":"public static String domToString(Document document) {\n\t\tSource source = new DOMSource(document);\n\t\ttry {\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\n\t\t\ttransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\n\t\t\tStringWriter sw=new StringWriter();\n            StreamResult resultStream = new StreamResult(sw);\n            transformer.transform(source, resultStream);\n            return sw.toString();\n\t\t} catch (TransformerException e) {\n\t\t\treturn e.toString();\n\t\t}\n\t}","cleancode":"public static string domtostring(document document) { source source = new domsource(document); try { transformerfactory factory = transformerfactory.newinstance(); transformer transformer = factory.newtransformer(); transformer.setoutputproperty(outputkeys. indent, \"yes\"); transformer.setoutputproperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\"); stringwriter sw=new stringwriter(); streamresult resultstream = new streamresult(sw); transformer.transform(source, resultstream); return sw.tostring(); } catch (transformerexception e) { return e.tostring(); } }","comment":"\/** * serializes a dom document to string. * * public for other transformation plugins * todo refactor out to own class * * @param document the document to serialize. * @param output the output to print errors to. * * @return the serialized document as string. *\/","repo":"mino98\/stix","code_context_2":"public static String domToString(Document document) {\nSource source = new DOMSource(document);\ntry {\nTransformerFactory factory = TransformerFactory.newInstance();\nTransformer transformer = factory.newTransformer();\ntransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\ntransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\nStringWriter sw=new StringWriter();\nStreamResult resultStream = new StreamResult(sw);\ntransformer.transform(source, resultStream);\nreturn sw.toString();\n} catch (TransformerException e) {\nreturn e.toString();\n}\n}","code_context_10":"public static String domToString(Document document) {\nSource source = new DOMSource(document);\ntry {\nTransformerFactory factory = TransformerFactory.newInstance();\nTransformer transformer = factory.newTransformer();\ntransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\ntransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\nStringWriter sw=new StringWriter();\nStreamResult resultStream = new StreamResult(sw);\ntransformer.transform(source, resultStream);\nreturn sw.toString();\n} catch (TransformerException e) {\nreturn e.toString();\n}\n}","code_context_20":"public static String domToString(Document document) {\nSource source = new DOMSource(document);\ntry {\nTransformerFactory factory = TransformerFactory.newInstance();\nTransformer transformer = factory.newTransformer();\ntransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\ntransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\nStringWriter sw=new StringWriter();\nStreamResult resultStream = new StreamResult(sw);\ntransformer.transform(source, resultStream);\nreturn sw.toString();\n} catch (TransformerException e) {\nreturn e.toString();\n}\n}","label":[1,0,0,0]}
{"id":25580,"original_code":"private void deviceClientMonitorLoop() {\n        do {\n            try {\n                \/\/ This synchronized block stops us from doing the select() if a new\n                \/\/ Device is being added.\n                \/\/ @see startMonitoringDevice()\n                synchronized (mDevices) {\n                }\n                int count = mSelector.select();\n                if (mQuit) {\n                    return;\n                }\n                synchronized (mClientsToReopen) {\n                    if (mClientsToReopen.size() > 0) {\n                        Set<Client> clients = mClientsToReopen.keySet();\n                        MonitorThread monitorThread = MonitorThread.getInstance();\n                        for (Client client : clients) {\n                            Device device = client.getDeviceImpl();\n                            int pid = client.getClientData().getPid();\n                            monitorThread.dropClient(client, false \/* notify *\/);\n                            \/\/ This is kinda bad, but if we don't wait a bit, the client\n                            \/\/ will never answer the second handshake!\n                            waitABit();\n                            int port = mClientsToReopen.get(client);\n                            if (port == IDebugPortProvider.NO_STATIC_PORT) {\n                                port = getNextDebuggerPort();\n                            }\n                            Log.d(\"DeviceMonitor\", \"Reopening \" + client);\n                            openClient(device, pid, port, monitorThread);\n                            device.update(Device.CHANGE_CLIENT_LIST);\n                        }\n                        mClientsToReopen.clear();\n                    }\n                }\n                if (count == 0) {\n                    continue;\n                }\n                Set<SelectionKey> keys = mSelector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isValid() && key.isReadable()) {\n                        Object attachment = key.attachment();\n                        if (attachment instanceof Device) {\n                            Device device = (Device)attachment;\n                            SocketChannel socket = device.getClientMonitoringSocket();\n                            if (socket != null) {\n                                try {\n                                    int length = readLength(socket, mLengthBuffer2);\n                                    processIncomingJdwpData(device, socket, length);\n                                } catch (IOException ioe) {\n                                    Log.d(\"DeviceMonitor\",\n                                            \"Error reading jdwp list: \" + ioe.getMessage());\n                                    socket.close();\n                                    \/\/ restart the monitoring of that device\n                                    synchronized (mDevices) {\n                                        if (mDevices.contains(device)) {\n                                            Log.d(\"DeviceMonitor\",\n                                                    \"Restarting monitoring service for \" + device);\n                                            startMonitoringDevice(device);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                if (mQuit == false) {\n                }\n            }\n        } while (mQuit == false);\n    }","code":"private void deviceClientMonitorLoop() {\n        do {\n            try {\n               \n               \n               \n                synchronized (mDevices) {\n                }\n                int count = mSelector.select();\n                if (mQuit) {\n                    return;\n                }\n                synchronized (mClientsToReopen) {\n                    if (mClientsToReopen.size() > 0) {\n                        Set<Client> clients = mClientsToReopen.keySet();\n                        MonitorThread monitorThread = MonitorThread.getInstance();\n                        for (Client client : clients) {\n                            Device device = client.getDeviceImpl();\n                            int pid = client.getClientData().getPid();\n                            monitorThread.dropClient(client, false);\n                           \n                           \n                            waitABit();\n                            int port = mClientsToReopen.get(client);\n                            if (port == IDebugPortProvider.NO_STATIC_PORT) {\n                                port = getNextDebuggerPort();\n                            }\n                            Log.d(\"DeviceMonitor\", \"Reopening \" + client);\n                            openClient(device, pid, port, monitorThread);\n                            device.update(Device.CHANGE_CLIENT_LIST);\n                        }\n                        mClientsToReopen.clear();\n                    }\n                }\n                if (count == 0) {\n                    continue;\n                }\n                Set<SelectionKey> keys = mSelector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isValid() && key.isReadable()) {\n                        Object attachment = key.attachment();\n                        if (attachment instanceof Device) {\n                            Device device = (Device)attachment;\n                            SocketChannel socket = device.getClientMonitoringSocket();\n                            if (socket != null) {\n                                try {\n                                    int length = readLength(socket, mLengthBuffer2);\n                                    processIncomingJdwpData(device, socket, length);\n                                } catch (IOException ioe) {\n                                    Log.d(\"DeviceMonitor\",\n                                            \"Error reading jdwp list: \" + ioe.getMessage());\n                                    socket.close();\n                                   \n                                    synchronized (mDevices) {\n                                        if (mDevices.contains(device)) {\n                                            Log.d(\"DeviceMonitor\",\n                                                    \"Restarting monitoring service for \" + device);\n                                            startMonitoringDevice(device);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                if (mQuit == false) {\n                }\n            }\n        } while (mQuit == false);\n    }","cleancode":"private void deviceclientmonitorloop() { do { try { synchronized (mdevices) { } int count = mselector.select(); if (mquit) { return; } synchronized (mclientstoreopen) { if (mclientstoreopen.size() > 0) { set<client> clients = mclientstoreopen.keyset(); monitorthread monitorthread = monitorthread.getinstance(); for (client client : clients) { device device = client.getdeviceimpl(); int pid = client.getclientdata().getpid(); monitorthread.dropclient(client, false); waitabit(); int port = mclientstoreopen.get(client); if (port == idebugportprovider.no_static_port) { port = getnextdebuggerport(); } log.d(\"devicemonitor\", \"reopening \" + client); openclient(device, pid, port, monitorthread); device.update(device.change_client_list); } mclientstoreopen.clear(); } } if (count == 0) { continue; } set<selectionkey> keys = mselector.selectedkeys(); iterator<selectionkey> iter = keys.iterator(); while (iter.hasnext()) { selectionkey key = iter.next(); iter.remove(); if (key.isvalid() && key.isreadable()) { object attachment = key.attachment(); if (attachment instanceof device) { device device = (device)attachment; socketchannel socket = device.getclientmonitoringsocket(); if (socket != null) { try { int length = readlength(socket, mlengthbuffer2); processincomingjdwpdata(device, socket, length); } catch (ioexception ioe) { log.d(\"devicemonitor\", \"error reading jdwp list: \" + ioe.getmessage()); socket.close(); synchronized (mdevices) { if (mdevices.contains(device)) { log.d(\"devicemonitor\", \"restarting monitoring service for \" + device); startmonitoringdevice(device); } } } } } } } } catch (ioexception e) { if (mquit == false) { } } } while (mquit == false); }","comment":"\/\/ this synchronized block stops us from doing the select() if a new \/\/ device is being added. \/\/ @see startmonitoringdevice()\n\/* notify *\/\n\/\/ this is kinda bad, but if we don't wait a bit, the client \/\/ will never answer the second handshake!\n\/\/ restart the monitoring of that device","repo":"lrscp\/ControlAndroidDeviceFromPC","code_context_2":"do {\ntry {\n\/\/ This synchronized block stops us from doing the select() if a new\n\/\/ Device is being added.\n\/\/ @see startMonitoringDevice()\nsynchronized (mDevices) {\n}\n\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\n\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\n\n\"Error reading jdwp list: \" + ioe.getMessage());\nsocket.close();\n\/\/ restart the monitoring of that device\nsynchronized (mDevices) {\nif (mDevices.contains(device)) {","code_context_10":"private void deviceClientMonitorLoop() {\ndo {\ntry {\n\/\/ This synchronized block stops us from doing the select() if a new\n\/\/ Device is being added.\n\/\/ @see startMonitoringDevice()\nsynchronized (mDevices) {\n}\nint count = mSelector.select();\nif (mQuit) {\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\n\nif (mQuit) {\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\nfor (Client client : clients) {\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\nif (port == IDebugPortProvider.NO_STATIC_PORT) {\nport = getNextDebuggerPort();\n}\nLog.d(\"DeviceMonitor\", \"Reopening \" + client);\nopenClient(device, pid, port, monitorThread);\ndevice.update(Device.CHANGE_CLIENT_LIST);\n\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\nfor (Client client : clients) {\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\nif (port == IDebugPortProvider.NO_STATIC_PORT) {\nport = getNextDebuggerPort();\n}\nLog.d(\"DeviceMonitor\", \"Reopening \" + client);\nopenClient(device, pid, port, monitorThread);\ndevice.update(Device.CHANGE_CLIENT_LIST);\n}\nmClientsToReopen.clear();\n\nDevice device = (Device)attachment;\nSocketChannel socket = device.getClientMonitoringSocket();\nif (socket != null) {\ntry {\nint length = readLength(socket, mLengthBuffer2);\nprocessIncomingJdwpData(device, socket, length);\n} catch (IOException ioe) {\nLog.d(\"DeviceMonitor\",\n\"Error reading jdwp list: \" + ioe.getMessage());\nsocket.close();\n\/\/ restart the monitoring of that device\nsynchronized (mDevices) {\nif (mDevices.contains(device)) {\nLog.d(\"DeviceMonitor\",\n\"Restarting monitoring service for \" + device);\nstartMonitoringDevice(device);\n}\n}\n}\n}\n}","code_context_20":"private void deviceClientMonitorLoop() {\ndo {\ntry {\n\/\/ This synchronized block stops us from doing the select() if a new\n\/\/ Device is being added.\n\/\/ @see startMonitoringDevice()\nsynchronized (mDevices) {\n}\nint count = mSelector.select();\nif (mQuit) {\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\nfor (Client client : clients) {\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\nif (port == IDebugPortProvider.NO_STATIC_PORT) {\nport = getNextDebuggerPort();\n\nprivate void deviceClientMonitorLoop() {\ndo {\ntry {\n\/\/ This synchronized block stops us from doing the select() if a new\n\/\/ Device is being added.\n\/\/ @see startMonitoringDevice()\nsynchronized (mDevices) {\n}\nint count = mSelector.select();\nif (mQuit) {\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\nfor (Client client : clients) {\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\nif (port == IDebugPortProvider.NO_STATIC_PORT) {\nport = getNextDebuggerPort();\n}\nLog.d(\"DeviceMonitor\", \"Reopening \" + client);\nopenClient(device, pid, port, monitorThread);\ndevice.update(Device.CHANGE_CLIENT_LIST);\n}\nmClientsToReopen.clear();\n}\n}\nif (count == 0) {\ncontinue;\n}\nSet<SelectionKey> keys = mSelector.selectedKeys();\nIterator<SelectionKey> iter = keys.iterator();\nwhile (iter.hasNext()) {\n\nprivate void deviceClientMonitorLoop() {\ndo {\ntry {\n\/\/ This synchronized block stops us from doing the select() if a new\n\/\/ Device is being added.\n\/\/ @see startMonitoringDevice()\nsynchronized (mDevices) {\n}\nint count = mSelector.select();\nif (mQuit) {\nreturn;\n}\nsynchronized (mClientsToReopen) {\nif (mClientsToReopen.size() > 0) {\nSet<Client> clients = mClientsToReopen.keySet();\nMonitorThread monitorThread = MonitorThread.getInstance();\nfor (Client client : clients) {\nDevice device = client.getDeviceImpl();\nint pid = client.getClientData().getPid();\nmonitorThread.dropClient(client, false \/* notify *\/);\n\/\/ This is kinda bad, but if we don't wait a bit, the client\n\/\/ will never answer the second handshake!\nwaitABit();\nint port = mClientsToReopen.get(client);\nif (port == IDebugPortProvider.NO_STATIC_PORT) {\nport = getNextDebuggerPort();\n}\nLog.d(\"DeviceMonitor\", \"Reopening \" + client);\nopenClient(device, pid, port, monitorThread);\ndevice.update(Device.CHANGE_CLIENT_LIST);\n}\nmClientsToReopen.clear();\n}\n}\nif (count == 0) {\ncontinue;\n}\nSet<SelectionKey> keys = mSelector.selectedKeys();\nIterator<SelectionKey> iter = keys.iterator();\nwhile (iter.hasNext()) {\nSelectionKey key = iter.next();\niter.remove();\n\ncontinue;\n}\nSet<SelectionKey> keys = mSelector.selectedKeys();\nIterator<SelectionKey> iter = keys.iterator();\nwhile (iter.hasNext()) {\nSelectionKey key = iter.next();\niter.remove();\nif (key.isValid() && key.isReadable()) {\nObject attachment = key.attachment();\nif (attachment instanceof Device) {\nDevice device = (Device)attachment;\nSocketChannel socket = device.getClientMonitoringSocket();\nif (socket != null) {\ntry {\nint length = readLength(socket, mLengthBuffer2);\nprocessIncomingJdwpData(device, socket, length);\n} catch (IOException ioe) {\nLog.d(\"DeviceMonitor\",\n\"Error reading jdwp list: \" + ioe.getMessage());\nsocket.close();\n\/\/ restart the monitoring of that device\nsynchronized (mDevices) {\nif (mDevices.contains(device)) {\nLog.d(\"DeviceMonitor\",\n\"Restarting monitoring service for \" + device);\nstartMonitoringDevice(device);\n}\n}\n}\n}\n}\n}\n}\n} catch (IOException e) {\nif (mQuit == false) {\n}\n}\n} while (mQuit == false);\n}","label":[1,0,0,0]}
{"id":33797,"original_code":"@POST\n\t@Path(\"\/services\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.CREATE_SERVICE + \"\\\")\")\n\tpublic RangerService createService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.createService(\" + service + \")\");\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.CREATE);\n\t\t\tUserSessionBase session = ContextUtil.getCurrentUserSession();\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tif(session != null && !session.isSpnegoEnabled()){\n\t\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\t\/\/ services including KMS\n\t\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\t}\n\t\t\tif(session != null && session.isSpnegoEnabled()){\n\t\t\t\tif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t\tif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = svcStore.createService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"createService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.createService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","code":"@POST\n\t@Path(\"\/services\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.CREATE_SERVICE + \"\\\")\")\n\tpublic RangerService createService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.createService(\" + service + \")\");\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.CREATE);\n\t\t\tUserSessionBase session = ContextUtil.getCurrentUserSession();\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tif(session != null && !session.isSpnegoEnabled()){\n\t\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\n\t\t\t\n\t\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\t}\n\t\t\tif(session != null && session.isSpnegoEnabled()){\n\t\t\t\tif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t\tif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = svcStore.createService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"createService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.createService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","cleancode":"@post @path(\"\/services\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.create_service + \"\\\")\") public rangerservice createservice(rangerservice service) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.createservice(\" + service + \")\"); } rangerservice ret = null; rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.createservice(servicename=\" + service.getname() + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(service, action.create); usersessionbase session = contextutil.getcurrentusersession(); xxservicedef xxservicedef = daomanager.getxxservicedef().findbyname(service.gettype()); if(session != null && !session.isspnegoenabled()){ bizutil.hasadminpermissions(\"services\"); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); } if(session != null && session.isspnegoenabled()){ if (session.iskeyadmin() && !xxservicedef.getimplclassname().equals(embeddedservicedefsutil.kms_impl_class_name)) { throw resterrorutil.createrestexception(\"keyadmin can create\/update\/delete only kms \", messageenums.oper_no_permission); } if ((!session.iskeyadmin() && !session.isuseradmin()) && xxservicedef.getimplclassname().equals(embeddedservicedefsutil.kms_impl_class_name)) { throw resterrorutil.createrestexception(\"user cannot create\/update\/delete kms service\", messageenums.oper_no_permission); } } ret = svcstore.createservice(service); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"createservice(\" + service + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.createservice(\" + service + \"): \" + ret); } return ret; }","comment":"\/\/ todo: as of now we are allowing sys_admin to create all the \/\/ services including kms","repo":"lw-lin\/incubator-ranger","code_context_2":"if(session != null && !session.isSpnegoEnabled()){\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n}","code_context_10":"try {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(service, Action.CREATE);\nUserSessionBase session = ContextUtil.getCurrentUserSession();\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\nif(session != null && !session.isSpnegoEnabled()){\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n}\nif(session != null && session.isSpnegoEnabled()){\nif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\nthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\nMessageEnums.OPER_NO_PERMISSION);\n}\nif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\nthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\nMessageEnums.OPER_NO_PERMISSION);","code_context_20":"@POST\n@Path(\"\/services\")\n@Produces({ \"application\/json\", \"application\/xml\" })\n@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.CREATE_SERVICE + \"\\\")\")\npublic RangerService createService(RangerService service) {\nif(LOG.isDebugEnabled()) {\nLOG.debug(\"==> ServiceREST.createService(\" + service + \")\");\n}\nRangerService ret = null;\nRangerPerfTracer perf = null;\ntry {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(service, Action.CREATE);\nUserSessionBase session = ContextUtil.getCurrentUserSession();\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\nif(session != null && !session.isSpnegoEnabled()){\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n}\nif(session != null && session.isSpnegoEnabled()){\nif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\nthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\nMessageEnums.OPER_NO_PERMISSION);\n}\nif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\nthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\nMessageEnums.OPER_NO_PERMISSION);\n}\n}\nret = svcStore.createService(service);\n} catch(WebApplicationException excp) {\nthrow excp;\n} catch(Throwable excp) {\nLOG.error(\"createService(\" + service + \") failed\", excp);\nthrow restErrorUtil.createRESTException(excp.getMessage());\n} finally {\nRangerPerfTracer.log(perf);","label":[1,0,0,0]}
{"id":33798,"original_code":"@PUT\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.UPDATE_SERVICE + \"\\\")\")\n\tpublic RangerService updateService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.updateService(): \" + service);\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.UPDATE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\/\/ services including KMS\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\tret = svcStore.updateService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"updateService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.updateService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","code":"@PUT\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.UPDATE_SERVICE + \"\\\")\")\n\tpublic RangerService updateService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.updateService(): \" + service);\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.UPDATE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\n\t\t\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\tret = svcStore.updateService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"updateService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.updateService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","cleancode":"@put @path(\"\/services\/{id}\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.update_service + \"\\\")\") public rangerservice updateservice(rangerservice service) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.updateservice(): \" + service); } rangerservice ret = null; rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.updateservice(servicename=\" + service.getname() + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(service, action.update); bizutil.hasadminpermissions(\"services\"); xxservicedef xxservicedef = daomanager.getxxservicedef().findbyname(service.gettype()); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); ret = svcstore.updateservice(service); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"updateservice(\" + service + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.updateservice(\" + service + \"): \" + ret); } return ret; }","comment":"\/\/ todo: as of now we are allowing sys_admin to create all the \/\/ services including kms","repo":"lw-lin\/incubator-ranger","code_context_2":"validator.validate(service, Action.UPDATE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());","code_context_10":"}\nRangerService ret = null;\nRangerPerfTracer perf = null;\ntry {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(service, Action.UPDATE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\nret = svcStore.updateService(service);\n} catch(WebApplicationException excp) {\nthrow excp;\n} catch(Throwable excp) {\nLOG.error(\"updateService(\" + service + \") failed\", excp);\nthrow restErrorUtil.createRESTException(excp.getMessage());\n} finally {\nRangerPerfTracer.log(perf);","code_context_20":"@PUT\n@Path(\"\/services\/{id}\")\n@Produces({ \"application\/json\", \"application\/xml\" })\n@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.UPDATE_SERVICE + \"\\\")\")\npublic RangerService updateService(RangerService service) {\nif(LOG.isDebugEnabled()) {\nLOG.debug(\"==> ServiceREST.updateService(): \" + service);\n}\nRangerService ret = null;\nRangerPerfTracer perf = null;\ntry {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(service, Action.UPDATE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\nbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\nret = svcStore.updateService(service);\n} catch(WebApplicationException excp) {\nthrow excp;\n} catch(Throwable excp) {\nLOG.error(\"updateService(\" + service + \") failed\", excp);\nthrow restErrorUtil.createRESTException(excp.getMessage());\n} finally {\nRangerPerfTracer.log(perf);\n}\nif(LOG.isDebugEnabled()) {\nLOG.debug(\"<== ServiceREST.updateService(\" + service + \"): \" + ret);\n}\nreturn ret;\n}","label":[1,0,0,0]}
{"id":33799,"original_code":"@DELETE\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.DELETE_SERVICE + \"\\\")\")\n\tpublic void deleteService(@PathParam(\"id\") Long id) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(id, Action.DELETE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\/\/ services including KMS\n\t\t\tXXService service = daoManager.getXXService().getById(id);\n\t\t\tEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\n\t\t\tif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\n\t\t\t\tList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\n\t\t\t\tif(!CollectionUtils.isEmpty(referringServices)){\n\t\t\t\t\tSet<String> referringServiceNames=new HashSet<String>();\n\t\t\t\t\tfor(XXService xXService:referringServices){\n\t\t\t\t\t\treferringServiceNames.add(xXService.getName());\n\t\t\t\t\t\tif(referringServiceNames.size()>=10){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(referringServices.size()<=10){\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames,MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames+\" and more..\",MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().getById(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\ttagStore.deleteAllTagObjectsForService(service.getName());\n\t\t\tsvcStore.deleteService(id);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"deleteService(\" + id + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t}","code":"@DELETE\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.DELETE_SERVICE + \"\\\")\")\n\tpublic void deleteService(@PathParam(\"id\") Long id) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(id, Action.DELETE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\n\t\t\n\t\t\tXXService service = daoManager.getXXService().getById(id);\n\t\t\tEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\n\t\t\tif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\n\t\t\t\tList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\n\t\t\t\tif(!CollectionUtils.isEmpty(referringServices)){\n\t\t\t\t\tSet<String> referringServiceNames=new HashSet<String>();\n\t\t\t\t\tfor(XXService xXService:referringServices){\n\t\t\t\t\t\treferringServiceNames.add(xXService.getName());\n\t\t\t\t\t\tif(referringServiceNames.size()>=10){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(referringServices.size()<=10){\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames,MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames+\" and more..\",MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().getById(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\ttagStore.deleteAllTagObjectsForService(service.getName());\n\t\t\tsvcStore.deleteService(id);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"deleteService(\" + id + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t}","cleancode":"@delete @path(\"\/services\/{id}\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.delete_service + \"\\\")\") public void deleteservice(@pathparam(\"id\") long id) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.deleteservice(\" + id + \")\"); } rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.deleteservice(serviceid=\" + id + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(id, action.delete); bizutil.hasadminpermissions(\"services\"); xxservice service = daomanager.getxxservice().getbyid(id); embeddedservicedefsutil embeddedservicedefsutil = embeddedservicedefsutil.instance(); if (service.gettype().equals(embeddedservicedefsutil.gettagservicedefid())){ list<xxservice> referringservices=daomanager.getxxservice().findbytagserviceid(id); if(!collectionutils.isempty(referringservices)){ set<string> referringservicenames=new hashset<string>(); for(xxservice xxservice:referringservices){ referringservicenames.add(xxservice.getname()); if(referringservicenames.size()>=10){ break; } } if(referringservices.size()<=10){ throw resterrorutil.createrestexception(\"tag service '\" + service.getname() + \"' is being referenced by \" + referringservices.size() + \" services: \"+referringservicenames,messageenums.oper_not_allowed_for_state); }else{ throw resterrorutil.createrestexception(\"tag service '\" + service.getname() + \"' is being referenced by \" + referringservices.size() + \" services: \"+referringservicenames+\" and more..\",messageenums.oper_not_allowed_for_state); } } } xxservicedef xxservicedef = daomanager.getxxservicedef().getbyid(service.gettype()); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); tagstore.deletealltagobjectsforservice(service.getname()); svcstore.deleteservice(id); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"deleteservice(\" + id + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.deleteservice(\" + id + \")\"); } }","comment":"\/\/ todo: as of now we are allowing sys_admin to create all the \/\/ services including kms","repo":"lw-lin\/incubator-ranger","code_context_2":"validator.validate(id, Action.DELETE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXService service = daoManager.getXXService().getById(id);\nEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();","code_context_10":"LOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n}\nRangerPerfTracer perf = null;\ntry {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(id, Action.DELETE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXService service = daoManager.getXXService().getById(id);\nEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\nif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\nList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\nif(!CollectionUtils.isEmpty(referringServices)){\nSet<String> referringServiceNames=new HashSet<String>();\nfor(XXService xXService:referringServices){\nreferringServiceNames.add(xXService.getName());\nif(referringServiceNames.size()>=10){\nbreak;","code_context_20":"@DELETE\n@Path(\"\/services\/{id}\")\n@Produces({ \"application\/json\", \"application\/xml\" })\n@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.DELETE_SERVICE + \"\\\")\")\npublic void deleteService(@PathParam(\"id\") Long id) {\nif(LOG.isDebugEnabled()) {\nLOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n}\nRangerPerfTracer perf = null;\ntry {\nif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\nperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n}\nRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\nvalidator.validate(id, Action.DELETE);\nbizUtil.hasAdminPermissions(\"Services\");\n\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\/\/ services including KMS\nXXService service = daoManager.getXXService().getById(id);\nEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\nif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\nList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\nif(!CollectionUtils.isEmpty(referringServices)){\nSet<String> referringServiceNames=new HashSet<String>();\nfor(XXService xXService:referringServices){\nreferringServiceNames.add(xXService.getName());\nif(referringServiceNames.size()>=10){\nbreak;\n}\n}\nif(referringServices.size()<=10){\nthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames,MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n}else{\nthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames+\" and more..\",MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n}\n}\n}\nXXServiceDef xxServiceDef = daoManager.getXXServiceDef().getById(service.getType());","label":[1,0,0,0]}
{"id":9239,"original_code":"@Issue(\"JENKINS-20415\")\n    @Test public void nonTopLevelItemGroup() throws Exception {\n        MatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\n        mp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\n        assertEquals(2, mp.getItems().size());\n        ListView v = new ListView(\"v\");\n        j.jenkins.addView(v);\n        v.setIncludeRegex(\".*\");\n        v.setRecurse(true);\n        \/\/ Note: did not manage to reproduce CCE until I changed expand to use \u2018for (TopLevelItem item : items)\u2019 rather than \u2018for (Item item : items)\u2019; perhaps a compiler-specific issue?\n        assertEquals(Collections.singletonList(mp), v.getItems());\n    }","code":"@Issue(\"JENKINS-20415\")\n    @Test public void nonTopLevelItemGroup() throws Exception {\n        MatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\n        mp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\n        assertEquals(2, mp.getItems().size());\n        ListView v = new ListView(\"v\");\n        j.jenkins.addView(v);\n        v.setIncludeRegex(\".*\");\n        v.setRecurse(true);\n        assertEquals(Collections.singletonList(mp), v.getItems());\n    }","cleancode":"@issue(\"jenkins-20415\") @test public void nontoplevelitemgroup() throws exception { matrixproject mp = j.jenkins.createproject(matrixproject.class, \"mp\"); mp.setaxes(new axislist(new textaxis(\"axis\", \"one\", \"two\"))); assertequals(2, mp.getitems().size()); listview v = new listview(\"v\"); j.jenkins.addview(v); v.setincluderegex(\".*\"); v.setrecurse(true); assertequals(collections.singletonlist(mp), v.getitems()); }","comment":"\/\/ note: did not manage to reproduce cce until i changed expand to use \u2018for (toplevelitem item : items)\u2019 rather than \u2018for (item item : items)\u2019; perhaps a compiler-specific issue?","repo":"mahevpm\/Mahendran_Jenkins","code_context_2":"v.setIncludeRegex(\".*\");\nv.setRecurse(true);\n\/\/ Note: did not manage to reproduce CCE until I changed expand to use \u2018for (TopLevelItem item : items)\u2019 rather than \u2018for (Item item : items)\u2019; perhaps a compiler-specific issue?\nassertEquals(Collections.singletonList(mp), v.getItems());\n}","code_context_10":"@Issue(\"JENKINS-20415\")\n@Test public void nonTopLevelItemGroup() throws Exception {\nMatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\nmp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\nassertEquals(2, mp.getItems().size());\nListView v = new ListView(\"v\");\nj.jenkins.addView(v);\nv.setIncludeRegex(\".*\");\nv.setRecurse(true);\n\/\/ Note: did not manage to reproduce CCE until I changed expand to use \u2018for (TopLevelItem item : items)\u2019 rather than \u2018for (Item item : items)\u2019; perhaps a compiler-specific issue?\nassertEquals(Collections.singletonList(mp), v.getItems());\n}","code_context_20":"@Issue(\"JENKINS-20415\")\n@Test public void nonTopLevelItemGroup() throws Exception {\nMatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\nmp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\nassertEquals(2, mp.getItems().size());\nListView v = new ListView(\"v\");\nj.jenkins.addView(v);\nv.setIncludeRegex(\".*\");\nv.setRecurse(true);\n\/\/ Note: did not manage to reproduce CCE until I changed expand to use \u2018for (TopLevelItem item : items)\u2019 rather than \u2018for (Item item : items)\u2019; perhaps a compiler-specific issue?\nassertEquals(Collections.singletonList(mp), v.getItems());\n}","label":[0,0,1,0]}
{"id":33880,"original_code":"@Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        \/\/ TODO empty method, if you want to definition & registry , use it.\n    }","code":"@Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n       \n    }","cleancode":"@override public void postprocessbeandefinitionregistry(beandefinitionregistry beandefinitionregistry) throws beansexception { }","comment":"\/\/ todo empty method, if you want to definition & registry , use it.","repo":"liuziyuan\/retrofit-spring-boot-starter","code_context_2":"@Override\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n\/\/ TODO empty method, if you want to definition & registry , use it.\n}","code_context_10":"@Override\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n\/\/ TODO empty method, if you want to definition & registry , use it.\n}","code_context_20":"@Override\npublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n\/\/ TODO empty method, if you want to definition & registry , use it.\n}","label":[0,1,0,0]}
{"id":33901,"original_code":"@Ignore \/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. Doesn't work yet.\n    @Test public void handlesMisnestedAInDivs() {\n        String h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\n        String w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\n            StringUtil.normaliseWhitespace(w),\n            StringUtil.normaliseWhitespace(doc.body().html()));\n    }","code":"@Ignore     @Test public void handlesMisnestedAInDivs() {\n        String h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\n        String w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\n            StringUtil.normaliseWhitespace(w),\n            StringUtil.normaliseWhitespace(doc.body().html()));\n    }","cleancode":"@ignore @test public void handlesmisnestedaindivs() { string h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\"; string w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\"; document doc = jsoup.parse(h); assertequals( stringutil.normalisewhitespace(w), stringutil.normalisewhitespace(doc.body().html())); }","comment":"\/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. doesn't work yet.","repo":"mikiec84\/jsoup","code_context_2":"@Ignore \/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. Doesn't work yet.\n@Test public void handlesMisnestedAInDivs() {\nString h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";","code_context_10":"@Ignore \/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. Doesn't work yet.\n@Test public void handlesMisnestedAInDivs() {\nString h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\nString w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\nDocument doc = Jsoup.parse(h);\nassertEquals(\nStringUtil.normaliseWhitespace(w),\nStringUtil.normaliseWhitespace(doc.body().html()));\n}","code_context_20":"@Ignore \/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. Doesn't work yet.\n@Test public void handlesMisnestedAInDivs() {\nString h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\nString w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\nDocument doc = Jsoup.parse(h);\nassertEquals(\nStringUtil.normaliseWhitespace(w),\nStringUtil.normaliseWhitespace(doc.body().html()));\n}","label":[0,0,0,1]}
{"id":1139,"original_code":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n    \/\/ Transform the observed (current) time series\n    if (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\n      anomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n    }\n    List<TransformationFunction> currentTimeSeriesTransformationChain =\n        getCurrentTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : currentTimeSeriesTransformationChain) {\n        anomalyDetectionContext\n            .setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\n                anomalyDetectionContext));\n      }\n    }\n    \/\/ Transform baseline time series\n    if (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\n      anomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n    }\n    List<TransformationFunction> baselineTimeSeriesTransformationChain =\n        getBaselineTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n        && CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\n        List<TimeSeries> transformedBaselines = new ArrayList<>();\n        for (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\n          TimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\n          transformedBaselines.add(transformedTS);\n        }\n        anomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n      }\n    }\n  }","code":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n   \n    if (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\n      anomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n    }\n    List<TransformationFunction> currentTimeSeriesTransformationChain =\n        getCurrentTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : currentTimeSeriesTransformationChain) {\n        anomalyDetectionContext\n            .setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\n                anomalyDetectionContext));\n      }\n    }\n   \n    if (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\n      anomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n    }\n    List<TransformationFunction> baselineTimeSeriesTransformationChain =\n        getBaselineTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n        && CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\n        List<TimeSeries> transformedBaselines = new ArrayList<>();\n        for (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\n          TimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\n          transformedBaselines.add(transformedTS);\n        }\n        anomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n      }\n    }\n  }","cleancode":"private void transformtimeseries(string metricname, anomalydetectioncontext anomalydetectioncontext) { if (anomalydetectioncontext.gettransformedcurrent(metricname) == null) { anomalydetectioncontext.settransformedcurrent(metricname, anomalydetectioncontext.getcurrent(metricname)); } list<transformationfunction> currenttimeseriestransformationchain = getcurrenttimeseriestransformationchain(); if (collectionutils.isnotempty(currenttimeseriestransformationchain)) { for (transformationfunction tf : currenttimeseriestransformationchain) { anomalydetectioncontext .settransformedcurrent(metricname, tf.transform(anomalydetectioncontext.gettransformedcurrent(metricname), anomalydetectioncontext)); } } if (anomalydetectioncontext.gettransformedbaselines(metricname) == null) { anomalydetectioncontext.settransformedbaselines(metricname, anomalydetectioncontext.getbaselines(metricname)); } list<transformationfunction> baselinetimeseriestransformationchain = getbaselinetimeseriestransformationchain(); if (collectionutils.isnotempty(anomalydetectioncontext.gettransformedbaselines(metricname)) && collectionutils.isnotempty(baselinetimeseriestransformationchain)) { for (transformationfunction tf : baselinetimeseriestransformationchain) { list<timeseries> transformedbaselines = new arraylist<>(); for (timeseries ts : anomalydetectioncontext.gettransformedbaselines(metricname)) { timeseries transformedts = tf.transform(ts, anomalydetectioncontext); transformedbaselines.add(transformedts); } anomalydetectioncontext.settransformedbaselines(metricname, transformedbaselines); } } }","comment":"\/** * transform the current time series and baselines. * * todo: apply chain-of-responsibility on the transformation chain * * @param metricname the name of the metric on which we apply transformation and prediction * @param anomalydetectioncontext anomaly detection context that contains the time series to be * transformed. *\/\n\/\/ transform the observed (current) time series\n\/\/ transform baseline time series","repo":"kupl\/starlab-benchmarks","code_context_2":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\nList<TimeSeries> transformedBaselines = new ArrayList<>();\nfor (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\nTimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\ntransformedBaselines.add(transformedTS);\n}\nanomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n}\n}\n}\n\nprivate void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));","code_context_10":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\nList<TimeSeries> transformedBaselines = new ArrayList<>();\nfor (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\nTimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\ntransformedBaselines.add(transformedTS);\n}\nanomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n}\n}\n}\n\nprivate void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\nList<TimeSeries> transformedBaselines = new ArrayList<>();\nfor (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {","code_context_20":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\nList<TimeSeries> transformedBaselines = new ArrayList<>();\nfor (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\nTimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\ntransformedBaselines.add(transformedTS);\n}\nanomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n}\n}\n}\n\nprivate void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\n\nprivate void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n\/\/ Transform the observed (current) time series\nif (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\nanomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n}\nList<TransformationFunction> currentTimeSeriesTransformationChain =\ngetCurrentTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : currentTimeSeriesTransformationChain) {\nanomalyDetectionContext\n.setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\nanomalyDetectionContext));\n}\n}\n\/\/ Transform baseline time series\nif (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\nanomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n}\nList<TransformationFunction> baselineTimeSeriesTransformationChain =\ngetBaselineTimeSeriesTransformationChain();\nif (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n&& CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\nfor (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\nList<TimeSeries> transformedBaselines = new ArrayList<>();\nfor (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\nTimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\ntransformedBaselines.add(transformedTS);\n}\nanomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n}\n}\n}","label":[0,1,0,0]}
{"id":17582,"original_code":"@Override\n  public void onManifest(String contentId, MediaPresentationDescription manifest) {\n    Handler mainHandler = player.getMainHandler();\n    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\n    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n    \/\/ Obtain Representations for playback.\n    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\n    ArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\n    ArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\n    Period period = manifest.periods.get(0);\n    boolean hasContentProtection = false;\n    for (int i = 0; i < period.adaptationSets.size(); i++) {\n      AdaptationSet adaptationSet = period.adaptationSets.get(i);\n      hasContentProtection |= adaptationSet.hasContentProtection();\n      int adaptationSetType = adaptationSet.type;\n      for (int j = 0; j < adaptationSet.representations.size(); j++) {\n        Representation representation = adaptationSet.representations.get(j);\n        if (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\n          audioRepresentationsList.add(representation);\n        } else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\n          Format format = representation.format;\n          if (format.width * format.height <= maxDecodableFrameSize) {\n            videoRepresentationsList.add(representation);\n          } else {\n            \/\/ The device isn't capable of playing this stream.\n          }\n        }\n      }\n    }\n    Representation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\n    videoRepresentationsList.toArray(videoRepresentations);\n    \/\/ Check drm support if necessary.\n    DrmSessionManager drmSessionManager = null;\n    if (hasContentProtection) {\n      if (Util.SDK_INT < 18) {\n        callback.onRenderersError(new UnsupportedOperationException(\n            \"Protected content not supported on API level \" + Util.SDK_INT));\n        return;\n      }\n      try {\n        Pair<DrmSessionManager, Boolean> drmSessionManagerData =\n            V18Compat.getDrmSessionManagerData(player, drmCallback);\n        drmSessionManager = drmSessionManagerData.first;\n        if (!drmSessionManagerData.second) {\n          \/\/ HD streams require L1 security.\n          videoRepresentations = getSdRepresentations(videoRepresentations);\n        }\n      } catch (Exception e) {\n        callback.onRenderersError(e);\n        return;\n      }\n    }\n    \/\/ Build the video renderer.\n    DataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n    ChunkSource videoChunkSource;\n    String mimeType = videoRepresentations[0].format.mimeType;\n    if (mimeType.equals(MimeTypes.VIDEO_MP4)) {\n      videoChunkSource = new DashMp4ChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n      \/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n      \/\/ definition streams.\n      videoRepresentations = getSdRepresentations(videoRepresentations);\n      videoChunkSource = new DashWebmChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else {\n      throw new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n    }\n    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\n        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n        DemoPlayer.TYPE_VIDEO);\n    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\n        drmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\n        mainHandler, player, 50);\n    \/\/ Build the audio renderer.\n    final String[] audioTrackNames;\n    final MultiTrackChunkSource audioChunkSource;\n    final MediaCodecAudioTrackRenderer audioRenderer;\n    if (audioRepresentationsList.isEmpty()) {\n      audioTrackNames = null;\n      audioChunkSource = null;\n      audioRenderer = null;\n    } else {\n      DataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n      audioTrackNames = new String[audioRepresentationsList.size()];\n      ChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\n      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\n      for (int i = 0; i < audioRepresentationsList.size(); i++) {\n        Representation representation = audioRepresentationsList.get(i);\n        Format format = representation.format;\n        audioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\n            format.audioSamplingRate + \"Hz)\";\n        audioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\n            audioEvaluator, representation);\n      }\n      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);\n      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\n          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n          DemoPlayer.TYPE_AUDIO);\n      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\n          mainHandler, player);\n    }\n    \/\/ Build the debug renderer.\n    TrackRenderer debugRenderer = debugTextView != null\n        ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n    \/\/ Invoke the callback.\n    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\n    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\n    MultiTrackChunkSource[] multiTrackChunkSources =\n        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\n    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\n    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\n    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\n    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\n    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\n    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n  }","code":"@Override\n  public void onManifest(String contentId, MediaPresentationDescription manifest) {\n    Handler mainHandler = player.getMainHandler();\n    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\n    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n   \n    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\n    ArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\n    ArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\n    Period period = manifest.periods.get(0);\n    boolean hasContentProtection = false;\n    for (int i = 0; i < period.adaptationSets.size(); i++) {\n      AdaptationSet adaptationSet = period.adaptationSets.get(i);\n      hasContentProtection |= adaptationSet.hasContentProtection();\n      int adaptationSetType = adaptationSet.type;\n      for (int j = 0; j < adaptationSet.representations.size(); j++) {\n        Representation representation = adaptationSet.representations.get(j);\n        if (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\n          audioRepresentationsList.add(representation);\n        } else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\n          Format format = representation.format;\n          if (format.width * format.height <= maxDecodableFrameSize) {\n            videoRepresentationsList.add(representation);\n          } else {\n           \n          }\n        }\n      }\n    }\n    Representation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\n    videoRepresentationsList.toArray(videoRepresentations);\n   \n    DrmSessionManager drmSessionManager = null;\n    if (hasContentProtection) {\n      if (Util.SDK_INT < 18) {\n        callback.onRenderersError(new UnsupportedOperationException(\n            \"Protected content not supported on API level \" + Util.SDK_INT));\n        return;\n      }\n      try {\n        Pair<DrmSessionManager, Boolean> drmSessionManagerData =\n            V18Compat.getDrmSessionManagerData(player, drmCallback);\n        drmSessionManager = drmSessionManagerData.first;\n        if (!drmSessionManagerData.second) {\n         \n          videoRepresentations = getSdRepresentations(videoRepresentations);\n        }\n      } catch (Exception e) {\n        callback.onRenderersError(e);\n        return;\n      }\n    }\n   \n    DataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n    ChunkSource videoChunkSource;\n    String mimeType = videoRepresentations[0].format.mimeType;\n    if (mimeType.equals(MimeTypes.VIDEO_MP4)) {\n      videoChunkSource = new DashMp4ChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n     \n     \n      videoRepresentations = getSdRepresentations(videoRepresentations);\n      videoChunkSource = new DashWebmChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else {\n      throw new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n    }\n    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\n        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n        DemoPlayer.TYPE_VIDEO);\n    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\n        drmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\n        mainHandler, player, 50);\n   \n    final String[] audioTrackNames;\n    final MultiTrackChunkSource audioChunkSource;\n    final MediaCodecAudioTrackRenderer audioRenderer;\n    if (audioRepresentationsList.isEmpty()) {\n      audioTrackNames = null;\n      audioChunkSource = null;\n      audioRenderer = null;\n    } else {\n      DataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n      audioTrackNames = new String[audioRepresentationsList.size()];\n      ChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\n      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\n      for (int i = 0; i < audioRepresentationsList.size(); i++) {\n        Representation representation = audioRepresentationsList.get(i);\n        Format format = representation.format;\n        audioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\n            format.audioSamplingRate + \"Hz)\";\n        audioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\n            audioEvaluator, representation);\n      }\n      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);\n      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\n          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n          DemoPlayer.TYPE_AUDIO);\n      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\n          mainHandler, player);\n    }\n   \n    TrackRenderer debugRenderer = debugTextView != null\n        ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n   \n    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\n    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\n    MultiTrackChunkSource[] multiTrackChunkSources =\n        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\n    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\n    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\n    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\n    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\n    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\n    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n  }","cleancode":"@override public void onmanifest(string contentid, mediapresentationdescription manifest) { handler mainhandler = player.getmainhandler(); loadcontrol loadcontrol = new defaultloadcontrol(new bufferpool(buffer_segment_size)); defaultbandwidthmeter bandwidthmeter = new defaultbandwidthmeter(mainhandler, player); int maxdecodableframesize = mediacodecutil.maxh264decodableframesize(); arraylist<representation> audiorepresentationslist = new arraylist<representation>(); arraylist<representation> videorepresentationslist = new arraylist<representation>(); period period = manifest.periods.get(0); boolean hascontentprotection = false; for (int i = 0; i < period.adaptationsets.size(); i++) { adaptationset adaptationset = period.adaptationsets.get(i); hascontentprotection |= adaptationset.hascontentprotection(); int adaptationsettype = adaptationset.type; for (int j = 0; j < adaptationset.representations.size(); j++) { representation representation = adaptationset.representations.get(j); if (adaptationsettype == adaptationset.type_audio) { audiorepresentationslist.add(representation); } else if (adaptationsettype == adaptationset.type_video) { format format = representation.format; if (format.width * format.height <= maxdecodableframesize) { videorepresentationslist.add(representation); } else { } } } } representation[] videorepresentations = new representation[videorepresentationslist.size()]; videorepresentationslist.toarray(videorepresentations); drmsessionmanager drmsessionmanager = null; if (hascontentprotection) { if (util.sdk_int < 18) { callback.onrendererserror(new unsupportedoperationexception( \"protected content not supported on api level \" + util.sdk_int)); return; } try { pair<drmsessionmanager, boolean> drmsessionmanagerdata = v18compat.getdrmsessionmanagerdata(player, drmcallback); drmsessionmanager = drmsessionmanagerdata.first; if (!drmsessionmanagerdata.second) { videorepresentations = getsdrepresentations(videorepresentations); } } catch (exception e) { callback.onrendererserror(e); return; } } datasource videodatasource = new httpdatasource(useragent, null, bandwidthmeter); chunksource videochunksource; string mimetype = videorepresentations[0].format.mimetype; if (mimetype.equals(mimetypes.video_mp4)) { videochunksource = new dashmp4chunksource(videodatasource, new adaptiveevaluator(bandwidthmeter), videorepresentations); } else if (mimetype.equals(mimetypes.video_webm)) { videorepresentations = getsdrepresentations(videorepresentations); videochunksource = new dashwebmchunksource(videodatasource, new adaptiveevaluator(bandwidthmeter), videorepresentations); } else { throw new illegalstateexception(\"unexpected mime type: \" + mimetype); } chunksamplesource videosamplesource = new chunksamplesource(videochunksource, loadcontrol, video_buffer_segments * buffer_segment_size, true, mainhandler, player, demoplayer.type_video); mediacodecvideotrackrenderer videorenderer = new mediacodecvideotrackrenderer(videosamplesource, drmsessionmanager, true, mediacodec.video_scaling_mode_scale_to_fit, 5000, mainhandler, player, 50); final string[] audiotracknames; final multitrackchunksource audiochunksource; final mediacodecaudiotrackrenderer audiorenderer; if (audiorepresentationslist.isempty()) { audiotracknames = null; audiochunksource = null; audiorenderer = null; } else { datasource audiodatasource = new httpdatasource(useragent, null, bandwidthmeter); audiotracknames = new string[audiorepresentationslist.size()]; chunksource[] audiochunksources = new chunksource[audiorepresentationslist.size()]; formatevaluator audioevaluator = new formatevaluator.fixedevaluator(); for (int i = 0; i < audiorepresentationslist.size(); i++) { representation representation = audiorepresentationslist.get(i); format format = representation.format; audiotracknames[i] = format.id + \" (\" + format.numchannels + \"ch, \" + format.audiosamplingrate + \"hz)\"; audiochunksources[i] = new dashmp4chunksource(audiodatasource, audioevaluator, representation); } audiochunksource = new multitrackchunksource(audiochunksources); samplesource audiosamplesource = new chunksamplesource(audiochunksource, loadcontrol, audio_buffer_segments * buffer_segment_size, true, mainhandler, player, demoplayer.type_audio); audiorenderer = new mediacodecaudiotrackrenderer(audiosamplesource, drmsessionmanager, true, mainhandler, player); } trackrenderer debugrenderer = debugtextview != null ? new debugtrackrenderer(debugtextview, videorenderer, videosamplesource) : null; string[][] tracknames = new string[demoplayer.renderer_count][]; tracknames[demoplayer.type_audio] = audiotracknames; multitrackchunksource[] multitrackchunksources = new multitrackchunksource[demoplayer.renderer_count]; multitrackchunksources[demoplayer.type_audio] = audiochunksource; trackrenderer[] renderers = new trackrenderer[demoplayer.renderer_count]; renderers[demoplayer.type_video] = videorenderer; renderers[demoplayer.type_audio] = audiorenderer; renderers[demoplayer.type_debug] = debugrenderer; callback.onrenderers(tracknames, multitrackchunksources, renderers); }","comment":"\/\/ obtain representations for playback.\n\/\/ the device isn't capable of playing this stream.\n\/\/ check drm support if necessary.\n\/\/ hd streams require l1 security.\n\/\/ build the video renderer.\n\/\/ todo: figure out how to query supported vpx resolutions. for now, restrict to standard \/\/ definition streams.\n\/\/ build the audio renderer.\n\/\/ build the debug renderer.\n\/\/ invoke the callback.","repo":"malmstein\/ExoPlayer","code_context_2":"LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\nDefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n\/\/ Obtain Representations for playback.\nint maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\nArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\n\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n}\n\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\n\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\n\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\n\ndrmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\nmainHandler, player, 50);\n\/\/ Build the audio renderer.\nfinal String[] audioTrackNames;\nfinal MultiTrackChunkSource audioChunkSource;\n\nmainHandler, player);\n}\n\/\/ Build the debug renderer.\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\/\/ Invoke the callback.\nString[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\ntrackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;","code_context_10":"@Override\npublic void onManifest(String contentId, MediaPresentationDescription manifest) {\nHandler mainHandler = player.getMainHandler();\nLoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\nDefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n\/\/ Obtain Representations for playback.\nint maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\nArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\nArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\nPeriod period = manifest.periods.get(0);\nboolean hasContentProtection = false;\nfor (int i = 0; i < period.adaptationSets.size(); i++) {\nAdaptationSet adaptationSet = period.adaptationSets.get(i);\nhasContentProtection |= adaptationSet.hasContentProtection();\nint adaptationSetType = adaptationSet.type;\nfor (int j = 0; j < adaptationSet.representations.size(); j++) {\n\nint adaptationSetType = adaptationSet.type;\nfor (int j = 0; j < adaptationSet.representations.size(); j++) {\nRepresentation representation = adaptationSet.representations.get(j);\nif (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\naudioRepresentationsList.add(representation);\n} else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\nFormat format = representation.format;\nif (format.width * format.height <= maxDecodableFrameSize) {\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n}\n}\n}\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\n\nif (format.width * format.height <= maxDecodableFrameSize) {\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n}\n}\n}\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\n\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\n\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else {\nthrow new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n}\nChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\nVIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_VIDEO);\nMediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\n\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else {\nthrow new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n}\nChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\nVIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_VIDEO);\nMediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\ndrmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\nmainHandler, player, 50);\n\/\/ Build the audio renderer.\nfinal String[] audioTrackNames;\nfinal MultiTrackChunkSource audioChunkSource;\nfinal MediaCodecAudioTrackRenderer audioRenderer;\nif (audioRepresentationsList.isEmpty()) {\naudioTrackNames = null;\naudioChunkSource = null;\naudioRenderer = null;\n} else {\nDataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\naudioTrackNames = new String[audioRepresentationsList.size()];\n\naudioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\naudioEvaluator, representation);\n}\naudioChunkSource = new MultiTrackChunkSource(audioChunkSources);\nSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\nAUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_AUDIO);\naudioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\nmainHandler, player);\n}\n\/\/ Build the debug renderer.\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\/\/ Invoke the callback.\nString[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\ntrackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\nMultiTrackChunkSource[] multiTrackChunkSources =\nnew MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\nmultiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\nTrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\nrenderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\n\naudioChunkSource = new MultiTrackChunkSource(audioChunkSources);\nSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\nAUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_AUDIO);\naudioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\nmainHandler, player);\n}\n\/\/ Build the debug renderer.\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\/\/ Invoke the callback.\nString[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\ntrackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\nMultiTrackChunkSource[] multiTrackChunkSources =\nnew MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\nmultiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\nTrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\nrenderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\nrenderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\nrenderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\ncallback.onRenderers(trackNames, multiTrackChunkSources, renderers);","code_context_20":"@Override\npublic void onManifest(String contentId, MediaPresentationDescription manifest) {\nHandler mainHandler = player.getMainHandler();\nLoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\nDefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n\/\/ Obtain Representations for playback.\nint maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\nArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\nArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\nPeriod period = manifest.periods.get(0);\nboolean hasContentProtection = false;\nfor (int i = 0; i < period.adaptationSets.size(); i++) {\nAdaptationSet adaptationSet = period.adaptationSets.get(i);\nhasContentProtection |= adaptationSet.hasContentProtection();\nint adaptationSetType = adaptationSet.type;\nfor (int j = 0; j < adaptationSet.representations.size(); j++) {\nRepresentation representation = adaptationSet.representations.get(j);\nif (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\naudioRepresentationsList.add(representation);\n} else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\nFormat format = representation.format;\nif (format.width * format.height <= maxDecodableFrameSize) {\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n\nDefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n\/\/ Obtain Representations for playback.\nint maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\nArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\nArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\nPeriod period = manifest.periods.get(0);\nboolean hasContentProtection = false;\nfor (int i = 0; i < period.adaptationSets.size(); i++) {\nAdaptationSet adaptationSet = period.adaptationSets.get(i);\nhasContentProtection |= adaptationSet.hasContentProtection();\nint adaptationSetType = adaptationSet.type;\nfor (int j = 0; j < adaptationSet.representations.size(); j++) {\nRepresentation representation = adaptationSet.representations.get(j);\nif (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\naudioRepresentationsList.add(representation);\n} else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\nFormat format = representation.format;\nif (format.width * format.height <= maxDecodableFrameSize) {\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n}\n}\n}\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\n\nfor (int i = 0; i < period.adaptationSets.size(); i++) {\nAdaptationSet adaptationSet = period.adaptationSets.get(i);\nhasContentProtection |= adaptationSet.hasContentProtection();\nint adaptationSetType = adaptationSet.type;\nfor (int j = 0; j < adaptationSet.representations.size(); j++) {\nRepresentation representation = adaptationSet.representations.get(j);\nif (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\naudioRepresentationsList.add(representation);\n} else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\nFormat format = representation.format;\nif (format.width * format.height <= maxDecodableFrameSize) {\nvideoRepresentationsList.add(representation);\n} else {\n\/\/ The device isn't capable of playing this stream.\n}\n}\n}\n}\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\n\/\/ The device isn't capable of playing this stream.\n}\n}\n}\n}\nRepresentation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\nvideoRepresentationsList.toArray(videoRepresentations);\n\/\/ Check drm support if necessary.\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n\nDrmSessionManager drmSessionManager = null;\nif (hasContentProtection) {\nif (Util.SDK_INT < 18) {\ncallback.onRenderersError(new UnsupportedOperationException(\n\"Protected content not supported on API level \" + Util.SDK_INT));\nreturn;\n}\ntry {\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else {\nthrow new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n}\nChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\nVIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_VIDEO);\nMediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\ndrmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\n\nPair<DrmSessionManager, Boolean> drmSessionManagerData =\nV18Compat.getDrmSessionManagerData(player, drmCallback);\ndrmSessionManager = drmSessionManagerData.first;\nif (!drmSessionManagerData.second) {\n\/\/ HD streams require L1 security.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\n}\n} catch (Exception e) {\ncallback.onRenderersError(e);\nreturn;\n}\n}\n\/\/ Build the video renderer.\nDataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else {\nthrow new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n}\nChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\nVIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_VIDEO);\nMediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\ndrmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\nmainHandler, player, 50);\n\/\/ Build the audio renderer.\nfinal String[] audioTrackNames;\nfinal MultiTrackChunkSource audioChunkSource;\nfinal MediaCodecAudioTrackRenderer audioRenderer;\nif (audioRepresentationsList.isEmpty()) {\naudioTrackNames = null;\naudioChunkSource = null;\naudioRenderer = null;\n\nChunkSource videoChunkSource;\nString mimeType = videoRepresentations[0].format.mimeType;\nif (mimeType.equals(MimeTypes.VIDEO_MP4)) {\nvideoChunkSource = new DashMp4ChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n\/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n\/\/ definition streams.\nvideoRepresentations = getSdRepresentations(videoRepresentations);\nvideoChunkSource = new DashWebmChunkSource(videoDataSource,\nnew AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n} else {\nthrow new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n}\nChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\nVIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_VIDEO);\nMediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\ndrmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\nmainHandler, player, 50);\n\/\/ Build the audio renderer.\nfinal String[] audioTrackNames;\nfinal MultiTrackChunkSource audioChunkSource;\nfinal MediaCodecAudioTrackRenderer audioRenderer;\nif (audioRepresentationsList.isEmpty()) {\naudioTrackNames = null;\naudioChunkSource = null;\naudioRenderer = null;\n} else {\nDataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\naudioTrackNames = new String[audioRepresentationsList.size()];\nChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\nFormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\nfor (int i = 0; i < audioRepresentationsList.size(); i++) {\nRepresentation representation = audioRepresentationsList.get(i);\nFormat format = representation.format;\naudioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\nformat.audioSamplingRate + \"Hz)\";\naudioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\naudioEvaluator, representation);\n}\n\n} else {\nDataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\naudioTrackNames = new String[audioRepresentationsList.size()];\nChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\nFormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\nfor (int i = 0; i < audioRepresentationsList.size(); i++) {\nRepresentation representation = audioRepresentationsList.get(i);\nFormat format = representation.format;\naudioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\nformat.audioSamplingRate + \"Hz)\";\naudioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\naudioEvaluator, representation);\n}\naudioChunkSource = new MultiTrackChunkSource(audioChunkSources);\nSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\nAUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_AUDIO);\naudioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\nmainHandler, player);\n}\n\/\/ Build the debug renderer.\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\/\/ Invoke the callback.\nString[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\ntrackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\nMultiTrackChunkSource[] multiTrackChunkSources =\nnew MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\nmultiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\nTrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\nrenderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\nrenderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\nrenderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\ncallback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n}\n\nChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\nFormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\nfor (int i = 0; i < audioRepresentationsList.size(); i++) {\nRepresentation representation = audioRepresentationsList.get(i);\nFormat format = representation.format;\naudioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\nformat.audioSamplingRate + \"Hz)\";\naudioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\naudioEvaluator, representation);\n}\naudioChunkSource = new MultiTrackChunkSource(audioChunkSources);\nSampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\nAUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\nDemoPlayer.TYPE_AUDIO);\naudioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\nmainHandler, player);\n}\n\/\/ Build the debug renderer.\nTrackRenderer debugRenderer = debugTextView != null\n? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n\/\/ Invoke the callback.\nString[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\ntrackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\nMultiTrackChunkSource[] multiTrackChunkSources =\nnew MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\nmultiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\nTrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\nrenderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\nrenderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\nrenderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\ncallback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n}","label":[1,0,0,0]}
{"id":17679,"original_code":"public void onFinished(JavaScriptObject jso) {\n\t\tapplFormItems.clear();\n\t\tapplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\n\t\tapplFormGenerators.clear();\n\t\tif (applFormItems == null || applFormItems.isEmpty()) {\n\t\t\t\/\/ when there are no application form items\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\n\t\t\tif (Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\tLocation.replace(Location.getParameter(\"targetexisting\"));\n\t\t\t}\n\t\t\t\/\/ when there are no application form items\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else {\n\t\t\t\/\/ create application form\n\t\t\tprepareApplicationForm();\n\t\t}\n\t\tsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\n\t\tevents.onFinished(jso);\n\t\tloaderImage.loadingFinished();\n\t}","code":"public void onFinished(JavaScriptObject jso) {\n\t\tapplFormItems.clear();\n\t\tapplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\n\t\tapplFormGenerators.clear();\n\t\tif (applFormItems == null || applFormItems.isEmpty()) {\n\t\t\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\t\t\n\t\t\tif (Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\tLocation.replace(Location.getParameter(\"targetexisting\"));\n\t\t\t}\n\t\t\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else {\n\t\t\n\t\t\tprepareApplicationForm();\n\t\t}\n\t\tsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\n\t\tevents.onFinished(jso);\n\t\tloaderImage.loadingFinished();\n\t}","cleancode":"public void onfinished(javascriptobject jso) { applformitems.clear(); applformitems.addall(jsonutils.<applicationformitemwithprefilledvalue>jsoaslist(jso)); applformgenerators.clear(); if (applformitems == null || applformitems.isempty()) { flextable ft = new flextable(); ft.setsize(\"100%\", \"300px\"); ft.sethtml(0, 0, new image(largeicons.instance.erroricon()) + applicationmessages.instance.noformdefined()); ft.getflexcellformatter().sethorizontalalignment(0, 0, hashorizontalalignment.align_center); ft.getflexcellformatter().setverticalalignment(0, 0, hasverticalalignment.align_middle); contents.setwidget(ft); } else if (perunentity.virtual_organization.equals(entity) && \"extension\".equalsignorecase(type) && location.getparameter(\"targetexisting\") != null) { if (location.getparameter(\"targetexisting\") != null) { location.replace(location.getparameter(\"targetexisting\")); } flextable ft = new flextable(); ft.setsize(\"100%\", \"300px\"); ft.sethtml(0, 0, new image(largeicons.instance.erroricon()) + applicationmessages.instance.alreadyvomember()); ft.getflexcellformatter().sethorizontalalignment(0, 0, hashorizontalalignment.align_center); ft.getflexcellformatter().setverticalalignment(0, 0, hasverticalalignment.align_middle); contents.setwidget(ft); } else { prepareapplicationform(); } session.getuielements().setlogtext(\"loading \" + type + \" application form items in selected vo finished:\" + applformitems.size()); events.onfinished(jso); loaderimage.loadingfinished(); }","comment":"\/** * called when loading successfully finishes. *\/\n\/\/ when there are no application form items\n\/\/ fixme - this is probably not good, since it prevents vo extension when targetexisting is specified.\n\/\/ when there are no application form items\n\/\/ create application form","repo":"licehammer\/perun","code_context_2":"public void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}\n\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\n\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\n\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}","code_context_10":"public void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}\n\npublic void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n\npublic void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}","code_context_20":"public void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}\n\npublic void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\n\npublic void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}\n\npublic void onFinished(JavaScriptObject jso) {\napplFormItems.clear();\napplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\napplFormGenerators.clear();\nif (applFormItems == null || applFormItems.isEmpty()) {\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\n\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\nif (Location.getParameter(\"targetexisting\") != null) {\nLocation.replace(Location.getParameter(\"targetexisting\"));\n}\n\/\/ when there are no application form items\nFlexTable ft = new FlexTable();\nft.setSize(\"100%\", \"300px\");\nft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\nft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\nft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\ncontents.setWidget(ft);\n} else {\n\/\/ create application form\nprepareApplicationForm();\n}\nsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\nevents.onFinished(jso);\nloaderImage.loadingFinished();\n}","label":[0,0,1,0]}
{"id":9531,"original_code":"private PathFormula withCorrectionTermsAndPC(\n      Block pBlock,\n      FormulaManagerView pFmgr,\n      BooleanFormulaManagerView pBfmgr,\n      BitvectorFormulaManagerView pBvfmgr,\n      PathFormulaManager pPfmgr,\n      CFA pCFA) {\n    BooleanFormula extendedBlockFormula = pBlock.getFormula();\n    PathFormula unprimedBlockContext = pBlock.getUnprimedContext();\n    PathFormula primedBlockContext = pBlock.getPrimedContext();\n    SSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\n    SSAMap primedSSAMap = primedBlockContext.getSsa();\n    for (String varName : programVariableNames) {\n      \/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\n      if (!primedSSAMap.containsVariable(varName)) {\n        BooleanFormula correctionterm =\n            pBvfmgr.equal(\n                makeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\n                makeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\n        extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n      } else {\n        \/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\n        if (unprimedSSAMap.containsVariable(varName)\n            && unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\n                  makeVar(\n                      pPfmgr,\n                      pFmgr,\n                      unprimedBlockContext,\n                      varName,\n                      unprimedSSAMap.getIndex(varName)));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n        \/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\n        if (primedSSAMap.getIndex(varName) < highestSSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(\n                      pPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\n                  makeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n      }\n    }\n    \/\/ Add program counter\n    int predID = getID(pBlock.getPredecessorLocation());\n    int succID = getID(pBlock.getSuccessorLocation());\n    BooleanFormula pcBefore =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(predID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\n    BooleanFormula pcAfter =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(succID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\n    extendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n    @SuppressWarnings(\"deprecation\")\n    \/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n    \/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\n    PathFormula pathFormula =\n        pPfmgr.makeNewPathFormula(\n            primedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\n    return pathFormula;\n  }","code":"private PathFormula withCorrectionTermsAndPC(\n      Block pBlock,\n      FormulaManagerView pFmgr,\n      BooleanFormulaManagerView pBfmgr,\n      BitvectorFormulaManagerView pBvfmgr,\n      PathFormulaManager pPfmgr,\n      CFA pCFA) {\n    BooleanFormula extendedBlockFormula = pBlock.getFormula();\n    PathFormula unprimedBlockContext = pBlock.getUnprimedContext();\n    PathFormula primedBlockContext = pBlock.getPrimedContext();\n    SSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\n    SSAMap primedSSAMap = primedBlockContext.getSsa();\n    for (String varName : programVariableNames) {\n     \n      if (!primedSSAMap.containsVariable(varName)) {\n        BooleanFormula correctionterm =\n            pBvfmgr.equal(\n                makeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\n                makeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\n        extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n      } else {\n       \n        if (unprimedSSAMap.containsVariable(varName)\n            && unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\n                  makeVar(\n                      pPfmgr,\n                      pFmgr,\n                      unprimedBlockContext,\n                      varName,\n                      unprimedSSAMap.getIndex(varName)));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n       \n        if (primedSSAMap.getIndex(varName) < highestSSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(\n                      pPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\n                  makeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n      }\n    }\n   \n    int predID = getID(pBlock.getPredecessorLocation());\n    int succID = getID(pBlock.getSuccessorLocation());\n    BooleanFormula pcBefore =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(predID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\n    BooleanFormula pcAfter =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(succID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\n    extendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n    @SuppressWarnings(\"deprecation\")\n   \n   \n    PathFormula pathFormula =\n        pPfmgr.makeNewPathFormula(\n            primedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\n    return pathFormula;\n  }","cleancode":"private pathformula withcorrectiontermsandpc( block pblock, formulamanagerview pfmgr, booleanformulamanagerview pbfmgr, bitvectorformulamanagerview pbvfmgr, pathformulamanager ppfmgr, cfa pcfa) { booleanformula extendedblockformula = pblock.getformula(); pathformula unprimedblockcontext = pblock.getunprimedcontext(); pathformula primedblockcontext = pblock.getprimedcontext(); ssamap unprimedssamap = unprimedblockcontext.getssa(); ssamap primedssamap = primedblockcontext.getssa(); for (string varname : programvariablenames) { if (!primedssamap.containsvariable(varname)) { booleanformula correctionterm = pbvfmgr.equal( makevar(ppfmgr, pfmgr, this.unprimedcontext, varname, standard_unprimed_ssa), makevar(ppfmgr, pfmgr, this.primedcontext, varname, highestssa)); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } else { if (unprimedssamap.containsvariable(varname) && unprimedssamap.getindex(varname) > standard_unprimed_ssa) { booleanformula correctionterm = pbvfmgr.equal( makevar(ppfmgr, pfmgr, unprimedblockcontext, varname, standard_unprimed_ssa), makevar( ppfmgr, pfmgr, unprimedblockcontext, varname, unprimedssamap.getindex(varname))); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } if (primedssamap.getindex(varname) < highestssa) { booleanformula correctionterm = pbvfmgr.equal( makevar( ppfmgr, pfmgr, primedblockcontext, varname, primedssamap.getindex(varname)), makevar(ppfmgr, pfmgr, primedblockcontext, varname, highestssa)); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } } } int predid = getid(pblock.getpredecessorlocation()); int succid = getid(pblock.getsuccessorlocation()); booleanformula pcbefore = pfmgr.instantiate( makeprogramcounterformula(predid, pbvfmgr, pcfa), ssamap.emptyssamap().withdefault(standard_unprimed_ssa)); booleanformula pcafter = pfmgr.instantiate( makeprogramcounterformula(succid, pbvfmgr, pcfa), ssamap.emptyssamap().withdefault(pc_primed_ssa)); extendedblockformula = pbfmgr.and(pcbefore, extendedblockformula, pcafter); @suppresswarnings(\"deprecation\") pathformula pathformula = ppfmgr.makenewpathformula( primedblockcontext.updateformula(extendedblockformula), this.primedcontext.getssa()); return pathformula; }","comment":"\/** * adds correction terms of the following form for variables v. * * <ul> * <li> if primed context has no v, conjoins v_1 = v_max (v doesn't change in this block) * <li> if primed context has index i &lt; max, conjoins v_i = v_max * <li> if unprimed context has has index i &gt; 1, conjoins v_1 = v_i * <\/ul> * * adds formulas for program counter before and after block transition. * * @return a path formula with the above mentioned adjustments to the block transition formula. * the ssa map contains the indices for all primed variables including those not in the * original block formula and the pc. the pointer target set is the same as before. *\/\n\/\/ add general correction v_1 = v_max if v is not in block formula (= not in primed context),\n\/\/ add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\n\/\/ add high correction v_? = v_max if primed context for v has lower index (? < max)\n\/\/ add program counter\n\/\/ todo: seems buggy because it implicitly combines extendedblockformula and \/\/ primedcontext.getssa() with pointertargetset of primedblockcontext, is this correct?","repo":"lembergerth\/cpachecker","code_context_2":"private PathFormula withCorrectionTermsAndPC(\nBlock pBlock,\nFormulaManagerView pFmgr,\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}\n\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\n\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\n\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\n\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(","code_context_10":"private PathFormula withCorrectionTermsAndPC(\nBlock pBlock,\nFormulaManagerView pFmgr,\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}\n\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\n\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\n\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}","code_context_20":"private PathFormula withCorrectionTermsAndPC(\nBlock pBlock,\nFormulaManagerView pFmgr,\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}\n\nprivate PathFormula withCorrectionTermsAndPC(\nBlock pBlock,\nFormulaManagerView pFmgr,\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n\nBlock pBlock,\nFormulaManagerView pFmgr,\nBooleanFormulaManagerView pBfmgr,\nBitvectorFormulaManagerView pBvfmgr,\nPathFormulaManager pPfmgr,\nCFA pCFA) {\nBooleanFormula extendedBlockFormula = pBlock.getFormula();\nPathFormula unprimedBlockContext = pBlock.getUnprimedContext();\nPathFormula primedBlockContext = pBlock.getPrimedContext();\nSSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\nSSAMap primedSSAMap = primedBlockContext.getSsa();\nfor (String varName : programVariableNames) {\n\/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\nif (!primedSSAMap.containsVariable(varName)) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\n\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n} else {\n\/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\nif (unprimedSSAMap.containsVariable(varName)\n&& unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\n\nmakeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\nmakeVar(\npPfmgr,\npFmgr,\nunprimedBlockContext,\nvarName,\nunprimedSSAMap.getIndex(varName)));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n\/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\nif (primedSSAMap.getIndex(varName) < highestSSA) {\nBooleanFormula correctionterm =\npBvfmgr.equal(\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}\n\nmakeVar(\npPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\nmakeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\nextendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n}\n}\n}\n\/\/ Add program counter\nint predID = getID(pBlock.getPredecessorLocation());\nint succID = getID(pBlock.getSuccessorLocation());\nBooleanFormula pcBefore =\npFmgr.instantiate(\nmakeProgramcounterFormula(predID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\nBooleanFormula pcAfter =\npFmgr.instantiate(\nmakeProgramcounterFormula(succID, pBvfmgr, pCFA),\nSSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\nextendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n@SuppressWarnings(\"deprecation\")\n\/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n\/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\nPathFormula pathFormula =\npPfmgr.makeNewPathFormula(\nprimedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\nreturn pathFormula;\n}","label":[0,0,1,0]}
{"id":1459,"original_code":"@Test\n    public void testPredicateTypeMismatch()\n    {\n        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n                getMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\n                Optional.of(this::mockApplyProjection),\n                Optional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n            \/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n            \/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n            \/\/ but dest_col_a has mismatched type compared to source domain\n            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n                    .execute(MOCK_SESSION, session -> {\n                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n                                .isInstanceOf(TrinoException.class)\n                                \/\/ TODO report source column name instead of ColumnHandle toString\n                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n                                        \"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n                    });\n        }\n    }","code":"@Test\n    public void testPredicateTypeMismatch()\n    {\n        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n                getMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\n                Optional.of(this::mockApplyProjection),\n                Optional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n           \n           \n           \n            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n                    .execute(MOCK_SESSION, session -> {\n                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n                                .isInstanceOf(TrinoException.class)\n                               \n                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n                                        \"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n                    });\n        }\n    }","cleancode":"@test public void testpredicatetypemismatch() { try (localqueryrunner queryrunner = createlocalqueryrunner( getmockapplyredirectafterpredicatepushdown(type_mismatched_redirection_mapping_bc, optional.of(immutableset.of(source_column_handle_b))), optional.of(this::mockapplyprojection), optional.of(getmockapplyfilter(immutableset.of(source_column_handle_c))))) { transaction(queryrunner.gettransactionmanager(), queryrunner.getaccesscontrol()) .execute(mock_session, session -> { assertthatthrownby(() -> queryrunner.createplan(session, \"select source_col_b from test_table where source_col_c = 'foo'\", warningcollector.noop)) .isinstanceof(trinoexception.class) .hasmessagematching(\"redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" + \"different from source column mock_catalog.test_schema.test_table.mockconnectorcolumnhandle.*source_col_c.* type: varchar\"); }); } }","comment":"\/\/ after 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned \/\/ redirection results in project('dest_col_b') -> filter('dest_col_c = 1') -> tablescan for such case \/\/ but dest_col_a has mismatched type compared to source domain\n\/\/ todo report source column name instead of columnhandle tostring","repo":"liujiansxcd\/trino","code_context_2":"Optional.of(this::mockApplyProjection),\nOptional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n\/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n\/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n\/\/ but dest_col_a has mismatched type compared to source domain\ntransaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n.execute(MOCK_SESSION, session -> {\n\nassertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n.isInstanceOf(TrinoException.class)\n\/\/ TODO report source column name instead of ColumnHandle toString\n.hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n\"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");","code_context_10":"@Test\npublic void testPredicateTypeMismatch()\n{\ntry (LocalQueryRunner queryRunner = createLocalQueryRunner(\ngetMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\nOptional.of(this::mockApplyProjection),\nOptional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n\/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n\/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n\/\/ but dest_col_a has mismatched type compared to source domain\ntransaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n.execute(MOCK_SESSION, session -> {\nassertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n.isInstanceOf(TrinoException.class)\n\/\/ TODO report source column name instead of ColumnHandle toString\n.hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n\"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n});\n}\n}\n\ngetMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\nOptional.of(this::mockApplyProjection),\nOptional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n\/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n\/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n\/\/ but dest_col_a has mismatched type compared to source domain\ntransaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n.execute(MOCK_SESSION, session -> {\nassertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n.isInstanceOf(TrinoException.class)\n\/\/ TODO report source column name instead of ColumnHandle toString\n.hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n\"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n});\n}\n}","code_context_20":"@Test\npublic void testPredicateTypeMismatch()\n{\ntry (LocalQueryRunner queryRunner = createLocalQueryRunner(\ngetMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\nOptional.of(this::mockApplyProjection),\nOptional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n\/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n\/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n\/\/ but dest_col_a has mismatched type compared to source domain\ntransaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n.execute(MOCK_SESSION, session -> {\nassertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n.isInstanceOf(TrinoException.class)\n\/\/ TODO report source column name instead of ColumnHandle toString\n.hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n\"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n});\n}\n}\n\n@Test\npublic void testPredicateTypeMismatch()\n{\ntry (LocalQueryRunner queryRunner = createLocalQueryRunner(\ngetMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\nOptional.of(this::mockApplyProjection),\nOptional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n\/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n\/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n\/\/ but dest_col_a has mismatched type compared to source domain\ntransaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n.execute(MOCK_SESSION, session -> {\nassertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n.isInstanceOf(TrinoException.class)\n\/\/ TODO report source column name instead of ColumnHandle toString\n.hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n\"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n});\n}\n}","label":[1,0,0,0]}
{"id":34339,"original_code":"private void createRowFactory(){\n        \/\/Play selected song from playlist, to skip forward or back\n        tableView.setRowFactory( tv -> {\n            TableRow<PlaylistSongDisplay> row = new TableRow<>();\n            row.setOnMouseClicked(event -> {\n                \/\/On double click of song, play it\n                if (event.getClickCount() == 2 && (! row.isEmpty()) ) {\n                    playlist.playPlaylistSelection(songHashMap.get(row.getItem()));\n                }\n                \/\/On right click open context menu\n                if (event.getButton() == MouseButton.SECONDARY) {\n                    ObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n                    ArrayList<Song> selectedIDs = new ArrayList<>();\n                    for (PlaylistSongDisplay rowSelected : selectedItems) {\n                        selectedIDs.add(songHashMap.get(rowSelected));\n                    }\n                    \/\/Allow for removal of selected songs from playlist\n                    removeSelected.setOnAction((actionEvent -> {\n                        playlist.removePlaylistSelection(selectedIDs);\n                        for (Song s: selectedIDs){\n                            playlistList.remove(songHashMapRev.get(s));\n                        }\n                    }));\n                    \/\/Allow for clearing entire playlist\n                    clearPlaylist.setOnAction(actionEvent -> {\n                        playlist.clearPlaylist();\n                        emptyTable();\n                    });\n                    \/\/Show context menu at location of click\n                    playlistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n                }\n                \/\/Undo selection if user clicks away from focused row\n                if (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\n                    tableView.getSelectionModel().clearSelection();\n                }\n            });\n            return row;\n        });\n        \/\/TODO: Add drag listener to move songs around as desired\n    }","code":"private void createRowFactory(){\n       \n        tableView.setRowFactory( tv -> {\n            TableRow<PlaylistSongDisplay> row = new TableRow<>();\n            row.setOnMouseClicked(event -> {\n               \n                if (event.getClickCount() == 2 && (! row.isEmpty()) ) {\n                    playlist.playPlaylistSelection(songHashMap.get(row.getItem()));\n                }\n               \n                if (event.getButton() == MouseButton.SECONDARY) {\n                    ObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n                    ArrayList<Song> selectedIDs = new ArrayList<>();\n                    for (PlaylistSongDisplay rowSelected : selectedItems) {\n                        selectedIDs.add(songHashMap.get(rowSelected));\n                    }\n                   \n                    removeSelected.setOnAction((actionEvent -> {\n                        playlist.removePlaylistSelection(selectedIDs);\n                        for (Song s: selectedIDs){\n                            playlistList.remove(songHashMapRev.get(s));\n                        }\n                    }));\n                   \n                    clearPlaylist.setOnAction(actionEvent -> {\n                        playlist.clearPlaylist();\n                        emptyTable();\n                    });\n                   \n                    playlistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n                }\n               \n                if (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\n                    tableView.getSelectionModel().clearSelection();\n                }\n            });\n            return row;\n        });\n       \n    }","cleancode":"private void createrowfactory(){ tableview.setrowfactory( tv -> { tablerow<playlistsongdisplay> row = new tablerow<>(); row.setonmouseclicked(event -> { if (event.getclickcount() == 2 && (! row.isempty()) ) { playlist.playplaylistselection(songhashmap.get(row.getitem())); } if (event.getbutton() == mousebutton.secondary) { observablelist<playlistsongdisplay> selecteditems = tableview.getselectionmodel().getselecteditems(); arraylist<song> selectedids = new arraylist<>(); for (playlistsongdisplay rowselected : selecteditems) { selectedids.add(songhashmap.get(rowselected)); } removeselected.setonaction((actionevent -> { playlist.removeplaylistselection(selectedids); for (song s: selectedids){ playlistlist.remove(songhashmaprev.get(s)); } })); clearplaylist.setonaction(actionevent -> { playlist.clearplaylist(); emptytable(); }); playlistcontextmenu.show(row, event.getscreenx(), event.getscreeny()); } if (event.getbutton() == mousebutton.primary && (row.isempty())){ tableview.getselectionmodel().clearselection(); } }); return row; }); }","comment":"\/\/play selected song from playlist, to skip forward or back\n\/\/on double click of song, play it\n\/\/on right click open context menu\n\/\/allow for removal of selected songs from playlist\n\/\/allow for clearing entire playlist\n\/\/show context menu at location of click\n\/\/undo selection if user clicks away from focused row\n\/\/todo: add drag listener to move songs around as desired","repo":"justinlautner\/Cassette","code_context_2":"private void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\n\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\n\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\n\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}","code_context_10":"private void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n\nprivate void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\nprivate void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\n\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}\n\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}","code_context_20":"private void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n\nprivate void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\n\nprivate void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n\nprivate void createRowFactory(){\n\/\/Play selected song from playlist, to skip forward or back\ntableView.setRowFactory( tv -> {\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n\nTableRow<PlaylistSongDisplay> row = new TableRow<>();\nrow.setOnMouseClicked(event -> {\n\/\/On double click of song, play it\nif (event.getClickCount() == 2 && (! row.isEmpty()) ) {\nplaylist.playPlaylistSelection(songHashMap.get(row.getItem()));\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}\n\n}\n\/\/On right click open context menu\nif (event.getButton() == MouseButton.SECONDARY) {\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}\n\nObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\nArrayList<Song> selectedIDs = new ArrayList<>();\nfor (PlaylistSongDisplay rowSelected : selectedItems) {\nselectedIDs.add(songHashMap.get(rowSelected));\n}\n\/\/Allow for removal of selected songs from playlist\nremoveSelected.setOnAction((actionEvent -> {\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}\n\nplaylist.removePlaylistSelection(selectedIDs);\nfor (Song s: selectedIDs){\nplaylistList.remove(songHashMapRev.get(s));\n}\n}));\n\/\/Allow for clearing entire playlist\nclearPlaylist.setOnAction(actionEvent -> {\nplaylist.clearPlaylist();\nemptyTable();\n});\n\/\/Show context menu at location of click\nplaylistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n}\n\/\/Undo selection if user clicks away from focused row\nif (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\ntableView.getSelectionModel().clearSelection();\n}\n});\nreturn row;\n});\n\/\/TODO: Add drag listener to move songs around as desired\n}","label":[0,1,0,0]}
{"id":34410,"original_code":"@Override\n    public void suspend() {\n        \/\/ TODO unsubscribe from everything? And resubscribe on resume?\n        super.suspend();\n        if (executor != null) executor.shutdownNow();\n        executorQueued.set(false);\n    }","code":"@Override\n    public void suspend() {\n       \n        super.suspend();\n        if (executor != null) executor.shutdownNow();\n        executorQueued.set(false);\n    }","cleancode":"@override public void suspend() { super.suspend(); if (executor != null) executor.shutdownnow(); executorqueued.set(false); }","comment":"\/\/ todo unsubscribe from everything? and resubscribe on resume?","repo":"kiuby88\/incubator-brooklyn","code_context_2":"@Override\npublic void suspend() {\n\/\/ TODO unsubscribe from everything? And resubscribe on resume?\nsuper.suspend();\nif (executor != null) executor.shutdownNow();","code_context_10":"@Override\npublic void suspend() {\n\/\/ TODO unsubscribe from everything? And resubscribe on resume?\nsuper.suspend();\nif (executor != null) executor.shutdownNow();\nexecutorQueued.set(false);\n}","code_context_20":"@Override\npublic void suspend() {\n\/\/ TODO unsubscribe from everything? And resubscribe on resume?\nsuper.suspend();\nif (executor != null) executor.shutdownNow();\nexecutorQueued.set(false);\n}","label":[1,0,0,0]}
{"id":1656,"original_code":"private void onSessionError(final int sessionId) {\n        \/\/ TODO(qinmin): pass the error code to native.\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                nativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n            }\n        });\n    }","code":"private void onSessionError(final int sessionId) {\n       \n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                nativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n            }\n        });\n    }","cleancode":"private void onsessionerror(final int sessionid) { mhandler.post(new runnable() { @override public void run() { nativeonsessionerror(mnativemediadrmbridge, sessionid); } }); }","comment":"\/\/ todo(qinmin): pass the error code to native.","repo":"kjthegod\/chromium","code_context_2":"private void onSessionError(final int sessionId) {\n\/\/ TODO(qinmin): pass the error code to native.\nmHandler.post(new Runnable() {\n@Override","code_context_10":"private void onSessionError(final int sessionId) {\n\/\/ TODO(qinmin): pass the error code to native.\nmHandler.post(new Runnable() {\n@Override\npublic void run() {\nnativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n}\n});\n}","code_context_20":"private void onSessionError(final int sessionId) {\n\/\/ TODO(qinmin): pass the error code to native.\nmHandler.post(new Runnable() {\n@Override\npublic void run() {\nnativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n}\n});\n}","label":[0,1,0,0]}
{"id":18096,"original_code":"@SuppressWarnings(\"unchecked\")\n\tpublic static void SetPageFacet(int facetType, String facetName, long delay) {\n\t\tFacesContext context = FacesContext.getCurrentInstance();\n\t\tMap viewScope = context.getViewRoot().getViewMap();\n\t\tString previousFacet = \"\";\n\t\tString selectedFacet = \"\";\n\t\ttry {\n\t\t\tswitch (facetType) {\n\t\t\tcase 1:\/\/ Login\n\t\t\t\tpreviousFacet = \"previousLoginFacet\";\n\t\t\t\tselectedFacet = \"selectedLoginFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\/\/ Home\n\t\t\t\tpreviousFacet = \"previousHomeFacet\";\n\t\t\t\tselectedFacet = \"selectedHomeFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\/\/ FormPlaceholderFacet\n\t\t\t\tpreviousFacet = \"previousFormPlaceholderFacet\";\n\t\t\t\tselectedFacet = \"selectedFormPlaceholderFacet\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (facetName.equals(\"Previous\")) {\n\t\t\t\tSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n\t\t\t} else if (!facetName.equals(viewScope.get(selectedFacet))) {\n\t\t\t\tif (delay > 0) {\n\t\t\t\t\tThread.currentThread();\n\t\t\t\t\tThread.sleep(delay);\n\t\t\t\t}\n\t\t\t\tviewScope.put(previousFacet, viewScope.get(selectedFacet));\n\t\t\t\tviewScope.put(selectedFacet, facetName);\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","code":"@SuppressWarnings(\"unchecked\")\n\tpublic static void SetPageFacet(int facetType, String facetName, long delay) {\n\t\tFacesContext context = FacesContext.getCurrentInstance();\n\t\tMap viewScope = context.getViewRoot().getViewMap();\n\t\tString previousFacet = \"\";\n\t\tString selectedFacet = \"\";\n\t\ttry {\n\t\t\tswitch (facetType) {\n\t\t\tcase 1\n\t\t\t\tpreviousFacet = \"previousLoginFacet\";\n\t\t\t\tselectedFacet = \"selectedLoginFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 2\n\t\t\t\tpreviousFacet = \"previousHomeFacet\";\n\t\t\t\tselectedFacet = \"selectedHomeFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 3\n\t\t\t\tpreviousFacet = \"previousFormPlaceholderFacet\";\n\t\t\t\tselectedFacet = \"selectedFormPlaceholderFacet\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (facetName.equals(\"Previous\")) {\n\t\t\t\tSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n\t\t\t} else if (!facetName.equals(viewScope.get(selectedFacet))) {\n\t\t\t\tif (delay > 0) {\n\t\t\t\t\tThread.currentThread();\n\t\t\t\t\tThread.sleep(delay);\n\t\t\t\t}\n\t\t\t\tviewScope.put(previousFacet, viewScope.get(selectedFacet));\n\t\t\t\tviewScope.put(selectedFacet, facetName);\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","cleancode":"@suppresswarnings(\"unchecked\") public static void setpagefacet(int facettype, string facetname, long delay) { facescontext context = facescontext.getcurrentinstance(); map viewscope = context.getviewroot().getviewmap(); string previousfacet = \"\"; string selectedfacet = \"\"; try { switch (facettype) { case 1 previousfacet = \"previousloginfacet\"; selectedfacet = \"selectedloginfacet\"; break; case 2 previousfacet = \"previoushomefacet\"; selectedfacet = \"selectedhomefacet\"; break; case 3 previousfacet = \"previousformplaceholderfacet\"; selectedfacet = \"selectedformplaceholderfacet\"; break; } if (facetname.equals(\"previous\")) { setpagefacet(facettype, viewscope.get(previousfacet).tostring(), delay); } else if (!facetname.equals(viewscope.get(selectedfacet))) { if (delay > 0) { thread.currentthread(); thread.sleep(delay); } viewscope.put(previousfacet, viewscope.get(selectedfacet)); viewscope.put(selectedfacet, facetname); } } catch (interruptedexception e) { e.printstacktrace(); } }","comment":"\/\/ todo: see if we are going to use this.\n\/\/ login\n\/\/ home\n\/\/ formplaceholderfacet","repo":"johnjardin\/ukuvuma-xpages-boilerplate","code_context_2":"@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\nviewScope.put(selectedFacet, facetName);\n}\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\n\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\n\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";","code_context_10":"@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\nviewScope.put(selectedFacet, facetName);\n}\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n\n@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\n\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);","code_context_20":"@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\nviewScope.put(selectedFacet, facetName);\n}\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n\n@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\n\n@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\nviewScope.put(selectedFacet, facetName);\n}\n} catch (InterruptedException e) {\ne.printStackTrace();\n\n@SuppressWarnings(\"unchecked\")\npublic static void SetPageFacet(int facetType, String facetName, long delay) {\nFacesContext context = FacesContext.getCurrentInstance();\nMap viewScope = context.getViewRoot().getViewMap();\nString previousFacet = \"\";\nString selectedFacet = \"\";\ntry {\nswitch (facetType) {\ncase 1:\/\/ Login\npreviousFacet = \"previousLoginFacet\";\nselectedFacet = \"selectedLoginFacet\";\nbreak;\ncase 2:\/\/ Home\npreviousFacet = \"previousHomeFacet\";\nselectedFacet = \"selectedHomeFacet\";\nbreak;\ncase 3:\/\/ FormPlaceholderFacet\npreviousFacet = \"previousFormPlaceholderFacet\";\nselectedFacet = \"selectedFormPlaceholderFacet\";\nbreak;\n}\nif (facetName.equals(\"Previous\")) {\nSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n} else if (!facetName.equals(viewScope.get(selectedFacet))) {\nif (delay > 0) {\nThread.currentThread();\nThread.sleep(delay);\n}\nviewScope.put(previousFacet, viewScope.get(selectedFacet));\nviewScope.put(selectedFacet, facetName);\n}\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}","label":[1,0,0,0]}
{"id":9907,"original_code":"public static List<String> contentPrefixList(int flags)\n\t{\n\t\tfinal List<String> contentPrefixList = new ArrayList<String>();\n\t\tif ((flags & JMF) != 0) {\n\t\t\tcontentPrefixList.add(\"javax\");\n\t\t\tcontentPrefixList.add(\"com.sun\");\n\t\t\tcontentPrefixList.add(\"com.ibm\");\n\t\t}\n\t\tif ((flags & FMJ_NATIVE) != 0) {\n\t\t\tif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\t\t\t\t\/\/ Quicktime:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.qt\");\n\t\t\t}\n\t\t\tif (OSUtils.isWindows()) {\n\t\t\t\t\/\/ DirectShow:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.ds\");\n\t\t\t}\n\t\t\tif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\t\t\t\t\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\t\t\t\t\/\/ DirectShow:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.gst\");\n\t\t\t}\n\t\t}\n\t\tif ((flags & FMJ) != 0) {\n\t\t\tcontentPrefixList.add(\"net.sf.fmj\");\n\t\t}\n\t\tif ((flags & THIRD_PARTY) != 0) {\n\t\t\t\/\/ none to add\n\t\t}\n\t\treturn contentPrefixList;\n\t}","code":"public static List<String> contentPrefixList(int flags)\n\t{\n\t\tfinal List<String> contentPrefixList = new ArrayList<String>();\n\t\tif ((flags & JMF) != 0) {\n\t\t\tcontentPrefixList.add(\"javax\");\n\t\t\tcontentPrefixList.add(\"com.sun\");\n\t\t\tcontentPrefixList.add(\"com.ibm\");\n\t\t}\n\t\tif ((flags & FMJ_NATIVE) != 0) {\n\t\t\tif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.qt\");\n\t\t\t}\n\t\t\tif (OSUtils.isWindows()) {\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.ds\");\n\t\t\t}\n\t\t\tif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\t\t\t\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.gst\");\n\t\t\t}\n\t\t}\n\t\tif ((flags & FMJ) != 0) {\n\t\t\tcontentPrefixList.add(\"net.sf.fmj\");\n\t\t}\n\t\tif ((flags & THIRD_PARTY) != 0) {\n\t\t\n\t\t}\n\t\treturn contentPrefixList;\n\t}","cleancode":"public static list<string> contentprefixlist(int flags) { final list<string> contentprefixlist = new arraylist<string>(); if ((flags & jmf) != 0) { contentprefixlist.add(\"javax\"); contentprefixlist.add(\"com.sun\"); contentprefixlist.add(\"com.ibm\"); } if ((flags & fmj_native) != 0) { if (osutils.ismacosx() || osutils.iswindows()) { contentprefixlist.add(\"net.sf.fmj.qt\"); } if (osutils.iswindows()) { contentprefixlist.add(\"net.sf.fmj.ds\"); } if (enable_gstreamer && osutils.islinux()) { contentprefixlist.add(\"net.sf.fmj.gst\"); } } if ((flags & fmj) != 0) { contentprefixlist.add(\"net.sf.fmj\"); } if ((flags & third_party) != 0) { } return contentprefixlist; }","comment":"\/\/ quicktime:\n\/\/ directshow:\n\/\/ todo: we could add these for other os's, as gstreamer is cross-platform. \/\/ directshow:\n\/\/ none to add","repo":"licaon-kter\/atalk-android","code_context_2":"if ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\n\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\n\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;","code_context_10":"public static List<String> contentPrefixList(int flags)\n{\nfinal List<String> contentPrefixList = new ArrayList<String>();\nif ((flags & JMF) != 0) {\ncontentPrefixList.add(\"javax\");\ncontentPrefixList.add(\"com.sun\");\ncontentPrefixList.add(\"com.ibm\");\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n\ncontentPrefixList.add(\"javax\");\ncontentPrefixList.add(\"com.sun\");\ncontentPrefixList.add(\"com.ibm\");\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n}","code_context_20":"public static List<String> contentPrefixList(int flags)\n{\nfinal List<String> contentPrefixList = new ArrayList<String>();\nif ((flags & JMF) != 0) {\ncontentPrefixList.add(\"javax\");\ncontentPrefixList.add(\"com.sun\");\ncontentPrefixList.add(\"com.ibm\");\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n}\n\npublic static List<String> contentPrefixList(int flags)\n{\nfinal List<String> contentPrefixList = new ArrayList<String>();\nif ((flags & JMF) != 0) {\ncontentPrefixList.add(\"javax\");\ncontentPrefixList.add(\"com.sun\");\ncontentPrefixList.add(\"com.ibm\");\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n}\n\npublic static List<String> contentPrefixList(int flags)\n{\nfinal List<String> contentPrefixList = new ArrayList<String>();\nif ((flags & JMF) != 0) {\ncontentPrefixList.add(\"javax\");\ncontentPrefixList.add(\"com.sun\");\ncontentPrefixList.add(\"com.ibm\");\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n}\n\n}\nif ((flags & FMJ_NATIVE) != 0) {\nif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\/\/ Quicktime:\ncontentPrefixList.add(\"net.sf.fmj.qt\");\n}\nif (OSUtils.isWindows()) {\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.ds\");\n}\nif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\/\/ DirectShow:\ncontentPrefixList.add(\"net.sf.fmj.gst\");\n}\n}\nif ((flags & FMJ) != 0) {\ncontentPrefixList.add(\"net.sf.fmj\");\n}\nif ((flags & THIRD_PARTY) != 0) {\n\/\/ none to add\n}\nreturn contentPrefixList;\n}","label":[0,1,0,0]}
{"id":26295,"original_code":"@Test(groups = \"slow\", enabled = false)\n    public void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n        \/\/ TODO add\/remove tag to invoice\n    }","code":"@Test(groups = \"slow\", enabled = false)\n    public void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n       \n    }","cleancode":"@test(groups = \"slow\", enabled = false) public void testoverduestateandwritten_offtag() throws exception { }","comment":"\/\/ todo add\/remove tag to invoice","repo":"kevinpostlewaite\/killbill","code_context_2":"@Test(groups = \"slow\", enabled = false)\npublic void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n\/\/ TODO add\/remove tag to invoice\n}","code_context_10":"@Test(groups = \"slow\", enabled = false)\npublic void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n\/\/ TODO add\/remove tag to invoice\n}","code_context_20":"@Test(groups = \"slow\", enabled = false)\npublic void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n\/\/ TODO add\/remove tag to invoice\n}","label":[0,1,0,0]}
{"id":26312,"original_code":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\t\t\/\/ TO-DO rethink how to manage multiple servers\n\t\tfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\n\t\tfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\n\t\tfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\n\t\t\t\tpathInfo.length());\n\t\treturn firstServer + swaggerPath;\n\t}","code":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\t\n\t\tfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\n\t\tfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\n\t\tfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\n\t\t\t\tpathInfo.length());\n\t\treturn firstServer + swaggerPath;\n\t}","cleancode":"private string getserverurl(openapi openapi, string pathinfo) { final string firstserver = openapiutils.mapserverstoendpoint(openapi.getservers()).get(0); final string apiidentifier = apimanagerservice.getapiidentifier(pathinfo); final string swaggerpath = pathinfo.substring(pathinfo.indexof(apiidentifier) + apiidentifier.length(), pathinfo.length()); return firstserver + swaggerpath; }","comment":"\/\/ to-do rethink how to manage multiple servers","repo":"marrmartin\/onesaitplatform-cloud","code_context_2":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\/\/ TO-DO rethink how to manage multiple servers\nfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\nfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);","code_context_10":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\/\/ TO-DO rethink how to manage multiple servers\nfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\nfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\nfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\npathInfo.length());\nreturn firstServer + swaggerPath;\n}","code_context_20":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\/\/ TO-DO rethink how to manage multiple servers\nfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\nfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\nfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\npathInfo.length());\nreturn firstServer + swaggerPath;\n}","label":[1,0,0,0]}
{"id":34553,"original_code":"@PostConstruct\n    public void setup(){\n        \/\/Do not use getClass() here... a typical weld issue...\n        endpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\n        availableMethods= Arrays.asList(Verb.values());\n        usersEndpoint=userWS.getEndpointUrl();\n        groupsEndpoint=groupWS.getEndpointUrl();\n        fidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\n        commonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n    }","code":"@PostConstruct\n    public void setup(){\n       \n        endpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\n        availableMethods= Arrays.asList(Verb.values());\n        usersEndpoint=userWS.getEndpointUrl();\n        groupsEndpoint=groupWS.getEndpointUrl();\n        fidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\n        commonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n    }","cleancode":"@postconstruct public void setup(){ endpointurl=appconfiguration.getbaseendpoint() + bulkwebservice.class.getannotation(path.class).value(); availablemethods= arrays.aslist(verb.values()); usersendpoint=userws.getendpointurl(); groupsendpoint=groupws.getendpointurl(); fidodevicesendpoint=fidodevicews.getendpointurl(); commonwsendpointprefix=usersendpoint.substring(0, usersendpoint.lastindexof(\"\/\")); }","comment":"\/\/do not use getclass() here... a typical weld issue...","repo":"linosgian\/oxTrust","code_context_2":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\navailableMethods= Arrays.asList(Verb.values());","code_context_10":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\navailableMethods= Arrays.asList(Verb.values());\nusersEndpoint=userWS.getEndpointUrl();\ngroupsEndpoint=groupWS.getEndpointUrl();\nfidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\ncommonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n}","code_context_20":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\navailableMethods= Arrays.asList(Verb.values());\nusersEndpoint=userWS.getEndpointUrl();\ngroupsEndpoint=groupWS.getEndpointUrl();\nfidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\ncommonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n}","label":[1,0,0,0]}
{"id":10032,"original_code":"private void onNetBegin(\n                BeginFW begin)\n            {\n                final long sequence = begin.sequence();\n                final long acknowledge = begin.acknowledge();\n                final int maximum = begin.maximum();\n                final long traceId = begin.traceId();\n                final long authorization = begin.authorization();\n                final long affinity = begin.affinity();\n                assert acknowledge <= sequence;\n                assert sequence >= replySeq;\n                assert acknowledge <= replyAck;\n                replySeq = sequence;\n                replyAck = acknowledge;\n                assert replyAck == replySeq;\n                assert maximum == 0;\n                boolean handshakeHashOK = false;\n                final OctetsFW extension = begin.extension();\n                if (extension.sizeof() != 0)\n                {\n                    \/\/ TODO: need lightweight approach (start)\n                    final HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\n                    final Map<String, String> headers = new LinkedHashMap<>();\n                    httpBeginEx.headers().forEach(header ->\n                    {\n                        final String name = header.name().asString();\n                        final String value = header.value().asString();\n                        headers.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n                    });\n                    final String status = headers.get(\":status\");\n                    final String upgrade = headers.get(\"upgrade\");\n                    final String hash = headers.get(\"sec-websocket-accept\");\n                    final String protocol = headers.get(\"sec-websocket-protocol\");\n                    \/\/ TODO: need lightweight approach (end)\n                    if (WEBSOCKET_STATUS.equals(status) &&\n                        WEBSOCKET_UPGRADE.equals(upgrade) &&\n                        Objects.equals(this.protocol, protocol))\n                    {\n                        sha1.reset();\n                        sha1.update(key.getBytes(US_ASCII));\n                        final byte[] digest = sha1.digest(HANDSHAKE_GUID);\n                        final Encoder encoder = Base64.getEncoder();\n                        final String handshakeHash = new String(encoder.encode(digest), US_ASCII);\n                        handshakeHashOK = handshakeHash.equals(hash);\n                    }\n                }\n                if (handshakeHashOK)\n                {\n                    doAppBegin(maximum, traceId, authorization, affinity);\n                }\n                else\n                {\n                    doAppReset(traceId, authorization);\n                }\n            }","code":"private void onNetBegin(\n                BeginFW begin)\n            {\n                final long sequence = begin.sequence();\n                final long acknowledge = begin.acknowledge();\n                final int maximum = begin.maximum();\n                final long traceId = begin.traceId();\n                final long authorization = begin.authorization();\n                final long affinity = begin.affinity();\n                assert acknowledge <= sequence;\n                assert sequence >= replySeq;\n                assert acknowledge <= replyAck;\n                replySeq = sequence;\n                replyAck = acknowledge;\n                assert replyAck == replySeq;\n                assert maximum == 0;\n                boolean handshakeHashOK = false;\n                final OctetsFW extension = begin.extension();\n                if (extension.sizeof() != 0)\n                {\n                   \n                    final HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\n                    final Map<String, String> headers = new LinkedHashMap<>();\n                    httpBeginEx.headers().forEach(header ->\n                    {\n                        final String name = header.name().asString();\n                        final String value = header.value().asString();\n                        headers.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n                    });\n                    final String status = headers.get(\":status\");\n                    final String upgrade = headers.get(\"upgrade\");\n                    final String hash = headers.get(\"sec-websocket-accept\");\n                    final String protocol = headers.get(\"sec-websocket-protocol\");\n                   \n                    if (WEBSOCKET_STATUS.equals(status) &&\n                        WEBSOCKET_UPGRADE.equals(upgrade) &&\n                        Objects.equals(this.protocol, protocol))\n                    {\n                        sha1.reset();\n                        sha1.update(key.getBytes(US_ASCII));\n                        final byte[] digest = sha1.digest(HANDSHAKE_GUID);\n                        final Encoder encoder = Base64.getEncoder();\n                        final String handshakeHash = new String(encoder.encode(digest), US_ASCII);\n                        handshakeHashOK = handshakeHash.equals(hash);\n                    }\n                }\n                if (handshakeHashOK)\n                {\n                    doAppBegin(maximum, traceId, authorization, affinity);\n                }\n                else\n                {\n                    doAppReset(traceId, authorization);\n                }\n            }","cleancode":"private void onnetbegin( beginfw begin) { final long sequence = begin.sequence(); final long acknowledge = begin.acknowledge(); final int maximum = begin.maximum(); final long traceid = begin.traceid(); final long authorization = begin.authorization(); final long affinity = begin.affinity(); assert acknowledge <= sequence; assert sequence >= replyseq; assert acknowledge <= replyack; replyseq = sequence; replyack = acknowledge; assert replyack == replyseq; assert maximum == 0; boolean handshakehashok = false; final octetsfw extension = begin.extension(); if (extension.sizeof() != 0) { final httpbeginexfw httpbeginex = extension.get(httpbeginexro::wrap); final map<string, string> headers = new linkedhashmap<>(); httpbeginex.headers().foreach(header -> { final string name = header.name().asstring(); final string value = header.value().asstring(); headers.merge(name, value, (v1, v2) -> string.format(\"%s, %s\", v1, v2)); }); final string status = headers.get(\":status\"); final string upgrade = headers.get(\"upgrade\"); final string hash = headers.get(\"sec-websocket-accept\"); final string protocol = headers.get(\"sec-websocket-protocol\"); if (websocket_status.equals(status) && websocket_upgrade.equals(upgrade) && objects.equals(this.protocol, protocol)) { sha1.reset(); sha1.update(key.getbytes(us_ascii)); final byte[] digest = sha1.digest(handshake_guid); final encoder encoder = base64.getencoder(); final string handshakehash = new string(encoder.encode(digest), us_ascii); handshakehashok = handshakehash.equals(hash); } } if (handshakehashok) { doappbegin(maximum, traceid, authorization, affinity); } else { doappreset(traceid, authorization); } }","comment":"\/\/ todo: need lightweight approach (start)\n\/\/ todo: need lightweight approach (end)","repo":"lukefallows\/zilla","code_context_2":"if (extension.sizeof() != 0)\n{\n\/\/ TODO: need lightweight approach (start)\nfinal HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\nfinal Map<String, String> headers = new LinkedHashMap<>();\n\nfinal String hash = headers.get(\"sec-websocket-accept\");\nfinal String protocol = headers.get(\"sec-websocket-protocol\");\n\/\/ TODO: need lightweight approach (end)\nif (WEBSOCKET_STATUS.equals(status) &&\nWEBSOCKET_UPGRADE.equals(upgrade) &&","code_context_10":"assert sequence >= replySeq;\nassert acknowledge <= replyAck;\nreplySeq = sequence;\nreplyAck = acknowledge;\nassert replyAck == replySeq;\nassert maximum == 0;\nboolean handshakeHashOK = false;\nfinal OctetsFW extension = begin.extension();\nif (extension.sizeof() != 0)\n{\n\/\/ TODO: need lightweight approach (start)\nfinal HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\nfinal Map<String, String> headers = new LinkedHashMap<>();\nhttpBeginEx.headers().forEach(header ->\n{\nfinal String name = header.name().asString();\nfinal String value = header.value().asString();\nheaders.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n});\nfinal String status = headers.get(\":status\");\nfinal String upgrade = headers.get(\"upgrade\");\n\nhttpBeginEx.headers().forEach(header ->\n{\nfinal String name = header.name().asString();\nfinal String value = header.value().asString();\nheaders.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n});\nfinal String status = headers.get(\":status\");\nfinal String upgrade = headers.get(\"upgrade\");\nfinal String hash = headers.get(\"sec-websocket-accept\");\nfinal String protocol = headers.get(\"sec-websocket-protocol\");\n\/\/ TODO: need lightweight approach (end)\nif (WEBSOCKET_STATUS.equals(status) &&\nWEBSOCKET_UPGRADE.equals(upgrade) &&\nObjects.equals(this.protocol, protocol))\n{\nsha1.reset();\nsha1.update(key.getBytes(US_ASCII));\nfinal byte[] digest = sha1.digest(HANDSHAKE_GUID);\nfinal Encoder encoder = Base64.getEncoder();\nfinal String handshakeHash = new String(encoder.encode(digest), US_ASCII);\nhandshakeHashOK = handshakeHash.equals(hash);","code_context_20":"private void onNetBegin(\nBeginFW begin)\n{\nfinal long sequence = begin.sequence();\nfinal long acknowledge = begin.acknowledge();\nfinal int maximum = begin.maximum();\nfinal long traceId = begin.traceId();\nfinal long authorization = begin.authorization();\nfinal long affinity = begin.affinity();\nassert acknowledge <= sequence;\nassert sequence >= replySeq;\nassert acknowledge <= replyAck;\nreplySeq = sequence;\nreplyAck = acknowledge;\nassert replyAck == replySeq;\nassert maximum == 0;\nboolean handshakeHashOK = false;\nfinal OctetsFW extension = begin.extension();\nif (extension.sizeof() != 0)\n{\n\/\/ TODO: need lightweight approach (start)\nfinal HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\nfinal Map<String, String> headers = new LinkedHashMap<>();\nhttpBeginEx.headers().forEach(header ->\n{\nfinal String name = header.name().asString();\nfinal String value = header.value().asString();\nheaders.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n});\nfinal String status = headers.get(\":status\");\nfinal String upgrade = headers.get(\"upgrade\");\nfinal String hash = headers.get(\"sec-websocket-accept\");\nfinal String protocol = headers.get(\"sec-websocket-protocol\");\n\/\/ TODO: need lightweight approach (end)\nif (WEBSOCKET_STATUS.equals(status) &&\nWEBSOCKET_UPGRADE.equals(upgrade) &&\nObjects.equals(this.protocol, protocol))\n{\nsha1.reset();\nsha1.update(key.getBytes(US_ASCII));\nfinal byte[] digest = sha1.digest(HANDSHAKE_GUID);\n\nreplyAck = acknowledge;\nassert replyAck == replySeq;\nassert maximum == 0;\nboolean handshakeHashOK = false;\nfinal OctetsFW extension = begin.extension();\nif (extension.sizeof() != 0)\n{\n\/\/ TODO: need lightweight approach (start)\nfinal HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\nfinal Map<String, String> headers = new LinkedHashMap<>();\nhttpBeginEx.headers().forEach(header ->\n{\nfinal String name = header.name().asString();\nfinal String value = header.value().asString();\nheaders.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n});\nfinal String status = headers.get(\":status\");\nfinal String upgrade = headers.get(\"upgrade\");\nfinal String hash = headers.get(\"sec-websocket-accept\");\nfinal String protocol = headers.get(\"sec-websocket-protocol\");\n\/\/ TODO: need lightweight approach (end)\nif (WEBSOCKET_STATUS.equals(status) &&\nWEBSOCKET_UPGRADE.equals(upgrade) &&\nObjects.equals(this.protocol, protocol))\n{\nsha1.reset();\nsha1.update(key.getBytes(US_ASCII));\nfinal byte[] digest = sha1.digest(HANDSHAKE_GUID);\nfinal Encoder encoder = Base64.getEncoder();\nfinal String handshakeHash = new String(encoder.encode(digest), US_ASCII);\nhandshakeHashOK = handshakeHash.equals(hash);\n}\n}\nif (handshakeHashOK)\n{\ndoAppBegin(maximum, traceId, authorization, affinity);\n}\nelse\n{\ndoAppReset(traceId, authorization);\n}","label":[1,0,0,0]}
{"id":18250,"original_code":"@Override\n\tpublic Value evaluate(Context context)\n\t{\n\t\tValue operand1 = get(0, context);\n\t\tValue operand2 = get(1, context);\n\t\tif (operand1.isNumber() && operand2.isList())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tList<Value> value2 = operand2.getList();\n\t\t\treturn value2.get(value1.intValue());\n\t\t}\n\t\telse if (operand1.isNumber() && operand2.isString())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tString value2 = operand2.getString();\n\t\t\treturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n\t\t}\n\t\t\/\/ TODO: explain more\n\t\tthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n\t}","code":"@Override\n\tpublic Value evaluate(Context context)\n\t{\n\t\tValue operand1 = get(0, context);\n\t\tValue operand2 = get(1, context);\n\t\tif (operand1.isNumber() && operand2.isList())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tList<Value> value2 = operand2.getList();\n\t\t\treturn value2.get(value1.intValue());\n\t\t}\n\t\telse if (operand1.isNumber() && operand2.isString())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tString value2 = operand2.getString();\n\t\t\treturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n\t\t}\n\t\n\t\tthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n\t}","cleancode":"@override public value evaluate(context context) { value operand1 = get(0, context); value operand2 = get(1, context); if (operand1.isnumber() && operand2.islist()) { bigdecimal value1 = operand1.getnumber(); list<value> value2 = operand2.getlist(); return value2.get(value1.intvalue()); } else if (operand1.isnumber() && operand2.isstring()) { bigdecimal value1 = operand1.getnumber(); string value2 = operand2.getstring(); return value.asstring(string.valueof(value2.charat(value1.intvalue()))); } throw new runtimeexception(\"cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\"); }","comment":"\/\/ todo: explain more","repo":"mauriciotogneri\/prefix","code_context_2":"return Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n}\n\/\/ TODO: explain more\nthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n}","code_context_10":"BigDecimal value1 = operand1.getNumber();\nList<Value> value2 = operand2.getList();\nreturn value2.get(value1.intValue());\n}\nelse if (operand1.isNumber() && operand2.isString())\n{\nBigDecimal value1 = operand1.getNumber();\nString value2 = operand2.getString();\nreturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n}\n\/\/ TODO: explain more\nthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n}","code_context_20":"@Override\npublic Value evaluate(Context context)\n{\nValue operand1 = get(0, context);\nValue operand2 = get(1, context);\nif (operand1.isNumber() && operand2.isList())\n{\nBigDecimal value1 = operand1.getNumber();\nList<Value> value2 = operand2.getList();\nreturn value2.get(value1.intValue());\n}\nelse if (operand1.isNumber() && operand2.isString())\n{\nBigDecimal value1 = operand1.getNumber();\nString value2 = operand2.getString();\nreturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n}\n\/\/ TODO: explain more\nthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n}","label":[0,0,0,0]}
{"id":10131,"original_code":"@Test\n  public void test() throws Exception {\n    \/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n    \/\/ dependency of Main).\n    assertEquals(2, mainDexList.size());\n    assertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\n    assertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\n    R8TestCompileResult compileResult =\n        testForR8(parameters.getBackend())\n            .addInnerClasses(getClass())\n            .addInliningAnnotations()\n            .addKeepClassAndMembersRules(Main.class)\n            .addMainDexListClassReferences(mainDexList)\n            .collectMainDexClasses()\n            .enableInliningAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .setMinApi(parameters.getApiLevel())\n            .allowDiagnosticMessages()\n            .compileWithExpectedDiagnostics(\n                diagnostics ->\n                    diagnostics\n                        .assertOnlyWarnings()\n                        .assertWarningsMatch(\n                            diagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\n    CodeInspector inspector = compileResult.inspector();\n    ClassSubject mainClassSubject = inspector.clazz(Main.class);\n    assertThat(mainClassSubject, isPresent());\n    MethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\n    assertThat(fooMethodSubject, isPresent());\n    ClassSubject aClassSubject = inspector.clazz(A.class);\n    assertThat(aClassSubject, isPresent());\n    MethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\n    assertThat(barMethodSubject, isPresent());\n    ClassSubject bClassSubject = inspector.clazz(B.class);\n    assertThat(bClassSubject, isPresent());\n    MethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\n    assertThat(bazMethodSubject, isPresent());\n    assertThat(fooMethodSubject, invokesMethod(barMethodSubject));\n    assertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n    \/\/ The main dex classes should be the same as the input main dex list.\n    assertEquals(\n        ImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\n        compileResult.getMainDexClasses());\n  }","code":"@Test\n  public void test() throws Exception {\n   \n   \n    assertEquals(2, mainDexList.size());\n    assertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\n    assertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\n    R8TestCompileResult compileResult =\n        testForR8(parameters.getBackend())\n            .addInnerClasses(getClass())\n            .addInliningAnnotations()\n            .addKeepClassAndMembersRules(Main.class)\n            .addMainDexListClassReferences(mainDexList)\n            .collectMainDexClasses()\n            .enableInliningAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .setMinApi(parameters.getApiLevel())\n            .allowDiagnosticMessages()\n            .compileWithExpectedDiagnostics(\n                diagnostics ->\n                    diagnostics\n                        .assertOnlyWarnings()\n                        .assertWarningsMatch(\n                            diagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\n    CodeInspector inspector = compileResult.inspector();\n    ClassSubject mainClassSubject = inspector.clazz(Main.class);\n    assertThat(mainClassSubject, isPresent());\n    MethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\n    assertThat(fooMethodSubject, isPresent());\n    ClassSubject aClassSubject = inspector.clazz(A.class);\n    assertThat(aClassSubject, isPresent());\n    MethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\n    assertThat(barMethodSubject, isPresent());\n    ClassSubject bClassSubject = inspector.clazz(B.class);\n    assertThat(bClassSubject, isPresent());\n    MethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\n    assertThat(bazMethodSubject, isPresent());\n    assertThat(fooMethodSubject, invokesMethod(barMethodSubject));\n    assertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n   \n    assertEquals(\n        ImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\n        compileResult.getMainDexClasses());\n  }","cleancode":"@test public void test() throws exception { assertequals(2, maindexlist.size()); assertequals(a.class.gettypename(), maindexlist.get(0).gettypename()); assertequals(main.class.gettypename(), maindexlist.get(1).gettypename()); r8testcompileresult compileresult = testforr8(parameters.getbackend()) .addinnerclasses(getclass()) .addinliningannotations() .addkeepclassandmembersrules(main.class) .addmaindexlistclassreferences(maindexlist) .collectmaindexclasses() .enableinliningannotations() .enablenohorizontalclassmergingannotations() .enablenohorizontalclassmergingannotations() .setminapi(parameters.getapilevel()) .allowdiagnosticmessages() .compilewithexpecteddiagnostics( diagnostics -> diagnostics .assertonlywarnings() .assertwarningsmatch( diagnostictype(unsupportedmaindexlistusagediagnostic.class))); codeinspector inspector = compileresult.inspector(); classsubject mainclasssubject = inspector.clazz(main.class); assertthat(mainclasssubject, ispresent()); methodsubject foomethodsubject = mainclasssubject.uniquemethodwithname(\"foo\"); assertthat(foomethodsubject, ispresent()); classsubject aclasssubject = inspector.clazz(a.class); assertthat(aclasssubject, ispresent()); methodsubject barmethodsubject = aclasssubject.uniquemethodwithname(\"bar\"); assertthat(barmethodsubject, ispresent()); classsubject bclasssubject = inspector.clazz(b.class); assertthat(bclasssubject, ispresent()); methodsubject bazmethodsubject = bclasssubject.uniquemethodwithname(\"baz\"); assertthat(bazmethodsubject, ispresent()); assertthat(foomethodsubject, invokesmethod(barmethodsubject)); assertthat(barmethodsubject, invokesmethod(bazmethodsubject)); assertequals( immutableset.of(mainclasssubject.getfinalname(), aclasssubject.getfinalname()), compileresult.getmaindexclasses()); }","comment":"\/\/ todo(b\/181858113): this test is likely obsolete once main-dex-list support is removed.\n\/\/ the generated main dex list should contain main (which is a root) and a (which is a direct \/\/ dependency of main).\n\/\/ the main dex classes should be the same as the input main dex list.","repo":"kami-lang\/madex-r8","code_context_2":"@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\nassertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\nR8TestCompileResult compileResult =\ntestForR8(parameters.getBackend())\n.addInnerClasses(getClass())\n.addInliningAnnotations()\n.addKeepClassAndMembersRules(Main.class)\n.addMainDexListClassReferences(mainDexList)\n.collectMainDexClasses()\n.enableInliningAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.setMinApi(parameters.getApiLevel())\n.allowDiagnosticMessages()\n.compileWithExpectedDiagnostics(\ndiagnostics ->\ndiagnostics\n.assertOnlyWarnings()\n.assertWarningsMatch(\ndiagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\nCodeInspector inspector = compileResult.inspector();\nClassSubject mainClassSubject = inspector.clazz(Main.class);\nassertThat(mainClassSubject, isPresent());\nMethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\nassertThat(fooMethodSubject, isPresent());\nClassSubject aClassSubject = inspector.clazz(A.class);\nassertThat(aClassSubject, isPresent());\nMethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\nassertThat(barMethodSubject, isPresent());\nClassSubject bClassSubject = inspector.clazz(B.class);\nassertThat(bClassSubject, isPresent());\nMethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\nassertThat(bazMethodSubject, isPresent());\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\ncompileResult.getMainDexClasses());\n}\n\n@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\n\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),","code_context_10":"@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\nassertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\nR8TestCompileResult compileResult =\ntestForR8(parameters.getBackend())\n.addInnerClasses(getClass())\n.addInliningAnnotations()\n.addKeepClassAndMembersRules(Main.class)\n.addMainDexListClassReferences(mainDexList)\n.collectMainDexClasses()\n.enableInliningAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.setMinApi(parameters.getApiLevel())\n.allowDiagnosticMessages()\n.compileWithExpectedDiagnostics(\ndiagnostics ->\ndiagnostics\n.assertOnlyWarnings()\n.assertWarningsMatch(\ndiagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\nCodeInspector inspector = compileResult.inspector();\nClassSubject mainClassSubject = inspector.clazz(Main.class);\nassertThat(mainClassSubject, isPresent());\nMethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\nassertThat(fooMethodSubject, isPresent());\nClassSubject aClassSubject = inspector.clazz(A.class);\nassertThat(aClassSubject, isPresent());\nMethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\nassertThat(barMethodSubject, isPresent());\nClassSubject bClassSubject = inspector.clazz(B.class);\nassertThat(bClassSubject, isPresent());\nMethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\nassertThat(bazMethodSubject, isPresent());\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\ncompileResult.getMainDexClasses());\n}\n\n@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\nassertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\nR8TestCompileResult compileResult =\ntestForR8(parameters.getBackend())\n.addInnerClasses(getClass())\n.addInliningAnnotations()\n.addKeepClassAndMembersRules(Main.class)\n.addMainDexListClassReferences(mainDexList)\n.collectMainDexClasses()\n\nClassSubject aClassSubject = inspector.clazz(A.class);\nassertThat(aClassSubject, isPresent());\nMethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\nassertThat(barMethodSubject, isPresent());\nClassSubject bClassSubject = inspector.clazz(B.class);\nassertThat(bClassSubject, isPresent());\nMethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\nassertThat(bazMethodSubject, isPresent());\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\ncompileResult.getMainDexClasses());\n}","code_context_20":"@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\nassertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\nR8TestCompileResult compileResult =\ntestForR8(parameters.getBackend())\n.addInnerClasses(getClass())\n.addInliningAnnotations()\n.addKeepClassAndMembersRules(Main.class)\n.addMainDexListClassReferences(mainDexList)\n.collectMainDexClasses()\n.enableInliningAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.setMinApi(parameters.getApiLevel())\n.allowDiagnosticMessages()\n.compileWithExpectedDiagnostics(\ndiagnostics ->\ndiagnostics\n.assertOnlyWarnings()\n.assertWarningsMatch(\ndiagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\nCodeInspector inspector = compileResult.inspector();\nClassSubject mainClassSubject = inspector.clazz(Main.class);\nassertThat(mainClassSubject, isPresent());\nMethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\nassertThat(fooMethodSubject, isPresent());\nClassSubject aClassSubject = inspector.clazz(A.class);\nassertThat(aClassSubject, isPresent());\nMethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\nassertThat(barMethodSubject, isPresent());\nClassSubject bClassSubject = inspector.clazz(B.class);\nassertThat(bClassSubject, isPresent());\nMethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\nassertThat(bazMethodSubject, isPresent());\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\ncompileResult.getMainDexClasses());\n}\n\n@Test\npublic void test() throws Exception {\n\/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n\/\/ dependency of Main).\nassertEquals(2, mainDexList.size());\nassertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\nassertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\nR8TestCompileResult compileResult =\ntestForR8(parameters.getBackend())\n.addInnerClasses(getClass())\n.addInliningAnnotations()\n.addKeepClassAndMembersRules(Main.class)\n.addMainDexListClassReferences(mainDexList)\n.collectMainDexClasses()\n.enableInliningAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.enableNoHorizontalClassMergingAnnotations()\n.setMinApi(parameters.getApiLevel())\n.allowDiagnosticMessages()\n.compileWithExpectedDiagnostics(\ndiagnostics ->\ndiagnostics\n.assertOnlyWarnings()\n.assertWarningsMatch(\n\ndiagnostics ->\ndiagnostics\n.assertOnlyWarnings()\n.assertWarningsMatch(\ndiagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\nCodeInspector inspector = compileResult.inspector();\nClassSubject mainClassSubject = inspector.clazz(Main.class);\nassertThat(mainClassSubject, isPresent());\nMethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\nassertThat(fooMethodSubject, isPresent());\nClassSubject aClassSubject = inspector.clazz(A.class);\nassertThat(aClassSubject, isPresent());\nMethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\nassertThat(barMethodSubject, isPresent());\nClassSubject bClassSubject = inspector.clazz(B.class);\nassertThat(bClassSubject, isPresent());\nMethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\nassertThat(bazMethodSubject, isPresent());\nassertThat(fooMethodSubject, invokesMethod(barMethodSubject));\nassertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n\/\/ The main dex classes should be the same as the input main dex list.\nassertEquals(\nImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\ncompileResult.getMainDexClasses());\n}","label":[0,0,0,1]}
{"id":18378,"original_code":"public T getAbstractOption() {\n        \/\/ WARNING!! Do not rename this method to getOption(). It breaks\n        \/\/ BeanUtils, which will silently not call setOption. Very annoying!\n        return abstractOption;\n    }","code":"public T getAbstractOption() {\n       \n       \n        return abstractOption;\n    }","cleancode":"public t getabstractoption() { return abstractoption; }","comment":"\/** * gets abstractoption set. * @return the {@code abstractoption} set *\/\n\/\/ warning!! do not rename this method to getoption(). it breaks \/\/ beanutils, which will silently not call setoption. very annoying!","repo":"kupl\/starlab-benchmarks","code_context_2":"public T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}\n\npublic T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}","code_context_10":"public T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}\n\npublic T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}","code_context_20":"public T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}\n\npublic T getAbstractOption() {\n\/\/ WARNING!! Do not rename this method to getOption(). It breaks\n\/\/ BeanUtils, which will silently not call setOption. Very annoying!\nreturn abstractOption;\n}","label":[0,0,1,0]}
{"id":18390,"original_code":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n                \/\/ TODO Want to use classLoader = mgmt.getCatalog().getRootClassLoader();\n                ClassLoader classLoader = LocalUsageManager.class.getClassLoader();\n                Optional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\n                if (result.isPresent()) {\n                    if (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\n                        return new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n                    } else {\n                        return (brooklyn.management.internal.UsageListener) result.get();\n                    }\n                } else {\n                    throw new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");\n                }\n            }","code":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n               \n                ClassLoader classLoader = LocalUsageManager.class.getClassLoader();\n                Optional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\n                if (result.isPresent()) {\n                    if (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\n                        return new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n                    } else {\n                        return (brooklyn.management.internal.UsageListener) result.get();\n                    }\n                } else {\n                    throw new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");\n                }\n            }","cleancode":"@override public brooklyn.management.internal.usagelistener apply(string input) { classloader classloader = localusagemanager.class.getclassloader(); optional<object> result = reflections.invokeconstructorwithargs(classloader, input); if (result.ispresent()) { if (result.get() instanceof brooklyn.management.internal.usagemanager.usagelistener) { return new brooklyn.management.internal.usagemanager.usagelistener.usagelisteneradapter((brooklyn.management.internal.usagemanager.usagelistener) result.get()); } else { return (brooklyn.management.internal.usagelistener) result.get(); } } else { throw new illegalstateexception(\"failed to create usagelistener from class name '\"+input+\"' using no-arg constructor\"); } }","comment":"\/\/ todo want to use classloader = mgmt.getcatalog().getrootclassloader();","repo":"kiuby88\/incubator-brooklyn","code_context_2":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n\/\/ TODO Want to use classLoader = mgmt.getCatalog().getRootClassLoader();\nClassLoader classLoader = LocalUsageManager.class.getClassLoader();\nOptional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);","code_context_10":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n\/\/ TODO Want to use classLoader = mgmt.getCatalog().getRootClassLoader();\nClassLoader classLoader = LocalUsageManager.class.getClassLoader();\nOptional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\nif (result.isPresent()) {\nif (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\nreturn new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n} else {\nreturn (brooklyn.management.internal.UsageListener) result.get();\n}\n} else {\nthrow new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");","code_context_20":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n\/\/ TODO Want to use classLoader = mgmt.getCatalog().getRootClassLoader();\nClassLoader classLoader = LocalUsageManager.class.getClassLoader();\nOptional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\nif (result.isPresent()) {\nif (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\nreturn new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n} else {\nreturn (brooklyn.management.internal.UsageListener) result.get();\n}\n} else {\nthrow new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");\n}\n}","label":[1,0,0,0]}
{"id":2022,"original_code":"@Test\n    public void testUpgradeTables() throws Exception {\n        TestRMTxStore store = new TestRMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n        \/\/ workaround for the db file deletion problem during the tests\n        store.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n        \/\/ use the old db definitions to create the tables\n        store.init();\n        \/\/ verify the absence of the new columns in the tables\n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        \/\/ upgrade the tables and add new columns to the old tables\n        store.upgrade();\n        store.init();\n        \/\/ verify the presence of the new columns in the upgraded tables\n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n    }","code":"@Test\n    public void testUpgradeTables() throws Exception {\n        TestRMTxStore store = new TestRMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n       \n        store.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n       \n        store.init();\n       \n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n       \n        store.upgrade();\n        store.init();\n       \n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n    }","cleancode":"@test public void testupgradetables() throws exception { testrmtxstore store = new testrmtxstore(); store.setdriverclassname(\"org.apache.derby.jdbc.embeddeddriver\"); store.seturl(messageformat.format(\"jdbc:derby:{0};create=true\", test_db_name)); store.init(); verifycolumns(store, \"cxf_rm_src_sequences\", new string[]{\"protocol_version\"}, true); verifycolumns(store, \"cxf_rm_dest_sequences\", new string[]{\"protocol_version\"}, true); verifycolumns(store, inbound_msgs_table_name, new string[]{}, true); verifycolumns(store, outbound_msgs_table_name, new string[]{}, true); store.upgrade(); store.init(); verifycolumns(store, \"cxf_rm_src_sequences\", new string[]{\"protocol_version\"}, false); verifycolumns(store, \"cxf_rm_dest_sequences\", new string[]{\"protocol_version\"}, false); verifycolumns(store, inbound_msgs_table_name, new string[]{}, false); verifycolumns(store, outbound_msgs_table_name, new string[]{}, false); }","comment":"\/\/ workaround for the db file deletion problem during the tests\n\/\/ use the old db definitions to create the tables\n\/\/ verify the absence of the new columns in the tables\n\/\/ upgrade the tables and add new columns to the old tables\n\/\/ verify the presence of the new columns in the upgraded tables","repo":"kimjand\/cxf","code_context_2":"TestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\n\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\n\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);","code_context_10":"@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}\n\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}","code_context_20":"@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}\n\n@Test\npublic void testUpgradeTables() throws Exception {\nTestRMTxStore store = new TestRMTxStore();\nstore.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n\/\/ workaround for the db file deletion problem during the tests\nstore.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n\/\/ use the old db definitions to create the tables\nstore.init();\n\/\/ verify the absence of the new columns in the tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n\/\/ upgrade the tables and add new columns to the old tables\nstore.upgrade();\nstore.init();\n\/\/ verify the presence of the new columns in the upgraded tables\nverifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\nverifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\nverifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n}","label":[1,0,0,0]}
{"id":2048,"original_code":"@VisibleForTesting\n  HeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\n    final Future<HeaderCacheElement> deferredResult;\n    \/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\n    HeaderCacheElement headerCacheUnsync = this.headerCache;\n    if (headerCacheUnsync.getCacheState() == CacheState.Good) {\n      return headerCacheUnsync;\n    }\n    \/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\n    synchronized (lock) {\n      CacheState state = headerCache.getCacheState();\n      switch (state) {\n        case Good:\n          return headerCache;\n        case Stale:\n          asyncRefresh();\n          return headerCache;\n        case Expired:\n        case Exception:\n          \/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\n          deferredResult = asyncRefresh();\n          break;\n        default:\n          return new HeaderCacheElement(\n              Status.UNAUTHENTICATED\n                  .withCause(new IllegalStateException(\"Could not process state: \" + state))\n          );\n      }\n    }\n    return deferredResult.get(5, TimeUnit.SECONDS);\n  }","code":"@VisibleForTesting\n  HeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\n    final Future<HeaderCacheElement> deferredResult;\n   \n    HeaderCacheElement headerCacheUnsync = this.headerCache;\n    if (headerCacheUnsync.getCacheState() == CacheState.Good) {\n      return headerCacheUnsync;\n    }\n   \n    synchronized (lock) {\n      CacheState state = headerCache.getCacheState();\n      switch (state) {\n        case Good:\n          return headerCache;\n        case Stale:\n          asyncRefresh();\n          return headerCache;\n        case Expired:\n        case Exception:\n         \n          deferredResult = asyncRefresh();\n          break;\n        default:\n          return new HeaderCacheElement(\n              Status.UNAUTHENTICATED\n                  .withCause(new IllegalStateException(\"Could not process state: \" + state))\n          );\n      }\n    }\n    return deferredResult.get(5, TimeUnit.SECONDS);\n  }","cleancode":"@visiblefortesting headercacheelement getheader() throws executionexception, interruptedexception, timeoutexception { final future<headercacheelement> deferredresult; headercacheelement headercacheunsync = this.headercache; if (headercacheunsync.getcachestate() == cachestate.good) { return headercacheunsync; } synchronized (lock) { cachestate state = headercache.getcachestate(); switch (state) { case good: return headercache; case stale: asyncrefresh(); return headercache; case expired: case exception: deferredresult = asyncrefresh(); break; default: return new headercacheelement( status.unauthenticated .withcause(new illegalstateexception(\"could not process state: \" + state)) ); } } return deferredresult.get(5, timeunit.seconds); }","comment":"\/** * get the http credential header we need from a new oauth2 accesstoken. *\/\n\/\/ optimize for the common case: do a volatile read to peek for a good cache value\n\/\/ todo(igorbernstein2): figure out how to make this work with appengine request scoped threads\n\/\/ defer the future resolution (asyncrefresh will spin up a thread that will try to acquire the lock)","repo":"mbrukman\/java-bigtable-hbase","code_context_2":"@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\nreturn deferredResult.get(5, TimeUnit.SECONDS);\n}\n\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\n\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\n\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;","code_context_10":"@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\nreturn deferredResult.get(5, TimeUnit.SECONDS);\n}\n\n@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\n\n@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\nreturn deferredResult.get(5, TimeUnit.SECONDS);","code_context_20":"@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\nreturn deferredResult.get(5, TimeUnit.SECONDS);\n}\n\n@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\n\n@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\n\n@VisibleForTesting\nHeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\nfinal Future<HeaderCacheElement> deferredResult;\n\/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\nHeaderCacheElement headerCacheUnsync = this.headerCache;\nif (headerCacheUnsync.getCacheState() == CacheState.Good) {\nreturn headerCacheUnsync;\n}\n\/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\nsynchronized (lock) {\nCacheState state = headerCache.getCacheState();\nswitch (state) {\ncase Good:\nreturn headerCache;\ncase Stale:\nasyncRefresh();\nreturn headerCache;\ncase Expired:\ncase Exception:\n\/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\ndeferredResult = asyncRefresh();\nbreak;\ndefault:\nreturn new HeaderCacheElement(\nStatus.UNAUTHENTICATED\n.withCause(new IllegalStateException(\"Could not process state: \" + state))\n);\n}\n}\nreturn deferredResult.get(5, TimeUnit.SECONDS);\n}","label":[1,0,0,0]}
{"id":10315,"original_code":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n        \/\/effectively map from type to (map from description to events)\n        Map<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\n        for (EventCluster aggregateEvent : preMergedEvents) {\n            typeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n                    .put(aggregateEvent.getDescription(), aggregateEvent);\n        }\n        \/\/result list to return\n        ArrayList<EventCluster> aggEvents = new ArrayList<>();\n        \/\/For each (type, description) key, merge agg events\n        for (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n            \/\/for each description ...\n            for (String descr : descrMap.keySet()) {\n                \/\/run through the sorted events, merging together adjacent events\n                Iterator<EventCluster> iterator = descrMap.get(descr).stream()\n                        .sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n                        .iterator();\n                EventCluster current = iterator.next();\n                while (iterator.hasNext()) {\n                    EventCluster next = iterator.next();\n                    Interval gap = current.getSpan().gap(next.getSpan());\n                    \/\/if they overlap or gap is less one quarter timeUnitLength\n                    \/\/TODO: 1\/4 factor is arbitrary. review! -jm\n                    if (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n                        \/\/merge them\n                        current = EventCluster.merge(current, next);\n                    } else {\n                        \/\/done merging into current, set next as new current\n                        aggEvents.add(current);\n                        current = next;\n                    }\n                }\n                aggEvents.add(current);\n            }\n        }\n        \/\/merge clusters to stripes\n        Map<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\n        for (EventCluster eventCluster : aggEvents) {\n            stripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\n                    new EventStripe(eventCluster, null), EventStripe::merge);\n        }\n        return stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n    }","code":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n       \n        Map<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\n        for (EventCluster aggregateEvent : preMergedEvents) {\n            typeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n                    .put(aggregateEvent.getDescription(), aggregateEvent);\n        }\n       \n        ArrayList<EventCluster> aggEvents = new ArrayList<>();\n       \n        for (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n           \n            for (String descr : descrMap.keySet()) {\n               \n                Iterator<EventCluster> iterator = descrMap.get(descr).stream()\n                        .sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n                        .iterator();\n                EventCluster current = iterator.next();\n                while (iterator.hasNext()) {\n                    EventCluster next = iterator.next();\n                    Interval gap = current.getSpan().gap(next.getSpan());\n                   \n                   \n                    if (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n                       \n                        current = EventCluster.merge(current, next);\n                    } else {\n                       \n                        aggEvents.add(current);\n                        current = next;\n                    }\n                }\n                aggEvents.add(current);\n            }\n        }\n       \n        Map<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\n        for (EventCluster eventCluster : aggEvents) {\n            stripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\n                    new EventStripe(eventCluster, null), EventStripe::merge);\n        }\n        return stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n    }","cleancode":"static private list<eventstripe> mergeclusterstostripes(period timeunitlength, list<eventcluster> premergedevents) { map<eventtype, setmultimap< string, eventcluster>> typemap = new hashmap<>(); for (eventcluster aggregateevent : premergedevents) { typemap.computeifabsent(aggregateevent.geteventtype(), eventtype -> hashmultimap.create()) .put(aggregateevent.getdescription(), aggregateevent); } arraylist<eventcluster> aggevents = new arraylist<>(); for (setmultimap<string, eventcluster> descrmap : typemap.values()) { for (string descr : descrmap.keyset()) { iterator<eventcluster> iterator = descrmap.get(descr).stream() .sorted(comparator.comparing(event -> event.getspan().getstartmillis())) .iterator(); eventcluster current = iterator.next(); while (iterator.hasnext()) { eventcluster next = iterator.next(); interval gap = current.getspan().gap(next.getspan()); if (gap == null || gap.toduration().getmillis() <= timeunitlength.todurationfrom(gap.getstart()).getmillis() \/ 4) { current = eventcluster.merge(current, next); } else { aggevents.add(current); current = next; } } aggevents.add(current); } } map<immutablepair<eventtype, string>, eventstripe> stripedescmap = new hashmap<>(); for (eventcluster eventcluster : aggevents) { stripedescmap.merge(immutablepair.of(eventcluster.geteventtype(), eventcluster.getdescription()), new eventstripe(eventcluster, null), eventstripe::merge); } return stripedescmap.values().stream().sorted(comparator.comparing(eventstripe::getstartmillis)).collect(collectors.tolist()); }","comment":"\/** * merge the events in the given list if they are within the same period * general algorithm is as follows: * * 1) sort them into a map from (type, description)-> list<aggevent> * 2) for each key in map, merge the events and accumulate them in a list to * return * * @param timeunitlength * @param premergedevents * * @return *\/\n\/\/effectively map from type to (map from description to events)\n\/\/result list to return\n\/\/for each (type, description) key, merge agg events\n\/\/for each description ...\n\/\/run through the sorted events, merging together adjacent events\n\/\/if they overlap or gap is less one quarter timeunitlength \/\/todo: 1\/4 factor is arbitrary. review! -jm\n\/\/merge them\n\/\/done merging into current, set next as new current\n\/\/merge clusters to stripes","repo":"karlmortensen\/autopsy","code_context_2":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\n\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\n\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\n\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\n\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\n\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {","code_context_10":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\n\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\n\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}","code_context_20":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\n\nstatic private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n\n\/\/effectively map from type to (map from description to events)\nMap<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\nfor (EventCluster aggregateEvent : preMergedEvents) {\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\ntypeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n.put(aggregateEvent.getDescription(), aggregateEvent);\n}\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\n\/\/result list to return\nArrayList<EventCluster> aggEvents = new ArrayList<>();\n\/\/For each (type, description) key, merge agg events\nfor (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n\/\/for each description ...\nfor (String descr : descrMap.keySet()) {\n\/\/run through the sorted events, merging together adjacent events\nIterator<EventCluster> iterator = descrMap.get(descr).stream()\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}\n\n.sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n.iterator();\nEventCluster current = iterator.next();\nwhile (iterator.hasNext()) {\nEventCluster next = iterator.next();\nInterval gap = current.getSpan().gap(next.getSpan());\n\/\/if they overlap or gap is less one quarter timeUnitLength\n\/\/TODO: 1\/4 factor is arbitrary. review! -jm\nif (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n\/\/merge them\ncurrent = EventCluster.merge(current, next);\n} else {\n\/\/done merging into current, set next as new current\naggEvents.add(current);\ncurrent = next;\n}\n}\naggEvents.add(current);\n}\n}\n\/\/merge clusters to stripes\nMap<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\nfor (EventCluster eventCluster : aggEvents) {\nstripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\nnew EventStripe(eventCluster, null), EventStripe::merge);\n}\nreturn stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n}","label":[1,0,0,0]}
{"id":2162,"original_code":"public void storeObjectField(int fieldNumber, Object value)\n    {\n        if (value == null)\n        {\n            return; \/\/ No value so nothing to do\n        }\n        ExecutionContext ec = op.getExecutionContext();\n        ClassLoaderResolver clr = ec.getClassLoaderResolver();\n        AbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\n        if (mmd != null)\n        {\n            DatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\n            JavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\n            if (fieldMapping != null)\n            {\n                if (fieldMapping instanceof InterfaceMapping)\n                {\n                    \/\/ 1-1 Interface field\n                    InterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\n                    if (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n                    {\n                        \/\/ Field is defined to not accept this type so just return\n                        return;\n                    }\n                    processInterfaceMappingForValue(intfMapping, value, mmd, ec);\n                }\n                else if (mmd.hasCollection() || mmd.hasArray())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                        \/\/ Not join table so no supported schema updates\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    ElementContainerTable collTbl = (ElementContainerTable)joinTbl;\n                    JavaTypeMapping elemMapping = collTbl.getElementMapping();\n                    if (elemMapping instanceof InterfaceMapping)\n                    {\n                        InterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\n                        if (mmd.hasCollection())\n                        {\n                            Collection coll = (Collection)value;\n                            if (coll.isEmpty())\n                            {\n                                return;\n                            }\n                            \/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n                            Object elementValue = coll.iterator().next();\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                        else if (mmd.hasArray())\n                        {\n                            if (Array.getLength(value) == 0)\n                            {\n                                return;\n                            }\n                            \/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n                            Object elementValue = Array.get(value,  0);\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                    }\n                }\n                else if (mmd.hasMap())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                        \/\/ Not join table so no supported schema updates\n                        return;\n                    }\n                    Map map = (Map)value;\n                    if (map.isEmpty())\n                    {\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    MapTable mapTbl = (MapTable)joinTbl;\n                    JavaTypeMapping keyMapping = mapTbl.getKeyMapping();\n                    if (keyMapping instanceof InterfaceMapping)\n                    {\n                        \/\/ Update key mapping using first key. Maybe we should do the same for all keys?\n                        InterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\n                        Object keyValue = map.keySet().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n                    }\n                    JavaTypeMapping valMapping = mapTbl.getValueMapping();\n                    if (valMapping instanceof InterfaceMapping)\n                    {\n                        \/\/ Update value mapping using first value. Maybe we should do the same for all values?\n                        InterfaceMapping intfMapping = (InterfaceMapping)valMapping;\n                        Object valValue = map.values().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n                    }\n                }\n            }\n        }\n    }","code":"public void storeObjectField(int fieldNumber, Object value)\n    {\n        if (value == null)\n        {\n            return;\n        }\n        ExecutionContext ec = op.getExecutionContext();\n        ClassLoaderResolver clr = ec.getClassLoaderResolver();\n        AbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\n        if (mmd != null)\n        {\n            DatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\n            JavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\n            if (fieldMapping != null)\n            {\n                if (fieldMapping instanceof InterfaceMapping)\n                {\n                   \n                    InterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\n                    if (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n                    {\n                       \n                        return;\n                    }\n                    processInterfaceMappingForValue(intfMapping, value, mmd, ec);\n                }\n                else if (mmd.hasCollection() || mmd.hasArray())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                       \n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    ElementContainerTable collTbl = (ElementContainerTable)joinTbl;\n                    JavaTypeMapping elemMapping = collTbl.getElementMapping();\n                    if (elemMapping instanceof InterfaceMapping)\n                    {\n                        InterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\n                        if (mmd.hasCollection())\n                        {\n                            Collection coll = (Collection)value;\n                            if (coll.isEmpty())\n                            {\n                                return;\n                            }\n                           \n                            Object elementValue = coll.iterator().next();\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                        else if (mmd.hasArray())\n                        {\n                            if (Array.getLength(value) == 0)\n                            {\n                                return;\n                            }\n                           \n                            Object elementValue = Array.get(value,  0);\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                    }\n                }\n                else if (mmd.hasMap())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                       \n                        return;\n                    }\n                    Map map = (Map)value;\n                    if (map.isEmpty())\n                    {\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    MapTable mapTbl = (MapTable)joinTbl;\n                    JavaTypeMapping keyMapping = mapTbl.getKeyMapping();\n                    if (keyMapping instanceof InterfaceMapping)\n                    {\n                       \n                        InterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\n                        Object keyValue = map.keySet().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n                    }\n                    JavaTypeMapping valMapping = mapTbl.getValueMapping();\n                    if (valMapping instanceof InterfaceMapping)\n                    {\n                       \n                        InterfaceMapping intfMapping = (InterfaceMapping)valMapping;\n                        Object valValue = map.values().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n                    }\n                }\n            }\n        }\n    }","cleancode":"public void storeobjectfield(int fieldnumber, object value) { if (value == null) { return; } executioncontext ec = op.getexecutioncontext(); classloaderresolver clr = ec.getclassloaderresolver(); abstractmembermetadata mmd = op.getclassmetadata().getmetadataformanagedmemberatabsoluteposition(fieldnumber); if (mmd != null) { datastoreclass table = rdbmsmgr.getdatastoreclass(op.getobject().getclass().getname(), clr); javatypemapping fieldmapping = table.getmembermapping(mmd); if (fieldmapping != null) { if (fieldmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)fieldmapping; if (mmd.getfieldtypes() != null || mmd.hasextension(metadata.extension_member_implementation_classes)) { return; } processinterfacemappingforvalue(intfmapping, value, mmd, ec); } else if (mmd.hascollection() || mmd.hasarray()) { boolean hasjoin = false; if (mmd.getjoinmetadata() != null) { hasjoin = true; } else { abstractmembermetadata[] relmmds = mmd.getrelatedmembermetadata(clr); if (relmmds != null && relmmds[0].getjoinmetadata() != null) { hasjoin = true; } } if (!hasjoin) { return; } table jointbl = fieldmapping.getstoremanager().gettable(mmd); elementcontainertable colltbl = (elementcontainertable)jointbl; javatypemapping elemmapping = colltbl.getelementmapping(); if (elemmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)elemmapping; if (mmd.hascollection()) { collection coll = (collection)value; if (coll.isempty()) { return; } object elementvalue = coll.iterator().next(); processinterfacemappingforvalue(intfmapping, elementvalue, mmd, ec); } else if (mmd.hasarray()) { if (array.getlength(value) == 0) { return; } object elementvalue = array.get(value, 0); processinterfacemappingforvalue(intfmapping, elementvalue, mmd, ec); } } } else if (mmd.hasmap()) { boolean hasjoin = false; if (mmd.getjoinmetadata() != null) { hasjoin = true; } else { abstractmembermetadata[] relmmds = mmd.getrelatedmembermetadata(clr); if (relmmds != null && relmmds[0].getjoinmetadata() != null) { hasjoin = true; } } if (!hasjoin) { return; } map map = (map)value; if (map.isempty()) { return; } table jointbl = fieldmapping.getstoremanager().gettable(mmd); maptable maptbl = (maptable)jointbl; javatypemapping keymapping = maptbl.getkeymapping(); if (keymapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)keymapping; object keyvalue = map.keyset().iterator().next(); processinterfacemappingforvalue(intfmapping, keyvalue, mmd, ec); } javatypemapping valmapping = maptbl.getvaluemapping(); if (valmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)valmapping; object valvalue = map.values().iterator().next(); processinterfacemappingforvalue(intfmapping, valvalue, mmd, ec); } } } } }","comment":"\/** * method to store an object field into the attached instance. * @param fieldnumber number of the field to store * @param value the value in the detached instance *\/\n\/\/ no value so nothing to do\n\/\/ 1-1 interface field\n\/\/ field is defined to not accept this type so just return\n\/\/ not join table so no supported schema updates\n\/\/ update value mapping using first element. maybe we should do the same for all elements?\n\/\/ update value mapping using first element. maybe we should do the same for all elements?\n\/\/ not join table so no supported schema updates\n\/\/ update key mapping using first key. maybe we should do the same for all keys?\n\/\/ update value mapping using first value. maybe we should do the same for all values?","repo":"meysam\/datanucleus-rdbms","code_context_2":"public void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = Array.get(value, 0);\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\n}\n}\nelse if (mmd.hasMap())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}\n\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\n\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\n\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\n\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\n\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\n\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();","code_context_10":"public void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = Array.get(value, 0);\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\n}\n}\nelse if (mmd.hasMap())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}\n\npublic void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\n\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\n\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\n\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\n\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\n\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}","code_context_20":"public void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = Array.get(value, 0);\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\n}\n}\nelse if (mmd.hasMap())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}\n\npublic void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n\npublic void storeObjectField(int fieldNumber, Object value)\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\n\n{\nif (value == null)\n{\nreturn; \/\/ No value so nothing to do\n}\nExecutionContext ec = op.getExecutionContext();\nClassLoaderResolver clr = ec.getClassLoaderResolver();\nAbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\nif (mmd != null)\n{\nDatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\nJavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\nif (fieldMapping != null)\n{\nif (fieldMapping instanceof InterfaceMapping)\n{\n\/\/ 1-1 Interface field\nInterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\nif (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n{\n\/\/ Field is defined to not accept this type so just return\nreturn;\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = Array.get(value, 0);\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\n}\n}\nelse if (mmd.hasMap())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\n\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n{\nif (Array.getLength(value) == 0)\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = Array.get(value, 0);\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\n}\n}\nelse if (mmd.hasMap())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\n\n}\nprocessInterfaceMappingForValue(intfMapping, value, mmd, ec);\n}\nelse if (mmd.hasCollection() || mmd.hasArray())\n{\nboolean hasJoin = false;\nif (mmd.getJoinMetaData() != null)\n{\nhasJoin = true;\n}\nelse\n{\nAbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nElementContainerTable collTbl = (ElementContainerTable)joinTbl;\nJavaTypeMapping elemMapping = collTbl.getElementMapping();\nif (elemMapping instanceof InterfaceMapping)\n{\nInterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\nif (mmd.hasCollection())\n{\nCollection coll = (Collection)value;\nif (coll.isEmpty())\n{\nreturn;\n}\n\/\/ Update value mapping using first element. Maybe we should do the same for all elements?\nObject elementValue = coll.iterator().next();\nprocessInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n}\nelse if (mmd.hasArray())\n\nif (relMmds != null && relMmds[0].getJoinMetaData() != null)\n{\nhasJoin = true;\n}\n}\nif (!hasJoin)\n{\n\/\/ Not join table so no supported schema updates\nreturn;\n}\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}\n\nreturn;\n}\nMap map = (Map)value;\nif (map.isEmpty())\n{\nreturn;\n}\nTable joinTbl = fieldMapping.getStoreManager().getTable(mmd);\nMapTable mapTbl = (MapTable)joinTbl;\nJavaTypeMapping keyMapping = mapTbl.getKeyMapping();\nif (keyMapping instanceof InterfaceMapping)\n{\n\/\/ Update key mapping using first key. Maybe we should do the same for all keys?\nInterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\nObject keyValue = map.keySet().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n}\nJavaTypeMapping valMapping = mapTbl.getValueMapping();\nif (valMapping instanceof InterfaceMapping)\n{\n\/\/ Update value mapping using first value. Maybe we should do the same for all values?\nInterfaceMapping intfMapping = (InterfaceMapping)valMapping;\nObject valValue = map.values().iterator().next();\nprocessInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n}\n}\n}\n}\n}","label":[1,0,0,0]}
{"id":2180,"original_code":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n        \/\/MenuManager menu = MenuManager.getInstance();\n        logger.config(\"R_InitData\");\n        data.R_InitData (wad);\n        \/\/UNUSED - gets points from a table.\n        \/\/logger.config(\"\\nR_InitPointToAngle\");\n        \/\/R_InitPointToAngle ();\n        \/\/UNUSED - gets points from a table.\n        \/\/logger.config(\"\\nR_InitTables\");\n        \/\/R_InitTables ();\n        \/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\n        R_SetViewSize (screenBlocks, detailLevel);\n        logger.config(\"R_InitPlanes\");\n        plane.R_InitPlanes ();   \/\/todo  Handled in r_planes.c\n        logger.config(\"R_InitLightTables\");\n        R_InitLightTables ();\n        logger.config(\"R_InitSkyMap\");\n        R_InitSkyMap (wad);   \/\/todo handled in r_sky.c\n        logger.config(\"R_InitTranslationTables\");\n        draw.R_InitTranslationTables ();  \/\/todo handled in r_draw.c\n        framecount = 0;\n    }","code":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n       \n        logger.config(\"R_InitData\");\n        data.R_InitData (wad);\n       \n       \n       \n       \n       \n       \n       \n        R_SetViewSize (screenBlocks, detailLevel);\n        logger.config(\"R_InitPlanes\");\n        plane.R_InitPlanes ();  \n        logger.config(\"R_InitLightTables\");\n        R_InitLightTables ();\n        logger.config(\"R_InitSkyMap\");\n        R_InitSkyMap (wad);  \n        logger.config(\"R_InitTranslationTables\");\n        draw.R_InitTranslationTables (); \n        framecount = 0;\n    }","cleancode":"public void r_init (wad wad, int screenblocks, boolean detaillevel) { logger.config(\"r_initdata\"); data.r_initdata (wad); r_setviewsize (screenblocks, detaillevel); logger.config(\"r_initplanes\"); plane.r_initplanes (); logger.config(\"r_initlighttables\"); r_initlighttables (); logger.config(\"r_initskymap\"); r_initskymap (wad); logger.config(\"r_inittranslationtables\"); draw.r_inittranslationtables (); framecount = 0; }","comment":"\/\/menumanager menu = menumanager.getinstance();\n\/\/unused - gets points from a table. \/\/logger.config(\"\\nr_initpointtoangle\"); \/\/r_initpointtoangle (); \/\/unused - gets points from a table. \/\/logger.config(\"\\nr_inittables\"); \/\/r_inittables (); \/\/ viewwidth \/ viewheight \/ detaillevel are set by the defaults\n\/\/todo handled in r_planes.c\n\/\/todo handled in r_sky.c\n\/\/todo handled in r_draw.c","repo":"maehem\/Thump","code_context_2":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\n\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\n\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\n\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}","code_context_10":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\n\npublic void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}","code_context_20":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\npublic void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\npublic void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\npublic void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}\n\npublic void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n\/\/MenuManager menu = MenuManager.getInstance();\nlogger.config(\"R_InitData\");\ndata.R_InitData (wad);\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitPointToAngle\");\n\/\/R_InitPointToAngle ();\n\/\/UNUSED - gets points from a table.\n\/\/logger.config(\"\\nR_InitTables\");\n\/\/R_InitTables ();\n\/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\nR_SetViewSize (screenBlocks, detailLevel);\nlogger.config(\"R_InitPlanes\");\nplane.R_InitPlanes (); \/\/todo Handled in r_planes.c\nlogger.config(\"R_InitLightTables\");\nR_InitLightTables ();\nlogger.config(\"R_InitSkyMap\");\nR_InitSkyMap (wad); \/\/todo handled in r_sky.c\nlogger.config(\"R_InitTranslationTables\");\ndraw.R_InitTranslationTables (); \/\/todo handled in r_draw.c\nframecount = 0;\n}","label":[1,0,0,0]}
{"id":2227,"original_code":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\n\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setResourceResolver(iepdResourceResolver);\n        List<Source> sourceList = new ArrayList<Source>();\n        for (String schemaPath : schemaPathList) {\n        \tInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\n        \tStreamSource schemaStreamSource = new StreamSource(schemaInStream);\n        \tsourceList.add(schemaStreamSource);        \t\n        }\n        Source[] schemaSourcesArray = sourceList.toArray(new Source[]{});\n        try {        \t\n            Schema schema = schemaFactory.newSchema(schemaSourcesArray);        \n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(d));\n        } catch (Exception e) {\n            try {\n                e.printStackTrace();\n                System.err.println(\"Input document:\");\n                XmlUtils.printNode(d);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n\t}","code":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\n\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setResourceResolver(iepdResourceResolver);\n        List<Source> sourceList = new ArrayList<Source>();\n        for (String schemaPath : schemaPathList) {\n        \tInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\n        \tStreamSource schemaStreamSource = new StreamSource(schemaInStream);\n        \tsourceList.add(schemaStreamSource);        \t\n        }\n        Source[] schemaSourcesArray = sourceList.toArray(new Source[]{});\n        try {        \t\n            Schema schema = schemaFactory.newSchema(schemaSourcesArray);        \n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(d));\n        } catch (Exception e) {\n            try {\n                e.printStackTrace();\n                System.err.println(\"Input document:\");\n                XmlUtils.printNode(d);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n\t}","cleancode":"public static void validateinstance(document d, lsresourceresolver iepdresourceresolver, list<string> schemapathlist) throws saxexception, exception { schemafactory schemafactory = schemafactory.newinstance(xmlconstants.w3c_xml_schema_ns_uri); schemafactory.setresourceresolver(iepdresourceresolver); list<source> sourcelist = new arraylist<source>(); for (string schemapath : schemapathlist) { inputstream schemainstream = xmlutils.class.getclassloader().getresourceasstream(schemapath); streamsource schemastreamsource = new streamsource(schemainstream); sourcelist.add(schemastreamsource); } source[] schemasourcesarray = sourcelist.toarray(new source[]{}); try { schema schema = schemafactory.newschema(schemasourcesarray); validator validator = schema.newvalidator(); validator.validate(new domsource(d)); } catch (exception e) { try { e.printstacktrace(); system.err.println(\"input document:\"); xmlutils.printnode(d); } catch (exception e1) { e1.printstacktrace(); } throw e; } }","comment":"\/** * validate a document against an iepd. note that this does not require the xsi namespace location attributes to be set in the instance. * * @param schemapathlist * the paths to all schemas necessary to validate the instance; this is the equivalent of specifying these schemas in an xsi:schemalocation attribute in the instance * * @param never_used_todo_remove * * * @param rootschemafilename * the name of the document\/exchange schema * @param d * the document to validate * @param iepdresourceresolver * the resource resolver to use * @return the document that was validated * @throws exception * if the document is not valid *\/","repo":"mark43\/nibrs","code_context_2":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setResourceResolver(iepdResourceResolver);\nList<Source> sourceList = new ArrayList<Source>();\nfor (String schemaPath : schemaPathList) {\nInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\nStreamSource schemaStreamSource = new StreamSource(schemaInStream);\nsourceList.add(schemaStreamSource);\n}\nSource[] schemaSourcesArray = sourceList.toArray(new Source[]{});\ntry {\nSchema schema = schemaFactory.newSchema(schemaSourcesArray);\nValidator validator = schema.newValidator();\nvalidator.validate(new DOMSource(d));\n} catch (Exception e) {\ntry {\ne.printStackTrace();\nSystem.err.println(\"Input document:\");\nXmlUtils.printNode(d);\n} catch (Exception e1) {\ne1.printStackTrace();\n}\nthrow e;\n}\n}","code_context_10":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setResourceResolver(iepdResourceResolver);\nList<Source> sourceList = new ArrayList<Source>();\nfor (String schemaPath : schemaPathList) {\nInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\nStreamSource schemaStreamSource = new StreamSource(schemaInStream);\nsourceList.add(schemaStreamSource);\n}\nSource[] schemaSourcesArray = sourceList.toArray(new Source[]{});\ntry {\nSchema schema = schemaFactory.newSchema(schemaSourcesArray);\nValidator validator = schema.newValidator();\nvalidator.validate(new DOMSource(d));\n} catch (Exception e) {\ntry {\ne.printStackTrace();\nSystem.err.println(\"Input document:\");\nXmlUtils.printNode(d);\n} catch (Exception e1) {\ne1.printStackTrace();\n}\nthrow e;\n}\n}","code_context_20":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\nSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\nschemaFactory.setResourceResolver(iepdResourceResolver);\nList<Source> sourceList = new ArrayList<Source>();\nfor (String schemaPath : schemaPathList) {\nInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\nStreamSource schemaStreamSource = new StreamSource(schemaInStream);\nsourceList.add(schemaStreamSource);\n}\nSource[] schemaSourcesArray = sourceList.toArray(new Source[]{});\ntry {\nSchema schema = schemaFactory.newSchema(schemaSourcesArray);\nValidator validator = schema.newValidator();\nvalidator.validate(new DOMSource(d));\n} catch (Exception e) {\ntry {\ne.printStackTrace();\nSystem.err.println(\"Input document:\");\nXmlUtils.printNode(d);\n} catch (Exception e1) {\ne1.printStackTrace();\n}\nthrow e;\n}\n}","label":[0,0,0,0]}
{"id":18713,"original_code":"@Test\n    \/** TODO this test works if we assume most recent version wins, but semantics TBC *\/\n    public void testMoreEntityV2ThenV1GivesV1() throws Exception {\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\n        addCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\n        forceCatalogUpdate();\n        addCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\n        Entity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\n        Entity moreEntity = Iterables.getOnlyElement(app.getChildren());\n        OsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);\n        OsgiVersionMoreEntityTest.assertV1MethodCall(moreEntity);\n    }","code":"@Test\n   \n    public void testMoreEntityV2ThenV1GivesV1() throws Exception {\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\n        addCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\n        forceCatalogUpdate();\n        addCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\n        Entity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\n        Entity moreEntity = Iterables.getOnlyElement(app.getChildren());\n        OsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);\n        OsgiVersionMoreEntityTest.assertV1MethodCall(moreEntity);\n    }","cleancode":"@test public void testmoreentityv2thenv1givesv1() throws exception { testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\"); testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\"); testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\"); addcatalogitems(getlocalresource(\"more-entity-v2-osgi-catalog.yaml\")); forcecatalogupdate(); addcatalogitems(getlocalresource(\"more-entity-v1-osgi-catalog.yaml\")); entity app = createandstartapplication(\"services: [ { type: 'more-entity:1.0' } ]\"); entity moreentity = iterables.getonlyelement(app.getchildren()); osgiversionmoreentitytest.assertv1effectorcall(moreentity); osgiversionmoreentitytest.assertv1methodcall(moreentity); }","comment":"\/** todo this test works if we assume most recent version wins, but semantics tbc *\/","repo":"kiuby88\/incubator-brooklyn","code_context_2":"@Test\n\/** TODO this test works if we assume most recent version wins, but semantics TBC *\/\npublic void testMoreEntityV2ThenV1GivesV1() throws Exception {\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");","code_context_10":"@Test\n\/** TODO this test works if we assume most recent version wins, but semantics TBC *\/\npublic void testMoreEntityV2ThenV1GivesV1() throws Exception {\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\naddCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\nforceCatalogUpdate();\naddCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\nEntity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\nEntity moreEntity = Iterables.getOnlyElement(app.getChildren());\nOsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);","code_context_20":"@Test\n\/** TODO this test works if we assume most recent version wins, but semantics TBC *\/\npublic void testMoreEntityV2ThenV1GivesV1() throws Exception {\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\nTestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\naddCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\nforceCatalogUpdate();\naddCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\nEntity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\nEntity moreEntity = Iterables.getOnlyElement(app.getChildren());\nOsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);\nOsgiVersionMoreEntityTest.assertV1MethodCall(moreEntity);\n}","label":[0,0,1,0]}
{"id":10580,"original_code":"public synchronized boolean markTaskCompleted (int taskId) {\n        Job job = getJobForTask(taskId);\n        if (job == null) {\n            LOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\n            return false;\n        }\n        job.completedTasks.add(taskId);\n        return true;\n    }","code":"public synchronized boolean markTaskCompleted (int taskId) {\n        Job job = getJobForTask(taskId);\n        if (job == null) {\n            LOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\n            return false;\n        }\n        job.completedTasks.add(taskId);\n        return true;\n    }","cleancode":"public synchronized boolean marktaskcompleted (int taskid) { job job = getjobfortask(taskid); if (job == null) { log.error(\"could not find a job containing task {}, and therefore could not mark the task as completed.\", taskid); return false; } job.completedtasks.add(taskid); return true; }","comment":"\/** * take a normal (non-priority) task out of a job queue, marking it as completed so it will not be re-delivered. * todo maybe use unique delivery receipts instead of task ids to handle redelivered tasks independently * @return whether the task was found and removed. *\/","repo":"mcheung610\/r5","code_context_2":"public synchronized boolean markTaskCompleted (int taskId) {\nJob job = getJobForTask(taskId);\nif (job == null) {\nLOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\nreturn false;\n}\njob.completedTasks.add(taskId);\nreturn true;\n}","code_context_10":"public synchronized boolean markTaskCompleted (int taskId) {\nJob job = getJobForTask(taskId);\nif (job == null) {\nLOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\nreturn false;\n}\njob.completedTasks.add(taskId);\nreturn true;\n}","code_context_20":"public synchronized boolean markTaskCompleted (int taskId) {\nJob job = getJobForTask(taskId);\nif (job == null) {\nLOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\nreturn false;\n}\njob.completedTasks.add(taskId);\nreturn true;\n}","label":[1,0,0,0]}
{"id":10625,"original_code":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\n\t\t\t\t\t\t\t\tTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n\t{\n\t\tfinal PlanNode inputPlanNode = input.getSource();\n\t\tfinal Iterator<Channel> allInChannels;\n\t\tallInChannels = Collections.singletonList(input).iterator();\n\t\t\/\/ check that the type serializer is consistent\n\t\tTypeSerializerFactory<?> typeSerFact = null;\n\t\twhile (allInChannels.hasNext()) {\n\t\t\tfinal Channel inConn = allInChannels.next();\n\t\t\tif (typeSerFact == null) {\n\t\t\t\ttypeSerFact = inConn.getSerializer();\n\t\t\t} else if (!typeSerFact.equals(inConn.getSerializer())) {\n\t\t\t\tthrow new CompilerException(\"Conflicting types in union operator.\");\n\t\t\t}\n\t\t\tfinal PlanNode sourceNode = inConn.getSource();\n\t\t\tFlinkVertex sourceVertex = this.vertices.get(sourceNode);\n\t\t\tTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\n\t\t\tconnectJobVertices(\n\t\t\t\t\tinConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n\t\t}\n\t\t\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\t\t\/\/ in the union case, it is the edge between union and the target node\n\t\taddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\n\t\treturn 1;\n\t}","code":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\n\t\t\t\t\t\t\t\tTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n\t{\n\t\tfinal PlanNode inputPlanNode = input.getSource();\n\t\tfinal Iterator<Channel> allInChannels;\n\t\tallInChannels = Collections.singletonList(input).iterator();\n\t\n\t\tTypeSerializerFactory<?> typeSerFact = null;\n\t\twhile (allInChannels.hasNext()) {\n\t\t\tfinal Channel inConn = allInChannels.next();\n\t\t\tif (typeSerFact == null) {\n\t\t\t\ttypeSerFact = inConn.getSerializer();\n\t\t\t} else if (!typeSerFact.equals(inConn.getSerializer())) {\n\t\t\t\tthrow new CompilerException(\"Conflicting types in union operator.\");\n\t\t\t}\n\t\t\tfinal PlanNode sourceNode = inConn.getSource();\n\t\t\tFlinkVertex sourceVertex = this.vertices.get(sourceNode);\n\t\t\tTezTaskConfig sourceVertexConfig = sourceVertex.getConfig();\n\t\t\tconnectJobVertices(\n\t\t\t\t\tinConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n\t\t}\n\t\n\t\n\t\taddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\n\t\treturn 1;\n\t}","cleancode":"private int translatechannel(channel input, int inputindex, flinkvertex targetvertex, teztaskconfig targetvertexconfig, boolean isbroadcast) throws exception { final plannode inputplannode = input.getsource(); final iterator<channel> allinchannels; allinchannels = collections.singletonlist(input).iterator(); typeserializerfactory<?> typeserfact = null; while (allinchannels.hasnext()) { final channel inconn = allinchannels.next(); if (typeserfact == null) { typeserfact = inconn.getserializer(); } else if (!typeserfact.equals(inconn.getserializer())) { throw new compilerexception(\"conflicting types in union operator.\"); } final plannode sourcenode = inconn.getsource(); flinkvertex sourcevertex = this.vertices.get(sourcenode); teztaskconfig sourcevertexconfig = sourcevertex.getconfig(); connectjobvertices( inconn, inputindex, sourcevertex, sourcevertexconfig, targetvertex, targetvertexconfig, isbroadcast); } addlocalinfofromchanneltoconfig(input, targetvertexconfig, inputindex, isbroadcast); return 1; }","comment":"\/\/ check that the type serializer is consistent\n\/\/todo ??? need to create a new tezconfig ???\n\/\/ the local strategy is added only once. in non-union case that is the actual edge, \/\/ in the union case, it is the edge between union and the target node","repo":"ljzzju\/incubator-flink","code_context_2":"final Iterator<Channel> allInChannels;\nallInChannels = Collections.singletonList(input).iterator();\n\/\/ check that the type serializer is consistent\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\n\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;","code_context_10":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\nTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n{\nfinal PlanNode inputPlanNode = input.getSource();\nfinal Iterator<Channel> allInChannels;\nallInChannels = Collections.singletonList(input).iterator();\n\/\/ check that the type serializer is consistent\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\nfinal Channel inConn = allInChannels.next();\nif (typeSerFact == null) {\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\n\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\nfinal Channel inConn = allInChannels.next();\nif (typeSerFact == null) {\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;\n}\n\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;\n}","code_context_20":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\nTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n{\nfinal PlanNode inputPlanNode = input.getSource();\nfinal Iterator<Channel> allInChannels;\nallInChannels = Collections.singletonList(input).iterator();\n\/\/ check that the type serializer is consistent\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\nfinal Channel inConn = allInChannels.next();\nif (typeSerFact == null) {\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;\n}\n\nprivate int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\nTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n{\nfinal PlanNode inputPlanNode = input.getSource();\nfinal Iterator<Channel> allInChannels;\nallInChannels = Collections.singletonList(input).iterator();\n\/\/ check that the type serializer is consistent\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\nfinal Channel inConn = allInChannels.next();\nif (typeSerFact == null) {\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;\n}\n\nTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n{\nfinal PlanNode inputPlanNode = input.getSource();\nfinal Iterator<Channel> allInChannels;\nallInChannels = Collections.singletonList(input).iterator();\n\/\/ check that the type serializer is consistent\nTypeSerializerFactory<?> typeSerFact = null;\nwhile (allInChannels.hasNext()) {\nfinal Channel inConn = allInChannels.next();\nif (typeSerFact == null) {\ntypeSerFact = inConn.getSerializer();\n} else if (!typeSerFact.equals(inConn.getSerializer())) {\nthrow new CompilerException(\"Conflicting types in union operator.\");\n}\nfinal PlanNode sourceNode = inConn.getSource();\nFlinkVertex sourceVertex = this.vertices.get(sourceNode);\nTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\nconnectJobVertices(\ninConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n}\n\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\/\/ in the union case, it is the edge between union and the target node\naddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\nreturn 1;\n}","label":[1,0,0,0]}
{"id":10626,"original_code":"private void connectJobVertices(Channel channel, int inputNumber,\n\t\t\t\t\t\t\tfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\n\t\t\t\t\t\t\tfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\n\t\t\tthrows CompilerException {\n\t\t\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\n\t\tfinal int outputIndex = sourceConfig.getNumOutputs();\n\t\tsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\n\t\tif (outputIndex == 0) {\n\t\t\tsourceConfig.setOutputSerializer(channel.getSerializer());\n\t\t}\n\t\tif (channel.getShipStrategyComparator() != null) {\n\t\t\tsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n\t\t}\n\t\tif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\n\t\t\tfinal DataDistribution dataDistribution = channel.getDataDistribution();\n\t\t\tif(dataDistribution != null) {\n\t\t\t\tsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\t\t\t\t\/\/ TODO: inject code and configuration for automatic histogram generation\n\t\t\t}\n\t\t}\n\t\t\/\/ ---------------- configure the receiver -------------------\n\t\tif (isBroadcast) {\n\t\t\ttargetConfig.addBroadcastInputToGroup(inputNumber);\n\t\t} else {\n\t\t\ttargetConfig.addInputToGroup(inputNumber);\n\t\t}\n\t\t\/\/----------------- connect source and target with edge ------------------------------\n\t\tFlinkEdge edge;\n\t\tShipStrategyType shipStrategy = channel.getShipStrategy();\n\t\tTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\n\t\tif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\n\t\t\tedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\t\t\t\/\/ For forward edges, create as many tasks in upstream operator as in source operator\n\t\t\ttargetVertex.setParallelism(sourceVertex.getParallelism());\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.BROADCAST) {\n\t\t\tedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\n\t\t\tedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse {\n\t\t\tthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n\t\t}\n\t\t\/\/ Tez-specific bookkeeping\n\t\t\/\/ TODO: This probably will not work for vertices with multiple outputs\n\t\tsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\n\t\ttargetVertex.addInput(sourceVertex, inputNumber);\n\t\tedges.add(edge);\n\t}","code":"private void connectJobVertices(Channel channel, int inputNumber,\n\t\t\t\t\t\t\tfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\n\t\t\t\t\t\t\tfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\n\t\t\tthrows CompilerException {\n\t\n\t\tfinal int outputIndex = sourceConfig.getNumOutputs();\n\t\tsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\n\t\tif (outputIndex == 0) {\n\t\t\tsourceConfig.setOutputSerializer(channel.getSerializer());\n\t\t}\n\t\tif (channel.getShipStrategyComparator() != null) {\n\t\t\tsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n\t\t}\n\t\tif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\n\t\t\tfinal DataDistribution dataDistribution = channel.getDataDistribution();\n\t\t\tif(dataDistribution != null) {\n\t\t\t\tsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t\tif (isBroadcast) {\n\t\t\ttargetConfig.addBroadcastInputToGroup(inputNumber);\n\t\t} else {\n\t\t\ttargetConfig.addInputToGroup(inputNumber);\n\t\t}\n\t\n\t\tFlinkEdge edge;\n\t\tShipStrategyType shipStrategy = channel.getShipStrategy();\n\t\tTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\n\t\tif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\n\t\t\tedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\t\t\n\t\t\ttargetVertex.setParallelism(sourceVertex.getParallelism());\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.BROADCAST) {\n\t\t\tedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\n\t\t\tedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse {\n\t\t\tthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n\t\t}\n\t\n\t\n\t\tsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\n\t\ttargetVertex.addInput(sourceVertex, inputNumber);\n\t\tedges.add(edge);\n\t}","cleancode":"private void connectjobvertices(channel channel, int inputnumber, final flinkvertex sourcevertex, final teztaskconfig sourceconfig, final flinkvertex targetvertex, final teztaskconfig targetconfig, boolean isbroadcast) throws compilerexception { final int outputindex = sourceconfig.getnumoutputs(); sourceconfig.addoutputshipstrategy(channel.getshipstrategy()); if (outputindex == 0) { sourceconfig.setoutputserializer(channel.getserializer()); } if (channel.getshipstrategycomparator() != null) { sourceconfig.setoutputcomparator(channel.getshipstrategycomparator(), outputindex); } if (channel.getshipstrategy() == shipstrategytype.partition_range) { final datadistribution datadistribution = channel.getdatadistribution(); if(datadistribution != null) { sourceconfig.setoutputdatadistribution(datadistribution, outputindex); } else { throw new runtimeexception(\"range partitioning requires data distribution\"); } } if (isbroadcast) { targetconfig.addbroadcastinputtogroup(inputnumber); } else { targetconfig.addinputtogroup(inputnumber); } flinkedge edge; shipstrategytype shipstrategy = channel.getshipstrategy(); typeserializer<?> serializer = channel.getserializer().getserializer(); if ((shipstrategy == shipstrategytype.forward) || (shipstrategy == shipstrategytype.none)) { edge = new flinkforwardedge(sourcevertex, targetvertex, serializer); targetvertex.setparallelism(sourcevertex.getparallelism()); } else if (shipstrategy == shipstrategytype.broadcast) { edge = new flinkbroadcastedge(sourcevertex, targetvertex, serializer); } else if (shipstrategy == shipstrategytype.partition_hash) { edge = new flinkpartitionedge(sourcevertex, targetvertex, serializer); } else { throw new compilerexception(\"ship strategy between nodes \" + sourcevertex.getvertex().getname() + \" and \" + targetvertex.getvertex().getname() + \" currently not supported\"); } sourcevertex.addnumberofsubtasksinoutput(targetvertex.getparallelism(), outputindex); targetvertex.addinput(sourcevertex, inputnumber); edges.add(edge); }","comment":"\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\n\/\/ todo: inject code and configuration for automatic histogram generation\n\/\/ ---------------- configure the receiver -------------------\n\/\/----------------- connect source and target with edge ------------------------------\n\/\/ for forward edges, create as many tasks in upstream operator as in source operator\n\/\/ tez-specific bookkeeping \/\/ todo: this probably will not work for vertices with multiple outputs","repo":"ljzzju\/incubator-flink","code_context_2":"final FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\nthrows CompilerException {\n\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\nfinal int outputIndex = sourceConfig.getNumOutputs();\nsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\n\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\n\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\n\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n}\n\/\/ Tez-specific bookkeeping\n\/\/ TODO: This probably will not work for vertices with multiple outputs\nsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\ntargetVertex.addInput(sourceVertex, inputNumber);","code_context_10":"private void connectJobVertices(Channel channel, int inputNumber,\nfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\nfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\nthrows CompilerException {\n\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\nfinal int outputIndex = sourceConfig.getNumOutputs();\nsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\nif (outputIndex == 0) {\nsourceConfig.setOutputSerializer(channel.getSerializer());\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\n\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\n\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\n\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\nelse {\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\nelse {\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n}\n\/\/ Tez-specific bookkeeping\n\/\/ TODO: This probably will not work for vertices with multiple outputs\nsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\ntargetVertex.addInput(sourceVertex, inputNumber);\nedges.add(edge);\n}","code_context_20":"private void connectJobVertices(Channel channel, int inputNumber,\nfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\nfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\nthrows CompilerException {\n\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\nfinal int outputIndex = sourceConfig.getNumOutputs();\nsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\nif (outputIndex == 0) {\nsourceConfig.setOutputSerializer(channel.getSerializer());\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n\nprivate void connectJobVertices(Channel channel, int inputNumber,\nfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\nfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\nthrows CompilerException {\n\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\nfinal int outputIndex = sourceConfig.getNumOutputs();\nsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\nif (outputIndex == 0) {\nsourceConfig.setOutputSerializer(channel.getSerializer());\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\n\nfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\nthrows CompilerException {\n\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\nfinal int outputIndex = sourceConfig.getNumOutputs();\nsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\nif (outputIndex == 0) {\nsourceConfig.setOutputSerializer(channel.getSerializer());\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\n\nsourceConfig.setOutputSerializer(channel.getSerializer());\n}\nif (channel.getShipStrategyComparator() != null) {\nsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n}\nif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\nelse {\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n}\n\/\/ Tez-specific bookkeeping\n\/\/ TODO: This probably will not work for vertices with multiple outputs\nsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\n\nfinal DataDistribution dataDistribution = channel.getDataDistribution();\nif(dataDistribution != null) {\nsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n} else {\nthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\/\/ TODO: inject code and configuration for automatic histogram generation\n}\n}\n\/\/ ---------------- configure the receiver -------------------\nif (isBroadcast) {\ntargetConfig.addBroadcastInputToGroup(inputNumber);\n} else {\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\nelse {\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n}\n\/\/ Tez-specific bookkeeping\n\/\/ TODO: This probably will not work for vertices with multiple outputs\nsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\ntargetVertex.addInput(sourceVertex, inputNumber);\nedges.add(edge);\n}\n\ntargetConfig.addInputToGroup(inputNumber);\n}\n\/\/----------------- connect source and target with edge ------------------------------\nFlinkEdge edge;\nShipStrategyType shipStrategy = channel.getShipStrategy();\nTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\nif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\nedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\/\/ For forward edges, create as many tasks in upstream operator as in source operator\ntargetVertex.setParallelism(sourceVertex.getParallelism());\n}\nelse if (shipStrategy == ShipStrategyType.BROADCAST) {\nedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n}\nelse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\nedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n}\nelse {\nthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n}\n\/\/ Tez-specific bookkeeping\n\/\/ TODO: This probably will not work for vertices with multiple outputs\nsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\ntargetVertex.addInput(sourceVertex, inputNumber);\nedges.add(edge);\n}","label":[1,1,0,0]}
{"id":10732,"original_code":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\n    public static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\n        Char chr = c.getChr();\n        if (inPacket.getUnreadAmount() == 0) {\n            \/\/ Coming back from the cash shop\n\/\/            chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\n            c.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\n            c.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\n            return;\n    }\n        byte fieldKey = inPacket.decodeByte();\n        int targetField = inPacket.decodeInt();\n        if (targetField == 106020100 || targetField == 106020400) {\n            \/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\n            targetField = 106020403;\n        } else if (targetField == 106020402) {\n            \/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\n            targetField = 106020000;\n        }\n        int x = inPacket.decodeShort();\n        int y = inPacket.decodeShort();\n        String portalName = inPacket.decodeString();\n        if (portalName != null && !\"\".equals(portalName)) {\n            Field field = chr.getField();\n            Portal portal = field.getPortalByName(portalName);\n            if (portal.getScript() != null && !portal.getScript().equals(\"\")) {\n                chr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n            } else {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\n                if (toField == null) {\n                    return;\n                }\n                Portal toPortal = toField.getPortalByName(portal.getTargetPortalName());\n                if (toPortal == null) {\n                    toPortal = toField.getPortalByName(\"sp\");\n                }\n                chr.warp(toField, toPortal);\n            }\n        } else if (chr.getHP() <= 0) {\n            if (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\n                InGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\n                chr.heal(chr.getMaxHP());\n                chr.healMP(chr.getMaxMP());\n                return;\n            }\n            \/\/ Character is dead, respawn request\n            inPacket.decodeByte(); \/\/ always 0\n            byte tarfield = inPacket.decodeByte(); \/\/ ?\n            byte reviveType = inPacket.decodeByte();\n            int returnMap = chr.getField().getReturnMap() == 999999999\n                    ? chr.getPreviousFieldID()\n                    : chr.getField().getReturnMap();\n            switch (reviveType) {\n                \/\/ so far only got 0?\n            }\n            if (!chr.hasBuffProtector()) {\n                chr.getTemporaryStatManager().removeAllStats();\n            }\n            int deathcount = chr.getDeathCount();\n            if (deathcount != 0) {\n                if (deathcount > 0) {\n                    deathcount--;\n                    chr.setDeathCount(deathcount);\n                    chr.write(UserLocal.deathCountInfo(deathcount));\n                }\n                chr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\n                chr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\n                chr.healHPMP();\n                return;\n            } else if (chr.getInstance() != null) {\n                chr.getInstance().removeChar(chr);\n            } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n                if (toField != null && chr.getTransferField() > 0) {\n                    chr.warp(toField);\n                }\n                chr.setTransferField(0);\n                return;\n            } else {\n                chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getField().getForcedReturn()));\n            }\n            chr.healHPMP();\n            chr.setBuffProtector(false);\n        } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n            Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n            if (toField != null && chr.getTransferField() > 0) {\n                chr.warp(toField);\n            }\n            chr.setTransferField(0);\n        }\n    }","code":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\n    public static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\n        Char chr = c.getChr();\n        if (inPacket.getUnreadAmount() == 0) {\n           \n            c.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\n            c.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\n            return;\n    }\n        byte fieldKey = inPacket.decodeByte();\n        int targetField = inPacket.decodeInt();\n        if (targetField == 106020100 || targetField == 106020400) {\n           \n            targetField = 106020403;\n        } else if (targetField == 106020402) {\n           \n            targetField = 106020000;\n        }\n        int x = inPacket.decodeShort();\n        int y = inPacket.decodeShort();\n        String portalName = inPacket.decodeString();\n        if (portalName != null && !\"\".equals(portalName)) {\n            Field field = chr.getField();\n            Portal portal = field.getPortalByName(portalName);\n            if (portal.getScript() != null && !portal.getScript().equals(\"\")) {\n                chr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n            } else {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\n                if (toField == null) {\n                    return;\n                }\n                Portal toPortal = toField.getPortalByName(portal.getTargetPortalName());\n                if (toPortal == null) {\n                    toPortal = toField.getPortalByName(\"sp\");\n                }\n                chr.warp(toField, toPortal);\n            }\n        } else if (chr.getHP() <= 0) {\n            if (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\n                InGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\n                chr.heal(chr.getMaxHP());\n                chr.healMP(chr.getMaxMP());\n                return;\n            }\n           \n            inPacket.decodeByte();\n            byte tarfield = inPacket.decodeByte();\n            byte reviveType = inPacket.decodeByte();\n            int returnMap = chr.getField().getReturnMap() == 999999999\n                    ? chr.getPreviousFieldID()\n                    : chr.getField().getReturnMap();\n            switch (reviveType) {\n               \n            }\n            if (!chr.hasBuffProtector()) {\n                chr.getTemporaryStatManager().removeAllStats();\n            }\n            int deathcount = chr.getDeathCount();\n            if (deathcount != 0) {\n                if (deathcount > 0) {\n                    deathcount--;\n                    chr.setDeathCount(deathcount);\n                    chr.write(UserLocal.deathCountInfo(deathcount));\n                }\n                chr.setNearestReturnPortal();\n                chr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\n                chr.healHPMP();\n                return;\n            } else if (chr.getInstance() != null) {\n                chr.getInstance().removeChar(chr);\n            } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n                if (toField != null && chr.getTransferField() > 0) {\n                    chr.warp(toField);\n                }\n                chr.setTransferField(0);\n                return;\n            } else {\n                chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getField().getForcedReturn()));\n            }\n            chr.healHPMP();\n            chr.setBuffProtector(false);\n        } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n            Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n            if (toField != null && chr.getTransferField() > 0) {\n                chr.warp(toField);\n            }\n            chr.setTransferField(0);\n        }\n    }","cleancode":"@handler(op = inheader.user_transfer_field_request) public static void handleusertransferfieldrequest(client c, inpacket inpacket) { char chr = c.getchr(); if (inpacket.getunreadamount() == 0) { c.getchannelinstance().addclientintransfer(c.getchannel(), chr.getid(), c); c.write(clientsocket.migratecommand(true, (short) c.getchannelinstance().getport())); return; } byte fieldkey = inpacket.decodebyte(); int targetfield = inpacket.decodeint(); if (targetfield == 106020100 || targetfield == 106020400) { targetfield = 106020403; } else if (targetfield == 106020402) { targetfield = 106020000; } int x = inpacket.decodeshort(); int y = inpacket.decodeshort(); string portalname = inpacket.decodestring(); if (portalname != null && !\"\".equals(portalname)) { field field = chr.getfield(); portal portal = field.getportalbyname(portalname); if (portal.getscript() != null && !portal.getscript().equals(\"\")) { chr.getscriptmanager().startscript(portal.getid(), portal.getscript(), scripttype.portal); } else { field tofield = chr.getorcreatefieldbycurrentinstancetype(portal.gettargetmapid()); if (tofield == null) { return; } portal toportal = tofield.getportalbyname(portal.gettargetportalname()); if (toportal == null) { toportal = tofield.getportalbyname(\"sp\"); } chr.warp(tofield, toportal); } } else if (chr.gethp() <= 0) { if (ingameeventmanager.getinstance().charineventmap(chr.getid())) { ingameeventmanager.getinstance().getactiveevent().onmigratedeath(chr); chr.heal(chr.getmaxhp()); chr.healmp(chr.getmaxmp()); return; } inpacket.decodebyte(); byte tarfield = inpacket.decodebyte(); byte revivetype = inpacket.decodebyte(); int returnmap = chr.getfield().getreturnmap() == 999999999 ? chr.getpreviousfieldid() : chr.getfield().getreturnmap(); switch (revivetype) { } if (!chr.hasbuffprotector()) { chr.gettemporarystatmanager().removeallstats(); } int deathcount = chr.getdeathcount(); if (deathcount != 0) { if (deathcount > 0) { deathcount--; chr.setdeathcount(deathcount); chr.write(userlocal.deathcountinfo(deathcount)); } chr.setnearestreturnportal(); chr.warp(chr.getfieldid(), chr.getpreviousportalid(), false); chr.healhpmp(); return; } else if (chr.getinstance() != null) { chr.getinstance().removechar(chr); } else if (chr.gettransferfield() == targetfield && chr.gettransferfieldreq() == chr.getfield().getid()) { field tofield = chr.getorcreatefieldbycurrentinstancetype(chr.gettransferfield()); if (tofield != null && chr.gettransferfield() > 0) { chr.warp(tofield); } chr.settransferfield(0); return; } else { chr.warp(chr.getorcreatefieldbycurrentinstancetype(chr.getfield().getforcedreturn())); } chr.healhpmp(); chr.setbuffprotector(false); } else if (chr.gettransferfield() == targetfield && chr.gettransferfieldreq() == chr.getfield().getid()) { field tofield = chr.getorcreatefieldbycurrentinstancetype(chr.gettransferfield()); if (tofield != null && chr.gettransferfield() > 0) { chr.warp(tofield); } chr.settransferfield(0); } }","comment":"\/\/ coming back from the cash shop \/\/ chr.warp(chr.getorcreatefieldbycurrentinstancetype(chr.getfieldid()));\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\n\/\/ character is dead, respawn request\n\/\/ always 0\n\/\/ ?\n\/\/ so far only got 0?\n\/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?","repo":"lynsone\/swordie","code_context_2":"Char chr = c.getChr();\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\n\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\n\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\n\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\n\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\n\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\nchr.healHPMP();","code_context_10":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\npublic static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\nChar chr = c.getChr();\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\nint x = inPacket.decodeShort();\nint y = inPacket.decodeShort();\nString portalName = inPacket.decodeString();\nif (portalName != null && !\"\".equals(portalName)) {\nField field = chr.getField();\n\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\nint x = inPacket.decodeShort();\nint y = inPacket.decodeShort();\nString portalName = inPacket.decodeString();\nif (portalName != null && !\"\".equals(portalName)) {\nField field = chr.getField();\nPortal portal = field.getPortalByName(portalName);\nif (portal.getScript() != null && !portal.getScript().equals(\"\")) {\nchr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n\n}\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\n\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\n\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\nchr.healHPMP();\nreturn;\n} else if (chr.getInstance() != null) {\nchr.getInstance().removeChar(chr);\n} else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\nif (toField != null && chr.getTransferField() > 0) {\nchr.warp(toField);\n}","code_context_20":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\npublic static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\nChar chr = c.getChr();\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\nint x = inPacket.decodeShort();\nint y = inPacket.decodeShort();\nString portalName = inPacket.decodeString();\nif (portalName != null && !\"\".equals(portalName)) {\nField field = chr.getField();\nPortal portal = field.getPortalByName(portalName);\nif (portal.getScript() != null && !portal.getScript().equals(\"\")) {\n\n@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\npublic static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\nChar chr = c.getChr();\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\nint x = inPacket.decodeShort();\nint y = inPacket.decodeShort();\nString portalName = inPacket.decodeString();\nif (portalName != null && !\"\".equals(portalName)) {\nField field = chr.getField();\nPortal portal = field.getPortalByName(portalName);\nif (portal.getScript() != null && !portal.getScript().equals(\"\")) {\nchr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n} else {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\nif (toField == null) {\nreturn;\n}\nPortal toPortal = toField.getPortalByName(portal.getTargetPortalName());\nif (toPortal == null) {\n\n@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\npublic static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\nChar chr = c.getChr();\nif (inPacket.getUnreadAmount() == 0) {\n\/\/ Coming back from the cash shop\n\/\/ chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\nc.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\nc.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\nreturn;\n}\nbyte fieldKey = inPacket.decodeByte();\nint targetField = inPacket.decodeInt();\nif (targetField == 106020100 || targetField == 106020400) {\n\/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\ntargetField = 106020403;\n} else if (targetField == 106020402) {\n\/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\ntargetField = 106020000;\n}\nint x = inPacket.decodeShort();\nint y = inPacket.decodeShort();\nString portalName = inPacket.decodeString();\nif (portalName != null && !\"\".equals(portalName)) {\nField field = chr.getField();\nPortal portal = field.getPortalByName(portalName);\nif (portal.getScript() != null && !portal.getScript().equals(\"\")) {\nchr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n} else {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\nif (toField == null) {\nreturn;\n}\nPortal toPortal = toField.getPortalByName(portal.getTargetPortalName());\nif (toPortal == null) {\ntoPortal = toField.getPortalByName(\"sp\");\n}\nchr.warp(toField, toPortal);\n\nif (portal.getScript() != null && !portal.getScript().equals(\"\")) {\nchr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n} else {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\nif (toField == null) {\nreturn;\n}\nPortal toPortal = toField.getPortalByName(portal.getTargetPortalName());\nif (toPortal == null) {\ntoPortal = toField.getPortalByName(\"sp\");\n}\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\n\nchr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n} else {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\nif (toField == null) {\nreturn;\n}\nPortal toPortal = toField.getPortalByName(portal.getTargetPortalName());\nif (toPortal == null) {\ntoPortal = toField.getPortalByName(\"sp\");\n}\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\n\n} else {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\nif (toField == null) {\nreturn;\n}\nPortal toPortal = toField.getPortalByName(portal.getTargetPortalName());\nif (toPortal == null) {\ntoPortal = toField.getPortalByName(\"sp\");\n}\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\nchr.healHPMP();\n\nif (toPortal == null) {\ntoPortal = toField.getPortalByName(\"sp\");\n}\nchr.warp(toField, toPortal);\n}\n} else if (chr.getHP() <= 0) {\nif (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\nInGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\nchr.heal(chr.getMaxHP());\nchr.healMP(chr.getMaxMP());\nreturn;\n}\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\nchr.healHPMP();\nreturn;\n} else if (chr.getInstance() != null) {\nchr.getInstance().removeChar(chr);\n} else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\nif (toField != null && chr.getTransferField() > 0) {\n\n\/\/ Character is dead, respawn request\ninPacket.decodeByte(); \/\/ always 0\nbyte tarfield = inPacket.decodeByte(); \/\/ ?\nbyte reviveType = inPacket.decodeByte();\nint returnMap = chr.getField().getReturnMap() == 999999999\n? chr.getPreviousFieldID()\n: chr.getField().getReturnMap();\nswitch (reviveType) {\n\/\/ so far only got 0?\n}\nif (!chr.hasBuffProtector()) {\nchr.getTemporaryStatManager().removeAllStats();\n}\nint deathcount = chr.getDeathCount();\nif (deathcount != 0) {\nif (deathcount > 0) {\ndeathcount--;\nchr.setDeathCount(deathcount);\nchr.write(UserLocal.deathCountInfo(deathcount));\n}\nchr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\nchr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\nchr.healHPMP();\nreturn;\n} else if (chr.getInstance() != null) {\nchr.getInstance().removeChar(chr);\n} else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\nif (toField != null && chr.getTransferField() > 0) {\nchr.warp(toField);\n}\nchr.setTransferField(0);\nreturn;\n} else {\nchr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getField().getForcedReturn()));\n}\nchr.healHPMP();\nchr.setBuffProtector(false);\n} else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\nField toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\nif (toField != null && chr.getTransferField() > 0) {","label":[1,0,1,0]}
{"id":18957,"original_code":"private <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\n      Connection connection,\n      String logMessageName, T obj) throws FatalErrorHalt, AbortRound {\n    byte[] data = null;\n    data = agent.serialize(obj);\n    logJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\n    byte[] lengthBytes = serializeInteger(data.length);\n    try {\n      connection.getOutputStream().write(lengthBytes);\n      connection.getOutputStream().write(data);\n    } catch (SocketException se) {\n      \/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n      \/\/ handleError(GOSSIP_IO_ERROR, se);\n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    } catch (IOException e) {\n      \/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n      \/\/ handleError(GOSSIP_IO_ERROR, e);\n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    }\n  }","code":"private <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\n      Connection connection,\n      String logMessageName, T obj) throws FatalErrorHalt, AbortRound {\n    byte[] data = null;\n    data = agent.serialize(obj);\n    logJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\n    byte[] lengthBytes = serializeInteger(data.length);\n    try {\n      connection.getOutputStream().write(lengthBytes);\n      connection.getOutputStream().write(data);\n    } catch (SocketException se) {\n     \n     \n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    } catch (IOException e) {\n     \n     \n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    }\n  }","cleancode":"private <t extends serializable> void sendobject(communicationpatternagent agent, connection connection, string logmessagename, t obj) throws fatalerrorhalt, abortround { byte[] data = null; data = agent.serialize(obj); logjson(logflag.serialization, \"mica-serialize-bytes-\" + logmessagename, data.length); byte[] lengthbytes = serializeinteger(data.length); try { connection.getoutputstream().write(lengthbytes); connection.getoutputstream().write(data); } catch (socketexception se) { handleerror(gossip_io_error, new abortround()); } catch (ioexception e) { handleerror(gossip_io_error, new abortround()); } }","comment":"\/\/ fixme: check that handleerror is aborting on gossip_io_error \/\/ handleerror(gossip_io_error, se);\n\/\/ fixme: check that handleerror is aborting on gossip_io_error \/\/ handleerror(gossip_io_error, e);","repo":"mica-gossip\/MiCA","code_context_2":"connection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {\n\nconnection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {","code_context_10":"Connection connection,\nString logMessageName, T obj) throws FatalErrorHalt, AbortRound {\nbyte[] data = null;\ndata = agent.serialize(obj);\nlogJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\nbyte[] lengthBytes = serializeInteger(data.length);\ntry {\nconnection.getOutputStream().write(lengthBytes);\nconnection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, e);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n}\n}\n\nConnection connection,\nString logMessageName, T obj) throws FatalErrorHalt, AbortRound {\nbyte[] data = null;\ndata = agent.serialize(obj);\nlogJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\nbyte[] lengthBytes = serializeInteger(data.length);\ntry {\nconnection.getOutputStream().write(lengthBytes);\nconnection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, e);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n}\n}","code_context_20":"private <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\nConnection connection,\nString logMessageName, T obj) throws FatalErrorHalt, AbortRound {\nbyte[] data = null;\ndata = agent.serialize(obj);\nlogJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\nbyte[] lengthBytes = serializeInteger(data.length);\ntry {\nconnection.getOutputStream().write(lengthBytes);\nconnection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, e);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n}\n}\n\nprivate <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\nConnection connection,\nString logMessageName, T obj) throws FatalErrorHalt, AbortRound {\nbyte[] data = null;\ndata = agent.serialize(obj);\nlogJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\nbyte[] lengthBytes = serializeInteger(data.length);\ntry {\nconnection.getOutputStream().write(lengthBytes);\nconnection.getOutputStream().write(data);\n} catch (SocketException se) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, se);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n} catch (IOException e) {\n\/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n\/\/ handleError(GOSSIP_IO_ERROR, e);\nhandleError(GOSSIP_IO_ERROR, new AbortRound());\n}\n}","label":[0,0,1,0]}
{"id":2602,"original_code":"@Test\n  public void testUnionType() throws Exception {\n    String sql =\"SELECT typeof(a) AS t, modeof(a) AS m, drilltypeof(a) AS dt\\n\" +\n                \"FROM cp.`jsoninput\/union\/c.json`\";\n    try {\n      testBuilder()\n        .optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n        .sqlQuery(sql)\n        .ordered()\n        .baselineColumns(\"t\",       \"m\",        \"dt\")\n        .baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n        .baselineValues( \"BIGINT\",  \"NULLABLE\", \"UNION\")\n        .baselineValues( \"FLOAT8\",  \"NULLABLE\", \"UNION\")\n        \/\/ The following should probably provide the type of the list,\n        \/\/ and report cardinality as ARRAY.\n        .baselineValues( \"LIST\",    \"NULLABLE\", \"UNION\")\n        .baselineValues( \"NULL\",    \"NULLABLE\", \"UNION\")\n        .go();\n    }\n    finally {\n      client.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n    }\n  }","code":"@Test\n  public void testUnionType() throws Exception {\n    String sql =\"SELECT typeof(a) AS t, modeof(a) AS m, drilltypeof(a) AS dt\\n\" +\n                \"FROM cp.`jsoninput\/union\/c.json`\";\n    try {\n      testBuilder()\n        .optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n        .sqlQuery(sql)\n        .ordered()\n        .baselineColumns(\"t\",       \"m\",        \"dt\")\n        .baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n        .baselineValues( \"BIGINT\",  \"NULLABLE\", \"UNION\")\n        .baselineValues( \"FLOAT8\",  \"NULLABLE\", \"UNION\")\n       \n       \n        .baselineValues( \"LIST\",    \"NULLABLE\", \"UNION\")\n        .baselineValues( \"NULL\",    \"NULLABLE\", \"UNION\")\n        .go();\n    }\n    finally {\n      client.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n    }\n  }","cleancode":"@test public void testuniontype() throws exception { string sql =\"select typeof(a) as t, modeof(a) as m, drilltypeof(a) as dt\\n\" + \"from cp.`jsoninput\/union\/c.json`\"; try { testbuilder() .optionsettingqueriesfortestquery(\"alter session set `exec.enable_union_type` = true\") .sqlquery(sql) .ordered() .baselinecolumns(\"t\", \"m\", \"dt\") .baselinevalues( \"varchar\", \"nullable\", \"union\") .baselinevalues( \"bigint\", \"nullable\", \"union\") .baselinevalues( \"float8\", \"nullable\", \"union\") .baselinevalues( \"list\", \"nullable\", \"union\") .baselinevalues( \"null\", \"nullable\", \"union\") .go(); } finally { client.resetsession(execconstants.enable_union_type_key); } }","comment":"\/\/ the following should probably provide the type of the list, \/\/ and report cardinality as array.","repo":"julien-faye\/drill","code_context_2":".baselineValues( \"BIGINT\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"FLOAT8\", \"NULLABLE\", \"UNION\")\n\/\/ The following should probably provide the type of the list,\n\/\/ and report cardinality as ARRAY.\n.baselineValues( \"LIST\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"NULL\", \"NULLABLE\", \"UNION\")","code_context_10":"\"FROM cp.`jsoninput\/union\/c.json`\";\ntry {\ntestBuilder()\n.optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n.sqlQuery(sql)\n.ordered()\n.baselineColumns(\"t\", \"m\", \"dt\")\n.baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"BIGINT\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"FLOAT8\", \"NULLABLE\", \"UNION\")\n\/\/ The following should probably provide the type of the list,\n\/\/ and report cardinality as ARRAY.\n.baselineValues( \"LIST\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"NULL\", \"NULLABLE\", \"UNION\")\n.go();\n}\nfinally {\nclient.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n}\n}","code_context_20":"@Test\npublic void testUnionType() throws Exception {\nString sql =\"SELECT typeof(a) AS t, modeof(a) AS m, drilltypeof(a) AS dt\\n\" +\n\"FROM cp.`jsoninput\/union\/c.json`\";\ntry {\ntestBuilder()\n.optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n.sqlQuery(sql)\n.ordered()\n.baselineColumns(\"t\", \"m\", \"dt\")\n.baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"BIGINT\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"FLOAT8\", \"NULLABLE\", \"UNION\")\n\/\/ The following should probably provide the type of the list,\n\/\/ and report cardinality as ARRAY.\n.baselineValues( \"LIST\", \"NULLABLE\", \"UNION\")\n.baselineValues( \"NULL\", \"NULLABLE\", \"UNION\")\n.go();\n}\nfinally {\nclient.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n}\n}","label":[1,0,0,0]}
{"id":10862,"original_code":"@Test\n    public void test20046() throws Throwable {\n        if (debug)\n            System.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\n        org.jsoup.helper.HttpConnection.Response response0 = null;\n        org.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\n        org.jsoup.Connection.Request request2 = null;\n        response1.req = request2;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\n        response1.charset = \"hi!\";\n        int int8 = response1.numRedirects;\n        response1.contentType = \"hi!\";\n        java.nio.ByteBuffer byteBuffer11 = response1.byteData;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\n        response1.numRedirects = (short) 10;\n        response1.contentType = \"\";\n        boolean boolean19 = response1.hasCookie(\"hi!\");\n        java.lang.String str20 = response1.statusMessage();\n        int int21 = response1.statusCode();\n        \/\/ The following exception was thrown during execution in test generation\n        try {\n            org.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky:             org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n        } catch (java.io.IOException e) {\n        \/\/ Expected exception.\n        }\n        org.junit.Assert.assertNull(strEntry5);\n        org.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\n        org.junit.Assert.assertNull(byteBuffer11);\n        org.junit.Assert.assertNull(strEntry13);\n        org.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\n        org.junit.Assert.assertNull(str20);\n        org.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n    }","code":"@Test\n    public void test20046() throws Throwable {\n        if (debug)\n            System.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\n        org.jsoup.helper.HttpConnection.Response response0 = null;\n        org.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\n        org.jsoup.Connection.Request request2 = null;\n        response1.req = request2;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\n        response1.charset = \"hi!\";\n        int int8 = response1.numRedirects;\n        response1.contentType = \"hi!\";\n        java.nio.ByteBuffer byteBuffer11 = response1.byteData;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\n        response1.numRedirects = (short) 10;\n        response1.contentType = \"\";\n        boolean boolean19 = response1.hasCookie(\"hi!\");\n        java.lang.String str20 = response1.statusMessage();\n        int int21 = response1.statusCode();\n       \n        try {\n            org.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n        } catch (java.io.IOException e) {\n       \n        }\n        org.junit.Assert.assertNull(strEntry5);\n        org.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\n        org.junit.Assert.assertNull(byteBuffer11);\n        org.junit.Assert.assertNull(strEntry13);\n        org.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\n        org.junit.Assert.assertNull(str20);\n        org.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n    }","cleancode":"@test public void test20046() throws throwable { if (debug) system.out.format(\"%n%s%n\", \"regressiontest40.test20046\"); org.jsoup.helper.httpconnection.response response0 = null; org.jsoup.helper.httpconnection.response response1 = new org.jsoup.helper.httpconnection.response(response0); org.jsoup.connection.request request2 = null; response1.req = request2; java.util.map.entry<java.lang.string, java.lang.string> strentry5 = response1.scanheaders(\"hi!\"); response1.charset = \"hi!\"; int int8 = response1.numredirects; response1.contenttype = \"hi!\"; java.nio.bytebuffer bytebuffer11 = response1.bytedata; java.util.map.entry<java.lang.string, java.lang.string> strentry13 = response1.scanheaders(\"\"); response1.numredirects = (short) 10; response1.contenttype = \"\"; boolean boolean19 = response1.hascookie(\"hi!\"); java.lang.string str20 = response1.statusmessage(); int int21 = response1.statuscode(); try { org.jsoup.helper.httpconnection.response response22 = new org.jsoup.helper.httpconnection.response(response1); } catch (java.io.ioexception e) { } org.junit.assert.assertnull(strentry5); org.junit.assert.asserttrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0); org.junit.assert.assertnull(bytebuffer11); org.junit.assert.assertnull(strentry13); org.junit.assert.asserttrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false); org.junit.assert.assertnull(str20); org.junit.assert.asserttrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0); }","comment":"\/\/ the following exception was thrown during execution in test generation\n\/\/ flaky: org.junit.assert.fail(\"expected exception of type java.io.ioexception; message: too many redirects occurred trying to load url null\");\n\/\/ expected exception.","repo":"leusonmario\/2022PhDThesis","code_context_2":"java.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);","code_context_10":"response1.charset = \"hi!\";\nint int8 = response1.numRedirects;\nresponse1.contentType = \"hi!\";\njava.nio.ByteBuffer byteBuffer11 = response1.byteData;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\n\njava.nio.ByteBuffer byteBuffer11 = response1.byteData;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\norg.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\norg.junit.Assert.assertNull(str20);\norg.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\norg.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\norg.junit.Assert.assertNull(str20);\norg.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n}","code_context_20":"@Test\npublic void test20046() throws Throwable {\nif (debug)\nSystem.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\norg.jsoup.helper.HttpConnection.Response response0 = null;\norg.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\norg.jsoup.Connection.Request request2 = null;\nresponse1.req = request2;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\nresponse1.charset = \"hi!\";\nint int8 = response1.numRedirects;\nresponse1.contentType = \"hi!\";\njava.nio.ByteBuffer byteBuffer11 = response1.byteData;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\norg.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\norg.junit.Assert.assertNull(str20);\norg.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n}\n\nif (debug)\nSystem.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\norg.jsoup.helper.HttpConnection.Response response0 = null;\norg.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\norg.jsoup.Connection.Request request2 = null;\nresponse1.req = request2;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\nresponse1.charset = \"hi!\";\nint int8 = response1.numRedirects;\nresponse1.contentType = \"hi!\";\njava.nio.ByteBuffer byteBuffer11 = response1.byteData;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\norg.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\norg.junit.Assert.assertNull(str20);\norg.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n}\n\norg.jsoup.helper.HttpConnection.Response response0 = null;\norg.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\norg.jsoup.Connection.Request request2 = null;\nresponse1.req = request2;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\nresponse1.charset = \"hi!\";\nint int8 = response1.numRedirects;\nresponse1.contentType = \"hi!\";\njava.nio.ByteBuffer byteBuffer11 = response1.byteData;\njava.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\nresponse1.numRedirects = (short) 10;\nresponse1.contentType = \"\";\nboolean boolean19 = response1.hasCookie(\"hi!\");\njava.lang.String str20 = response1.statusMessage();\nint int21 = response1.statusCode();\n\/\/ The following exception was thrown during execution in test generation\ntry {\norg.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky: org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n} catch (java.io.IOException e) {\n\/\/ Expected exception.\n}\norg.junit.Assert.assertNull(strEntry5);\norg.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\norg.junit.Assert.assertNull(byteBuffer11);\norg.junit.Assert.assertNull(strEntry13);\norg.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\norg.junit.Assert.assertNull(str20);\norg.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n}","label":[0,0,1,0]}
{"id":10871,"original_code":"private void checkNullable() {\n      if (ConfigurationAnnotations.getNullableType(element).isPresent()) {\n        report.addWarning(\"@Nullable on @Produces methods does not do anything\");\n      }\n    }","code":"private void checkNullable() {\n      if (ConfigurationAnnotations.getNullableType(element).isPresent()) {\n        report.addWarning(\"@Nullable on @Produces methods does not do anything\");\n      }\n    }","cleancode":"private void checknullable() { if (configurationannotations.getnullabletype(element).ispresent()) { report.addwarning(\"@nullable on @produces methods does not do anything\"); } }","comment":"\/** adds a warning if a {@link produces @produces} method is declared nullable. *\/ \/\/ todo(beder): properly handle nullable with producer methods.","repo":"lynnfield\/dagger","code_context_2":"private void checkNullable() {\nif (ConfigurationAnnotations.getNullableType(element).isPresent()) {\nreport.addWarning(\"@Nullable on @Produces methods does not do anything\");\n}\n}","code_context_10":"private void checkNullable() {\nif (ConfigurationAnnotations.getNullableType(element).isPresent()) {\nreport.addWarning(\"@Nullable on @Produces methods does not do anything\");\n}\n}","code_context_20":"private void checkNullable() {\nif (ConfigurationAnnotations.getNullableType(element).isPresent()) {\nreport.addWarning(\"@Nullable on @Produces methods does not do anything\");\n}\n}","label":[0,1,0,0]}
{"id":19094,"original_code":"private IMRIValueListener createValueListener() {\n\t\treturn new IMRIValueListener() {\n\t\t\t@Override\n\t\t\tpublic void valueChanged(MRIValueEvent event) {\n\t\t\t\tif (event.getValue() instanceof CompositeData) {\n\t\t\t\t\t\/\/ FIXME: change to a better test of containment?\n\t\t\t\t\tdispose();\n\t\t\t\t\tm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","code":"private IMRIValueListener createValueListener() {\n\t\treturn new IMRIValueListener() {\n\t\t\t@Override\n\t\t\tpublic void valueChanged(MRIValueEvent event) {\n\t\t\t\tif (event.getValue() instanceof CompositeData) {\n\t\t\t\t\n\t\t\t\t\tdispose();\n\t\t\t\t\tm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","cleancode":"private imrivaluelistener createvaluelistener() { return new imrivaluelistener() { @override public void valuechanged(mrivalueevent event) { if (event.getvalue() instanceof compositedata) { dispose(); m_repository.movepossiblechildsubscriptions(unavailablechildsubscriptions.this); } } }; }","comment":"\/\/ fixme: change to a better test of containment?","repo":"meghasfdc\/jmc","code_context_2":"public void valueChanged(MRIValueEvent event) {\nif (event.getValue() instanceof CompositeData) {\n\/\/ FIXME: change to a better test of containment?\ndispose();\nm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);","code_context_10":"private IMRIValueListener createValueListener() {\nreturn new IMRIValueListener() {\n@Override\npublic void valueChanged(MRIValueEvent event) {\nif (event.getValue() instanceof CompositeData) {\n\/\/ FIXME: change to a better test of containment?\ndispose();\nm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n}\n}\n};\n}","code_context_20":"private IMRIValueListener createValueListener() {\nreturn new IMRIValueListener() {\n@Override\npublic void valueChanged(MRIValueEvent event) {\nif (event.getValue() instanceof CompositeData) {\n\/\/ FIXME: change to a better test of containment?\ndispose();\nm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n}\n}\n};\n}","label":[1,0,0,0]}
{"id":19169,"original_code":"private boolean ruleMatches(String text, String pattern) {\n        int patternPos = 0;\n        int textPos = 0;\n        int patternEnd = pattern.length();\n        int textEnd = text.length();\n        boolean containsEndChar = pattern.endsWith(\"$\");\n        if (containsEndChar) {\n            patternEnd -= 1;\n        }\n        while ((patternPos < patternEnd) && (textPos < textEnd)) {\n            \/\/ Find next wildcard in the pattern.\n            int wildcardPos = pattern.indexOf('*', patternPos);\n            if (wildcardPos == -1) {\n                wildcardPos = patternEnd;\n            }\n            \/\/ If we're at a wildcard in the pattern, find the place in the text\n            \/\/ where the character(s) after the wildcard match up with what's in\n            \/\/ the text.\n            if (wildcardPos == patternPos) {\n                patternPos += 1;\n                if (patternPos >= patternEnd) {\n                    \/\/ Pattern ends with '*', we're all good.\n                    return true;\n                }\n                \/\/ TODO - don't worry about having two '*' in a row?\n                \/\/ Find the end of the pattern piece we need to match.\n                int patternPieceEnd = pattern.indexOf('*', patternPos);\n                if (patternPieceEnd == -1) {\n                    patternPieceEnd = patternEnd;\n                }\n                boolean matched = false;\n                int patternPieceLen = patternPieceEnd - patternPos;\n                while ((textPos + patternPieceLen <= textEnd) && !matched) {\n                    \/\/ See if patternPieceLen chars from text at textPos match\n                    \/\/ chars from pattern at patternPos\n                    matched = true;\n                    for (int i = 0; i < patternPieceLen && matched; i++) {\n                        if (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\n                            matched = false;\n                        }\n                    }\n                    \/\/ If we matched, we're all set, otherwise we have to\n                    \/\/ advance textPos\n                    if (!matched) {\n                        textPos += 1;\n                    }\n                }\n                \/\/ If we matched, we're all set, otherwise we failed\n                if (!matched) {\n                    return false;\n                }\n            } else {\n                \/\/ See if the pattern from patternPos to wildcardPos matches the\n                \/\/ text starting at textPos\n                while ((patternPos < wildcardPos) && (textPos < textEnd)) {\n                    if (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \/\/ If we didn't reach the end of the pattern, make sure we're not at a\n        \/\/ wildcard, that's a 0 or more match, so then we're still OK.\n        while ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\n            patternPos += 1;\n        }\n        \/\/ We're at the end, so we have a match if the pattern was completely\n        \/\/ consumed, and either we consumed all the text or we didn't have to\n        \/\/ match it all (no '$' at end of the pattern)\n        return (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n    }","code":"private boolean ruleMatches(String text, String pattern) {\n        int patternPos = 0;\n        int textPos = 0;\n        int patternEnd = pattern.length();\n        int textEnd = text.length();\n        boolean containsEndChar = pattern.endsWith(\"$\");\n        if (containsEndChar) {\n            patternEnd -= 1;\n        }\n        while ((patternPos < patternEnd) && (textPos < textEnd)) {\n           \n            int wildcardPos = pattern.indexOf('*', patternPos);\n            if (wildcardPos == -1) {\n                wildcardPos = patternEnd;\n            }\n           \n           \n           \n            if (wildcardPos == patternPos) {\n                patternPos += 1;\n                if (patternPos >= patternEnd) {\n                   \n                    return true;\n                }\n               \n               \n                int patternPieceEnd = pattern.indexOf('*', patternPos);\n                if (patternPieceEnd == -1) {\n                    patternPieceEnd = patternEnd;\n                }\n                boolean matched = false;\n                int patternPieceLen = patternPieceEnd - patternPos;\n                while ((textPos + patternPieceLen <= textEnd) && !matched) {\n                   \n                   \n                    matched = true;\n                    for (int i = 0; i < patternPieceLen && matched; i++) {\n                        if (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\n                            matched = false;\n                        }\n                    }\n                   \n                   \n                    if (!matched) {\n                        textPos += 1;\n                    }\n                }\n               \n                if (!matched) {\n                    return false;\n                }\n            } else {\n               \n               \n                while ((patternPos < wildcardPos) && (textPos < textEnd)) {\n                    if (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n       \n       \n        while ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\n            patternPos += 1;\n        }\n       \n       \n       \n        return (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n    }","cleancode":"private boolean rulematches(string text, string pattern) { int patternpos = 0; int textpos = 0; int patternend = pattern.length(); int textend = text.length(); boolean containsendchar = pattern.endswith(\"$\"); if (containsendchar) { patternend -= 1; } while ((patternpos < patternend) && (textpos < textend)) { int wildcardpos = pattern.indexof('*', patternpos); if (wildcardpos == -1) { wildcardpos = patternend; } if (wildcardpos == patternpos) { patternpos += 1; if (patternpos >= patternend) { return true; } int patternpieceend = pattern.indexof('*', patternpos); if (patternpieceend == -1) { patternpieceend = patternend; } boolean matched = false; int patternpiecelen = patternpieceend - patternpos; while ((textpos + patternpiecelen <= textend) && !matched) { matched = true; for (int i = 0; i < patternpiecelen && matched; i++) { if (text.charat(textpos + i) != pattern.charat(patternpos + i)) { matched = false; } } if (!matched) { textpos += 1; } } if (!matched) { return false; } } else { while ((patternpos < wildcardpos) && (textpos < textend)) { if (text.charat(textpos++) != pattern.charat(patternpos++)) { return false; } } } } while ((patternpos < patternend) && (pattern.charat(patternpos) == '*')) { patternpos += 1; } return (patternpos == patternend) && ((textpos == textend) || !containsendchar); }","comment":"\/\/ find next wildcard in the pattern.\n\/\/ if we're at a wildcard in the pattern, find the place in the text \/\/ where the character(s) after the wildcard match up with what's in \/\/ the text.\n\/\/ pattern ends with '*', we're all good.\n\/\/ todo - don't worry about having two '*' in a row? \/\/ find the end of the pattern piece we need to match.\n\/\/ see if patternpiecelen chars from text at textpos match \/\/ chars from pattern at patternpos\n\/\/ if we matched, we're all set, otherwise we have to \/\/ advance textpos\n\/\/ if we matched, we're all set, otherwise we failed\n\/\/ see if the pattern from patternpos to wildcardpos matches the \/\/ text starting at textpos\n\/\/ if we didn't reach the end of the pattern, make sure we're not at a \/\/ wildcard, that's a 0 or more match, so then we're still ok.\n\/\/ we're at the end, so we have a match if the pattern was completely \/\/ consumed, and either we consumed all the text or we didn't have to \/\/ match it all (no '$' at end of the pattern)","repo":"kovyrin\/crawler-commons","code_context_2":"}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\n\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\n\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\n\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\n\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\n\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}","code_context_10":"private boolean ruleMatches(String text, String pattern) {\nint patternPos = 0;\nint textPos = 0;\nint patternEnd = pattern.length();\nint textEnd = text.length();\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\n\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\n\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\n\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\n\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}\n\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}","code_context_20":"private boolean ruleMatches(String text, String pattern) {\nint patternPos = 0;\nint textPos = 0;\nint patternEnd = pattern.length();\nint textEnd = text.length();\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\n\nprivate boolean ruleMatches(String text, String pattern) {\nint patternPos = 0;\nint textPos = 0;\nint patternEnd = pattern.length();\nint textEnd = text.length();\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\n\nint patternPos = 0;\nint textPos = 0;\nint patternEnd = pattern.length();\nint textEnd = text.length();\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\nint textEnd = text.length();\nboolean containsEndChar = pattern.endsWith(\"$\");\nif (containsEndChar) {\npatternEnd -= 1;\n}\nwhile ((patternPos < patternEnd) && (textPos < textEnd)) {\n\/\/ Find next wildcard in the pattern.\nint wildcardPos = pattern.indexOf('*', patternPos);\nif (wildcardPos == -1) {\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n\nwildcardPos = patternEnd;\n}\n\/\/ If we're at a wildcard in the pattern, find the place in the text\n\/\/ where the character(s) after the wildcard match up with what's in\n\/\/ the text.\nif (wildcardPos == patternPos) {\npatternPos += 1;\nif (patternPos >= patternEnd) {\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\n\n\/\/ Pattern ends with '*', we're all good.\nreturn true;\n}\n\/\/ TODO - don't worry about having two '*' in a row?\n\/\/ Find the end of the pattern piece we need to match.\nint patternPieceEnd = pattern.indexOf('*', patternPos);\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\n\nif (patternPieceEnd == -1) {\npatternPieceEnd = patternEnd;\n}\nboolean matched = false;\nint patternPieceLen = patternPieceEnd - patternPos;\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\nwhile ((textPos + patternPieceLen <= textEnd) && !matched) {\n\/\/ See if patternPieceLen chars from text at textPos match\n\/\/ chars from pattern at patternPos\nmatched = true;\nfor (int i = 0; i < patternPieceLen && matched; i++) {\nif (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\nmatched = false;\n}\n}\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}\n\n\/\/ If we matched, we're all set, otherwise we have to\n\/\/ advance textPos\nif (!matched) {\ntextPos += 1;\n}\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}\n\n}\n\/\/ If we matched, we're all set, otherwise we failed\nif (!matched) {\nreturn false;\n}\n} else {\n\/\/ See if the pattern from patternPos to wildcardPos matches the\n\/\/ text starting at textPos\nwhile ((patternPos < wildcardPos) && (textPos < textEnd)) {\nif (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\nreturn false;\n}\n}\n}\n}\n\/\/ If we didn't reach the end of the pattern, make sure we're not at a\n\/\/ wildcard, that's a 0 or more match, so then we're still OK.\nwhile ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\npatternPos += 1;\n}\n\/\/ We're at the end, so we have a match if the pattern was completely\n\/\/ consumed, and either we consumed all the text or we didn't have to\n\/\/ match it all (no '$' at end of the pattern)\nreturn (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n}","label":[1,0,0,0]}
{"id":11110,"original_code":"private void validateImportPackage(IProgressMonitor monitor) {\n        IHeader header = getHeader(Constants.IMPORT_PACKAGE);\n        if (header == null)\n            return;\n        BundleDescription desc = fModel.getBundleDescription();\n        if (desc == null) {\n            ManifestElement[] elements = header.getElements();\n            for (int i = 0; i < elements.length; i++) {\n                validateSpecificationVersionAttribute(header, elements[i]);\n                validateImportPackageVersion(header, elements[i]);\n            }\n            return;\n        }\n        boolean hasUnresolved = false;\n        VersionConstraint[] constraints = desc.getContainingState().getStateHelper().getUnsatisfiedConstraints(desc);\n        for (int i = 0; i < constraints.length; i++) {\n            if (constraints[i] instanceof ImportPackageSpecification) {\n                hasUnresolved = true;\n                break;\n            }\n        }\n        HashMap<String, ExportPackageDescription> exported = getAvailableExportedPackages(desc.getContainingState());\n        ImportPackageSpecification[] imports = desc.getImportPackages();\n        if (desc.hasDynamicImports()) {\n            List<ImportPackageSpecification> staticImportsList = new ArrayList();\n            for (int i = 0; i < imports.length; ++i) {\n                if (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\n                    staticImportsList.add(imports[i]);\n            }\n            imports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n        }\n        ManifestElement[] elements = header.getElements();\n        int index = 0;\n        for (int i = 0; i < elements.length; i++) {\n            checkCanceled(monitor);\n            validateSpecificationVersionAttribute(header, elements[i]);\n            validateResolutionDirective(header, elements[i]);\n            \/\/ TODO we should only validate versions that we have a match\n            validateImportPackageVersion(header, elements[i]);\n            if (!hasUnresolved)\n                continue;\n            int length = elements[i].getValueComponents().length;\n            for (int j = 0; j < length; j++) {\n                ImportPackageSpecification importSpec = imports[index++];\n                String name = importSpec.getName();\n                if (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n                name.equals(\"java\") || name.startsWith(\"java.\")) {\n                    IHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n                    if (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\n                    jreHeader.getValue())) {\n                        report(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\n                        continue;\n                    }\n                }\n                if (importSpec.isResolved() || !isCheckUnresolvedImports())\n                    continue;\n                boolean optional = isOptional(elements[i]);\n                int severity = getRequireBundleSeverity(elements[i], optional);\n                ExportPackageDescription export = exported.get(name);\n                if (export != null) {\n                    if (export.getSupplier().isResolved()) {\n                        Version version = export.getVersion();\n                        org.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\n                        if (range != null && !range.isIncluded(version)) {\n                            report(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n                        }\n                    } else {\n                        report(NLS.bind(PDECoreMessages.BundleErrorReporter_unresolvedExporter, new String[] { export.getSupplier().getSymbolicName(), name }), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_OTHER);\n                    }\n                } else {\n                    IMarker marker = report(NLS.bind(PDECoreMessages.BundleErrorReporter_PackageNotExported, name), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.M_IMPORT_PKG_NOT_AVAILABLE, PDEMarkerFactory.CAT_FATAL);\n                    try {\n                        if (marker != null) {\n                            \/\/$NON-NLS-1$\n                            marker.setAttribute(\/\/$NON-NLS-1$\n                            \"packageName\", \/\/$NON-NLS-1$\n                            name);\n                            if (optional)\n                                \/\/$NON-NLS-1$\n                                marker.setAttribute(\/\/$NON-NLS-1$\n                                \"optional\", \/\/$NON-NLS-1$\n                                true);\n                        }\n                    } catch (CoreException e) {\n                    }\n                }\n            }\n        }\n    }","code":"private void validateImportPackage(IProgressMonitor monitor) {\n        IHeader header = getHeader(Constants.IMPORT_PACKAGE);\n        if (header == null)\n            return;\n        BundleDescription desc = fModel.getBundleDescription();\n        if (desc == null) {\n            ManifestElement[] elements = header.getElements();\n            for (int i = 0; i < elements.length; i++) {\n                validateSpecificationVersionAttribute(header, elements[i]);\n                validateImportPackageVersion(header, elements[i]);\n            }\n            return;\n        }\n        boolean hasUnresolved = false;\n        VersionConstraint[] constraints = desc.getContainingState().getStateHelper().getUnsatisfiedConstraints(desc);\n        for (int i = 0; i < constraints.length; i++) {\n            if (constraints[i] instanceof ImportPackageSpecification) {\n                hasUnresolved = true;\n                break;\n            }\n        }\n        HashMap<String, ExportPackageDescription> exported = getAvailableExportedPackages(desc.getContainingState());\n        ImportPackageSpecification[] imports = desc.getImportPackages();\n        if (desc.hasDynamicImports()) {\n            List<ImportPackageSpecification> staticImportsList = new ArrayList();\n            for (int i = 0; i < imports.length; ++i) {\n                if (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\n                    staticImportsList.add(imports[i]);\n            }\n            imports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n        }\n        ManifestElement[] elements = header.getElements();\n        int index = 0;\n        for (int i = 0; i < elements.length; i++) {\n            checkCanceled(monitor);\n            validateSpecificationVersionAttribute(header, elements[i]);\n            validateResolutionDirective(header, elements[i]);\n           \n            validateImportPackageVersion(header, elements[i]);\n            if (!hasUnresolved)\n                continue;\n            int length = elements[i].getValueComponents().length;\n            for (int j = 0; j < length; j++) {\n                ImportPackageSpecification importSpec = imports[index++];\n                String name = importSpec.getName();\n                if \n                name.equals(\"java\") || name.startsWith(\"java.\")) {\n                    IHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n                    if (jreHeader == null || !\"true\".equals\n                    jreHeader.getValue())) {\n                        report(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\n                        continue;\n                    }\n                }\n                if (importSpec.isResolved() || !isCheckUnresolvedImports())\n                    continue;\n                boolean optional = isOptional(elements[i]);\n                int severity = getRequireBundleSeverity(elements[i], optional);\n                ExportPackageDescription export = exported.get(name);\n                if (export != null) {\n                    if (export.getSupplier().isResolved()) {\n                        Version version = export.getVersion();\n                        org.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\n                        if (range != null && !range.isIncluded(version)) {\n                            report(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n                        }\n                    } else {\n                        report(NLS.bind(PDECoreMessages.BundleErrorReporter_unresolvedExporter, new String[] { export.getSupplier().getSymbolicName(), name }), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_OTHER);\n                    }\n                } else {\n                    IMarker marker = report(NLS.bind(PDECoreMessages.BundleErrorReporter_PackageNotExported, name), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.M_IMPORT_PKG_NOT_AVAILABLE, PDEMarkerFactory.CAT_FATAL);\n                    try {\n                        if (marker != null) {\n                           \n                            marker.setAttribute\n                            \"packageName\",\n                            name);\n                            if (optional)\n                               \n                                marker.setAttribute\n                                \"optional\",\n                                true);\n                        }\n                    } catch (CoreException e) {\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void validateimportpackage(iprogressmonitor monitor) { iheader header = getheader(constants.import_package); if (header == null) return; bundledescription desc = fmodel.getbundledescription(); if (desc == null) { manifestelement[] elements = header.getelements(); for (int i = 0; i < elements.length; i++) { validatespecificationversionattribute(header, elements[i]); validateimportpackageversion(header, elements[i]); } return; } boolean hasunresolved = false; versionconstraint[] constraints = desc.getcontainingstate().getstatehelper().getunsatisfiedconstraints(desc); for (int i = 0; i < constraints.length; i++) { if (constraints[i] instanceof importpackagespecification) { hasunresolved = true; break; } } hashmap<string, exportpackagedescription> exported = getavailableexportedpackages(desc.getcontainingstate()); importpackagespecification[] imports = desc.getimportpackages(); if (desc.hasdynamicimports()) { list<importpackagespecification> staticimportslist = new arraylist(); for (int i = 0; i < imports.length; ++i) { if (!imports[i].getdirective(constants.resolution_directive).equals(importpackagespecification.resolution_dynamic)) staticimportslist.add(imports[i]); } imports = staticimportslist.toarray(new importpackagespecification[staticimportslist.size()]); } manifestelement[] elements = header.getelements(); int index = 0; for (int i = 0; i < elements.length; i++) { checkcanceled(monitor); validatespecificationversionattribute(header, elements[i]); validateresolutiondirective(header, elements[i]); validateimportpackageversion(header, elements[i]); if (!hasunresolved) continue; int length = elements[i].getvaluecomponents().length; for (int j = 0; j < length; j++) { importpackagespecification importspec = imports[index++]; string name = importspec.getname(); if name.equals(\"java\") || name.startswith(\"java.\")) { iheader jreheader = getheader(icoreconstants.eclipse_jrebundle); if (jreheader == null || !\"true\".equals jreheader.getvalue())) { report(pdecoremessages.bundleerrorreporter_importnojre, getpackageline(header, elements[i]), compilerflags.error, pdemarkerfactory.m_java_package__ported, pdemarkerfactory.cat_fatal); continue; } } if (importspec.isresolved() || !ischeckunresolvedimports()) continue; boolean optional = isoptional(elements[i]); int severity = getrequirebundleseverity(elements[i], optional); exportpackagedescription export = exported.get(name); if (export != null) { if (export.getsupplier().isresolved()) { version version = export.getversion(); org.eclipse.osgi.service.resolver.versionrange range = importspec.getversionrange(); if (range != null && !range.isincluded(version)) { report(nls.bind(pdecoremessages.bundleerrorreporter_unsatisfiedconstraint, importspec.tostring()), getpackageline(header, elements[i]), severity, pdemarkerfactory.cat_fatal); } } else { report(nls.bind(pdecoremessages.bundleerrorreporter_unresolvedexporter, new string[] { export.getsupplier().getsymbolicname(), name }), getpackageline(header, elements[i]), severity, pdemarkerfactory.cat_other); } } else { imarker marker = report(nls.bind(pdecoremessages.bundleerrorreporter_packagenotexported, name), getpackageline(header, elements[i]), severity, pdemarkerfactory.m_import_pkg_not_available, pdemarkerfactory.cat_fatal); try { if (marker != null) { marker.setattribute \"packagename\", name); if (optional) marker.setattribute \"optional\", true); } } catch (coreexception e) { } } } } }","comment":"\/\/ todo we should only validate versions that we have a match\n\/\/$non-nls-1$ \/\/$non-nls-2$\n\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/$non-nls-1$\n\/\/$non-nls-1$","repo":"masud-technope\/BLIZZARD-Replication-Package-ESEC-FSE2018","code_context_2":"validateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);","code_context_10":"staticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\n\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;","code_context_20":"hasUnresolved = true;\nbreak;\n}\n}\nHashMap<String, ExportPackageDescription> exported = getAvailableExportedPackages(desc.getContainingState());\nImportPackageSpecification[] imports = desc.getImportPackages();\nif (desc.hasDynamicImports()) {\nList<ImportPackageSpecification> staticImportsList = new ArrayList();\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}\n\nfor (int i = 0; i < imports.length; ++i) {\nif (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\nstaticImportsList.add(imports[i]);\n}\nimports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n}\nManifestElement[] elements = header.getElements();\nint index = 0;\nfor (int i = 0; i < elements.length; i++) {\ncheckCanceled(monitor);\nvalidateSpecificationVersionAttribute(header, elements[i]);\nvalidateResolutionDirective(header, elements[i]);\n\/\/ TODO we should only validate versions that we have a match\nvalidateImportPackageVersion(header, elements[i]);\nif (!hasUnresolved)\ncontinue;\nint length = elements[i].getValueComponents().length;\nfor (int j = 0; j < length; j++) {\nImportPackageSpecification importSpec = imports[index++];\nString name = importSpec.getName();\nif (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\nname.equals(\"java\") || name.startsWith(\"java.\")) {\nIHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\nif (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\njreHeader.getValue())) {\nreport(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\ncontinue;\n}\n}\nif (importSpec.isResolved() || !isCheckUnresolvedImports())\ncontinue;\nboolean optional = isOptional(elements[i]);\nint severity = getRequireBundleSeverity(elements[i], optional);\nExportPackageDescription export = exported.get(name);\nif (export != null) {\nif (export.getSupplier().isResolved()) {\nVersion version = export.getVersion();\norg.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\nif (range != null && !range.isIncluded(version)) {\nreport(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n}","label":[1,0,0,0]}
{"id":3341,"original_code":"@Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch(item.getItemId()) {\n            case R.id.clean_all:\n                db.open();\n                db.drop();\n                db.close();\n                break;\n            case R.id.manage_backup:\n                db.Backup();\n                break;\n            case R.id.manage_funds:\n                startActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\n                break;\n                                                \/*\n                                                    TODO: check for possibility to chain\/join\/combine xml menus\n                                                    TODO: manage recurring funds (ie set monthly incomes\/payments)\n                                                *\/\n            default:\n                Log.e (TAG, \"MENU = WTF?\");\n        }\n        return super.onOptionsItemSelected(item);\n    }","code":"@Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch(item.getItemId()) {\n            case R.id.clean_all:\n                db.open();\n                db.drop();\n                db.close();\n                break;\n            case R.id.manage_backup:\n                db.Backup();\n                break;\n            case R.id.manage_funds:\n                startActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\n                break;\n                                               \n            default:\n                Log.e (TAG, \"MENU = WTF?\");\n        }\n        return super.onOptionsItemSelected(item);\n    }","cleancode":"@override public boolean onoptionsitemselected(menuitem item) { switch(item.getitemid()) { case r.id.clean_all: db.open(); db.drop(); db.close(); break; case r.id.manage_backup: db.backup(); break; case r.id.manage_funds: startactivityforresult(new intent(bilansview.this, bilansstatussetting.class), 1); break; default: log.e (tag, \"menu = wtf?\"); } return super.onoptionsitemselected(item); }","comment":"\/* todo: check for possibility to chain\/join\/combine xml menus todo: manage recurring funds (ie set monthly incomes\/payments) *\/","repo":"kkrolczyk\/Schowek","code_context_2":"startActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\nbreak;\n\/*\nTODO: check for possibility to chain\/join\/combine xml menus\nTODO: manage recurring funds (ie set monthly incomes\/payments)\n*\/\ndefault:\nLog.e (TAG, \"MENU = WTF?\");","code_context_10":"db.open();\ndb.drop();\ndb.close();\nbreak;\ncase R.id.manage_backup:\ndb.Backup();\nbreak;\ncase R.id.manage_funds:\nstartActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\nbreak;\n\/*\nTODO: check for possibility to chain\/join\/combine xml menus\nTODO: manage recurring funds (ie set monthly incomes\/payments)\n*\/\ndefault:\nLog.e (TAG, \"MENU = WTF?\");\n}\nreturn super.onOptionsItemSelected(item);\n}","code_context_20":"@Override\npublic boolean onOptionsItemSelected(MenuItem item) {\nswitch(item.getItemId()) {\ncase R.id.clean_all:\ndb.open();\ndb.drop();\ndb.close();\nbreak;\ncase R.id.manage_backup:\ndb.Backup();\nbreak;\ncase R.id.manage_funds:\nstartActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\nbreak;\n\/*\nTODO: check for possibility to chain\/join\/combine xml menus\nTODO: manage recurring funds (ie set monthly incomes\/payments)\n*\/\ndefault:\nLog.e (TAG, \"MENU = WTF?\");\n}\nreturn super.onOptionsItemSelected(item);\n}","label":[0,1,0,0]}
{"id":3342,"original_code":"private void updateSingleAccount(double amount, String account_name) {\n        \/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n        \/\/ so for now - hardcoded for backwards compatiblility\n        if (account_name.equals(\"bankomat\")){\n            status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n        }\n        else {\n            status_disp.reduce_wealth(account_name, (float) amount);\n            Log.e(TAG, account_name + \" \" + amount);\n        }\n    }","code":"private void updateSingleAccount(double amount, String account_name) {\n       \n       \n        if (account_name.equals(\"bankomat\")){\n            status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount);\n        }\n        else {\n            status_disp.reduce_wealth(account_name, (float) amount);\n            Log.e(TAG, account_name + \" \" + amount);\n        }\n    }","cleancode":"private void updatesingleaccount(double amount, string account_name) { if (account_name.equals(\"bankomat\")){ status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); } else { status_disp.reduce_wealth(account_name, (float) amount); log.e(tag, account_name + \" \" + amount); } }","comment":"\/\/ ok nasty hack here. currently account have no idea which direction money flows. \/\/ so for now - hardcoded for backwards compatiblility\n\/\/ todo: remove hardcoded account names...crashes if names dont match","repo":"kkrolczyk\/Schowek","code_context_2":"private void updateSingleAccount(double amount, String account_name) {\n\/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n}\nelse {","code_context_10":"private void updateSingleAccount(double amount, String account_name) {\n\/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n}\nelse {\nstatus_disp.reduce_wealth(account_name, (float) amount);\nLog.e(TAG, account_name + \" \" + amount);\n}\n}\n\nprivate void updateSingleAccount(double amount, String account_name) {\n\/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n}\nelse {\nstatus_disp.reduce_wealth(account_name, (float) amount);\nLog.e(TAG, account_name + \" \" + amount);\n}\n}","code_context_20":"private void updateSingleAccount(double amount, String account_name) {\n\/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n}\nelse {\nstatus_disp.reduce_wealth(account_name, (float) amount);\nLog.e(TAG, account_name + \" \" + amount);\n}\n}\n\nprivate void updateSingleAccount(double amount, String account_name) {\n\/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n\/\/ so for now - hardcoded for backwards compatiblility\nif (account_name.equals(\"bankomat\")){\nstatus_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n}\nelse {\nstatus_disp.reduce_wealth(account_name, (float) amount);\nLog.e(TAG, account_name + \" \" + amount);\n}\n}","label":[1,0,1,0]}
{"id":19798,"original_code":"protected void onDragonDeath(EnderDragon dragon) {\n        log(\"The dragon died.\");\n        if (_stageNumber != 11) {\n            log(\"But we're not in stage 11, so it doesn't count.\");\n            return;\n        }\n        if (DragonFight.CONFIG.FIGHT_OWNER == null) {\n            log(\"But nobody owns the fight, so it doesn't count.\");\n            return;\n        }\n        \/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\n        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\n        getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\n                                                      ChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\n        Player player = offlinePlayer.getPlayer();\n        if (player == null) {\n            \/\/ Fight owner is offline. Record an unclaimed prize.\n            log(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\n            getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\n            DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n        } else {\n            \/\/ Select a single drop from the `df-dragon-drops` loot set.\n            \/\/ TODO: actually, multiple drops should be supported, once\n            \/\/ BeastMaster supports deferred item drops.\n            log(\"Generating dragon prizes for \" + player.getName());\n            List<ItemStack> prizes = generatePrizes();\n            if (!givePrizes(player, prizes)) {\n                \/\/ The item(s) did not fit, so player must claim with command.\n                DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n                String slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\n                               ChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\n                                   ChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\n                                   ChatColor.DARK_PURPLE + \" to claim your prize.\");\n            }\n        }\n        \/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n        \/\/ recorded, to prevent extra prizes if spurious dragons spawn.\n        DragonFight.CONFIG.FIGHT_OWNER = null;\n        DragonFight.CONFIG.save();\n    }","code":"protected void onDragonDeath(EnderDragon dragon) {\n        log(\"The dragon died.\");\n        if (_stageNumber != 11) {\n            log(\"But we're not in stage 11, so it doesn't count.\");\n            return;\n        }\n        if (DragonFight.CONFIG.FIGHT_OWNER == null) {\n            log(\"But nobody owns the fight, so it doesn't count.\");\n            return;\n        }\n       \n        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\n        getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\n                                                      ChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\n        Player player = offlinePlayer.getPlayer();\n        if (player == null) {\n           \n            log(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\n            getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\n            DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n        } else {\n           \n           \n           \n            log(\"Generating dragon prizes for \" + player.getName());\n            List<ItemStack> prizes = generatePrizes();\n            if (!givePrizes(player, prizes)) {\n               \n                DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n                String slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\n                               ChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\n                                   ChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\n                                   ChatColor.DARK_PURPLE + \" to claim your prize.\");\n            }\n        }\n       \n       \n        DragonFight.CONFIG.FIGHT_OWNER = null;\n        DragonFight.CONFIG.save();\n    }","cleancode":"protected void ondragondeath(enderdragon dragon) { log(\"the dragon died.\"); if (_stagenumber != 11) { log(\"but we're not in stage 11, so it doesn't count.\"); return; } if (dragonfight.config.fight_owner == null) { log(\"but nobody owns the fight, so it doesn't count.\"); return; } offlineplayer offlineplayer = bukkit.getofflineplayer(dragonfight.config.fight_owner); getnearbyplayers().foreach(p -> p.sendmessage(chatcolor.light_purple + offlineplayer.getname() + chatcolor.dark_purple + \" was awarded the prize for defeating the dragon.\")); player player = offlineplayer.getplayer(); if (player == null) { log(\"an unclaimed prize was added to offline fight owner \" + offlineplayer.getname() + \".\"); getnearbyplayers().foreach(p -> p.sendmessage(chatcolor.dark_purple + \"they can claim it when they log in.\")); dragonfight.config.incunclaimedprizes(offlineplayer.getuniqueid(), 1); } else { log(\"generating dragon prizes for \" + player.getname()); list<itemstack> prizes = generateprizes(); if (!giveprizes(player, prizes)) { dragonfight.config.incunclaimedprizes(offlineplayer.getuniqueid(), 1); string slots = chatcolor.light_purple + integer.tostring(prizes.size()) + chatcolor.dark_purple + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\"); player.sendmessage(chatcolor.dark_purple + \"you need at least \" + slots + \" empty.\"); player.sendmessage(chatcolor.dark_purple + \"run \" + chatcolor.light_purple + \"\/dragon prize\" + chatcolor.dark_purple + \" to claim your prize.\"); } } dragonfight.config.fight_owner = null; dragonfight.config.save(); }","comment":"\/\/ ------------------------------------------------------------------------ \/** * when the dragon dies: * * <ul> * <li>if the fight owner is online, put the dragon drops in that player's * inventory. if they are not online, * <\/ul> * * @param dragon the dragon that died. *\/\n\/\/ bukkit.getofflineplayer() never returns null, even for non-existent.\n\/\/ fight owner is offline. record an unclaimed prize.\n\/\/ select a single drop from the `df-dragon-drops` loot set. \/\/ todo: actually, multiple drops should be supported, once \/\/ beastmaster supports deferred item drops.\n\/\/ the item(s) did not fit, so player must claim with command.\n\/\/ clear the fight owner once prizes have been given or unclaimed prizes \/\/ recorded, to prevent extra prizes if spurious dragons spawn.","repo":"kadenscott\/DragonFight","code_context_2":"protected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}\n\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\n\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\n\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\n\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\n\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();","code_context_10":"protected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}\n\nprotected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\n\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}","code_context_20":"protected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}\n\nprotected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\n\nprotected void onDragonDeath(EnderDragon dragon) {\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\nlog(\"The dragon died.\");\nif (_stageNumber != 11) {\nlog(\"But we're not in stage 11, so it doesn't count.\");\nreturn;\n}\nif (DragonFight.CONFIG.FIGHT_OWNER == null) {\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}\n\nlog(\"But nobody owns the fight, so it doesn't count.\");\nreturn;\n}\n\/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\nOfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\nChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\nPlayer player = offlinePlayer.getPlayer();\nif (player == null) {\n\/\/ Fight owner is offline. Record an unclaimed prize.\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}\n\nlog(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\ngetNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n} else {\n\/\/ Select a single drop from the `df-dragon-drops` loot set.\n\/\/ TODO: actually, multiple drops should be supported, once\n\/\/ BeastMaster supports deferred item drops.\nlog(\"Generating dragon prizes for \" + player.getName());\nList<ItemStack> prizes = generatePrizes();\nif (!givePrizes(player, prizes)) {\n\/\/ The item(s) did not fit, so player must claim with command.\nDragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\nString slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\nChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\nplayer.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\nChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\nChatColor.DARK_PURPLE + \" to claim your prize.\");\n}\n}\n\/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n\/\/ recorded, to prevent extra prizes if spurious dragons spawn.\nDragonFight.CONFIG.FIGHT_OWNER = null;\nDragonFight.CONFIG.save();\n}","label":[1,0,0,0]}
{"id":11718,"original_code":"@Override\n    protected void processAuthenticationResponse(HttpServletRequest request,\n                                                 HttpServletResponse response, AuthenticationContext context)\n            throws AuthenticationFailedException {\n        try {\n            Map<String, String> authenticatorProperties = context.getAuthenticatorProperties();\n            String clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\n            String clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\n            String tokenEndPoint = getTokenEndpoint(authenticatorProperties);\n            if (tokenEndPoint == null) {\n                tokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n            }\n            String callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\n            log.debug(\"callBackUrl : \" + callBackUrl);\n            if (callBackUrl == null) {\n                callBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\n                callBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n            }\n            @SuppressWarnings({\"unchecked\"})\n            Map<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\n            if (paramValueMap != null\n                && paramValueMap.containsKey(\"redirect_uri\")) {\n                callBackUrl = paramValueMap.get(\"redirect_uri\");\n            }\n            OAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\n            String code = authzResponse.getCode();\n            OAuthClientRequest accessRequest;\n            try {\n                accessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n                        .setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n                        .setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n            } catch (OAuthSystemException e) {\n                throw new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n            }\n            \/\/ create OAuth client that uses custom http client under the hood\n            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\n            OAuthClientResponse oAuthResponse;\n            try {\n                oAuthResponse = oAuthClient.accessToken(accessRequest);\n            } catch (OAuthSystemException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Exception while requesting access token\", e);\n                }\n                throw new AuthenticationFailedException(\"Exception while requesting access token\", e);\n            }\n            \/\/ TODO : return access token and id token to framework\n            String accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\n            String idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\n            if (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\n                context.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\n                if (idToken != null) {\n                    context.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\n                    String base64Body = idToken.split(\"\\\\.\")[1];\n                    byte[] decoded = Base64.decodeBase64(base64Body.getBytes());\n                    String json = new String(decoded);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Id token json string : \" + json);\n                    }\n                    Map<String, Object> jsonObject = JSONUtils.parseJSON(json);\n                    if (jsonObject != null) {\n                        Map<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\n                        String authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\n                        AuthenticatedUser authenticatedUserObj = AuthenticatedUser\n                                .createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\n                        authenticatedUserObj.setUserAttributes(claims);\n                        context.setSubject(authenticatedUserObj);\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Decoded json object is null\");\n                        }\n                        throw new AuthenticationFailedException(\"Decoded json object is null\");\n                    }\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Authentication Failed\");\n                    }\n                    throw new AuthenticationFailedException(\"Authentication Failed\");\n                }\n            } else {\n                throw new AuthenticationFailedException(\"Authentication Failed\");\n            }\n        } catch (OAuthProblemException e) {\n            throw new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n        } catch (JSONException e) {\n            throw new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n        }\n    }","code":"@Override\n    protected void processAuthenticationResponse(HttpServletRequest request,\n                                                 HttpServletResponse response, AuthenticationContext context)\n            throws AuthenticationFailedException {\n        try {\n            Map<String, String> authenticatorProperties = context.getAuthenticatorProperties();\n            String clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\n            String clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\n            String tokenEndPoint = getTokenEndpoint(authenticatorProperties);\n            if (tokenEndPoint == null) {\n                tokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n            }\n            String callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\n            log.debug(\"callBackUrl : \" + callBackUrl);\n            if (callBackUrl == null) {\n                callBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\n                callBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n            }\n            @SuppressWarnings({\"unchecked\"})\n            Map<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\n            if (paramValueMap != null\n                && paramValueMap.containsKey(\"redirect_uri\")) {\n                callBackUrl = paramValueMap.get(\"redirect_uri\");\n            }\n            OAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\n            String code = authzResponse.getCode();\n            OAuthClientRequest accessRequest;\n            try {\n                accessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n                        .setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n                        .setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n            } catch (OAuthSystemException e) {\n                throw new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n            }\n           \n            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\n            OAuthClientResponse oAuthResponse;\n            try {\n                oAuthResponse = oAuthClient.accessToken(accessRequest);\n            } catch (OAuthSystemException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Exception while requesting access token\", e);\n                }\n                throw new AuthenticationFailedException(\"Exception while requesting access token\", e);\n            }\n           \n            String accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\n            String idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\n            if (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\n                context.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\n                if (idToken != null) {\n                    context.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\n                    String base64Body = idToken.split(\"\\\\.\")[1];\n                    byte[] decoded = Base64.decodeBase64(base64Body.getBytes());\n                    String json = new String(decoded);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Id token json string : \" + json);\n                    }\n                    Map<String, Object> jsonObject = JSONUtils.parseJSON(json);\n                    if (jsonObject != null) {\n                        Map<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\n                        String authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\n                        AuthenticatedUser authenticatedUserObj = AuthenticatedUser\n                                .createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\n                        authenticatedUserObj.setUserAttributes(claims);\n                        context.setSubject(authenticatedUserObj);\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Decoded json object is null\");\n                        }\n                        throw new AuthenticationFailedException(\"Decoded json object is null\");\n                    }\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Authentication Failed\");\n                    }\n                    throw new AuthenticationFailedException(\"Authentication Failed\");\n                }\n            } else {\n                throw new AuthenticationFailedException(\"Authentication Failed\");\n            }\n        } catch (OAuthProblemException e) {\n            throw new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n        } catch (JSONException e) {\n            throw new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n        }\n    }","cleancode":"@override protected void processauthenticationresponse(httpservletrequest request, httpservletresponse response, authenticationcontext context) throws authenticationfailedexception { try { map<string, string> authenticatorproperties = context.getauthenticatorproperties(); string clientid = authenticatorproperties.get(oidcauthenticatorconstants.client_id); string clientsecret = authenticatorproperties.get(oidcauthenticatorconstants.client_secret); string tokenendpoint = gettokenendpoint(authenticatorproperties); if (tokenendpoint == null) { tokenendpoint = authenticatorproperties.get(oidcauthenticatorconstants.oauth2_token_url); } string callbackurl = authenticatorproperties.get(googleoauth2authenticationconstant.callback_url); log.debug(\"callbackurl : \" + callbackurl); if (callbackurl == null) { callbackurl = carbonuiutil.getadminconsoleurl(request); callbackurl = callbackurl.replace(\"commonauth\/carbon\/\", \"commonauth\"); } @suppresswarnings({\"unchecked\"}) map<string, string> paramvaluemap = (map<string, string>) context.getproperty(\"oidc:param.map\"); if (paramvaluemap != null && paramvaluemap.containskey(\"redirect_uri\")) { callbackurl = paramvaluemap.get(\"redirect_uri\"); } oauthauthzresponse authzresponse = oauthauthzresponse.oauthcodeauthzresponse(request); string code = authzresponse.getcode(); oauthclientrequest accessrequest; try { accessrequest = oauthclientrequest.tokenlocation(tokenendpoint) .setgranttype(granttype.authorization_code).setclientid(clientid).setclientsecret(clientsecret) .setredirecturi(callbackurl).setcode(code).buildbodymessage(); } catch (oauthsystemexception e) { throw new authenticationfailedexception(\"exception while building request for request access token\", e); } oauthclient oauthclient = new oauthclient(new urlconnectionclient()); oauthclientresponse oauthresponse; try { oauthresponse = oauthclient.accesstoken(accessrequest); } catch (oauthsystemexception e) { if (log.isdebugenabled()) { log.debug(\"exception while requesting access token\", e); } throw new authenticationfailedexception(\"exception while requesting access token\", e); } string accesstoken = oauthresponse.getparam(oidcauthenticatorconstants.access_token); string idtoken = oauthresponse.getparam(oidcauthenticatorconstants.id_token); if (accesstoken != null && (idtoken != null || !requiredidtoken(authenticatorproperties))) { context.setproperty(oidcauthenticatorconstants.access_token, accesstoken); if (idtoken != null) { context.setproperty(oidcauthenticatorconstants.id_token, idtoken); string base64body = idtoken.split(\"\\\\.\")[1]; byte[] decoded = base64.decodebase64(base64body.getbytes()); string json = new string(decoded); if (log.isdebugenabled()) { log.debug(\"id token json string : \" + json); } map<string, object> jsonobject = jsonutils.parsejson(json); if (jsonobject != null) { map<claimmapping, string> claims = getsubjectattributes(oauthresponse); string authenticateduser = (string) jsonobject.get(oidcauthenticatorconstants.claim.email); authenticateduser authenticateduserobj = authenticateduser .createfederateauthenticateduserfromsubjectidentifier(authenticateduser); authenticateduserobj.setuserattributes(claims); context.setsubject(authenticateduserobj); } else { if (log.isdebugenabled()) { log.debug(\"decoded json object is null\"); } throw new authenticationfailedexception(\"decoded json object is null\"); } } else { if (log.isdebugenabled()) { log.debug(\"authentication failed\"); } throw new authenticationfailedexception(\"authentication failed\"); } } else { throw new authenticationfailedexception(\"authentication failed\"); } } catch (oauthproblemexception e) { throw new authenticationfailedexception(\"error occurred while acquiring access token\", e); } catch (jsonexception e) { throw new authenticationfailedexception(\"error occurred while parsing json object\", e); } }","comment":"\/** * this method are overridden for extra claim request to google end-point * * @param request * @param response * @param context * @throws authenticationfailedexception *\/\n\/\/ create oauth client that uses custom http client under the hood\n\/\/ todo : return access token and id token to framework","repo":"manjulaRathnayaka\/carbon-identity","code_context_2":"@Override\nprotected void processAuthenticationResponse(HttpServletRequest request,\nHttpServletResponse response, AuthenticationContext context)\nthrows AuthenticationFailedException {\ntry {\nMap<String, String> authenticatorProperties = context.getAuthenticatorProperties();\nString clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\nString clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\nString tokenEndPoint = getTokenEndpoint(authenticatorProperties);\nif (tokenEndPoint == null) {\ntokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n}\nString callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\nlog.debug(\"callBackUrl : \" + callBackUrl);\nif (callBackUrl == null) {\ncallBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\ncallBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n}\n@SuppressWarnings({\"unchecked\"})\nMap<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\nif (paramValueMap != null\n&& paramValueMap.containsKey(\"redirect_uri\")) {\ncallBackUrl = paramValueMap.get(\"redirect_uri\");\n}\nOAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\nif (log.isDebugEnabled()) {\nlog.debug(\"Id token json string : \" + json);\n}\nMap<String, Object> jsonObject = JSONUtils.parseJSON(json);\nif (jsonObject != null) {\nMap<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\nString authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\nAuthenticatedUser authenticatedUserObj = AuthenticatedUser\n.createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\nauthenticatedUserObj.setUserAttributes(claims);\ncontext.setSubject(authenticatedUserObj);\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Decoded json object is null\");\n}\nthrow new AuthenticationFailedException(\"Decoded json object is null\");\n}\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Authentication Failed\");\n}\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} else {\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} catch (OAuthProblemException e) {\nthrow new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n} catch (JSONException e) {\nthrow new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n}\n}\n\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\n\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);","code_context_10":"@Override\nprotected void processAuthenticationResponse(HttpServletRequest request,\nHttpServletResponse response, AuthenticationContext context)\nthrows AuthenticationFailedException {\ntry {\nMap<String, String> authenticatorProperties = context.getAuthenticatorProperties();\nString clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\nString clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\nString tokenEndPoint = getTokenEndpoint(authenticatorProperties);\nif (tokenEndPoint == null) {\ntokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n}\nString callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\nlog.debug(\"callBackUrl : \" + callBackUrl);\nif (callBackUrl == null) {\ncallBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\ncallBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n}\n@SuppressWarnings({\"unchecked\"})\nMap<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\nif (paramValueMap != null\n&& paramValueMap.containsKey(\"redirect_uri\")) {\ncallBackUrl = paramValueMap.get(\"redirect_uri\");\n}\nOAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\nif (log.isDebugEnabled()) {\nlog.debug(\"Id token json string : \" + json);\n}\nMap<String, Object> jsonObject = JSONUtils.parseJSON(json);\nif (jsonObject != null) {\nMap<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\nString authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\nAuthenticatedUser authenticatedUserObj = AuthenticatedUser\n.createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\nauthenticatedUserObj.setUserAttributes(claims);\ncontext.setSubject(authenticatedUserObj);\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Decoded json object is null\");\n}\nthrow new AuthenticationFailedException(\"Decoded json object is null\");\n}\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Authentication Failed\");\n}\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} else {\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} catch (OAuthProblemException e) {\nthrow new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n} catch (JSONException e) {\nthrow new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n}\n}\n\nOAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\nif (log.isDebugEnabled()) {","code_context_20":"@Override\nprotected void processAuthenticationResponse(HttpServletRequest request,\nHttpServletResponse response, AuthenticationContext context)\nthrows AuthenticationFailedException {\ntry {\nMap<String, String> authenticatorProperties = context.getAuthenticatorProperties();\nString clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\nString clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\nString tokenEndPoint = getTokenEndpoint(authenticatorProperties);\nif (tokenEndPoint == null) {\ntokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n}\nString callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\nlog.debug(\"callBackUrl : \" + callBackUrl);\nif (callBackUrl == null) {\ncallBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\ncallBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n}\n@SuppressWarnings({\"unchecked\"})\nMap<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\nif (paramValueMap != null\n&& paramValueMap.containsKey(\"redirect_uri\")) {\ncallBackUrl = paramValueMap.get(\"redirect_uri\");\n}\nOAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\nif (log.isDebugEnabled()) {\nlog.debug(\"Id token json string : \" + json);\n}\nMap<String, Object> jsonObject = JSONUtils.parseJSON(json);\nif (jsonObject != null) {\nMap<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\nString authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\nAuthenticatedUser authenticatedUserObj = AuthenticatedUser\n.createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\nauthenticatedUserObj.setUserAttributes(claims);\ncontext.setSubject(authenticatedUserObj);\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Decoded json object is null\");\n}\nthrow new AuthenticationFailedException(\"Decoded json object is null\");\n}\n} else {\nif (log.isDebugEnabled()) {\nlog.debug(\"Authentication Failed\");\n}\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} else {\nthrow new AuthenticationFailedException(\"Authentication Failed\");\n}\n} catch (OAuthProblemException e) {\nthrow new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n} catch (JSONException e) {\nthrow new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n}\n}\n\nif (callBackUrl == null) {\ncallBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\ncallBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n}\n@SuppressWarnings({\"unchecked\"})\nMap<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\nif (paramValueMap != null\n&& paramValueMap.containsKey(\"redirect_uri\")) {\ncallBackUrl = paramValueMap.get(\"redirect_uri\");\n}\nOAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\n\nString code = authzResponse.getCode();\nOAuthClientRequest accessRequest;\ntry {\naccessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n.setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n.setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n} catch (OAuthSystemException e) {\nthrow new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n}\n\/\/ create OAuth client that uses custom http client under the hood\nOAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\nOAuthClientResponse oAuthResponse;\ntry {\noAuthResponse = oAuthClient.accessToken(accessRequest);\n} catch (OAuthSystemException e) {\nif (log.isDebugEnabled()) {\nlog.debug(\"Exception while requesting access token\", e);\n}\nthrow new AuthenticationFailedException(\"Exception while requesting access token\", e);\n}\n\/\/ TODO : return access token and id token to framework\nString accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\nString idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\nif (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\ncontext.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\nif (idToken != null) {\ncontext.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\nString base64Body = idToken.split(\"\\\\.\")[1];\nbyte[] decoded = Base64.decodeBase64(base64Body.getBytes());\nString json = new String(decoded);\nif (log.isDebugEnabled()) {\nlog.debug(\"Id token json string : \" + json);\n}\nMap<String, Object> jsonObject = JSONUtils.parseJSON(json);\nif (jsonObject != null) {\nMap<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\nString authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\nAuthenticatedUser authenticatedUserObj = AuthenticatedUser\n.createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\nauthenticatedUserObj.setUserAttributes(claims);\ncontext.setSubject(authenticatedUserObj);","label":[0,1,0,0]}
{"id":11781,"original_code":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\n            throws MetadataValidationException, MetadataException {\n        System.out.println(\"Related QueryContents\");\n        this.displayStructureHeader(index, xv);\n        Metadata m = getMetadata();\n        boolean object_refs = m.isObjectRefsOnly();\n        if (m.getWrapper() == null) {\n            return;\n        }\n        xv.getMetadata().addMetadata(m);\n        if (object_refs) {\n            \/\/ no idea what to do here\n        } else {\n            String ref_id = this.getReferenceId();\n            h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n                    + ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n                    + ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n                    + \")\");\n            \/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\n            for (OMElement a_ele : m.getAssociations()) {\n                String src_id = m.getAssocSource(a_ele);\n                String a_type = m.getAssocType(a_ele);\n                String a_id = m.getId(a_ele);\n                String tgt_id = m.getAssocTarget(a_ele);\n                if (src_id == null) {\n                } else if (src_id != null && !src_id.equals(this.getReferenceId())) {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaced by\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"has appended\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transformed to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\n                        a_type = \"is snapshot of\";\n                    } else {\n                        a_type = a_type + \" by\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(src_id, cntl)\n                            + \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n                            + \"]\");\n                } else {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaces\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"appended to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transform of\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(tgt_id, cntl)\n                            + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n                            + \"]\");\n                }\n            }\n        }\n    }","code":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\n            throws MetadataValidationException, MetadataException {\n        System.out.println(\"Related QueryContents\");\n        this.displayStructureHeader(index, xv);\n        Metadata m = getMetadata();\n        boolean object_refs = m.isObjectRefsOnly();\n        if (m.getWrapper() == null) {\n            return;\n        }\n        xv.getMetadata().addMetadata(m);\n        if (object_refs) {\n           \n        } else {\n            String ref_id = this.getReferenceId();\n            h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n                    + ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n                    + ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n                    + \")\");\n           \n            for (OMElement a_ele : m.getAssociations()) {\n                String src_id = m.getAssocSource(a_ele);\n                String a_type = m.getAssocType(a_ele);\n                String a_id = m.getId(a_ele);\n                String tgt_id = m.getAssocTarget(a_ele);\n                if (src_id == null) {\n                } else if (src_id != null && !src_id.equals(this.getReferenceId())) {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaced by\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"has appended\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transformed to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\n                        a_type = \"is snapshot of\";\n                    } else {\n                        a_type = a_type + \" by\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(src_id, cntl)\n                            + \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n                            + \"]\");\n                } else {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaces\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"appended to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transform of\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(tgt_id, cntl)\n                            + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n                            + \"]\");\n                }\n            }\n        }\n    }","cleancode":"public void displaystructure(querycontrol q_cntl, int index, httputils h, xview xv, string cntl) throws metadatavalidationexception, metadataexception { system.out.println(\"related querycontents\"); this.displaystructureheader(index, xv); metadata m = getmetadata(); boolean object_refs = m.isobjectrefsonly(); if (m.getwrapper() == null) { return; } xv.getmetadata().addmetadata(m); if (object_refs) { } else { string ref_id = this.getreferenceid(); h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \" + ((m.isretrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\") + ((m.isretrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\") + \")\"); for (omelement a_ele : m.getassociations()) { string src_id = m.getassocsource(a_ele); string a_type = m.getassoctype(a_ele); string a_id = m.getid(a_ele); string tgt_id = m.getassoctarget(a_ele); if (src_id == null) { } else if (src_id != null && !src_id.equals(this.getreferenceid())) { if (metadatasupport.xdsb_ihe_assoc_type_rplc.equals(a_type)) { a_type = \"replaced by\"; } else if (metadatasupport.xdsb_ihe_assoc_type_apnd.equals(a_type)) { a_type = \"has appended\"; } else if (metadatasupport.xdsb_ihe_assoc_type_xfrm.equals(a_type)) { a_type = \"transformed to\"; } else if (metadatasupport.xdsb_ihe_assoc_type_issnapshotof.equals(a_type)) { a_type = \"is snapshot of\"; } else { a_type = a_type + \" by\"; } h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \" + xv.build_details_link(src_id, cntl) + \" (\" + xv.build_xml_link(src_id, cntl) + \" \" + ((m.isretrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\") + ((m.isretrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\") + \") \" + \" [\" + ((q_cntl.hasendpoint()) ? xv.build_related_link(src_id) : \"\") + \"]\"); } else { if (metadatasupport.xdsb_ihe_assoc_type_rplc.equals(a_type)) { a_type = \"replaces\"; } else if (metadatasupport.xdsb_ihe_assoc_type_apnd.equals(a_type)) { a_type = \"appended to\"; } else if (metadatasupport.xdsb_ihe_assoc_type_xfrm.equals(a_type)) { a_type = \"transform of\"; } h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \" + xv.build_details_link(tgt_id, cntl) + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \" + ((m.isretrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\") + ((m.isretrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\") + \") \" + \" [\" + ((q_cntl.hasendpoint()) ? xv.build_related_link(tgt_id) : \"\") + \"]\"); } } } }","comment":"\/** * * @param q_cntl * @param index * @param h * @param xv * @param cntl * @throws metadatavalidationexception * @throws metadataexception *\/\n\/\/ no idea what to do here\n\/\/ ams 04\/24\/2009 - fixme - refactor this - 'else-if' and 'else' are pretty similar","repo":"kef\/hieos","code_context_2":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"has appended\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transformed to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\na_type = \"is snapshot of\";\n} else {\na_type = a_type + \" by\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(src_id, cntl)\n+ \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n+ \"]\");\n} else {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaces\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"appended to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transform of\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(tgt_id, cntl)\n+ \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n+ \"]\");\n}\n}\n}\n}\n\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\n\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);","code_context_10":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"has appended\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transformed to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\na_type = \"is snapshot of\";\n} else {\na_type = a_type + \" by\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(src_id, cntl)\n+ \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n+ \"]\");\n} else {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaces\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"appended to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transform of\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(tgt_id, cntl)\n+ \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n+ \"]\");\n}\n}\n}\n}\n\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\n\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {","code_context_20":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"has appended\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transformed to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\na_type = \"is snapshot of\";\n} else {\na_type = a_type + \" by\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(src_id, cntl)\n+ \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n+ \"]\");\n} else {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaces\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"appended to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transform of\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(tgt_id, cntl)\n+ \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n+ ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n+ \") \"\n+ \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n+ \"]\");\n}\n}\n}\n}\n\npublic void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"has appended\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transformed to\";\n\npublic void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\nthrows MetadataValidationException, MetadataException {\nSystem.out.println(\"Related QueryContents\");\nthis.displayStructureHeader(index, xv);\nMetadata m = getMetadata();\nboolean object_refs = m.isObjectRefsOnly();\nif (m.getWrapper() == null) {\nreturn;\n}\nxv.getMetadata().addMetadata(m);\nif (object_refs) {\n\/\/ no idea what to do here\n} else {\nString ref_id = this.getReferenceId();\nh.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n+ ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n+ ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n+ \")\");\n\/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\nfor (OMElement a_ele : m.getAssociations()) {\nString src_id = m.getAssocSource(a_ele);\nString a_type = m.getAssocType(a_ele);\nString a_id = m.getId(a_ele);\nString tgt_id = m.getAssocTarget(a_ele);\nif (src_id == null) {\n} else if (src_id != null && !src_id.equals(this.getReferenceId())) {\nif (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\na_type = \"replaced by\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\na_type = \"has appended\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\na_type = \"transformed to\";\n} else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\na_type = \"is snapshot of\";\n} else {\na_type = a_type + \" by\";\n}\nh.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n+ xv.build_details_link(src_id, cntl)","label":[1,1,0,0]}
{"id":3600,"original_code":"public RemoteEventData[] readAhead(int maxEvents) \n        throws IOException, ClassNotFoundException \n    {\n        boolean IOExceptionCaught = false;\n        stateCheck();\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        \/\/ Check if empty\n\tif (isEmpty()) \n\t    throw new NoSuchElementException();    \n        long readCount = rcount;\n        long readPosition = rpos;\n        long logNum = getLogNum(readCount); \n        File log = getLogFile(logNum);\n        RemoteEvent evt = null;\n        ArrayList rData = new ArrayList();\n        int i = 0;\n        LogInputStream in = null;\n        boolean done = false;\n        printControlData(persistenceLogger, \"Before read::readAhead\");\n        if (persistenceLogger.isLoggable(Level.FINEST)) {\n            persistenceLogger.log(Level.FINEST, \n                \"EventLog::readAhead() maxEvents = {0}\", \n                new Object[] {Integer.valueOf(maxEvents)});\n        } \n        while ((readCount < wcount) && \n               (rData.size() < maxEvents) &&\n               !done) \n        {\n            if (logNum != getLogNum(readCount)) {\n                logNum = getLogNum(readCount);\n                log = getLogFile(logNum);\n                readPosition = 0;\n            }\n            try {\n                \/\/ get the input stream\n                in = streamPool.getLogInputStream(log, readPosition);\n                \/\/ read the event\n                evt = eventReader.read(in); \n                \/\/ update readCount and readPosition\n                readCount++;\n                readPosition = in.getOffset(); \/\/ offset to next unread event\n                \/\/Generate new entry\n                rData.add(new RemoteEventData(\n                   evt, \n                   new RemoteEventDataCursor(readCount, readPosition)));\n            } catch (IOException ie) {\n                \/\/ We'll get interrupted when asked to shutdown.\n                \/\/ In this case, we can skip the call to nextReadAheadLog.\n                if (ie instanceof InterruptedIOException) {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() interrupted \");\n                    } \n                    \/\/ Stop processing events\n                    done = true;\n                } else {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() received IOException \" \n                            + \"... skipping to next read log\"); \n                    }\n                    readCount = nextReadAheadLog(readCount);\n                    \/\/ TODO - rcount = readCount;\n                    \/\/ TODO - if bump rcount you need to bump wcount too\n                    \/\/ TODO - if bump counts then you need to persist them\n                    readPosition = 0;\n                    IOExceptionCaught = true; \n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() new readCount is {0}\", \n                            Long.valueOf(readCount)); \n                    }                    \n                }\n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", ie);\n                }\n            } catch (ClassNotFoundException cnfe) {\n                \/\/ Note that the read offset is still valid since the\n                \/\/ MarshalledObject extraction should always succeed.\n                \/\/ It's just that the RemoteEvent within it could not\n                \/\/ be reconstituted. Therefore, just skip to the next\n                \/\/ MarshalledObject in the stream.\n                readCount++;\n                readPosition = in.getOffset();\n                \/\/Generate new entry\n                rData.add(new RemoteEventData(\n                   null, \n                   new RemoteEventDataCursor(readCount, readPosition)));                \n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", cnfe);\n                }            \n            } finally {\n                \/\/ If an IOException occurs then the eventReader is in \n                \/\/ a bad state. Therefore, we get rid of our existing\n                \/\/ reference and create a fresh one. The underlying\n                \/\/ stream is also removed from from the pool, forcing\n                \/\/ a fresh copy to be returned on the next \"get\" request.\n                if (IOExceptionCaught) {\n                    \/\/TODO (FCS) add close to interface\n                    \/\/eventReader.close();\n                    eventReader = new EventReader();\n                    if (in != null) {\n                        streamPool.removeLogStream(in);\n                        in = null;\n                    }\n                } else { \n                    if (in != null)\n                        streamPool.releaseLogStream(in);\n                    \/* Shouldn't have to release since we have exclusive\n                     * access, but the next getLogInputStream assumes things\n                     * are on the freelist.\n                     *\/\n                }\n            }\n        }\n        printControlData(persistenceLogger, \"After Event::readAhead\");\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        return (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n    }","code":"public RemoteEventData[] readAhead(int maxEvents) \n        throws IOException, ClassNotFoundException \n    {\n        boolean IOExceptionCaught = false;\n        stateCheck();\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n       \n\tif (isEmpty()) \n\t    throw new NoSuchElementException();    \n        long readCount = rcount;\n        long readPosition = rpos;\n        long logNum = getLogNum(readCount); \n        File log = getLogFile(logNum);\n        RemoteEvent evt = null;\n        ArrayList rData = new ArrayList();\n        int i = 0;\n        LogInputStream in = null;\n        boolean done = false;\n        printControlData(persistenceLogger, \"Before read::readAhead\");\n        if (persistenceLogger.isLoggable(Level.FINEST)) {\n            persistenceLogger.log(Level.FINEST, \n                \"EventLog::readAhead() maxEvents = {0}\", \n                new Object[] {Integer.valueOf(maxEvents)});\n        } \n        while ((readCount < wcount) && \n               (rData.size() < maxEvents) &&\n               !done) \n        {\n            if (logNum != getLogNum(readCount)) {\n                logNum = getLogNum(readCount);\n                log = getLogFile(logNum);\n                readPosition = 0;\n            }\n            try {\n               \n                in = streamPool.getLogInputStream(log, readPosition);\n               \n                evt = eventReader.read(in); \n               \n                readCount++;\n                readPosition = in.getOffset();\n               \n                rData.add(new RemoteEventData(\n                   evt, \n                   new RemoteEventDataCursor(readCount, readPosition)));\n            } catch (IOException ie) {\n               \n               \n                if (ie instanceof InterruptedIOException) {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() interrupted \");\n                    } \n                   \n                    done = true;\n                } else {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() received IOException \" \n                            + \"... skipping to next read log\"); \n                    }\n                    readCount = nextReadAheadLog(readCount);\n                   \n                   \n                   \n                    readPosition = 0;\n                    IOExceptionCaught = true; \n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() new readCount is {0}\", \n                            Long.valueOf(readCount)); \n                    }                    \n                }\n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", ie);\n                }\n            } catch (ClassNotFoundException cnfe) {\n               \n               \n               \n               \n               \n                readCount++;\n                readPosition = in.getOffset();\n               \n                rData.add(new RemoteEventData(\n                   null, \n                   new RemoteEventDataCursor(readCount, readPosition)));                \n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", cnfe);\n                }            \n            } finally {\n               \n               \n               \n               \n               \n                if (IOExceptionCaught) {\n                   \n                   \n                    eventReader = new EventReader();\n                    if (in != null) {\n                        streamPool.removeLogStream(in);\n                        in = null;\n                    }\n                } else { \n                    if (in != null)\n                        streamPool.releaseLogStream(in);\n                   \n                }\n            }\n        }\n        printControlData(persistenceLogger, \"After Event::readAhead\");\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        return (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n    }","cleancode":"public remoteeventdata[] readahead(int maxevents) throws ioexception, classnotfoundexception { boolean ioexceptioncaught = false; statecheck(); if (debugstate) { assertinvariants(); } if (isempty()) throw new nosuchelementexception(); long readcount = rcount; long readposition = rpos; long lognum = getlognum(readcount); file log = getlogfile(lognum); remoteevent evt = null; arraylist rdata = new arraylist(); int i = 0; loginputstream in = null; boolean done = false; printcontroldata(persistencelogger, \"before read::readahead\"); if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() maxevents = {0}\", new object[] {integer.valueof(maxevents)}); } while ((readcount < wcount) && (rdata.size() < maxevents) && !done) { if (lognum != getlognum(readcount)) { lognum = getlognum(readcount); log = getlogfile(lognum); readposition = 0; } try { in = streampool.getloginputstream(log, readposition); evt = eventreader.read(in); readcount++; readposition = in.getoffset(); rdata.add(new remoteeventdata( evt, new remoteeventdatacursor(readcount, readposition))); } catch (ioexception ie) { if (ie instanceof interruptedioexception) { if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() interrupted \"); } done = true; } else { if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() received ioexception \" + \"... skipping to next read log\"); } readcount = nextreadaheadlog(readcount); readposition = 0; ioexceptioncaught = true; if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() new readcount is {0}\", long.valueof(readcount)); } } if (persistencelogger.isloggable(levels.handled)) { persistencelogger.log(levels.handled, \"exception: \", ie); } } catch (classnotfoundexception cnfe) { readcount++; readposition = in.getoffset(); rdata.add(new remoteeventdata( null, new remoteeventdatacursor(readcount, readposition))); if (persistencelogger.isloggable(levels.handled)) { persistencelogger.log(levels.handled, \"exception: \", cnfe); } } finally { if (ioexceptioncaught) { eventreader = new eventreader(); if (in != null) { streampool.removelogstream(in); in = null; } } else { if (in != null) streampool.releaselogstream(in); } } } printcontroldata(persistencelogger, \"after event::readahead\"); if (debugstate) { assertinvariants(); } return (remoteeventdata[]) rdata.toarray(new remoteeventdata[0]); }","comment":"\/\/ inherit documentation from supertype\n\/\/ check if empty\n\/\/ get the input stream\n\/\/ read the event\n\/\/ update readcount and readposition\n\/\/ offset to next unread event\n\/\/generate new entry\n\/\/ we'll get interrupted when asked to shutdown. \/\/ in this case, we can skip the call to nextreadaheadlog.\n\/\/ stop processing events\n\/\/ todo - rcount = readcount; \/\/ todo - if bump rcount you need to bump wcount too \/\/ todo - if bump counts then you need to persist them\n\/\/ note that the read offset is still valid since the \/\/ marshalledobject extraction should always succeed. \/\/ it's just that the remoteevent within it could not \/\/ be reconstituted. therefore, just skip to the next \/\/ marshalledobject in the stream.\n\/\/generate new entry\n\/\/ if an ioexception occurs then the eventreader is in \/\/ a bad state. therefore, we get rid of our existing \/\/ reference and create a fresh one. the underlying \/\/ stream is also removed from from the pool, forcing \/\/ a fresh copy to be returned on the next \"get\" request.\n\/\/todo (fcs) add close to interface \/\/eventreader.close();\n\/* shouldn't have to release since we have exclusive * access, but the next getloginputstream assumes things * are on the freelist. *\/","repo":"mkleczek\/river","code_context_2":"public RemoteEventData[] readAhead(int maxEvents)\nthrows IOException, ClassNotFoundException\n{\nboolean IOExceptionCaught = false;\nstateCheck();\nif (debugState) {\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\nlong readCount = rcount;\nlong readPosition = rpos;\nlong logNum = getLogNum(readCount);\nFile log = getLogFile(logNum);\nRemoteEvent evt = null;\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n}\n\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\n\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\n\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\n\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\n\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\n\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\n\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\n\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\n\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\n\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\n\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}","code_context_10":"public RemoteEventData[] readAhead(int maxEvents)\nthrows IOException, ClassNotFoundException\n{\nboolean IOExceptionCaught = false;\nstateCheck();\nif (debugState) {\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\nlong readCount = rcount;\nlong readPosition = rpos;\nlong logNum = getLogNum(readCount);\nFile log = getLogFile(logNum);\nRemoteEvent evt = null;\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n}\n\npublic RemoteEventData[] readAhead(int maxEvents)\nthrows IOException, ClassNotFoundException\n{\nboolean IOExceptionCaught = false;\nstateCheck();\nif (debugState) {\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\nlong readCount = rcount;\nlong readPosition = rpos;\nlong logNum = getLogNum(readCount);\nFile log = getLogFile(logNum);\nRemoteEvent evt = null;\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\n\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\n\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\n\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n}","code_context_20":"public RemoteEventData[] readAhead(int maxEvents)\nthrows IOException, ClassNotFoundException\n{\nboolean IOExceptionCaught = false;\nstateCheck();\nif (debugState) {\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\nlong readCount = rcount;\nlong readPosition = rpos;\nlong logNum = getLogNum(readCount);\nFile log = getLogFile(logNum);\nRemoteEvent evt = null;\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n}\n\npublic RemoteEventData[] readAhead(int maxEvents)\nthrows IOException, ClassNotFoundException\n{\nboolean IOExceptionCaught = false;\nstateCheck();\nif (debugState) {\nassertInvariants();\n}\n\/\/ Check if empty\nif (isEmpty())\nthrow new NoSuchElementException();\nlong readCount = rcount;\nlong readPosition = rpos;\nlong logNum = getLogNum(readCount);\nFile log = getLogFile(logNum);\nRemoteEvent evt = null;\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n\nArrayList rData = new ArrayList();\nint i = 0;\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n\nLogInputStream in = null;\nboolean done = false;\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\n\nprintControlData(persistenceLogger, \"Before read::readAhead\");\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\n\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\n\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\n\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\/\/ TODO - rcount = readCount;\n\/\/ TODO - if bump rcount you need to bump wcount too\n\/\/ TODO - if bump counts then you need to persist them\nreadPosition = 0;\nIOExceptionCaught = true;\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() new readCount is {0}\",\nLong.valueOf(readCount));\n}\n}\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\n\n\"EventLog::readAhead() maxEvents = {0}\",\nnew Object[] {Integer.valueOf(maxEvents)});\n}\nwhile ((readCount < wcount) &&\n(rData.size() < maxEvents) &&\n!done)\n{\nif (logNum != getLogNum(readCount)) {\nlogNum = getLogNum(readCount);\nlog = getLogFile(logNum);\nreadPosition = 0;\n}\ntry {\n\/\/ get the input stream\nin = streamPool.getLogInputStream(log, readPosition);\n\/\/ read the event\nevt = eventReader.read(in);\n\/\/ update readCount and readPosition\nreadCount++;\nreadPosition = in.getOffset(); \/\/ offset to next unread event\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nevt,\nnew RemoteEventDataCursor(readCount, readPosition)));\n} catch (IOException ie) {\n\/\/ We'll get interrupted when asked to shutdown.\n\/\/ In this case, we can skip the call to nextReadAheadLog.\nif (ie instanceof InterruptedIOException) {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() interrupted \");\n}\n\/\/ Stop processing events\ndone = true;\n} else {\nif (persistenceLogger.isLoggable(Level.FINEST)) {\npersistenceLogger.log(Level.FINEST,\n\"EventLog::readAhead() received IOException \"\n+ \"... skipping to next read log\");\n}\nreadCount = nextReadAheadLog(readCount);\n\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", ie);\n}\n} catch (ClassNotFoundException cnfe) {\n\/\/ Note that the read offset is still valid since the\n\/\/ MarshalledObject extraction should always succeed.\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\n\n\/\/ It's just that the RemoteEvent within it could not\n\/\/ be reconstituted. Therefore, just skip to the next\n\/\/ MarshalledObject in the stream.\nreadCount++;\nreadPosition = in.getOffset();\n\/\/Generate new entry\nrData.add(new RemoteEventData(\nnull,\nnew RemoteEventDataCursor(readCount, readPosition)));\nif (persistenceLogger.isLoggable(Levels.HANDLED)) {\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n\npersistenceLogger.log(Levels.HANDLED,\n\"Exception: \", cnfe);\n}\n} finally {\n\/\/ If an IOException occurs then the eventReader is in\n\/\/ a bad state. Therefore, we get rid of our existing\n\/\/ reference and create a fresh one. The underlying\n\/\/ stream is also removed from from the pool, forcing\n\/\/ a fresh copy to be returned on the next \"get\" request.\nif (IOExceptionCaught) {\n\/\/TODO (FCS) add close to interface\n\/\/eventReader.close();\neventReader = new EventReader();\nif (in != null) {\nstreamPool.removeLogStream(in);\nin = null;\n}\n} else {\nif (in != null)\nstreamPool.releaseLogStream(in);\n\/* Shouldn't have to release since we have exclusive\n* access, but the next getLogInputStream assumes things\n* are on the freelist.\n*\/\n}\n}\n}\nprintControlData(persistenceLogger, \"After Event::readAhead\");\nif (debugState) {\nassertInvariants();\n}\nreturn (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n}","label":[0,1,0,0]}
{"id":11842,"original_code":"public LoginContext authenticate(String user, char[] password, String realm) {\n\t\t\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\t\t\/\/ JndiLoginModule\n\t\t\/\/ ...sun...\n\t\tPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\n\t\tLoginContext lc;\n\t\ttry {\n\t\t\tlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n\t\t} catch (LoginException e) {\n\t\t\tLOG.error(\"Exception during new LoginContext()\", e);\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\t\/\/ call callback to retrieve credentials, and checks that\n\t\t\t\/\/ Authentication fails\n\t\t\tlc.login();\n\t\t} catch (LoginException e) {\n\t\t\t\/\/ FIXME. LoginException may happen either because authentication\n\t\t\t\/\/ failed, or for many other reasons.\n\t\t\t\/\/ We should ignore the first, and LOG the latter.\n\t\t\tLOG.error(\"Exception while loggin-in\", e);\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tArrays.fill(password, '\\u0000');\n\t\t}\n\t\treturn lc;\n\t}","code":"public LoginContext authenticate(String user, char[] password, String realm) {\n\t\n\t\n\t\n\t\tPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\n\t\tLoginContext lc;\n\t\ttry {\n\t\t\tlc = new LoginContext(realm, cbh);\n\t\t} catch (LoginException e) {\n\t\t\tLOG.error(\"Exception during new LoginContext()\", e);\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\n\t\t\n\t\t\tlc.login();\n\t\t} catch (LoginException e) {\n\t\t\n\t\t\n\t\t\n\t\t\tLOG.error(\"Exception while loggin-in\", e);\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tArrays.fill(password, '\\u0000');\n\t\t}\n\t\treturn lc;\n\t}","cleancode":"public logincontext authenticate(string user, char[] password, string realm) { passivecallbackhandler cbh = new passivecallbackhandler(user, password); logincontext lc; try { lc = new logincontext(realm, cbh); } catch (loginexception e) { log.error(\"exception during new logincontext()\", e); return null; } try { lc.login(); } catch (loginexception e) { log.error(\"exception while loggin-in\", e); return null; } finally { arrays.fill(password, '\\u0000'); } return lc; }","comment":"\/** * authenticate given username and password through jaas (instead of java ee * security). * * @param user, * or null * @param password * cleartext password. after authentication will be cleared. * @param realm * jaas realm name * @return *\/\n\/\/ consider modules: krb5loginmodule, ldaploginmodule, ntloginmodule, \/\/ jndiloginmodule \/\/ ...sun...\n\/\/ referenced in jaas.conf\n\/\/ call callback to retrieve credentials, and checks that \/\/ authentication fails\n\/\/ fixme. loginexception may happen either because authentication \/\/ failed, or for many other reasons. \/\/ we should ignore the first, and log the latter.","repo":"luca-vercelli\/java-web-template","code_context_2":"public LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\n\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\n\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;","code_context_10":"public LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\n\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}","code_context_20":"public LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}\n\npublic LoginContext authenticate(String user, char[] password, String realm) {\n\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\/\/ JndiLoginModule\n\/\/ ...sun...\nPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\nLoginContext lc;\ntry {\nlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n} catch (LoginException e) {\nLOG.error(\"Exception during new LoginContext()\", e);\nreturn null;\n}\ntry {\n\/\/ call callback to retrieve credentials, and checks that\n\/\/ Authentication fails\nlc.login();\n} catch (LoginException e) {\n\/\/ FIXME. LoginException may happen either because authentication\n\/\/ failed, or for many other reasons.\n\/\/ We should ignore the first, and LOG the latter.\nLOG.error(\"Exception while loggin-in\", e);\nreturn null;\n} finally {\nArrays.fill(password, '\\u0000');\n}\nreturn lc;\n}","label":[0,0,1,0]}
{"id":11878,"original_code":"@Override\n\tpublic void runWithEvent(IAction action, Event event) {\n\t\tupdateEnablement(action);\n\t\tif (action.isEnabled()) {\n\t\t\tISelection currentSelection = getSelection();\n\t\t\tSet<EPlanElement> selected = PlanEditorUtil.emfFromSelection(currentSelection);\n\t\t\tfinal MoveToOrbitOperation op = new MoveToOrbitOperation(selected);\n\t\t\tString errorMsg = op.analyzeMistakenSelection();\n\t\t\tif (errorMsg != null) {\n\t\t\t\tLogUtil.warn(errorMsg);\n\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Nothing to Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\"No orbit-related plan elements selected.\",\n\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg, new ExecutionException(selected.toString())));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString orbitId = promptForValue();\n\t\t\t\tif (orbitId != null) {\n\t\t\t\t\top.setOrbitId(orbitId);\n\t\t\t\t\tIUndoContext undoContext = getUndoContext();\n\t\t\t\t\tCommonUtils.execute(op, undoContext);\n\t\t\t\t\tString errorMsg2 = op.analyzeMissingOrbitDestination();\n\t\t\t\t\tif (errorMsg2 != null) {\n\t\t\t\t\t\tLogUtil.warn(errorMsg2);\n\t\t\t\t\t\t\/\/TODO:  Use the new WidgetUtils.showErrorToUser method.\n\t\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\t\t\"Move To \" + OrbitEventUtil.ORBIT_NAME +  \" may not have done what you expected.\",\n\t\t\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t\tIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\n\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}","code":"@Override\n\tpublic void runWithEvent(IAction action, Event event) {\n\t\tupdateEnablement(action);\n\t\tif (action.isEnabled()) {\n\t\t\tISelection currentSelection = getSelection();\n\t\t\tSet<EPlanElement> selected = PlanEditorUtil.emfFromSelection(currentSelection);\n\t\t\tfinal MoveToOrbitOperation op = new MoveToOrbitOperation(selected);\n\t\t\tString errorMsg = op.analyzeMistakenSelection();\n\t\t\tif (errorMsg != null) {\n\t\t\t\tLogUtil.warn(errorMsg);\n\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Nothing to Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\"No orbit-related plan elements selected.\",\n\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg, new ExecutionException(selected.toString())));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString orbitId = promptForValue();\n\t\t\t\tif (orbitId != null) {\n\t\t\t\t\top.setOrbitId(orbitId);\n\t\t\t\t\tIUndoContext undoContext = getUndoContext();\n\t\t\t\t\tCommonUtils.execute(op, undoContext);\n\t\t\t\t\tString errorMsg2 = op.analyzeMissingOrbitDestination();\n\t\t\t\t\tif (errorMsg2 != null) {\n\t\t\t\t\t\tLogUtil.warn(errorMsg2);\n\t\t\t\t\t\n\t\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\t\t\"Move To \" + OrbitEventUtil.ORBIT_NAME +  \" may not have done what you expected.\",\n\t\t\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t\tIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\n\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"@override public void runwithevent(iaction action, event event) { updateenablement(action); if (action.isenabled()) { iselection currentselection = getselection(); set<eplanelement> selected = planeditorutil.emffromselection(currentselection); final movetoorbitoperation op = new movetoorbitoperation(selected); string errormsg = op.analyzemistakenselection(); if (errormsg != null) { logutil.warn(errormsg); errordialog.openerror(widgetutils.getshell(), \"nothing to move to \" + orbiteventutil.orbit_name, \"no orbit-related plan elements selected.\", new exceptionstatus(editorplugin.id, errormsg, new executionexception(selected.tostring()))); return; } try { string orbitid = promptforvalue(); if (orbitid != null) { op.setorbitid(orbitid); iundocontext undocontext = getundocontext(); commonutils.execute(op, undocontext); string errormsg2 = op.analyzemissingorbitdestination(); if (errormsg2 != null) { logutil.warn(errormsg2); errordialog.openerror(widgetutils.getshell(), \"move to \" + orbiteventutil.orbit_name, \"move to \" + orbiteventutil.orbit_name + \" may not have done what you expected.\", new exceptionstatus(editorplugin.id, errormsg2, new executionexception(selected.tostring()))); return; } } } catch (exception e) { istatus error = new exceptionstatus(editorplugin.id, e.getmessage(), e); errordialog.openerror(widgetutils.getshell(), \"an error occurred\", \"that didn't work.\", error); } } }","comment":"\/\/todo: use the new widgetutils.showerrortouser method.","repo":"mikiec84\/OpenSPIFe","code_context_2":"if (errorMsg2 != null) {\nLogUtil.warn(errorMsg2);\n\/\/TODO: Use the new WidgetUtils.showErrorToUser method.\nErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\"Move To \" + OrbitEventUtil.ORBIT_NAME + \" may not have done what you expected.\",","code_context_10":"}\ntry {\nString orbitId = promptForValue();\nif (orbitId != null) {\nop.setOrbitId(orbitId);\nIUndoContext undoContext = getUndoContext();\nCommonUtils.execute(op, undoContext);\nString errorMsg2 = op.analyzeMissingOrbitDestination();\nif (errorMsg2 != null) {\nLogUtil.warn(errorMsg2);\n\/\/TODO: Use the new WidgetUtils.showErrorToUser method.\nErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\"Move To \" + OrbitEventUtil.ORBIT_NAME + \" may not have done what you expected.\",\nnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\nreturn;\n}\n}\n}\ncatch (Exception e) {\nIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\nErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);","code_context_20":"ISelection currentSelection = getSelection();\nSet<EPlanElement> selected = PlanEditorUtil.emfFromSelection(currentSelection);\nfinal MoveToOrbitOperation op = new MoveToOrbitOperation(selected);\nString errorMsg = op.analyzeMistakenSelection();\nif (errorMsg != null) {\nLogUtil.warn(errorMsg);\nErrorDialog.openError(WidgetUtils.getShell(), \"Nothing to Move To \" + OrbitEventUtil.ORBIT_NAME,\n\"No orbit-related plan elements selected.\",\nnew ExceptionStatus(EditorPlugin.ID, errorMsg, new ExecutionException(selected.toString())));\nreturn;\n}\ntry {\nString orbitId = promptForValue();\nif (orbitId != null) {\nop.setOrbitId(orbitId);\nIUndoContext undoContext = getUndoContext();\nCommonUtils.execute(op, undoContext);\nString errorMsg2 = op.analyzeMissingOrbitDestination();\nif (errorMsg2 != null) {\nLogUtil.warn(errorMsg2);\n\/\/TODO: Use the new WidgetUtils.showErrorToUser method.\nErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\"Move To \" + OrbitEventUtil.ORBIT_NAME + \" may not have done what you expected.\",\nnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\nreturn;\n}\n}\n}\ncatch (Exception e) {\nIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\nErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);\n}\n}\n}","label":[1,0,0,0]}
{"id":20922,"original_code":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n\t{\n\t\t\/\/ TODO: Check & refactor this\n\t\t\/\/ Get Tree\n\t\tint AD_Tree_ID = 0;\n\t\tMClient client = MClient.get(ctx);\n\t\tI_AD_ClientInfo ci = client.getInfo();\n\t\tif (TREETYPE_Activity.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Activity_ID();\n\t\telse if (TREETYPE_BoM.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"BoM Trees not supported\");\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\n\t\telse if (TREETYPE_Campaign.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\n\t\telse if (TREETYPE_ElementValue.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\n\t\telse if (TREETYPE_Menu.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Menu_ID();\n\t\telse if (TREETYPE_Organization.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Org_ID();\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Product_ID();\n\t\telse if (TREETYPE_ProductCategory.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"Product Category Trees not supported\");\n\t\telse if (TREETYPE_Project.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Project_ID();\n\t\telse if (TREETYPE_SalesRegion.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\n\t\tif (AD_Tree_ID == 0)\n\t\t\tthrow new IllegalArgumentException(\"No Tree found\");\n\t\tMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\n\t\tif (tree.get_ID() != AD_Tree_ID)\n\t\t\tthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\t\t\/\/ Insert Tree in correct tree\n\t\tboolean saved = false;\n\t\tif (TREETYPE_Menu.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t{\n\t\t\tMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMTree_Node node = new MTree_Node(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\treturn saved;\n\t}","code":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n\t{\n\t\n\t\n\t\tint AD_Tree_ID = 0;\n\t\tMClient client = MClient.get(ctx);\n\t\tI_AD_ClientInfo ci = client.getInfo();\n\t\tif (TREETYPE_Activity.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Activity_ID();\n\t\telse if (TREETYPE_BoM.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"BoM Trees not supported\");\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\n\t\telse if (TREETYPE_Campaign.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\n\t\telse if (TREETYPE_ElementValue.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\n\t\telse if (TREETYPE_Menu.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Menu_ID();\n\t\telse if (TREETYPE_Organization.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Org_ID();\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Product_ID();\n\t\telse if (TREETYPE_ProductCategory.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"Product Category Trees not supported\");\n\t\telse if (TREETYPE_Project.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Project_ID();\n\t\telse if (TREETYPE_SalesRegion.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\n\t\tif (AD_Tree_ID == 0)\n\t\t\tthrow new IllegalArgumentException(\"No Tree found\");\n\t\tMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\n\t\tif (tree.get_ID() != AD_Tree_ID)\n\t\t\tthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\t\n\t\tboolean saved = false;\n\t\tif (TREETYPE_Menu.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t{\n\t\t\tMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMTree_Node node = new MTree_Node(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\treturn saved;\n\t}","cleancode":"public static boolean addnode(properties ctx, string treetype, int record_id, string trxname) { int ad_tree_id = 0; mclient client = mclient.get(ctx); i_ad_clientinfo ci = client.getinfo(); if (treetype_activity.equals(treetype)) ad_tree_id = ci.getad_tree_activity_id(); else if (treetype_bom.equals(treetype)) throw new illegalargumentexception(\"bom trees not supported\"); else if (treetype_bpartner.equals(treetype)) ad_tree_id = ci.getad_tree_bpartner_id(); else if (treetype_campaign.equals(treetype)) ad_tree_id = ci.getad_tree_campaign_id(); else if (treetype_elementvalue.equals(treetype)) throw new illegalargumentexception(\"elementvalue cannot use this api\"); else if (treetype_menu.equals(treetype)) ad_tree_id = ci.getad_tree_menu_id(); else if (treetype_organization.equals(treetype)) ad_tree_id = ci.getad_tree_org_id(); else if (treetype_product.equals(treetype)) ad_tree_id = ci.getad_tree_product_id(); else if (treetype_productcategory.equals(treetype)) throw new illegalargumentexception(\"product category trees not supported\"); else if (treetype_project.equals(treetype)) ad_tree_id = ci.getad_tree_project_id(); else if (treetype_salesregion.equals(treetype)) ad_tree_id = ci.getad_tree_salesregion_id(); if (ad_tree_id == 0) throw new illegalargumentexception(\"no tree found\"); mtree_base tree = mtree_base.get(ctx, ad_tree_id, trxname); if (tree.get_id() != ad_tree_id) throw new illegalargumentexception(\"tree found ad_tree_id=\" + ad_tree_id); boolean saved = false; if (treetype_menu.equals(treetype)) { mtree_nodemm node = new mtree_nodemm(tree, record_id); saved = node.save(); } else if (treetype_bpartner.equals(treetype)) { mtree_nodebp node = new mtree_nodebp(tree, record_id); saved = node.save(); } else if (treetype_product.equals(treetype)) { mtree_nodepr node = new mtree_nodepr(tree, record_id); saved = node.save(); } else { mtree_node node = new mtree_node(tree, record_id); saved = node.save(); } return saved; }","comment":"\/** * add node to correct tree * * @param ctx cpntext * @param treetype tree type * @param record_id id * @param trxname transaction * @return true if node added *\/\n\/\/ todo: check & refactor this \/\/ get tree\n\/\/ insert tree in correct tree","repo":"metas-fresh\/fresh","code_context_2":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\nI_AD_ClientInfo ci = client.getInfo();\nif (TREETYPE_Activity.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Activity_ID();\nelse if (TREETYPE_BoM.equals(treeType))\nthrow new IllegalArgumentException(\"BoM Trees not supported\");\nelse if (TREETYPE_BPartner.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\nelse if (TREETYPE_Campaign.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\nelse if (TREETYPE_ElementValue.equals(treeType))\nthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\nelse if (TREETYPE_Menu.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Menu_ID();\nelse if (TREETYPE_Organization.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Org_ID();\nelse if (TREETYPE_Product.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Product_ID();\nelse if (TREETYPE_ProductCategory.equals(treeType))\nthrow new IllegalArgumentException(\"Product Category Trees not supported\");\nelse if (TREETYPE_Project.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Project_ID();\nelse if (TREETYPE_SalesRegion.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\nif (AD_Tree_ID == 0)\nthrow new IllegalArgumentException(\"No Tree found\");\nMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))\n{\nMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_BPartner.equals(treeType))\n{\nMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_Product.equals(treeType))\n{\nMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\nsaved = node.save();\n}\nelse\n{\nMTree_Node node = new MTree_Node(tree, Record_ID);\nsaved = node.save();\n}\nreturn saved;\n}\n\npublic static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\n\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))","code_context_10":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\nI_AD_ClientInfo ci = client.getInfo();\nif (TREETYPE_Activity.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Activity_ID();\nelse if (TREETYPE_BoM.equals(treeType))\nthrow new IllegalArgumentException(\"BoM Trees not supported\");\nelse if (TREETYPE_BPartner.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\nelse if (TREETYPE_Campaign.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\nelse if (TREETYPE_ElementValue.equals(treeType))\nthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\nelse if (TREETYPE_Menu.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Menu_ID();\nelse if (TREETYPE_Organization.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Org_ID();\nelse if (TREETYPE_Product.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Product_ID();\nelse if (TREETYPE_ProductCategory.equals(treeType))\nthrow new IllegalArgumentException(\"Product Category Trees not supported\");\nelse if (TREETYPE_Project.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Project_ID();\nelse if (TREETYPE_SalesRegion.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\nif (AD_Tree_ID == 0)\nthrow new IllegalArgumentException(\"No Tree found\");\nMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))\n{\nMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_BPartner.equals(treeType))\n{\nMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_Product.equals(treeType))\n{\nMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\nsaved = node.save();\n}\nelse\n{\nMTree_Node node = new MTree_Node(tree, Record_ID);\nsaved = node.save();\n}\nreturn saved;\n}\n\npublic static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\nI_AD_ClientInfo ci = client.getInfo();\nif (TREETYPE_Activity.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Activity_ID();\nelse if (TREETYPE_BoM.equals(treeType))\nthrow new IllegalArgumentException(\"BoM Trees not supported\");\nelse if (TREETYPE_BPartner.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\nelse if (TREETYPE_Campaign.equals(treeType))\n\nthrow new IllegalArgumentException(\"Product Category Trees not supported\");\nelse if (TREETYPE_Project.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Project_ID();\nelse if (TREETYPE_SalesRegion.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\nif (AD_Tree_ID == 0)\nthrow new IllegalArgumentException(\"No Tree found\");\nMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))\n{\nMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_BPartner.equals(treeType))\n{\nMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\nsaved = node.save();","code_context_20":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\nI_AD_ClientInfo ci = client.getInfo();\nif (TREETYPE_Activity.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Activity_ID();\nelse if (TREETYPE_BoM.equals(treeType))\nthrow new IllegalArgumentException(\"BoM Trees not supported\");\nelse if (TREETYPE_BPartner.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\nelse if (TREETYPE_Campaign.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\nelse if (TREETYPE_ElementValue.equals(treeType))\nthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\nelse if (TREETYPE_Menu.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Menu_ID();\nelse if (TREETYPE_Organization.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Org_ID();\nelse if (TREETYPE_Product.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Product_ID();\nelse if (TREETYPE_ProductCategory.equals(treeType))\nthrow new IllegalArgumentException(\"Product Category Trees not supported\");\nelse if (TREETYPE_Project.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Project_ID();\nelse if (TREETYPE_SalesRegion.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\nif (AD_Tree_ID == 0)\nthrow new IllegalArgumentException(\"No Tree found\");\nMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))\n{\nMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_BPartner.equals(treeType))\n{\nMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_Product.equals(treeType))\n{\nMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\nsaved = node.save();\n}\nelse\n{\nMTree_Node node = new MTree_Node(tree, Record_ID);\nsaved = node.save();\n}\nreturn saved;\n}\n\npublic static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n{\n\/\/ TODO: Check & refactor this\n\/\/ Get Tree\nint AD_Tree_ID = 0;\nMClient client = MClient.get(ctx);\nI_AD_ClientInfo ci = client.getInfo();\nif (TREETYPE_Activity.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Activity_ID();\nelse if (TREETYPE_BoM.equals(treeType))\nthrow new IllegalArgumentException(\"BoM Trees not supported\");\nelse if (TREETYPE_BPartner.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\nelse if (TREETYPE_Campaign.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\nelse if (TREETYPE_ElementValue.equals(treeType))\nthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\nelse if (TREETYPE_Menu.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Menu_ID();\nelse if (TREETYPE_Organization.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Org_ID();\nelse if (TREETYPE_Product.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Product_ID();\nelse if (TREETYPE_ProductCategory.equals(treeType))\n\nAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\nelse if (TREETYPE_ElementValue.equals(treeType))\nthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\nelse if (TREETYPE_Menu.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Menu_ID();\nelse if (TREETYPE_Organization.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Org_ID();\nelse if (TREETYPE_Product.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Product_ID();\nelse if (TREETYPE_ProductCategory.equals(treeType))\nthrow new IllegalArgumentException(\"Product Category Trees not supported\");\nelse if (TREETYPE_Project.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_Project_ID();\nelse if (TREETYPE_SalesRegion.equals(treeType))\nAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\nif (AD_Tree_ID == 0)\nthrow new IllegalArgumentException(\"No Tree found\");\nMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\nif (tree.get_ID() != AD_Tree_ID)\nthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\/\/ Insert Tree in correct tree\nboolean saved = false;\nif (TREETYPE_Menu.equals(treeType))\n{\nMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_BPartner.equals(treeType))\n{\nMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\nsaved = node.save();\n}\nelse if (TREETYPE_Product.equals(treeType))\n{\nMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\nsaved = node.save();\n}\nelse\n{\nMTree_Node node = new MTree_Node(tree, Record_ID);\nsaved = node.save();","label":[1,0,0,0]}
{"id":12731,"original_code":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\n        Set<Operator> seenByDFS = new HashSet<Operator>();\n        Map<LogicalPlan, PigOutLogicalChunks> mapping =\n                new HashMap<>();\n        while ( !visitQueue.isEmpty() ) {\n            Operator s = visitQueue.poll();\n            LogicalRelationalOperator lro = (LogicalRelationalOperator) s;\n            log.debug(\"Visit: \" + lro);\n            \/\/ for each s, we may need to create a new \"chunk\"\n\t\t\t\/\/ each partition is created by DFS from a source\n            if (!seenByDFS.add(s)) continue;\n            \/\/ Create a new logical plan for the new chunk\n            LogicalPlan newPlan = new LogicalPlan();\n            newPlan.add(s);\n            subPlans.put(s, newPlan);\n            List<Operator> preds = this.plan.getPredecessors(s);\n            if (preds != null)\n                planPreds.put(newPlan, new LinkedList<>(preds));\n            log.debug(lro.getAlias() + \" is the root of new chunk\");\n            discoverPartition(s, seenByDFS, newPlan);\n            String nameNode = this.siteAssignment.get(s);\n            String hostname = nameNode.split(\":\")[0];\n            String portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\n            int port = new Integer(portNum);\n            PigOutCluster clusterInfo = getPigOutCluster(hostname, port);\n            long dataIn = computeDataInSize(newPlan);\n            long dataOut = computeDataOutSize(newPlan);\n            addStores(newPlan);\n            addLoads(newPlan);\n            Iterator<Operator> it = newPlan.getOperators();\n            while (it.hasNext()) {\n                Operator op = it.next();\n                op.setPlan(newPlan);\n            }\n            PigOutLogicalChunks chunk;\n            chunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\n            chunk.setAlias(lro.getAlias());\n            mapping.put( newPlan, chunk );\n        }\n        for (LogicalPlan lp : mapping.keySet()) {\n            List<Operator> succs = planSuccs.get(lp);\n            List<Operator> preds = planPreds.get(lp);\n            PigOutLogicalChunks chunk = mapping.get(lp);\n            if (succs != null) {\n                for (Operator succ : succs) {\n                    LogicalPlan succLP = (LogicalPlan) succ.getPlan();\n                    PigOutLogicalChunks succChunk = mapping.get(succLP);\n                    succChunk.addPredecessors(chunk);\n                    log.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n                }\n            }\n            if (preds != null) {\n                for (Operator pred : preds) {\n                    LogicalPlan predLP = (LogicalPlan) pred.getPlan();\n                    PigOutLogicalChunks predChunk = mapping.get(predLP);\n                    chunk.addPredecessors(predChunk);\n                    log.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n                }\n            }\n        }\n        List<PigOutLogicalChunks> list_chunks = new LinkedList<>();\n        for (PigOutLogicalChunks chunk : mapping.values()) {\n            list_chunks.add( chunk );\n        }\n        return list_chunks;\n    }","code":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\n        Set<Operator> seenByDFS = new HashSet<Operator>();\n        Map<LogicalPlan, PigOutLogicalChunks> mapping =\n                new HashMap<>();\n        while ( !visitQueue.isEmpty() ) {\n            Operator s = visitQueue.poll();\n            LogicalRelationalOperator lro = (LogicalRelationalOperator) s;\n            log.debug(\"Visit: \" + lro);\n           \n\t\t\n            if (!seenByDFS.add(s)) continue;\n           \n            LogicalPlan newPlan = new LogicalPlan();\n            newPlan.add(s);\n            subPlans.put(s, newPlan);\n            List<Operator> preds = this.plan.getPredecessors(s);\n            if (preds != null)\n                planPreds.put(newPlan, new LinkedList<>(preds));\n            log.debug(lro.getAlias() + \" is the root of new chunk\");\n            discoverPartition(s, seenByDFS, newPlan);\n            String nameNode = this.siteAssignment.get(s);\n            String hostname = nameNode.split(\":\")[0];\n            String portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\n            int port = new Integer(portNum);\n            PigOutCluster clusterInfo = getPigOutCluster(hostname, port);\n            long dataIn = computeDataInSize(newPlan);\n            long dataOut = computeDataOutSize(newPlan);\n            addStores(newPlan);\n            addLoads(newPlan);\n            Iterator<Operator> it = newPlan.getOperators();\n            while (it.hasNext()) {\n                Operator op = it.next();\n                op.setPlan(newPlan);\n            }\n            PigOutLogicalChunks chunk;\n            chunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\n            chunk.setAlias(lro.getAlias());\n            mapping.put( newPlan, chunk );\n        }\n        for (LogicalPlan lp : mapping.keySet()) {\n            List<Operator> succs = planSuccs.get(lp);\n            List<Operator> preds = planPreds.get(lp);\n            PigOutLogicalChunks chunk = mapping.get(lp);\n            if (succs != null) {\n                for (Operator succ : succs) {\n                    LogicalPlan succLP = (LogicalPlan) succ.getPlan();\n                    PigOutLogicalChunks succChunk = mapping.get(succLP);\n                    succChunk.addPredecessors(chunk);\n                    log.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n                }\n            }\n            if (preds != null) {\n                for (Operator pred : preds) {\n                    LogicalPlan predLP = (LogicalPlan) pred.getPlan();\n                    PigOutLogicalChunks predChunk = mapping.get(predLP);\n                    chunk.addPredecessors(predChunk);\n                    log.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n                }\n            }\n        }\n        List<PigOutLogicalChunks> list_chunks = new LinkedList<>();\n        for (PigOutLogicalChunks chunk : mapping.values()) {\n            list_chunks.add( chunk );\n        }\n        return list_chunks;\n    }","cleancode":"public list<pigoutlogicalchunks> createlogicalchunks() throws frontendexception { set<operator> seenbydfs = new hashset<operator>(); map<logicalplan, pigoutlogicalchunks> mapping = new hashmap<>(); while ( !visitqueue.isempty() ) { operator s = visitqueue.poll(); logicalrelationaloperator lro = (logicalrelationaloperator) s; log.debug(\"visit: \" + lro); if (!seenbydfs.add(s)) continue; logicalplan newplan = new logicalplan(); newplan.add(s); subplans.put(s, newplan); list<operator> preds = this.plan.getpredecessors(s); if (preds != null) planpreds.put(newplan, new linkedlist<>(preds)); log.debug(lro.getalias() + \" is the root of new chunk\"); discoverpartition(s, seenbydfs, newplan); string namenode = this.siteassignment.get(s); string hostname = namenode.split(\":\")[0]; string portnum = this.context.getproperties().getproperty(hostname + \".job.tracker\").split(\":\")[1]; int port = new integer(portnum); pigoutcluster clusterinfo = getpigoutcluster(hostname, port); long datain = computedatainsize(newplan); long dataout = computedataoutsize(newplan); addstores(newplan); addloads(newplan); iterator<operator> it = newplan.getoperators(); while (it.hasnext()) { operator op = it.next(); op.setplan(newplan); } pigoutlogicalchunks chunk; chunk = new pigoutlogicalchunks(newplan, context, clusterinfo, datain, dataout); chunk.setalias(lro.getalias()); mapping.put( newplan, chunk ); } for (logicalplan lp : mapping.keyset()) { list<operator> succs = plansuccs.get(lp); list<operator> preds = planpreds.get(lp); pigoutlogicalchunks chunk = mapping.get(lp); if (succs != null) { for (operator succ : succs) { logicalplan succlp = (logicalplan) succ.getplan(); pigoutlogicalchunks succchunk = mapping.get(succlp); succchunk.addpredecessors(chunk); log.debug(succchunk.getalias() + \" depends on \" + chunk.getalias()); } } if (preds != null) { for (operator pred : preds) { logicalplan predlp = (logicalplan) pred.getplan(); pigoutlogicalchunks predchunk = mapping.get(predlp); chunk.addpredecessors(predchunk); log.debug(chunk.getalias() + \" depends on \" + predchunk.getalias()); } } } list<pigoutlogicalchunks> list_chunks = new linkedlist<>(); for (pigoutlogicalchunks chunk : mapping.values()) { list_chunks.add( chunk ); } return list_chunks; }","comment":"\/\/ todo: make this method shorter, less than 100 lines\n\/\/ for each s, we may need to create a new \"chunk\" \/\/ each partition is created by dfs from a source\n\/\/ create a new logical plan for the new chunk","repo":"kyunghoj\/pigout","code_context_2":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];\nString portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\nint port = new Integer(portNum);\nPigOutCluster clusterInfo = getPigOutCluster(hostname, port);\nlong dataIn = computeDataInSize(newPlan);\nlong dataOut = computeDataOutSize(newPlan);\naddStores(newPlan);\naddLoads(newPlan);\nIterator<Operator> it = newPlan.getOperators();\nwhile (it.hasNext()) {\nOperator op = it.next();\nop.setPlan(newPlan);\n}\nPigOutLogicalChunks chunk;\nchunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\nchunk.setAlias(lro.getAlias());\nmapping.put( newPlan, chunk );\n}\nfor (LogicalPlan lp : mapping.keySet()) {\nList<Operator> succs = planSuccs.get(lp);\nList<Operator> preds = planPreds.get(lp);\nPigOutLogicalChunks chunk = mapping.get(lp);\nif (succs != null) {\nfor (Operator succ : succs) {\nLogicalPlan succLP = (LogicalPlan) succ.getPlan();\nPigOutLogicalChunks succChunk = mapping.get(succLP);\nsuccChunk.addPredecessors(chunk);\nlog.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n}\n}\nif (preds != null) {\nfor (Operator pred : preds) {\nLogicalPlan predLP = (LogicalPlan) pred.getPlan();\nPigOutLogicalChunks predChunk = mapping.get(predLP);\nchunk.addPredecessors(predChunk);\nlog.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n}\n}\n}\nList<PigOutLogicalChunks> list_chunks = new LinkedList<>();\nfor (PigOutLogicalChunks chunk : mapping.values()) {\nlist_chunks.add( chunk );\n}\nreturn list_chunks;\n}\n\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\n\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);","code_context_10":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];\nString portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\nint port = new Integer(portNum);\nPigOutCluster clusterInfo = getPigOutCluster(hostname, port);\nlong dataIn = computeDataInSize(newPlan);\nlong dataOut = computeDataOutSize(newPlan);\naddStores(newPlan);\naddLoads(newPlan);\nIterator<Operator> it = newPlan.getOperators();\nwhile (it.hasNext()) {\nOperator op = it.next();\nop.setPlan(newPlan);\n}\nPigOutLogicalChunks chunk;\nchunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\nchunk.setAlias(lro.getAlias());\nmapping.put( newPlan, chunk );\n}\nfor (LogicalPlan lp : mapping.keySet()) {\nList<Operator> succs = planSuccs.get(lp);\nList<Operator> preds = planPreds.get(lp);\nPigOutLogicalChunks chunk = mapping.get(lp);\nif (succs != null) {\nfor (Operator succ : succs) {\nLogicalPlan succLP = (LogicalPlan) succ.getPlan();\nPigOutLogicalChunks succChunk = mapping.get(succLP);\nsuccChunk.addPredecessors(chunk);\nlog.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n}\n}\nif (preds != null) {\nfor (Operator pred : preds) {\nLogicalPlan predLP = (LogicalPlan) pred.getPlan();\nPigOutLogicalChunks predChunk = mapping.get(predLP);\nchunk.addPredecessors(predChunk);\nlog.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n}\n}\n}\nList<PigOutLogicalChunks> list_chunks = new LinkedList<>();\nfor (PigOutLogicalChunks chunk : mapping.values()) {\nlist_chunks.add( chunk );\n}\nreturn list_chunks;\n}\n\npublic List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\n\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];","code_context_20":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];\nString portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\nint port = new Integer(portNum);\nPigOutCluster clusterInfo = getPigOutCluster(hostname, port);\nlong dataIn = computeDataInSize(newPlan);\nlong dataOut = computeDataOutSize(newPlan);\naddStores(newPlan);\naddLoads(newPlan);\nIterator<Operator> it = newPlan.getOperators();\nwhile (it.hasNext()) {\nOperator op = it.next();\nop.setPlan(newPlan);\n}\nPigOutLogicalChunks chunk;\nchunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\nchunk.setAlias(lro.getAlias());\nmapping.put( newPlan, chunk );\n}\nfor (LogicalPlan lp : mapping.keySet()) {\nList<Operator> succs = planSuccs.get(lp);\nList<Operator> preds = planPreds.get(lp);\nPigOutLogicalChunks chunk = mapping.get(lp);\nif (succs != null) {\nfor (Operator succ : succs) {\nLogicalPlan succLP = (LogicalPlan) succ.getPlan();\nPigOutLogicalChunks succChunk = mapping.get(succLP);\nsuccChunk.addPredecessors(chunk);\nlog.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n}\n}\nif (preds != null) {\nfor (Operator pred : preds) {\nLogicalPlan predLP = (LogicalPlan) pred.getPlan();\nPigOutLogicalChunks predChunk = mapping.get(predLP);\nchunk.addPredecessors(predChunk);\nlog.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n}\n}\n}\nList<PigOutLogicalChunks> list_chunks = new LinkedList<>();\nfor (PigOutLogicalChunks chunk : mapping.values()) {\nlist_chunks.add( chunk );\n}\nreturn list_chunks;\n}\n\npublic List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];\nString portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\nint port = new Integer(portNum);\nPigOutCluster clusterInfo = getPigOutCluster(hostname, port);\nlong dataIn = computeDataInSize(newPlan);\nlong dataOut = computeDataOutSize(newPlan);\naddStores(newPlan);\naddLoads(newPlan);\nIterator<Operator> it = newPlan.getOperators();\n\npublic List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\nSet<Operator> seenByDFS = new HashSet<Operator>();\nMap<LogicalPlan, PigOutLogicalChunks> mapping =\nnew HashMap<>();\nwhile ( !visitQueue.isEmpty() ) {\nOperator s = visitQueue.poll();\nLogicalRelationalOperator lro = (LogicalRelationalOperator) s;\nlog.debug(\"Visit: \" + lro);\n\/\/ for each s, we may need to create a new \"chunk\"\n\/\/ each partition is created by DFS from a source\nif (!seenByDFS.add(s)) continue;\n\/\/ Create a new logical plan for the new chunk\nLogicalPlan newPlan = new LogicalPlan();\nnewPlan.add(s);\nsubPlans.put(s, newPlan);\nList<Operator> preds = this.plan.getPredecessors(s);\nif (preds != null)\nplanPreds.put(newPlan, new LinkedList<>(preds));\nlog.debug(lro.getAlias() + \" is the root of new chunk\");\ndiscoverPartition(s, seenByDFS, newPlan);\nString nameNode = this.siteAssignment.get(s);\nString hostname = nameNode.split(\":\")[0];\nString portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\nint port = new Integer(portNum);\nPigOutCluster clusterInfo = getPigOutCluster(hostname, port);\nlong dataIn = computeDataInSize(newPlan);\nlong dataOut = computeDataOutSize(newPlan);\naddStores(newPlan);\naddLoads(newPlan);\nIterator<Operator> it = newPlan.getOperators();\nwhile (it.hasNext()) {\nOperator op = it.next();","label":[1,0,0,0]}
{"id":21065,"original_code":"@Bean\n    public ListFactoryBean userDnList() {\n        ListFactoryBean bean = new ListFactoryBean();\n        bean.setTargetListClass(ArrayList.class);\n        \/\/ TODO Add values to this list to allow more distinguished name patterns.\n        \/\/      If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\n        List<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n                \"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n                \/\/ TODO CONFIGURATION\n                \/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n                \/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n        );\n        bean.setSourceList(sourceList);\n        return bean;\n    }","code":"@Bean\n    public ListFactoryBean userDnList() {\n        ListFactoryBean bean = new ListFactoryBean();\n        bean.setTargetListClass(ArrayList.class);\n       \n       \n        List<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n                \"cn={0},OU=WCT users,DC=webcurator,DC=org\")\n               \n               \n               \n        );\n        bean.setSourceList(sourceList);\n        return bean;\n    }","cleancode":"@bean public listfactorybean userdnlist() { listfactorybean bean = new listfactorybean(); bean.settargetlistclass(arraylist.class); list<string> sourcelist = new arraylist<string>(arrays.aslist(\"${ldap.dn}\", \"cn={0},ou=wct users,dc=webcurator,dc=org\") ); bean.setsourcelist(sourcelist); return bean; }","comment":"\/\/ todo add values to this list to allow more distinguished name patterns. \/\/ if preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\n\/\/,\n\/\/ todo configuration \/\/\"cn={0},ou=wct users,dc=webcurator,dc=org\", \/\/\"cn={0},ou=wct users,dc=webcurator,dc=org\"","repo":"mbreemhaar\/webcurator","code_context_2":"ListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);","code_context_10":"@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}\n\n@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}\n\n@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}","code_context_20":"@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}\n\n@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}\n\n@Bean\npublic ListFactoryBean userDnList() {\nListFactoryBean bean = new ListFactoryBean();\nbean.setTargetListClass(ArrayList.class);\n\/\/ TODO Add values to this list to allow more distinguished name patterns.\n\/\/ If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\nList<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n\"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n\/\/ TODO CONFIGURATION\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n\/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n);\nbean.setSourceList(sourceList);\nreturn bean;\n}","label":[1,1,0,0]}
{"id":21104,"original_code":"private static String safeUri(String uri) {\n        \/\/ todo: make this way more safe\n        return uri.replace(\" \", \"%20\");\n    }","code":"private static String safeUri(String uri) {\n       \n        return uri.replace(\" \", \"%20\");\n    }","cleancode":"private static string safeuri(string uri) { return uri.replace(\" \", \"%20\"); }","comment":"\/\/ todo: make this way more safe","repo":"mikiec84\/blueprints","code_context_2":"private static String safeUri(String uri) {\n\/\/ todo: make this way more safe\nreturn uri.replace(\" \", \"%20\");\n}","code_context_10":"private static String safeUri(String uri) {\n\/\/ todo: make this way more safe\nreturn uri.replace(\" \", \"%20\");\n}","code_context_20":"private static String safeUri(String uri) {\n\/\/ todo: make this way more safe\nreturn uri.replace(\" \", \"%20\");\n}","label":[1,0,0,0]}
{"id":13004,"original_code":"public static void main(String[] args) {\n        printoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n    }","code":"public static void main(String[] args) {\n        printoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n    }","cleancode":"public static void main(string[] args) { printoutmodelfile(\"\/users\/aidancbrady\/documents\/mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\"); }","comment":"\/\/todo: at to get access to the cubelist and childmodel or not bother given we have already converted things \/*public static voxelshape getshapefrommodel(modelrenderer... models) { return getshapefrommodel(false, models); } public static voxelshape getshapefrommodel(boolean print, modelrenderer... models) { list<voxelshape> shapes = new arraylist<>(); for (modelrenderer model : models) { shapes.add(getshapefrommodel(print, model)); } return voxelshapeutils.combine(shapes); } public static voxelshape getshapefrommodel(boolean print, modelrenderer model) { list<voxelshape> shapes = new arraylist<>(); for (modelbox box : model.cubelist) { shapes.add(voxelshapeutils.getslope(box.posx1, box.posy1, box.posz1, box.posx2, box.posy2, box.posz2, model.rotationpointx, model.rotationpointy, model.rotationpointz, model.rotateanglex, model.rotateangley, model.rotateanglez, print)); } if (model.childmodels != null) { for (modelrenderer childmodel : model.childmodels) { shapes.add(getshapefrommodel(print, childmodel)); } } return voxelshapeutils.combine(shapes, false); }*\/","repo":"marcus8448\/Mekanism","code_context_2":"public static void main(String[] args) {\nprintoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n}","code_context_10":"public static void main(String[] args) {\nprintoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n}","code_context_20":"public static void main(String[] args) {\nprintoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n}","label":[1,0,0,0]}
{"id":13116,"original_code":"private String compoundProduce( JavaFileManager.Location location, Set<ITypeManifold> sps, String fqn, DiagnosticListener<JavaFileObject> errorHandler )\n  {\n    ITypeManifold found = null;\n    String result = \"\";\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == Primary ||\n          sp.getContributorKind() == Partial )\n      {\n        if( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n        {\n          \/\/## todo: use location to select more specifically (in Java 9+ with the location's module)\n          List<IFile> files = sp.findFilesForType( fqn );\n          JavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\n          errorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n            \"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n            \"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n            \"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n            \"If the former, consider renaming one or more of the resource files.\\n\" +\n            \"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n        }\n        else\n        {\n          found = sp;\n          result = sp.contribute( location, fqn, false, result, errorHandler );\n        }\n      }\n    }\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == ContributorKind.Supplemental )\n      {\n        result = sp.contribute( location, fqn, false, result, errorHandler );\n      }\n    }\n    return result;\n  }","code":"private String compoundProduce( JavaFileManager.Location location, Set<ITypeManifold> sps, String fqn, DiagnosticListener<JavaFileObject> errorHandler )\n  {\n    ITypeManifold found = null;\n    String result = \"\";\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == Primary ||\n          sp.getContributorKind() == Partial )\n      {\n        if( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n        {\n         \n          List<IFile> files = sp.findFilesForType( fqn );\n          JavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\n          errorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n            \"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n            \"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n            \"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n            \"If the former, consider renaming one or more of the resource files.\\n\" +\n            \"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n        }\n        else\n        {\n          found = sp;\n          result = sp.contribute( location, fqn, false, result, errorHandler );\n        }\n      }\n    }\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == ContributorKind.Supplemental )\n      {\n        result = sp.contribute( location, fqn, false, result, errorHandler );\n      }\n    }\n    return result;\n  }","cleancode":"private string compoundproduce( javafilemanager.location location, set<itypemanifold> sps, string fqn, diagnosticlistener<javafileobject> errorhandler ) { itypemanifold found = null; string result = \"\"; for( itypemanifold sp: sps ) { if( sp.getcontributorkind() == primary || sp.getcontributorkind() == partial ) { if( found != null && (found.getcontributorkind() == primary || sp.getcontributorkind() == primary) ) { list<ifile> files = sp.findfilesfortype( fqn ); javafileobject file = new sourcejavafileobject( files.get( 0 ).touri() ); errorhandler.report( new javacdiagnostic( file, diagnostic.kind.error, 0, 1, 1, \"the type, \" + fqn + \", has conflicting type manifolds:\\n\" + \"'\" + found.getclass().getname() + \"' and '\" + sp.getclass().getname() + \"'.\\n\" + \"either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" + \"if the former, consider renaming one or more of the resource files.\\n\" + \"if the latter, you must remove one or more of the type manifold libraries.\" ) ); } else { found = sp; result = sp.contribute( location, fqn, false, result, errorhandler ); } } } for( itypemanifold sp: sps ) { if( sp.getcontributorkind() == contributorkind.supplemental ) { result = sp.contribute( location, fqn, false, result, errorhandler ); } } return result; }","comment":"\/\/## todo: use location to select more specifically (in java 9+ with the location's module)","repo":"manifold-systems\/manifold","code_context_2":"if( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n{\n\/\/## todo: use location to select more specifically (in Java 9+ with the location's module)\nList<IFile> files = sp.findFilesForType( fqn );\nJavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );","code_context_10":"{\nITypeManifold found = null;\nString result = \"\";\nfor( ITypeManifold sp: sps )\n{\nif( sp.getContributorKind() == Primary ||\nsp.getContributorKind() == Partial )\n{\nif( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n{\n\/\/## todo: use location to select more specifically (in Java 9+ with the location's module)\nList<IFile> files = sp.findFilesForType( fqn );\nJavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\nerrorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n\"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n\"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n\"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n\"If the former, consider renaming one or more of the resource files.\\n\" +\n\"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n}\nelse","code_context_20":"private String compoundProduce( JavaFileManager.Location location, Set<ITypeManifold> sps, String fqn, DiagnosticListener<JavaFileObject> errorHandler )\n{\nITypeManifold found = null;\nString result = \"\";\nfor( ITypeManifold sp: sps )\n{\nif( sp.getContributorKind() == Primary ||\nsp.getContributorKind() == Partial )\n{\nif( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n{\n\/\/## todo: use location to select more specifically (in Java 9+ with the location's module)\nList<IFile> files = sp.findFilesForType( fqn );\nJavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\nerrorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n\"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n\"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n\"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n\"If the former, consider renaming one or more of the resource files.\\n\" +\n\"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n}\nelse\n{\nfound = sp;\nresult = sp.contribute( location, fqn, false, result, errorHandler );\n}\n}\n}\nfor( ITypeManifold sp: sps )\n{\nif( sp.getContributorKind() == ContributorKind.Supplemental )\n{","label":[1,0,0,0]}
{"id":13241,"original_code":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\n        if (mDrawingPie != null) {\n            if (degree >= mDrawingPie.toAngle \/ 2) {\n                if (!mDrawingPie.hasCached) {\n                    \/\/ fix anim duration too short\n                    PieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\n                    if (preWrapper != null && !preWrapper.hasCached) {\n                        preWrapper.hasCached = true;\n                        mCachedDrawWrappers.add(preWrapper);\n                    }\n                    mCachedDrawWrappers.add(mDrawingPie);\n                    mDrawingPie.hasCached = true;\n                }\n            }\n        }\n        mDrawingPie = infoWrapper;\n        animAngle = degree;\n        callInvalidate();\n    }","code":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\n        if (mDrawingPie != null) {\n            if (degree >= mDrawingPie.toAngle \/ 2) {\n                if (!mDrawingPie.hasCached) {\n                   \n                    PieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\n                    if (preWrapper != null && !preWrapper.hasCached) {\n                        preWrapper.hasCached = true;\n                        mCachedDrawWrappers.add(preWrapper);\n                    }\n                    mCachedDrawWrappers.add(mDrawingPie);\n                    mDrawingPie.hasCached = true;\n                }\n            }\n        }\n        mDrawingPie = infoWrapper;\n        animAngle = degree;\n        callInvalidate();\n    }","cleancode":"public void setcurpie(pieinfowrapperr infowrapper, float degree) { if (mdrawingpie != null) { if (degree >= mdrawingpie.toangle \/ 2) { if (!mdrawingpie.hascached) { pieinfowrapperr prewrapper = mdrawingpie.prewrapper; if (prewrapper != null && !prewrapper.hascached) { prewrapper.hascached = true; mcacheddrawwrappers.add(prewrapper); } mcacheddrawwrappers.add(mdrawingpie); mdrawingpie.hascached = true; } } } mdrawingpie = infowrapper; animangle = degree; callinvalidate(); }","comment":"\/\/-----------------------------------------tools-----------------------------------------\n\/\/ fix anim duration too short","repo":"linyingfa\/AnimatedPieView-master","code_context_2":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\nif (mDrawingPie != null) {\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {\npreWrapper.hasCached = true;\nmCachedDrawWrappers.add(preWrapper);\n}\nmCachedDrawWrappers.add(mDrawingPie);\nmDrawingPie.hasCached = true;\n}\n}\n}\nmDrawingPie = infoWrapper;\nanimAngle = degree;\ncallInvalidate();\n}\n\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {","code_context_10":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\nif (mDrawingPie != null) {\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {\npreWrapper.hasCached = true;\nmCachedDrawWrappers.add(preWrapper);\n}\nmCachedDrawWrappers.add(mDrawingPie);\nmDrawingPie.hasCached = true;\n}\n}\n}\nmDrawingPie = infoWrapper;\nanimAngle = degree;\ncallInvalidate();\n}\n\npublic void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\nif (mDrawingPie != null) {\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {\npreWrapper.hasCached = true;\nmCachedDrawWrappers.add(preWrapper);\n}\nmCachedDrawWrappers.add(mDrawingPie);\nmDrawingPie.hasCached = true;\n}\n}\n}","code_context_20":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\nif (mDrawingPie != null) {\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {\npreWrapper.hasCached = true;\nmCachedDrawWrappers.add(preWrapper);\n}\nmCachedDrawWrappers.add(mDrawingPie);\nmDrawingPie.hasCached = true;\n}\n}\n}\nmDrawingPie = infoWrapper;\nanimAngle = degree;\ncallInvalidate();\n}\n\npublic void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\nif (mDrawingPie != null) {\nif (degree >= mDrawingPie.toAngle \/ 2) {\nif (!mDrawingPie.hasCached) {\n\/\/ fix anim duration too short\nPieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\nif (preWrapper != null && !preWrapper.hasCached) {\npreWrapper.hasCached = true;\nmCachedDrawWrappers.add(preWrapper);\n}\nmCachedDrawWrappers.add(mDrawingPie);\nmDrawingPie.hasCached = true;\n}\n}\n}\nmDrawingPie = infoWrapper;\nanimAngle = degree;\ncallInvalidate();\n}","label":[1,0,0,0]}
{"id":21553,"original_code":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\n\t\t\tthrows IllegalArgumentException {\n\t\t\/\/ TODO Auto-generated method stub\n\t\t\/\/Read data from hdfs\n\t\tList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\n\t\tList<LineChart> lineCharts = new ArrayList<LineChart>();\n\t\tfor(String  selectedCol : columnNames)\n\t\t{\n\t\t\tLineChart lineChart =  singleLineGen(results, dataType, columns, selectedCol);\n\t\t\tif(lineChart == null)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tlineCharts.add(lineChart);\n\t\t}\n\t\treturn lineCharts;\n\t}","code":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\n\t\t\tthrows IllegalArgumentException {\n\t\n\t\n\t\tList<String> results = readAllData(filePath,true);\n\t\tList<LineChart> lineCharts = new ArrayList<LineChart>();\n\t\tfor(String  selectedCol : columnNames)\n\t\t{\n\t\t\tLineChart lineChart =  singleLineGen(results, dataType, columns, selectedCol);\n\t\t\tif(lineChart == null)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tlineCharts.add(lineChart);\n\t\t}\n\t\treturn lineCharts;\n\t}","cleancode":"public list<linechart> linechartgen(string filepath, string datatype, list<string> columns, list<string> columnnames) throws illegalargumentexception { list<string> results = readalldata(filepath,true); list<linechart> linecharts = new arraylist<linechart>(); for(string selectedcol : columnnames) { linechart linechart = singlelinegen(results, datatype, columns, selectedcol); if(linechart == null) continue; else linecharts.add(linechart); } return linecharts; }","comment":"\/** * get line chart data option string to draw the chart * * @param filepath data file path * @param datatype data type * @param columns data all columns * @param columnnames select data columns( list data) * @return * @throws illegalargumentexception *\/\n\/\/ todo auto-generated method stub \/\/read data from hdfs\n\/\/only read limited line data(if the data length over max length)","repo":"milkboylyf\/EasyML","code_context_2":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;\n}\n\npublic List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\n\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)","code_context_10":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;\n}\n\npublic List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\n\npublic List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;","code_context_20":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;\n}\n\npublic List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;\n}\n\npublic List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\nthrows IllegalArgumentException {\n\/\/ TODO Auto-generated method stub\n\/\/Read data from hdfs\nList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\nList<LineChart> lineCharts = new ArrayList<LineChart>();\nfor(String selectedCol : columnNames)\n{\nLineChart lineChart = singleLineGen(results, dataType, columns, selectedCol);\nif(lineChart == null)\ncontinue;\nelse\nlineCharts.add(lineChart);\n}\nreturn lineCharts;\n}","label":[0,1,0,0]}
{"id":13513,"original_code":"@Override\n    public Value evaluate(BlockContext ctx) {\n        ctx.beforeExpression(this);\n        FunctionBlock funcBlock = null;\n        BlockContext callContext = ctx;\n        if (object != null) {\n            \/\/ method call on an object\n            if (VariableReference.isSelfReference(object.getName())) {\n                \/\/ self object reference?\n                funcBlock = callContext.retrieveLocalFunction(functionName);\n                throw new RockstarRuntimeException(\"self reference\");\n            } else if (VariableReference.isParentReference(object.getName())) {\n                \/\/ parent object reference\n                \/\/ find the caller object context\n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n                \/\/ get the parent object, if exists\n                RockObject parentObj = callerObj.getSuperObject();\n                if (parentObj != null) {\n                    \/\/ find the context that contains the function starting the parent\n                    callContext = parentObj.getContextForFunction(functionName);\n                    \/\/ the call context must be the same object as the caller object\n                    if ((callContext != null)\n                            && (callContext instanceof RockObject)\n                            && (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n                        \/\/ get the method from that context\n                        funcBlock = callContext.retrieveLocalFunction(functionName);\n                    }\n                } else {\n                    throw new RockstarRuntimeException(\"parent reference in non-inherited class\");\n                }\n            } else {\n                \/\/ object reference\n                ctx.beforeExpression(object);\n                Value objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\n                if (objValue == null) {\n                    throw new RockstarRuntimeException(\"Object not found: \" + object);\n                }\n                if (objValue.isObject()) {\n                    \/\/ get the object itself\n                    RockObject objContext = objValue.getObject();\n                    \/\/ find the context that contains the function\n                    callContext = objContext.getContextForFunction(functionName);\n                    if (callContext == null) {\n                        throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                    }\n                    \/\/ get the method from the object\n                    funcBlock = callContext.retrieveLocalFunction(functionName);\n                } else {\n                    throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                }\n            }\n        } else {\n            \/\/ simple method call syntax\n            if (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n                \/\/ unqualified \"parent\" function: must be a parent constructor reference\n                \/\/ find the caller object context\n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n                \/\/ get the parent object, if exists\n                RockObject parentObj = callerObj.getSuperObject();\n                \/\/ TODO check if it is called in a constructor\n                if (parentObj != null) {\n                    \/\/ context is the parent object\n                    callContext = parentObj;\n                    \/\/ get the constructor from the parent context\n                    funcBlock = parentObj.getConstructor();\n                } else {\n                    throw new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n                }\n            } else {\n                \/\/ pure function call or unqualified call in an object context?\n                BlockContext funcCtx = ctx.getContextForFunction(functionName);\n                if (funcCtx == null) {\n                    \/\/ function not found, or function exists only in subcontexts\n                    throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n                }\n                \/\/ we found the function, now we need to find the overrides, if it is on an object\n                if (funcCtx instanceof RockObject) {\n                    \/\/ search the function from the top of the object levels\n                    funcCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n                } else {\n                    \/\/ find the containing context by name\n                    funcCtx = ctx.getContextForFunction(functionName);\n                }\n                \/\/ retrieve the function code\n                funcBlock = funcCtx.retrieveLocalFunction(functionName);\n            }\n        }\n        Value retValue;\n        if (funcBlock != null) {\n            List<Expression> params = getParameters();\n            List<Value> values = new ArrayList<>(params.size());\n            params.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n            \/\/ call the functon\n            retValue = funcBlock.call(callContext, values);\n        } else {\n            if (object == null) {\n                throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n            }\n            throw new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n        }\n        \/\/ return the return value\n        return ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n    }","code":"@Override\n    public Value evaluate(BlockContext ctx) {\n        ctx.beforeExpression(this);\n        FunctionBlock funcBlock = null;\n        BlockContext callContext = ctx;\n        if (object != null) {\n           \n            if (VariableReference.isSelfReference(object.getName())) {\n               \n                funcBlock = callContext.retrieveLocalFunction(functionName);\n                throw new RockstarRuntimeException(\"self reference\");\n            } else if (VariableReference.isParentReference(object.getName())) {\n               \n               \n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n               \n                RockObject parentObj = callerObj.getSuperObject();\n                if (parentObj != null) {\n                   \n                    callContext = parentObj.getContextForFunction(functionName);\n                   \n                    if ((callContext != null)\n                            && (callContext instanceof RockObject)\n                            && (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n                       \n                        funcBlock = callContext.retrieveLocalFunction(functionName);\n                    }\n                } else {\n                    throw new RockstarRuntimeException(\"parent reference in non-inherited class\");\n                }\n            } else {\n               \n                ctx.beforeExpression(object);\n                Value objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\n                if (objValue == null) {\n                    throw new RockstarRuntimeException(\"Object not found: \" + object);\n                }\n                if (objValue.isObject()) {\n                   \n                    RockObject objContext = objValue.getObject();\n                   \n                    callContext = objContext.getContextForFunction(functionName);\n                    if (callContext == null) {\n                        throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                    }\n                   \n                    funcBlock = callContext.retrieveLocalFunction(functionName);\n                } else {\n                    throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                }\n            }\n        } else {\n           \n            if (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n               \n               \n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n               \n                RockObject parentObj = callerObj.getSuperObject();\n               \n                if (parentObj != null) {\n                   \n                    callContext = parentObj;\n                   \n                    funcBlock = parentObj.getConstructor();\n                } else {\n                    throw new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n                }\n            } else {\n               \n                BlockContext funcCtx = ctx.getContextForFunction(functionName);\n                if (funcCtx == null) {\n                   \n                    throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n                }\n               \n                if (funcCtx instanceof RockObject) {\n                   \n                    funcCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n                } else {\n                   \n                    funcCtx = ctx.getContextForFunction(functionName);\n                }\n               \n                funcBlock = funcCtx.retrieveLocalFunction(functionName);\n            }\n        }\n        Value retValue;\n        if (funcBlock != null) {\n            List<Expression> params = getParameters();\n            List<Value> values = new ArrayList<>(params.size());\n            params.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n           \n            retValue = funcBlock.call(callContext, values);\n        } else {\n            if (object == null) {\n                throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n            }\n            throw new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n        }\n       \n        return ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n    }","cleancode":"@override public value evaluate(blockcontext ctx) { ctx.beforeexpression(this); functionblock funcblock = null; blockcontext callcontext = ctx; if (object != null) { if (variablereference.isselfreference(object.getname())) { funcblock = callcontext.retrievelocalfunction(functionname); throw new rockstarruntimeexception(\"self reference\"); } else if (variablereference.isparentreference(object.getname())) { rockobject callerobj = ctx.getthisobjectctx() .orelsethrow(() -> new rockstarruntimeexception(\"parent reference in a non-object context\")); rockobject parentobj = callerobj.getsuperobject(); if (parentobj != null) { callcontext = parentobj.getcontextforfunction(functionname); if ((callcontext != null) && (callcontext instanceof rockobject) && (((rockobject) callcontext).getobjid() == callerobj.getobjid())) { funcblock = callcontext.retrievelocalfunction(functionname); } } else { throw new rockstarruntimeexception(\"parent reference in non-inherited class\"); } } else { ctx.beforeexpression(object); value objvalue = ctx.afterexpression(object, ctx.getvariablevalue(object)); if (objvalue == null) { throw new rockstarruntimeexception(\"object not found: \" + object); } if (objvalue.isobject()) { rockobject objcontext = objvalue.getobject(); callcontext = objcontext.getcontextforfunction(functionname); if (callcontext == null) { throw new rockstarruntimeexception(\"invalid method call \" + functionname + \" on a \" + objvalue.gettype().name() + \" type variable \" + object); } funcblock = callcontext.retrievelocalfunction(functionname); } else { throw new rockstarruntimeexception(\"invalid method call \" + functionname + \" on a \" + objvalue.gettype().name() + \" type variable \" + object); } } } else { if (variablereference.isparentreference(functionname) && ctx.getthisobjectctx().ispresent()) { rockobject callerobj = ctx.getthisobjectctx() .orelsethrow(() -> new rockstarruntimeexception(\"parent constructor call in a non-object context\")); rockobject parentobj = callerobj.getsuperobject(); if (parentobj != null) { callcontext = parentobj; funcblock = parentobj.getconstructor(); } else { throw new rockstarruntimeexception(\"parent constructor reference in non-inherited class\"); } } else { blockcontext funcctx = ctx.getcontextforfunction(functionname); if (funcctx == null) { throw new rockstarruntimeexception(\"undefined function: \" + functionname); } if (funcctx instanceof rockobject) { funcctx = ((rockobject) funcctx).gettopobject().getcontextforfunction(functionname); } else { funcctx = ctx.getcontextforfunction(functionname); } funcblock = funcctx.retrievelocalfunction(functionname); } } value retvalue; if (funcblock != null) { list<expression> params = getparameters(); list<value> values = new arraylist<>(params.size()); params.foreach((expr) -> values.add(expr.evaluate(ctx).asparameter())); retvalue = funcblock.call(callcontext, values); } else { if (object == null) { throw new rockstarruntimeexception(\"undefined function: \" + functionname); } throw new rockstarruntimeexception(\"undefined method: \" + functionname + \" on class \" + object.getname()); } return ctx.afterexpression(this, retvalue == null ? value.null : retvalue); }","comment":"\/\/ method call on an object\n\/\/ self object reference?\n\/\/ parent object reference \/\/ find the caller object context\n\/\/ get the parent object, if exists\n\/\/ find the context that contains the function starting the parent\n\/\/ the call context must be the same object as the caller object\n\/\/ get the method from that context\n\/\/ object reference\n\/\/ get the object itself\n\/\/ find the context that contains the function\n\/\/ get the method from the object\n\/\/ simple method call syntax\n\/\/ unqualified \"parent\" function: must be a parent constructor reference \/\/ find the caller object context\n\/\/ get the parent object, if exists\n\/\/ todo check if it is called in a constructor\n\/\/ context is the parent object\n\/\/ get the constructor from the parent context\n\/\/ pure function call or unqualified call in an object context?\n\/\/ function not found, or function exists only in subcontexts\n\/\/ we found the function, now we need to find the overrides, if it is on an object\n\/\/ search the function from the top of the object levels\n\/\/ find the containing context by name\n\/\/ retrieve the function code\n\/\/ call the functon\n\/\/ return the return value","repo":"mikesep\/rocky","code_context_2":"BlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\n\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\n\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\n\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\n\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\n\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\n\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\n\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\n\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\n\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\n\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\n\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}","code_context_10":"@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\n\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\n\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\n\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\n\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\n\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\n\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\n\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}\n\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}","code_context_20":"@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\n\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\n\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\n\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n}\nif (objValue.isObject()) {\n\/\/ get the object itself\nRockObject objContext = objValue.getObject();\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\n@Override\npublic Value evaluate(BlockContext ctx) {\nctx.beforeExpression(this);\nFunctionBlock funcBlock = null;\nBlockContext callContext = ctx;\nif (object != null) {\n\/\/ method call on an object\nif (VariableReference.isSelfReference(object.getName())) {\n\/\/ self object reference?\nfuncBlock = callContext.retrieveLocalFunction(functionName);\nthrow new RockstarRuntimeException(\"self reference\");\n} else if (VariableReference.isParentReference(object.getName())) {\n\/\/ parent object reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\nif (parentObj != null) {\n\/\/ find the context that contains the function starting the parent\ncallContext = parentObj.getContextForFunction(functionName);\n\/\/ the call context must be the same object as the caller object\nif ((callContext != null)\n&& (callContext instanceof RockObject)\n&& (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n\/\/ get the method from that context\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n}\n} else {\nthrow new RockstarRuntimeException(\"parent reference in non-inherited class\");\n}\n} else {\n\/\/ object reference\nctx.beforeExpression(object);\nValue objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\nif (objValue == null) {\nthrow new RockstarRuntimeException(\"Object not found: \" + object);\n\n\/\/ find the context that contains the function\ncallContext = objContext.getContextForFunction(functionName);\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\nif (callContext == null) {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n\n}\n\/\/ get the method from the object\nfuncBlock = callContext.retrieveLocalFunction(functionName);\n} else {\nthrow new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n}\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\n\n}\n} else {\n\/\/ simple method call syntax\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\n\nif (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n\/\/ unqualified \"parent\" function: must be a parent constructor reference\n\/\/ find the caller object context\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\n\nRockObject callerObj = ctx.getThisObjectCtx()\n.orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\n\n\/\/ get the parent object, if exists\nRockObject parentObj = callerObj.getSuperObject();\n\/\/ TODO check if it is called in a constructor\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\nif (parentObj != null) {\n\/\/ context is the parent object\ncallContext = parentObj;\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\n\n\/\/ get the constructor from the parent context\nfuncBlock = parentObj.getConstructor();\n} else {\nthrow new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n}\n} else {\n\/\/ pure function call or unqualified call in an object context?\nBlockContext funcCtx = ctx.getContextForFunction(functionName);\nif (funcCtx == null) {\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}\n\n\/\/ function not found, or function exists only in subcontexts\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\n\/\/ we found the function, now we need to find the overrides, if it is on an object\nif (funcCtx instanceof RockObject) {\n\/\/ search the function from the top of the object levels\nfuncCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n} else {\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}\n\n\/\/ find the containing context by name\nfuncCtx = ctx.getContextForFunction(functionName);\n}\n\/\/ retrieve the function code\nfuncBlock = funcCtx.retrieveLocalFunction(functionName);\n}\n}\nValue retValue;\nif (funcBlock != null) {\nList<Expression> params = getParameters();\nList<Value> values = new ArrayList<>(params.size());\nparams.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n\/\/ call the functon\nretValue = funcBlock.call(callContext, values);\n} else {\nif (object == null) {\nthrow new RockstarRuntimeException(\"Undefined function: \" + functionName);\n}\nthrow new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n}\n\/\/ return the return value\nreturn ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n}","label":[1,1,0,0]}
{"id":21954,"original_code":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\n    InputSource input = null;\n    final String systemId = source.getSystemId();\n    try {\n      \/\/ Try to get InputSource from SAXSource input\n      if (source instanceof SAXSource) {\n        final SAXSource sax = (SAXSource) source;\n        input = sax.getInputSource();\n        \/\/ Pass the SAX parser to the compiler\n        try {\n          XMLReader reader = sax.getXMLReader();\n          \/*\n           * Fix for bug 24695 According to JAXP 1.2 specification if a\n           * SAXSource is created using a SAX InputSource the Transformer or\n           * TransformerFactory creates a reader via the XMLReaderFactory if\n           * setXMLReader is not used\n           *\/\n          if (reader == null) {\n            try {\n              reader = XMLReaderFactory.createXMLReader();\n            } catch (final Exception e) {\n              try {\n                \/\/ Incase there is an exception thrown\n                \/\/ resort to JAXP\n                final SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setNamespaceAware(true);\n                if (xsltc.isSecureProcessing()) {\n                  try {\n                    parserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                  } catch (final SAXException se) {\n                  }\n                }\n                reader = parserFactory.newSAXParser().getXMLReader();\n              } catch (final ParserConfigurationException pce) {\n                throw new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n              }\n            }\n          }\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\n          xsltc.setXMLReader(reader);\n        } catch (final SAXNotRecognizedException snre) {\n          throw new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n        } catch (final SAXNotSupportedException snse) {\n          throw new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n        } catch (final SAXException se) {\n          throw new TransformerConfigurationException(\"SAXException \", se);\n        }\n      }\n      \/\/ handle DOMSource\n      else if (source instanceof DOMSource) {\n        final DOMSource domsrc = (DOMSource) source;\n        final Document dom = (Document) domsrc.getNode();\n        final DOM2SAX dom2sax = new DOM2SAX(dom);\n        xsltc.setXMLReader(dom2sax);\n        \/\/ Try to get SAX InputSource from DOM Source.\n        input = SAXSource.sourceToInputSource(source);\n        if (input == null) {\n          input = new InputSource(domsrc.getSystemId());\n        }\n      }\n      \/\/ Try to get InputStream or Reader from StreamSource\n      else if (source instanceof StreamSource) {\n        final StreamSource stream = (StreamSource) source;\n        final InputStream istream = stream.getInputStream();\n        final Reader reader = stream.getReader();\n        xsltc.setXMLReader(null); \/\/ Clear old XML reader\n        \/\/ Create InputSource from Reader or InputStream in Source\n        if (istream != null) {\n          input = new InputSource(istream);\n        } else if (reader != null) {\n          input = new InputSource(reader);\n        } else {\n          input = new InputSource(systemId);\n        }\n      } else {\n        final ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\n        throw new TransformerConfigurationException(err.toString());\n      }\n      input.setSystemId(systemId);\n    } catch (final NullPointerException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\n      throw new TransformerConfigurationException(err.toString());\n    } catch (final SecurityException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\n      throw new TransformerConfigurationException(err.toString());\n    }\n    return input;\n  }","code":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\n    InputSource input = null;\n    final String systemId = source.getSystemId();\n    try {\n     \n      if (source instanceof SAXSource) {\n        final SAXSource sax = (SAXSource) source;\n        input = sax.getInputSource();\n       \n        try {\n          XMLReader reader = sax.getXMLReader();\n         \n          if (reader == null) {\n            try {\n              reader = XMLReaderFactory.createXMLReader();\n            } catch (final Exception e) {\n              try {\n               \n               \n                final SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setNamespaceAware(true);\n                if (xsltc.isSecureProcessing()) {\n                  try {\n                    parserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                  } catch (final SAXException se) {\n                  }\n                }\n                reader = parserFactory.newSAXParser().getXMLReader();\n              } catch (final ParserConfigurationException pce) {\n                throw new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n              }\n            }\n          }\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\n          xsltc.setXMLReader(reader);\n        } catch (final SAXNotRecognizedException snre) {\n          throw new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n        } catch (final SAXNotSupportedException snse) {\n          throw new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n        } catch (final SAXException se) {\n          throw new TransformerConfigurationException(\"SAXException \", se);\n        }\n      }\n     \n      else if (source instanceof DOMSource) {\n        final DOMSource domsrc = (DOMSource) source;\n        final Document dom = (Document) domsrc.getNode();\n        final DOM2SAX dom2sax = new DOM2SAX(dom);\n        xsltc.setXMLReader(dom2sax);\n       \n        input = SAXSource.sourceToInputSource(source);\n        if (input == null) {\n          input = new InputSource(domsrc.getSystemId());\n        }\n      }\n     \n      else if (source instanceof StreamSource) {\n        final StreamSource stream = (StreamSource) source;\n        final InputStream istream = stream.getInputStream();\n        final Reader reader = stream.getReader();\n        xsltc.setXMLReader(null);\n       \n        if (istream != null) {\n          input = new InputSource(istream);\n        } else if (reader != null) {\n          input = new InputSource(reader);\n        } else {\n          input = new InputSource(systemId);\n        }\n      } else {\n        final ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\n        throw new TransformerConfigurationException(err.toString());\n      }\n      input.setSystemId(systemId);\n    } catch (final NullPointerException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\n      throw new TransformerConfigurationException(err.toString());\n    } catch (final SecurityException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\n      throw new TransformerConfigurationException(err.toString());\n    }\n    return input;\n  }","cleancode":"public static inputsource getinputsource(xsltc xsltc, source source) throws transformerconfigurationexception { inputsource input = null; final string systemid = source.getsystemid(); try { if (source instanceof saxsource) { final saxsource sax = (saxsource) source; input = sax.getinputsource(); try { xmlreader reader = sax.getxmlreader(); if (reader == null) { try { reader = xmlreaderfactory.createxmlreader(); } catch (final exception e) { try { final saxparserfactory parserfactory = saxparserfactory.newinstance(); parserfactory.setnamespaceaware(true); if (xsltc.issecureprocessing()) { try { parserfactory.setfeature(xmlconstants.feature_secure_processing, true); } catch (final saxexception se) { } } reader = parserfactory.newsaxparser().getxmlreader(); } catch (final parserconfigurationexception pce) { throw new transformerconfigurationexception(\"parserconfigurationexception\", pce); } } } reader.setfeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true); reader.setfeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false); xsltc.setxmlreader(reader); } catch (final saxnotrecognizedexception snre) { throw new transformerconfigurationexception(\"saxnotrecognizedexception \", snre); } catch (final saxnotsupportedexception snse) { throw new transformerconfigurationexception(\"saxnotsupportedexception \", snse); } catch (final saxexception se) { throw new transformerconfigurationexception(\"saxexception \", se); } } else if (source instanceof domsource) { final domsource domsrc = (domsource) source; final document dom = (document) domsrc.getnode(); final dom2sax dom2sax = new dom2sax(dom); xsltc.setxmlreader(dom2sax); input = saxsource.sourcetoinputsource(source); if (input == null) { input = new inputsource(domsrc.getsystemid()); } } else if (source instanceof streamsource) { final streamsource stream = (streamsource) source; final inputstream istream = stream.getinputstream(); final reader reader = stream.getreader(); xsltc.setxmlreader(null); if (istream != null) { input = new inputsource(istream); } else if (reader != null) { input = new inputsource(reader); } else { input = new inputsource(systemid); } } else { final errormsg err = new errormsg(messages.get().jaxpunknownsourceerr()); throw new transformerconfigurationexception(err.tostring()); } input.setsystemid(systemid); } catch (final nullpointerexception e) { final errormsg err = new errormsg(messages.get().jaxpnosourceerr(\"transformerfactory.newtemplates()\")); throw new transformerconfigurationexception(err.tostring()); } catch (final securityexception e) { final errormsg err = new errormsg(messages.get().fileaccesserr(systemid), -1); throw new transformerconfigurationexception(err.tostring()); } return input; }","comment":"\/** * creates a sax2 inputsource object from a trax source object * * @param xsltc * todo * @param source * todo * @return todo * @throws transformerconfigurationexception * todo *\/\n\/\/ try to get inputsource from saxsource input\n\/\/ pass the sax parser to the compiler\n\/* * fix for bug 24695 according to jaxp 1.2 specification if a * saxsource is created using a sax inputsource the transformer or * transformerfactory creates a reader via the xmlreaderfactory if * setxmlreader is not used *\/\n\/\/ incase there is an exception thrown \/\/ resort to jaxp\n\/\/ handle domsource\n\/\/ try to get sax inputsource from dom source.\n\/\/ try to get inputstream or reader from streamsource\n\/\/ clear old xml reader\n\/\/ create inputsource from reader or inputstream in source","repo":"lyca\/lyca-xslt","code_context_2":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\nthrow new TransformerConfigurationException(err.toString());\n} catch (final SecurityException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\nthrow new TransformerConfigurationException(err.toString());\n}\nreturn input;\n}\n\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\n\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\n\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\n\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\n\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\n\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\n\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\n\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);","code_context_10":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\nthrow new TransformerConfigurationException(err.toString());\n} catch (final SecurityException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\nthrow new TransformerConfigurationException(err.toString());\n}\nreturn input;\n}\n\npublic static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n\npublic static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\n\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\n\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\n\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\n\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\n\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());","code_context_20":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\nthrow new TransformerConfigurationException(err.toString());\n} catch (final SecurityException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\nthrow new TransformerConfigurationException(err.toString());\n}\nreturn input;\n}\n\npublic static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\npublic static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\npublic static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\nInputSource input = null;\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n\nfinal String systemId = source.getSystemId();\ntry {\n\/\/ Try to get InputSource from SAXSource input\nif (source instanceof SAXSource) {\nfinal SAXSource sax = (SAXSource) source;\ninput = sax.getInputSource();\n\/\/ Pass the SAX parser to the compiler\ntry {\nXMLReader reader = sax.getXMLReader();\n\/*\n* Fix for bug 24695 According to JAXP 1.2 specification if a\n* SAXSource is created using a SAX InputSource the Transformer or\n* TransformerFactory creates a reader via the XMLReaderFactory if\n* setXMLReader is not used\n*\/\nif (reader == null) {\ntry {\nreader = XMLReaderFactory.createXMLReader();\n} catch (final Exception e) {\ntry {\n\/\/ Incase there is an exception thrown\n\/\/ resort to JAXP\nfinal SAXParserFactory parserFactory = SAXParserFactory.newInstance();\nparserFactory.setNamespaceAware(true);\nif (xsltc.isSecureProcessing()) {\ntry {\nparserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\n\n} catch (final SAXException se) {\n}\n}\nreader = parserFactory.newSAXParser().getXMLReader();\n} catch (final ParserConfigurationException pce) {\nthrow new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n\n}\n}\n}\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\nreader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\nxsltc.setXMLReader(reader);\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\n\n} catch (final SAXNotRecognizedException snre) {\nthrow new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n} catch (final SAXNotSupportedException snse) {\nthrow new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n} catch (final SAXException se) {\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\n\nthrow new TransformerConfigurationException(\"SAXException \", se);\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\nthrow new TransformerConfigurationException(err.toString());\n} catch (final SecurityException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\nthrow new TransformerConfigurationException(err.toString());\n}\n\n}\n}\n\/\/ handle DOMSource\nelse if (source instanceof DOMSource) {\nfinal DOMSource domsrc = (DOMSource) source;\nfinal Document dom = (Document) domsrc.getNode();\nfinal DOM2SAX dom2sax = new DOM2SAX(dom);\nxsltc.setXMLReader(dom2sax);\n\/\/ Try to get SAX InputSource from DOM Source.\ninput = SAXSource.sourceToInputSource(source);\nif (input == null) {\ninput = new InputSource(domsrc.getSystemId());\n}\n}\n\/\/ Try to get InputStream or Reader from StreamSource\nelse if (source instanceof StreamSource) {\nfinal StreamSource stream = (StreamSource) source;\nfinal InputStream istream = stream.getInputStream();\nfinal Reader reader = stream.getReader();\nxsltc.setXMLReader(null); \/\/ Clear old XML reader\n\/\/ Create InputSource from Reader or InputStream in Source\nif (istream != null) {\ninput = new InputSource(istream);\n} else if (reader != null) {\ninput = new InputSource(reader);\n} else {\ninput = new InputSource(systemId);\n}\n} else {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\nthrow new TransformerConfigurationException(err.toString());\n}\ninput.setSystemId(systemId);\n} catch (final NullPointerException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\nthrow new TransformerConfigurationException(err.toString());\n} catch (final SecurityException e) {\nfinal ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\nthrow new TransformerConfigurationException(err.toString());\n}\nreturn input;","label":[0,0,1,0]}
{"id":30244,"original_code":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\n        switch (code) {\n            case UP:\n                move(new Point(-1, 0),\"\");\n                break;\n            case RIGHT:\n                move(new Point(0, 1),\"\");\n                break;\n            case DOWN:\n                move(new Point(1, 0),\"\");\n                break;\n            case LEFT:\n                move(new Point(0, -1),\"\");\n                break;\n            default:\n                \/\/ TODO: implement something funny.\n        }\n        if (isDebugActive()) {\n            System.out.println(code);\n        }\n    }","code":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\n        switch (code) {\n            case UP:\n                move(new Point(-1, 0),\"\");\n                break;\n            case RIGHT:\n                move(new Point(0, 1),\"\");\n                break;\n            case DOWN:\n                move(new Point(1, 0),\"\");\n                break;\n            case LEFT:\n                move(new Point(0, -1),\"\");\n                break;\n            default:\n               \n        }\n        if (isDebugActive()) {\n            System.out.println(code);\n        }\n    }","cleancode":"public void handlekey(keycode code) throws ioexception, classnotfoundexception { switch (code) { case up: move(new point(-1, 0),\"\"); break; case right: move(new point(0, 1),\"\"); break; case down: move(new point(1, 0),\"\"); break; case left: move(new point(0, -1),\"\"); break; default: } if (isdebugactive()) { system.out.println(code); } }","comment":"\/** * this method handle the keyboard input of the player. * it handles keeper moves. * @param code * @throws ioexception * @throws classnotfoundexception *\/\n\/\/ todo: implement something funny.","repo":"krisiney\/SOKOBANFX-DMS-2020","code_context_2":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\nswitch (code) {\ncase UP:\nmove(new Point(-1, 0),\"\");\nbreak;\ncase RIGHT:\nmove(new Point(0, 1),\"\");\nbreak;\ncase DOWN:\nmove(new Point(1, 0),\"\");\nbreak;\ncase LEFT:\nmove(new Point(0, -1),\"\");\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {\nSystem.out.println(code);\n}\n}\n\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {","code_context_10":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\nswitch (code) {\ncase UP:\nmove(new Point(-1, 0),\"\");\nbreak;\ncase RIGHT:\nmove(new Point(0, 1),\"\");\nbreak;\ncase DOWN:\nmove(new Point(1, 0),\"\");\nbreak;\ncase LEFT:\nmove(new Point(0, -1),\"\");\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {\nSystem.out.println(code);\n}\n}\n\ncase RIGHT:\nmove(new Point(0, 1),\"\");\nbreak;\ncase DOWN:\nmove(new Point(1, 0),\"\");\nbreak;\ncase LEFT:\nmove(new Point(0, -1),\"\");\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {\nSystem.out.println(code);\n}\n}","code_context_20":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\nswitch (code) {\ncase UP:\nmove(new Point(-1, 0),\"\");\nbreak;\ncase RIGHT:\nmove(new Point(0, 1),\"\");\nbreak;\ncase DOWN:\nmove(new Point(1, 0),\"\");\nbreak;\ncase LEFT:\nmove(new Point(0, -1),\"\");\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {\nSystem.out.println(code);\n}\n}\n\npublic void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\nswitch (code) {\ncase UP:\nmove(new Point(-1, 0),\"\");\nbreak;\ncase RIGHT:\nmove(new Point(0, 1),\"\");\nbreak;\ncase DOWN:\nmove(new Point(1, 0),\"\");\nbreak;\ncase LEFT:\nmove(new Point(0, -1),\"\");\nbreak;\ndefault:\n\/\/ TODO: implement something funny.\n}\nif (isDebugActive()) {\nSystem.out.println(code);\n}\n}","label":[0,1,0,0]}
{"id":22278,"original_code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"net onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n            if (subscriber != null && !subscriber.isUnsubscribed()) {\n                subscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n            }\n        }","code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"net onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n            if (subscriber != null && !subscriber.isUnsubscribed()) {\n                subscriber.onNext(o)","cleancode":"@override public void onnext(t o) { if (debug) log.i(tag, \"net onnext o:\" + o); observablewrapper.setdata(o); logthread(\"\"); if (debug) log.e(tag, \" check subscriber :\" + subscriber + \" isunsubscribed:\" + subscriber.isunsubscribed()); if (subscriber != null && !subscriber.isunsubscribed()) { subscriber.onnext(o)","comment":"\/\/ fixme: issue a:\u5916\u9762\u5982\u679cobservableon \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onnext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86oncomplete\u6216\u8005onerror,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onnext\u6ca1\u6709\u88ab\u8c03\u7528","repo":"ming1991\/mingop","code_context_2":"if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n}","code_context_10":"@Override\npublic void onNext(T o) {\nif (debug) Log.i(TAG, \"net onNext o:\" + o);\nobservableWrapper.setData(o);\nlogThread(\"\");\nif (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n}","code_context_20":"@Override\npublic void onNext(T o) {\nif (debug) Log.i(TAG, \"net onNext o:\" + o);\nobservableWrapper.setData(o);\nlogThread(\"\");\nif (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n}","label":[0,0,1,0]}
{"id":22279,"original_code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"cache onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (netLatch.getCount() > 0) {\n                if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n                if (subscriber != null && !subscriber.isUnsubscribed()) {\n                    subscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n                }\n            } else {\n                if (debug) Log.e(TAG, \"net result had been load,so cache is not need to load\");\n            }\n        }","code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"cache onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (netLatch.getCount() > 0) {\n                if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n                if (subscriber != null && !subscriber.isUnsubscribed()) {\n                    subscriber.onNext(o)\"net result had been load,so cache is not need to load\");\n            }\n        }","cleancode":"@override public void onnext(t o) { if (debug) log.i(tag, \"cache onnext o:\" + o); observablewrapper.setdata(o); logthread(\"\"); if (netlatch.getcount() > 0) { if (debug) log.e(tag, \" check subscriber :\" + subscriber + \" isunsubscribed:\" + subscriber.isunsubscribed()); if (subscriber != null && !subscriber.isunsubscribed()) { subscriber.onnext(o)\"net result had been load,so cache is not need to load\"); } }","comment":"\/\/ fixme: issue a:\u5916\u9762\u5982\u679cobservableon \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onnext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86oncomplete\u6216\u8005onerror,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onnext\u6ca1\u6709\u88ab\u8c03\u7528","repo":"ming1991\/mingop","code_context_2":"if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n} else {","code_context_10":"@Override\npublic void onNext(T o) {\nif (debug) Log.i(TAG, \"cache onNext o:\" + o);\nobservableWrapper.setData(o);\nlogThread(\"\");\nif (netLatch.getCount() > 0) {\nif (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n} else {\nif (debug) Log.e(TAG, \"net result had been load,so cache is not need to load\");\n}\n}","code_context_20":"@Override\npublic void onNext(T o) {\nif (debug) Log.i(TAG, \"cache onNext o:\" + o);\nobservableWrapper.setData(o);\nlogThread(\"\");\nif (netLatch.getCount() > 0) {\nif (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\nif (subscriber != null && !subscriber.isUnsubscribed()) {\nsubscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n}\n} else {\nif (debug) Log.e(TAG, \"net result had been load,so cache is not need to load\");\n}\n}","label":[0,0,1,0]}
{"id":14123,"original_code":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","code":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","cleancode":"public abstract iterable<tuple2<k, v>> docall(final t t) throws exception;","comment":"\/** * do work here * * @param v1 * @return *\/","repo":"lordjoe\/SparkAccumulators","code_context_2":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","code_context_10":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","code_context_20":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","label":[0,1,0,0]}
{"id":22556,"original_code":"private boolean updateAddressFilter(String filter)\n\t{\n\t\tString[] pieces = filter.split(\"\/\");\n\t\tif(pieces.length != 2)\n\t\t{\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tInetAddress new_filter_address;\n\t\tInetAddress new_filter_mask;\n\t\tboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\n\t\ttry {\n\t\t\tnew_filter_address = InetAddress.getByName(pieces[0]);\n\t\t\t\/\/ compute the subnet mask address\n\t\t\tbyte[] byte_mask = new byte[4];\n\t\t\tint slash = Integer.parseInt(pieces[1]);\n\t\t\t\/\/ compute the mask address \n\t\t\t\/\/ there is probably a way easier way to do this\n\t\t\tfor (int j=0; slash-- > 0; j++) {\n\t\t\t\tif (j<8)  byte_mask[0] += Math.pow(2,j);\n\t\t\t\tif (j<16) byte_mask[1] += Math.pow(2,j-8);\n\t\t\t\tif (j<24) byte_mask[2] += Math.pow(2,j-16);\n\t\t\t\tif (j<32) byte_mask[3] += Math.pow(2,j-24);\n\t\t\t}\n\t\t\tnew_filter_mask = InetAddress.getByAddress(byte_mask);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tip_filter_enabled = new_filter_enabled;\n\t\tfilter_address = new_filter_address;\n\t\tfilter_mask = new_filter_mask;\n\t\tfireExpressionChangedEvent();\n\t\t\/\/TODO: make data listen to this so that we don't need this call\n\t\tdata.setFilterPredicate(this);\n\t\tSystem.out.println(\"Updating filter succeeded!\");\n\t\tsearchTextField.setBackground(Color.WHITE);\n\t\treturn true;\n\t}","code":"private boolean updateAddressFilter(String filter)\n\t{\n\t\tString[] pieces = filter.split(\"\/\");\n\t\tif(pieces.length != 2)\n\t\t{\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tInetAddress new_filter_address;\n\t\tInetAddress new_filter_mask;\n\t\tboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\n\t\ttry {\n\t\t\tnew_filter_address = InetAddress.getByName(pieces[0]);\n\t\t\n\t\t\tbyte[] byte_mask = new byte[4];\n\t\t\tint slash = Integer.parseInt(pieces[1]);\n\t\t\n\t\t\n\t\t\tfor (int j=0; slash-- > 0; j++) {\n\t\t\t\tif (j<8)  byte_mask[0] += Math.pow(2,j);\n\t\t\t\tif (j<16) byte_mask[1] += Math.pow(2,j-8);\n\t\t\t\tif (j<24) byte_mask[2] += Math.pow(2,j-16);\n\t\t\t\tif (j<32) byte_mask[3] += Math.pow(2,j-24);\n\t\t\t}\n\t\t\tnew_filter_mask = InetAddress.getByAddress(byte_mask);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tip_filter_enabled = new_filter_enabled;\n\t\tfilter_address = new_filter_address;\n\t\tfilter_mask = new_filter_mask;\n\t\tfireExpressionChangedEvent();\n\t\n\t\tdata.setFilterPredicate(this);\n\t\tSystem.out.println(\"Updating filter succeeded!\");\n\t\tsearchTextField.setBackground(Color.WHITE);\n\t\treturn true;\n\t}","cleancode":"private boolean updateaddressfilter(string filter) { string[] pieces = filter.split(\"\/\"); if(pieces.length != 2) { searchtextfield.setbackground(color.red); return false; } inetaddress new_filter_address; inetaddress new_filter_mask; boolean new_filter_enabled = !(pieces[1].equals(\"0\")); try { new_filter_address = inetaddress.getbyname(pieces[0]); byte[] byte_mask = new byte[4]; int slash = integer.parseint(pieces[1]); for (int j=0; slash-- > 0; j++) { if (j<8) byte_mask[0] += math.pow(2,j); if (j<16) byte_mask[1] += math.pow(2,j-8); if (j<24) byte_mask[2] += math.pow(2,j-16); if (j<32) byte_mask[3] += math.pow(2,j-24); } new_filter_mask = inetaddress.getbyaddress(byte_mask); } catch (exception e) { searchtextfield.setbackground(color.red); return false; } ip_filter_enabled = new_filter_enabled; filter_address = new_filter_address; filter_mask = new_filter_mask; fireexpressionchangedevent(); data.setfilterpredicate(this); system.out.println(\"updating filter succeeded!\"); searchtextfield.setbackground(color.white); return true; }","comment":"\/\/ compute the subnet mask address\n\/\/ compute the mask address \/\/ there is probably a way easier way to do this\n\/\/todo: make data listen to this so that we don't need this call","repo":"kylekyle\/netgrok","code_context_2":"try {\nnew_filter_address = InetAddress.getByName(pieces[0]);\n\/\/ compute the subnet mask address\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\n\nfilter_mask = new_filter_mask;\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\nSystem.out.println(\"Updating filter succeeded!\");","code_context_10":"if(pieces.length != 2)\n{\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nInetAddress new_filter_address;\nInetAddress new_filter_mask;\nboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\ntry {\nnew_filter_address = InetAddress.getByName(pieces[0]);\n\/\/ compute the subnet mask address\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\nif (j<16) byte_mask[1] += Math.pow(2,j-8);\nif (j<24) byte_mask[2] += Math.pow(2,j-16);\nif (j<32) byte_mask[3] += Math.pow(2,j-24);\n}\n\nreturn false;\n}\nInetAddress new_filter_address;\nInetAddress new_filter_mask;\nboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\ntry {\nnew_filter_address = InetAddress.getByName(pieces[0]);\n\/\/ compute the subnet mask address\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\nif (j<16) byte_mask[1] += Math.pow(2,j-8);\nif (j<24) byte_mask[2] += Math.pow(2,j-16);\nif (j<32) byte_mask[3] += Math.pow(2,j-24);\n}\nnew_filter_mask = InetAddress.getByAddress(byte_mask);\n}\ncatch (Exception e) {\nsearchTextField.setBackground(Color.RED);\n\nnew_filter_mask = InetAddress.getByAddress(byte_mask);\n}\ncatch (Exception e) {\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nip_filter_enabled = new_filter_enabled;\nfilter_address = new_filter_address;\nfilter_mask = new_filter_mask;\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\nSystem.out.println(\"Updating filter succeeded!\");\nsearchTextField.setBackground(Color.WHITE);\nreturn true;\n}","code_context_20":"private boolean updateAddressFilter(String filter)\n{\nString[] pieces = filter.split(\"\/\");\nif(pieces.length != 2)\n{\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nInetAddress new_filter_address;\nInetAddress new_filter_mask;\nboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\ntry {\nnew_filter_address = InetAddress.getByName(pieces[0]);\n\/\/ compute the subnet mask address\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\nif (j<16) byte_mask[1] += Math.pow(2,j-8);\nif (j<24) byte_mask[2] += Math.pow(2,j-16);\nif (j<32) byte_mask[3] += Math.pow(2,j-24);\n}\nnew_filter_mask = InetAddress.getByAddress(byte_mask);\n}\ncatch (Exception e) {\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nip_filter_enabled = new_filter_enabled;\nfilter_address = new_filter_address;\nfilter_mask = new_filter_mask;\nfireExpressionChangedEvent();\n\nprivate boolean updateAddressFilter(String filter)\n{\nString[] pieces = filter.split(\"\/\");\nif(pieces.length != 2)\n{\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nInetAddress new_filter_address;\nInetAddress new_filter_mask;\nboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\ntry {\nnew_filter_address = InetAddress.getByName(pieces[0]);\n\/\/ compute the subnet mask address\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\nif (j<16) byte_mask[1] += Math.pow(2,j-8);\nif (j<24) byte_mask[2] += Math.pow(2,j-16);\nif (j<32) byte_mask[3] += Math.pow(2,j-24);\n}\nnew_filter_mask = InetAddress.getByAddress(byte_mask);\n}\ncatch (Exception e) {\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nip_filter_enabled = new_filter_enabled;\nfilter_address = new_filter_address;\nfilter_mask = new_filter_mask;\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\nSystem.out.println(\"Updating filter succeeded!\");\nsearchTextField.setBackground(Color.WHITE);\n\nbyte[] byte_mask = new byte[4];\nint slash = Integer.parseInt(pieces[1]);\n\/\/ compute the mask address\n\/\/ there is probably a way easier way to do this\nfor (int j=0; slash-- > 0; j++) {\nif (j<8) byte_mask[0] += Math.pow(2,j);\nif (j<16) byte_mask[1] += Math.pow(2,j-8);\nif (j<24) byte_mask[2] += Math.pow(2,j-16);\nif (j<32) byte_mask[3] += Math.pow(2,j-24);\n}\nnew_filter_mask = InetAddress.getByAddress(byte_mask);\n}\ncatch (Exception e) {\nsearchTextField.setBackground(Color.RED);\nreturn false;\n}\nip_filter_enabled = new_filter_enabled;\nfilter_address = new_filter_address;\nfilter_mask = new_filter_mask;\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\nSystem.out.println(\"Updating filter succeeded!\");\nsearchTextField.setBackground(Color.WHITE);\nreturn true;\n}","label":[1,0,0,0]}
{"id":22557,"original_code":"private void updateRanges()\n\t{\n\t\t\/\/ get the minimum degree rank\n\t\tmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\n\t\tmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\n\t\tmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\n\t\tmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\n\t\tfireExpressionChangedEvent();\n\t\t\/\/TODO: make data listen to this so that we don't need this call\n\t\tdata.setFilterPredicate(this);\n\t}","code":"private void updateRanges()\n\t{\n\t\n\t\tmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\n\t\tmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\n\t\tmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\n\t\tmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\n\t\tfireExpressionChangedEvent();\n\t\n\t\tdata.setFilterPredicate(this);\n\t}","cleancode":"private void updateranges() { min_degree_rank = (float)(degreerangeslider.getlowvalue() - degreerangeslider.getminimum()) \/ (float)(degreerangeslider.getmaximum() - degreerangeslider.getminimum()); max_degree_rank = (float)(degreerangeslider.gethighvalue() - degreerangeslider.getminimum()) \/ (float)(degreerangeslider.getmaximum() - degreerangeslider.getminimum()); min_bandwidth_rank = (float)(bandwidthrangeslider.getlowvalue() - bandwidthrangeslider.getminimum()) \/ (float)(bandwidthrangeslider.getmaximum() - bandwidthrangeslider.getminimum()); max_bandwidth_rank = (float)(bandwidthrangeslider.gethighvalue() - bandwidthrangeslider.getminimum()) \/ (float)(bandwidthrangeslider.getmaximum() - bandwidthrangeslider.getminimum()); min_degree_enabled = degreerangeslider.getlowvalue() != degreerangeslider.getminimum(); max_degree_enabled = degreerangeslider.gethighvalue() != degreerangeslider.getmaximum(); min_bandwidth_enabled = bandwidthrangeslider.getlowvalue() != bandwidthrangeslider.getminimum(); max_bandwidth_enabled = bandwidthrangeslider.gethighvalue() != bandwidthrangeslider.getmaximum(); fireexpressionchangedevent(); data.setfilterpredicate(this); }","comment":"\/\/ get the minimum degree rank\n\/\/todo: make data listen to this so that we don't need this call","repo":"kylekyle\/netgrok","code_context_2":"private void updateRanges()\n{\n\/\/ get the minimum degree rank\nmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\nmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\n}","code_context_10":"private void updateRanges()\n{\n\/\/ get the minimum degree rank\nmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\nmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\n\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\nmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\nmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\nmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\n}","code_context_20":"private void updateRanges()\n{\n\/\/ get the minimum degree rank\nmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\nmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\nmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\nmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\n}\n\nprivate void updateRanges()\n{\n\/\/ get the minimum degree rank\nmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/\n(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\nmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/\n(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\nmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\nmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\nmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\nmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\nfireExpressionChangedEvent();\n\/\/TODO: make data listen to this so that we don't need this call\ndata.setFilterPredicate(this);\n}","label":[1,0,0,0]}
{"id":30751,"original_code":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\n        for (ConstantInfo constant : constantPool) {\n            if (constant instanceof ConstantInfo.Class) {\n                ConstantInfo.Class info = (ConstantInfo.Class)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Fieldref) {\n                ConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.Methodref) {\n                ConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.InterfaceMethodref) {\n                ConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.String) {\n                ConstantInfo.String info = (ConstantInfo.String)constant;\n                info.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Integer\n                    || constant instanceof ConstantInfo.Float\n                    || constant instanceof ConstantInfo.Long\n                    || constant instanceof ConstantInfo.Double) {\n                \/\/ not needed\n            } else if (constant instanceof ConstantInfo.NameAndType) {\n                ConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n                info.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Utf8) {\n                \/\/ not needed\n            } else if (constant instanceof ConstantInfo.MethodHandle\n                    || constant instanceof ConstantInfo.MethodType\n                    || constant instanceof ConstantInfo.InvokeDynamic) {\n                \/\/ not used yet\n            } else if (constant != null) { \/\/ Long\/Double may leave create a blank space\n                throw new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n            }\n        }\n    }","code":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\n        for (ConstantInfo constant : constantPool) {\n            if (constant instanceof ConstantInfo.Class) {\n                ConstantInfo.Class info = (ConstantInfo.Class)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Fieldref) {\n                ConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.Methodref) {\n                ConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.InterfaceMethodref) {\n                ConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.String) {\n                ConstantInfo.String info = (ConstantInfo.String)constant;\n                info.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Integer\n                    || constant instanceof ConstantInfo.Float\n                    || constant instanceof ConstantInfo.Long\n                    || constant instanceof ConstantInfo.Double) {\n               \n            } else if (constant instanceof ConstantInfo.NameAndType) {\n                ConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n                info.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Utf8) {\n               \n            } else if (constant instanceof ConstantInfo.MethodHandle\n                    || constant instanceof ConstantInfo.MethodType\n                    || constant instanceof ConstantInfo.InvokeDynamic) {\n               \n            } else if (constant != null) {\n                throw new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n            }\n        }\n    }","cleancode":"private void resolveconstantpoolreferences(constantinfo[] constantpool) { for (constantinfo constant : constantpool) { if (constant instanceof constantinfo.class) { constantinfo.class info = (constantinfo.class)constant; info.setname(((constantinfo.utf8)constantpool[info.getnameindex() - 1]).getstring()); } else if (constant instanceof constantinfo.fieldref) { constantinfo.fieldref info = (constantinfo.fieldref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.methodref) { constantinfo.methodref info = (constantinfo.methodref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.interfacemethodref) { constantinfo.interfacemethodref info = (constantinfo.interfacemethodref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.string) { constantinfo.string info = (constantinfo.string)constant; info.setstring(((constantinfo.utf8)constantpool[info.getstringindex() - 1]).getstring()); } else if (constant instanceof constantinfo.integer || constant instanceof constantinfo.float || constant instanceof constantinfo.long || constant instanceof constantinfo.double) { } else if (constant instanceof constantinfo.nameandtype) { constantinfo.nameandtype info = (constantinfo.nameandtype)constant; info.setname(((constantinfo.utf8)constantpool[info.getnameindex() - 1]).getstring()); info.setdescriptor(((constantinfo.utf8)constantpool[info.getdescriptorindex() - 1]).getstring()); } else if (constant instanceof constantinfo.utf8) { } else if (constant instanceof constantinfo.methodhandle || constant instanceof constantinfo.methodtype || constant instanceof constantinfo.invokedynamic) { } else if (constant != null) { throw new unsupportedoperationexception(\"unhandled constanttype: \" + constant); } } }","comment":"\/\/ resolve reference to constantpool by index in constants\n\/\/ not needed\n\/\/ not needed\n\/\/ not used yet\n\/\/ long\/double may leave create a blank space","repo":"k0kubun\/jjvm","code_context_2":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\nfor (ConstantInfo constant : constantPool) {\nif (constant instanceof ConstantInfo.Class) {\nConstantInfo.Class info = (ConstantInfo.Class)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Fieldref) {\nConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.Methodref) {\nConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.InterfaceMethodref) {\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}","code_context_10":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\nfor (ConstantInfo constant : constantPool) {\nif (constant instanceof ConstantInfo.Class) {\nConstantInfo.Class info = (ConstantInfo.Class)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Fieldref) {\nConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.Methodref) {\nConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.InterfaceMethodref) {\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}","code_context_20":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\nfor (ConstantInfo constant : constantPool) {\nif (constant instanceof ConstantInfo.Class) {\nConstantInfo.Class info = (ConstantInfo.Class)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Fieldref) {\nConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.Methodref) {\nConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.InterfaceMethodref) {\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Fieldref) {\nConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.Methodref) {\nConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.InterfaceMethodref) {\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Fieldref) {\nConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.Methodref) {\nConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.InterfaceMethodref) {\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\nConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}\n\ninfo.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\ninfo.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n} else if (constant instanceof ConstantInfo.String) {\nConstantInfo.String info = (ConstantInfo.String)constant;\ninfo.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Integer\n|| constant instanceof ConstantInfo.Float\n|| constant instanceof ConstantInfo.Long\n|| constant instanceof ConstantInfo.Double) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.NameAndType) {\nConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\ninfo.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\ninfo.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n} else if (constant instanceof ConstantInfo.Utf8) {\n\/\/ not needed\n} else if (constant instanceof ConstantInfo.MethodHandle\n|| constant instanceof ConstantInfo.MethodType\n|| constant instanceof ConstantInfo.InvokeDynamic) {\n\/\/ not used yet\n} else if (constant != null) { \/\/ Long\/Double may leave create a blank space\nthrow new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n}\n}\n}","label":[1,0,0,0]}
{"id":22840,"original_code":"public static void send(final InternalDistributedMember recipient, final int processorId,\n        final DM dm, Set keys) throws ForceReattemptException {\n      Assert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\n      final int numSeries = 1;\n      final int seriesNum = 0;\n      \/\/ chunkEntries returns false if didn't finish\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n      }\n      try {\n        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\n          new ObjectIntProcedure() {\n            int msgNum = 0;\n            boolean last = false;\n            \/**\n              * @param a byte[] chunk\n              * @param b positive if last chunk\n              * @return true to continue to next chunk\n              *\/\n            public boolean executeWith(Object a, int b) {\n\/\/              if (this.last)\n\/\/                throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\n              HeapDataOutputStream chunk = (HeapDataOutputStream)a;\n              this.last = b > 0;\n              try {\n                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\n                return okay;\n              }\n              catch (CancelException e) {\n                return false;\n              }\n            }\n          });\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n        }\n      }\n      catch (IOException io) {\n        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n      }\n      \/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n      \/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n    }","code":"public static void send(final InternalDistributedMember recipient, final int processorId,\n        final DM dm, Set keys) throws ForceReattemptException {\n      Assert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\n      final int numSeries = 1;\n      final int seriesNum = 0;\n     \n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n      }\n      try {\n        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\n          new ObjectIntProcedure() {\n            int msgNum = 0;\n            boolean last = false;\n           \n            public boolean executeWith(Object a, int b) {\n              HeapDataOutputStream chunk = (HeapDataOutputStream)a;\n              this.last = b > 0;\n              try {\n                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\n                return okay;\n              }\n              catch (CancelException e) {\n                return false;\n              }\n            }\n          });\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n        }\n      }\n      catch (IOException io) {\n        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n      }\n     \n     \n    }","cleancode":"public static void send(final internaldistributedmember recipient, final int processorid, final dm dm, set keys) throws forcereattemptexception { assert.asserttrue(recipient != null, \"fetchkeysreplymessage null reply message\"); final int numseries = 1; final int seriesnum = 0; if (logger.isdebugenabled()) { logger.debug(\"starting pr keys chunking for {} kets to member {}\", keys.size(), recipient); } try { boolean finished = chunkset(recipient, keys, initialimageoperation.chunk_size_in_bytes, false, new objectintprocedure() { int msgnum = 0; boolean last = false; public boolean executewith(object a, int b) { heapdataoutputstream chunk = (heapdataoutputstream)a; this.last = b > 0; try { boolean okay = sendchunk(recipient, processorid, dm, chunk, seriesnum, msgnum++, numseries, this.last); return okay; } catch (cancelexception e) { return false; } } }); if (logger.isdebugenabled()) { logger.debug(\"{} pr keys chunking\", (finished?\"finished\" : \"did not complete\")); } } catch (ioexception io) { throw new forcereattemptexception(localizedstrings.fetchkeysmessage_unable_to_send_response_to_fetch_keys_request.tolocalizedstring(), io); } }","comment":"\/** * send an ack * @throws forcereattemptexception if the peer is no longer available *\/\n\/\/ chunkentries returns false if didn't finish\n\/** * @param a byte[] chunk * @param b positive if last chunk * @return true to continue to next chunk *\/\n\/\/ if (this.last) \/\/ throw new internalgemfireerror(localizedstrings.fetchkeysmessage_already_processed_last_chunk.tolocalizedstring());\n\/\/ todo [bruce] pass a reference to the cache or region down here so we can do this test \/\/assert.asserttrue(!cache is closed, \"chunking interrupted but cache is still open\");","repo":"karensmolermiller\/incubator-geode","code_context_2":"public static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}\n\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\n\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}","code_context_10":"public static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}\n\npublic static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\n\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}","code_context_20":"public static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}\n\npublic static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\n\npublic static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n\npublic static void send(final InternalDistributedMember recipient, final int processorId,\nfinal DM dm, Set keys) throws ForceReattemptException {\nAssert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\nfinal int numSeries = 1;\nfinal int seriesNum = 0;\n\/\/ chunkEntries returns false if didn't finish\nif (logger.isDebugEnabled()) {\nlogger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n}\ntry {\nboolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\nnew ObjectIntProcedure() {\nint msgNum = 0;\nboolean last = false;\n\/**\n* @param a byte[] chunk\n* @param b positive if last chunk\n* @return true to continue to next chunk\n*\/\npublic boolean executeWith(Object a, int b) {\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n\n\/\/ if (this.last)\n\/\/ throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\nHeapDataOutputStream chunk = (HeapDataOutputStream)a;\nthis.last = b > 0;\ntry {\nboolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\nreturn okay;\n}\ncatch (CancelException e) {\nreturn false;\n}\n}\n});\nif (logger.isDebugEnabled()) {\nlogger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n}\n}\ncatch (IOException io) {\nthrow new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n}\n\/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n\/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n}","label":[0,1,0,0]}
{"id":14744,"original_code":"@Override\n\t    void processOFMessage(ControllerChannelHandler h, OFMessage m)\n\t\t    throws IOException {\n\t\tswitch (m.getType()) {\n\t\t    case HELLO:\n\t\t\tprocessOFHello(h, (OFHello) m);\n\t\t\tbreak;    \n\t\t    case ECHO_REPLY:\n\t\t\tbreak;\n\t\t    case ECHO_REQUEST:\n\t\t\tprocessOFEchoRequest(h, (OFEchoRequest) m);\n\t\t\tbreak;\n\t\t    case FEATURES_REQUEST:\n\t\t\tprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\n\t\t\tbreak;\n\t\t    case BARRIER_REQUEST:\n\t\t\t\/\/TODO: actually implement barrier contract\n\t\t\tOFBarrierReply breply = new OFBarrierReply();\n\t\t\tbreply.setXid(m.getXid());\n\t\t\th.channel.write(Collections.singletonList(breply));\n\t\t\tbreak;\n\t\t    case SET_CONFIG:\n\t\t    case ERROR:\n\t\t    case PACKET_OUT:\n\t\t    case PORT_MOD:\n\t\t    case QUEUE_GET_CONFIG_REQUEST:\n\t\t    case STATS_REQUEST:    \n\t\t    case FLOW_MOD:\n\t\t    case GET_CONFIG_REQUEST:\n\t\t\th.sw.handleIO(m);\n\t\t\tbreak;\n\t\t    case VENDOR:\n\t\t\tunhandledMessageReceived(h, m);\n\t\t\tbreak;\n\t\t    case FEATURES_REPLY:\n\t\t    case FLOW_REMOVED:\n\t\t    case PACKET_IN:\n\t\t    case PORT_STATUS:\n\t\t    case BARRIER_REPLY:\n\t\t    case GET_CONFIG_REPLY:\n\t\t    case STATS_REPLY:\n\t\t    case QUEUE_GET_CONFIG_REPLY:\n\t\t\tillegalMessageReceived(h, m);\n\t\t\tbreak;\n\t\t}\n\t    }","code":"@Override\n\t    void processOFMessage(ControllerChannelHandler h, OFMessage m)\n\t\t    throws IOException {\n\t\tswitch (m.getType()) {\n\t\t    case HELLO:\n\t\t\tprocessOFHello(h, (OFHello) m);\n\t\t\tbreak;    \n\t\t    case ECHO_REPLY:\n\t\t\tbreak;\n\t\t    case ECHO_REQUEST:\n\t\t\tprocessOFEchoRequest(h, (OFEchoRequest) m);\n\t\t\tbreak;\n\t\t    case FEATURES_REQUEST:\n\t\t\tprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\n\t\t\tbreak;\n\t\t    case BARRIER_REQUEST:\n\t\t\n\t\t\tOFBarrierReply breply = new OFBarrierReply();\n\t\t\tbreply.setXid(m.getXid());\n\t\t\th.channel.write(Collections.singletonList(breply));\n\t\t\tbreak;\n\t\t    case SET_CONFIG:\n\t\t    case ERROR:\n\t\t    case PACKET_OUT:\n\t\t    case PORT_MOD:\n\t\t    case QUEUE_GET_CONFIG_REQUEST:\n\t\t    case STATS_REQUEST:    \n\t\t    case FLOW_MOD:\n\t\t    case GET_CONFIG_REQUEST:\n\t\t\th.sw.handleIO(m);\n\t\t\tbreak;\n\t\t    case VENDOR:\n\t\t\tunhandledMessageReceived(h, m);\n\t\t\tbreak;\n\t\t    case FEATURES_REPLY:\n\t\t    case FLOW_REMOVED:\n\t\t    case PACKET_IN:\n\t\t    case PORT_STATUS:\n\t\t    case BARRIER_REPLY:\n\t\t    case GET_CONFIG_REPLY:\n\t\t    case STATS_REPLY:\n\t\t    case QUEUE_GET_CONFIG_REPLY:\n\t\t\tillegalMessageReceived(h, m);\n\t\t\tbreak;\n\t\t}\n\t    }","cleancode":"@override void processofmessage(controllerchannelhandler h, ofmessage m) throws ioexception { switch (m.gettype()) { case hello: processofhello(h, (ofhello) m); break; case echo_reply: break; case echo_request: processofechorequest(h, (ofechorequest) m); break; case features_request: processoffeaturesrequest(h, (offeaturesrequest) m); break; case barrier_request: ofbarrierreply breply = new ofbarrierreply(); breply.setxid(m.getxid()); h.channel.write(collections.singletonlist(breply)); break; case set_config: case error: case packet_out: case port_mod: case queue_get_config_request: case stats_request: case flow_mod: case get_config_request: h.sw.handleio(m); break; case vendor: unhandledmessagereceived(h, m); break; case features_reply: case flow_removed: case packet_in: case port_status: case barrier_reply: case get_config_reply: case stats_reply: case queue_get_config_reply: illegalmessagereceived(h, m); break; } }","comment":"\/\/todo: actually implement barrier contract","repo":"mgerola\/OpenVirteX","code_context_2":"break;\ncase BARRIER_REQUEST:\n\/\/TODO: actually implement barrier contract\nOFBarrierReply breply = new OFBarrierReply();\nbreply.setXid(m.getXid());","code_context_10":"break;\ncase ECHO_REPLY:\nbreak;\ncase ECHO_REQUEST:\nprocessOFEchoRequest(h, (OFEchoRequest) m);\nbreak;\ncase FEATURES_REQUEST:\nprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\nbreak;\ncase BARRIER_REQUEST:\n\/\/TODO: actually implement barrier contract\nOFBarrierReply breply = new OFBarrierReply();\nbreply.setXid(m.getXid());\nh.channel.write(Collections.singletonList(breply));\nbreak;\ncase SET_CONFIG:\ncase ERROR:\ncase PACKET_OUT:\ncase PORT_MOD:\ncase QUEUE_GET_CONFIG_REQUEST:\ncase STATS_REQUEST:","code_context_20":"@Override\nvoid processOFMessage(ControllerChannelHandler h, OFMessage m)\nthrows IOException {\nswitch (m.getType()) {\ncase HELLO:\nprocessOFHello(h, (OFHello) m);\nbreak;\ncase ECHO_REPLY:\nbreak;\ncase ECHO_REQUEST:\nprocessOFEchoRequest(h, (OFEchoRequest) m);\nbreak;\ncase FEATURES_REQUEST:\nprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\nbreak;\ncase BARRIER_REQUEST:\n\/\/TODO: actually implement barrier contract\nOFBarrierReply breply = new OFBarrierReply();\nbreply.setXid(m.getXid());\nh.channel.write(Collections.singletonList(breply));\nbreak;\ncase SET_CONFIG:\ncase ERROR:\ncase PACKET_OUT:\ncase PORT_MOD:\ncase QUEUE_GET_CONFIG_REQUEST:\ncase STATS_REQUEST:\ncase FLOW_MOD:\ncase GET_CONFIG_REQUEST:\nh.sw.handleIO(m);\nbreak;\ncase VENDOR:\nunhandledMessageReceived(h, m);\nbreak;\ncase FEATURES_REPLY:\ncase FLOW_REMOVED:\ncase PACKET_IN:","label":[0,1,0,0]}
{"id":14763,"original_code":"private void concultar() {\n        String sql = \"select * from tbusuarios where iduser=?\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            rs = pst.executeQuery();\n            if (rs.next()) {\n                txtUsuNome.setText(rs.getString(2));\n                txtUsuFone.setText(rs.getString(3));\n                txtUsuLogin.setText(rs.getString(4));\n                txtUsuSenha.setText(rs.getString(5));\n                \/\/a linha abaixo se refere ao combobox \n                cboUsuPerfil.setSelectedItem(rs.getString(6));\n            } else {\n                JOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n                \/\/as linhas abaixo \"limpam os campos\"\n                txtUsuNome.setText(null);\n                txtUsuFone.setText(null);\n                txtUsuLogin.setText(null);\n                txtUsuSenha.setText(null);\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","code":"private void concultar() {\n        String sql = \"select * from tbusuarios where iduser=?\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            rs = pst.executeQuery();\n            if (rs.next()) {\n                txtUsuNome.setText(rs.getString(2));\n                txtUsuFone.setText(rs.getString(3));\n                txtUsuLogin.setText(rs.getString(4));\n                txtUsuSenha.setText(rs.getString(5));\n               \n                cboUsuPerfil.setSelectedItem(rs.getString(6));\n            } else {\n                JOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n               \n                txtUsuNome.setText(null);\n                txtUsuFone.setText(null);\n                txtUsuLogin.setText(null);\n                txtUsuSenha.setText(null);\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","cleancode":"private void concultar() { string sql = \"select * from tbusuarios where iduser=?\"; try { pst = conexao.preparestatement(sql); pst.setstring(1, txtusuid.gettext()); rs = pst.executequery(); if (rs.next()) { txtusunome.settext(rs.getstring(2)); txtusufone.settext(rs.getstring(3)); txtusulogin.settext(rs.getstring(4)); txtususenha.settext(rs.getstring(5)); cbousuperfil.setselecteditem(rs.getstring(6)); } else { joptionpane.showmessagedialog(null, \"usu\u00e1rio n\u00e3o cadastrado\"); txtusunome.settext(null); txtusufone.settext(null); txtusulogin.settext(null); txtususenha.settext(null); } } catch (exception e) { joptionpane.showmessagedialog(null, e); } }","comment":"\/\/metodo para consultar usuario\n\/\/a linha abaixo se refere ao combobox\n\/\/as linhas abaixo \"limpam os campos\"","repo":"marceloamorimcg\/Dr.InfoSystem","code_context_2":"private void concultar() {\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\n\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);","code_context_10":"private void concultar() {\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\n\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}","code_context_20":"private void concultar() {\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void concultar() {\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void concultar() {\nString sql = \"select * from tbusuarios where iduser=?\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\nrs = pst.executeQuery();\nif (rs.next()) {\ntxtUsuNome.setText(rs.getString(2));\ntxtUsuFone.setText(rs.getString(3));\ntxtUsuLogin.setText(rs.getString(4));\ntxtUsuSenha.setText(rs.getString(5));\n\/\/a linha abaixo se refere ao combobox\ncboUsuPerfil.setSelectedItem(rs.getString(6));\n} else {\nJOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n\/\/as linhas abaixo \"limpam os campos\"\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}","label":[0,0,0,0]}
{"id":14764,"original_code":"private void adicionar() {\n        String sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            pst.setString(2, txtUsuNome.getText());\n            pst.setString(3, txtUsuFone.getText());\n            pst.setString(4, txtUsuLogin.getText());\n            pst.setString(5, txtUsuSenha.getText());\n            pst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n            \/\/validi\u00e7\u00e3o dos campos obrigatorios\n            if ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\n                JOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n            } else {\n                \/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n                \/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\n                int adicionado = pst.executeUpdate();\n                \/\/ testando a logica \n                \/\/System.out.println(adicionado);\n                if (adicionado > 0) {\n                    JOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\n                    txtUsuNome.setText(null);\n                    txtUsuFone.setText(null);\n                    txtUsuLogin.setText(null);\n                    txtUsuSenha.setText(null);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","code":"private void adicionar() {\n        String sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            pst.setString(2, txtUsuNome.getText());\n            pst.setString(3, txtUsuFone.getText());\n            pst.setString(4, txtUsuLogin.getText());\n            pst.setString(5, txtUsuSenha.getText());\n            pst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n                      if ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\n                JOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n            } else {\n                            \n                int adicionado = pst.executeUpdate();\n               \n               \n                if (adicionado > 0) {\n                    JOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\n                    txtUsuNome.setText(null);\n                    txtUsuFone.setText(null);\n                    txtUsuLogin.setText(null);\n                    txtUsuSenha.setText(null);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","cleancode":"private void adicionar() { string sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\"; try { pst = conexao.preparestatement(sql); pst.setstring(1, txtusuid.gettext()); pst.setstring(2, txtusunome.gettext()); pst.setstring(3, txtusufone.gettext()); pst.setstring(4, txtusulogin.gettext()); pst.setstring(5, txtususenha.gettext()); pst.setstring(6, cbousuperfil.getselecteditem().tostring()); if ((txtusuid.gettext().isempty()) || (txtusunome.gettext().isempty()) || (txtusulogin.gettext().isempty()) || (txtususenha.gettext().isempty())) { joptionpane.showmessagedialog(null, \"preencha todos os campos obrigatorio\"); } else { int adicionado = pst.executeupdate(); if (adicionado > 0) { joptionpane.showmessagedialog(null, \"usuario adicionado com sucesso\"); txtusunome.settext(null); txtusufone.settext(null); txtusulogin.settext(null); txtususenha.settext(null); } } } catch (exception e) { joptionpane.showmessagedialog(null, e); } }","comment":"\/\/metodo para adicionar usu\u00e1rio\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela \/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\n\/\/ testando a logica \/\/system.out.println(adicionado);","repo":"marceloamorimcg\/Dr.InfoSystem","code_context_2":"private void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");","code_context_10":"private void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\n\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);","code_context_20":"private void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}\n\nprivate void adicionar() {\nString sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\ntry {\npst = conexao.prepareStatement(sql);\npst.setString(1, txtUsuId.getText());\npst.setString(2, txtUsuNome.getText());\npst.setString(3, txtUsuFone.getText());\npst.setString(4, txtUsuLogin.getText());\npst.setString(5, txtUsuSenha.getText());\npst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n\/\/validi\u00e7\u00e3o dos campos obrigatorios\nif ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\nJOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n} else {\n\/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n\/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\nint adicionado = pst.executeUpdate();\n\/\/ testando a logica\n\/\/System.out.println(adicionado);\nif (adicionado > 0) {\nJOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\ntxtUsuNome.setText(null);\ntxtUsuFone.setText(null);\ntxtUsuLogin.setText(null);\ntxtUsuSenha.setText(null);\n}\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(null, e);\n}\n}","label":[0,0,0,0]}
{"id":14786,"original_code":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n        \/\/ Use a predefined list of known Tokenizers\n        \/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\n        if (\"CSVTokenizer\".equals( tokenizerType )) {\n            return new CSVTokenizerImpl();\n        }\n        \/\/ Use the name of a class and instantiate this tokenizer\n        try {\n            \/\/ use classloader  and search for named class in class path...\n            ClassLoader classLoader = this.getClass().getClassLoader();\n            Class<?> loadedClass = classLoader.loadClass( tokenizerType );\n            \/\/ TODO: check if superclass is registered as a DataTokenizer....\n            \/\/ and check if it implements DataTokenizer\n            Class<?>[] interfaces = loadedClass.getInterfaces();\n            if (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n                \/\/ create the class using the unparametereized the constructor. \n                return (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n            }\n        }\n        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n                        | NoSuchMethodException | SecurityException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalArgumentException();\n    }","code":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n       \n       \n        if (\"CSVTokenizer\".equals( tokenizerType )) {\n            return new CSVTokenizerImpl();\n        }\n       \n        try {\n           \n            ClassLoader classLoader = this.getClass().getClassLoader();\n            Class<?> loadedClass = classLoader.loadClass( tokenizerType );\n           \n           \n            Class<?>[] interfaces = loadedClass.getInterfaces();\n            if (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n               \n                return (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n            }\n        }\n        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n                        | NoSuchMethodException | SecurityException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalArgumentException();\n    }","cleancode":"public datatokenizer buildtokenizerinstance( string tokenizertype ) { if (\"csvtokenizer\".equals( tokenizertype )) { return new csvtokenizerimpl(); } try { classloader classloader = this.getclass().getclassloader(); class<?> loadedclass = classloader.loadclass( tokenizertype ); class<?>[] interfaces = loadedclass.getinterfaces(); if (arrays.aslist( interfaces ).contains( datatokenizer.class )) { return (datatokenizer) loadedclass.getdeclaredconstructor().newinstance(); } } catch (classnotfoundexception | instantiationexception | illegalaccessexception | illegalargumentexception | invocationtargetexception | nosuchmethodexception | securityexception e) { e.printstacktrace(); } throw new illegalargumentexception(); }","comment":"\/\/ use a predefined list of known tokenizers \/\/ todo: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\n\/\/ use the name of a class and instantiate this tokenizer\n\/\/ use classloader and search for named class in class path...\n\/\/ todo: check if superclass is registered as a datatokenizer.... \/\/ and check if it implements datatokenizer\n\/\/ create the class using the unparametereized the constructor.","repo":"mindscan-de\/BrightFlux","code_context_2":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\n\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}","code_context_10":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\n\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\n\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\nthrow new IllegalArgumentException();\n}","code_context_20":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\nthrow new IllegalArgumentException();\n}\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\nthrow new IllegalArgumentException();\n}\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\nthrow new IllegalArgumentException();\n}\n\npublic DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n\/\/ Use a predefined list of known Tokenizers\n\/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\nif (\"CSVTokenizer\".equals( tokenizerType )) {\nreturn new CSVTokenizerImpl();\n}\n\/\/ Use the name of a class and instantiate this tokenizer\ntry {\n\/\/ use classloader and search for named class in class path...\nClassLoader classLoader = this.getClass().getClassLoader();\nClass<?> loadedClass = classLoader.loadClass( tokenizerType );\n\/\/ TODO: check if superclass is registered as a DataTokenizer....\n\/\/ and check if it implements DataTokenizer\nClass<?>[] interfaces = loadedClass.getInterfaces();\nif (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n\/\/ create the class using the unparametereized the constructor.\nreturn (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n}\n}\ncatch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| NoSuchMethodException | SecurityException e) {\ne.printStackTrace();\n}\nthrow new IllegalArgumentException();\n}","label":[0,1,0,0]}
{"id":23051,"original_code":"@Override\n\tprotected void updateConnectButtonState() {\n\t\t\/\/ TODO: Update this logic to also handle the user logged in by email.\n\t\tboolean connected = getPlusClient().isConnected();\n\t\tmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\n\t\tmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n\t}","code":"@Override\n\tprotected void updateConnectButtonState() {\n\t\n\t\tboolean connected = getPlusClient().isConnected();\n\t\tmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\n\t\tmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n\t}","cleancode":"@override protected void updateconnectbuttonstate() { boolean connected = getplusclient().isconnected(); msignoutbuttons.setvisibility(connected ? view.visible : view.gone); mplussigninbutton.setvisibility(connected ? view.gone : view.visible); }","comment":"\/\/ todo: update this logic to also handle the user logged in by email.","repo":"llanox\/EasyVote","code_context_2":"@Override\nprotected void updateConnectButtonState() {\n\/\/ TODO: Update this logic to also handle the user logged in by email.\nboolean connected = getPlusClient().isConnected();\nmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);","code_context_10":"@Override\nprotected void updateConnectButtonState() {\n\/\/ TODO: Update this logic to also handle the user logged in by email.\nboolean connected = getPlusClient().isConnected();\nmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\nmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n}","code_context_20":"@Override\nprotected void updateConnectButtonState() {\n\/\/ TODO: Update this logic to also handle the user logged in by email.\nboolean connected = getPlusClient().isConnected();\nmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\nmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n}","label":[0,1,0,0]}
{"id":23285,"original_code":"@Test\n\tpublic void fetchTest(){ \n\/\/\t\tFileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/\t\tfor(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/\t\t\tSystem.out.println(config);\n\/\/\t\t}\n\/\/\t\tRestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/\t\trcc.getAll(\"prod\", \"ssa\");\n\/\/\t\t\n\t}","code":"@Test\n\tpublic void fetchTest(){ \n\t}","cleancode":"@test public void fetchtest(){ }","comment":"\/\/note : this is actually a funcitonal test and does not belong here. it's just being used for dev purposes and should be removed \/\/ or refactored into a true unit test\n\/\/ fileconfigprovider fcp = new fileconfigprovider(\"overrides.json\"); \/\/ for(config config : fcp.getall(\"prod\", \"ssa\")){ \/\/ system.out.println(config); \/\/ } \/\/ restconfigprovider rcc = new restconfigprovider(\"http:\/\/localhost:8080\/configuration\"); \/\/ rcc.getall(\"prod\", \"ssa\"); \/\/","repo":"krisglover\/cia","code_context_2":"@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}\n\n@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}","code_context_10":"@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}\n\n@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}","code_context_20":"@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}\n\n@Test\npublic void fetchTest(){\n\/\/ FileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/ for(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/ System.out.println(config);\n\/\/ }\n\/\/ RestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/ rcc.getAll(\"prod\", \"ssa\");\n\/\/\n}","label":[0,0,0,1]}
{"id":31543,"original_code":"private String waitForAnswer(String expected) {\n        \/\/ todo add the possibility to specify more options to be specified\n        \/\/ todo use regexp matching instead of the beginning of a string\n        String line = null;\n        if (expected != null) {\n            try {\n                while ((line = mplayerOutErr.readLine()) != null) {\n                    if (MusicZones.getIsDebugOn()) {\n                        logger.log(Level.INFO, \"Reading line: {0}\", line);\n                    }\n                    if (line.startsWith(expected)) {\n                        return line;\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(ex);\n            }\n        }\n        return line;\n    }","code":"private String waitForAnswer(String expected) {\n       \n       \n        String line = null;\n        if (expected != null) {\n            try {\n                while ((line = mplayerOutErr.readLine()) != null) {\n                    if (MusicZones.getIsDebugOn()) {\n                        logger.log(Level.INFO, \"Reading line: {0}\", line);\n                    }\n                    if (line.startsWith(expected)) {\n                        return line;\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(ex);\n            }\n        }\n        return line;\n    }","cleancode":"private string waitforanswer(string expected) { string line = null; if (expected != null) { try { while ((line = mplayerouterr.readline()) != null) { if (musiczones.getisdebugon()) { logger.log(level.info, \"reading line: {0}\", line); } if (line.startswith(expected)) { return line; } } } catch (ioexception ex) { system.err.println(ex); } } return line; }","comment":"\/** read from the mplayer standard output and error a line that starts with the given parameter and return it. * @param expected the expected starting string for the line * @return the entire line from the standard output or error of mplayer *\/\n\/\/ todo add the possibility to specify more options to be specified \/\/ todo use regexp matching instead of the beginning of a string","repo":"jzerbe\/musiczones","code_context_2":"private String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {\ntry {\nwhile ((line = mplayerOutErr.readLine()) != null) {\nif (MusicZones.getIsDebugOn()) {\nlogger.log(Level.INFO, \"Reading line: {0}\", line);\n}\nif (line.startsWith(expected)) {\nreturn line;\n}\n}\n} catch (IOException ex) {\nSystem.err.println(ex);\n}\n}\nreturn line;\n}\n\nprivate String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {","code_context_10":"private String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {\ntry {\nwhile ((line = mplayerOutErr.readLine()) != null) {\nif (MusicZones.getIsDebugOn()) {\nlogger.log(Level.INFO, \"Reading line: {0}\", line);\n}\nif (line.startsWith(expected)) {\nreturn line;\n}\n}\n} catch (IOException ex) {\nSystem.err.println(ex);\n}\n}\nreturn line;\n}\n\nprivate String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {\ntry {\nwhile ((line = mplayerOutErr.readLine()) != null) {\nif (MusicZones.getIsDebugOn()) {\nlogger.log(Level.INFO, \"Reading line: {0}\", line);\n}\nif (line.startsWith(expected)) {\nreturn line;\n}","code_context_20":"private String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {\ntry {\nwhile ((line = mplayerOutErr.readLine()) != null) {\nif (MusicZones.getIsDebugOn()) {\nlogger.log(Level.INFO, \"Reading line: {0}\", line);\n}\nif (line.startsWith(expected)) {\nreturn line;\n}\n}\n} catch (IOException ex) {\nSystem.err.println(ex);\n}\n}\nreturn line;\n}\n\nprivate String waitForAnswer(String expected) {\n\/\/ todo add the possibility to specify more options to be specified\n\/\/ todo use regexp matching instead of the beginning of a string\nString line = null;\nif (expected != null) {\ntry {\nwhile ((line = mplayerOutErr.readLine()) != null) {\nif (MusicZones.getIsDebugOn()) {\nlogger.log(Level.INFO, \"Reading line: {0}\", line);\n}\nif (line.startsWith(expected)) {\nreturn line;\n}\n}\n} catch (IOException ex) {\nSystem.err.println(ex);\n}\n}\nreturn line;\n}","label":[0,1,0,0]}
{"id":31583,"original_code":"private void logGameStart(CFMap map) {\n        log.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n        \/\/TODO: FIX ANNOTATION STUFF\n        \/\/log.println(\"[Red Team Controller: \" + quote(game.getController(Team.RED).getIdString()) + \"]\");\n        \/\/log.println(\"[Blue Team Controller: \" + quote(game.getController(Team.BLUE).getIdString()) + \"]\");\n        log.println();\n        log.println(\"> Game started.\");\n    }","code":"private void logGameStart(CFMap map) {\n        log.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n       \n       \n       \n        log.println();\n        log.println(\"> Game started.\");\n    }","cleancode":"private void loggamestart(cfmap map) { log.println(\"=== codefray version 1 [capture the flag] official game log ===\\n\"); log.println(); log.println(\"> game started.\"); }","comment":"\/\/todo: fix annotation stuff \/\/log.println(\"[red team controller: \" + quote(game.getcontroller(team.red).getidstring()) + \"]\"); \/\/log.println(\"[blue team controller: \" + quote(game.getcontroller(team.blue).getidstring()) + \"]\");","repo":"lg198\/CodeFray","code_context_2":"private void logGameStart(CFMap map) {\nlog.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n\/\/TODO: FIX ANNOTATION STUFF\n\/\/log.println(\"[Red Team Controller: \" + quote(game.getController(Team.RED).getIdString()) + \"]\");\n\/\/log.println(\"[Blue Team Controller: \" + quote(game.getController(Team.BLUE).getIdString()) + \"]\");\nlog.println();\nlog.println(\"> Game started.\");","code_context_10":"private void logGameStart(CFMap map) {\nlog.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n\/\/TODO: FIX ANNOTATION STUFF\n\/\/log.println(\"[Red Team Controller: \" + quote(game.getController(Team.RED).getIdString()) + \"]\");\n\/\/log.println(\"[Blue Team Controller: \" + quote(game.getController(Team.BLUE).getIdString()) + \"]\");\nlog.println();\nlog.println(\"> Game started.\");\n}","code_context_20":"private void logGameStart(CFMap map) {\nlog.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n\/\/TODO: FIX ANNOTATION STUFF\n\/\/log.println(\"[Red Team Controller: \" + quote(game.getController(Team.RED).getIdString()) + \"]\");\n\/\/log.println(\"[Blue Team Controller: \" + quote(game.getController(Team.BLUE).getIdString()) + \"]\");\nlog.println();\nlog.println(\"> Game started.\");\n}","label":[0,1,0,0]}
{"id":31644,"original_code":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n        \/\/ If the filtered question is the same than asked\n        if(normalizedQuestion.equals(questionAsked))\n            return 100;\n        \/\/ If it is an ordered subset\n        \/\/ TODO I'M NOT SURE IF THIS IS WORKING\n        else if(isSubset(questionAsked))\n            return 65;\n        else if(containsWords(questionAsked)>0)\n            return 30;\n        \/\/ Otherwise\n        else\n            return 0;\n    }","code":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n       \n        if(normalizedQuestion.equals(questionAsked))\n            return 100;\n       \n       \n        else if(isSubset(questionAsked))\n            return 65;\n        else if(containsWords(questionAsked)>0)\n            return 30;\n       \n        else\n            return 0;\n    }","cleancode":"public int getprioritylevel(linkedlist<string> questionasked) { if(normalizedquestion.equals(questionasked)) return 100; else if(issubset(questionasked)) return 65; else if(containswords(questionasked)>0) return 30; else return 0; }","comment":"\/** * obtains the priority of this rule. it actually is a dynamic priority * that depends on the question that was asked. * the priority is: * - 100% if the question asked is the same to the background of the rule. * - 50% if the question asked is an ordered subset of the filtered question. * - 0% otherwise. * @param questionasked question asked by the user, that underwent the filtering process. * @return the dynamic priority of the rule. *\/\n\/\/ if the filtered question is the same than asked\n\/\/ if it is an ordered subset \/\/ todo i'm not sure if this is working\n\/\/ otherwise","repo":"melvidoni\/chatbot","code_context_2":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\n\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;","code_context_10":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}","code_context_20":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}\n\npublic int getPriorityLevel(LinkedList<String> questionAsked) {\n\/\/ If the filtered question is the same than asked\nif(normalizedQuestion.equals(questionAsked))\nreturn 100;\n\/\/ If it is an ordered subset\n\/\/ TODO I'M NOT SURE IF THIS IS WORKING\nelse if(isSubset(questionAsked))\nreturn 65;\nelse if(containsWords(questionAsked)>0)\nreturn 30;\n\/\/ Otherwise\nelse\nreturn 0;\n}","label":[1,0,0,0]}
{"id":31645,"original_code":"private int containsWords(LinkedList<String> questionAsked) {\n        \/\/ Create a counter\n        int containedWords = 0;\n        \/\/ For each word asked\n        for(String wordAsked : questionAsked) {\n            \/\/ If found, we add one, otherwise, we add zero\n            containedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n        }\n        \/\/ Return the value\n        return containedWords;\n    }","code":"private int containsWords(LinkedList<String> questionAsked) {\n       \n        int containedWords = 0;\n       \n        for(String wordAsked : questionAsked) {\n           \n            containedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n        }\n       \n        return containedWords;\n    }","cleancode":"private int containswords(linkedlist<string> questionasked) { int containedwords = 0; for(string wordasked : questionasked) { containedwords += normalizedquestion.contains(wordasked) ? 1 : 0; } return containedwords; }","comment":"\/** * evaluates if the normalized questions contains the words of the question asked * and returns the amount of words found. * todo i don't know if this is sloppy or it should work like this * @param questionasked the question to compare. * @return the amount of words of questionasked found in normalizedquestion. *\/\n\/\/ create a counter\n\/\/ for each word asked\n\/\/ if found, we add one, otherwise, we add zero\n\/\/ return the value","repo":"melvidoni\/chatbot","code_context_2":"private int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\n\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\n\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}","code_context_10":"private int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}","code_context_20":"private int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}\n\nprivate int containsWords(LinkedList<String> questionAsked) {\n\/\/ Create a counter\nint containedWords = 0;\n\/\/ For each word asked\nfor(String wordAsked : questionAsked) {\n\/\/ If found, we add one, otherwise, we add zero\ncontainedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n}\n\/\/ Return the value\nreturn containedWords;\n}","label":[1,0,0,0]}
{"id":31742,"original_code":"@Inject(\n            method = \"updateTexture()V\",\n            at = @At(\n                    value = \"HEAD\",\n                    target = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n            ),\n            cancellable = true)\n    private void updateAetherTexture(CallbackInfo ci) {\n        if (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\n            for (int i = 0; i < 128; ++i) {\n                for (int j = 0; j < 128; ++j) {\n                    int k = j + i * 128;\n                    int l = this.state.colors[k] & 255;\n                    if (l >> 2 == 0) { \/\/ MapColor.CLEAR\n                        \/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n                        \/\/ Comment your code please!\n                        this.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n                    } else {\n                        this.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n                    }\n                }\n            }\n            this.texture.upload();\n            ci.cancel();\n        }\n    }","code":"@Inject(\n            method = \"updateTexture()V\",\n            at = @At(\n                    value = \"HEAD\",\n                    target = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n            ),\n            cancellable = true)\n    private void updateAetherTexture(CallbackInfo ci) {\n        if (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\n            for (int i = 0; i < 128; ++i) {\n                for (int j = 0; j < 128; ++j) {\n                    int k = j + i * 128;\n                    int l = this.state.colors[k] & 255;\n                    if (l >> 2 == 0) {\n                       \n                       \n                        this.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n                    } else {\n                        this.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n                    }\n                }\n            }\n            this.texture.upload();\n            ci.cancel();\n        }\n    }","cleancode":"@inject( method = \"updatetexture()v\", at = @at( value = \"head\", target = \"net\/minecraft\/client\/render\/maprenderer$maptexture.updatetexture()v\" ), cancellable = true) private void updateaethertexture(callbackinfo ci) { if (this.state.dimension == aetherdimension.aether_world_key){ for (int i = 0; i < 128; ++i) { for (int j = 0; j < 128; ++j) { int k = j + i * 128; int l = this.state.colors[k] & 255; if (l >> 2 == 0) { this.texture.getimage().setcolor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24); } else { this.texture.getimage().setcolor(j, i, aethermapcolorutil.getcolor(mapcolor.colors[l >> 2], l & 3)); } } } this.texture.upload(); ci.cancel(); } }","comment":"\/** * recolors map colors in the aether dimension to look nicer. * could be a redirect, but that would actually probably be less compatible with other mods. * however, if the game updates this won't break, which is a bad thing *\/\n\/\/ mapcolor.clear\n\/\/ who knows what this does? nothing, it seems. but just in case i'll let it stick around. \/\/ comment your code please!","repo":"kalucky0\/The-Aether","code_context_2":"@Inject(\nmethod = \"updateTexture()V\",\nat = @At(\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}\n\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\n\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {","code_context_10":"@Inject(\nmethod = \"updateTexture()V\",\nat = @At(\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}\n\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}","code_context_20":"@Inject(\nmethod = \"updateTexture()V\",\nat = @At(\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}\n\n@Inject(\nmethod = \"updateTexture()V\",\nat = @At(\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}\n\n@Inject(\nmethod = \"updateTexture()V\",\nat = @At(\nvalue = \"HEAD\",\ntarget = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n),\ncancellable = true)\nprivate void updateAetherTexture(CallbackInfo ci) {\nif (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\nfor (int i = 0; i < 128; ++i) {\nfor (int j = 0; j < 128; ++j) {\nint k = j + i * 128;\nint l = this.state.colors[k] & 255;\nif (l >> 2 == 0) { \/\/ MapColor.CLEAR\n\/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n\/\/ Comment your code please!\nthis.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n} else {\nthis.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n}\n}\n}\nthis.texture.upload();\nci.cancel();\n}\n}","label":[1,0,0,0]}
{"id":31763,"original_code":"@Test\n\tpublic void test_EchoUser_restTemplate() {\n\t    String firstName = \"Chuck\";\n\t    String lastName = \"Norris\";\n\t\tString result = restTemplate.getForObject(\n\t\t\t\t\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName, \n\t\t\t\tString.class);\n\t\tString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\n\t\tassertThat(result, containsString(expected));\n\t\tlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n\t}","code":"@Test\n\tpublic void test_EchoUser_restTemplate() {\n\t    String firstName = \"Chuck\";\n\t    String lastName = \"Norris\";\n\t\tString result = restTemplate.getForObject(\n\t\t\t\t\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName, \n\t\t\t\tString.class);\n\t\tString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\n\t\tassertThat(result, containsString(expected));\n\t\tlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n\t}","cleancode":"@test public void test_echouser_resttemplate() { string firstname = \"chuck\"; string lastname = \"norris\"; string result = resttemplate.getforobject( \"http:\/\/localhost:8888\/\"+firstname+\"\/\"+lastname, string.class); string expected = \"{\\\"firstname\\\":\\\"\"+firstname+\"\\\",\\\"lastname\\\":\\\"\"+lastname+\"\\\"}\"; assertthat(result, containsstring(expected)); log.info(\"*** successfully echoed a user (\"+firstname+\" \"+lastname+\") through rest ***\"); }","comment":"\/\/ todo does not work with boot integeration tests:","repo":"mickknutson\/spring-cloud-config","code_context_2":"@Test\npublic void test_EchoUser_restTemplate() {\nString firstName = \"Chuck\";\nString lastName = \"Norris\";\nString result = restTemplate.getForObject(\n\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName,\nString.class);\nString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\nassertThat(result, containsString(expected));\nlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n}","code_context_10":"@Test\npublic void test_EchoUser_restTemplate() {\nString firstName = \"Chuck\";\nString lastName = \"Norris\";\nString result = restTemplate.getForObject(\n\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName,\nString.class);\nString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\nassertThat(result, containsString(expected));\nlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n}","code_context_20":"@Test\npublic void test_EchoUser_restTemplate() {\nString firstName = \"Chuck\";\nString lastName = \"Norris\";\nString result = restTemplate.getForObject(\n\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName,\nString.class);\nString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\nassertThat(result, containsString(expected));\nlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n}","label":[0,0,1,0]}
{"id":15506,"original_code":"public boolean validateBinaryExpr(BinaryExpr node) {\n        ExprNode expr1 = node.getExpr1();\n        ExprNode expr2 = node.getExpr2();\n        Type t1 = expr1.getType();\n        Type t2 = expr2.getType();\n        String op = node.getOperation();\n        switch (op) {\n            case \"==\":\n            case \"!=\":\n                if (Types.isNumber(t1)) {\n                    return this.requireNumber(expr2,t2);\n                } else {\n                    return true;\n                    \/\/TODO pass anything.may be Object needed?\n                }\n            case \"+\":\n            case \"-\":\n            case \"*\":\n            case \"\/\":\n            case \"%\":\n            case \">=\":\n            case \"<=\":\n            case \">\":\n            case \"<\":\n            case \"&\":\n            case \"|\":\n            case \"^\":\n            case BinaryExpr.OP_SHIFT_LEFT:\n            case BinaryExpr.OP_SHIFT_RIGHT:\n            case BinaryExpr.OP_UNSIGNED_SHIFT_RIGHT:\n                return this.requireNumber(expr1, t1) && this.requireNumber(expr2, t2);\n            case \"&&\":\n            case \"||\":\n                return requireBoolean(expr1, t1) && requireBoolean(expr2, t2);\n            default:\n                diagnosisReporter.report(Diagnosis.Kind.ERROR, \"unsupported operation:\" + op, node.offset);\n                return false;\n        }\n    }","code":"public boolean validateBinaryExpr(BinaryExpr node) {\n        ExprNode expr1 = node.getExpr1();\n        ExprNode expr2 = node.getExpr2();\n        Type t1 = expr1.getType();\n        Type t2 = expr2.getType();\n        String op = node.getOperation();\n        switch (op) {\n            case \"==\":\n            case \"!=\":\n                if (Types.isNumber(t1)) {\n                    return this.requireNumber(expr2,t2);\n                } else {\n                    return true;\n                   \n                }\n            case \"+\":\n            case \"-\":\n            case \"*\":\n            case \"\/\":\n            case \"%\":\n            case \">=\":\n            case \"<=\":\n            case \">\":\n            case \"<\":\n            case \"&\":\n            case \"|\":\n            case \"^\":\n            case BinaryExpr.OP_SHIFT_LEFT:\n            case BinaryExpr.OP_SHIFT_RIGHT:\n            case BinaryExpr.OP_UNSIGNED_SHIFT_RIGHT:\n                return this.requireNumber(expr1, t1) && this.requireNumber(expr2, t2);\n            case \"&&\":\n            case \"||\":\n                return requireBoolean(expr1, t1) && requireBoolean(expr2, t2);\n            default:\n                diagnosisReporter.report(Diagnosis.Kind.ERROR, \"unsupported operation:\" + op, node.offset);\n                return false;\n        }\n    }","cleancode":"public boolean validatebinaryexpr(binaryexpr node) { exprnode expr1 = node.getexpr1(); exprnode expr2 = node.getexpr2(); type t1 = expr1.gettype(); type t2 = expr2.gettype(); string op = node.getoperation(); switch (op) { case \"==\": case \"!=\": if (types.isnumber(t1)) { return this.requirenumber(expr2,t2); } else { return true; } case \"+\": case \"-\": case \"*\": case \"\/\": case \"%\": case \">=\": case \"<=\": case \">\": case \"<\": case \"&\": case \"|\": case \"^\": case binaryexpr.op_shift_left: case binaryexpr.op_shift_right: case binaryexpr.op_unsigned_shift_right: return this.requirenumber(expr1, t1) && this.requirenumber(expr2, t2); case \"&&\": case \"||\": return requireboolean(expr1, t1) && requireboolean(expr2, t2); default: diagnosisreporter.report(diagnosis.kind.error, \"unsupported operation:\" + op, node.offset); return false; } }","comment":"\/\/todo pass anything.may be object needed?","repo":"lbqh\/kalang","code_context_2":"} else {\nreturn true;\n\/\/TODO pass anything.may be Object needed?\n}\ncase \"+\":","code_context_10":"Type t1 = expr1.getType();\nType t2 = expr2.getType();\nString op = node.getOperation();\nswitch (op) {\ncase \"==\":\ncase \"!=\":\nif (Types.isNumber(t1)) {\nreturn this.requireNumber(expr2,t2);\n} else {\nreturn true;\n\/\/TODO pass anything.may be Object needed?\n}\ncase \"+\":\ncase \"-\":\ncase \"*\":\ncase \"\/\":\ncase \"%\":\ncase \">=\":\ncase \"<=\":\ncase \">\":\ncase \"<\":","code_context_20":"public boolean validateBinaryExpr(BinaryExpr node) {\nExprNode expr1 = node.getExpr1();\nExprNode expr2 = node.getExpr2();\nType t1 = expr1.getType();\nType t2 = expr2.getType();\nString op = node.getOperation();\nswitch (op) {\ncase \"==\":\ncase \"!=\":\nif (Types.isNumber(t1)) {\nreturn this.requireNumber(expr2,t2);\n} else {\nreturn true;\n\/\/TODO pass anything.may be Object needed?\n}\ncase \"+\":\ncase \"-\":\ncase \"*\":\ncase \"\/\":\ncase \"%\":\ncase \">=\":\ncase \"<=\":\ncase \">\":\ncase \"<\":\ncase \"&\":\ncase \"|\":\ncase \"^\":\ncase BinaryExpr.OP_SHIFT_LEFT:\ncase BinaryExpr.OP_SHIFT_RIGHT:\ncase BinaryExpr.OP_UNSIGNED_SHIFT_RIGHT:\nreturn this.requireNumber(expr1, t1) && this.requireNumber(expr2, t2);\ncase \"&&\":\ncase \"||\":\nreturn requireBoolean(expr1, t1) && requireBoolean(expr2, t2);","label":[0,1,0,0]}
{"id":15600,"original_code":"public void projectTo(final ComplexProjective1 cp)\n        throws IllegalArgumentException {\n        \/* Check if the point lies on the sphere. *\/\n        if (Math.abs(normSquared() - 1.0) > EPSILON) {\n            throw new IllegalArgumentException(\"Norm must be 1.0. \" +\n                                               \"Norm is \" + norm() + \". \");\n        }\n        \/* Check if the point lies above or below the xy-plane. *\/\n        if (z > 0.0) {\n            \/* We might be close to the north pole. This would be bad,\n             * numerically. So perform a 180 degree rotation around the\n             * x-axis, project that point, and swap the entries of the\n             * result.\n             *\/\n            \/* Dummy variables *\/\n            final double dummyRe;\n            final double dummyIm;\n            \/* Rotate by 180 degree around the x-axis. *\/\n            y = -y;\n            z = -z;\n            \/* Project that point. Now, z < -EPSILON. *\/\n            belowXYProjectTo(cp);\n            \/* Rotate back. *\/\n            y = -y;\n            z = -z;\n            \/* Swap the entries of the result.\n             *\n             * TODO: Maybe Complex2 should have a final method that swaps the\n             * entries. This might speed up dereferencing the fields of cp,\n             * because dereferencing fiels of other objects might be slower\n             * than dereferencing fields of the same object. But actually, I\n             * don't know if that is true or if it matters. *\/\n            dummyRe = cp.aRe;\n            dummyIm = cp.aIm;\n            cp.aRe = cp.bRe;\n            cp.aIm = cp.bIm;\n            cp.bRe = dummyRe;\n            cp.bIm = dummyIm;\n        } else {\n            \/* Point lies below xy-plane so we use *\/\n            belowXYProjectTo(cp);\n        }\n    }","code":"public void projectTo(final ComplexProjective1 cp)\n        throws IllegalArgumentException {\n       \n        if (Math.abs(normSquared() - 1.0) > EPSILON) {\n            throw new IllegalArgumentException(\"Norm must be 1.0. \" +\n                                               \"Norm is \" + norm() + \". \");\n        }\n       \n        if (z > 0.0) {\n           \n           \n            final double dummyRe;\n            final double dummyIm;\n           \n            y = -y;\n            z = -z;\n           \n            belowXYProjectTo(cp);\n           \n            y = -y;\n            z = -z;\n           \n            dummyRe = cp.aRe;\n            dummyIm = cp.aIm;\n            cp.aRe = cp.bRe;\n            cp.aIm = cp.bIm;\n            cp.bRe = dummyRe;\n            cp.bIm = dummyIm;\n        } else {\n           \n            belowXYProjectTo(cp);\n        }\n    }","cleancode":"public void projectto(final complexprojective1 cp) throws illegalargumentexception { if (math.abs(normsquared() - 1.0) > epsilon) { throw new illegalargumentexception(\"norm must be 1.0. \" + \"norm is \" + norm() + \". \"); } if (z > 0.0) { final double dummyre; final double dummyim; y = -y; z = -z; belowxyprojectto(cp); y = -y; z = -z; dummyre = cp.are; dummyim = cp.aim; cp.are = cp.bre; cp.aim = cp.bim; cp.bre = dummyre; cp.bim = dummyim; } else { belowxyprojectto(cp); } }","comment":"\/** * <p>project a point on the unit sphere stereographically from the north * pole to complex projective space.<\/p> * * <p><code>(0, 0, 1)<\/code> is projected to the point with homogeneous * coordinates <code>(1, 0)<\/code>.<br> <code>(0, 0, -1)<\/code> is * projected to the point with homogenous coordinates <code>(0, * 1)<\/code>.<\/p> * * @param cp the {@link complexprojective1} used to hand over the * result. must not be null. * * @throws illegalargumentexception if {@link #normsquared()} differs from * <code>1.0<\/code> by more than {@link #epsilon} *\/\n\/* check if the point lies on the sphere. *\/\n\/* check if the point lies above or below the xy-plane. *\/\n\/* we might be close to the north pole. this would be bad, * numerically. so perform a 180 degree rotation around the * x-axis, project that point, and swap the entries of the * result. *\/\n\/* dummy variables *\/\n\/* rotate by 180 degree around the x-axis. *\/\n\/* project that point. now, z < -epsilon. *\/\n\/* rotate back. *\/\n\/* swap the entries of the result. * * todo: maybe complex2 should have a final method that swaps the * entries. this might speed up dereferencing the fields of cp, * because dereferencing fiels of other objects might be slower * than dereferencing fields of the same object. but actually, i * don't know if that is true or if it matters. *\/\n\/* point lies below xy-plane so we use *\/","repo":"jupsal\/schmies-jTEM","code_context_2":"public void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\n\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\n\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\n\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}","code_context_10":"public void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\n\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\n\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}","code_context_20":"public void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n\npublic void projectTo(final ComplexProjective1 cp)\nthrows IllegalArgumentException {\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n\n\/* Check if the point lies on the sphere. *\/\nif (Math.abs(normSquared() - 1.0) > EPSILON) {\nthrow new IllegalArgumentException(\"Norm must be 1.0. \" +\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}\n\n\"Norm is \" + norm() + \". \");\n}\n\/* Check if the point lies above or below the xy-plane. *\/\nif (z > 0.0) {\n\/* We might be close to the north pole. This would be bad,\n* numerically. So perform a 180 degree rotation around the\n* x-axis, project that point, and swap the entries of the\n* result.\n*\/\n\/* Dummy variables *\/\nfinal double dummyRe;\nfinal double dummyIm;\n\/* Rotate by 180 degree around the x-axis. *\/\ny = -y;\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}\n\nz = -z;\n\/* Project that point. Now, z < -EPSILON. *\/\nbelowXYProjectTo(cp);\n\/* Rotate back. *\/\ny = -y;\nz = -z;\n\/* Swap the entries of the result.\n*\n* TODO: Maybe Complex2 should have a final method that swaps the\n* entries. This might speed up dereferencing the fields of cp,\n* because dereferencing fiels of other objects might be slower\n* than dereferencing fields of the same object. But actually, I\n* don't know if that is true or if it matters. *\/\ndummyRe = cp.aRe;\ndummyIm = cp.aIm;\ncp.aRe = cp.bRe;\ncp.aIm = cp.bIm;\ncp.bRe = dummyRe;\ncp.bIm = dummyIm;\n} else {\n\/* Point lies below xy-plane so we use *\/\nbelowXYProjectTo(cp);\n}\n}","label":[1,0,0,0]}
{"id":32041,"original_code":"@Test\n    public void dontPullAttachmentAlreadyPulled() {\n        try {\n            \/\/ create a rev with an attachment, then update it keeping attachment\n            \/\/ TODO we need to somehow check the attachment wasn't re-downloaded\n            createRevisionAndBigTextAttachment();\n            pull();\n            DocumentRevision docRev1 = datastore.getDocument(id, rev);\n            Attachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\n            updateRevisionAndKeepAttachment();\n            updateRevisionAndKeepAttachment();\n            pull();\n            DocumentRevision docRev2 = datastore.getDocument(id, rev);\n            Attachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\n            Assert.assertNotNull(a2);\n        } catch (Exception e) {\n            Assert.fail(\"Create\/pull error \" + e);\n        }\n    }","code":"@Test\n    public void dontPullAttachmentAlreadyPulled() {\n        try {\n           \n           \n            createRevisionAndBigTextAttachment();\n            pull();\n            DocumentRevision docRev1 = datastore.getDocument(id, rev);\n            Attachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\n            updateRevisionAndKeepAttachment();\n            updateRevisionAndKeepAttachment();\n            pull();\n            DocumentRevision docRev2 = datastore.getDocument(id, rev);\n            Attachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\n            Assert.assertNotNull(a2);\n        } catch (Exception e) {\n            Assert.fail(\"Create\/pull error \" + e);\n        }\n    }","cleancode":"@test public void dontpullattachmentalreadypulled() { try { createrevisionandbigtextattachment(); pull(); documentrevision docrev1 = datastore.getdocument(id, rev); attachment a1 = datastore.getattachment(docrev1, bigtextattachmentname); updaterevisionandkeepattachment(); updaterevisionandkeepattachment(); pull(); documentrevision docrev2 = datastore.getdocument(id, rev); attachment a2 = datastore.getattachment(docrev2, bigtextattachmentname); assert.assertnotnull(a2); } catch (exception e) { assert.fail(\"create\/pull error \" + e); } }","comment":"\/\/ create a rev with an attachment, then update it keeping attachment \/\/ todo we need to somehow check the attachment wasn't re-downloaded","repo":"kiwiwearables\/sync-android","code_context_2":"public void dontPullAttachmentAlreadyPulled() {\ntry {\n\/\/ create a rev with an attachment, then update it keeping attachment\n\/\/ TODO we need to somehow check the attachment wasn't re-downloaded\ncreateRevisionAndBigTextAttachment();\npull();","code_context_10":"@Test\npublic void dontPullAttachmentAlreadyPulled() {\ntry {\n\/\/ create a rev with an attachment, then update it keeping attachment\n\/\/ TODO we need to somehow check the attachment wasn't re-downloaded\ncreateRevisionAndBigTextAttachment();\npull();\nDocumentRevision docRev1 = datastore.getDocument(id, rev);\nAttachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\nupdateRevisionAndKeepAttachment();\nupdateRevisionAndKeepAttachment();\npull();\nDocumentRevision docRev2 = datastore.getDocument(id, rev);\nAttachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\nAssert.assertNotNull(a2);","code_context_20":"@Test\npublic void dontPullAttachmentAlreadyPulled() {\ntry {\n\/\/ create a rev with an attachment, then update it keeping attachment\n\/\/ TODO we need to somehow check the attachment wasn't re-downloaded\ncreateRevisionAndBigTextAttachment();\npull();\nDocumentRevision docRev1 = datastore.getDocument(id, rev);\nAttachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\nupdateRevisionAndKeepAttachment();\nupdateRevisionAndKeepAttachment();\npull();\nDocumentRevision docRev2 = datastore.getDocument(id, rev);\nAttachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\nAssert.assertNotNull(a2);\n} catch (Exception e) {\nAssert.fail(\"Create\/pull error \" + e);\n}\n}","label":[1,0,0,0]}
{"id":7632,"original_code":"@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Bundle extras;\n        Log.d(TAG, \"Widget configuration activity created\");\n        setResult(RESULT_CANCELED);\n        extras = getIntent().getExtras();\n        if (extras != null) {\n            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n        }\n        if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\n            finish();\n            return;\n        }\n        resultValue = new Intent();\n        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\n        setResult(RESULT_OK, resultValue);\n        if(SessionManager.hasSessionInStore(this)) {\n            \/\/ Finish activity earlier\n            Log.d(TAG, \"Session already taken, leaving configuration activity\");\n            finish();\n        }\n    }","code":"@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Bundle extras;\n        Log.d(TAG, \"Widget configuration activity created\");\n        setResult(RESULT_CANCELED);\n        extras = getIntent().getExtras();\n        if (extras != null) {\n            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n        }\n        if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\n            finish();\n            return;\n        }\n        resultValue = new Intent();\n        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\n        setResult(RESULT_OK, resultValue);\n        if(SessionManager.hasSessionInStore(this)) {\n           \n            Log.d(TAG, \"Session already taken, leaving configuration activity\");\n            finish();\n        }\n    }","cleancode":"@override protected void oncreate(bundle savedinstancestate) { super.oncreate(savedinstancestate); bundle extras; log.d(tag, \"widget configuration activity created\"); setresult(result_canceled); extras = getintent().getextras(); if (extras != null) { mappwidgetid = extras.getint(appwidgetmanager.extra_appwidget_id, appwidgetmanager.invalid_appwidget_id); } if (mappwidgetid == appwidgetmanager.invalid_appwidget_id) { finish(); return; } resultvalue = new intent(); resultvalue.putextra(appwidgetmanager.extra_appwidget_id, mappwidgetid); setresult(result_ok, resultvalue); if(sessionmanager.hassessioninstore(this)) { log.d(tag, \"session already taken, leaving configuration activity\"); finish(); } }","comment":"\/\/ fixme: flashing blank activity\n\/\/ finish activity earlier","repo":"memleakpl\/flat","code_context_2":"@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nBundle extras;\nLog.d(TAG, \"Widget configuration activity created\");\nsetResult(RESULT_CANCELED);\nextras = getIntent().getExtras();\nif (extras != null) {\nmAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\nAppWidgetManager.INVALID_APPWIDGET_ID);\n}\nif (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\nfinish();\nreturn;\n}\nresultValue = new Intent();\nresultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();\n}\n}\n\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();","code_context_10":"@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nBundle extras;\nLog.d(TAG, \"Widget configuration activity created\");\nsetResult(RESULT_CANCELED);\nextras = getIntent().getExtras();\nif (extras != null) {\nmAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\nAppWidgetManager.INVALID_APPWIDGET_ID);\n}\nif (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\nfinish();\nreturn;\n}\nresultValue = new Intent();\nresultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();\n}\n}\n\nAppWidgetManager.INVALID_APPWIDGET_ID);\n}\nif (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\nfinish();\nreturn;\n}\nresultValue = new Intent();\nresultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();\n}\n}","code_context_20":"@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nBundle extras;\nLog.d(TAG, \"Widget configuration activity created\");\nsetResult(RESULT_CANCELED);\nextras = getIntent().getExtras();\nif (extras != null) {\nmAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\nAppWidgetManager.INVALID_APPWIDGET_ID);\n}\nif (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\nfinish();\nreturn;\n}\nresultValue = new Intent();\nresultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();\n}\n}\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\nsuper.onCreate(savedInstanceState);\nBundle extras;\nLog.d(TAG, \"Widget configuration activity created\");\nsetResult(RESULT_CANCELED);\nextras = getIntent().getExtras();\nif (extras != null) {\nmAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\nAppWidgetManager.INVALID_APPWIDGET_ID);\n}\nif (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\nfinish();\nreturn;\n}\nresultValue = new Intent();\nresultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\nsetResult(RESULT_OK, resultValue);\nif(SessionManager.hasSessionInStore(this)) {\n\/\/ Finish activity earlier\nLog.d(TAG, \"Session already taken, leaving configuration activity\");\nfinish();\n}\n}","label":[0,0,1,0]}
{"id":24024,"original_code":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\n\t\tif (object == null) {\n\t\t\tbuffer.append(\"NULL\");\n\t\t} else if (object instanceof String) {\n\t\t\tbuffer.append('\\'');\n\t\t\t\/\/ lets escape quotes\n\t\t\tString literal = (String) object;\n\t\t\tif (literal.length() > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n\t\t\t}\n\t\t\tint curPos = 0;\n\t\t\tint endPos = 0;\n\t\t\twhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\n\t\t\t\tbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\n\t\t\t\tcurPos = endPos + 1;\n\t\t\t}\n\t\t\tif (curPos < literal.length())\n\t\t\t\tbuffer.append(literal.substring(curPos));\n\t\t\tbuffer.append('\\'');\n\t\t}\n\t\t\/\/ handle byte pretty formatting\n\t\telse if (object instanceof Byte) {\n\t\t\tIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n\t\t} else if (object instanceof Number) {\n\t\t\t\/\/ process numeric value (do something smart in the future)\n\t\t\tbuffer.append(object);\n\t\t} else if (object instanceof java.sql.Date) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.sql.Time) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.util.Date) {\n\t\t\tlong time = ((java.util.Date) object).getTime();\n\t\t\tbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n\t\t} else if (object instanceof java.util.Calendar) {\n\t\t\tlong time = ((java.util.Calendar) object).getTimeInMillis();\n\t\t\tbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n\t\t} else if (object instanceof Character) {\n\t\t\tbuffer.append(((Character) object).charValue());\n\t\t} else if (object instanceof Boolean) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof Enum<?>) {\n\t\t\t\/\/ buffer.append(object.getClass().getName()).append(\".\");\n\t\t\tbuffer.append(((Enum<?>) object).name()).append(\"=\");\n\t\t\tif (object instanceof ExtendedEnumeration) {\n\t\t\t\tObject value = ((ExtendedEnumeration) object).getDatabaseValue();\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t\tbuffer.append(value);\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(((Enum<?>) object).ordinal());\n\t\t\t\t\/\/ FIXME -- this isn't quite right\n\t\t\t}\n\t\t} else if (object instanceof SQLParameterBinding) {\n\t\t\tsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n\t\t} else if (object.getClass().isArray()) {\n\t\t\tbuffer.append(\"< \");\n\t\t\tint len = Array.getLength(object);\n\t\t\tboolean trimming = false;\n\t\t\tif (len > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tlen = TRIM_VALUES_THRESHOLD;\n\t\t\t\ttrimming = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tbuffer.append(\",\");\n\t\t\t\t}\n\t\t\t\tsqlLiteralForObject(buffer, Array.get(object, i));\n\t\t\t}\n\t\t\tif (trimming) {\n\t\t\t\tbuffer.append(\"...\");\n\t\t\t}\n\t\t\tbuffer.append('>');\n\t\t} else {\n\t\t\tbuffer.append(object.getClass().getName()).append(\"@\").append(System.identityHashCode(object));\n\t\t}\n\t}","code":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\n\t\tif (object == null) {\n\t\t\tbuffer.append(\"NULL\");\n\t\t} else if (object instanceof String) {\n\t\t\tbuffer.append('\\'');\n\t\t\n\t\t\tString literal = (String) object;\n\t\t\tif (literal.length() > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n\t\t\t}\n\t\t\tint curPos = 0;\n\t\t\tint endPos = 0;\n\t\t\twhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\n\t\t\t\tbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\n\t\t\t\tcurPos = endPos + 1;\n\t\t\t}\n\t\t\tif (curPos < literal.length())\n\t\t\t\tbuffer.append(literal.substring(curPos));\n\t\t\tbuffer.append('\\'');\n\t\t}\n\t\n\t\telse if (object instanceof Byte) {\n\t\t\tIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n\t\t} else if (object instanceof Number) {\n\t\t\n\t\t\tbuffer.append(object);\n\t\t} else if (object instanceof java.sql.Date) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.sql.Time) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.util.Date) {\n\t\t\tlong time = ((java.util.Date) object).getTime();\n\t\t\tbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n\t\t} else if (object instanceof java.util.Calendar) {\n\t\t\tlong time = ((java.util.Calendar) object).getTimeInMillis();\n\t\t\tbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n\t\t} else if (object instanceof Character) {\n\t\t\tbuffer.append(((Character) object).charValue());\n\t\t} else if (object instanceof Boolean) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof Enum<?>) {\n\t\t\n\t\t\tbuffer.append(((Enum<?>) object).name()).append(\"=\");\n\t\t\tif (object instanceof ExtendedEnumeration) {\n\t\t\t\tObject value = ((ExtendedEnumeration) object).getDatabaseValue();\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t\tbuffer.append(value);\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(((Enum<?>) object).ordinal());\n\t\t\t\n\t\t\t}\n\t\t} else if (object instanceof SQLParameterBinding) {\n\t\t\tsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n\t\t} else if (object.getClass().isArray()) {\n\t\t\tbuffer.append(\"< \");\n\t\t\tint len = Array.getLength(object);\n\t\t\tboolean trimming = false;\n\t\t\tif (len > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tlen = TRIM_VALUES_THRESHOLD;\n\t\t\t\ttrimming = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tbuffer.append(\",\");\n\t\t\t\t}\n\t\t\t\tsqlLiteralForObject(buffer, Array.get(object, i));\n\t\t\t}\n\t\t\tif (trimming) {\n\t\t\t\tbuffer.append(\"...\");\n\t\t\t}\n\t\t\tbuffer.append('>');\n\t\t} else {\n\t\t\tbuffer.append(object.getClass().getName()).append(\"@\").append(System.identityHashCode(object));\n\t\t}\n\t}","cleancode":"void sqlliteralforobject(stringbuilder buffer, object object) { if (object == null) { buffer.append(\"null\"); } else if (object instanceof string) { buffer.append('\\''); string literal = (string) object; if (literal.length() > trim_values_threshold) { literal = literal.substring(0, trim_values_threshold) + \"...\"; } int curpos = 0; int endpos = 0; while ((endpos = literal.indexof('\\'', curpos)) >= 0) { buffer.append(literal.substring(curpos, endpos + 1)).append('\\''); curpos = endpos + 1; } if (curpos < literal.length()) buffer.append(literal.substring(curpos)); buffer.append('\\''); } else if (object instanceof byte) { idutil.appendformattedbyte(buffer, ((byte) object).bytevalue()); } else if (object instanceof number) { buffer.append(object); } else if (object instanceof java.sql.date) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof java.sql.time) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof java.util.date) { long time = ((java.util.date) object).gettime(); buffer.append('\\'').append(new java.sql.timestamp(time)).append('\\''); } else if (object instanceof java.util.calendar) { long time = ((java.util.calendar) object).gettimeinmillis(); buffer.append(object.getclass().getname()).append('(').append(new java.sql.timestamp(time)).append(')'); } else if (object instanceof character) { buffer.append(((character) object).charvalue()); } else if (object instanceof boolean) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof enum<?>) { buffer.append(((enum<?>) object).name()).append(\"=\"); if (object instanceof extendedenumeration) { object value = ((extendedenumeration) object).getdatabasevalue(); if (value instanceof string) buffer.append(\"'\"); buffer.append(value); if (value instanceof string) buffer.append(\"'\"); } else { buffer.append(((enum<?>) object).ordinal()); } } else if (object instanceof sqlparameterbinding) { sqlliteralforobject(buffer, ((sqlparameterbinding) object).getvalue()); } else if (object.getclass().isarray()) { buffer.append(\"< \"); int len = array.getlength(object); boolean trimming = false; if (len > trim_values_threshold) { len = trim_values_threshold; trimming = true; } for (int i = 0; i < len; i++) { if (i > 0) { buffer.append(\",\"); } sqlliteralforobject(buffer, array.get(object, i)); } if (trimming) { buffer.append(\"...\"); } buffer.append('>'); } else { buffer.append(object.getclass().getname()).append(\"@\").append(system.identityhashcode(object)); } }","comment":"\/\/ lets escape quotes\n\/\/ handle byte pretty formatting\n\/\/ process numeric value (do something smart in the future)\n\/\/ buffer.append(object.getclass().getname()).append(\".\");\n\/\/ fixme -- this isn't quite right","repo":"laakhbeenor\/cayenne","code_context_2":"} else if (object instanceof String) {\nbuffer.append('\\'');\n\/\/ lets escape quotes\nString literal = (String) object;\nif (literal.length() > TRIM_VALUES_THRESHOLD) {\n\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\n\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\/\/ buffer.append(object.getClass().getName()).append(\".\");\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\n\n} else {\nbuffer.append(((Enum<?>) object).ordinal());\n\/\/ FIXME -- this isn't quite right\n}\n} else if (object instanceof SQLParameterBinding) {","code_context_10":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\nif (object == null) {\nbuffer.append(\"NULL\");\n} else if (object instanceof String) {\nbuffer.append('\\'');\n\/\/ lets escape quotes\nString literal = (String) object;\nif (literal.length() > TRIM_VALUES_THRESHOLD) {\nliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n}\nint curPos = 0;\nint endPos = 0;\nwhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\nbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\ncurPos = endPos + 1;\n}\n\nint curPos = 0;\nint endPos = 0;\nwhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\nbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\ncurPos = endPos + 1;\n}\nif (curPos < literal.length())\nbuffer.append(literal.substring(curPos));\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.sql.Time) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.util.Date) {\n\ncurPos = endPos + 1;\n}\nif (curPos < literal.length())\nbuffer.append(literal.substring(curPos));\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.sql.Time) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.util.Date) {\nlong time = ((java.util.Date) object).getTime();\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\n\nlong time = ((java.util.Date) object).getTime();\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\nbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n} else if (object instanceof Character) {\nbuffer.append(((Character) object).charValue());\n} else if (object instanceof Boolean) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\/\/ buffer.append(object.getClass().getName()).append(\".\");\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\nObject value = ((ExtendedEnumeration) object).getDatabaseValue();\nif (value instanceof String)\nbuffer.append(\"'\");\nbuffer.append(value);\nif (value instanceof String)\nbuffer.append(\"'\");\n} else {\nbuffer.append(((Enum<?>) object).ordinal());\n\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\nObject value = ((ExtendedEnumeration) object).getDatabaseValue();\nif (value instanceof String)\nbuffer.append(\"'\");\nbuffer.append(value);\nif (value instanceof String)\nbuffer.append(\"'\");\n} else {\nbuffer.append(((Enum<?>) object).ordinal());\n\/\/ FIXME -- this isn't quite right\n}\n} else if (object instanceof SQLParameterBinding) {\nsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n} else if (object.getClass().isArray()) {\nbuffer.append(\"< \");\nint len = Array.getLength(object);\nboolean trimming = false;\nif (len > TRIM_VALUES_THRESHOLD) {\nlen = TRIM_VALUES_THRESHOLD;\ntrimming = true;","code_context_20":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\nif (object == null) {\nbuffer.append(\"NULL\");\n} else if (object instanceof String) {\nbuffer.append('\\'');\n\/\/ lets escape quotes\nString literal = (String) object;\nif (literal.length() > TRIM_VALUES_THRESHOLD) {\nliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n}\nint curPos = 0;\nint endPos = 0;\nwhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\nbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\ncurPos = endPos + 1;\n}\nif (curPos < literal.length())\nbuffer.append(literal.substring(curPos));\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n\nvoid sqlLiteralForObject(StringBuilder buffer, Object object) {\nif (object == null) {\nbuffer.append(\"NULL\");\n} else if (object instanceof String) {\nbuffer.append('\\'');\n\/\/ lets escape quotes\nString literal = (String) object;\nif (literal.length() > TRIM_VALUES_THRESHOLD) {\nliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n}\nint curPos = 0;\nint endPos = 0;\nwhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\nbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\ncurPos = endPos + 1;\n}\nif (curPos < literal.length())\nbuffer.append(literal.substring(curPos));\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.sql.Time) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.util.Date) {\nlong time = ((java.util.Date) object).getTime();\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\nbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n} else if (object instanceof Character) {\nbuffer.append(((Character) object).charValue());\n} else if (object instanceof Boolean) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\nbuffer.append('\\'');\n\/\/ lets escape quotes\nString literal = (String) object;\nif (literal.length() > TRIM_VALUES_THRESHOLD) {\nliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n}\nint curPos = 0;\nint endPos = 0;\nwhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\nbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\ncurPos = endPos + 1;\n}\nif (curPos < literal.length())\nbuffer.append(literal.substring(curPos));\nbuffer.append('\\'');\n}\n\/\/ handle byte pretty formatting\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.sql.Time) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.util.Date) {\nlong time = ((java.util.Date) object).getTime();\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\nbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n} else if (object instanceof Character) {\nbuffer.append(((Character) object).charValue());\n} else if (object instanceof Boolean) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\/\/ buffer.append(object.getClass().getName()).append(\".\");\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\nObject value = ((ExtendedEnumeration) object).getDatabaseValue();\n\nelse if (object instanceof Byte) {\nIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n} else if (object instanceof Number) {\n\/\/ process numeric value (do something smart in the future)\nbuffer.append(object);\n} else if (object instanceof java.sql.Date) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.sql.Time) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof java.util.Date) {\nlong time = ((java.util.Date) object).getTime();\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\nbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n} else if (object instanceof Character) {\nbuffer.append(((Character) object).charValue());\n} else if (object instanceof Boolean) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\/\/ buffer.append(object.getClass().getName()).append(\".\");\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\nObject value = ((ExtendedEnumeration) object).getDatabaseValue();\nif (value instanceof String)\nbuffer.append(\"'\");\nbuffer.append(value);\nif (value instanceof String)\nbuffer.append(\"'\");\n} else {\nbuffer.append(((Enum<?>) object).ordinal());\n\/\/ FIXME -- this isn't quite right\n}\n} else if (object instanceof SQLParameterBinding) {\nsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n} else if (object.getClass().isArray()) {\nbuffer.append(\"< \");\nint len = Array.getLength(object);\nboolean trimming = false;\nif (len > TRIM_VALUES_THRESHOLD) {\nlen = TRIM_VALUES_THRESHOLD;\n\nbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n} else if (object instanceof java.util.Calendar) {\nlong time = ((java.util.Calendar) object).getTimeInMillis();\nbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n} else if (object instanceof Character) {\nbuffer.append(((Character) object).charValue());\n} else if (object instanceof Boolean) {\nbuffer.append('\\'').append(object).append('\\'');\n} else if (object instanceof Enum<?>) {\n\/\/ buffer.append(object.getClass().getName()).append(\".\");\nbuffer.append(((Enum<?>) object).name()).append(\"=\");\nif (object instanceof ExtendedEnumeration) {\nObject value = ((ExtendedEnumeration) object).getDatabaseValue();\nif (value instanceof String)\nbuffer.append(\"'\");\nbuffer.append(value);\nif (value instanceof String)\nbuffer.append(\"'\");\n} else {\nbuffer.append(((Enum<?>) object).ordinal());\n\/\/ FIXME -- this isn't quite right\n}\n} else if (object instanceof SQLParameterBinding) {\nsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n} else if (object.getClass().isArray()) {\nbuffer.append(\"< \");\nint len = Array.getLength(object);\nboolean trimming = false;\nif (len > TRIM_VALUES_THRESHOLD) {\nlen = TRIM_VALUES_THRESHOLD;\ntrimming = true;\n}\nfor (int i = 0; i < len; i++) {\nif (i > 0) {\nbuffer.append(\",\");\n}\nsqlLiteralForObject(buffer, Array.get(object, i));\n}\nif (trimming) {\nbuffer.append(\"...\");\n}","label":[0,0,1,0]}
{"id":15851,"original_code":"protected double valueFor(Object o)\n        {\n        if (o instanceof java.lang.Number)  \/\/ compiler complains unless I include the full classname!!! Huh?\n            return ((Number)o).doubleValue();\n        else if (o instanceof Valuable)\n            return ((Valuable)o).doubleValue();\n        else if (o instanceof Boolean)\n            return ((Boolean)o).booleanValue() ? 1 : 0;\n        else return Double.NaN;  \/\/ unknown\n        }","code":"protected double valueFor(Object o)\n        {\n        if (o instanceof java.lang.Number) \n            return ((Number)o).doubleValue();\n        else if (o instanceof Valuable)\n            return ((Valuable)o).doubleValue();\n        else if (o instanceof Boolean)\n            return ((Boolean)o).booleanValue() ? 1 : 0;\n        else return Double.NaN; \n        }","cleancode":"protected double valuefor(object o) { if (o instanceof java.lang.number) return ((number)o).doublevalue(); else if (o instanceof valuable) return ((valuable)o).doublevalue(); else if (o instanceof boolean) return ((boolean)o).booleanvalue() ? 1 : 0; else return double.nan; }","comment":"\/\/ compiler complains unless i include the full classname!!! huh?\n\/\/ unknown","repo":"minhhn2910\/g-mason","code_context_2":"protected double valueFor(Object o)\n{\nif (o instanceof java.lang.Number) \/\/ compiler complains unless I include the full classname!!! Huh?\nreturn ((Number)o).doubleValue();\nelse if (o instanceof Valuable)\n\nelse if (o instanceof Boolean)\nreturn ((Boolean)o).booleanValue() ? 1 : 0;\nelse return Double.NaN; \/\/ unknown\n}","code_context_10":"protected double valueFor(Object o)\n{\nif (o instanceof java.lang.Number) \/\/ compiler complains unless I include the full classname!!! Huh?\nreturn ((Number)o).doubleValue();\nelse if (o instanceof Valuable)\nreturn ((Valuable)o).doubleValue();\nelse if (o instanceof Boolean)\nreturn ((Boolean)o).booleanValue() ? 1 : 0;\nelse return Double.NaN; \/\/ unknown\n}\n\nprotected double valueFor(Object o)\n{\nif (o instanceof java.lang.Number) \/\/ compiler complains unless I include the full classname!!! Huh?\nreturn ((Number)o).doubleValue();\nelse if (o instanceof Valuable)\nreturn ((Valuable)o).doubleValue();\nelse if (o instanceof Boolean)\nreturn ((Boolean)o).booleanValue() ? 1 : 0;\nelse return Double.NaN; \/\/ unknown\n}","code_context_20":"protected double valueFor(Object o)\n{\nif (o instanceof java.lang.Number) \/\/ compiler complains unless I include the full classname!!! Huh?\nreturn ((Number)o).doubleValue();\nelse if (o instanceof Valuable)\nreturn ((Valuable)o).doubleValue();\nelse if (o instanceof Boolean)\nreturn ((Boolean)o).booleanValue() ? 1 : 0;\nelse return Double.NaN; \/\/ unknown\n}\n\nprotected double valueFor(Object o)\n{\nif (o instanceof java.lang.Number) \/\/ compiler complains unless I include the full classname!!! Huh?\nreturn ((Number)o).doubleValue();\nelse if (o instanceof Valuable)\nreturn ((Valuable)o).doubleValue();\nelse if (o instanceof Boolean)\nreturn ((Boolean)o).booleanValue() ? 1 : 0;\nelse return Double.NaN; \/\/ unknown\n}","label":[1,0,0,0]}
{"id":24088,"original_code":"private Grid<Cuenta> createGrid() {\n\t\tgrid = new Grid<>();\n\t\tgrid.setWidthFull();\n\t\tgrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\n\t\tgrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\n        grid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\n        grid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\n        return grid;\n\t}","code":"private Grid<Cuenta> createGrid() {\n\t\tgrid = new Grid<>();\n\t\tgrid.setWidthFull();\n\t\tgrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\n\t\tgrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\n        grid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\n        grid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\n        return grid;\n\t}","cleancode":"private grid<cuenta> creategrid() { grid = new grid<>(); grid.setwidthfull(); grid.addthemevariants(gridvariant.lumo_no_border,gridvariant.lumo_row_stripes); simpledateformat dateformat = new simpledateformat(\"dd\/mm\/yyyy\"); grid.addcolumn(c -> c.getiban()).setheader(\"iban\").setflexgrow(1); grid.addcolumn(c -> c.getsaldo()).setheader(\"saldo\").setflexgrow(1); grid.addcolumn(c -> dateformat.format(c.getfechacreacion())).setheader(\"fecha creacion\").setwidth(\"250px\").setflexgrow(0); return grid; }","comment":"\/** * metodo que se encarga de crear un grid para la visualizacion de los datos de un movimiento * @return devuelve un grid con los campos para representar movimientos *\/","repo":"juansgonzalez\/ingenia-bank","code_context_2":"private Grid<Cuenta> createGrid() {\ngrid = new Grid<>();\ngrid.setWidthFull();\ngrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\ngrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\ngrid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\ngrid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\nreturn grid;\n}","code_context_10":"private Grid<Cuenta> createGrid() {\ngrid = new Grid<>();\ngrid.setWidthFull();\ngrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\ngrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\ngrid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\ngrid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\nreturn grid;\n}","code_context_20":"private Grid<Cuenta> createGrid() {\ngrid = new Grid<>();\ngrid.setWidthFull();\ngrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\nSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\ngrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\ngrid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\ngrid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\nreturn grid;\n}","label":[0,0,0,0]}
{"id":7744,"original_code":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n            \"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n            \"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n            \"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n            \"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n            \"RecyclerView is the same as what we expecting from the JSON.\")\n    @Test\n    public void hitList_isCorrect() {\n        \/\/ TODO write me\n    }","code":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n            \"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n            \"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n            \"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n            \"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n            \"RecyclerView is the same as what we expecting from the JSON.\")\n    @Test\n    public void hitList_isCorrect() {\n       \n    }","cleancode":"@ignore(\"this test was not writted due to lack of time. this is what should have been done:\\n\" + \"since this feature involves network calls, to properly unit test this it, is necessary\\n\" + \"to mock the network module and provide a fake json response. this way the test doesn't\\n\" + \"rely on an internet connection, a web service and the json response is always the same.\\n\" + \"once we have that it is possible tu use assertj-android to check if the data inside the\\n\" + \"recyclerview is the same as what we expecting from the json.\") @test public void hitlist_iscorrect() { }","comment":"\/\/ todo write me","repo":"leinardi\/Dagger2MVP","code_context_2":"@Test\npublic void hitList_isCorrect() {\n\/\/ TODO write me\n}","code_context_10":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n\"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n\"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n\"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n\"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n\"RecyclerView is the same as what we expecting from the JSON.\")\n@Test\npublic void hitList_isCorrect() {\n\/\/ TODO write me\n}","code_context_20":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n\"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n\"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n\"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n\"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n\"RecyclerView is the same as what we expecting from the JSON.\")\n@Test\npublic void hitList_isCorrect() {\n\/\/ TODO write me\n}","label":[0,1,0,0]}
{"id":24143,"original_code":"@Override\n        public boolean equals(Object obj) {\n            \/\/ TODO: come up with a better implementation of this later\n            return false;\n        }","code":"@Override\n        public boolean equals(Object obj) {\n           \n            return false;\n        }","cleancode":"@override public boolean equals(object obj) { return false; }","comment":"\/\/ todo: come up with a better implementation of this later","repo":"kaubster\/se-577-group-projects","code_context_2":"@Override\npublic boolean equals(Object obj) {\n\/\/ TODO: come up with a better implementation of this later\nreturn false;\n}","code_context_10":"@Override\npublic boolean equals(Object obj) {\n\/\/ TODO: come up with a better implementation of this later\nreturn false;\n}","code_context_20":"@Override\npublic boolean equals(Object obj) {\n\/\/ TODO: come up with a better implementation of this later\nreturn false;\n}","label":[1,0,0,0]}
{"id":7766,"original_code":"@Test\n\tpublic void testPaginate() throws Exception {\n\t\t\/\/fail(\"Test not implemented yet.\");\n\t\t\/\/TODO: do later\n\t}","code":"@Test\n\tpublic void testPaginate() throws Exception {\n\t\n\t\n\t}","cleancode":"@test public void testpaginate() throws exception { }","comment":"\/\/fail(\"test not implemented yet.\"); \/\/todo: do later","repo":"mkalus\/segrada","code_context_2":"@Test\npublic void testPaginate() throws Exception {\n\/\/fail(\"Test not implemented yet.\");\n\/\/TODO: do later\n}","code_context_10":"@Test\npublic void testPaginate() throws Exception {\n\/\/fail(\"Test not implemented yet.\");\n\/\/TODO: do later\n}","code_context_20":"@Test\npublic void testPaginate() throws Exception {\n\/\/fail(\"Test not implemented yet.\");\n\/\/TODO: do later\n}","label":[0,0,0,1]}
{"id":7935,"original_code":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\t\t\/\/ WARNING\n\t\t\/\/ INCOMPLETE see processSubtypeConstraints\n\t\tTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\n\t\tFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\n\t\tView view = RRef.view();\n\t\tTypeReference SprimeRef = box(Sref);\n\t\tJava7 java = view.language(Java7.class);\n\t\tif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\t\t  \/\/ the constraint S >> R', provided R is not void\t\n\t\t\tTypeReference RprimeRef = substitutedReference(RRef);\n\t\t\tconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n\t\t}\n\t\t\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\n\t\tfor(TypeParameter param: typeParameters()) {\n\t\t\tTypeReference Bi = param.upperBoundReference();\n\t\t\tTypeReference BiAfterSubstitution = substitutedReference(Bi);\n\t\t\tType Ti = (Type) param.selectionDeclaration();\n\t\t\tType BTi = assignments().type(param);\n\t\t\tif(BTi == null) {\n\t\t\t\tBTi = Ti;\n\t\t\t}\n\t\t\tconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\n\t\t\tconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n\t\t}\n\t\tfor(GGConstraint constraint: _origin.generatedGG()) {\n\t\t\tconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tfor(EQConstraint constraint: _origin.generatedEQ()) {\n\t\t\tconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\t\t\/\/ JLS: Any equality constraints are resolved ...\n\t\tseconds.processEqualityConstraints();\n\t\t\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\t\t\/\/      Ti is inferred to be glb(U1,...,Uk)\n\t\tseconds.processSubtypeConstraints();\n\t\t\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\t\t\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\t\t\/\/ inferred to be P [T =Object ].\n\t\tfor(TypeParameter param: seconds.unresolvedParameters()) {\n\t\t\tseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n\t\t}\n  \t\/\/FIXME Perform substitution\n\t\tfor(TypeParameter param: unresolvedParameters()) {\n\t\t\tadd(seconds.assignments().assignment(param));\n\t\t}\n\t}","code":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\t\n\t\n\t\tTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\n\t\tFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\n\t\tView view = RRef.view();\n\t\tTypeReference SprimeRef = box(Sref);\n\t\tJava7 java = view.language(Java7.class);\n\t\tif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\t\t \n\t\t\tTypeReference RprimeRef = substitutedReference(RRef);\n\t\t\tconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n\t\t}\n\t\n\t\tfor(TypeParameter param: typeParameters()) {\n\t\t\tTypeReference Bi = param.upperBoundReference();\n\t\t\tTypeReference BiAfterSubstitution = substitutedReference(Bi);\n\t\t\tType Ti = (Type) param.selectionDeclaration();\n\t\t\tType BTi = assignments().type(param);\n\t\t\tif(BTi == null) {\n\t\t\t\tBTi = Ti;\n\t\t\t}\n\t\t\tconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\n\t\t\tconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n\t\t}\n\t\tfor(GGConstraint constraint: _origin.generatedGG()) {\n\t\t\tconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tfor(EQConstraint constraint: _origin.generatedEQ()) {\n\t\t\tconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\t\n\t\tseconds.processEqualityConstraints();\n\t\n\t\n\t\tseconds.processSubtypeConstraints();\n\t\n\t\n\t\n\t\tfor(TypeParameter param: seconds.unresolvedParameters()) {\n\t\t\tseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n\t\t}\n  \n\t\tfor(TypeParameter param: unresolvedParameters()) {\n\t\t\tadd(seconds.assignments().assignment(param));\n\t\t}\n\t}","cleancode":"private void processunresolved(typereference sref) throws lookupexception { typereference rref = (typereference) invokedgenericmethod().returntypereference(); firstphaseconstraintset constraints = new firstphaseconstraintset(invocation(), invokedgenericmethod()); view view = rref.view(); typereference sprimeref = box(sref); java7 java = view.language(java7.class); if(! rref.getelement().sameas(java.voidtype(rref.view().namespace()))) { typereference rprimeref = substitutedreference(rref); constraints.add(new ggconstraint(sprimeref, rprimeref.getelement())); } for(typeparameter param: typeparameters()) { typereference bi = param.upperboundreference(); typereference biaftersubstitution = substitutedreference(bi); type ti = (type) param.selectiondeclaration(); type bti = assignments().type(param); if(bti == null) { bti = ti; } constraints.add(new ggconstraint(biaftersubstitution, ti)); constraints.add(new ssconstraint(java.reference(bti), biaftersubstitution.getelement())); } for(ggconstraint constraint: _origin.generatedgg()) { constraints.add(new ggconstraint(substitutedreference(constraint.aref()), constraint.f())); } for(eqconstraint constraint: _origin.generatedeq()) { constraints.add(new eqconstraint(substitutedreference(constraint.aref()), constraint.f())); } secondphaseconstraintset seconds = constraints.secondphase(); seconds.processequalityconstraints(); seconds.processsubtypeconstraints(); for(typeparameter param: seconds.unresolvedparameters()) { seconds.add(new actualtypeassignment(param, java.getdefaultsuperclass(view.namespace()))); } for(typeparameter param: unresolvedparameters()) { add(seconds.assignments().assignment(param)); } }","comment":"\/\/ warning \/\/ incomplete see processsubtypeconstraints\n\/\/ the constraint s >> r', provided r is not void\n\/\/ additional constraints bi[t1=b(t1) ... tn=b(tn)] >> ti where bi is the declared bound of ti\n\/\/ jls: any equality constraints are resolved ...\n\/\/ jls: ..., and then, for each remaining constraint of the form ti <: uk, the argument \/\/ ti is inferred to be glb(u1,...,uk)\n\/\/any remaining type variable t that has not yet been inferred is then inferred \/\/ to have type object . if a previously inferred type variable p uses t , then p is \/\/ inferred to be p [t =object ].\n\/\/fixme perform substitution","repo":"markovandooren\/jnome","code_context_2":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\n\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\n\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));","code_context_10":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\nprivate void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\n\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}\n\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}","code_context_20":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\n\nprivate void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\nprivate void processUnresolved(TypeReference Sref) throws LookupException {\n\/\/ WARNING\n\/\/ INCOMPLETE see processSubtypeConstraints\nTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\nFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\nView view = RRef.view();\nTypeReference SprimeRef = box(Sref);\nJava7 java = view.language(Java7.class);\nif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\/\/ the constraint S >> R', provided R is not void\nTypeReference RprimeRef = substitutedReference(RRef);\nconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\n}\n\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}\n\nfor(TypeParameter param: typeParameters()) {\nTypeReference Bi = param.upperBoundReference();\nTypeReference BiAfterSubstitution = substitutedReference(Bi);\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}\n\nType Ti = (Type) param.selectionDeclaration();\nType BTi = assignments().type(param);\nif(BTi == null) {\nBTi = Ti;\n}\nconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}\n\nconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n}\nfor(GGConstraint constraint: _origin.generatedGG()) {\nconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nfor(EQConstraint constraint: _origin.generatedEQ()) {\nconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n}\nSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\/\/ JLS: Any equality constraints are resolved ...\nseconds.processEqualityConstraints();\n\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\/\/ Ti is inferred to be glb(U1,...,Uk)\nseconds.processSubtypeConstraints();\n\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\/\/ inferred to be P [T =Object ].\nfor(TypeParameter param: seconds.unresolvedParameters()) {\nseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n}\n\/\/FIXME Perform substitution\nfor(TypeParameter param: unresolvedParameters()) {\nadd(seconds.assignments().assignment(param));\n}\n}","label":[0,1,0,0]}

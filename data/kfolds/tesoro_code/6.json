{"id":22,"original_code":"public boolean usesRegs() {\n        \/\/ FIXME: this is almost certainly boned.  a Reg could appear in the\n        \/\/ address expressions.\n        for (int i=0;i<rhs().length;++i) {\n            if (usesDirectly(i) && rhs()[i] instanceof Reg) {\n                return true;\n            }\n        }\n        if (opcode.form().implicitUses(head().code()).length!=0) {\n            return true;\n        }\n        return false;\n    }","code_wo_comment":"public boolean usesRegs() {\n       \n       \n        for (int i=0;i<rhs().length;++i) {\n            if (usesDirectly(i) && rhs()[i] instanceof Reg) {\n                return true;\n            }\n        }\n        if (opcode.form().implicitUses(head().code()).length!=0) {\n            return true;\n        }\n        return false;\n    }","cleancode":"public boolean usesregs() { for (int i=0;i<rhs().length;++i) { if (usesdirectly(i) && rhs()[i] instanceof reg) { return true; } } if (opcode.form().implicituses(head().code()).length!=0) { return true; } return false; }","repo":"mihirlibran\/cse605","label":[0,0,1,0]}
{"id":83,"original_code":"@Test\n    public void parseNegativeIntegerLiteral(\n    ) throws ExpressionException {\n        LineSpecifier ls = new LineSpecifier(0, 10);\n        Locale locale = new Locale(ls, 10);\n        ExpressionParser parser = new ExpressionParser(\"-14458\", locale);\n        Expression exp = parser.parse(new Assembler.Builder().build());\n        assertEquals(2, exp._items.size());\n        ExpressionItem item0 = exp._items.get(0);\n        assertTrue(item0 instanceof OperatorItem);\n\/\/        Operator op = ((OperatorItem) item0)._operator; \/\/  TODO check this value if we can, somehow\n        ExpressionItem item1 = exp._items.get(1);\n        assertTrue(item1 instanceof ValueItem);\n        Value v1 = ((ValueItem)item1)._value;\n        assertTrue(v1 instanceof IntegerValue);\n        assertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n    }","code_wo_comment":"@Test\n    public void parseNegativeIntegerLiteral(\n    ) throws ExpressionException {\n        LineSpecifier ls = new LineSpecifier(0, 10);\n        Locale locale = new Locale(ls, 10);\n        ExpressionParser parser = new ExpressionParser(\"-14458\", locale);\n        Expression exp = parser.parse(new Assembler.Builder().build());\n        assertEquals(2, exp._items.size());\n        ExpressionItem item0 = exp._items.get(0);\n        assertTrue(item0 instanceof OperatorItem);\n        ExpressionItem item1 = exp._items.get(1);\n        assertTrue(item1 instanceof ValueItem);\n        Value v1 = ((ValueItem)item1)._value;\n        assertTrue(v1 instanceof IntegerValue);\n        assertEquals(14458L, ((IntegerValue)v1)._value.get().longValue());\n    }","cleancode":"@test public void parsenegativeintegerliteral( ) throws expressionexception { linespecifier ls = new linespecifier(0, 10); locale locale = new locale(ls, 10); expressionparser parser = new expressionparser(\"-14458\", locale); expression exp = parser.parse(new assembler.builder().build()); assertequals(2, exp._items.size()); expressionitem item0 = exp._items.get(0); asserttrue(item0 instanceof operatoritem); expressionitem item1 = exp._items.get(1); asserttrue(item1 instanceof valueitem); value v1 = ((valueitem)item1)._value; asserttrue(v1 instanceof integervalue); assertequals(14458l, ((integervalue)v1)._value.get().longvalue()); }","repo":"kduncan99\/em2200-java","label":[1,0,0,0]}
{"id":118,"original_code":"@Override\n    public void onLocationChanged(Location location) {\n        mLocation = location;\n        if (mLocation != null) {\n            \/\/ Bug report: cached GeoPoint is being returned as the first value.\n            \/\/ Wait for the 2nd value to be returned, which is hopefully not cached?\n            ++mLocationCount;\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") lat: \" +\n                    mLocation.getLatitude() + \" long: \" +\n                    mLocation.getLongitude() + \" acc: \" +\n                    mLocation.getAccuracy());\n            if (mLocationCount > 1) {\n                mLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\n                        mLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\n                if (mLocation.getAccuracy() <= mLocationAccuracy) {\n                    returnLocation();\n                }\n            }\n        } else {\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") null location\");\n        }\n    }","code_wo_comment":"@Override\n    public void onLocationChanged(Location location) {\n        mLocation = location;\n        if (mLocation != null) {\n           \n           \n            ++mLocationCount;\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") lat: \" +\n                    mLocation.getLatitude() + \" long: \" +\n                    mLocation.getLongitude() + \" acc: \" +\n                    mLocation.getAccuracy());\n            if (mLocationCount > 1) {\n                mLocationDialog.setMessage(getString(R.string.location_provider_accuracy,\n                        mLocation.getProvider(), truncateDouble(mLocation.getAccuracy())));\n                if (mLocation.getAccuracy() <= mLocationAccuracy) {\n                    returnLocation();\n                }\n            }\n        } else {\n            InfoLogger.geolog(\"GeoPointActivity: \" + System.currentTimeMillis() +\n                    \" onLocationChanged(\" + mLocationCount + \") null location\");\n        }\n    }","cleancode":"@override public void onlocationchanged(location location) { mlocation = location; if (mlocation != null) { ++mlocationcount; infologger.geolog(\"geopointactivity: \" + system.currenttimemillis() + \" onlocationchanged(\" + mlocationcount + \") lat: \" + mlocation.getlatitude() + \" long: \" + mlocation.getlongitude() + \" acc: \" + mlocation.getaccuracy()); if (mlocationcount > 1) { mlocationdialog.setmessage(getstring(r.string.location_provider_accuracy, mlocation.getprovider(), truncatedouble(mlocation.getaccuracy()))); if (mlocation.getaccuracy() <= mlocationaccuracy) { returnlocation(); } } } else { infologger.geolog(\"geopointactivity: \" + system.currenttimemillis() + \" onlocationchanged(\" + mlocationcount + \") null location\"); } }","repo":"jorgepsendziuk\/novo_coletor","label":[0,0,1,0]}
{"id":32955,"original_code":"@Deprecated\n    public FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\n        Yaml yaml = new Yaml();\n        LinkedHashMap swaggerFile =  yaml.load(FileUtils.openInputStream(spec));\n        String groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\n        String artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\n        String artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\n        String groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\n        StringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\n        artifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\n        CodegenConfigurator configurator = new CodegenConfigurator();\n        String artifactId = artifactIdSb.toString();\n        initializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\n        configurator.setArtifactVersionApi(artifactVersionApi);\n        return getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n    }","code_wo_comment":"@Deprecated\n    public FileDataSource generatePythonImpl(File spec, String artifactName, String groupId, String artifactVersion, String implemName) throws Exception {\n        Yaml yaml = new Yaml();\n        LinkedHashMap swaggerFile =  yaml.load(FileUtils.openInputStream(spec));\n        String groupIdApi = getPropInSwaggerFile(swaggerFile, \"x-groupId\");\n        String artifactNameApi = getPropInSwaggerFile(swaggerFile, \"x-artifactName\");\n        String artifactVersionApi = getPropInSwaggerFile(swaggerFile, \"version\");\n        String groupName = groupId.substring(groupId.lastIndexOf('.') + 1);\n        StringBuilder artifactIdSb = new StringBuilder().append(groupName).append(\"-\").append(artifactNameApi).append(\"-\");\n        artifactIdSb.append(artifactName.replaceAll(\"-\",\"\"));\n        CodegenConfigurator configurator = new CodegenConfigurator();\n        String artifactId = artifactIdSb.toString();\n        initializeConfigurator(spec, \"KathraPython\", artifactNameApi, groupIdApi, artifactVersion, \"implem\", artifactId, configurator);\n        configurator.setArtifactVersionApi(artifactVersionApi);\n        return getFileDataSource(spec, \"implem\", artifactIdSb, artifactId, configurator);\n    }","cleancode":"@deprecated public filedatasource generatepythonimpl(file spec, string artifactname, string groupid, string artifactversion, string implemname) throws exception { yaml yaml = new yaml(); linkedhashmap swaggerfile = yaml.load(fileutils.openinputstream(spec)); string groupidapi = getpropinswaggerfile(swaggerfile, \"x-groupid\"); string artifactnameapi = getpropinswaggerfile(swaggerfile, \"x-artifactname\"); string artifactversionapi = getpropinswaggerfile(swaggerfile, \"version\"); string groupname = groupid.substring(groupid.lastindexof('.') + 1); stringbuilder artifactidsb = new stringbuilder().append(groupname).append(\"-\").append(artifactnameapi).append(\"-\"); artifactidsb.append(artifactname.replaceall(\"-\",\"\")); codegenconfigurator configurator = new codegenconfigurator(); string artifactid = artifactidsb.tostring(); initializeconfigurator(spec, \"kathrapython\", artifactnameapi, groupidapi, artifactversion, \"implem\", artifactid, configurator); configurator.setartifactversionapi(artifactversionapi); return getfiledatasource(spec, \"implem\", artifactidsb, artifactid, configurator); }","repo":"kathra-project\/kathra-codegen-swagger","label":[1,0,0,0]}
{"id":16627,"original_code":"public void checkList()\n\t{\n\t\tif(observed.size() != cachedSize)\n\t\t{\n\t\t\tcachedSize = observed.size();\n\t\t\tlistUpdated();\n\t\t}\n\t}","code_wo_comment":"public void checkList()\n\t{\n\t\tif(observed.size() != cachedSize)\n\t\t{\n\t\t\tcachedSize = observed.size();\n\t\t\tlistUpdated();\n\t\t}\n\t}","cleancode":"public void checklist() { if(observed.size() != cachedsize) { cachedsize = observed.size(); listupdated(); } }","repo":"justin-espedal\/polydes","label":[0,0,1,0]}
{"id":16754,"original_code":"@Override\n        public boolean isReferenceTo(PsiElement psiElement) {\n            if(!(psiElement instanceof PhpNamedElement)) {\n                return false;\n            }\n            String text = getElement().getText();\n            if(StringUtils.isBlank(text)) {\n                return false;\n            }\n            PsiElement namespace = element.getPrevSibling();\n            if(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n                \/\/ @TODO: namespace not supported\n                return false;\n            }\n            String classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\n            if(classByContext != null) {\n                return StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n                    .equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n            }\n            return false;\n        }","code_wo_comment":"@Override\n        public boolean isReferenceTo(PsiElement psiElement) {\n            if(!(psiElement instanceof PhpNamedElement)) {\n                return false;\n            }\n            String text = getElement().getText();\n            if(StringUtils.isBlank(text)) {\n                return false;\n            }\n            PsiElement namespace = element.getPrevSibling();\n            if(PhpPsiUtil.isOfType(namespace, PhpDocTokenTypes.DOC_NAMESPACE)) {\n               \n                return false;\n            }\n            String classByContext = PhpElementsUtil.getFqnForClassNameByContext(element, text);\n            if(classByContext != null) {\n                return StringUtils.stripStart(((PhpNamedElement) psiElement).getFQN(), \"\\\\\")\n                    .equalsIgnoreCase(StringUtils.stripStart(fqn, \"\\\\\"));\n            }\n            return false;\n        }","cleancode":"@override public boolean isreferenceto(psielement psielement) { if(!(psielement instanceof phpnamedelement)) { return false; } string text = getelement().gettext(); if(stringutils.isblank(text)) { return false; } psielement namespace = element.getprevsibling(); if(phppsiutil.isoftype(namespace, phpdoctokentypes.doc_namespace)) { return false; } string classbycontext = phpelementsutil.getfqnforclassnamebycontext(element, text); if(classbycontext != null) { return stringutils.stripstart(((phpnamedelement) psielement).getfqn(), \"\\\\\") .equalsignorecase(stringutils.stripstart(fqn, \"\\\\\")); } return false; }","repo":"meyerbaptiste\/idea-php-annotation-plugin","label":[0,1,0,0]}
{"id":16808,"original_code":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\n        MDCBuilder.buildMdcContext(stack);\n        String environmentCrn = stack.getEnvironmentCrn();\n        Multimap<String, String> warnings = ArrayListMultimap.create();\n        try {\n            FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n            UsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\n            stateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\n            retrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\n            if (options.isFullSync()) {\n                \/\/ TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\n                if (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\n                    cloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\n                    LOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n                }\n                if (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\n                    try {\n                        sudoRuleService.setupSudoRule(stack, freeIpaClient);\n                    } catch (Exception e) {\n                        warnings.put(stack.getEnvironmentCrn(), e.getMessage());\n                        LOGGER.error(\"{} failed for environment '{}'.\", ADD_SUDO_RULES, stack.getEnvironmentCrn(), e);\n                    }\n                    LOGGER.debug(\"Finished {}.\", ADD_SUDO_RULES);\n                }\n            }\n            return toSyncStatusDetail(environmentCrn, warnings);\n        } catch (TimeoutException e) {\n            LOGGER.warn(\"Timed out while synchronizing environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, \"Timed out\", warnings);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to synchronize environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, e.getLocalizedMessage(), warnings);\n        }\n    }","code_wo_comment":"public SyncStatusDetail synchronizeStack(Stack stack, UmsUsersState umsUsersState, UserSyncOptions options) {\n        MDCBuilder.buildMdcContext(stack);\n        String environmentCrn = stack.getEnvironmentCrn();\n        Multimap<String, String> warnings = ArrayListMultimap.create();\n        try {\n            FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n            UsersStateDifference usersStateDifferenceBeforeSync = compareUmsAndFreeIpa(umsUsersState, options, freeIpaClient);\n            stateApplier.applyDifference(umsUsersState, environmentCrn, warnings, usersStateDifferenceBeforeSync, options, freeIpaClient);\n            retrySyncIfBatchCallHasWarnings(stack, umsUsersState, warnings, options, freeIpaClient, usersStateDifferenceBeforeSync);\n            if (options.isFullSync()) {\n               \n                if (entitlementService.cloudIdentityMappingEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", SYNC_CLOUD_IDENTITIES);\n                    cloudIdentitySyncService.syncCloudIdentities(stack, umsUsersState, warnings::put);\n                    LOGGER.debug(\"Finished {}.\", SYNC_CLOUD_IDENTITIES);\n                }\n                if (entitlementService.isEnvironmentPrivilegedUserEnabled(stack.getAccountId())) {\n                    LOGGER.debug(\"Starting {} ...\", ADD_SUDO_RULES);\n                    try {\n                        sudoRuleService.setupSudoRule(stack, freeIpaClient);\n                    } catch (Exception e) {\n                        warnings.put(stack.getEnvironmentCrn(), e.getMessage());\n                        LOGGER.error(\"{} failed for environment '{}'.\", ADD_SUDO_RULES, stack.getEnvironmentCrn(), e);\n                    }\n                    LOGGER.debug(\"Finished {}.\", ADD_SUDO_RULES);\n                }\n            }\n            return toSyncStatusDetail(environmentCrn, warnings);\n        } catch (TimeoutException e) {\n            LOGGER.warn(\"Timed out while synchronizing environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, \"Timed out\", warnings);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to synchronize environment {}\", environmentCrn, e);\n            return SyncStatusDetail.fail(environmentCrn, e.getLocalizedMessage(), warnings);\n        }\n    }","cleancode":"public syncstatusdetail synchronizestack(stack stack, umsusersstate umsusersstate, usersyncoptions options) { mdcbuilder.buildmdccontext(stack); string environmentcrn = stack.getenvironmentcrn(); multimap<string, string> warnings = arraylistmultimap.create(); try { freeipaclient freeipaclient = freeipaclientfactory.getfreeipaclientforstack(stack); usersstatedifference usersstatedifferencebeforesync = compareumsandfreeipa(umsusersstate, options, freeipaclient); stateapplier.applydifference(umsusersstate, environmentcrn, warnings, usersstatedifferencebeforesync, options, freeipaclient); retrysyncifbatchcallhaswarnings(stack, umsusersstate, warnings, options, freeipaclient, usersstatedifferencebeforesync); if (options.isfullsync()) { if (entitlementservice.cloudidentitymappingenabled(stack.getaccountid())) { logger.debug(\"starting {} ...\", sync_cloud_identities); cloudidentitysyncservice.synccloudidentities(stack, umsusersstate, warnings::put); logger.debug(\"finished {}.\", sync_cloud_identities); } if (entitlementservice.isenvironmentprivilegeduserenabled(stack.getaccountid())) { logger.debug(\"starting {} ...\", add_sudo_rules); try { sudoruleservice.setupsudorule(stack, freeipaclient); } catch (exception e) { warnings.put(stack.getenvironmentcrn(), e.getmessage()); logger.error(\"{} failed for environment '{}'.\", add_sudo_rules, stack.getenvironmentcrn(), e); } logger.debug(\"finished {}.\", add_sudo_rules); } } return tosyncstatusdetail(environmentcrn, warnings); } catch (timeoutexception e) { logger.warn(\"timed out while synchronizing environment {}\", environmentcrn, e); return syncstatusdetail.fail(environmentcrn, \"timed out\", warnings); } catch (exception e) { logger.warn(\"failed to synchronize environment {}\", environmentcrn, e); return syncstatusdetail.fail(environmentcrn, e.getlocalizedmessage(), warnings); } }","repo":"mdvtlp\/cloudbreak","label":[0,1,0,0]}
{"id":25017,"original_code":"public static String obtainProcessID() {\n\t\t\/\/get process id\n\t\tString pname = ManagementFactory.getRuntimeMXBean().getName(); \/\/pid@hostname\n\t\tString pid = pname.split(\"@\")[0];\n\t\t\/\/ TODO: change this as soon as we switch to a java version >= 9\n\t\t\/\/ import java.lang.ProcessHandle;\n\t\t\/\/ pid = ProcessHandle.current().pid();\n\t\treturn pid;\n\t}","code_wo_comment":"public static String obtainProcessID() {\n\t\n\t\tString pname = ManagementFactory.getRuntimeMXBean().getName();\n\t\tString pid = pname.split(\"@\")[0];\n\t\n\t\n\t\n\t\treturn pid;\n\t}","cleancode":"public static string obtainprocessid() { string pname = managementfactory.getruntimemxbean().getname(); string pid = pname.split(\"@\")[0]; return pid; }","repo":"mgd-hin\/systemds","label":[1,0,0,0]}
{"id":16892,"original_code":"public static LeXeMerger build(String pathToMergeSchema) {\n        if (builder == null) {\n            builder = new GenericLexemeBuilder();\n        }\n        return builder.build(pathToMergeSchema);\n    }","code_wo_comment":"public static LeXeMerger build(String pathToMergeSchema) {\n        if (builder == null) {\n            builder = new GenericLexemeBuilder();\n        }\n        return builder.build(pathToMergeSchema);\n    }","cleancode":"public static lexemerger build(string pathtomergeschema) { if (builder == null) { builder = new genericlexemebuilder(); } return builder.build(pathtomergeschema); }","repo":"maybeec\/lexeme","label":[0,0,0,0]}
{"id":16946,"original_code":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\n                                          String controlFileName,\n                                          String testGroupID,\n                                          String oneTestID,\n                                          Map<String, ServiceResult> serviceResultsMap,\n                                          boolean param_autoDeletePOSTS,\n                                          Dump dump,\n                                          String protoHostPortParam,\n                                          AuthsMap defaultAuths,\n                                          List<String> reportsList,\n                                          String reportsDir)\n                                          throws Exception {\n        \/\/Internally, we maintain two collections of ServiceResult:\n        \/\/  the first is the return value of this method.\n        \/\/  the second is the serviceResultsMap, which is used for keeping track of CSIDs created by POSTs, for later reference by DELETE, etc.\n        List<ServiceResult> results = new ArrayList<ServiceResult>();\n        XmlReplayReport report = new XmlReplayReport(reportsDir);\n        String controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\n        org.dom4j.Document document;\n        document = getDocument(controlFile); \/\/will check full path first, then checks relative to PWD.\n        if (document==null){\n            throw new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n        }\n        String protoHostPort;\n        if (Tools.isEmpty(protoHostPortParam)){\n            protoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\n            System.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n        } else {\n            protoHostPort = protoHostPortParam;\n        }\n        if (Tools.isEmpty(protoHostPort)){\n            throw new Exception(\"XmlReplay control file must have a protoHostPort element\");\n        }\n        String authsMapINFO;\n        AuthsMap authsMap = readAuths(document);\n        if (authsMap.map.size()==0){\n            authsMap = defaultAuths;\n            authsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n        } else {\n            authsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n        }\n        report.addTestGroup(testGroupID, controlFileName);   \/\/controlFileName is just the short name, without the full path.\n        String xmlReplayHeader = \"========================================================================\"\n                          +\"\\r\\nXmlReplay running:\"\n                          +\"\\r\\n   controlFile: \"+ (new File(controlFile).getCanonicalPath())\n                          +\"\\r\\n   protoHostPort: \"+protoHostPort\n                          +\"\\r\\n   testGroup: \"+testGroupID\n                          + (Tools.notEmpty(oneTestID) ? \"\\r\\n   oneTestID: \"+oneTestID : \"\")\n                          +\"\\r\\n   AuthsMap: \"+authsMapINFO\n                          +\"\\r\\n   param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n                          +\"\\r\\n   Dump info: \"+dump\n                          +\"\\r\\n========================================================================\"\n                          +\"\\r\\n\";\n        report.addRunInfo(xmlReplayHeader);\n        System.out.println(xmlReplayHeader);\n        String autoDeletePOSTS = \"\";\n        List<Node> testgroupNodes;\n        if (Tools.notEmpty(testGroupID)){\n            testgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n        } else {\n            testgroupNodes = document.selectNodes(\"\/\/testGroup\");\n        }\n        JexlEngine jexl = new JexlEngine();   \/\/ Used for expression language expansion from uri field.\n        XmlReplayEval evalStruct = new XmlReplayEval();\n        evalStruct.serviceResultsMap = serviceResultsMap;\n        evalStruct.jexl = jexl;\n        for (Node testgroup : testgroupNodes) {\n            XmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys();\/\/MapContext();  \/\/Get a new JexlContext for each test group.\n            evalStruct.jc = jc;\n            autoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\n            List<Node> tests;\n            if (Tools.notEmpty(oneTestID)){\n                tests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n            } else {\n                tests = testgroup.selectNodes(\"test\");\n            }\n            String authForTest = \"\";\n            int testElementIndex = -1;\n            for (Node testNode : tests) {\n                long startTime = System.currentTimeMillis();\n                try {\n                    testElementIndex++;\n                    String testID = testNode.valueOf(\"@ID\");\n                    \/\/\n                    \/\/ Figure out if we will auto delete resources\n                    boolean autoDelete = param_autoDeletePOSTS;\n                    String autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\n                    if (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\n                    \tautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n                    }\n                    String testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\n                    String method = testNode.valueOf(\"method\");\n                    String contentType = testNode.valueOf(\"contentType\");\n                    String uri = testNode.valueOf(\"uri\");\n                    String fullURL = Tools.glue(protoHostPort, \"\/\", uri);\n                    if (contentType == null || contentType.equals(\"\")) {\n                        contentType = XmlReplayTransport.APPLICATION_XML;\n                    }\n                    String currentAuthForTest = null;\n                    String authIDForTest = testNode.valueOf(\"@auth\");\n                    if (Tools.notEmpty(authIDForTest)){\n                        currentAuthForTest = authsMap.map.get(authIDForTest);\n                    }\n                    else {\n                        String tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\n                        if (Tools.notEmpty(tokenAuthExpression)){\n                            currentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n                        }\n                    }\n                    if (Tools.notEmpty(currentAuthForTest)){\n                        authForTest = currentAuthForTest; \/\/else just run with current from last loop;\n                    }\n                    if (Tools.isEmpty(authForTest)){\n                        authForTest = defaultAuths.getDefaultAuth();\n                    }\n                    if (uri.indexOf(\"$\")>-1){\n                        uri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n                    }\n                    fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    List<Integer> expectedCodes = new ArrayList<Integer>();\n                    String expectedCodesStr = testNode.valueOf(\"expectedCodes\");\n                    if (Tools.notEmpty(expectedCodesStr)){\n                         String[] codesArray = expectedCodesStr.split(\",\");\n                         for (String code : codesArray){\n                             expectedCodes.add(new Integer(code.trim()));\n                         }\n                    }\n                    Node responseNode = testNode.selectSingleNode(\"response\");\n                    PartsStruct expectedResponseParts = null;\n                    if (responseNode!=null){\n                        expectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n                        \/\/System.out.println(\"reponse parts: >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"+expectedResponseParts);\n                    }\n                    ServiceResult serviceResult;\n                    boolean isPOST = method.equalsIgnoreCase(\"POST\");\n                    boolean isPUT =  method.equalsIgnoreCase(\"PUT\");\n                    if ( isPOST || isPUT ) {\n                        PartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\n                        if (Tools.notEmpty(parts.overrideTestID)) {\n                            testID = parts.overrideTestID;\n                        }\n                        if (isPOST){\n                            String csid = CSIDfromTestID(testNode, serviceResultsMap);\n                            if (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n                        } else if (isPUT) {\n                            uri = fromTestID(uri, testNode, serviceResultsMap);\n                        }\n                        \/\/vars only make sense in two contexts: POST\/PUT, because you are submitting another file with internal expressions,\n                        \/\/ and in <response> nodes. For GET, DELETE, there is no payload, so all the URLs with potential expressions are right there in the testNode.\n                        Map<String,String> vars = null;\n                        if (parts.varsList.size()>0){\n                            vars = parts.varsList.get(0);\n                        }\n                        serviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\n                        serviceResult.autoDelete = autoDelete;\n                        if (vars!=null) {\n                            serviceResult.addVars(vars);\n                        }\n                        results.add(serviceResult);\n                        \/\/if (isPOST){\n                            serviceResultsMap.put(testID, serviceResult);      \/\/PUTs do not return a Location, so don't add PUTs to serviceResultsMap.\n                        \/\/}\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    } else if (method.equalsIgnoreCase(\"DELETE\")){\n                        String fromTestID = testNode.valueOf(\"fromTestID\");\n                        ServiceResult pr = serviceResultsMap.get(fromTestID);\n                        if (pr!=null){\n                            serviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\n                            serviceResult.fromTestID = fromTestID;\n                            if (expectedCodes.size()>0){\n                                serviceResult.expectedCodes = expectedCodes;\n                            }\n                            results.add(serviceResult);\n                            if (serviceResult.codeInSuccessRange(serviceResult.responseCode)){  \/\/gotExpectedResult depends on serviceResult.expectedCodes.\n                                serviceResultsMap.remove(fromTestID);\n                            }\n                        } else {\n                            if (Tools.notEmpty(fromTestID)){\n                                serviceResult = new ServiceResult();\n                                serviceResult.responseCode = 0;\n                                serviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\n                                System.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n                            } else {\n                                serviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n                            }\n                            serviceResult.fromTestID = fromTestID;\n                            results.add(serviceResult);\n                        }\n                    } else if (method.equalsIgnoreCase(\"GET\")){\n                        fullURL = fromTestID(fullURL, testNode, serviceResultsMap);\n                        serviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else if (method.equalsIgnoreCase(\"LIST\")){\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                        String listQueryParams = \"\"; \/\/TODO: empty for now, later may pick up from XML control file.\n                        serviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else {\n                        throw new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n                    }\n                    serviceResult.testID = testID;\n                    serviceResult.fullURL = fullURL;\n                    serviceResult.auth = authForTest;\n                    serviceResult.method = method;\n                    if (expectedCodes.size()>0){\n                        serviceResult.expectedCodes = expectedCodes;\n                    }\n                    if (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\n                    if (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\n                    Node expectedLevel = testNode.selectSingleNode(\"response\/expected\");\n                    if (expectedLevel!=null){\n                        String level = expectedLevel.valueOf(\"@level\");\n                        serviceResult.payloadStrictness = level;\n                    }\n                    \/\/=====================================================\n                    \/\/  ALL VALIDATION FOR ALL REQUESTS IS DONE HERE:\n                    \/\/=====================================================\n                    boolean hasError = false;\n                    String vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\n                    if (Tools.notEmpty(vError)){\n                        serviceResult.error = vError;\n                        serviceResult.failureReason = \" : VALIDATION ERROR; \";\n                        hasError = true;\n                    }\n                    if (hasError == false){\n                        hasError = ! serviceResult.gotExpectedResult();\n                    }\n                    boolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\n                    String serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\n                    String leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\n                    report.addTestResult(serviceResult);\n                    if (   (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n                        || (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full)         ){\n                        System.out.println(\"\\r\\n#---------------------#\");\n                    }\n                    System.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\n                    if (dump.payloads || (doingAuto&&hasError) ) {\n                        if (Tools.notBlank(serviceResult.requestPayload)){\n                            System.out.println(\"\\r\\n========== request payload ===============\");\n                            System.out.println(serviceResult.requestPayload);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                    if (dump.payloads || (doingAuto&&hasError)) {\n                        if (Tools.notBlank(serviceResult.result)){\n                            System.out.println(\"\\r\\n========== response payload ==============\");\n                            System.out.println(serviceResult.result);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                } catch (Throwable t) {\n                    String msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\n                    System.out.println(msg);\n                    System.out.println(Tools.getStackTrace(t));\n                    ServiceResult serviceResult = new ServiceResult();\n                    serviceResult.error = msg;\n                    serviceResult.failureReason = \" : SYSTEM ERROR; \";\n                    results.add(serviceResult);\n                }\n            }\n            if (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\n                autoDelete(serviceResultsMap, \"default\", 0);\n            }\n        }\n        \/\/=== Now spit out the HTML report file ===\n        File m = new File(controlFileName);\n        String localName = m.getName();\/\/don't instantiate, just use File to extract file name without directory.\n        String reportName = localName+'-'+testGroupID+\".html\";\n        File resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\n        if (resultFile!=null) {\n            String toc = report.getTOC(reportName);\n            reportsList.add(toc);\n        }\n        \/\/================================\n        return results;\n    }","code_wo_comment":"public static List<ServiceResult> runXmlReplayFile(String xmlReplayBaseDir,\n                                          String controlFileName,\n                                          String testGroupID,\n                                          String oneTestID,\n                                          Map<String, ServiceResult> serviceResultsMap,\n                                          boolean param_autoDeletePOSTS,\n                                          Dump dump,\n                                          String protoHostPortParam,\n                                          AuthsMap defaultAuths,\n                                          List<String> reportsList,\n                                          String reportsDir)\n                                          throws Exception {\n       \n       \n       \n        List<ServiceResult> results = new ArrayList<ServiceResult>();\n        XmlReplayReport report = new XmlReplayReport(reportsDir);\n        String controlFile = Tools.glue(xmlReplayBaseDir, \"\/\", controlFileName);\n        org.dom4j.Document document;\n        document = getDocument(controlFile);\n        if (document==null){\n            throw new FileNotFoundException(\"XmlReplay control file (\"+controlFileName+\") not found in basedir: \"+xmlReplayBaseDir+\" Exiting test.\");\n        }\n        String protoHostPort;\n        if (Tools.isEmpty(protoHostPortParam)){\n            protoHostPort = document.selectSingleNode(\"\/xmlReplay\/protoHostPort\").getText().trim();\n            System.out.println(\"DEPRECATED: Using protoHostPort ('\"+protoHostPort+\"') from xmlReplay file ('\"+controlFile+\"'), not master.\");\n        } else {\n            protoHostPort = protoHostPortParam;\n        }\n        if (Tools.isEmpty(protoHostPort)){\n            throw new Exception(\"XmlReplay control file must have a protoHostPort element\");\n        }\n        String authsMapINFO;\n        AuthsMap authsMap = readAuths(document);\n        if (authsMap.map.size()==0){\n            authsMap = defaultAuths;\n            authsMapINFO = \"Using defaultAuths from master file: \"+defaultAuths;\n        } else {\n            authsMapINFO = \"Using AuthsMap from control file: \"+authsMap;\n        }\n        report.addTestGroup(testGroupID, controlFileName);  \n        String xmlReplayHeader = \"========================================================================\"\n                          +\"\\r\\nXmlReplay running:\"\n                          +\"\\r\\n   controlFile: \"+ (new File(controlFile).getCanonicalPath())\n                          +\"\\r\\n   protoHostPort: \"+protoHostPort\n                          +\"\\r\\n   testGroup: \"+testGroupID\n                          + (Tools.notEmpty(oneTestID) ? \"\\r\\n   oneTestID: \"+oneTestID : \"\")\n                          +\"\\r\\n   AuthsMap: \"+authsMapINFO\n                          +\"\\r\\n   param_autoDeletePOSTS: \"+param_autoDeletePOSTS\n                          +\"\\r\\n   Dump info: \"+dump\n                          +\"\\r\\n========================================================================\"\n                          +\"\\r\\n\";\n        report.addRunInfo(xmlReplayHeader);\n        System.out.println(xmlReplayHeader);\n        String autoDeletePOSTS = \"\";\n        List<Node> testgroupNodes;\n        if (Tools.notEmpty(testGroupID)){\n            testgroupNodes = document.selectNodes(\"\/\/testGroup[@ID='\"+testGroupID+\"']\");\n        } else {\n            testgroupNodes = document.selectNodes(\"\/\/testGroup\");\n        }\n        JexlEngine jexl = new JexlEngine();  \n        XmlReplayEval evalStruct = new XmlReplayEval();\n        evalStruct.serviceResultsMap = serviceResultsMap;\n        evalStruct.jexl = jexl;\n        for (Node testgroup : testgroupNodes) {\n            XmlReplayEval.MapContextWKeys jc = new XmlReplayEval.MapContextWKeys()\n            evalStruct.jc = jc;\n            autoDeletePOSTS = testgroup.valueOf(\"@autoDeletePOSTS\");\n            List<Node> tests;\n            if (Tools.notEmpty(oneTestID)){\n                tests = testgroup.selectNodes(\"test[@ID='\"+oneTestID+\"']\");\n            } else {\n                tests = testgroup.selectNodes(\"test\");\n            }\n            String authForTest = \"\";\n            int testElementIndex = -1;\n            for (Node testNode : tests) {\n                long startTime = System.currentTimeMillis();\n                try {\n                    testElementIndex++;\n                    String testID = testNode.valueOf(\"@ID\");\n                   \n                   \n                    boolean autoDelete = param_autoDeletePOSTS;\n                    String autoDeleteValue = testNode.valueOf(\"@autoDeletePOSTS\");\n                    if (autoDeleteValue != null && !autoDeleteValue.trim().isEmpty()) {\n                    \tautoDelete = Boolean.valueOf(autoDeleteValue).booleanValue();\n                    }\n                    String testIDLabel = Tools.notEmpty(testID) ? (testGroupID+'.'+testID) : (testGroupID+'.'+testElementIndex);\n                    String method = testNode.valueOf(\"method\");\n                    String contentType = testNode.valueOf(\"contentType\");\n                    String uri = testNode.valueOf(\"uri\");\n                    String fullURL = Tools.glue(protoHostPort, \"\/\", uri);\n                    if (contentType == null || contentType.equals(\"\")) {\n                        contentType = XmlReplayTransport.APPLICATION_XML;\n                    }\n                    String currentAuthForTest = null;\n                    String authIDForTest = testNode.valueOf(\"@auth\");\n                    if (Tools.notEmpty(authIDForTest)){\n                        currentAuthForTest = authsMap.map.get(authIDForTest);\n                    }\n                    else {\n                        String tokenAuthExpression = testNode.valueOf(\"@tokenauth\");\n                        if (Tools.notEmpty(tokenAuthExpression)){\n                            currentAuthForTest = \"Bearer \" + evalStruct.eval(tokenAuthExpression, serviceResultsMap, null, jexl, jc);\n                        }\n                    }\n                    if (Tools.notEmpty(currentAuthForTest)){\n                        authForTest = currentAuthForTest;\n                    }\n                    if (Tools.isEmpty(authForTest)){\n                        authForTest = defaultAuths.getDefaultAuth();\n                    }\n                    if (uri.indexOf(\"$\")>-1){\n                        uri = evalStruct.eval(uri, serviceResultsMap, null, jexl, jc);\n                    }\n                    fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    List<Integer> expectedCodes = new ArrayList<Integer>();\n                    String expectedCodesStr = testNode.valueOf(\"expectedCodes\");\n                    if (Tools.notEmpty(expectedCodesStr)){\n                         String[] codesArray = expectedCodesStr.split(\",\");\n                         for (String code : codesArray){\n                             expectedCodes.add(new Integer(code.trim()));\n                         }\n                    }\n                    Node responseNode = testNode.selectSingleNode(\"response\");\n                    PartsStruct expectedResponseParts = null;\n                    if (responseNode!=null){\n                        expectedResponseParts = PartsStruct.readParts(responseNode, testID, xmlReplayBaseDir);\n                       \n                    }\n                    ServiceResult serviceResult;\n                    boolean isPOST = method.equalsIgnoreCase(\"POST\");\n                    boolean isPUT =  method.equalsIgnoreCase(\"PUT\");\n                    if ( isPOST || isPUT ) {\n                        PartsStruct parts = PartsStruct.readParts(testNode, testID, xmlReplayBaseDir);\n                        if (Tools.notEmpty(parts.overrideTestID)) {\n                            testID = parts.overrideTestID;\n                        }\n                        if (isPOST){\n                            String csid = CSIDfromTestID(testNode, serviceResultsMap);\n                            if (Tools.notEmpty(csid)) uri = Tools.glue(uri, \"\/\", csid+\"\/items\/\");\n                        } else if (isPUT) {\n                            uri = fromTestID(uri, testNode, serviceResultsMap);\n                        }\n                       \n                       \n                        Map<String,String> vars = null;\n                        if (parts.varsList.size()>0){\n                            vars = parts.varsList.get(0);\n                        }\n                        serviceResult = XmlReplayTransport.doPOST_PUTFromXML(parts.responseFilename, vars, protoHostPort, uri, method, contentType, evalStruct, authForTest, testIDLabel);\n                        serviceResult.autoDelete = autoDelete;\n                        if (vars!=null) {\n                            serviceResult.addVars(vars);\n                        }\n                        results.add(serviceResult);\n                       \n                            serviceResultsMap.put(testID, serviceResult);     \n                       \n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                    } else if (method.equalsIgnoreCase(\"DELETE\")){\n                        String fromTestID = testNode.valueOf(\"fromTestID\");\n                        ServiceResult pr = serviceResultsMap.get(fromTestID);\n                        if (pr!=null){\n                            serviceResult = XmlReplayTransport.doDELETE(pr.deleteURL, authForTest, testIDLabel, fromTestID);\n                            serviceResult.fromTestID = fromTestID;\n                            if (expectedCodes.size()>0){\n                                serviceResult.expectedCodes = expectedCodes;\n                            }\n                            results.add(serviceResult);\n                            if (serviceResult.codeInSuccessRange(serviceResult.responseCode)){ \n                                serviceResultsMap.remove(fromTestID);\n                            }\n                        } else {\n                            if (Tools.notEmpty(fromTestID)){\n                                serviceResult = new ServiceResult();\n                                serviceResult.responseCode = 0;\n                                serviceResult.error = \"ID not found in element fromTestID: \"+fromTestID;\n                                System.err.println(\"****\\r\\nServiceResult: \"+serviceResult.error+\". SKIPPING TEST. Full URL: \"+fullURL);\n                            } else {\n                                serviceResult = XmlReplayTransport.doDELETE(fullURL, authForTest, testID, fromTestID);\n                            }\n                            serviceResult.fromTestID = fromTestID;\n                            results.add(serviceResult);\n                        }\n                    } else if (method.equalsIgnoreCase(\"GET\")){\n                        fullURL = fromTestID(fullURL, testNode, serviceResultsMap);\n                        serviceResult = XmlReplayTransport.doGET(fullURL, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else if (method.equalsIgnoreCase(\"LIST\")){\n                        fullURL = fixupFullURL(fullURL, protoHostPort, uri);\n                        String listQueryParams = \"\";\n                        serviceResult = XmlReplayTransport.doLIST(fullURL, listQueryParams, authForTest, testIDLabel);\n                        results.add(serviceResult);\n                        serviceResultsMap.put(testID, serviceResult);\n                    } else {\n                        throw new Exception(\"HTTP method not supported by XmlReplay: \"+method);\n                    }\n                    serviceResult.testID = testID;\n                    serviceResult.fullURL = fullURL;\n                    serviceResult.auth = authForTest;\n                    serviceResult.method = method;\n                    if (expectedCodes.size()>0){\n                        serviceResult.expectedCodes = expectedCodes;\n                    }\n                    if (Tools.isEmpty(serviceResult.testID)) serviceResult.testID = testIDLabel;\n                    if (Tools.isEmpty(serviceResult.testGroupID)) serviceResult.testGroupID = testGroupID;\n                    Node expectedLevel = testNode.selectSingleNode(\"response\/expected\");\n                    if (expectedLevel!=null){\n                        String level = expectedLevel.valueOf(\"@level\");\n                        serviceResult.payloadStrictness = level;\n                    }\n                   \n                   \n                   \n                    boolean hasError = false;\n                    String vError = validateResponse(serviceResult, serviceResultsMap, expectedResponseParts, evalStruct);\n                    if (Tools.notEmpty(vError)){\n                        serviceResult.error = vError;\n                        serviceResult.failureReason = \" : VALIDATION ERROR; \";\n                        hasError = true;\n                    }\n                    if (hasError == false){\n                        hasError = ! serviceResult.gotExpectedResult();\n                    }\n                    boolean doingAuto = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.auto);\n                    String serviceResultRow = serviceResult.dump(dump.dumpServiceResult, hasError)+\"; time:\"+(System.currentTimeMillis()-startTime);\n                    String leader = (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed) ? \"XmlReplay:\"+testIDLabel+\": \": \"\";\n                    report.addTestResult(serviceResult);\n                    if (   (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.detailed)\n                        || (dump.dumpServiceResult == ServiceResult.DUMP_OPTIONS.full)         ){\n                        System.out.println(\"\\r\\n#---------------------#\");\n                    }\n                    System.out.println(timeString()+\" \"+leader+serviceResultRow+\"\\r\\n\");\n                    if (dump.payloads || (doingAuto&&hasError) ) {\n                        if (Tools.notBlank(serviceResult.requestPayload)){\n                            System.out.println(\"\\r\\n========== request payload ===============\");\n                            System.out.println(serviceResult.requestPayload);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                    if (dump.payloads || (doingAuto&&hasError)) {\n                        if (Tools.notBlank(serviceResult.result)){\n                            System.out.println(\"\\r\\n========== response payload ==============\");\n                            System.out.println(serviceResult.result);\n                            System.out.println(\"==========================================\\r\\n\");\n                        }\n                    }\n                } catch (Throwable t) {\n                    String msg = \"ERROR: XmlReplay experienced an error in a test node: \"+testNode+\" Throwable: \"+t;\n                    System.out.println(msg);\n                    System.out.println(Tools.getStackTrace(t));\n                    ServiceResult serviceResult = new ServiceResult();\n                    serviceResult.error = msg;\n                    serviceResult.failureReason = \" : SYSTEM ERROR; \";\n                    results.add(serviceResult);\n                }\n            }\n            if (Tools.isTrue(autoDeletePOSTS) && param_autoDeletePOSTS){\n                autoDelete(serviceResultsMap, \"default\", 0);\n            }\n        }\n       \n        File m = new File(controlFileName);\n        String localName = m.getName()\n        String reportName = localName+'-'+testGroupID+\".html\";\n        File resultFile = report.saveReport(xmlReplayBaseDir, reportsDir, reportName);\n        if (resultFile!=null) {\n            String toc = report.getTOC(reportName);\n            reportsList.add(toc);\n        }\n       \n        return results;\n    }","cleancode":"public static list<serviceresult> runxmlreplayfile(string xmlreplaybasedir, string controlfilename, string testgroupid, string onetestid, map<string, serviceresult> serviceresultsmap, boolean param_autodeleteposts, dump dump, string protohostportparam, authsmap defaultauths, list<string> reportslist, string reportsdir) throws exception { list<serviceresult> results = new arraylist<serviceresult>(); xmlreplayreport report = new xmlreplayreport(reportsdir); string controlfile = tools.glue(xmlreplaybasedir, \"\/\", controlfilename); org.dom4j.document document; document = getdocument(controlfile); if (document==null){ throw new filenotfoundexception(\"xmlreplay control file (\"+controlfilename+\") not found in basedir: \"+xmlreplaybasedir+\" exiting test.\"); } string protohostport; if (tools.isempty(protohostportparam)){ protohostport = document.selectsinglenode(\"\/xmlreplay\/protohostport\").gettext().trim(); system.out.println(\"deprecated: using protohostport ('\"+protohostport+\"') from xmlreplay file ('\"+controlfile+\"'), not master.\"); } else { protohostport = protohostportparam; } if (tools.isempty(protohostport)){ throw new exception(\"xmlreplay control file must have a protohostport element\"); } string authsmapinfo; authsmap authsmap = readauths(document); if (authsmap.map.size()==0){ authsmap = defaultauths; authsmapinfo = \"using defaultauths from master file: \"+defaultauths; } else { authsmapinfo = \"using authsmap from control file: \"+authsmap; } report.addtestgroup(testgroupid, controlfilename); string xmlreplayheader = \"========================================================================\" +\"\\r\\nxmlreplay running:\" +\"\\r\\n controlfile: \"+ (new file(controlfile).getcanonicalpath()) +\"\\r\\n protohostport: \"+protohostport +\"\\r\\n testgroup: \"+testgroupid + (tools.notempty(onetestid) ? \"\\r\\n onetestid: \"+onetestid : \"\") +\"\\r\\n authsmap: \"+authsmapinfo +\"\\r\\n param_autodeleteposts: \"+param_autodeleteposts +\"\\r\\n dump info: \"+dump +\"\\r\\n========================================================================\" +\"\\r\\n\"; report.addruninfo(xmlreplayheader); system.out.println(xmlreplayheader); string autodeleteposts = \"\"; list<node> testgroupnodes; if (tools.notempty(testgroupid)){ testgroupnodes = document.selectnodes(\"\/\/testgroup[@id='\"+testgroupid+\"']\"); } else { testgroupnodes = document.selectnodes(\"\/\/testgroup\"); } jexlengine jexl = new jexlengine(); xmlreplayeval evalstruct = new xmlreplayeval(); evalstruct.serviceresultsmap = serviceresultsmap; evalstruct.jexl = jexl; for (node testgroup : testgroupnodes) { xmlreplayeval.mapcontextwkeys jc = new xmlreplayeval.mapcontextwkeys() evalstruct.jc = jc; autodeleteposts = testgroup.valueof(\"@autodeleteposts\"); list<node> tests; if (tools.notempty(onetestid)){ tests = testgroup.selectnodes(\"test[@id='\"+onetestid+\"']\"); } else { tests = testgroup.selectnodes(\"test\"); } string authfortest = \"\"; int testelementindex = -1; for (node testnode : tests) { long starttime = system.currenttimemillis(); try { testelementindex++; string testid = testnode.valueof(\"@id\"); boolean autodelete = param_autodeleteposts; string autodeletevalue = testnode.valueof(\"@autodeleteposts\"); if (autodeletevalue != null && !autodeletevalue.trim().isempty()) { autodelete = boolean.valueof(autodeletevalue).booleanvalue(); } string testidlabel = tools.notempty(testid) ? (testgroupid+'.'+testid) : (testgroupid+'.'+testelementindex); string method = testnode.valueof(\"method\"); string contenttype = testnode.valueof(\"contenttype\"); string uri = testnode.valueof(\"uri\"); string fullurl = tools.glue(protohostport, \"\/\", uri); if (contenttype == null || contenttype.equals(\"\")) { contenttype = xmlreplaytransport.application_xml; } string currentauthfortest = null; string authidfortest = testnode.valueof(\"@auth\"); if (tools.notempty(authidfortest)){ currentauthfortest = authsmap.map.get(authidfortest); } else { string tokenauthexpression = testnode.valueof(\"@tokenauth\"); if (tools.notempty(tokenauthexpression)){ currentauthfortest = \"bearer \" + evalstruct.eval(tokenauthexpression, serviceresultsmap, null, jexl, jc); } } if (tools.notempty(currentauthfortest)){ authfortest = currentauthfortest; } if (tools.isempty(authfortest)){ authfortest = defaultauths.getdefaultauth(); } if (uri.indexof(\"$\")>-1){ uri = evalstruct.eval(uri, serviceresultsmap, null, jexl, jc); } fullurl = fixupfullurl(fullurl, protohostport, uri); list<integer> expectedcodes = new arraylist<integer>(); string expectedcodesstr = testnode.valueof(\"expectedcodes\"); if (tools.notempty(expectedcodesstr)){ string[] codesarray = expectedcodesstr.split(\",\"); for (string code : codesarray){ expectedcodes.add(new integer(code.trim())); } } node responsenode = testnode.selectsinglenode(\"response\"); partsstruct expectedresponseparts = null; if (responsenode!=null){ expectedresponseparts = partsstruct.readparts(responsenode, testid, xmlreplaybasedir); } serviceresult serviceresult; boolean ispost = method.equalsignorecase(\"post\"); boolean isput = method.equalsignorecase(\"put\"); if ( ispost || isput ) { partsstruct parts = partsstruct.readparts(testnode, testid, xmlreplaybasedir); if (tools.notempty(parts.overridetestid)) { testid = parts.overridetestid; } if (ispost){ string csid = csidfromtestid(testnode, serviceresultsmap); if (tools.notempty(csid)) uri = tools.glue(uri, \"\/\", csid+\"\/items\/\"); } else if (isput) { uri = fromtestid(uri, testnode, serviceresultsmap); } map<string,string> vars = null; if (parts.varslist.size()>0){ vars = parts.varslist.get(0); } serviceresult = xmlreplaytransport.dopost_putfromxml(parts.responsefilename, vars, protohostport, uri, method, contenttype, evalstruct, authfortest, testidlabel); serviceresult.autodelete = autodelete; if (vars!=null) { serviceresult.addvars(vars); } results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); fullurl = fixupfullurl(fullurl, protohostport, uri); } else if (method.equalsignorecase(\"delete\")){ string fromtestid = testnode.valueof(\"fromtestid\"); serviceresult pr = serviceresultsmap.get(fromtestid); if (pr!=null){ serviceresult = xmlreplaytransport.dodelete(pr.deleteurl, authfortest, testidlabel, fromtestid); serviceresult.fromtestid = fromtestid; if (expectedcodes.size()>0){ serviceresult.expectedcodes = expectedcodes; } results.add(serviceresult); if (serviceresult.codeinsuccessrange(serviceresult.responsecode)){ serviceresultsmap.remove(fromtestid); } } else { if (tools.notempty(fromtestid)){ serviceresult = new serviceresult(); serviceresult.responsecode = 0; serviceresult.error = \"id not found in element fromtestid: \"+fromtestid; system.err.println(\"****\\r\\nserviceresult: \"+serviceresult.error+\". skipping test. full url: \"+fullurl); } else { serviceresult = xmlreplaytransport.dodelete(fullurl, authfortest, testid, fromtestid); } serviceresult.fromtestid = fromtestid; results.add(serviceresult); } } else if (method.equalsignorecase(\"get\")){ fullurl = fromtestid(fullurl, testnode, serviceresultsmap); serviceresult = xmlreplaytransport.doget(fullurl, authfortest, testidlabel); results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); } else if (method.equalsignorecase(\"list\")){ fullurl = fixupfullurl(fullurl, protohostport, uri); string listqueryparams = \"\"; serviceresult = xmlreplaytransport.dolist(fullurl, listqueryparams, authfortest, testidlabel); results.add(serviceresult); serviceresultsmap.put(testid, serviceresult); } else { throw new exception(\"http method not supported by xmlreplay: \"+method); } serviceresult.testid = testid; serviceresult.fullurl = fullurl; serviceresult.auth = authfortest; serviceresult.method = method; if (expectedcodes.size()>0){ serviceresult.expectedcodes = expectedcodes; } if (tools.isempty(serviceresult.testid)) serviceresult.testid = testidlabel; if (tools.isempty(serviceresult.testgroupid)) serviceresult.testgroupid = testgroupid; node expectedlevel = testnode.selectsinglenode(\"response\/expected\"); if (expectedlevel!=null){ string level = expectedlevel.valueof(\"@level\"); serviceresult.payloadstrictness = level; } boolean haserror = false; string verror = validateresponse(serviceresult, serviceresultsmap, expectedresponseparts, evalstruct); if (tools.notempty(verror)){ serviceresult.error = verror; serviceresult.failurereason = \" : validation error; \"; haserror = true; } if (haserror == false){ haserror = ! serviceresult.gotexpectedresult(); } boolean doingauto = (dump.dumpserviceresult == serviceresult.dump_options.auto); string serviceresultrow = serviceresult.dump(dump.dumpserviceresult, haserror)+\"; time:\"+(system.currenttimemillis()-starttime); string leader = (dump.dumpserviceresult == serviceresult.dump_options.detailed) ? \"xmlreplay:\"+testidlabel+\": \": \"\"; report.addtestresult(serviceresult); if ( (dump.dumpserviceresult == serviceresult.dump_options.detailed) || (dump.dumpserviceresult == serviceresult.dump_options.full) ){ system.out.println(\"\\r\\n#---------------------#\"); } system.out.println(timestring()+\" \"+leader+serviceresultrow+\"\\r\\n\"); if (dump.payloads || (doingauto&&haserror) ) { if (tools.notblank(serviceresult.requestpayload)){ system.out.println(\"\\r\\n========== request payload ===============\"); system.out.println(serviceresult.requestpayload); system.out.println(\"==========================================\\r\\n\"); } } if (dump.payloads || (doingauto&&haserror)) { if (tools.notblank(serviceresult.result)){ system.out.println(\"\\r\\n========== response payload ==============\"); system.out.println(serviceresult.result); system.out.println(\"==========================================\\r\\n\"); } } } catch (throwable t) { string msg = \"error: xmlreplay experienced an error in a test node: \"+testnode+\" throwable: \"+t; system.out.println(msg); system.out.println(tools.getstacktrace(t)); serviceresult serviceresult = new serviceresult(); serviceresult.error = msg; serviceresult.failurereason = \" : system error; \"; results.add(serviceresult); } } if (tools.istrue(autodeleteposts) && param_autodeleteposts){ autodelete(serviceresultsmap, \"default\", 0); } } file m = new file(controlfilename); string localname = m.getname() string reportname = localname+'-'+testgroupid+\".html\"; file resultfile = report.savereport(xmlreplaybasedir, reportsdir, reportname); if (resultfile!=null) { string toc = report.gettoc(reportname); reportslist.add(toc); } return results; }","repo":"litchfieldhistoricalsociety\/services","label":[1,0,0,0]}
{"id":25235,"original_code":"@Test\n    public void positionalConstructors() throws Exception {\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\n        String cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\n        assertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n        \/\/ These go through a different code path:\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        \/* TODO casting arrays is not yet supported:\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; Boolean x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; Boolean x = a; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"String[] a = ['true']; a as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"String[] a = ['true']; a as Boolean\");\n        *\/\n        \/* TODO tuple assignment is not yet supported:\n        assertRejected(new ProxyWhitelist(), \"new java.util.LinkedList java.util.Collection\", \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.LinkedList java.util.Collection\"), Arrays.asList(\"v\"), \"String[] a = ['v']; def (LinkedList x, int y) = [a, 1]; x\");\n        *\/\n    }","code_wo_comment":"@Test\n    public void positionalConstructors() throws Exception {\n        assertRejected(new ProxyWhitelist(), \"new java.lang.Boolean java.lang.String\", \"['true'] as Boolean\");\n        assertEvaluate(new StaticWhitelist(\"new java.lang.Boolean java.lang.String\"), true, \"['true'] as Boolean\");\n        String cc = \"staticMethod org.kohsuke.groovy.sandbox.impl.Checker checkedCast java.lang.Class java.lang.Object boolean boolean boolean\";\n        assertRejected(new StaticWhitelist(cc), \"new java.lang.Boolean java.lang.String\", \"Boolean x = ['true']; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.lang.Boolean java.lang.String\"), true, \"Boolean x = ['true']; x\");\n        assertRejected(new ProxyWhitelist(), \"new java.util.TreeMap java.util.Map\", \"[k: 1] as TreeMap\");\n        assertEvaluate(new StaticWhitelist(\"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"[k: 1] as TreeMap\");\n        assertRejected(new StaticWhitelist(cc), \"new java.util.TreeMap java.util.Map\", \"TreeMap x = [k: 1]; x\");\n        assertEvaluate(new StaticWhitelist(cc, \"new java.util.TreeMap java.util.Map\"), Collections.singletonMap(\"k\", 1), \"TreeMap x = [k: 1]; x\");\n       \n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"[1] as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"['v'] as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(1), \"LinkedList x = [1]; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"LinkedList x = ['v']; x\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(1), \"int[] a = [1]; a as LinkedList\");\n        assertEvaluate(new ProxyWhitelist(), Arrays.asList(\"v\"), \"String[] a = ['v']; a as LinkedList\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n        assertEvaluate(new StaticWhitelist(cc), Arrays.asList(\"v\"), \"String[] a = ['v']; LinkedList x = a; x\");\n       \n       \n    }","cleancode":"@test public void positionalconstructors() throws exception { assertrejected(new proxywhitelist(), \"new java.lang.boolean java.lang.string\", \"['true'] as boolean\"); assertevaluate(new staticwhitelist(\"new java.lang.boolean java.lang.string\"), true, \"['true'] as boolean\"); string cc = \"staticmethod org.kohsuke.groovy.sandbox.impl.checker checkedcast java.lang.class java.lang.object boolean boolean boolean\"; assertrejected(new staticwhitelist(cc), \"new java.lang.boolean java.lang.string\", \"boolean x = ['true']; x\"); assertevaluate(new staticwhitelist(cc, \"new java.lang.boolean java.lang.string\"), true, \"boolean x = ['true']; x\"); assertrejected(new proxywhitelist(), \"new java.util.treemap java.util.map\", \"[k: 1] as treemap\"); assertevaluate(new staticwhitelist(\"new java.util.treemap java.util.map\"), collections.singletonmap(\"k\", 1), \"[k: 1] as treemap\"); assertrejected(new staticwhitelist(cc), \"new java.util.treemap java.util.map\", \"treemap x = [k: 1]; x\"); assertevaluate(new staticwhitelist(cc, \"new java.util.treemap java.util.map\"), collections.singletonmap(\"k\", 1), \"treemap x = [k: 1]; x\"); assertevaluate(new proxywhitelist(), arrays.aslist(1), \"[1] as linkedlist\"); assertevaluate(new proxywhitelist(), arrays.aslist(\"v\"), \"['v'] as linkedlist\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(1), \"linkedlist x = [1]; x\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"linkedlist x = ['v']; x\"); assertevaluate(new proxywhitelist(), arrays.aslist(1), \"int[] a = [1]; a as linkedlist\"); assertevaluate(new proxywhitelist(), arrays.aslist(\"v\"), \"string[] a = ['v']; a as linkedlist\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"string[] a = ['v']; linkedlist x = a; x\"); assertevaluate(new staticwhitelist(cc), arrays.aslist(\"v\"), \"string[] a = ['v']; linkedlist x = a; x\"); }","repo":"maheshp\/gocd-groovy-dsl-config-plugin","label":[1,1,0,0]}
{"id":685,"original_code":"public static final int testElementParsing (\n            final PrintStream out, final BufferedReader in, final String ... args)\n    {\n        final String    ans=getval(out, in, \"use owner document y\/[n]\/q\");\n        if (isQuit(ans))\n            return 0;\n        Document    owner=null;\n        if ((ans != null) && (ans.length() > 0) && ('y' == Character.toLowerCase(ans.charAt(0))))\n        {\n            try\n            {\n                owner = DOMUtils.createDefaultDocument();\n            }\n            catch(ParserConfigurationException e)\n            {\n                System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n            }\n        }\n        final int    nErr=testElementParsing(out, in, owner, args);\n        if (owner != null)\n        {\n            \/\/ TODO show resulting document\n        }\n        return nErr;\n    }","code_wo_comment":"public static final int testElementParsing (\n            final PrintStream out, final BufferedReader in, final String ... args)\n    {\n        final String    ans=getval(out, in, \"use owner document y\/[n]\/q\");\n        if (isQuit(ans))\n            return 0;\n        Document    owner=null;\n        if ((ans != null) && (ans.length() > 0) && ('y' == Character.toLowerCase(ans.charAt(0))))\n        {\n            try\n            {\n                owner = DOMUtils.createDefaultDocument();\n            }\n            catch(ParserConfigurationException e)\n            {\n                System.err.println(e.getClass().getName() + \": \" + e.getMessage());\n            }\n        }\n        final int    nErr=testElementParsing(out, in, owner, args);\n        if (owner != null)\n        {\n           \n        }\n        return nErr;\n    }","cleancode":"public static final int testelementparsing ( final printstream out, final bufferedreader in, final string ... args) { final string ans=getval(out, in, \"use owner document y\/[n]\/q\"); if (isquit(ans)) return 0; document owner=null; if ((ans != null) && (ans.length() > 0) && ('y' == character.tolowercase(ans.charat(0)))) { try { owner = domutils.createdefaultdocument(); } catch(parserconfigurationexception e) { system.err.println(e.getclass().getname() + \": \" + e.getmessage()); } } final int nerr=testelementparsing(out, in, owner, args); if (owner != null) { } return nerr; }","repo":"lgoldstein\/communitychest","label":[0,1,0,0]}
{"id":33498,"original_code":"@SuppressWarnings(\"fallthrough\")\n    @Override\n    public Token<CppTokenId> nextToken() {\n        while (true) {\n            \/\/ special handling for escaped lines\n            if (lastTokenEndedByEscapedLine > 0) {\n                int c = read(false);\n                lastTokenEndedByEscapedLine--;\n                assert c == '\\\\' : \"there must be \\\\\";\n                c = read(false);\n                assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\n                if (c == '\\r') {\n                    lastTokenEndedByEscapedLine--;\n                    if (input.consumeNewline()) {\n                        lastTokenEndedByEscapedLine--;\n                    }\n                    return token(CppTokenId.ESCAPED_LINE);\n                } else {\n                    lastTokenEndedByEscapedLine--;\n                    return token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE); \/\/ NOI18N\n                }\n            } else {\n                int c = read(true);\n                \/\/ if read of the first char caused skipping escaped line\n                \/\/ do we need to backup and create escaped lines first?\n                switch (c) {\n                    case '\"': {\n                        Token<CppTokenId> out = finishDblQuote();\n                        assert out != null : \"not handled dobule quote\";\n                        return out;\n                    }\n                    case '\\'': {\/\/ char literal\n                        Token<CppTokenId> out = finishSingleQuote();\n                        assert out != null : \"not handled single quote\";\n                        return out;\n                    }\n                    case '#': {\n                        Token<CppTokenId> out = finishSharp();\n                        assert out != null : \"not handled #\";\n                        return out;\n                    }\n                    case '\/':\n                        switch (read(true)) {\n                            case '\/': \/\/ in single-line or doxygen comment\n                            {\n                                Token<CppTokenId> out = finishLineComment(true);\n                                assert out != null : \"not handled \/\/\";\n                                return out;\n                            }\n                            case '=': \/\/ found \/=\n                                return token(CppTokenId.SLASHEQ);\n                            case '*': \/\/ in multi-line or doxygen comment\n                            {\n                                Token<CppTokenId> out = finishBlockComment(true);\n                                assert out != null : \"not handled \/*\";\n                                return out;\n                            }\n                        } \/\/ end of switch()\n                        backup(1);\n                        return token(CppTokenId.SLASH);\n                    case '=':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.EQEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.EQ);\n                    case '>':\n                        switch (read(true)) {\n                            case '>': \/\/ >>\n                                if (read(true) == '=') {\n                                    return token(CppTokenId.GTGTEQ);\n                                }\n                                backup(1);\n                                return token(CppTokenId.GTGT);\n                            case '=': \/\/ >=\n                                return token(CppTokenId.GTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.GT);\n                    case '<': {\n                        Token<CppTokenId> out = finishLT();\n                        assert out != null : \"not handled '<'\";\n                        return out;\n                    }\n                    case '+':\n                        switch (read(true)) {\n                            case '+':\n                                return token(CppTokenId.PLUSPLUS);\n                            case '=':\n                                return token(CppTokenId.PLUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.PLUS);\n                    case '-':\n                        switch (read(true)) {\n                            case '-':\n                                return token(CppTokenId.MINUSMINUS);\n                            case '>':\n                                if (read(true) == '*') {\n                                    return token(CppTokenId.ARROWMBR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.ARROW);\n                            case '=':\n                                return token(CppTokenId.MINUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.MINUS);\n                    case '*':\n                        switch (read(true)) {\n                            case '\/': \/\/ invalid comment end - *\/ or int*\/* *\/\n                                if (read(true) == '*') {\n                                    backup(2);\n                                    return token(CppTokenId.STAR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.INVALID_COMMENT_END);\n                            case '=':\n                                return token(CppTokenId.STAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.STAR);\n                    case '|':\n                        switch (read(true)) {\n                            case '|':\n                                return token(CppTokenId.BARBAR);\n                            case '=':\n                                return token(CppTokenId.BAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.BAR);\n                    case '&':\n                        switch (read(true)) {\n                            case '&':\n                                return token(CppTokenId.AMPAMP);\n                            case '=':\n                                return token(CppTokenId.AMPEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.AMP);\n                    case '%': {\n                        Token<CppTokenId> out = finishPercent();\n                        assert out != null : \"not handled %\";\n                        return out;\n                    }\n                    case '^':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.CARETEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.CARET);\n                    case '!':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.NOTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.NOT);\n                    case '.':\n                        if ((c = read(true)) == '.') {\n                            if (read(true) == '.') { \/\/ ellipsis ...\n                                return token(CppTokenId.ELLIPSIS);\n                            } else {\n                                input.backup(2);\n                            }\n                        } else if ('0' <= c && c <= '9') { \/\/ float literal\n                            return finishNumberLiteral(read(true), true);\n                        } else if (c == '*') {\n                            return token(CppTokenId.DOTMBR);\n                        } else {\n                            backup(1);\n                        }\n                        return token(CppTokenId.DOT);\n                    case ':':\n                        if (read(true) == ':') {\n                            return token(CppTokenId.SCOPE);\n                        }\n                        backup(1);\n                        return token(CppTokenId.COLON);\n                    case '~':\n                        return token(CppTokenId.TILDE);\n                    case ',':\n                        return token(CppTokenId.COMMA);\n                    case ';':\n                        return token(CppTokenId.SEMICOLON);\n                    case '?':\n                        return token(CppTokenId.QUESTION);\n                    case '(':\n                        return token(CppTokenId.LPAREN);\n                    case ')':\n                        return token(CppTokenId.RPAREN);\n                    case '[':\n                        return token(CppTokenId.LBRACKET);\n                    case ']':\n                        return token(CppTokenId.RBRACKET);\n                    case '{':\n                        return token(CppTokenId.LBRACE);\n                    case '}':\n                        return token(CppTokenId.RBRACE);\n                    case '`':\n                        return token(CppTokenId.GRAVE_ACCENT);\n                    case '@':\n                        return token(CppTokenId.AT);\n                    case '0': \/\/ in a number literal\n                        c = read(true);\n                        if (c == 'x' || c == 'X' || \/\/ in hexadecimal (possibly floating-point) literal\n                                c == 'b' || c == 'B' ) { \/\/ in bianry literal\n                            boolean inFraction = false;\n                            while (true) {\n                                switch (read(true)) {\n                                    case '0':\n                                    case '1':\n                                    case '2':\n                                    case '3':\n                                    case '4':\n                                    case '5':\n                                    case '6':\n                                    case '7':\n                                    case '8':\n                                    case '9':\n                                    case 'a':\n                                    case 'b':\n                                    case 'c':\n                                    case 'd':\n                                    case 'e':\n                                    case 'f':\n                                    case 'A':\n                                    case 'B':\n                                    case 'C':\n                                    case 'D':\n                                    case 'E':\n                                    case 'F':\n                                        break;\n                                    case '.': \/\/ hex float literal\n                                        if (!inFraction) {\n                                            inFraction = true;\n                                        } else { \/\/ two dots in the float literal\n                                            return token(CppTokenId.FLOAT_LITERAL_INVALID);\n                                        }\n                                        break;\n                                    case 'l':\n                                    case 'L': \/\/ 0x1234l or 0x1234L\n                                        return finishLongLiteral(read(true));\n                                    case 'p':\n                                    case 'P': \/\/ binary exponent\n                                        return finishFloatExponent();\n                                    case 'u':\n                                    case 'U':\n                                        return finishUnsignedLiteral(read(true));\n                                    default:\n                                        backup(1);\n                                        \/\/ if float then before mandatory binary exponent => invalid\n                                        return token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n                                                : CppTokenId.INT_LITERAL);\n                                }\n                            } \/\/ end of while(true)\n                        }\n                        return finishNumberLiteral(c, false);\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        return finishNumberLiteral(read(true), false);\n                    case '\\\\':\n                        return token(CppTokenId.BACK_SLASH);\n                    case '\\r':\n                        consumeNewline();\n                        return token(CppTokenId.NEW_LINE);\n                    case '\\n':\n                        return token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE); \/\/ NOI18N\n                    \/\/ All Character.isWhitespace(c) below 0x80 follow\n                    \/\/ ['\\t' - '\\f'] and [0x1c - ' ']\n                    case '\\t':\n                    case 0x0b:\n                    case '\\f':\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n                        return finishWhitespace();\n                    case ' ':\n                        c = read(true);\n                        if (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') { \/\/ Return single space as flyweight token\n                            backup(1);\n                            return token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE); \/\/ NOI18N\n                        }\n                        return finishWhitespace();\n                    case EOF:\n                        if (isTokenSplittedByEscapedLine()) {\n                            backup(1);\n                            assert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\n                            break;\n                        }\n                        return null;\n                    case '$':\n                        \/\/ dollar is extension in gcc and msvc $ is a valid start of identifiers\n\/\/                        return token(CppTokenId.DOLLAR);\n                    default:\n                        c = translateSurrogates(c);\n                        if (CndLexerUtilities.isCppIdentifierStart(c)) {\n                            if (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\n                                int next = read(true);\n                                boolean raw_string = (c == 'R');\n                                if (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n                                    \/\/ uR, UR or LR\n                                    raw_string = true;\n                                    next = read(true);\n                                } else if (next == '8' && c == 'u') {\n                                    \/\/ u8\n                                    next = read(true);\n                                    if (next == 'R') {\n                                        \/\/ u8R\n                                        raw_string = true;\n                                        next = read(true);\n                                    }\n                                }\n                                if (next == '\"') {\n                                    \/\/ string with L\/U\/u\/R prefixes\n                                    Token<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\n                                    assert out != null : \"not handled dobule quote\";\n                                    return out;\n                                } else if (next == '\\'' && !raw_string) {\n                                    \/\/ char with L or U\/u prefix\n                                    Token<CppTokenId> out = finishSingleQuote();\n                                    assert out != null : \"not handled single quote\";\n                                    return out;\n                                } else {\n                                    backup(1);\n                                }\n                            }\n                            if (c == 'E') {\n                                if(isExecSQL(c)) {\n                                    Token<CppTokenId> out = finishExecSQL();\n                                    assert out != null : \"not handled exec sql\";\n                                    return out;\n                                }\n                            }\n                            return keywordOrIdentifier(c);\n                        }\n                        if (Character.isWhitespace(c)) {\n                            return finishWhitespace();\n                        }\n                        \/\/ Invalid char\n                        return token(CppTokenId.ERROR);\n                }\n            } \/\/ end of switch (c)\n        } \/\/ end of while(true)\n    }","code_wo_comment":"@SuppressWarnings(\"fallthrough\")\n    @Override\n    public Token<CppTokenId> nextToken() {\n        while (true) {\n           \n            if (lastTokenEndedByEscapedLine > 0) {\n                int c = read(false);\n                lastTokenEndedByEscapedLine--;\n                assert c == '\\\\' : \"there must be \\\\\";\n                c = read(false);\n                assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\";\n                if (c == '\\r') {\n                    lastTokenEndedByEscapedLine--;\n                    if (input.consumeNewline()) {\n                        lastTokenEndedByEscapedLine--;\n                    }\n                    return token(CppTokenId.ESCAPED_LINE);\n                } else {\n                    lastTokenEndedByEscapedLine--;\n                    return token(CppTokenId.ESCAPED_LINE, \"\\\\\\n\", PartType.COMPLETE);\n                }\n            } else {\n                int c = read(true);\n               \n               \n                switch (c) {\n                    case '\"': {\n                        Token<CppTokenId> out = finishDblQuote();\n                        assert out != null : \"not handled dobule quote\";\n                        return out;\n                    }\n                    case '\\'': \n                        Token<CppTokenId> out = finishSingleQuote();\n                        assert out != null : \"not handled single quote\";\n                        return out;\n                    }\n                    case '#': {\n                        Token<CppTokenId> out = finishSharp();\n                        assert out != null : \"not handled #\";\n                        return out;\n                    }\n                    case '\/':\n                        switch (read(true)) {\n                            case '\/':\n                            {\n                                Token<CppTokenId> out = finishLineComment(true);\n                                assert out != null : \"not handled \/\/\";\n                                return out;\n                            }\n                            case '=':\n                                return token(CppTokenId.SLASHEQ);\n                            case '*':\n                            {\n                                Token<CppTokenId> out = finishBlockComment(true);\n                                assert out != null : \"not handled \/*\";\n                                return out;\n                            }\n                        }\n                        backup(1);\n                        return token(CppTokenId.SLASH);\n                    case '=':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.EQEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.EQ);\n                    case '>':\n                        switch (read(true)) {\n                            case '>':\n                                if (read(true) == '=') {\n                                    return token(CppTokenId.GTGTEQ);\n                                }\n                                backup(1);\n                                return token(CppTokenId.GTGT);\n                            case '=':\n                                return token(CppTokenId.GTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.GT);\n                    case '<': {\n                        Token<CppTokenId> out = finishLT();\n                        assert out != null : \"not handled '<'\";\n                        return out;\n                    }\n                    case '+':\n                        switch (read(true)) {\n                            case '+':\n                                return token(CppTokenId.PLUSPLUS);\n                            case '=':\n                                return token(CppTokenId.PLUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.PLUS);\n                    case '-':\n                        switch (read(true)) {\n                            case '-':\n                                return token(CppTokenId.MINUSMINUS);\n                            case '>':\n                                if (read(true) == '*') {\n                                    return token(CppTokenId.ARROWMBR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.ARROW);\n                            case '=':\n                                return token(CppTokenId.MINUSEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.MINUS);\n                    case '*':\n                        switch (read(true)) {\n                            case '\/':\n                                if (read(true) == '*') {\n                                    backup(2);\n                                    return token(CppTokenId.STAR);\n                                }\n                                backup(1);\n                                return token(CppTokenId.INVALID_COMMENT_END);\n                            case '=':\n                                return token(CppTokenId.STAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.STAR);\n                    case '|':\n                        switch (read(true)) {\n                            case '|':\n                                return token(CppTokenId.BARBAR);\n                            case '=':\n                                return token(CppTokenId.BAREQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.BAR);\n                    case '&':\n                        switch (read(true)) {\n                            case '&':\n                                return token(CppTokenId.AMPAMP);\n                            case '=':\n                                return token(CppTokenId.AMPEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.AMP);\n                    case '%': {\n                        Token<CppTokenId> out = finishPercent();\n                        assert out != null : \"not handled %\";\n                        return out;\n                    }\n                    case '^':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.CARETEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.CARET);\n                    case '!':\n                        if (read(true) == '=') {\n                            return token(CppTokenId.NOTEQ);\n                        }\n                        backup(1);\n                        return token(CppTokenId.NOT);\n                    case '.':\n                        if ((c = read(true)) == '.') {\n                            if (read(true) == '.') {\n                                return token(CppTokenId.ELLIPSIS);\n                            } else {\n                                input.backup(2);\n                            }\n                        } else if ('0' <= c && c <= '9') {\n                            return finishNumberLiteral(read(true), true);\n                        } else if (c == '*') {\n                            return token(CppTokenId.DOTMBR);\n                        } else {\n                            backup(1);\n                        }\n                        return token(CppTokenId.DOT);\n                    case ':':\n                        if (read(true) == ':') {\n                            return token(CppTokenId.SCOPE);\n                        }\n                        backup(1);\n                        return token(CppTokenId.COLON);\n                    case '~':\n                        return token(CppTokenId.TILDE);\n                    case ',':\n                        return token(CppTokenId.COMMA);\n                    case ';':\n                        return token(CppTokenId.SEMICOLON);\n                    case '?':\n                        return token(CppTokenId.QUESTION);\n                    case '(':\n                        return token(CppTokenId.LPAREN);\n                    case ')':\n                        return token(CppTokenId.RPAREN);\n                    case '[':\n                        return token(CppTokenId.LBRACKET);\n                    case ']':\n                        return token(CppTokenId.RBRACKET);\n                    case '{':\n                        return token(CppTokenId.LBRACE);\n                    case '}':\n                        return token(CppTokenId.RBRACE);\n                    case '`':\n                        return token(CppTokenId.GRAVE_ACCENT);\n                    case '@':\n                        return token(CppTokenId.AT);\n                    case '0':\n                        c = read(true);\n                        if (c == 'x' || c == 'X' ||\n                                c == 'b' || c == 'B' ) {\n                            boolean inFraction = false;\n                            while (true) {\n                                switch (read(true)) {\n                                    case '0':\n                                    case '1':\n                                    case '2':\n                                    case '3':\n                                    case '4':\n                                    case '5':\n                                    case '6':\n                                    case '7':\n                                    case '8':\n                                    case '9':\n                                    case 'a':\n                                    case 'b':\n                                    case 'c':\n                                    case 'd':\n                                    case 'e':\n                                    case 'f':\n                                    case 'A':\n                                    case 'B':\n                                    case 'C':\n                                    case 'D':\n                                    case 'E':\n                                    case 'F':\n                                        break;\n                                    case '.':\n                                        if (!inFraction) {\n                                            inFraction = true;\n                                        } else {\n                                            return token(CppTokenId.FLOAT_LITERAL_INVALID);\n                                        }\n                                        break;\n                                    case 'l':\n                                    case 'L':\n                                        return finishLongLiteral(read(true));\n                                    case 'p':\n                                    case 'P':\n                                        return finishFloatExponent();\n                                    case 'u':\n                                    case 'U':\n                                        return finishUnsignedLiteral(read(true));\n                                    default:\n                                        backup(1);\n                                       \n                                        return token(inFraction ? CppTokenId.FLOAT_LITERAL_INVALID\n                                                : CppTokenId.INT_LITERAL);\n                                }\n                            }\n                        }\n                        return finishNumberLiteral(c, false);\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        return finishNumberLiteral(read(true), false);\n                    case '\\\\':\n                        return token(CppTokenId.BACK_SLASH);\n                    case '\\r':\n                        consumeNewline();\n                        return token(CppTokenId.NEW_LINE);\n                    case '\\n':\n                        return token(CppTokenId.NEW_LINE, \"\\n\", PartType.COMPLETE);\n                   \n                   \n                    case '\\t':\n                    case 0x0b:\n                    case '\\f':\n                    case 0x1c:\n                    case 0x1d:\n                    case 0x1e:\n                    case 0x1f:\n                        return finishWhitespace();\n                    case ' ':\n                        c = read(true);\n                        if (c == EOF || !Character.isWhitespace(c) || c == '\\n' || c == '\\r') {\n                            backup(1);\n                            return token(CppTokenId.WHITESPACE, \" \", PartType.COMPLETE);\n                        }\n                        return finishWhitespace();\n                    case EOF:\n                        if (isTokenSplittedByEscapedLine()) {\n                            backup(1);\n                            assert lastTokenEndedByEscapedLine > 0 : \"lastTokenEndedByEscapedLine is \" + lastTokenEndedByEscapedLine;\n                            break;\n                        }\n                        return null;\n                    case '$':\n                       \n                    default:\n                        c = translateSurrogates(c);\n                        if (CndLexerUtilities.isCppIdentifierStart(c)) {\n                            if (c == 'L' || c == 'U' || c == 'u' || c == 'R') {\n                                int next = read(true);\n                                boolean raw_string = (c == 'R');\n                                if (next == 'R' && (c == 'u' || c == 'U' || c == 'L')) {\n                                   \n                                    raw_string = true;\n                                    next = read(true);\n                                } else if (next == '8' && c == 'u') {\n                                   \n                                    next = read(true);\n                                    if (next == 'R') {\n                                       \n                                        raw_string = true;\n                                        next = read(true);\n                                    }\n                                }\n                                if (next == '\"') {\n                                   \n                                    Token<CppTokenId> out = raw_string ? finishRawString() : finishDblQuote();\n                                    assert out != null : \"not handled dobule quote\";\n                                    return out;\n                                } else if (next == '\\'' && !raw_string) {\n                                   \n                                    Token<CppTokenId> out = finishSingleQuote();\n                                    assert out != null : \"not handled single quote\";\n                                    return out;\n                                } else {\n                                    backup(1);\n                                }\n                            }\n                            if (c == 'E') {\n                                if(isExecSQL(c)) {\n                                    Token<CppTokenId> out = finishExecSQL();\n                                    assert out != null : \"not handled exec sql\";\n                                    return out;\n                                }\n                            }\n                            return keywordOrIdentifier(c);\n                        }\n                        if (Character.isWhitespace(c)) {\n                            return finishWhitespace();\n                        }\n                       \n                        return token(CppTokenId.ERROR);\n                }\n            }\n        }\n    }","cleancode":"@suppresswarnings(\"fallthrough\") @override public token<cpptokenid> nexttoken() { while (true) { if (lasttokenendedbyescapedline > 0) { int c = read(false); lasttokenendedbyescapedline--; assert c == '\\\\' : \"there must be \\\\\"; c = read(false); assert c == '\\n' || c == '\\r' : \"there must be \\r or \\n\"; if (c == '\\r') { lasttokenendedbyescapedline--; if (input.consumenewline()) { lasttokenendedbyescapedline--; } return token(cpptokenid.escaped_line); } else { lasttokenendedbyescapedline--; return token(cpptokenid.escaped_line, \"\\\\\\n\", parttype.complete); } } else { int c = read(true); switch (c) { case '\"': { token<cpptokenid> out = finishdblquote(); assert out != null : \"not handled dobule quote\"; return out; } case '\\'': token<cpptokenid> out = finishsinglequote(); assert out != null : \"not handled single quote\"; return out; } case '#': { token<cpptokenid> out = finishsharp(); assert out != null : \"not handled #\"; return out; } case '\/': switch (read(true)) { case '\/': { token<cpptokenid> out = finishlinecomment(true); assert out != null : \"not handled \/\/\"; return out; } case '=': return token(cpptokenid.slasheq); case '*': { token<cpptokenid> out = finishblockcomment(true); assert out != null : \"not handled \/*\"; return out; } } backup(1); return token(cpptokenid.slash); case '=': if (read(true) == '=') { return token(cpptokenid.eqeq); } backup(1); return token(cpptokenid.eq); case '>': switch (read(true)) { case '>': if (read(true) == '=') { return token(cpptokenid.gtgteq); } backup(1); return token(cpptokenid.gtgt); case '=': return token(cpptokenid.gteq); } backup(1); return token(cpptokenid.gt); case '<': { token<cpptokenid> out = finishlt(); assert out != null : \"not handled '<'\"; return out; } case '+': switch (read(true)) { case '+': return token(cpptokenid.plusplus); case '=': return token(cpptokenid.pluseq); } backup(1); return token(cpptokenid.plus); case '-': switch (read(true)) { case '-': return token(cpptokenid.minusminus); case '>': if (read(true) == '*') { return token(cpptokenid.arrowmbr); } backup(1); return token(cpptokenid.arrow); case '=': return token(cpptokenid.minuseq); } backup(1); return token(cpptokenid.minus); case '*': switch (read(true)) { case '\/': if (read(true) == '*') { backup(2); return token(cpptokenid.star); } backup(1); return token(cpptokenid.invalid_comment_end); case '=': return token(cpptokenid.stareq); } backup(1); return token(cpptokenid.star); case '|': switch (read(true)) { case '|': return token(cpptokenid.barbar); case '=': return token(cpptokenid.bareq); } backup(1); return token(cpptokenid.bar); case '&': switch (read(true)) { case '&': return token(cpptokenid.ampamp); case '=': return token(cpptokenid.ampeq); } backup(1); return token(cpptokenid.amp); case '%': { token<cpptokenid> out = finishpercent(); assert out != null : \"not handled %\"; return out; } case '^': if (read(true) == '=') { return token(cpptokenid.careteq); } backup(1); return token(cpptokenid.caret); case '!': if (read(true) == '=') { return token(cpptokenid.noteq); } backup(1); return token(cpptokenid.not); case '.': if ((c = read(true)) == '.') { if (read(true) == '.') { return token(cpptokenid.ellipsis); } else { input.backup(2); } } else if ('0' <= c && c <= '9') { return finishnumberliteral(read(true), true); } else if (c == '*') { return token(cpptokenid.dotmbr); } else { backup(1); } return token(cpptokenid.dot); case ':': if (read(true) == ':') { return token(cpptokenid.scope); } backup(1); return token(cpptokenid.colon); case '~': return token(cpptokenid.tilde); case ',': return token(cpptokenid.comma); case ';': return token(cpptokenid.semicolon); case '?': return token(cpptokenid.question); case '(': return token(cpptokenid.lparen); case ')': return token(cpptokenid.rparen); case '[': return token(cpptokenid.lbracket); case ']': return token(cpptokenid.rbracket); case '{': return token(cpptokenid.lbrace); case '}': return token(cpptokenid.rbrace); case '`': return token(cpptokenid.grave_accent); case '@': return token(cpptokenid.at); case '0': c = read(true); if (c == 'x' || c == 'x' || c == 'b' || c == 'b' ) { boolean infraction = false; while (true) { switch (read(true)) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': break; case '.': if (!infraction) { infraction = true; } else { return token(cpptokenid.float_literal_invalid); } break; case 'l': case 'l': return finishlongliteral(read(true)); case 'p': case 'p': return finishfloatexponent(); case 'u': case 'u': return finishunsignedliteral(read(true)); default: backup(1); return token(infraction ? cpptokenid.float_literal_invalid : cpptokenid.int_literal); } } } return finishnumberliteral(c, false); case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return finishnumberliteral(read(true), false); case '\\\\': return token(cpptokenid.back_slash); case '\\r': consumenewline(); return token(cpptokenid.new_line); case '\\n': return token(cpptokenid.new_line, \"\\n\", parttype.complete); case '\\t': case 0x0b: case '\\f': case 0x1c: case 0x1d: case 0x1e: case 0x1f: return finishwhitespace(); case ' ': c = read(true); if (c == eof || !character.iswhitespace(c) || c == '\\n' || c == '\\r') { backup(1); return token(cpptokenid.whitespace, \" \", parttype.complete); } return finishwhitespace(); case eof: if (istokensplittedbyescapedline()) { backup(1); assert lasttokenendedbyescapedline > 0 : \"lasttokenendedbyescapedline is \" + lasttokenendedbyescapedline; break; } return null; case '$': default: c = translatesurrogates(c); if (cndlexerutilities.iscppidentifierstart(c)) { if (c == 'l' || c == 'u' || c == 'u' || c == 'r') { int next = read(true); boolean raw_string = (c == 'r'); if (next == 'r' && (c == 'u' || c == 'u' || c == 'l')) { raw_string = true; next = read(true); } else if (next == '8' && c == 'u') { next = read(true); if (next == 'r') { raw_string = true; next = read(true); } } if (next == '\"') { token<cpptokenid> out = raw_string ? finishrawstring() : finishdblquote(); assert out != null : \"not handled dobule quote\"; return out; } else if (next == '\\'' && !raw_string) { token<cpptokenid> out = finishsinglequote(); assert out != null : \"not handled single quote\"; return out; } else { backup(1); } } if (c == 'e') { if(isexecsql(c)) { token<cpptokenid> out = finishexecsql(); assert out != null : \"not handled exec sql\"; return out; } } return keywordoridentifier(c); } if (character.iswhitespace(c)) { return finishwhitespace(); } return token(cpptokenid.error); } } } }","repo":"leginee\/netbeans","label":[1,0,0,0]}
{"id":25373,"original_code":"protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNode() {\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String separator, @NonNls @NotNull String value,\n                                      boolean hasChildren) {\n            setPresentation(icon, type, separator, value, null, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value,\n                                      @Nullable NotNullFunction<String, String> valuePresenter, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setGroupingPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean expand) {\n            setPresentation(icon, value, valuePresenter, true);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean hasChildren) {\n            doSetPresentation(icon, null, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value, @Nullable final NotNullFunction<String, String> valuePresenter, final boolean hasChildren) {\n            doSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n          }\n          private void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              public void run() {\n                doShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n              }\n            });\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, value, hasChildren);\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, separator, value, hasChildren);\n          }\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n            \/\/todo[nik] implement?\n          }\n          public boolean isObsolete() {\n            \/\/todo[nik]\n            return false;\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","code_wo_comment":"protected void evaluateAndShowHint() {\n    myEvaluator.evaluate(myExpression, new XEvaluationCallbackBase() {\n      public void evaluated(@NotNull final XValue result) {\n        result.computePresentation(new XValueNode() {\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String separator, @NonNls @NotNull String value,\n                                      boolean hasChildren) {\n            setPresentation(icon, type, separator, value, null, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String type, @NonNls @NotNull String value,\n                                      @Nullable NotNullFunction<String, String> valuePresenter, boolean hasChildren) {\n            setPresentation(icon, type, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setGroupingPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean expand) {\n            setPresentation(icon, value, valuePresenter, true);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable String value, @Nullable XValuePresenter valuePresenter, boolean hasChildren) {\n            doSetPresentation(icon, null, XDebuggerUIConstants.EQ_TEXT, value, valuePresenter, hasChildren);\n          }\n          @Override\n          public void setPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value, @Nullable final NotNullFunction<String, String> valuePresenter, final boolean hasChildren) {\n            doSetPresentation(icon, type, separator, value, valuePresenter == null ? null : new XValuePresenterAdapter(valuePresenter), hasChildren);\n          }\n          private void doSetPresentation(@Nullable Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @Nullable final String value, @Nullable final XValuePresenter valuePresenter, final boolean hasChildren) {\n            AppUIUtil.invokeOnEdt(new Runnable() {\n              public void run() {\n                doShowHint(result, separator, value, type, valuePresenter == null ? XValueNodeImpl.DEFAULT_VALUE_PRESENTER : valuePresenter, hasChildren);\n              }\n            });\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, value, hasChildren);\n          }\n          public void setPresentation(@NonNls final String name, @Nullable final Icon icon, @NonNls @Nullable final String type, @NonNls @NotNull final String separator,\n                                      @NonNls @NotNull final String value,\n                                      final boolean hasChildren) {\n            setPresentation(icon, type, separator, value, hasChildren);\n          }\n          public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n           \n          }\n          public boolean isObsolete() {\n           \n            return false;\n          }\n        }, XValuePlace.TOOLTIP);\n      }\n      public void errorOccurred(@NotNull final String errorMessage) {\n        LOG.debug(\"Cannot evaluate '\" + myExpression + \"':\" + errorMessage);\n      }\n    }, myExpressionPosition);\n  }","cleancode":"protected void evaluateandshowhint() { myevaluator.evaluate(myexpression, new xevaluationcallbackbase() { public void evaluated(@notnull final xvalue result) { result.computepresentation(new xvaluenode() { @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string value, boolean haschildren) { setpresentation(icon, type, xdebuggeruiconstants.eq_text, value, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string separator, @nonnls @notnull string value, boolean haschildren) { setpresentation(icon, type, separator, value, null, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string type, @nonnls @notnull string value, @nullable notnullfunction<string, string> valuepresenter, boolean haschildren) { setpresentation(icon, type, xdebuggeruiconstants.eq_text, value, valuepresenter, haschildren); } @override public void setgroupingpresentation(@nullable icon icon, @nonnls @nullable string value, @nullable xvaluepresenter valuepresenter, boolean expand) { setpresentation(icon, value, valuepresenter, true); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable string value, @nullable xvaluepresenter valuepresenter, boolean haschildren) { dosetpresentation(icon, null, xdebuggeruiconstants.eq_text, value, valuepresenter, haschildren); } @override public void setpresentation(@nullable icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @notnull final string value, @nullable final notnullfunction<string, string> valuepresenter, final boolean haschildren) { dosetpresentation(icon, type, separator, value, valuepresenter == null ? null : new xvaluepresenteradapter(valuepresenter), haschildren); } private void dosetpresentation(@nullable icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @nullable final string value, @nullable final xvaluepresenter valuepresenter, final boolean haschildren) { appuiutil.invokeonedt(new runnable() { public void run() { doshowhint(result, separator, value, type, valuepresenter == null ? xvaluenodeimpl.default_value_presenter : valuepresenter, haschildren); } }); } public void setpresentation(@nonnls final string name, @nullable final icon icon, @nonnls @nullable final string type, @nonnls @notnull final string value, final boolean haschildren) { setpresentation(icon, type, value, haschildren); } public void setpresentation(@nonnls final string name, @nullable final icon icon, @nonnls @nullable final string type, @nonnls @notnull final string separator, @nonnls @notnull final string value, final boolean haschildren) { setpresentation(icon, type, separator, value, haschildren); } public void setfullvalueevaluator(@notnull xfullvalueevaluator fullvalueevaluator) { } public boolean isobsolete() { return false; } }, xvalueplace.tooltip); } public void erroroccurred(@notnull final string errormessage) { log.debug(\"cannot evaluate '\" + myexpression + \"':\" + errormessage); } }, myexpressionposition); }","repo":"liveqmock\/platform-tools-idea","label":[0,1,0,0]}
{"id":25388,"original_code":"@DB\n    private Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\n                                       boolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\n                                       final long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\n                                       final Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\n        final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\n        final DataCenterVO zone = _dcDao.findById(zoneId);\n        \/\/ this method supports only guest network creation\n        if (ntwkOff.getTrafficType() != TrafficType.Guest) {\n            s_logger.warn(\"Only guest networks can be created using this method\");\n            return null;\n        }\n        final boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n        \/\/check resource limits\n        if (updateResourceCount) {\n            _resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n        }\n        \/\/ Validate network offering\n        if (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n            \/\/ see NetworkOfferingVO\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\n            ex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\n            throw ex;\n        }\n        \/\/ Validate physical network\n        if (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n            \/\/ see PhysicalNetworkVO.java\n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n            ex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\n            throw ex;\n        }\n        boolean ipv6 = false;\n        if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n            ipv6 = true;\n        }\n        \/\/ Validate zone\n        if (zone.getNetworkType() == NetworkType.Basic) {\n            \/\/ In Basic zone the network should have aclType=Domain, domainId=1, subdomainAccess=true\n            if (aclType == null || aclType != ACLType.Domain) {\n                throw new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n            }\n            \/\/ Only one guest network is supported in Basic zone\n            final List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\n            if (!guestNetworks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n            }\n            \/\/ if zone is basic, only Shared network offerings w\/o source nat service are allowed\n            if (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\n                throw new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n                        + Service.SourceNat.getName() + \" service are allowed\");\n            }\n            if (domainId == null || domainId != Domain.ROOT_DOMAIN) {\n                throw new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n            }\n            if (subdomainAccess == null) {\n                subdomainAccess = true;\n            } else if (!subdomainAccess) {\n                throw new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n            }\n            if (vlanId == null) {\n                vlanId = Vlan.UNTAGGED;\n            } else {\n                if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                    throw new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n                }\n            }\n        } else if (zone.getNetworkType() == NetworkType.Advanced) {\n            if (zone.isSecurityGroupEnabled()) {\n                if (isolatedPvlan != null) {\n                    throw new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n                }\n                \/\/ Only Account specific Isolated network with sourceNat service disabled are allowed in security group\n                \/\/ enabled zone\n                if (ntwkOff.getGuestType() != GuestType.Shared) {\n                    throw new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n                }\n                if (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\n                    throw new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n                }\n            }\n            \/\/don't allow eip\/elb networks in Advance zone\n            if (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\n                throw new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n            }\n        }\n        if (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\n            throw new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n        }\n        \/\/TODO(VXLAN): Support VNI specified\n        \/\/ VlanId can be specified only when network offering supports it\n        final boolean vlanSpecified = vlanId != null;\n        if (vlanSpecified != ntwkOff.isSpecifyVlan()) {\n            if (vlanSpecified) {\n                throw new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n            } else {\n                throw new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n            }\n        }\n        if (vlanSpecified) {\n            URI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n            \/\/ Aux: generate secondary URI for secondary VLAN ID (if provided) for performing checks\n            URI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n            \/\/don't allow to specify vlan tag used by physical network for dynamic vlan allocation\n            if (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n                    _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (! UuidUtils.validateUUID(vlanId)){\n                \/\/ For Isolated and L2 networks, don't allow to create network with vlan that already exists in the zone\n                if (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\n                    if (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else {\n                        final List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n                        \/\/for the network that is created as part of private gateway,\n                        \/\/the vnet is not coming from the data center vnet table, so the list can be empty\n                        if (!dcVnets.isEmpty()) {\n                            final DataCenterVnetVO dcVnet = dcVnets.get(0);\n                            \/\/ Fail network creation if specified vlan is dedicated to a different account\n                            if (dcVnet.getAccountGuestVlanMapId() != null) {\n                                final Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\n                                final AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\n                                if (map.getAccountId() != owner.getAccountId()) {\n                                    throw new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n                                }\n                                \/\/ Fail network creation if owner has a dedicated range of vlans but the specified vlan belongs to the system pool\n                            } else {\n                                final List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\n                                if (maps != null && !maps.isEmpty()) {\n                                    final int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\n                                    final int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\n                                    if (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\n                                        throw new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n                                                + owner.getAccountName());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    \/\/ don't allow to creating shared network with given Vlan ID, if there already exists a isolated network or\n                    \/\/ shared network with same Vlan ID in the zone\n                    if (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\n                        throw new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n                    }\n                }\n            }\n        }\n        \/\/ If networkDomain is not specified, take it from the global configuration\n        if (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\n            final Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\n                    Service.Dns);\n            final String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\n            if (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\n                if (networkDomain != null) {\n                    \/\/ TBD: NetworkOfferingId and zoneId. Send uuids instead.\n                    throw new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n                }\n            } else {\n                if (networkDomain == null) {\n                    \/\/ 1) Get networkDomain from the corresponding account\/domain\/zone\n                    if (aclType == ACLType.Domain) {\n                        networkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n                    } else if (aclType == ACLType.Account) {\n                        networkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n                    }\n                    \/\/ 2) If null, generate networkDomain using domain suffix from the global config variables\n                    if (networkDomain == null) {\n                        networkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n                    }\n                } else {\n                    \/\/ validate network domain\n                    if (!NetUtils.verifyDomainName(networkDomain)) {\n                        throw new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n                                + \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                                + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n                    }\n                }\n            }\n        }\n        \/\/ In Advance zone Cidr for Shared networks and Isolated networks w\/o source nat service can't be NULL - 2.2.x\n        \/\/ limitation, remove after we introduce support for multiple ip ranges\n        \/\/ with different Cidrs for the same Shared network\n        final boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n                && ntwkOff.getTrafficType() == TrafficType.Guest\n                && (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n                && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\n        if (cidr == null && ip6Cidr == null && cidrRequired) {\n            if (ntwkOff.getGuestType() == GuestType.Shared) {\n                throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n            } else {\n                throw new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n            }\n        }\n        checkL2OfferingServices(ntwkOff);\n        \/\/ No cidr can be specified in Basic zone\n        if (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\n            throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n        }\n        \/\/ Check if cidr is RFC1918 compliant if the network is Guest Isolated for IPv4\n        if (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\n            if (!NetUtils.validateGuestCidr(cidr)) {\n                throw new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n            }\n        }\n        final String networkDomainFinal = networkDomain;\n        final String vlanIdFinal = vlanId;\n        final Boolean subdomainAccessFinal = subdomainAccess;\n        final Network network = Transaction.execute(new TransactionCallback<Network>() {\n            @Override\n            public Network doInTransaction(final TransactionStatus status) {\n                Long physicalNetworkId = null;\n                if (pNtwk != null) {\n                    physicalNetworkId = pNtwk.getId();\n                }\n                final DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\n                final NetworkVO userNetwork = new NetworkVO();\n                userNetwork.setNetworkDomain(networkDomainFinal);\n                if (cidr != null && gateway != null) {\n                    userNetwork.setCidr(cidr);\n                    userNetwork.setGateway(gateway);\n                }\n                if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n                    userNetwork.setIp6Cidr(ip6Cidr);\n                    userNetwork.setIp6Gateway(ip6Gateway);\n                }\n                if (externalId != null) {\n                    userNetwork.setExternalId(externalId);\n                }\n                if (StringUtils.isNotBlank(routerIp)) {\n                    userNetwork.setRouterIp(routerIp);\n                }\n                if (StringUtils.isNotBlank(routerIpv6)) {\n                    userNetwork.setRouterIpv6(routerIpv6);\n                }\n                if (vlanIdFinal != null) {\n                    if (isolatedPvlan == null) {\n                        URI uri = null;\n                        if (UuidUtils.validateUUID(vlanIdFinal)){\n                            \/\/Logical router's UUID provided as VLAN_ID\n                            userNetwork.setVlanIdAsUUID(vlanIdFinal); \/\/Set transient field\n                        } else {\n                            uri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n                        }\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n                                \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        if (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                        } else {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                        }\n                    } else {\n                        if (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            throw new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n                        }\n                        URI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with primary vlan \" + vlanIdFinal +\n                                    \" and secondary vlan \" + isolatedPvlan + \" type \" + isolatedPvlanType +\n                                    \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        userNetwork.setBroadcastDomainType(BroadcastDomainType.Pvlan);\n                        userNetwork.setPvlanType(isolatedPvlanType);\n                    }\n                }\n                final List<? extends Network> networks = setupNetwork(owner, ntwkOff, userNetwork, plan, name, displayText, true, domainId, aclType, subdomainAccessFinal, vpcId,\n                        isDisplayNetworkEnabled);\n                Network network = null;\n                if (networks == null || networks.isEmpty()) {\n                    throw new CloudRuntimeException(\"Fail to create a network\");\n                } else {\n                    if (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\n                        Network defaultGuestNetwork = networks.get(0);\n                        for (final Network nw : networks) {\n                            if (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\n                                defaultGuestNetwork = nw;\n                            }\n                        }\n                        network = defaultGuestNetwork;\n                    } else {\n                        \/\/ For shared network\n                        network = networks.get(0);\n                    }\n                }\n                if (updateResourceCount) {\n                    _resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n                }\n                return network;\n            }\n        });\n        CallContext.current().setEventDetails(\"Network Id: \" + network.getId());\n        CallContext.current().putContextParameter(Network.class, network.getUuid());\n        return network;\n    }","code_wo_comment":"@DB\n    private Network createGuestNetwork(final long networkOfferingId, final String name, final String displayText, final String gateway, final String cidr, String vlanId,\n                                       boolean bypassVlanOverlapCheck, String networkDomain, final Account owner, final Long domainId, final PhysicalNetwork pNtwk,\n                                       final long zoneId, final ACLType aclType, Boolean subdomainAccess, final Long vpcId, final String ip6Gateway, final String ip6Cidr,\n                                       final Boolean isDisplayNetworkEnabled, final String isolatedPvlan, Network.PVlanType isolatedPvlanType, String externalId, final Boolean isPrivateNetwork, String routerIp, String routerIpv6) throws ConcurrentOperationException, InsufficientCapacityException, ResourceAllocationException {\n        final NetworkOfferingVO ntwkOff = _networkOfferingDao.findById(networkOfferingId);\n        final DataCenterVO zone = _dcDao.findById(zoneId);\n       \n        if (ntwkOff.getTrafficType() != TrafficType.Guest) {\n            s_logger.warn(\"Only guest networks can be created using this method\");\n            return null;\n        }\n        final boolean updateResourceCount = resourceCountNeedsUpdate(ntwkOff, aclType);\n       \n        if (updateResourceCount) {\n            _resourceLimitMgr.checkResourceLimit(owner, ResourceType.network, isDisplayNetworkEnabled);\n        }\n       \n        if (ntwkOff.getState() != NetworkOffering.State.Enabled) {\n           \n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Can't use specified network offering id as its state is not \" + NetworkOffering.State.Enabled);\n            ex.addProxyObject(ntwkOff.getUuid(), \"networkOfferingId\");\n            throw ex;\n        }\n       \n        if (pNtwk.getState() != PhysicalNetwork.State.Enabled) {\n           \n            final InvalidParameterValueException ex = new InvalidParameterValueException(\"Specified physical network id is\" + \" in incorrect state:\" + pNtwk.getState());\n            ex.addProxyObject(pNtwk.getUuid(), \"physicalNetworkId\");\n            throw ex;\n        }\n        boolean ipv6 = false;\n        if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n            ipv6 = true;\n        }\n       \n        if (zone.getNetworkType() == NetworkType.Basic) {\n           \n            if (aclType == null || aclType != ACLType.Domain) {\n                throw new InvalidParameterValueException(\"Only AclType=Domain can be specified for network creation in Basic zone\");\n            }\n           \n            final List<NetworkVO> guestNetworks = _networksDao.listByZoneAndTrafficType(zone.getId(), TrafficType.Guest);\n            if (!guestNetworks.isEmpty()) {\n                throw new InvalidParameterValueException(\"Can't have more than one Guest network in zone with network type \" + NetworkType.Basic);\n            }\n           \n            if (!(ntwkOff.getGuestType() == GuestType.Shared && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat))) {\n                throw new InvalidParameterValueException(\"For zone of type \" + NetworkType.Basic + \" only offerings of \" + \"guestType \" + GuestType.Shared + \" with disabled \"\n                        + Service.SourceNat.getName() + \" service are allowed\");\n            }\n            if (domainId == null || domainId != Domain.ROOT_DOMAIN) {\n                throw new InvalidParameterValueException(\"Guest network in Basic zone should be dedicated to ROOT domain\");\n            }\n            if (subdomainAccess == null) {\n                subdomainAccess = true;\n            } else if (!subdomainAccess) {\n                throw new InvalidParameterValueException(\"Subdomain access should be set to true for the\" + \" guest network in the Basic zone\");\n            }\n            if (vlanId == null) {\n                vlanId = Vlan.UNTAGGED;\n            } else {\n                if (!vlanId.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                    throw new InvalidParameterValueException(\"Only vlan \" + Vlan.UNTAGGED + \" can be created in \" + \"the zone of type \" + NetworkType.Basic);\n                }\n            }\n        } else if (zone.getNetworkType() == NetworkType.Advanced) {\n            if (zone.isSecurityGroupEnabled()) {\n                if (isolatedPvlan != null) {\n                    throw new InvalidParameterValueException(\"Isolated Private VLAN is not supported with security group!\");\n                }\n               \n               \n                if (ntwkOff.getGuestType() != GuestType.Shared) {\n                    throw new InvalidParameterValueException(\"Only shared guest network can be created in security group enabled zone\");\n                }\n                if (_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)) {\n                    throw new InvalidParameterValueException(\"Service SourceNat is not allowed in security group enabled zone\");\n                }\n            }\n           \n            if (ntwkOff.isElasticIp() || ntwkOff.isElasticLb()) {\n                throw new InvalidParameterValueException(\"Elastic IP and Elastic LB services are supported in zone of type \" + NetworkType.Basic);\n            }\n        }\n        if (ipv6 && NetUtils.getIp6CidrSize(ip6Cidr) != 64) {\n            throw new InvalidParameterValueException(\"IPv6 subnet should be exactly 64-bits in size\");\n        }\n       \n       \n        final boolean vlanSpecified = vlanId != null;\n        if (vlanSpecified != ntwkOff.isSpecifyVlan()) {\n            if (vlanSpecified) {\n                throw new InvalidParameterValueException(\"Can't specify vlan; corresponding offering says specifyVlan=false\");\n            } else {\n                throw new InvalidParameterValueException(\"Vlan has to be specified; corresponding offering says specifyVlan=true\");\n            }\n        }\n        if (vlanSpecified) {\n            URI uri = encodeVlanIdIntoBroadcastUri(vlanId, pNtwk);\n           \n            URI secondaryUri = StringUtils.isNotBlank(isolatedPvlan) ? BroadcastDomainType.fromString(isolatedPvlan) : null;\n           \n            if (!(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) && _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(uri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag to use for new guest network, \" + vlanId + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (secondaryUri != null && !(bypassVlanOverlapCheck && ntwkOff.getGuestType() == GuestType.Shared) &&\n                    _dcDao.findVnet(zoneId, pNtwk.getId(), BroadcastDomainType.getValue(secondaryUri)).size() > 0) {\n                throw new InvalidParameterValueException(\"The VLAN tag for isolated PVLAN \" + isolatedPvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \"\n                        + zone.getName());\n            }\n            if (! UuidUtils.validateUUID(vlanId)){\n               \n                if (!hasGuestBypassVlanOverlapCheck(bypassVlanOverlapCheck, ntwkOff, isPrivateNetwork)) {\n                    if (_networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + vlanId + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else if (secondaryUri != null && _networksDao.listByZoneAndUriAndGuestType(zoneId, secondaryUri.toString(), null).size() > 0) {\n                        throw new InvalidParameterValueException(\"Network with vlan \" + isolatedPvlan + \" already exists or overlaps with other network vlans in zone \" + zoneId);\n                    } else {\n                        final List<DataCenterVnetVO> dcVnets = _datacenterVnetDao.findVnet(zoneId, BroadcastDomainType.getValue(uri));\n                       \n                       \n                        if (!dcVnets.isEmpty()) {\n                            final DataCenterVnetVO dcVnet = dcVnets.get(0);\n                           \n                            if (dcVnet.getAccountGuestVlanMapId() != null) {\n                                final Long accountGuestVlanMapId = dcVnet.getAccountGuestVlanMapId();\n                                final AccountGuestVlanMapVO map = _accountGuestVlanMapDao.findById(accountGuestVlanMapId);\n                                if (map.getAccountId() != owner.getAccountId()) {\n                                    throw new InvalidParameterValueException(\"Vlan \" + vlanId + \" is dedicated to a different account\");\n                                }\n                               \n                            } else {\n                                final List<AccountGuestVlanMapVO> maps = _accountGuestVlanMapDao.listAccountGuestVlanMapsByAccount(owner.getAccountId());\n                                if (maps != null && !maps.isEmpty()) {\n                                    final int vnetsAllocatedToAccount = _datacenterVnetDao.countVnetsAllocatedToAccount(zoneId, owner.getAccountId());\n                                    final int vnetsDedicatedToAccount = _datacenterVnetDao.countVnetsDedicatedToAccount(zoneId, owner.getAccountId());\n                                    if (vnetsAllocatedToAccount < vnetsDedicatedToAccount) {\n                                        throw new InvalidParameterValueException(\"Specified vlan \" + vlanId + \" doesn't belong\" + \" to the vlan range dedicated to the owner \"\n                                                + owner.getAccountName());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } else {\n                   \n                   \n                    if (!bypassVlanOverlapCheck && _networksDao.listByZoneAndUriAndGuestType(zoneId, uri.toString(), GuestType.Isolated).size() > 0 ) {\n                        throw new InvalidParameterValueException(\"There is an existing isolated\/shared network that overlaps with vlan id:\" + vlanId + \" in zone \" + zoneId);\n                    }\n                }\n            }\n        }\n       \n        if (_networkModel.areServicesSupportedByNetworkOffering(networkOfferingId, Service.Dns)) {\n            final Map<Network.Capability, String> dnsCapabilities = _networkModel.getNetworkOfferingServiceCapabilities(_entityMgr.findById(NetworkOffering.class, networkOfferingId),\n                    Service.Dns);\n            final String isUpdateDnsSupported = dnsCapabilities.get(Capability.AllowDnsSuffixModification);\n            if (isUpdateDnsSupported == null || !Boolean.valueOf(isUpdateDnsSupported)) {\n                if (networkDomain != null) {\n                   \n                    throw new InvalidParameterValueException(\"Domain name change is not supported by network offering id=\" + networkOfferingId + \" in zone id=\" + zoneId);\n                }\n            } else {\n                if (networkDomain == null) {\n                   \n                    if (aclType == ACLType.Domain) {\n                        networkDomain = _networkModel.getDomainNetworkDomain(domainId, zoneId);\n                    } else if (aclType == ACLType.Account) {\n                        networkDomain = _networkModel.getAccountNetworkDomain(owner.getId(), zoneId);\n                    }\n                   \n                    if (networkDomain == null) {\n                        networkDomain = \"cs\" + Long.toHexString(owner.getId()) + GuestDomainSuffix.valueIn(zoneId);\n                    }\n                } else {\n                   \n                    if (!NetUtils.verifyDomainName(networkDomain)) {\n                        throw new InvalidParameterValueException(\"Invalid network domain. Total length shouldn't exceed 190 chars. Each domain \"\n                                + \"label must be between 1 and 63 characters long, can contain ASCII letters 'a' through 'z', the digits '0' through '9', \"\n                                + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\");\n                    }\n                }\n            }\n        }\n       \n       \n       \n        final boolean cidrRequired = zone.getNetworkType() == NetworkType.Advanced\n                && ntwkOff.getTrafficType() == TrafficType.Guest\n                && (ntwkOff.getGuestType() == GuestType.Shared || (ntwkOff.getGuestType() == GuestType.Isolated\n                && !_networkModel.areServicesSupportedByNetworkOffering(ntwkOff.getId(), Service.SourceNat)));\n        if (cidr == null && ip6Cidr == null && cidrRequired) {\n            if (ntwkOff.getGuestType() == GuestType.Shared) {\n                throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask are required when create network of\" + \" type \" + Network.GuestType.Shared);\n            } else {\n                throw new InvalidParameterValueException(\"gateway\/netmask are required when create network of\" + \" type \" + GuestType.Isolated + \" with service \" + Service.SourceNat.getName() + \" disabled\");\n            }\n        }\n        checkL2OfferingServices(ntwkOff);\n       \n        if (zone.getNetworkType() == NetworkType.Basic && cidr != null) {\n            throw new InvalidParameterValueException(\"StartIp\/endIp\/gateway\/netmask can't be specified for zone of type \" + NetworkType.Basic);\n        }\n       \n        if (cidr != null && ntwkOff.getGuestType() == Network.GuestType.Isolated && ntwkOff.getTrafficType() == TrafficType.Guest) {\n            if (!NetUtils.validateGuestCidr(cidr)) {\n                throw new InvalidParameterValueException(\"Virtual Guest Cidr \" + cidr + \" is not RFC 1918 or 6598 compliant\");\n            }\n        }\n        final String networkDomainFinal = networkDomain;\n        final String vlanIdFinal = vlanId;\n        final Boolean subdomainAccessFinal = subdomainAccess;\n        final Network network = Transaction.execute(new TransactionCallback<Network>() {\n            @Override\n            public Network doInTransaction(final TransactionStatus status) {\n                Long physicalNetworkId = null;\n                if (pNtwk != null) {\n                    physicalNetworkId = pNtwk.getId();\n                }\n                final DataCenterDeployment plan = new DataCenterDeployment(zoneId, null, null, null, null, physicalNetworkId);\n                final NetworkVO userNetwork = new NetworkVO();\n                userNetwork.setNetworkDomain(networkDomainFinal);\n                if (cidr != null && gateway != null) {\n                    userNetwork.setCidr(cidr);\n                    userNetwork.setGateway(gateway);\n                }\n                if (StringUtils.isNoneBlank(ip6Gateway, ip6Cidr)) {\n                    userNetwork.setIp6Cidr(ip6Cidr);\n                    userNetwork.setIp6Gateway(ip6Gateway);\n                }\n                if (externalId != null) {\n                    userNetwork.setExternalId(externalId);\n                }\n                if (StringUtils.isNotBlank(routerIp)) {\n                    userNetwork.setRouterIp(routerIp);\n                }\n                if (StringUtils.isNotBlank(routerIpv6)) {\n                    userNetwork.setRouterIpv6(routerIpv6);\n                }\n                if (vlanIdFinal != null) {\n                    if (isolatedPvlan == null) {\n                        URI uri = null;\n                        if (UuidUtils.validateUUID(vlanIdFinal)){\n                           \n                            userNetwork.setVlanIdAsUUID(vlanIdFinal);\n                        } else {\n                            uri = encodeVlanIdIntoBroadcastUri(vlanIdFinal, pNtwk);\n                        }\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString()).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with vlan \" + vlanIdFinal +\n                                \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        if (!vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Vlan);\n                        } else {\n                            userNetwork.setBroadcastDomainType(BroadcastDomainType.Native);\n                        }\n                    } else {\n                        if (vlanIdFinal.equalsIgnoreCase(Vlan.UNTAGGED)) {\n                            throw new InvalidParameterValueException(\"Cannot support pvlan with untagged primary vlan!\");\n                        }\n                        URI uri = NetUtils.generateUriForPvlan(vlanIdFinal, isolatedPvlan, isolatedPvlanType.toString());\n                        if (_networksDao.listByPhysicalNetworkPvlan(physicalNetworkId, uri.toString(), isolatedPvlanType).size() > 0) {\n                            throw new InvalidParameterValueException(\"Network with primary vlan \" + vlanIdFinal +\n                                    \" and secondary vlan \" + isolatedPvlan + \" type \" + isolatedPvlanType +\n                                    \" already exists or overlaps with other network pvlans in zone \" + zoneId);\n                        }\n                        userNetwork.setBroadcastUri(uri);\n                        userNetwork.setBroadcastDomainType(BroadcastDomainType.Pvlan);\n                        userNetwork.setPvlanType(isolatedPvlanType);\n                    }\n                }\n                final List<? extends Network> networks = setupNetwork(owner, ntwkOff, userNetwork, plan, name, displayText, true, domainId, aclType, subdomainAccessFinal, vpcId,\n                        isDisplayNetworkEnabled);\n                Network network = null;\n                if (networks == null || networks.isEmpty()) {\n                    throw new CloudRuntimeException(\"Fail to create a network\");\n                } else {\n                    if (networks.size() > 0 && networks.get(0).getGuestType() == Network.GuestType.Isolated && networks.get(0).getTrafficType() == TrafficType.Guest) {\n                        Network defaultGuestNetwork = networks.get(0);\n                        for (final Network nw : networks) {\n                            if (nw.getCidr() != null && nw.getCidr().equals(zone.getGuestNetworkCidr())) {\n                                defaultGuestNetwork = nw;\n                            }\n                        }\n                        network = defaultGuestNetwork;\n                    } else {\n                       \n                        network = networks.get(0);\n                    }\n                }\n                if (updateResourceCount) {\n                    _resourceLimitMgr.incrementResourceCount(owner.getId(), ResourceType.network, isDisplayNetworkEnabled);\n                }\n                return network;\n            }\n        });\n        CallContext.current().setEventDetails(\"Network Id: \" + network.getId());\n        CallContext.current().putContextParameter(Network.class, network.getUuid());\n        return network;\n    }","cleancode":"@db private network createguestnetwork(final long networkofferingid, final string name, final string displaytext, final string gateway, final string cidr, string vlanid, boolean bypassvlanoverlapcheck, string networkdomain, final account owner, final long domainid, final physicalnetwork pntwk, final long zoneid, final acltype acltype, boolean subdomainaccess, final long vpcid, final string ip6gateway, final string ip6cidr, final boolean isdisplaynetworkenabled, final string isolatedpvlan, network.pvlantype isolatedpvlantype, string externalid, final boolean isprivatenetwork, string routerip, string routeripv6) throws concurrentoperationexception, insufficientcapacityexception, resourceallocationexception { final networkofferingvo ntwkoff = _networkofferingdao.findbyid(networkofferingid); final datacentervo zone = _dcdao.findbyid(zoneid); if (ntwkoff.gettraffictype() != traffictype.guest) { s_logger.warn(\"only guest networks can be created using this method\"); return null; } final boolean updateresourcecount = resourcecountneedsupdate(ntwkoff, acltype); if (updateresourcecount) { _resourcelimitmgr.checkresourcelimit(owner, resourcetype.network, isdisplaynetworkenabled); } if (ntwkoff.getstate() != networkoffering.state.enabled) { final invalidparametervalueexception ex = new invalidparametervalueexception(\"can't use specified network offering id as its state is not \" + networkoffering.state.enabled); ex.addproxyobject(ntwkoff.getuuid(), \"networkofferingid\"); throw ex; } if (pntwk.getstate() != physicalnetwork.state.enabled) { final invalidparametervalueexception ex = new invalidparametervalueexception(\"specified physical network id is\" + \" in incorrect state:\" + pntwk.getstate()); ex.addproxyobject(pntwk.getuuid(), \"physicalnetworkid\"); throw ex; } boolean ipv6 = false; if (stringutils.isnoneblank(ip6gateway, ip6cidr)) { ipv6 = true; } if (zone.getnetworktype() == networktype.basic) { if (acltype == null || acltype != acltype.domain) { throw new invalidparametervalueexception(\"only acltype=domain can be specified for network creation in basic zone\"); } final list<networkvo> guestnetworks = _networksdao.listbyzoneandtraffictype(zone.getid(), traffictype.guest); if (!guestnetworks.isempty()) { throw new invalidparametervalueexception(\"can't have more than one guest network in zone with network type \" + networktype.basic); } if (!(ntwkoff.getguesttype() == guesttype.shared && !_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat))) { throw new invalidparametervalueexception(\"for zone of type \" + networktype.basic + \" only offerings of \" + \"guesttype \" + guesttype.shared + \" with disabled \" + service.sourcenat.getname() + \" service are allowed\"); } if (domainid == null || domainid != domain.root_domain) { throw new invalidparametervalueexception(\"guest network in basic zone should be dedicated to root domain\"); } if (subdomainaccess == null) { subdomainaccess = true; } else if (!subdomainaccess) { throw new invalidparametervalueexception(\"subdomain access should be set to true for the\" + \" guest network in the basic zone\"); } if (vlanid == null) { vlanid = vlan.untagged; } else { if (!vlanid.equalsignorecase(vlan.untagged)) { throw new invalidparametervalueexception(\"only vlan \" + vlan.untagged + \" can be created in \" + \"the zone of type \" + networktype.basic); } } } else if (zone.getnetworktype() == networktype.advanced) { if (zone.issecuritygroupenabled()) { if (isolatedpvlan != null) { throw new invalidparametervalueexception(\"isolated private vlan is not supported with security group!\"); } if (ntwkoff.getguesttype() != guesttype.shared) { throw new invalidparametervalueexception(\"only shared guest network can be created in security group enabled zone\"); } if (_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat)) { throw new invalidparametervalueexception(\"service sourcenat is not allowed in security group enabled zone\"); } } if (ntwkoff.iselasticip() || ntwkoff.iselasticlb()) { throw new invalidparametervalueexception(\"elastic ip and elastic lb services are supported in zone of type \" + networktype.basic); } } if (ipv6 && netutils.getip6cidrsize(ip6cidr) != 64) { throw new invalidparametervalueexception(\"ipv6 subnet should be exactly 64-bits in size\"); } final boolean vlanspecified = vlanid != null; if (vlanspecified != ntwkoff.isspecifyvlan()) { if (vlanspecified) { throw new invalidparametervalueexception(\"can't specify vlan; corresponding offering says specifyvlan=false\"); } else { throw new invalidparametervalueexception(\"vlan has to be specified; corresponding offering says specifyvlan=true\"); } } if (vlanspecified) { uri uri = encodevlanidintobroadcasturi(vlanid, pntwk); uri secondaryuri = stringutils.isnotblank(isolatedpvlan) ? broadcastdomaintype.fromstring(isolatedpvlan) : null; if (!(bypassvlanoverlapcheck && ntwkoff.getguesttype() == guesttype.shared) && _dcdao.findvnet(zoneid, pntwk.getid(), broadcastdomaintype.getvalue(uri)).size() > 0) { throw new invalidparametervalueexception(\"the vlan tag to use for new guest network, \" + vlanid + \" is already being used for dynamic vlan allocation for the guest network in zone \" + zone.getname()); } if (secondaryuri != null && !(bypassvlanoverlapcheck && ntwkoff.getguesttype() == guesttype.shared) && _dcdao.findvnet(zoneid, pntwk.getid(), broadcastdomaintype.getvalue(secondaryuri)).size() > 0) { throw new invalidparametervalueexception(\"the vlan tag for isolated pvlan \" + isolatedpvlan + \" is already being used for dynamic vlan allocation for the guest network in zone \" + zone.getname()); } if (! uuidutils.validateuuid(vlanid)){ if (!hasguestbypassvlanoverlapcheck(bypassvlanoverlapcheck, ntwkoff, isprivatenetwork)) { if (_networksdao.listbyzoneanduriandguesttype(zoneid, uri.tostring(), null).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + vlanid + \" already exists or overlaps with other network vlans in zone \" + zoneid); } else if (secondaryuri != null && _networksdao.listbyzoneanduriandguesttype(zoneid, secondaryuri.tostring(), null).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + isolatedpvlan + \" already exists or overlaps with other network vlans in zone \" + zoneid); } else { final list<datacentervnetvo> dcvnets = _datacentervnetdao.findvnet(zoneid, broadcastdomaintype.getvalue(uri)); if (!dcvnets.isempty()) { final datacentervnetvo dcvnet = dcvnets.get(0); if (dcvnet.getaccountguestvlanmapid() != null) { final long accountguestvlanmapid = dcvnet.getaccountguestvlanmapid(); final accountguestvlanmapvo map = _accountguestvlanmapdao.findbyid(accountguestvlanmapid); if (map.getaccountid() != owner.getaccountid()) { throw new invalidparametervalueexception(\"vlan \" + vlanid + \" is dedicated to a different account\"); } } else { final list<accountguestvlanmapvo> maps = _accountguestvlanmapdao.listaccountguestvlanmapsbyaccount(owner.getaccountid()); if (maps != null && !maps.isempty()) { final int vnetsallocatedtoaccount = _datacentervnetdao.countvnetsallocatedtoaccount(zoneid, owner.getaccountid()); final int vnetsdedicatedtoaccount = _datacentervnetdao.countvnetsdedicatedtoaccount(zoneid, owner.getaccountid()); if (vnetsallocatedtoaccount < vnetsdedicatedtoaccount) { throw new invalidparametervalueexception(\"specified vlan \" + vlanid + \" doesn't belong\" + \" to the vlan range dedicated to the owner \" + owner.getaccountname()); } } } } } } else { if (!bypassvlanoverlapcheck && _networksdao.listbyzoneanduriandguesttype(zoneid, uri.tostring(), guesttype.isolated).size() > 0 ) { throw new invalidparametervalueexception(\"there is an existing isolated\/shared network that overlaps with vlan id:\" + vlanid + \" in zone \" + zoneid); } } } } if (_networkmodel.areservicessupportedbynetworkoffering(networkofferingid, service.dns)) { final map<network.capability, string> dnscapabilities = _networkmodel.getnetworkofferingservicecapabilities(_entitymgr.findbyid(networkoffering.class, networkofferingid), service.dns); final string isupdatednssupported = dnscapabilities.get(capability.allowdnssuffixmodification); if (isupdatednssupported == null || !boolean.valueof(isupdatednssupported)) { if (networkdomain != null) { throw new invalidparametervalueexception(\"domain name change is not supported by network offering id=\" + networkofferingid + \" in zone id=\" + zoneid); } } else { if (networkdomain == null) { if (acltype == acltype.domain) { networkdomain = _networkmodel.getdomainnetworkdomain(domainid, zoneid); } else if (acltype == acltype.account) { networkdomain = _networkmodel.getaccountnetworkdomain(owner.getid(), zoneid); } if (networkdomain == null) { networkdomain = \"cs\" + long.tohexstring(owner.getid()) + guestdomainsuffix.valuein(zoneid); } } else { if (!netutils.verifydomainname(networkdomain)) { throw new invalidparametervalueexception(\"invalid network domain. total length shouldn't exceed 190 chars. each domain \" + \"label must be between 1 and 63 characters long, can contain ascii letters 'a' through 'z', the digits '0' through '9', \" + \"and the hyphen ('-'); can't start or end with \\\"-\\\"\"); } } } } final boolean cidrrequired = zone.getnetworktype() == networktype.advanced && ntwkoff.gettraffictype() == traffictype.guest && (ntwkoff.getguesttype() == guesttype.shared || (ntwkoff.getguesttype() == guesttype.isolated && !_networkmodel.areservicessupportedbynetworkoffering(ntwkoff.getid(), service.sourcenat))); if (cidr == null && ip6cidr == null && cidrrequired) { if (ntwkoff.getguesttype() == guesttype.shared) { throw new invalidparametervalueexception(\"startip\/endip\/gateway\/netmask are required when create network of\" + \" type \" + network.guesttype.shared); } else { throw new invalidparametervalueexception(\"gateway\/netmask are required when create network of\" + \" type \" + guesttype.isolated + \" with service \" + service.sourcenat.getname() + \" disabled\"); } } checkl2offeringservices(ntwkoff); if (zone.getnetworktype() == networktype.basic && cidr != null) { throw new invalidparametervalueexception(\"startip\/endip\/gateway\/netmask can't be specified for zone of type \" + networktype.basic); } if (cidr != null && ntwkoff.getguesttype() == network.guesttype.isolated && ntwkoff.gettraffictype() == traffictype.guest) { if (!netutils.validateguestcidr(cidr)) { throw new invalidparametervalueexception(\"virtual guest cidr \" + cidr + \" is not rfc 1918 or 6598 compliant\"); } } final string networkdomainfinal = networkdomain; final string vlanidfinal = vlanid; final boolean subdomainaccessfinal = subdomainaccess; final network network = transaction.execute(new transactioncallback<network>() { @override public network dointransaction(final transactionstatus status) { long physicalnetworkid = null; if (pntwk != null) { physicalnetworkid = pntwk.getid(); } final datacenterdeployment plan = new datacenterdeployment(zoneid, null, null, null, null, physicalnetworkid); final networkvo usernetwork = new networkvo(); usernetwork.setnetworkdomain(networkdomainfinal); if (cidr != null && gateway != null) { usernetwork.setcidr(cidr); usernetwork.setgateway(gateway); } if (stringutils.isnoneblank(ip6gateway, ip6cidr)) { usernetwork.setip6cidr(ip6cidr); usernetwork.setip6gateway(ip6gateway); } if (externalid != null) { usernetwork.setexternalid(externalid); } if (stringutils.isnotblank(routerip)) { usernetwork.setrouterip(routerip); } if (stringutils.isnotblank(routeripv6)) { usernetwork.setrouteripv6(routeripv6); } if (vlanidfinal != null) { if (isolatedpvlan == null) { uri uri = null; if (uuidutils.validateuuid(vlanidfinal)){ usernetwork.setvlanidasuuid(vlanidfinal); } else { uri = encodevlanidintobroadcasturi(vlanidfinal, pntwk); } if (_networksdao.listbyphysicalnetworkpvlan(physicalnetworkid, uri.tostring()).size() > 0) { throw new invalidparametervalueexception(\"network with vlan \" + vlanidfinal + \" already exists or overlaps with other network pvlans in zone \" + zoneid); } usernetwork.setbroadcasturi(uri); if (!vlanidfinal.equalsignorecase(vlan.untagged)) { usernetwork.setbroadcastdomaintype(broadcastdomaintype.vlan); } else { usernetwork.setbroadcastdomaintype(broadcastdomaintype.native); } } else { if (vlanidfinal.equalsignorecase(vlan.untagged)) { throw new invalidparametervalueexception(\"cannot support pvlan with untagged primary vlan!\"); } uri uri = netutils.generateuriforpvlan(vlanidfinal, isolatedpvlan, isolatedpvlantype.tostring()); if (_networksdao.listbyphysicalnetworkpvlan(physicalnetworkid, uri.tostring(), isolatedpvlantype).size() > 0) { throw new invalidparametervalueexception(\"network with primary vlan \" + vlanidfinal + \" and secondary vlan \" + isolatedpvlan + \" type \" + isolatedpvlantype + \" already exists or overlaps with other network pvlans in zone \" + zoneid); } usernetwork.setbroadcasturi(uri); usernetwork.setbroadcastdomaintype(broadcastdomaintype.pvlan); usernetwork.setpvlantype(isolatedpvlantype); } } final list<? extends network> networks = setupnetwork(owner, ntwkoff, usernetwork, plan, name, displaytext, true, domainid, acltype, subdomainaccessfinal, vpcid, isdisplaynetworkenabled); network network = null; if (networks == null || networks.isempty()) { throw new cloudruntimeexception(\"fail to create a network\"); } else { if (networks.size() > 0 && networks.get(0).getguesttype() == network.guesttype.isolated && networks.get(0).gettraffictype() == traffictype.guest) { network defaultguestnetwork = networks.get(0); for (final network nw : networks) { if (nw.getcidr() != null && nw.getcidr().equals(zone.getguestnetworkcidr())) { defaultguestnetwork = nw; } } network = defaultguestnetwork; } else { network = networks.get(0); } } if (updateresourcecount) { _resourcelimitmgr.incrementresourcecount(owner.getid(), resourcetype.network, isdisplaynetworkenabled); } return network; } }); callcontext.current().seteventdetails(\"network id: \" + network.getid()); callcontext.current().putcontextparameter(network.class, network.getuuid()); return network; }","repo":"leolleeooleo\/cloudstack","label":[1,1,0,0]}
{"id":25403,"original_code":"public static String domToString(Document document) {\n\t\tSource source = new DOMSource(document);\n\t\ttry {\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\n\t\t\ttransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\n\t\t\tStringWriter sw=new StringWriter();\n            StreamResult resultStream = new StreamResult(sw);\n            transformer.transform(source, resultStream);\n            return sw.toString();\n\t\t} catch (TransformerException e) {\n\t\t\treturn e.toString();\n\t\t}\n\t}","code_wo_comment":"public static String domToString(Document document) {\n\t\tSource source = new DOMSource(document);\n\t\ttry {\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer transformer = factory.newTransformer();\n\t\t\ttransformer.setOutputProperty(OutputKeys. INDENT, \"yes\");\n\t\t\ttransformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\");\n\t\t\tStringWriter sw=new StringWriter();\n            StreamResult resultStream = new StreamResult(sw);\n            transformer.transform(source, resultStream);\n            return sw.toString();\n\t\t} catch (TransformerException e) {\n\t\t\treturn e.toString();\n\t\t}\n\t}","cleancode":"public static string domtostring(document document) { source source = new domsource(document); try { transformerfactory factory = transformerfactory.newinstance(); transformer transformer = factory.newtransformer(); transformer.setoutputproperty(outputkeys. indent, \"yes\"); transformer.setoutputproperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"1\"); stringwriter sw=new stringwriter(); streamresult resultstream = new streamresult(sw); transformer.transform(source, resultstream); return sw.tostring(); } catch (transformerexception e) { return e.tostring(); } }","repo":"mino98\/stix","label":[1,0,0,0]}
{"id":25580,"original_code":"private void deviceClientMonitorLoop() {\n        do {\n            try {\n                \/\/ This synchronized block stops us from doing the select() if a new\n                \/\/ Device is being added.\n                \/\/ @see startMonitoringDevice()\n                synchronized (mDevices) {\n                }\n                int count = mSelector.select();\n                if (mQuit) {\n                    return;\n                }\n                synchronized (mClientsToReopen) {\n                    if (mClientsToReopen.size() > 0) {\n                        Set<Client> clients = mClientsToReopen.keySet();\n                        MonitorThread monitorThread = MonitorThread.getInstance();\n                        for (Client client : clients) {\n                            Device device = client.getDeviceImpl();\n                            int pid = client.getClientData().getPid();\n                            monitorThread.dropClient(client, false \/* notify *\/);\n                            \/\/ This is kinda bad, but if we don't wait a bit, the client\n                            \/\/ will never answer the second handshake!\n                            waitABit();\n                            int port = mClientsToReopen.get(client);\n                            if (port == IDebugPortProvider.NO_STATIC_PORT) {\n                                port = getNextDebuggerPort();\n                            }\n                            Log.d(\"DeviceMonitor\", \"Reopening \" + client);\n                            openClient(device, pid, port, monitorThread);\n                            device.update(Device.CHANGE_CLIENT_LIST);\n                        }\n                        mClientsToReopen.clear();\n                    }\n                }\n                if (count == 0) {\n                    continue;\n                }\n                Set<SelectionKey> keys = mSelector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isValid() && key.isReadable()) {\n                        Object attachment = key.attachment();\n                        if (attachment instanceof Device) {\n                            Device device = (Device)attachment;\n                            SocketChannel socket = device.getClientMonitoringSocket();\n                            if (socket != null) {\n                                try {\n                                    int length = readLength(socket, mLengthBuffer2);\n                                    processIncomingJdwpData(device, socket, length);\n                                } catch (IOException ioe) {\n                                    Log.d(\"DeviceMonitor\",\n                                            \"Error reading jdwp list: \" + ioe.getMessage());\n                                    socket.close();\n                                    \/\/ restart the monitoring of that device\n                                    synchronized (mDevices) {\n                                        if (mDevices.contains(device)) {\n                                            Log.d(\"DeviceMonitor\",\n                                                    \"Restarting monitoring service for \" + device);\n                                            startMonitoringDevice(device);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                if (mQuit == false) {\n                }\n            }\n        } while (mQuit == false);\n    }","code_wo_comment":"private void deviceClientMonitorLoop() {\n        do {\n            try {\n               \n               \n               \n                synchronized (mDevices) {\n                }\n                int count = mSelector.select();\n                if (mQuit) {\n                    return;\n                }\n                synchronized (mClientsToReopen) {\n                    if (mClientsToReopen.size() > 0) {\n                        Set<Client> clients = mClientsToReopen.keySet();\n                        MonitorThread monitorThread = MonitorThread.getInstance();\n                        for (Client client : clients) {\n                            Device device = client.getDeviceImpl();\n                            int pid = client.getClientData().getPid();\n                            monitorThread.dropClient(client, false);\n                           \n                           \n                            waitABit();\n                            int port = mClientsToReopen.get(client);\n                            if (port == IDebugPortProvider.NO_STATIC_PORT) {\n                                port = getNextDebuggerPort();\n                            }\n                            Log.d(\"DeviceMonitor\", \"Reopening \" + client);\n                            openClient(device, pid, port, monitorThread);\n                            device.update(Device.CHANGE_CLIENT_LIST);\n                        }\n                        mClientsToReopen.clear();\n                    }\n                }\n                if (count == 0) {\n                    continue;\n                }\n                Set<SelectionKey> keys = mSelector.selectedKeys();\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    iter.remove();\n                    if (key.isValid() && key.isReadable()) {\n                        Object attachment = key.attachment();\n                        if (attachment instanceof Device) {\n                            Device device = (Device)attachment;\n                            SocketChannel socket = device.getClientMonitoringSocket();\n                            if (socket != null) {\n                                try {\n                                    int length = readLength(socket, mLengthBuffer2);\n                                    processIncomingJdwpData(device, socket, length);\n                                } catch (IOException ioe) {\n                                    Log.d(\"DeviceMonitor\",\n                                            \"Error reading jdwp list: \" + ioe.getMessage());\n                                    socket.close();\n                                   \n                                    synchronized (mDevices) {\n                                        if (mDevices.contains(device)) {\n                                            Log.d(\"DeviceMonitor\",\n                                                    \"Restarting monitoring service for \" + device);\n                                            startMonitoringDevice(device);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                if (mQuit == false) {\n                }\n            }\n        } while (mQuit == false);\n    }","cleancode":"private void deviceclientmonitorloop() { do { try { synchronized (mdevices) { } int count = mselector.select(); if (mquit) { return; } synchronized (mclientstoreopen) { if (mclientstoreopen.size() > 0) { set<client> clients = mclientstoreopen.keyset(); monitorthread monitorthread = monitorthread.getinstance(); for (client client : clients) { device device = client.getdeviceimpl(); int pid = client.getclientdata().getpid(); monitorthread.dropclient(client, false); waitabit(); int port = mclientstoreopen.get(client); if (port == idebugportprovider.no_static_port) { port = getnextdebuggerport(); } log.d(\"devicemonitor\", \"reopening \" + client); openclient(device, pid, port, monitorthread); device.update(device.change_client_list); } mclientstoreopen.clear(); } } if (count == 0) { continue; } set<selectionkey> keys = mselector.selectedkeys(); iterator<selectionkey> iter = keys.iterator(); while (iter.hasnext()) { selectionkey key = iter.next(); iter.remove(); if (key.isvalid() && key.isreadable()) { object attachment = key.attachment(); if (attachment instanceof device) { device device = (device)attachment; socketchannel socket = device.getclientmonitoringsocket(); if (socket != null) { try { int length = readlength(socket, mlengthbuffer2); processincomingjdwpdata(device, socket, length); } catch (ioexception ioe) { log.d(\"devicemonitor\", \"error reading jdwp list: \" + ioe.getmessage()); socket.close(); synchronized (mdevices) { if (mdevices.contains(device)) { log.d(\"devicemonitor\", \"restarting monitoring service for \" + device); startmonitoringdevice(device); } } } } } } } } catch (ioexception e) { if (mquit == false) { } } } while (mquit == false); }","repo":"lrscp\/ControlAndroidDeviceFromPC","label":[1,0,0,0]}
{"id":33797,"original_code":"@POST\n\t@Path(\"\/services\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.CREATE_SERVICE + \"\\\")\")\n\tpublic RangerService createService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.createService(\" + service + \")\");\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.CREATE);\n\t\t\tUserSessionBase session = ContextUtil.getCurrentUserSession();\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tif(session != null && !session.isSpnegoEnabled()){\n\t\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\t\/\/ services including KMS\n\t\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\t}\n\t\t\tif(session != null && session.isSpnegoEnabled()){\n\t\t\t\tif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t\tif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = svcStore.createService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"createService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.createService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","code_wo_comment":"@POST\n\t@Path(\"\/services\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.CREATE_SERVICE + \"\\\")\")\n\tpublic RangerService createService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.createService(\" + service + \")\");\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.createService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.CREATE);\n\t\t\tUserSessionBase session = ContextUtil.getCurrentUserSession();\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tif(session != null && !session.isSpnegoEnabled()){\n\t\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\n\t\t\t\n\t\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\t}\n\t\t\tif(session != null && session.isSpnegoEnabled()){\n\t\t\t\tif (session.isKeyAdmin() && !xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"KeyAdmin can create\/update\/delete only KMS \",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t\tif ((!session.isKeyAdmin() && !session.isUserAdmin()) && xxServiceDef.getImplclassname().equals(EmbeddedServiceDefsUtil.KMS_IMPL_CLASS_NAME)) {\n\t\t\t\t\tthrow restErrorUtil.createRESTException(\"User cannot create\/update\/delete KMS Service\",\n\t\t\t\t\t\t\tMessageEnums.OPER_NO_PERMISSION);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = svcStore.createService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"createService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.createService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","cleancode":"@post @path(\"\/services\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.create_service + \"\\\")\") public rangerservice createservice(rangerservice service) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.createservice(\" + service + \")\"); } rangerservice ret = null; rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.createservice(servicename=\" + service.getname() + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(service, action.create); usersessionbase session = contextutil.getcurrentusersession(); xxservicedef xxservicedef = daomanager.getxxservicedef().findbyname(service.gettype()); if(session != null && !session.isspnegoenabled()){ bizutil.hasadminpermissions(\"services\"); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); } if(session != null && session.isspnegoenabled()){ if (session.iskeyadmin() && !xxservicedef.getimplclassname().equals(embeddedservicedefsutil.kms_impl_class_name)) { throw resterrorutil.createrestexception(\"keyadmin can create\/update\/delete only kms \", messageenums.oper_no_permission); } if ((!session.iskeyadmin() && !session.isuseradmin()) && xxservicedef.getimplclassname().equals(embeddedservicedefsutil.kms_impl_class_name)) { throw resterrorutil.createrestexception(\"user cannot create\/update\/delete kms service\", messageenums.oper_no_permission); } } ret = svcstore.createservice(service); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"createservice(\" + service + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.createservice(\" + service + \"): \" + ret); } return ret; }","repo":"lw-lin\/incubator-ranger","label":[1,0,0,0]}
{"id":33798,"original_code":"@PUT\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.UPDATE_SERVICE + \"\\\")\")\n\tpublic RangerService updateService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.updateService(): \" + service);\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.UPDATE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\/\/ services including KMS\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\tret = svcStore.updateService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"updateService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.updateService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","code_wo_comment":"@PUT\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.UPDATE_SERVICE + \"\\\")\")\n\tpublic RangerService updateService(RangerService service) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.updateService(): \" + service);\n\t\t}\n\t\tRangerService    ret  = null;\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.updateService(serviceName=\" + service.getName() + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(service, Action.UPDATE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\n\t\t\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().findByName(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\tret = svcStore.updateService(service);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"updateService(\" + service + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.updateService(\" + service + \"): \" + ret);\n\t\t}\n\t\treturn ret;\n\t}","cleancode":"@put @path(\"\/services\/{id}\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.update_service + \"\\\")\") public rangerservice updateservice(rangerservice service) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.updateservice(): \" + service); } rangerservice ret = null; rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.updateservice(servicename=\" + service.getname() + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(service, action.update); bizutil.hasadminpermissions(\"services\"); xxservicedef xxservicedef = daomanager.getxxservicedef().findbyname(service.gettype()); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); ret = svcstore.updateservice(service); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"updateservice(\" + service + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.updateservice(\" + service + \"): \" + ret); } return ret; }","repo":"lw-lin\/incubator-ranger","label":[1,0,0,0]}
{"id":33799,"original_code":"@DELETE\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.DELETE_SERVICE + \"\\\")\")\n\tpublic void deleteService(@PathParam(\"id\") Long id) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(id, Action.DELETE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\t\/\/ TODO: As of now we are allowing SYS_ADMIN to create all the\n\t\t\t\/\/ services including KMS\n\t\t\tXXService service = daoManager.getXXService().getById(id);\n\t\t\tEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\n\t\t\tif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\n\t\t\t\tList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\n\t\t\t\tif(!CollectionUtils.isEmpty(referringServices)){\n\t\t\t\t\tSet<String> referringServiceNames=new HashSet<String>();\n\t\t\t\t\tfor(XXService xXService:referringServices){\n\t\t\t\t\t\treferringServiceNames.add(xXService.getName());\n\t\t\t\t\t\tif(referringServiceNames.size()>=10){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(referringServices.size()<=10){\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames,MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames+\" and more..\",MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().getById(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\ttagStore.deleteAllTagObjectsForService(service.getName());\n\t\t\tsvcStore.deleteService(id);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"deleteService(\" + id + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t}","code_wo_comment":"@DELETE\n\t@Path(\"\/services\/{id}\")\n\t@Produces({ \"application\/json\", \"application\/xml\" })\n\t@PreAuthorize(\"@rangerPreAuthSecurityHandler.isAPIAccessible(\\\"\" + RangerAPIList.DELETE_SERVICE + \"\\\")\")\n\tpublic void deleteService(@PathParam(\"id\") Long id) {\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"==> ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t\tRangerPerfTracer perf = null;\n\t\ttry {\n\t\t\tif(RangerPerfTracer.isPerfTraceEnabled(PERF_LOG)) {\n\t\t\t\tperf = RangerPerfTracer.getPerfTracer(PERF_LOG, \"ServiceREST.deleteService(serviceId=\" + id + \")\");\n\t\t\t}\n\t\t\tRangerServiceValidator validator = validatorFactory.getServiceValidator(svcStore);\n\t\t\tvalidator.validate(id, Action.DELETE);\n\t\t\tbizUtil.hasAdminPermissions(\"Services\");\n\t\t\n\t\t\n\t\t\tXXService service = daoManager.getXXService().getById(id);\n\t\t\tEmbeddedServiceDefsUtil embeddedServiceDefsUtil = EmbeddedServiceDefsUtil.instance();\n\t\t\tif (service.getType().equals(embeddedServiceDefsUtil.getTagServiceDefId())){\n\t\t\t\tList<XXService> referringServices=daoManager.getXXService().findByTagServiceId(id);\n\t\t\t\tif(!CollectionUtils.isEmpty(referringServices)){\n\t\t\t\t\tSet<String> referringServiceNames=new HashSet<String>();\n\t\t\t\t\tfor(XXService xXService:referringServices){\n\t\t\t\t\t\treferringServiceNames.add(xXService.getName());\n\t\t\t\t\t\tif(referringServiceNames.size()>=10){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(referringServices.size()<=10){\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames,MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthrow restErrorUtil.createRESTException(\"Tag service '\" + service.getName() + \"' is being referenced by \" + referringServices.size() + \" services: \"+referringServiceNames+\" and more..\",MessageEnums.OPER_NOT_ALLOWED_FOR_STATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tXXServiceDef xxServiceDef = daoManager.getXXServiceDef().getById(service.getType());\n\t\t\tbizUtil.hasKMSPermissions(\"Service\", xxServiceDef.getImplclassname());\n\t\t\ttagStore.deleteAllTagObjectsForService(service.getName());\n\t\t\tsvcStore.deleteService(id);\n\t\t} catch(WebApplicationException excp) {\n\t\t\tthrow excp;\n\t\t} catch(Throwable excp) {\n\t\t\tLOG.error(\"deleteService(\" + id + \") failed\", excp);\n\t\t\tthrow restErrorUtil.createRESTException(excp.getMessage());\n\t\t} finally {\n\t\t\tRangerPerfTracer.log(perf);\n\t\t}\n\t\tif(LOG.isDebugEnabled()) {\n\t\t\tLOG.debug(\"<== ServiceREST.deleteService(\" + id + \")\");\n\t\t}\n\t}","cleancode":"@delete @path(\"\/services\/{id}\") @produces({ \"application\/json\", \"application\/xml\" }) @preauthorize(\"@rangerpreauthsecurityhandler.isapiaccessible(\\\"\" + rangerapilist.delete_service + \"\\\")\") public void deleteservice(@pathparam(\"id\") long id) { if(log.isdebugenabled()) { log.debug(\"==> servicerest.deleteservice(\" + id + \")\"); } rangerperftracer perf = null; try { if(rangerperftracer.isperftraceenabled(perf_log)) { perf = rangerperftracer.getperftracer(perf_log, \"servicerest.deleteservice(serviceid=\" + id + \")\"); } rangerservicevalidator validator = validatorfactory.getservicevalidator(svcstore); validator.validate(id, action.delete); bizutil.hasadminpermissions(\"services\"); xxservice service = daomanager.getxxservice().getbyid(id); embeddedservicedefsutil embeddedservicedefsutil = embeddedservicedefsutil.instance(); if (service.gettype().equals(embeddedservicedefsutil.gettagservicedefid())){ list<xxservice> referringservices=daomanager.getxxservice().findbytagserviceid(id); if(!collectionutils.isempty(referringservices)){ set<string> referringservicenames=new hashset<string>(); for(xxservice xxservice:referringservices){ referringservicenames.add(xxservice.getname()); if(referringservicenames.size()>=10){ break; } } if(referringservices.size()<=10){ throw resterrorutil.createrestexception(\"tag service '\" + service.getname() + \"' is being referenced by \" + referringservices.size() + \" services: \"+referringservicenames,messageenums.oper_not_allowed_for_state); }else{ throw resterrorutil.createrestexception(\"tag service '\" + service.getname() + \"' is being referenced by \" + referringservices.size() + \" services: \"+referringservicenames+\" and more..\",messageenums.oper_not_allowed_for_state); } } } xxservicedef xxservicedef = daomanager.getxxservicedef().getbyid(service.gettype()); bizutil.haskmspermissions(\"service\", xxservicedef.getimplclassname()); tagstore.deletealltagobjectsforservice(service.getname()); svcstore.deleteservice(id); } catch(webapplicationexception excp) { throw excp; } catch(throwable excp) { log.error(\"deleteservice(\" + id + \") failed\", excp); throw resterrorutil.createrestexception(excp.getmessage()); } finally { rangerperftracer.log(perf); } if(log.isdebugenabled()) { log.debug(\"<== servicerest.deleteservice(\" + id + \")\"); } }","repo":"lw-lin\/incubator-ranger","label":[1,0,0,0]}
{"id":9239,"original_code":"@Issue(\"JENKINS-20415\")\n    @Test public void nonTopLevelItemGroup() throws Exception {\n        MatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\n        mp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\n        assertEquals(2, mp.getItems().size());\n        ListView v = new ListView(\"v\");\n        j.jenkins.addView(v);\n        v.setIncludeRegex(\".*\");\n        v.setRecurse(true);\n        \/\/ Note: did not manage to reproduce CCE until I changed expand to use \u2018for (TopLevelItem item : items)\u2019 rather than \u2018for (Item item : items)\u2019; perhaps a compiler-specific issue?\n        assertEquals(Collections.singletonList(mp), v.getItems());\n    }","code_wo_comment":"@Issue(\"JENKINS-20415\")\n    @Test public void nonTopLevelItemGroup() throws Exception {\n        MatrixProject mp = j.jenkins.createProject(MatrixProject.class, \"mp\");\n        mp.setAxes(new AxisList(new TextAxis(\"axis\", \"one\", \"two\")));\n        assertEquals(2, mp.getItems().size());\n        ListView v = new ListView(\"v\");\n        j.jenkins.addView(v);\n        v.setIncludeRegex(\".*\");\n        v.setRecurse(true);\n        assertEquals(Collections.singletonList(mp), v.getItems());\n    }","cleancode":"@issue(\"jenkins-20415\") @test public void nontoplevelitemgroup() throws exception { matrixproject mp = j.jenkins.createproject(matrixproject.class, \"mp\"); mp.setaxes(new axislist(new textaxis(\"axis\", \"one\", \"two\"))); assertequals(2, mp.getitems().size()); listview v = new listview(\"v\"); j.jenkins.addview(v); v.setincluderegex(\".*\"); v.setrecurse(true); assertequals(collections.singletonlist(mp), v.getitems()); }","repo":"mahevpm\/Mahendran_Jenkins","label":[0,0,1,0]}
{"id":33880,"original_code":"@Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n        \/\/ TODO empty method, if you want to definition & registry , use it.\n    }","code_wo_comment":"@Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {\n       \n    }","cleancode":"@override public void postprocessbeandefinitionregistry(beandefinitionregistry beandefinitionregistry) throws beansexception { }","repo":"liuziyuan\/retrofit-spring-boot-starter","label":[0,1,0,0]}
{"id":33901,"original_code":"@Ignore \/\/ todo: test case for https:\/\/github.com\/jhy\/jsoup\/issues\/845. Doesn't work yet.\n    @Test public void handlesMisnestedAInDivs() {\n        String h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\n        String w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\n            StringUtil.normaliseWhitespace(w),\n            StringUtil.normaliseWhitespace(doc.body().html()));\n    }","code_wo_comment":"@Ignore     @Test public void handlesMisnestedAInDivs() {\n        String h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\";\n        String w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\n            StringUtil.normaliseWhitespace(w),\n            StringUtil.normaliseWhitespace(doc.body().html()));\n    }","cleancode":"@ignore @test public void handlesmisnestedaindivs() { string h = \"<a href='#1'><div><div><a href='#2'>child<\/a<\/div<\/div><\/a>\"; string w = \"<a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><div><a href=\\\"#1\\\"><\/a><a href=\\\"#2\\\">child<\/a><\/div><\/div>\"; document doc = jsoup.parse(h); assertequals( stringutil.normalisewhitespace(w), stringutil.normalisewhitespace(doc.body().html())); }","repo":"mikiec84\/jsoup","label":[0,0,0,1]}
{"id":1139,"original_code":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n    \/\/ Transform the observed (current) time series\n    if (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\n      anomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n    }\n    List<TransformationFunction> currentTimeSeriesTransformationChain =\n        getCurrentTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : currentTimeSeriesTransformationChain) {\n        anomalyDetectionContext\n            .setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\n                anomalyDetectionContext));\n      }\n    }\n    \/\/ Transform baseline time series\n    if (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\n      anomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n    }\n    List<TransformationFunction> baselineTimeSeriesTransformationChain =\n        getBaselineTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n        && CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\n        List<TimeSeries> transformedBaselines = new ArrayList<>();\n        for (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\n          TimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\n          transformedBaselines.add(transformedTS);\n        }\n        anomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n      }\n    }\n  }","code_wo_comment":"private void transformTimeSeries(String metricName, AnomalyDetectionContext anomalyDetectionContext) {\n   \n    if (anomalyDetectionContext.getTransformedCurrent(metricName) == null) {\n      anomalyDetectionContext.setTransformedCurrent(metricName, anomalyDetectionContext.getCurrent(metricName));\n    }\n    List<TransformationFunction> currentTimeSeriesTransformationChain =\n        getCurrentTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(currentTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : currentTimeSeriesTransformationChain) {\n        anomalyDetectionContext\n            .setTransformedCurrent(metricName, tf.transform(anomalyDetectionContext.getTransformedCurrent(metricName),\n                anomalyDetectionContext));\n      }\n    }\n   \n    if (anomalyDetectionContext.getTransformedBaselines(metricName) == null) {\n      anomalyDetectionContext.setTransformedBaselines(metricName, anomalyDetectionContext.getBaselines(metricName));\n    }\n    List<TransformationFunction> baselineTimeSeriesTransformationChain =\n        getBaselineTimeSeriesTransformationChain();\n    if (CollectionUtils.isNotEmpty(anomalyDetectionContext.getTransformedBaselines(metricName))\n        && CollectionUtils.isNotEmpty(baselineTimeSeriesTransformationChain)) {\n      for (TransformationFunction tf : baselineTimeSeriesTransformationChain) {\n        List<TimeSeries> transformedBaselines = new ArrayList<>();\n        for (TimeSeries ts : anomalyDetectionContext.getTransformedBaselines(metricName)) {\n          TimeSeries transformedTS = tf.transform(ts, anomalyDetectionContext);\n          transformedBaselines.add(transformedTS);\n        }\n        anomalyDetectionContext.setTransformedBaselines(metricName, transformedBaselines);\n      }\n    }\n  }","cleancode":"private void transformtimeseries(string metricname, anomalydetectioncontext anomalydetectioncontext) { if (anomalydetectioncontext.gettransformedcurrent(metricname) == null) { anomalydetectioncontext.settransformedcurrent(metricname, anomalydetectioncontext.getcurrent(metricname)); } list<transformationfunction> currenttimeseriestransformationchain = getcurrenttimeseriestransformationchain(); if (collectionutils.isnotempty(currenttimeseriestransformationchain)) { for (transformationfunction tf : currenttimeseriestransformationchain) { anomalydetectioncontext .settransformedcurrent(metricname, tf.transform(anomalydetectioncontext.gettransformedcurrent(metricname), anomalydetectioncontext)); } } if (anomalydetectioncontext.gettransformedbaselines(metricname) == null) { anomalydetectioncontext.settransformedbaselines(metricname, anomalydetectioncontext.getbaselines(metricname)); } list<transformationfunction> baselinetimeseriestransformationchain = getbaselinetimeseriestransformationchain(); if (collectionutils.isnotempty(anomalydetectioncontext.gettransformedbaselines(metricname)) && collectionutils.isnotempty(baselinetimeseriestransformationchain)) { for (transformationfunction tf : baselinetimeseriestransformationchain) { list<timeseries> transformedbaselines = new arraylist<>(); for (timeseries ts : anomalydetectioncontext.gettransformedbaselines(metricname)) { timeseries transformedts = tf.transform(ts, anomalydetectioncontext); transformedbaselines.add(transformedts); } anomalydetectioncontext.settransformedbaselines(metricname, transformedbaselines); } } }","repo":"kupl\/starlab-benchmarks","label":[0,1,0,0]}
{"id":17582,"original_code":"@Override\n  public void onManifest(String contentId, MediaPresentationDescription manifest) {\n    Handler mainHandler = player.getMainHandler();\n    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\n    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n    \/\/ Obtain Representations for playback.\n    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\n    ArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\n    ArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\n    Period period = manifest.periods.get(0);\n    boolean hasContentProtection = false;\n    for (int i = 0; i < period.adaptationSets.size(); i++) {\n      AdaptationSet adaptationSet = period.adaptationSets.get(i);\n      hasContentProtection |= adaptationSet.hasContentProtection();\n      int adaptationSetType = adaptationSet.type;\n      for (int j = 0; j < adaptationSet.representations.size(); j++) {\n        Representation representation = adaptationSet.representations.get(j);\n        if (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\n          audioRepresentationsList.add(representation);\n        } else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\n          Format format = representation.format;\n          if (format.width * format.height <= maxDecodableFrameSize) {\n            videoRepresentationsList.add(representation);\n          } else {\n            \/\/ The device isn't capable of playing this stream.\n          }\n        }\n      }\n    }\n    Representation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\n    videoRepresentationsList.toArray(videoRepresentations);\n    \/\/ Check drm support if necessary.\n    DrmSessionManager drmSessionManager = null;\n    if (hasContentProtection) {\n      if (Util.SDK_INT < 18) {\n        callback.onRenderersError(new UnsupportedOperationException(\n            \"Protected content not supported on API level \" + Util.SDK_INT));\n        return;\n      }\n      try {\n        Pair<DrmSessionManager, Boolean> drmSessionManagerData =\n            V18Compat.getDrmSessionManagerData(player, drmCallback);\n        drmSessionManager = drmSessionManagerData.first;\n        if (!drmSessionManagerData.second) {\n          \/\/ HD streams require L1 security.\n          videoRepresentations = getSdRepresentations(videoRepresentations);\n        }\n      } catch (Exception e) {\n        callback.onRenderersError(e);\n        return;\n      }\n    }\n    \/\/ Build the video renderer.\n    DataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n    ChunkSource videoChunkSource;\n    String mimeType = videoRepresentations[0].format.mimeType;\n    if (mimeType.equals(MimeTypes.VIDEO_MP4)) {\n      videoChunkSource = new DashMp4ChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n      \/\/ TODO: Figure out how to query supported vpX resolutions. For now, restrict to standard\n      \/\/ definition streams.\n      videoRepresentations = getSdRepresentations(videoRepresentations);\n      videoChunkSource = new DashWebmChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else {\n      throw new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n    }\n    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\n        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n        DemoPlayer.TYPE_VIDEO);\n    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\n        drmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\n        mainHandler, player, 50);\n    \/\/ Build the audio renderer.\n    final String[] audioTrackNames;\n    final MultiTrackChunkSource audioChunkSource;\n    final MediaCodecAudioTrackRenderer audioRenderer;\n    if (audioRepresentationsList.isEmpty()) {\n      audioTrackNames = null;\n      audioChunkSource = null;\n      audioRenderer = null;\n    } else {\n      DataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n      audioTrackNames = new String[audioRepresentationsList.size()];\n      ChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\n      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\n      for (int i = 0; i < audioRepresentationsList.size(); i++) {\n        Representation representation = audioRepresentationsList.get(i);\n        Format format = representation.format;\n        audioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\n            format.audioSamplingRate + \"Hz)\";\n        audioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\n            audioEvaluator, representation);\n      }\n      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);\n      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\n          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n          DemoPlayer.TYPE_AUDIO);\n      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\n          mainHandler, player);\n    }\n    \/\/ Build the debug renderer.\n    TrackRenderer debugRenderer = debugTextView != null\n        ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n    \/\/ Invoke the callback.\n    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\n    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\n    MultiTrackChunkSource[] multiTrackChunkSources =\n        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\n    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\n    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\n    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\n    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\n    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\n    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n  }","code_wo_comment":"@Override\n  public void onManifest(String contentId, MediaPresentationDescription manifest) {\n    Handler mainHandler = player.getMainHandler();\n    LoadControl loadControl = new DefaultLoadControl(new BufferPool(BUFFER_SEGMENT_SIZE));\n    DefaultBandwidthMeter bandwidthMeter = new DefaultBandwidthMeter(mainHandler, player);\n   \n    int maxDecodableFrameSize = MediaCodecUtil.maxH264DecodableFrameSize();\n    ArrayList<Representation> audioRepresentationsList = new ArrayList<Representation>();\n    ArrayList<Representation> videoRepresentationsList = new ArrayList<Representation>();\n    Period period = manifest.periods.get(0);\n    boolean hasContentProtection = false;\n    for (int i = 0; i < period.adaptationSets.size(); i++) {\n      AdaptationSet adaptationSet = period.adaptationSets.get(i);\n      hasContentProtection |= adaptationSet.hasContentProtection();\n      int adaptationSetType = adaptationSet.type;\n      for (int j = 0; j < adaptationSet.representations.size(); j++) {\n        Representation representation = adaptationSet.representations.get(j);\n        if (adaptationSetType == AdaptationSet.TYPE_AUDIO) {\n          audioRepresentationsList.add(representation);\n        } else if (adaptationSetType == AdaptationSet.TYPE_VIDEO) {\n          Format format = representation.format;\n          if (format.width * format.height <= maxDecodableFrameSize) {\n            videoRepresentationsList.add(representation);\n          } else {\n           \n          }\n        }\n      }\n    }\n    Representation[] videoRepresentations = new Representation[videoRepresentationsList.size()];\n    videoRepresentationsList.toArray(videoRepresentations);\n   \n    DrmSessionManager drmSessionManager = null;\n    if (hasContentProtection) {\n      if (Util.SDK_INT < 18) {\n        callback.onRenderersError(new UnsupportedOperationException(\n            \"Protected content not supported on API level \" + Util.SDK_INT));\n        return;\n      }\n      try {\n        Pair<DrmSessionManager, Boolean> drmSessionManagerData =\n            V18Compat.getDrmSessionManagerData(player, drmCallback);\n        drmSessionManager = drmSessionManagerData.first;\n        if (!drmSessionManagerData.second) {\n         \n          videoRepresentations = getSdRepresentations(videoRepresentations);\n        }\n      } catch (Exception e) {\n        callback.onRenderersError(e);\n        return;\n      }\n    }\n   \n    DataSource videoDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n    ChunkSource videoChunkSource;\n    String mimeType = videoRepresentations[0].format.mimeType;\n    if (mimeType.equals(MimeTypes.VIDEO_MP4)) {\n      videoChunkSource = new DashMp4ChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else if (mimeType.equals(MimeTypes.VIDEO_WEBM)) {\n     \n     \n      videoRepresentations = getSdRepresentations(videoRepresentations);\n      videoChunkSource = new DashWebmChunkSource(videoDataSource,\n          new AdaptiveEvaluator(bandwidthMeter), videoRepresentations);\n    } else {\n      throw new IllegalStateException(\"Unexpected mime type: \" + mimeType);\n    }\n    ChunkSampleSource videoSampleSource = new ChunkSampleSource(videoChunkSource, loadControl,\n        VIDEO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n        DemoPlayer.TYPE_VIDEO);\n    MediaCodecVideoTrackRenderer videoRenderer = new MediaCodecVideoTrackRenderer(videoSampleSource,\n        drmSessionManager, true, MediaCodec.VIDEO_SCALING_MODE_SCALE_TO_FIT, 5000,\n        mainHandler, player, 50);\n   \n    final String[] audioTrackNames;\n    final MultiTrackChunkSource audioChunkSource;\n    final MediaCodecAudioTrackRenderer audioRenderer;\n    if (audioRepresentationsList.isEmpty()) {\n      audioTrackNames = null;\n      audioChunkSource = null;\n      audioRenderer = null;\n    } else {\n      DataSource audioDataSource = new HttpDataSource(userAgent, null, bandwidthMeter);\n      audioTrackNames = new String[audioRepresentationsList.size()];\n      ChunkSource[] audioChunkSources = new ChunkSource[audioRepresentationsList.size()];\n      FormatEvaluator audioEvaluator = new FormatEvaluator.FixedEvaluator();\n      for (int i = 0; i < audioRepresentationsList.size(); i++) {\n        Representation representation = audioRepresentationsList.get(i);\n        Format format = representation.format;\n        audioTrackNames[i] = format.id + \" (\" + format.numChannels + \"ch, \" +\n            format.audioSamplingRate + \"Hz)\";\n        audioChunkSources[i] = new DashMp4ChunkSource(audioDataSource,\n            audioEvaluator, representation);\n      }\n      audioChunkSource = new MultiTrackChunkSource(audioChunkSources);\n      SampleSource audioSampleSource = new ChunkSampleSource(audioChunkSource, loadControl,\n          AUDIO_BUFFER_SEGMENTS * BUFFER_SEGMENT_SIZE, true, mainHandler, player,\n          DemoPlayer.TYPE_AUDIO);\n      audioRenderer = new MediaCodecAudioTrackRenderer(audioSampleSource, drmSessionManager, true,\n          mainHandler, player);\n    }\n   \n    TrackRenderer debugRenderer = debugTextView != null\n        ? new DebugTrackRenderer(debugTextView, videoRenderer, videoSampleSource) : null;\n   \n    String[][] trackNames = new String[DemoPlayer.RENDERER_COUNT][];\n    trackNames[DemoPlayer.TYPE_AUDIO] = audioTrackNames;\n    MultiTrackChunkSource[] multiTrackChunkSources =\n        new MultiTrackChunkSource[DemoPlayer.RENDERER_COUNT];\n    multiTrackChunkSources[DemoPlayer.TYPE_AUDIO] = audioChunkSource;\n    TrackRenderer[] renderers = new TrackRenderer[DemoPlayer.RENDERER_COUNT];\n    renderers[DemoPlayer.TYPE_VIDEO] = videoRenderer;\n    renderers[DemoPlayer.TYPE_AUDIO] = audioRenderer;\n    renderers[DemoPlayer.TYPE_DEBUG] = debugRenderer;\n    callback.onRenderers(trackNames, multiTrackChunkSources, renderers);\n  }","cleancode":"@override public void onmanifest(string contentid, mediapresentationdescription manifest) { handler mainhandler = player.getmainhandler(); loadcontrol loadcontrol = new defaultloadcontrol(new bufferpool(buffer_segment_size)); defaultbandwidthmeter bandwidthmeter = new defaultbandwidthmeter(mainhandler, player); int maxdecodableframesize = mediacodecutil.maxh264decodableframesize(); arraylist<representation> audiorepresentationslist = new arraylist<representation>(); arraylist<representation> videorepresentationslist = new arraylist<representation>(); period period = manifest.periods.get(0); boolean hascontentprotection = false; for (int i = 0; i < period.adaptationsets.size(); i++) { adaptationset adaptationset = period.adaptationsets.get(i); hascontentprotection |= adaptationset.hascontentprotection(); int adaptationsettype = adaptationset.type; for (int j = 0; j < adaptationset.representations.size(); j++) { representation representation = adaptationset.representations.get(j); if (adaptationsettype == adaptationset.type_audio) { audiorepresentationslist.add(representation); } else if (adaptationsettype == adaptationset.type_video) { format format = representation.format; if (format.width * format.height <= maxdecodableframesize) { videorepresentationslist.add(representation); } else { } } } } representation[] videorepresentations = new representation[videorepresentationslist.size()]; videorepresentationslist.toarray(videorepresentations); drmsessionmanager drmsessionmanager = null; if (hascontentprotection) { if (util.sdk_int < 18) { callback.onrendererserror(new unsupportedoperationexception( \"protected content not supported on api level \" + util.sdk_int)); return; } try { pair<drmsessionmanager, boolean> drmsessionmanagerdata = v18compat.getdrmsessionmanagerdata(player, drmcallback); drmsessionmanager = drmsessionmanagerdata.first; if (!drmsessionmanagerdata.second) { videorepresentations = getsdrepresentations(videorepresentations); } } catch (exception e) { callback.onrendererserror(e); return; } } datasource videodatasource = new httpdatasource(useragent, null, bandwidthmeter); chunksource videochunksource; string mimetype = videorepresentations[0].format.mimetype; if (mimetype.equals(mimetypes.video_mp4)) { videochunksource = new dashmp4chunksource(videodatasource, new adaptiveevaluator(bandwidthmeter), videorepresentations); } else if (mimetype.equals(mimetypes.video_webm)) { videorepresentations = getsdrepresentations(videorepresentations); videochunksource = new dashwebmchunksource(videodatasource, new adaptiveevaluator(bandwidthmeter), videorepresentations); } else { throw new illegalstateexception(\"unexpected mime type: \" + mimetype); } chunksamplesource videosamplesource = new chunksamplesource(videochunksource, loadcontrol, video_buffer_segments * buffer_segment_size, true, mainhandler, player, demoplayer.type_video); mediacodecvideotrackrenderer videorenderer = new mediacodecvideotrackrenderer(videosamplesource, drmsessionmanager, true, mediacodec.video_scaling_mode_scale_to_fit, 5000, mainhandler, player, 50); final string[] audiotracknames; final multitrackchunksource audiochunksource; final mediacodecaudiotrackrenderer audiorenderer; if (audiorepresentationslist.isempty()) { audiotracknames = null; audiochunksource = null; audiorenderer = null; } else { datasource audiodatasource = new httpdatasource(useragent, null, bandwidthmeter); audiotracknames = new string[audiorepresentationslist.size()]; chunksource[] audiochunksources = new chunksource[audiorepresentationslist.size()]; formatevaluator audioevaluator = new formatevaluator.fixedevaluator(); for (int i = 0; i < audiorepresentationslist.size(); i++) { representation representation = audiorepresentationslist.get(i); format format = representation.format; audiotracknames[i] = format.id + \" (\" + format.numchannels + \"ch, \" + format.audiosamplingrate + \"hz)\"; audiochunksources[i] = new dashmp4chunksource(audiodatasource, audioevaluator, representation); } audiochunksource = new multitrackchunksource(audiochunksources); samplesource audiosamplesource = new chunksamplesource(audiochunksource, loadcontrol, audio_buffer_segments * buffer_segment_size, true, mainhandler, player, demoplayer.type_audio); audiorenderer = new mediacodecaudiotrackrenderer(audiosamplesource, drmsessionmanager, true, mainhandler, player); } trackrenderer debugrenderer = debugtextview != null ? new debugtrackrenderer(debugtextview, videorenderer, videosamplesource) : null; string[][] tracknames = new string[demoplayer.renderer_count][]; tracknames[demoplayer.type_audio] = audiotracknames; multitrackchunksource[] multitrackchunksources = new multitrackchunksource[demoplayer.renderer_count]; multitrackchunksources[demoplayer.type_audio] = audiochunksource; trackrenderer[] renderers = new trackrenderer[demoplayer.renderer_count]; renderers[demoplayer.type_video] = videorenderer; renderers[demoplayer.type_audio] = audiorenderer; renderers[demoplayer.type_debug] = debugrenderer; callback.onrenderers(tracknames, multitrackchunksources, renderers); }","repo":"malmstein\/ExoPlayer","label":[1,0,0,0]}
{"id":17679,"original_code":"public void onFinished(JavaScriptObject jso) {\n\t\tapplFormItems.clear();\n\t\tapplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\n\t\tapplFormGenerators.clear();\n\t\tif (applFormItems == null || applFormItems.isEmpty()) {\n\t\t\t\/\/ when there are no application form items\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\/\/ FIXME - this is probably not good, since it prevents vo extension when targetexisting is specified.\n\t\t\tif (Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\tLocation.replace(Location.getParameter(\"targetexisting\"));\n\t\t\t}\n\t\t\t\/\/ when there are no application form items\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else {\n\t\t\t\/\/ create application form\n\t\t\tprepareApplicationForm();\n\t\t}\n\t\tsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\n\t\tevents.onFinished(jso);\n\t\tloaderImage.loadingFinished();\n\t}","code_wo_comment":"public void onFinished(JavaScriptObject jso) {\n\t\tapplFormItems.clear();\n\t\tapplFormItems.addAll(JsonUtils.<ApplicationFormItemWithPrefilledValue>jsoAsList(jso));\n\t\tapplFormGenerators.clear();\n\t\tif (applFormItems == null || applFormItems.isEmpty()) {\n\t\t\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.noFormDefined());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else if (PerunEntity.VIRTUAL_ORGANIZATION.equals(entity) && \"EXTENSION\".equalsIgnoreCase(type) && Location.getParameter(\"targetexisting\") != null) {\n\t\t\n\t\t\tif (Location.getParameter(\"targetexisting\") != null) {\n\t\t\t\tLocation.replace(Location.getParameter(\"targetexisting\"));\n\t\t\t}\n\t\t\n\t\t\tFlexTable ft = new FlexTable();\n\t\t\tft.setSize(\"100%\", \"300px\");\n\t\t\tft.setHTML(0, 0, new Image(LargeIcons.INSTANCE.errorIcon()) + ApplicationMessages.INSTANCE.alreadyVoMember());\n\t\t\tft.getFlexCellFormatter().setHorizontalAlignment(0, 0, HasHorizontalAlignment.ALIGN_CENTER);\n\t\t\tft.getFlexCellFormatter().setVerticalAlignment(0, 0, HasVerticalAlignment.ALIGN_MIDDLE);\n\t\t\tcontents.setWidget(ft);\n\t\t} else {\n\t\t\n\t\t\tprepareApplicationForm();\n\t\t}\n\t\tsession.getUiElements().setLogText(\"Loading \" + type + \" application form items in selected VO finished:\" + applFormItems.size());\n\t\tevents.onFinished(jso);\n\t\tloaderImage.loadingFinished();\n\t}","cleancode":"public void onfinished(javascriptobject jso) { applformitems.clear(); applformitems.addall(jsonutils.<applicationformitemwithprefilledvalue>jsoaslist(jso)); applformgenerators.clear(); if (applformitems == null || applformitems.isempty()) { flextable ft = new flextable(); ft.setsize(\"100%\", \"300px\"); ft.sethtml(0, 0, new image(largeicons.instance.erroricon()) + applicationmessages.instance.noformdefined()); ft.getflexcellformatter().sethorizontalalignment(0, 0, hashorizontalalignment.align_center); ft.getflexcellformatter().setverticalalignment(0, 0, hasverticalalignment.align_middle); contents.setwidget(ft); } else if (perunentity.virtual_organization.equals(entity) && \"extension\".equalsignorecase(type) && location.getparameter(\"targetexisting\") != null) { if (location.getparameter(\"targetexisting\") != null) { location.replace(location.getparameter(\"targetexisting\")); } flextable ft = new flextable(); ft.setsize(\"100%\", \"300px\"); ft.sethtml(0, 0, new image(largeicons.instance.erroricon()) + applicationmessages.instance.alreadyvomember()); ft.getflexcellformatter().sethorizontalalignment(0, 0, hashorizontalalignment.align_center); ft.getflexcellformatter().setverticalalignment(0, 0, hasverticalalignment.align_middle); contents.setwidget(ft); } else { prepareapplicationform(); } session.getuielements().setlogtext(\"loading \" + type + \" application form items in selected vo finished:\" + applformitems.size()); events.onfinished(jso); loaderimage.loadingfinished(); }","repo":"licehammer\/perun","label":[0,0,1,0]}
{"id":9531,"original_code":"private PathFormula withCorrectionTermsAndPC(\n      Block pBlock,\n      FormulaManagerView pFmgr,\n      BooleanFormulaManagerView pBfmgr,\n      BitvectorFormulaManagerView pBvfmgr,\n      PathFormulaManager pPfmgr,\n      CFA pCFA) {\n    BooleanFormula extendedBlockFormula = pBlock.getFormula();\n    PathFormula unprimedBlockContext = pBlock.getUnprimedContext();\n    PathFormula primedBlockContext = pBlock.getPrimedContext();\n    SSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\n    SSAMap primedSSAMap = primedBlockContext.getSsa();\n    for (String varName : programVariableNames) {\n      \/\/ Add general correction v_1 = v_max if v is not in block formula (= not in primed context),\n      if (!primedSSAMap.containsVariable(varName)) {\n        BooleanFormula correctionterm =\n            pBvfmgr.equal(\n                makeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\n                makeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\n        extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n      } else {\n        \/\/ Add low correction v_1 = v_? if unprimed context for v has higher index (? > 1).\n        if (unprimedSSAMap.containsVariable(varName)\n            && unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\n                  makeVar(\n                      pPfmgr,\n                      pFmgr,\n                      unprimedBlockContext,\n                      varName,\n                      unprimedSSAMap.getIndex(varName)));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n        \/\/ Add high correction v_? = v_max if primed context for v has lower index (? < max)\n        if (primedSSAMap.getIndex(varName) < highestSSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(\n                      pPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\n                  makeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n      }\n    }\n    \/\/ Add program counter\n    int predID = getID(pBlock.getPredecessorLocation());\n    int succID = getID(pBlock.getSuccessorLocation());\n    BooleanFormula pcBefore =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(predID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\n    BooleanFormula pcAfter =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(succID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\n    extendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n    @SuppressWarnings(\"deprecation\")\n    \/\/ TODO: seems buggy because it implicitly combines extendedBlockFormula and\n    \/\/ primedContext.getSsa() with PointerTargetSet of primedBlockContext, is this correct?\n    PathFormula pathFormula =\n        pPfmgr.makeNewPathFormula(\n            primedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\n    return pathFormula;\n  }","code_wo_comment":"private PathFormula withCorrectionTermsAndPC(\n      Block pBlock,\n      FormulaManagerView pFmgr,\n      BooleanFormulaManagerView pBfmgr,\n      BitvectorFormulaManagerView pBvfmgr,\n      PathFormulaManager pPfmgr,\n      CFA pCFA) {\n    BooleanFormula extendedBlockFormula = pBlock.getFormula();\n    PathFormula unprimedBlockContext = pBlock.getUnprimedContext();\n    PathFormula primedBlockContext = pBlock.getPrimedContext();\n    SSAMap unprimedSSAMap = unprimedBlockContext.getSsa();\n    SSAMap primedSSAMap = primedBlockContext.getSsa();\n    for (String varName : programVariableNames) {\n     \n      if (!primedSSAMap.containsVariable(varName)) {\n        BooleanFormula correctionterm =\n            pBvfmgr.equal(\n                makeVar(pPfmgr, pFmgr, this.unprimedContext, varName, STANDARD_UNPRIMED_SSA),\n                makeVar(pPfmgr, pFmgr, this.primedContext, varName, highestSSA));\n        extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n      } else {\n       \n        if (unprimedSSAMap.containsVariable(varName)\n            && unprimedSSAMap.getIndex(varName) > STANDARD_UNPRIMED_SSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(pPfmgr, pFmgr, unprimedBlockContext, varName, STANDARD_UNPRIMED_SSA),\n                  makeVar(\n                      pPfmgr,\n                      pFmgr,\n                      unprimedBlockContext,\n                      varName,\n                      unprimedSSAMap.getIndex(varName)));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n       \n        if (primedSSAMap.getIndex(varName) < highestSSA) {\n          BooleanFormula correctionterm =\n              pBvfmgr.equal(\n                  makeVar(\n                      pPfmgr, pFmgr, primedBlockContext, varName, primedSSAMap.getIndex(varName)),\n                  makeVar(pPfmgr, pFmgr, primedBlockContext, varName, highestSSA));\n          extendedBlockFormula = pBfmgr.and(extendedBlockFormula, correctionterm);\n        }\n      }\n    }\n   \n    int predID = getID(pBlock.getPredecessorLocation());\n    int succID = getID(pBlock.getSuccessorLocation());\n    BooleanFormula pcBefore =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(predID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(STANDARD_UNPRIMED_SSA));\n    BooleanFormula pcAfter =\n        pFmgr.instantiate(\n            makeProgramcounterFormula(succID, pBvfmgr, pCFA),\n            SSAMap.emptySSAMap().withDefault(PC_PRIMED_SSA));\n    extendedBlockFormula = pBfmgr.and(pcBefore, extendedBlockFormula, pcAfter);\n    @SuppressWarnings(\"deprecation\")\n   \n   \n    PathFormula pathFormula =\n        pPfmgr.makeNewPathFormula(\n            primedBlockContext.updateFormula(extendedBlockFormula), this.primedContext.getSsa());\n    return pathFormula;\n  }","cleancode":"private pathformula withcorrectiontermsandpc( block pblock, formulamanagerview pfmgr, booleanformulamanagerview pbfmgr, bitvectorformulamanagerview pbvfmgr, pathformulamanager ppfmgr, cfa pcfa) { booleanformula extendedblockformula = pblock.getformula(); pathformula unprimedblockcontext = pblock.getunprimedcontext(); pathformula primedblockcontext = pblock.getprimedcontext(); ssamap unprimedssamap = unprimedblockcontext.getssa(); ssamap primedssamap = primedblockcontext.getssa(); for (string varname : programvariablenames) { if (!primedssamap.containsvariable(varname)) { booleanformula correctionterm = pbvfmgr.equal( makevar(ppfmgr, pfmgr, this.unprimedcontext, varname, standard_unprimed_ssa), makevar(ppfmgr, pfmgr, this.primedcontext, varname, highestssa)); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } else { if (unprimedssamap.containsvariable(varname) && unprimedssamap.getindex(varname) > standard_unprimed_ssa) { booleanformula correctionterm = pbvfmgr.equal( makevar(ppfmgr, pfmgr, unprimedblockcontext, varname, standard_unprimed_ssa), makevar( ppfmgr, pfmgr, unprimedblockcontext, varname, unprimedssamap.getindex(varname))); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } if (primedssamap.getindex(varname) < highestssa) { booleanformula correctionterm = pbvfmgr.equal( makevar( ppfmgr, pfmgr, primedblockcontext, varname, primedssamap.getindex(varname)), makevar(ppfmgr, pfmgr, primedblockcontext, varname, highestssa)); extendedblockformula = pbfmgr.and(extendedblockformula, correctionterm); } } } int predid = getid(pblock.getpredecessorlocation()); int succid = getid(pblock.getsuccessorlocation()); booleanformula pcbefore = pfmgr.instantiate( makeprogramcounterformula(predid, pbvfmgr, pcfa), ssamap.emptyssamap().withdefault(standard_unprimed_ssa)); booleanformula pcafter = pfmgr.instantiate( makeprogramcounterformula(succid, pbvfmgr, pcfa), ssamap.emptyssamap().withdefault(pc_primed_ssa)); extendedblockformula = pbfmgr.and(pcbefore, extendedblockformula, pcafter); @suppresswarnings(\"deprecation\") pathformula pathformula = ppfmgr.makenewpathformula( primedblockcontext.updateformula(extendedblockformula), this.primedcontext.getssa()); return pathformula; }","repo":"lembergerth\/cpachecker","label":[0,0,1,0]}
{"id":1459,"original_code":"@Test\n    public void testPredicateTypeMismatch()\n    {\n        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n                getMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\n                Optional.of(this::mockApplyProjection),\n                Optional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n            \/\/ After 'source_col_c = 1' is pushed into source table scan, it's possible for 'source_col_c' table scan assignment to be pruned\n            \/\/ Redirection results in Project('dest_col_b') -> Filter('dest_col_c = 1') -> TableScan for such case\n            \/\/ but dest_col_a has mismatched type compared to source domain\n            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n                    .execute(MOCK_SESSION, session -> {\n                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n                                .isInstanceOf(TrinoException.class)\n                                \/\/ TODO report source column name instead of ColumnHandle toString\n                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n                                        \"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n                    });\n        }\n    }","code_wo_comment":"@Test\n    public void testPredicateTypeMismatch()\n    {\n        try (LocalQueryRunner queryRunner = createLocalQueryRunner(\n                getMockApplyRedirectAfterPredicatePushdown(TYPE_MISMATCHED_REDIRECTION_MAPPING_BC, Optional.of(ImmutableSet.of(SOURCE_COLUMN_HANDLE_B))),\n                Optional.of(this::mockApplyProjection),\n                Optional.of(getMockApplyFilter(ImmutableSet.of(SOURCE_COLUMN_HANDLE_C))))) {\n           \n           \n           \n            transaction(queryRunner.getTransactionManager(), queryRunner.getAccessControl())\n                    .execute(MOCK_SESSION, session -> {\n                        assertThatThrownBy(() -> queryRunner.createPlan(session, \"SELECT source_col_b FROM test_table WHERE source_col_c = 'foo'\", WarningCollector.NOOP))\n                                .isInstanceOf(TrinoException.class)\n                               \n                                .hasMessageMatching(\"Redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" +\n                                        \"different from source column mock_catalog.test_schema.test_table.MockConnectorColumnHandle.*source_col_c.* type: varchar\");\n                    });\n        }\n    }","cleancode":"@test public void testpredicatetypemismatch() { try (localqueryrunner queryrunner = createlocalqueryrunner( getmockapplyredirectafterpredicatepushdown(type_mismatched_redirection_mapping_bc, optional.of(immutableset.of(source_column_handle_b))), optional.of(this::mockapplyprojection), optional.of(getmockapplyfilter(immutableset.of(source_column_handle_c))))) { transaction(queryrunner.gettransactionmanager(), queryrunner.getaccesscontrol()) .execute(mock_session, session -> { assertthatthrownby(() -> queryrunner.createplan(session, \"select source_col_b from test_table where source_col_c = 'foo'\", warningcollector.noop)) .isinstanceof(trinoexception.class) .hasmessagematching(\"redirected column mock_catalog.target_schema.target_table.destination_col_a has type integer, \" + \"different from source column mock_catalog.test_schema.test_table.mockconnectorcolumnhandle.*source_col_c.* type: varchar\"); }); } }","repo":"liujiansxcd\/trino","label":[1,0,0,0]}
{"id":34339,"original_code":"private void createRowFactory(){\n        \/\/Play selected song from playlist, to skip forward or back\n        tableView.setRowFactory( tv -> {\n            TableRow<PlaylistSongDisplay> row = new TableRow<>();\n            row.setOnMouseClicked(event -> {\n                \/\/On double click of song, play it\n                if (event.getClickCount() == 2 && (! row.isEmpty()) ) {\n                    playlist.playPlaylistSelection(songHashMap.get(row.getItem()));\n                }\n                \/\/On right click open context menu\n                if (event.getButton() == MouseButton.SECONDARY) {\n                    ObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n                    ArrayList<Song> selectedIDs = new ArrayList<>();\n                    for (PlaylistSongDisplay rowSelected : selectedItems) {\n                        selectedIDs.add(songHashMap.get(rowSelected));\n                    }\n                    \/\/Allow for removal of selected songs from playlist\n                    removeSelected.setOnAction((actionEvent -> {\n                        playlist.removePlaylistSelection(selectedIDs);\n                        for (Song s: selectedIDs){\n                            playlistList.remove(songHashMapRev.get(s));\n                        }\n                    }));\n                    \/\/Allow for clearing entire playlist\n                    clearPlaylist.setOnAction(actionEvent -> {\n                        playlist.clearPlaylist();\n                        emptyTable();\n                    });\n                    \/\/Show context menu at location of click\n                    playlistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n                }\n                \/\/Undo selection if user clicks away from focused row\n                if (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\n                    tableView.getSelectionModel().clearSelection();\n                }\n            });\n            return row;\n        });\n        \/\/TODO: Add drag listener to move songs around as desired\n    }","code_wo_comment":"private void createRowFactory(){\n       \n        tableView.setRowFactory( tv -> {\n            TableRow<PlaylistSongDisplay> row = new TableRow<>();\n            row.setOnMouseClicked(event -> {\n               \n                if (event.getClickCount() == 2 && (! row.isEmpty()) ) {\n                    playlist.playPlaylistSelection(songHashMap.get(row.getItem()));\n                }\n               \n                if (event.getButton() == MouseButton.SECONDARY) {\n                    ObservableList<PlaylistSongDisplay> selectedItems = tableView.getSelectionModel().getSelectedItems();\n                    ArrayList<Song> selectedIDs = new ArrayList<>();\n                    for (PlaylistSongDisplay rowSelected : selectedItems) {\n                        selectedIDs.add(songHashMap.get(rowSelected));\n                    }\n                   \n                    removeSelected.setOnAction((actionEvent -> {\n                        playlist.removePlaylistSelection(selectedIDs);\n                        for (Song s: selectedIDs){\n                            playlistList.remove(songHashMapRev.get(s));\n                        }\n                    }));\n                   \n                    clearPlaylist.setOnAction(actionEvent -> {\n                        playlist.clearPlaylist();\n                        emptyTable();\n                    });\n                   \n                    playlistContextMenu.show(row, event.getScreenX(), event.getScreenY());\n                }\n               \n                if (event.getButton() == MouseButton.PRIMARY && (row.isEmpty())){\n                    tableView.getSelectionModel().clearSelection();\n                }\n            });\n            return row;\n        });\n       \n    }","cleancode":"private void createrowfactory(){ tableview.setrowfactory( tv -> { tablerow<playlistsongdisplay> row = new tablerow<>(); row.setonmouseclicked(event -> { if (event.getclickcount() == 2 && (! row.isempty()) ) { playlist.playplaylistselection(songhashmap.get(row.getitem())); } if (event.getbutton() == mousebutton.secondary) { observablelist<playlistsongdisplay> selecteditems = tableview.getselectionmodel().getselecteditems(); arraylist<song> selectedids = new arraylist<>(); for (playlistsongdisplay rowselected : selecteditems) { selectedids.add(songhashmap.get(rowselected)); } removeselected.setonaction((actionevent -> { playlist.removeplaylistselection(selectedids); for (song s: selectedids){ playlistlist.remove(songhashmaprev.get(s)); } })); clearplaylist.setonaction(actionevent -> { playlist.clearplaylist(); emptytable(); }); playlistcontextmenu.show(row, event.getscreenx(), event.getscreeny()); } if (event.getbutton() == mousebutton.primary && (row.isempty())){ tableview.getselectionmodel().clearselection(); } }); return row; }); }","repo":"justinlautner\/Cassette","label":[0,1,0,0]}
{"id":34410,"original_code":"@Override\n    public void suspend() {\n        \/\/ TODO unsubscribe from everything? And resubscribe on resume?\n        super.suspend();\n        if (executor != null) executor.shutdownNow();\n        executorQueued.set(false);\n    }","code_wo_comment":"@Override\n    public void suspend() {\n       \n        super.suspend();\n        if (executor != null) executor.shutdownNow();\n        executorQueued.set(false);\n    }","cleancode":"@override public void suspend() { super.suspend(); if (executor != null) executor.shutdownnow(); executorqueued.set(false); }","repo":"kiuby88\/incubator-brooklyn","label":[1,0,0,0]}
{"id":1656,"original_code":"private void onSessionError(final int sessionId) {\n        \/\/ TODO(qinmin): pass the error code to native.\n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                nativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n            }\n        });\n    }","code_wo_comment":"private void onSessionError(final int sessionId) {\n       \n        mHandler.post(new Runnable() {\n            @Override\n            public void run() {\n                nativeOnSessionError(mNativeMediaDrmBridge, sessionId);\n            }\n        });\n    }","cleancode":"private void onsessionerror(final int sessionid) { mhandler.post(new runnable() { @override public void run() { nativeonsessionerror(mnativemediadrmbridge, sessionid); } }); }","repo":"kjthegod\/chromium","label":[0,1,0,0]}
{"id":18096,"original_code":"@SuppressWarnings(\"unchecked\")\n\tpublic static void SetPageFacet(int facetType, String facetName, long delay) {\n\t\tFacesContext context = FacesContext.getCurrentInstance();\n\t\tMap viewScope = context.getViewRoot().getViewMap();\n\t\tString previousFacet = \"\";\n\t\tString selectedFacet = \"\";\n\t\ttry {\n\t\t\tswitch (facetType) {\n\t\t\tcase 1:\/\/ Login\n\t\t\t\tpreviousFacet = \"previousLoginFacet\";\n\t\t\t\tselectedFacet = \"selectedLoginFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 2:\/\/ Home\n\t\t\t\tpreviousFacet = \"previousHomeFacet\";\n\t\t\t\tselectedFacet = \"selectedHomeFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 3:\/\/ FormPlaceholderFacet\n\t\t\t\tpreviousFacet = \"previousFormPlaceholderFacet\";\n\t\t\t\tselectedFacet = \"selectedFormPlaceholderFacet\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (facetName.equals(\"Previous\")) {\n\t\t\t\tSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n\t\t\t} else if (!facetName.equals(viewScope.get(selectedFacet))) {\n\t\t\t\tif (delay > 0) {\n\t\t\t\t\tThread.currentThread();\n\t\t\t\t\tThread.sleep(delay);\n\t\t\t\t}\n\t\t\t\tviewScope.put(previousFacet, viewScope.get(selectedFacet));\n\t\t\t\tviewScope.put(selectedFacet, facetName);\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","code_wo_comment":"@SuppressWarnings(\"unchecked\")\n\tpublic static void SetPageFacet(int facetType, String facetName, long delay) {\n\t\tFacesContext context = FacesContext.getCurrentInstance();\n\t\tMap viewScope = context.getViewRoot().getViewMap();\n\t\tString previousFacet = \"\";\n\t\tString selectedFacet = \"\";\n\t\ttry {\n\t\t\tswitch (facetType) {\n\t\t\tcase 1\n\t\t\t\tpreviousFacet = \"previousLoginFacet\";\n\t\t\t\tselectedFacet = \"selectedLoginFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 2\n\t\t\t\tpreviousFacet = \"previousHomeFacet\";\n\t\t\t\tselectedFacet = \"selectedHomeFacet\";\n\t\t\t\tbreak;\n\t\t\tcase 3\n\t\t\t\tpreviousFacet = \"previousFormPlaceholderFacet\";\n\t\t\t\tselectedFacet = \"selectedFormPlaceholderFacet\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (facetName.equals(\"Previous\")) {\n\t\t\t\tSetPageFacet(facetType, viewScope.get(previousFacet).toString(), delay);\n\t\t\t} else if (!facetName.equals(viewScope.get(selectedFacet))) {\n\t\t\t\tif (delay > 0) {\n\t\t\t\t\tThread.currentThread();\n\t\t\t\t\tThread.sleep(delay);\n\t\t\t\t}\n\t\t\t\tviewScope.put(previousFacet, viewScope.get(selectedFacet));\n\t\t\t\tviewScope.put(selectedFacet, facetName);\n\t\t\t}\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","cleancode":"@suppresswarnings(\"unchecked\") public static void setpagefacet(int facettype, string facetname, long delay) { facescontext context = facescontext.getcurrentinstance(); map viewscope = context.getviewroot().getviewmap(); string previousfacet = \"\"; string selectedfacet = \"\"; try { switch (facettype) { case 1 previousfacet = \"previousloginfacet\"; selectedfacet = \"selectedloginfacet\"; break; case 2 previousfacet = \"previoushomefacet\"; selectedfacet = \"selectedhomefacet\"; break; case 3 previousfacet = \"previousformplaceholderfacet\"; selectedfacet = \"selectedformplaceholderfacet\"; break; } if (facetname.equals(\"previous\")) { setpagefacet(facettype, viewscope.get(previousfacet).tostring(), delay); } else if (!facetname.equals(viewscope.get(selectedfacet))) { if (delay > 0) { thread.currentthread(); thread.sleep(delay); } viewscope.put(previousfacet, viewscope.get(selectedfacet)); viewscope.put(selectedfacet, facetname); } } catch (interruptedexception e) { e.printstacktrace(); } }","repo":"johnjardin\/ukuvuma-xpages-boilerplate","label":[1,0,0,0]}
{"id":9907,"original_code":"public static List<String> contentPrefixList(int flags)\n\t{\n\t\tfinal List<String> contentPrefixList = new ArrayList<String>();\n\t\tif ((flags & JMF) != 0) {\n\t\t\tcontentPrefixList.add(\"javax\");\n\t\t\tcontentPrefixList.add(\"com.sun\");\n\t\t\tcontentPrefixList.add(\"com.ibm\");\n\t\t}\n\t\tif ((flags & FMJ_NATIVE) != 0) {\n\t\t\tif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\t\t\t\t\/\/ Quicktime:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.qt\");\n\t\t\t}\n\t\t\tif (OSUtils.isWindows()) {\n\t\t\t\t\/\/ DirectShow:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.ds\");\n\t\t\t}\n\t\t\tif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\t\t\t\t\/\/ TODO: we could add these for other OS's, as gstreamer is cross-platform.\n\t\t\t\t\/\/ DirectShow:\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.gst\");\n\t\t\t}\n\t\t}\n\t\tif ((flags & FMJ) != 0) {\n\t\t\tcontentPrefixList.add(\"net.sf.fmj\");\n\t\t}\n\t\tif ((flags & THIRD_PARTY) != 0) {\n\t\t\t\/\/ none to add\n\t\t}\n\t\treturn contentPrefixList;\n\t}","code_wo_comment":"public static List<String> contentPrefixList(int flags)\n\t{\n\t\tfinal List<String> contentPrefixList = new ArrayList<String>();\n\t\tif ((flags & JMF) != 0) {\n\t\t\tcontentPrefixList.add(\"javax\");\n\t\t\tcontentPrefixList.add(\"com.sun\");\n\t\t\tcontentPrefixList.add(\"com.ibm\");\n\t\t}\n\t\tif ((flags & FMJ_NATIVE) != 0) {\n\t\t\tif (OSUtils.isMacOSX() || OSUtils.isWindows()) {\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.qt\");\n\t\t\t}\n\t\t\tif (OSUtils.isWindows()) {\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.ds\");\n\t\t\t}\n\t\t\tif (ENABLE_GSTREAMER && OSUtils.isLinux()) {\n\t\t\t\n\t\t\t\n\t\t\t\tcontentPrefixList.add(\"net.sf.fmj.gst\");\n\t\t\t}\n\t\t}\n\t\tif ((flags & FMJ) != 0) {\n\t\t\tcontentPrefixList.add(\"net.sf.fmj\");\n\t\t}\n\t\tif ((flags & THIRD_PARTY) != 0) {\n\t\t\n\t\t}\n\t\treturn contentPrefixList;\n\t}","cleancode":"public static list<string> contentprefixlist(int flags) { final list<string> contentprefixlist = new arraylist<string>(); if ((flags & jmf) != 0) { contentprefixlist.add(\"javax\"); contentprefixlist.add(\"com.sun\"); contentprefixlist.add(\"com.ibm\"); } if ((flags & fmj_native) != 0) { if (osutils.ismacosx() || osutils.iswindows()) { contentprefixlist.add(\"net.sf.fmj.qt\"); } if (osutils.iswindows()) { contentprefixlist.add(\"net.sf.fmj.ds\"); } if (enable_gstreamer && osutils.islinux()) { contentprefixlist.add(\"net.sf.fmj.gst\"); } } if ((flags & fmj) != 0) { contentprefixlist.add(\"net.sf.fmj\"); } if ((flags & third_party) != 0) { } return contentprefixlist; }","repo":"licaon-kter\/atalk-android","label":[0,1,0,0]}
{"id":26295,"original_code":"@Test(groups = \"slow\", enabled = false)\n    public void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n        \/\/ TODO add\/remove tag to invoice\n    }","code_wo_comment":"@Test(groups = \"slow\", enabled = false)\n    public void testOverdueStateAndWRITTEN_OFFTag() throws Exception {\n       \n    }","cleancode":"@test(groups = \"slow\", enabled = false) public void testoverduestateandwritten_offtag() throws exception { }","repo":"kevinpostlewaite\/killbill","label":[0,1,0,0]}
{"id":26312,"original_code":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\t\t\/\/ TO-DO rethink how to manage multiple servers\n\t\tfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\n\t\tfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\n\t\tfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\n\t\t\t\tpathInfo.length());\n\t\treturn firstServer + swaggerPath;\n\t}","code_wo_comment":"private String getServerUrl(OpenAPI openAPI, String pathInfo) {\n\t\n\t\tfinal String firstServer = openAPIUtils.mapServersToEndpoint(openAPI.getServers()).get(0);\n\t\tfinal String apiIdentifier = apiManagerService.getApiIdentifier(pathInfo);\n\t\tfinal String swaggerPath = pathInfo.substring(pathInfo.indexOf(apiIdentifier) + apiIdentifier.length(),\n\t\t\t\tpathInfo.length());\n\t\treturn firstServer + swaggerPath;\n\t}","cleancode":"private string getserverurl(openapi openapi, string pathinfo) { final string firstserver = openapiutils.mapserverstoendpoint(openapi.getservers()).get(0); final string apiidentifier = apimanagerservice.getapiidentifier(pathinfo); final string swaggerpath = pathinfo.substring(pathinfo.indexof(apiidentifier) + apiidentifier.length(), pathinfo.length()); return firstserver + swaggerpath; }","repo":"marrmartin\/onesaitplatform-cloud","label":[1,0,0,0]}
{"id":34553,"original_code":"@PostConstruct\n    public void setup(){\n        \/\/Do not use getClass() here... a typical weld issue...\n        endpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\n        availableMethods= Arrays.asList(Verb.values());\n        usersEndpoint=userWS.getEndpointUrl();\n        groupsEndpoint=groupWS.getEndpointUrl();\n        fidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\n        commonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n    }","code_wo_comment":"@PostConstruct\n    public void setup(){\n       \n        endpointUrl=appConfiguration.getBaseEndpoint() + BulkWebService.class.getAnnotation(Path.class).value();\n        availableMethods= Arrays.asList(Verb.values());\n        usersEndpoint=userWS.getEndpointUrl();\n        groupsEndpoint=groupWS.getEndpointUrl();\n        fidodevicesEndpoint=fidoDeviceWS.getEndpointUrl();\n        commonWsEndpointPrefix=usersEndpoint.substring(0, usersEndpoint.lastIndexOf(\"\/\"));\n    }","cleancode":"@postconstruct public void setup(){ endpointurl=appconfiguration.getbaseendpoint() + bulkwebservice.class.getannotation(path.class).value(); availablemethods= arrays.aslist(verb.values()); usersendpoint=userws.getendpointurl(); groupsendpoint=groupws.getendpointurl(); fidodevicesendpoint=fidodevicews.getendpointurl(); commonwsendpointprefix=usersendpoint.substring(0, usersendpoint.lastindexof(\"\/\")); }","repo":"linosgian\/oxTrust","label":[1,0,0,0]}
{"id":10032,"original_code":"private void onNetBegin(\n                BeginFW begin)\n            {\n                final long sequence = begin.sequence();\n                final long acknowledge = begin.acknowledge();\n                final int maximum = begin.maximum();\n                final long traceId = begin.traceId();\n                final long authorization = begin.authorization();\n                final long affinity = begin.affinity();\n                assert acknowledge <= sequence;\n                assert sequence >= replySeq;\n                assert acknowledge <= replyAck;\n                replySeq = sequence;\n                replyAck = acknowledge;\n                assert replyAck == replySeq;\n                assert maximum == 0;\n                boolean handshakeHashOK = false;\n                final OctetsFW extension = begin.extension();\n                if (extension.sizeof() != 0)\n                {\n                    \/\/ TODO: need lightweight approach (start)\n                    final HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\n                    final Map<String, String> headers = new LinkedHashMap<>();\n                    httpBeginEx.headers().forEach(header ->\n                    {\n                        final String name = header.name().asString();\n                        final String value = header.value().asString();\n                        headers.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n                    });\n                    final String status = headers.get(\":status\");\n                    final String upgrade = headers.get(\"upgrade\");\n                    final String hash = headers.get(\"sec-websocket-accept\");\n                    final String protocol = headers.get(\"sec-websocket-protocol\");\n                    \/\/ TODO: need lightweight approach (end)\n                    if (WEBSOCKET_STATUS.equals(status) &&\n                        WEBSOCKET_UPGRADE.equals(upgrade) &&\n                        Objects.equals(this.protocol, protocol))\n                    {\n                        sha1.reset();\n                        sha1.update(key.getBytes(US_ASCII));\n                        final byte[] digest = sha1.digest(HANDSHAKE_GUID);\n                        final Encoder encoder = Base64.getEncoder();\n                        final String handshakeHash = new String(encoder.encode(digest), US_ASCII);\n                        handshakeHashOK = handshakeHash.equals(hash);\n                    }\n                }\n                if (handshakeHashOK)\n                {\n                    doAppBegin(maximum, traceId, authorization, affinity);\n                }\n                else\n                {\n                    doAppReset(traceId, authorization);\n                }\n            }","code_wo_comment":"private void onNetBegin(\n                BeginFW begin)\n            {\n                final long sequence = begin.sequence();\n                final long acknowledge = begin.acknowledge();\n                final int maximum = begin.maximum();\n                final long traceId = begin.traceId();\n                final long authorization = begin.authorization();\n                final long affinity = begin.affinity();\n                assert acknowledge <= sequence;\n                assert sequence >= replySeq;\n                assert acknowledge <= replyAck;\n                replySeq = sequence;\n                replyAck = acknowledge;\n                assert replyAck == replySeq;\n                assert maximum == 0;\n                boolean handshakeHashOK = false;\n                final OctetsFW extension = begin.extension();\n                if (extension.sizeof() != 0)\n                {\n                   \n                    final HttpBeginExFW httpBeginEx = extension.get(httpBeginExRO::wrap);\n                    final Map<String, String> headers = new LinkedHashMap<>();\n                    httpBeginEx.headers().forEach(header ->\n                    {\n                        final String name = header.name().asString();\n                        final String value = header.value().asString();\n                        headers.merge(name, value, (v1, v2) -> String.format(\"%s, %s\", v1, v2));\n                    });\n                    final String status = headers.get(\":status\");\n                    final String upgrade = headers.get(\"upgrade\");\n                    final String hash = headers.get(\"sec-websocket-accept\");\n                    final String protocol = headers.get(\"sec-websocket-protocol\");\n                   \n                    if (WEBSOCKET_STATUS.equals(status) &&\n                        WEBSOCKET_UPGRADE.equals(upgrade) &&\n                        Objects.equals(this.protocol, protocol))\n                    {\n                        sha1.reset();\n                        sha1.update(key.getBytes(US_ASCII));\n                        final byte[] digest = sha1.digest(HANDSHAKE_GUID);\n                        final Encoder encoder = Base64.getEncoder();\n                        final String handshakeHash = new String(encoder.encode(digest), US_ASCII);\n                        handshakeHashOK = handshakeHash.equals(hash);\n                    }\n                }\n                if (handshakeHashOK)\n                {\n                    doAppBegin(maximum, traceId, authorization, affinity);\n                }\n                else\n                {\n                    doAppReset(traceId, authorization);\n                }\n            }","cleancode":"private void onnetbegin( beginfw begin) { final long sequence = begin.sequence(); final long acknowledge = begin.acknowledge(); final int maximum = begin.maximum(); final long traceid = begin.traceid(); final long authorization = begin.authorization(); final long affinity = begin.affinity(); assert acknowledge <= sequence; assert sequence >= replyseq; assert acknowledge <= replyack; replyseq = sequence; replyack = acknowledge; assert replyack == replyseq; assert maximum == 0; boolean handshakehashok = false; final octetsfw extension = begin.extension(); if (extension.sizeof() != 0) { final httpbeginexfw httpbeginex = extension.get(httpbeginexro::wrap); final map<string, string> headers = new linkedhashmap<>(); httpbeginex.headers().foreach(header -> { final string name = header.name().asstring(); final string value = header.value().asstring(); headers.merge(name, value, (v1, v2) -> string.format(\"%s, %s\", v1, v2)); }); final string status = headers.get(\":status\"); final string upgrade = headers.get(\"upgrade\"); final string hash = headers.get(\"sec-websocket-accept\"); final string protocol = headers.get(\"sec-websocket-protocol\"); if (websocket_status.equals(status) && websocket_upgrade.equals(upgrade) && objects.equals(this.protocol, protocol)) { sha1.reset(); sha1.update(key.getbytes(us_ascii)); final byte[] digest = sha1.digest(handshake_guid); final encoder encoder = base64.getencoder(); final string handshakehash = new string(encoder.encode(digest), us_ascii); handshakehashok = handshakehash.equals(hash); } } if (handshakehashok) { doappbegin(maximum, traceid, authorization, affinity); } else { doappreset(traceid, authorization); } }","repo":"lukefallows\/zilla","label":[1,0,0,0]}
{"id":18250,"original_code":"@Override\n\tpublic Value evaluate(Context context)\n\t{\n\t\tValue operand1 = get(0, context);\n\t\tValue operand2 = get(1, context);\n\t\tif (operand1.isNumber() && operand2.isList())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tList<Value> value2 = operand2.getList();\n\t\t\treturn value2.get(value1.intValue());\n\t\t}\n\t\telse if (operand1.isNumber() && operand2.isString())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tString value2 = operand2.getString();\n\t\t\treturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n\t\t}\n\t\t\/\/ TODO: explain more\n\t\tthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n\t}","code_wo_comment":"@Override\n\tpublic Value evaluate(Context context)\n\t{\n\t\tValue operand1 = get(0, context);\n\t\tValue operand2 = get(1, context);\n\t\tif (operand1.isNumber() && operand2.isList())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tList<Value> value2 = operand2.getList();\n\t\t\treturn value2.get(value1.intValue());\n\t\t}\n\t\telse if (operand1.isNumber() && operand2.isString())\n\t\t{\n\t\t\tBigDecimal value1 = operand1.getNumber();\n\t\t\tString value2 = operand2.getString();\n\t\t\treturn Value.asString(String.valueOf(value2.charAt(value1.intValue())));\n\t\t}\n\t\n\t\tthrow new RuntimeException(\"Cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\");\n\t}","cleancode":"@override public value evaluate(context context) { value operand1 = get(0, context); value operand2 = get(1, context); if (operand1.isnumber() && operand2.islist()) { bigdecimal value1 = operand1.getnumber(); list<value> value2 = operand2.getlist(); return value2.get(value1.intvalue()); } else if (operand1.isnumber() && operand2.isstring()) { bigdecimal value1 = operand1.getnumber(); string value2 = operand2.getstring(); return value.asstring(string.valueof(value2.charat(value1.intvalue()))); } throw new runtimeexception(\"cannot perform operation '\" + token.lexeme + \"' at: [\" + token.line + \", \" + token.column + \"]\"); }","repo":"mauriciotogneri\/prefix","label":[0,0,0,0]}
{"id":10131,"original_code":"@Test\n  public void test() throws Exception {\n    \/\/ The generated main dex list should contain Main (which is a root) and A (which is a direct\n    \/\/ dependency of Main).\n    assertEquals(2, mainDexList.size());\n    assertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\n    assertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\n    R8TestCompileResult compileResult =\n        testForR8(parameters.getBackend())\n            .addInnerClasses(getClass())\n            .addInliningAnnotations()\n            .addKeepClassAndMembersRules(Main.class)\n            .addMainDexListClassReferences(mainDexList)\n            .collectMainDexClasses()\n            .enableInliningAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .setMinApi(parameters.getApiLevel())\n            .allowDiagnosticMessages()\n            .compileWithExpectedDiagnostics(\n                diagnostics ->\n                    diagnostics\n                        .assertOnlyWarnings()\n                        .assertWarningsMatch(\n                            diagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\n    CodeInspector inspector = compileResult.inspector();\n    ClassSubject mainClassSubject = inspector.clazz(Main.class);\n    assertThat(mainClassSubject, isPresent());\n    MethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\n    assertThat(fooMethodSubject, isPresent());\n    ClassSubject aClassSubject = inspector.clazz(A.class);\n    assertThat(aClassSubject, isPresent());\n    MethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\n    assertThat(barMethodSubject, isPresent());\n    ClassSubject bClassSubject = inspector.clazz(B.class);\n    assertThat(bClassSubject, isPresent());\n    MethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\n    assertThat(bazMethodSubject, isPresent());\n    assertThat(fooMethodSubject, invokesMethod(barMethodSubject));\n    assertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n    \/\/ The main dex classes should be the same as the input main dex list.\n    assertEquals(\n        ImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\n        compileResult.getMainDexClasses());\n  }","code_wo_comment":"@Test\n  public void test() throws Exception {\n   \n   \n    assertEquals(2, mainDexList.size());\n    assertEquals(A.class.getTypeName(), mainDexList.get(0).getTypeName());\n    assertEquals(Main.class.getTypeName(), mainDexList.get(1).getTypeName());\n    R8TestCompileResult compileResult =\n        testForR8(parameters.getBackend())\n            .addInnerClasses(getClass())\n            .addInliningAnnotations()\n            .addKeepClassAndMembersRules(Main.class)\n            .addMainDexListClassReferences(mainDexList)\n            .collectMainDexClasses()\n            .enableInliningAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .enableNoHorizontalClassMergingAnnotations()\n            .setMinApi(parameters.getApiLevel())\n            .allowDiagnosticMessages()\n            .compileWithExpectedDiagnostics(\n                diagnostics ->\n                    diagnostics\n                        .assertOnlyWarnings()\n                        .assertWarningsMatch(\n                            diagnosticType(UnsupportedMainDexListUsageDiagnostic.class)));\n    CodeInspector inspector = compileResult.inspector();\n    ClassSubject mainClassSubject = inspector.clazz(Main.class);\n    assertThat(mainClassSubject, isPresent());\n    MethodSubject fooMethodSubject = mainClassSubject.uniqueMethodWithName(\"foo\");\n    assertThat(fooMethodSubject, isPresent());\n    ClassSubject aClassSubject = inspector.clazz(A.class);\n    assertThat(aClassSubject, isPresent());\n    MethodSubject barMethodSubject = aClassSubject.uniqueMethodWithName(\"bar\");\n    assertThat(barMethodSubject, isPresent());\n    ClassSubject bClassSubject = inspector.clazz(B.class);\n    assertThat(bClassSubject, isPresent());\n    MethodSubject bazMethodSubject = bClassSubject.uniqueMethodWithName(\"baz\");\n    assertThat(bazMethodSubject, isPresent());\n    assertThat(fooMethodSubject, invokesMethod(barMethodSubject));\n    assertThat(barMethodSubject, invokesMethod(bazMethodSubject));\n   \n    assertEquals(\n        ImmutableSet.of(mainClassSubject.getFinalName(), aClassSubject.getFinalName()),\n        compileResult.getMainDexClasses());\n  }","cleancode":"@test public void test() throws exception { assertequals(2, maindexlist.size()); assertequals(a.class.gettypename(), maindexlist.get(0).gettypename()); assertequals(main.class.gettypename(), maindexlist.get(1).gettypename()); r8testcompileresult compileresult = testforr8(parameters.getbackend()) .addinnerclasses(getclass()) .addinliningannotations() .addkeepclassandmembersrules(main.class) .addmaindexlistclassreferences(maindexlist) .collectmaindexclasses() .enableinliningannotations() .enablenohorizontalclassmergingannotations() .enablenohorizontalclassmergingannotations() .setminapi(parameters.getapilevel()) .allowdiagnosticmessages() .compilewithexpecteddiagnostics( diagnostics -> diagnostics .assertonlywarnings() .assertwarningsmatch( diagnostictype(unsupportedmaindexlistusagediagnostic.class))); codeinspector inspector = compileresult.inspector(); classsubject mainclasssubject = inspector.clazz(main.class); assertthat(mainclasssubject, ispresent()); methodsubject foomethodsubject = mainclasssubject.uniquemethodwithname(\"foo\"); assertthat(foomethodsubject, ispresent()); classsubject aclasssubject = inspector.clazz(a.class); assertthat(aclasssubject, ispresent()); methodsubject barmethodsubject = aclasssubject.uniquemethodwithname(\"bar\"); assertthat(barmethodsubject, ispresent()); classsubject bclasssubject = inspector.clazz(b.class); assertthat(bclasssubject, ispresent()); methodsubject bazmethodsubject = bclasssubject.uniquemethodwithname(\"baz\"); assertthat(bazmethodsubject, ispresent()); assertthat(foomethodsubject, invokesmethod(barmethodsubject)); assertthat(barmethodsubject, invokesmethod(bazmethodsubject)); assertequals( immutableset.of(mainclasssubject.getfinalname(), aclasssubject.getfinalname()), compileresult.getmaindexclasses()); }","repo":"kami-lang\/madex-r8","label":[0,0,0,1]}
{"id":18378,"original_code":"public T getAbstractOption() {\n        \/\/ WARNING!! Do not rename this method to getOption(). It breaks\n        \/\/ BeanUtils, which will silently not call setOption. Very annoying!\n        return abstractOption;\n    }","code_wo_comment":"public T getAbstractOption() {\n       \n       \n        return abstractOption;\n    }","cleancode":"public t getabstractoption() { return abstractoption; }","repo":"kupl\/starlab-benchmarks","label":[0,0,1,0]}
{"id":18390,"original_code":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n                \/\/ TODO Want to use classLoader = mgmt.getCatalog().getRootClassLoader();\n                ClassLoader classLoader = LocalUsageManager.class.getClassLoader();\n                Optional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\n                if (result.isPresent()) {\n                    if (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\n                        return new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n                    } else {\n                        return (brooklyn.management.internal.UsageListener) result.get();\n                    }\n                } else {\n                    throw new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");\n                }\n            }","code_wo_comment":"@Override public brooklyn.management.internal.UsageListener apply(String input) {\n               \n                ClassLoader classLoader = LocalUsageManager.class.getClassLoader();\n                Optional<Object> result = Reflections.invokeConstructorWithArgs(classLoader, input);\n                if (result.isPresent()) {\n                    if (result.get() instanceof brooklyn.management.internal.UsageManager.UsageListener) {\n                        return new brooklyn.management.internal.UsageManager.UsageListener.UsageListenerAdapter((brooklyn.management.internal.UsageManager.UsageListener) result.get());\n                    } else {\n                        return (brooklyn.management.internal.UsageListener) result.get();\n                    }\n                } else {\n                    throw new IllegalStateException(\"Failed to create UsageListener from class name '\"+input+\"' using no-arg constructor\");\n                }\n            }","cleancode":"@override public brooklyn.management.internal.usagelistener apply(string input) { classloader classloader = localusagemanager.class.getclassloader(); optional<object> result = reflections.invokeconstructorwithargs(classloader, input); if (result.ispresent()) { if (result.get() instanceof brooklyn.management.internal.usagemanager.usagelistener) { return new brooklyn.management.internal.usagemanager.usagelistener.usagelisteneradapter((brooklyn.management.internal.usagemanager.usagelistener) result.get()); } else { return (brooklyn.management.internal.usagelistener) result.get(); } } else { throw new illegalstateexception(\"failed to create usagelistener from class name '\"+input+\"' using no-arg constructor\"); } }","repo":"kiuby88\/incubator-brooklyn","label":[1,0,0,0]}
{"id":2022,"original_code":"@Test\n    public void testUpgradeTables() throws Exception {\n        TestRMTxStore store = new TestRMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n        \/\/ workaround for the db file deletion problem during the tests\n        store.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n        \/\/ use the old db definitions to create the tables\n        store.init();\n        \/\/ verify the absence of the new columns in the tables\n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        \/\/ upgrade the tables and add new columns to the old tables\n        store.upgrade();\n        store.init();\n        \/\/ verify the presence of the new columns in the upgraded tables\n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n    }","code_wo_comment":"@Test\n    public void testUpgradeTables() throws Exception {\n        TestRMTxStore store = new TestRMTxStore();\n        store.setDriverClassName(\"org.apache.derby.jdbc.EmbeddedDriver\");\n       \n        store.setUrl(MessageFormat.format(\"jdbc:derby:{0};create=true\", TEST_DB_NAME));\n       \n        store.init();\n       \n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, true);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, true);\n       \n        store.upgrade();\n        store.init();\n       \n        verifyColumns(store, \"CXF_RM_SRC_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, \"CXF_RM_DEST_SEQUENCES\", new String[]{\"PROTOCOL_VERSION\"}, false);\n        verifyColumns(store, INBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n        verifyColumns(store, OUTBOUND_MSGS_TABLE_NAME, new String[]{}, false);\n    }","cleancode":"@test public void testupgradetables() throws exception { testrmtxstore store = new testrmtxstore(); store.setdriverclassname(\"org.apache.derby.jdbc.embeddeddriver\"); store.seturl(messageformat.format(\"jdbc:derby:{0};create=true\", test_db_name)); store.init(); verifycolumns(store, \"cxf_rm_src_sequences\", new string[]{\"protocol_version\"}, true); verifycolumns(store, \"cxf_rm_dest_sequences\", new string[]{\"protocol_version\"}, true); verifycolumns(store, inbound_msgs_table_name, new string[]{}, true); verifycolumns(store, outbound_msgs_table_name, new string[]{}, true); store.upgrade(); store.init(); verifycolumns(store, \"cxf_rm_src_sequences\", new string[]{\"protocol_version\"}, false); verifycolumns(store, \"cxf_rm_dest_sequences\", new string[]{\"protocol_version\"}, false); verifycolumns(store, inbound_msgs_table_name, new string[]{}, false); verifycolumns(store, outbound_msgs_table_name, new string[]{}, false); }","repo":"kimjand\/cxf","label":[1,0,0,0]}
{"id":2048,"original_code":"@VisibleForTesting\n  HeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\n    final Future<HeaderCacheElement> deferredResult;\n    \/\/ Optimize for the common case: do a volatile read to peek for a Good cache value\n    HeaderCacheElement headerCacheUnsync = this.headerCache;\n    if (headerCacheUnsync.getCacheState() == CacheState.Good) {\n      return headerCacheUnsync;\n    }\n    \/\/ TODO(igorbernstein2): figure out how to make this work with appengine request scoped threads\n    synchronized (lock) {\n      CacheState state = headerCache.getCacheState();\n      switch (state) {\n        case Good:\n          return headerCache;\n        case Stale:\n          asyncRefresh();\n          return headerCache;\n        case Expired:\n        case Exception:\n          \/\/ defer the future resolution (asyncRefresh will spin up a thread that will try to acquire the lock)\n          deferredResult = asyncRefresh();\n          break;\n        default:\n          return new HeaderCacheElement(\n              Status.UNAUTHENTICATED\n                  .withCause(new IllegalStateException(\"Could not process state: \" + state))\n          );\n      }\n    }\n    return deferredResult.get(5, TimeUnit.SECONDS);\n  }","code_wo_comment":"@VisibleForTesting\n  HeaderCacheElement getHeader() throws ExecutionException, InterruptedException, TimeoutException {\n    final Future<HeaderCacheElement> deferredResult;\n   \n    HeaderCacheElement headerCacheUnsync = this.headerCache;\n    if (headerCacheUnsync.getCacheState() == CacheState.Good) {\n      return headerCacheUnsync;\n    }\n   \n    synchronized (lock) {\n      CacheState state = headerCache.getCacheState();\n      switch (state) {\n        case Good:\n          return headerCache;\n        case Stale:\n          asyncRefresh();\n          return headerCache;\n        case Expired:\n        case Exception:\n         \n          deferredResult = asyncRefresh();\n          break;\n        default:\n          return new HeaderCacheElement(\n              Status.UNAUTHENTICATED\n                  .withCause(new IllegalStateException(\"Could not process state: \" + state))\n          );\n      }\n    }\n    return deferredResult.get(5, TimeUnit.SECONDS);\n  }","cleancode":"@visiblefortesting headercacheelement getheader() throws executionexception, interruptedexception, timeoutexception { final future<headercacheelement> deferredresult; headercacheelement headercacheunsync = this.headercache; if (headercacheunsync.getcachestate() == cachestate.good) { return headercacheunsync; } synchronized (lock) { cachestate state = headercache.getcachestate(); switch (state) { case good: return headercache; case stale: asyncrefresh(); return headercache; case expired: case exception: deferredresult = asyncrefresh(); break; default: return new headercacheelement( status.unauthenticated .withcause(new illegalstateexception(\"could not process state: \" + state)) ); } } return deferredresult.get(5, timeunit.seconds); }","repo":"mbrukman\/java-bigtable-hbase","label":[1,0,0,0]}
{"id":10315,"original_code":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n        \/\/effectively map from type to (map from description to events)\n        Map<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\n        for (EventCluster aggregateEvent : preMergedEvents) {\n            typeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n                    .put(aggregateEvent.getDescription(), aggregateEvent);\n        }\n        \/\/result list to return\n        ArrayList<EventCluster> aggEvents = new ArrayList<>();\n        \/\/For each (type, description) key, merge agg events\n        for (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n            \/\/for each description ...\n            for (String descr : descrMap.keySet()) {\n                \/\/run through the sorted events, merging together adjacent events\n                Iterator<EventCluster> iterator = descrMap.get(descr).stream()\n                        .sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n                        .iterator();\n                EventCluster current = iterator.next();\n                while (iterator.hasNext()) {\n                    EventCluster next = iterator.next();\n                    Interval gap = current.getSpan().gap(next.getSpan());\n                    \/\/if they overlap or gap is less one quarter timeUnitLength\n                    \/\/TODO: 1\/4 factor is arbitrary. review! -jm\n                    if (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n                        \/\/merge them\n                        current = EventCluster.merge(current, next);\n                    } else {\n                        \/\/done merging into current, set next as new current\n                        aggEvents.add(current);\n                        current = next;\n                    }\n                }\n                aggEvents.add(current);\n            }\n        }\n        \/\/merge clusters to stripes\n        Map<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\n        for (EventCluster eventCluster : aggEvents) {\n            stripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\n                    new EventStripe(eventCluster, null), EventStripe::merge);\n        }\n        return stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n    }","code_wo_comment":"static private List<EventStripe> mergeClustersToStripes(Period timeUnitLength, List<EventCluster> preMergedEvents) {\n       \n        Map<EventType, SetMultimap< String, EventCluster>> typeMap = new HashMap<>();\n        for (EventCluster aggregateEvent : preMergedEvents) {\n            typeMap.computeIfAbsent(aggregateEvent.getEventType(), eventType -> HashMultimap.create())\n                    .put(aggregateEvent.getDescription(), aggregateEvent);\n        }\n       \n        ArrayList<EventCluster> aggEvents = new ArrayList<>();\n       \n        for (SetMultimap<String, EventCluster> descrMap : typeMap.values()) {\n           \n            for (String descr : descrMap.keySet()) {\n               \n                Iterator<EventCluster> iterator = descrMap.get(descr).stream()\n                        .sorted(Comparator.comparing(event -> event.getSpan().getStartMillis()))\n                        .iterator();\n                EventCluster current = iterator.next();\n                while (iterator.hasNext()) {\n                    EventCluster next = iterator.next();\n                    Interval gap = current.getSpan().gap(next.getSpan());\n                   \n                   \n                    if (gap == null || gap.toDuration().getMillis() <= timeUnitLength.toDurationFrom(gap.getStart()).getMillis() \/ 4) {\n                       \n                        current = EventCluster.merge(current, next);\n                    } else {\n                       \n                        aggEvents.add(current);\n                        current = next;\n                    }\n                }\n                aggEvents.add(current);\n            }\n        }\n       \n        Map<ImmutablePair<EventType, String>, EventStripe> stripeDescMap = new HashMap<>();\n        for (EventCluster eventCluster : aggEvents) {\n            stripeDescMap.merge(ImmutablePair.of(eventCluster.getEventType(), eventCluster.getDescription()),\n                    new EventStripe(eventCluster, null), EventStripe::merge);\n        }\n        return stripeDescMap.values().stream().sorted(Comparator.comparing(EventStripe::getStartMillis)).collect(Collectors.toList());\n    }","cleancode":"static private list<eventstripe> mergeclusterstostripes(period timeunitlength, list<eventcluster> premergedevents) { map<eventtype, setmultimap< string, eventcluster>> typemap = new hashmap<>(); for (eventcluster aggregateevent : premergedevents) { typemap.computeifabsent(aggregateevent.geteventtype(), eventtype -> hashmultimap.create()) .put(aggregateevent.getdescription(), aggregateevent); } arraylist<eventcluster> aggevents = new arraylist<>(); for (setmultimap<string, eventcluster> descrmap : typemap.values()) { for (string descr : descrmap.keyset()) { iterator<eventcluster> iterator = descrmap.get(descr).stream() .sorted(comparator.comparing(event -> event.getspan().getstartmillis())) .iterator(); eventcluster current = iterator.next(); while (iterator.hasnext()) { eventcluster next = iterator.next(); interval gap = current.getspan().gap(next.getspan()); if (gap == null || gap.toduration().getmillis() <= timeunitlength.todurationfrom(gap.getstart()).getmillis() \/ 4) { current = eventcluster.merge(current, next); } else { aggevents.add(current); current = next; } } aggevents.add(current); } } map<immutablepair<eventtype, string>, eventstripe> stripedescmap = new hashmap<>(); for (eventcluster eventcluster : aggevents) { stripedescmap.merge(immutablepair.of(eventcluster.geteventtype(), eventcluster.getdescription()), new eventstripe(eventcluster, null), eventstripe::merge); } return stripedescmap.values().stream().sorted(comparator.comparing(eventstripe::getstartmillis)).collect(collectors.tolist()); }","repo":"karlmortensen\/autopsy","label":[1,0,0,0]}
{"id":2162,"original_code":"public void storeObjectField(int fieldNumber, Object value)\n    {\n        if (value == null)\n        {\n            return; \/\/ No value so nothing to do\n        }\n        ExecutionContext ec = op.getExecutionContext();\n        ClassLoaderResolver clr = ec.getClassLoaderResolver();\n        AbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\n        if (mmd != null)\n        {\n            DatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\n            JavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\n            if (fieldMapping != null)\n            {\n                if (fieldMapping instanceof InterfaceMapping)\n                {\n                    \/\/ 1-1 Interface field\n                    InterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\n                    if (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n                    {\n                        \/\/ Field is defined to not accept this type so just return\n                        return;\n                    }\n                    processInterfaceMappingForValue(intfMapping, value, mmd, ec);\n                }\n                else if (mmd.hasCollection() || mmd.hasArray())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                        \/\/ Not join table so no supported schema updates\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    ElementContainerTable collTbl = (ElementContainerTable)joinTbl;\n                    JavaTypeMapping elemMapping = collTbl.getElementMapping();\n                    if (elemMapping instanceof InterfaceMapping)\n                    {\n                        InterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\n                        if (mmd.hasCollection())\n                        {\n                            Collection coll = (Collection)value;\n                            if (coll.isEmpty())\n                            {\n                                return;\n                            }\n                            \/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n                            Object elementValue = coll.iterator().next();\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                        else if (mmd.hasArray())\n                        {\n                            if (Array.getLength(value) == 0)\n                            {\n                                return;\n                            }\n                            \/\/ Update value mapping using first element. Maybe we should do the same for all elements?\n                            Object elementValue = Array.get(value,  0);\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                    }\n                }\n                else if (mmd.hasMap())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                        \/\/ Not join table so no supported schema updates\n                        return;\n                    }\n                    Map map = (Map)value;\n                    if (map.isEmpty())\n                    {\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    MapTable mapTbl = (MapTable)joinTbl;\n                    JavaTypeMapping keyMapping = mapTbl.getKeyMapping();\n                    if (keyMapping instanceof InterfaceMapping)\n                    {\n                        \/\/ Update key mapping using first key. Maybe we should do the same for all keys?\n                        InterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\n                        Object keyValue = map.keySet().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n                    }\n                    JavaTypeMapping valMapping = mapTbl.getValueMapping();\n                    if (valMapping instanceof InterfaceMapping)\n                    {\n                        \/\/ Update value mapping using first value. Maybe we should do the same for all values?\n                        InterfaceMapping intfMapping = (InterfaceMapping)valMapping;\n                        Object valValue = map.values().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"public void storeObjectField(int fieldNumber, Object value)\n    {\n        if (value == null)\n        {\n            return;\n        }\n        ExecutionContext ec = op.getExecutionContext();\n        ClassLoaderResolver clr = ec.getClassLoaderResolver();\n        AbstractMemberMetaData mmd = op.getClassMetaData().getMetaDataForManagedMemberAtAbsolutePosition(fieldNumber);\n        if (mmd != null)\n        {\n            DatastoreClass table = rdbmsMgr.getDatastoreClass(op.getObject().getClass().getName(), clr);\n            JavaTypeMapping fieldMapping = table.getMemberMapping(mmd);\n            if (fieldMapping != null)\n            {\n                if (fieldMapping instanceof InterfaceMapping)\n                {\n                   \n                    InterfaceMapping intfMapping = (InterfaceMapping)fieldMapping;\n                    if (mmd.getFieldTypes() != null || mmd.hasExtension(MetaData.EXTENSION_MEMBER_IMPLEMENTATION_CLASSES))\n                    {\n                       \n                        return;\n                    }\n                    processInterfaceMappingForValue(intfMapping, value, mmd, ec);\n                }\n                else if (mmd.hasCollection() || mmd.hasArray())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                       \n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    ElementContainerTable collTbl = (ElementContainerTable)joinTbl;\n                    JavaTypeMapping elemMapping = collTbl.getElementMapping();\n                    if (elemMapping instanceof InterfaceMapping)\n                    {\n                        InterfaceMapping intfMapping = (InterfaceMapping)elemMapping;\n                        if (mmd.hasCollection())\n                        {\n                            Collection coll = (Collection)value;\n                            if (coll.isEmpty())\n                            {\n                                return;\n                            }\n                           \n                            Object elementValue = coll.iterator().next();\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                        else if (mmd.hasArray())\n                        {\n                            if (Array.getLength(value) == 0)\n                            {\n                                return;\n                            }\n                           \n                            Object elementValue = Array.get(value,  0);\n                            processInterfaceMappingForValue(intfMapping, elementValue, mmd, ec);\n                        }\n                    }\n                }\n                else if (mmd.hasMap())\n                {\n                    boolean hasJoin = false;\n                    if (mmd.getJoinMetaData() != null)\n                    {\n                        hasJoin = true;\n                    }\n                    else\n                    {\n                        AbstractMemberMetaData[] relMmds = mmd.getRelatedMemberMetaData(clr);\n                        if (relMmds != null && relMmds[0].getJoinMetaData() != null)\n                        {\n                            hasJoin = true;\n                        }\n                    }\n                    if (!hasJoin)\n                    {\n                       \n                        return;\n                    }\n                    Map map = (Map)value;\n                    if (map.isEmpty())\n                    {\n                        return;\n                    }\n                    Table joinTbl = fieldMapping.getStoreManager().getTable(mmd);\n                    MapTable mapTbl = (MapTable)joinTbl;\n                    JavaTypeMapping keyMapping = mapTbl.getKeyMapping();\n                    if (keyMapping instanceof InterfaceMapping)\n                    {\n                       \n                        InterfaceMapping intfMapping = (InterfaceMapping)keyMapping;\n                        Object keyValue = map.keySet().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, keyValue, mmd, ec);\n                    }\n                    JavaTypeMapping valMapping = mapTbl.getValueMapping();\n                    if (valMapping instanceof InterfaceMapping)\n                    {\n                       \n                        InterfaceMapping intfMapping = (InterfaceMapping)valMapping;\n                        Object valValue = map.values().iterator().next();\n                        processInterfaceMappingForValue(intfMapping, valValue, mmd, ec);\n                    }\n                }\n            }\n        }\n    }","cleancode":"public void storeobjectfield(int fieldnumber, object value) { if (value == null) { return; } executioncontext ec = op.getexecutioncontext(); classloaderresolver clr = ec.getclassloaderresolver(); abstractmembermetadata mmd = op.getclassmetadata().getmetadataformanagedmemberatabsoluteposition(fieldnumber); if (mmd != null) { datastoreclass table = rdbmsmgr.getdatastoreclass(op.getobject().getclass().getname(), clr); javatypemapping fieldmapping = table.getmembermapping(mmd); if (fieldmapping != null) { if (fieldmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)fieldmapping; if (mmd.getfieldtypes() != null || mmd.hasextension(metadata.extension_member_implementation_classes)) { return; } processinterfacemappingforvalue(intfmapping, value, mmd, ec); } else if (mmd.hascollection() || mmd.hasarray()) { boolean hasjoin = false; if (mmd.getjoinmetadata() != null) { hasjoin = true; } else { abstractmembermetadata[] relmmds = mmd.getrelatedmembermetadata(clr); if (relmmds != null && relmmds[0].getjoinmetadata() != null) { hasjoin = true; } } if (!hasjoin) { return; } table jointbl = fieldmapping.getstoremanager().gettable(mmd); elementcontainertable colltbl = (elementcontainertable)jointbl; javatypemapping elemmapping = colltbl.getelementmapping(); if (elemmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)elemmapping; if (mmd.hascollection()) { collection coll = (collection)value; if (coll.isempty()) { return; } object elementvalue = coll.iterator().next(); processinterfacemappingforvalue(intfmapping, elementvalue, mmd, ec); } else if (mmd.hasarray()) { if (array.getlength(value) == 0) { return; } object elementvalue = array.get(value, 0); processinterfacemappingforvalue(intfmapping, elementvalue, mmd, ec); } } } else if (mmd.hasmap()) { boolean hasjoin = false; if (mmd.getjoinmetadata() != null) { hasjoin = true; } else { abstractmembermetadata[] relmmds = mmd.getrelatedmembermetadata(clr); if (relmmds != null && relmmds[0].getjoinmetadata() != null) { hasjoin = true; } } if (!hasjoin) { return; } map map = (map)value; if (map.isempty()) { return; } table jointbl = fieldmapping.getstoremanager().gettable(mmd); maptable maptbl = (maptable)jointbl; javatypemapping keymapping = maptbl.getkeymapping(); if (keymapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)keymapping; object keyvalue = map.keyset().iterator().next(); processinterfacemappingforvalue(intfmapping, keyvalue, mmd, ec); } javatypemapping valmapping = maptbl.getvaluemapping(); if (valmapping instanceof interfacemapping) { interfacemapping intfmapping = (interfacemapping)valmapping; object valvalue = map.values().iterator().next(); processinterfacemappingforvalue(intfmapping, valvalue, mmd, ec); } } } } }","repo":"meysam\/datanucleus-rdbms","label":[1,0,0,0]}
{"id":2180,"original_code":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n        \/\/MenuManager menu = MenuManager.getInstance();\n        logger.config(\"R_InitData\");\n        data.R_InitData (wad);\n        \/\/UNUSED - gets points from a table.\n        \/\/logger.config(\"\\nR_InitPointToAngle\");\n        \/\/R_InitPointToAngle ();\n        \/\/UNUSED - gets points from a table.\n        \/\/logger.config(\"\\nR_InitTables\");\n        \/\/R_InitTables ();\n        \/\/ viewwidth \/ viewheight \/ detailLevel are set by the defaults\n        R_SetViewSize (screenBlocks, detailLevel);\n        logger.config(\"R_InitPlanes\");\n        plane.R_InitPlanes ();   \/\/todo  Handled in r_planes.c\n        logger.config(\"R_InitLightTables\");\n        R_InitLightTables ();\n        logger.config(\"R_InitSkyMap\");\n        R_InitSkyMap (wad);   \/\/todo handled in r_sky.c\n        logger.config(\"R_InitTranslationTables\");\n        draw.R_InitTranslationTables ();  \/\/todo handled in r_draw.c\n        framecount = 0;\n    }","code_wo_comment":"public void R_Init (Wad wad, int screenBlocks, boolean detailLevel) {\n       \n        logger.config(\"R_InitData\");\n        data.R_InitData (wad);\n       \n       \n       \n       \n       \n       \n       \n        R_SetViewSize (screenBlocks, detailLevel);\n        logger.config(\"R_InitPlanes\");\n        plane.R_InitPlanes ();  \n        logger.config(\"R_InitLightTables\");\n        R_InitLightTables ();\n        logger.config(\"R_InitSkyMap\");\n        R_InitSkyMap (wad);  \n        logger.config(\"R_InitTranslationTables\");\n        draw.R_InitTranslationTables (); \n        framecount = 0;\n    }","cleancode":"public void r_init (wad wad, int screenblocks, boolean detaillevel) { logger.config(\"r_initdata\"); data.r_initdata (wad); r_setviewsize (screenblocks, detaillevel); logger.config(\"r_initplanes\"); plane.r_initplanes (); logger.config(\"r_initlighttables\"); r_initlighttables (); logger.config(\"r_initskymap\"); r_initskymap (wad); logger.config(\"r_inittranslationtables\"); draw.r_inittranslationtables (); framecount = 0; }","repo":"maehem\/Thump","label":[1,0,0,0]}
{"id":2227,"original_code":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\n\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setResourceResolver(iepdResourceResolver);\n        List<Source> sourceList = new ArrayList<Source>();\n        for (String schemaPath : schemaPathList) {\n        \tInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\n        \tStreamSource schemaStreamSource = new StreamSource(schemaInStream);\n        \tsourceList.add(schemaStreamSource);        \t\n        }\n        Source[] schemaSourcesArray = sourceList.toArray(new Source[]{});\n        try {        \t\n            Schema schema = schemaFactory.newSchema(schemaSourcesArray);        \n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(d));\n        } catch (Exception e) {\n            try {\n                e.printStackTrace();\n                System.err.println(\"Input document:\");\n                XmlUtils.printNode(d);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n\t}","code_wo_comment":"public static void validateInstance(Document d, LSResourceResolver iepdResourceResolver, List<String> schemaPathList) throws SAXException, Exception {\n\t\tSchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setResourceResolver(iepdResourceResolver);\n        List<Source> sourceList = new ArrayList<Source>();\n        for (String schemaPath : schemaPathList) {\n        \tInputStream schemaInStream = XmlUtils.class.getClassLoader().getResourceAsStream(schemaPath);\n        \tStreamSource schemaStreamSource = new StreamSource(schemaInStream);\n        \tsourceList.add(schemaStreamSource);        \t\n        }\n        Source[] schemaSourcesArray = sourceList.toArray(new Source[]{});\n        try {        \t\n            Schema schema = schemaFactory.newSchema(schemaSourcesArray);        \n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(d));\n        } catch (Exception e) {\n            try {\n                e.printStackTrace();\n                System.err.println(\"Input document:\");\n                XmlUtils.printNode(d);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n            }\n            throw e;\n        }\n\t}","cleancode":"public static void validateinstance(document d, lsresourceresolver iepdresourceresolver, list<string> schemapathlist) throws saxexception, exception { schemafactory schemafactory = schemafactory.newinstance(xmlconstants.w3c_xml_schema_ns_uri); schemafactory.setresourceresolver(iepdresourceresolver); list<source> sourcelist = new arraylist<source>(); for (string schemapath : schemapathlist) { inputstream schemainstream = xmlutils.class.getclassloader().getresourceasstream(schemapath); streamsource schemastreamsource = new streamsource(schemainstream); sourcelist.add(schemastreamsource); } source[] schemasourcesarray = sourcelist.toarray(new source[]{}); try { schema schema = schemafactory.newschema(schemasourcesarray); validator validator = schema.newvalidator(); validator.validate(new domsource(d)); } catch (exception e) { try { e.printstacktrace(); system.err.println(\"input document:\"); xmlutils.printnode(d); } catch (exception e1) { e1.printstacktrace(); } throw e; } }","repo":"mark43\/nibrs","label":[0,0,0,0]}
{"id":18713,"original_code":"@Test\n    \/** TODO this test works if we assume most recent version wins, but semantics TBC *\/\n    public void testMoreEntityV2ThenV1GivesV1() throws Exception {\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\n        addCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\n        forceCatalogUpdate();\n        addCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\n        Entity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\n        Entity moreEntity = Iterables.getOnlyElement(app.getChildren());\n        OsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);\n        OsgiVersionMoreEntityTest.assertV1MethodCall(moreEntity);\n    }","code_wo_comment":"@Test\n   \n    public void testMoreEntityV2ThenV1GivesV1() throws Exception {\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\");\n        TestResourceUnavailableException.throwIfResourceUnavailable(getClass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\");\n        addCatalogItems(getLocalResource(\"more-entity-v2-osgi-catalog.yaml\"));\n        forceCatalogUpdate();\n        addCatalogItems(getLocalResource(\"more-entity-v1-osgi-catalog.yaml\"));\n        Entity app = createAndStartApplication(\"services: [ { type: 'more-entity:1.0' } ]\");\n        Entity moreEntity = Iterables.getOnlyElement(app.getChildren());\n        OsgiVersionMoreEntityTest.assertV1EffectorCall(moreEntity);\n        OsgiVersionMoreEntityTest.assertV1MethodCall(moreEntity);\n    }","cleancode":"@test public void testmoreentityv2thenv1givesv1() throws exception { testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.1.0.jar\"); testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-more-entities_0.2.0.jar\"); testresourceunavailableexception.throwifresourceunavailable(getclass(), \"\/brooklyn\/osgi\/brooklyn-test-osgi-entities.jar\"); addcatalogitems(getlocalresource(\"more-entity-v2-osgi-catalog.yaml\")); forcecatalogupdate(); addcatalogitems(getlocalresource(\"more-entity-v1-osgi-catalog.yaml\")); entity app = createandstartapplication(\"services: [ { type: 'more-entity:1.0' } ]\"); entity moreentity = iterables.getonlyelement(app.getchildren()); osgiversionmoreentitytest.assertv1effectorcall(moreentity); osgiversionmoreentitytest.assertv1methodcall(moreentity); }","repo":"kiuby88\/incubator-brooklyn","label":[0,0,1,0]}
{"id":10580,"original_code":"public synchronized boolean markTaskCompleted (int taskId) {\n        Job job = getJobForTask(taskId);\n        if (job == null) {\n            LOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\n            return false;\n        }\n        job.completedTasks.add(taskId);\n        return true;\n    }","code_wo_comment":"public synchronized boolean markTaskCompleted (int taskId) {\n        Job job = getJobForTask(taskId);\n        if (job == null) {\n            LOG.error(\"Could not find a job containing task {}, and therefore could not mark the task as completed.\", taskId);\n            return false;\n        }\n        job.completedTasks.add(taskId);\n        return true;\n    }","cleancode":"public synchronized boolean marktaskcompleted (int taskid) { job job = getjobfortask(taskid); if (job == null) { log.error(\"could not find a job containing task {}, and therefore could not mark the task as completed.\", taskid); return false; } job.completedtasks.add(taskid); return true; }","repo":"mcheung610\/r5","label":[1,0,0,0]}
{"id":10625,"original_code":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\n\t\t\t\t\t\t\t\tTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n\t{\n\t\tfinal PlanNode inputPlanNode = input.getSource();\n\t\tfinal Iterator<Channel> allInChannels;\n\t\tallInChannels = Collections.singletonList(input).iterator();\n\t\t\/\/ check that the type serializer is consistent\n\t\tTypeSerializerFactory<?> typeSerFact = null;\n\t\twhile (allInChannels.hasNext()) {\n\t\t\tfinal Channel inConn = allInChannels.next();\n\t\t\tif (typeSerFact == null) {\n\t\t\t\ttypeSerFact = inConn.getSerializer();\n\t\t\t} else if (!typeSerFact.equals(inConn.getSerializer())) {\n\t\t\t\tthrow new CompilerException(\"Conflicting types in union operator.\");\n\t\t\t}\n\t\t\tfinal PlanNode sourceNode = inConn.getSource();\n\t\t\tFlinkVertex sourceVertex = this.vertices.get(sourceNode);\n\t\t\tTezTaskConfig sourceVertexConfig = sourceVertex.getConfig(); \/\/TODO ??? need to create a new TezConfig ???\n\t\t\tconnectJobVertices(\n\t\t\t\t\tinConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n\t\t}\n\t\t\/\/ the local strategy is added only once. in non-union case that is the actual edge,\n\t\t\/\/ in the union case, it is the edge between union and the target node\n\t\taddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\n\t\treturn 1;\n\t}","code_wo_comment":"private int translateChannel(Channel input, int inputIndex, FlinkVertex targetVertex,\n\t\t\t\t\t\t\t\tTezTaskConfig targetVertexConfig, boolean isBroadcast) throws Exception\n\t{\n\t\tfinal PlanNode inputPlanNode = input.getSource();\n\t\tfinal Iterator<Channel> allInChannels;\n\t\tallInChannels = Collections.singletonList(input).iterator();\n\t\n\t\tTypeSerializerFactory<?> typeSerFact = null;\n\t\twhile (allInChannels.hasNext()) {\n\t\t\tfinal Channel inConn = allInChannels.next();\n\t\t\tif (typeSerFact == null) {\n\t\t\t\ttypeSerFact = inConn.getSerializer();\n\t\t\t} else if (!typeSerFact.equals(inConn.getSerializer())) {\n\t\t\t\tthrow new CompilerException(\"Conflicting types in union operator.\");\n\t\t\t}\n\t\t\tfinal PlanNode sourceNode = inConn.getSource();\n\t\t\tFlinkVertex sourceVertex = this.vertices.get(sourceNode);\n\t\t\tTezTaskConfig sourceVertexConfig = sourceVertex.getConfig();\n\t\t\tconnectJobVertices(\n\t\t\t\t\tinConn, inputIndex, sourceVertex, sourceVertexConfig, targetVertex, targetVertexConfig, isBroadcast);\n\t\t}\n\t\n\t\n\t\taddLocalInfoFromChannelToConfig(input, targetVertexConfig, inputIndex, isBroadcast);\n\t\treturn 1;\n\t}","cleancode":"private int translatechannel(channel input, int inputindex, flinkvertex targetvertex, teztaskconfig targetvertexconfig, boolean isbroadcast) throws exception { final plannode inputplannode = input.getsource(); final iterator<channel> allinchannels; allinchannels = collections.singletonlist(input).iterator(); typeserializerfactory<?> typeserfact = null; while (allinchannels.hasnext()) { final channel inconn = allinchannels.next(); if (typeserfact == null) { typeserfact = inconn.getserializer(); } else if (!typeserfact.equals(inconn.getserializer())) { throw new compilerexception(\"conflicting types in union operator.\"); } final plannode sourcenode = inconn.getsource(); flinkvertex sourcevertex = this.vertices.get(sourcenode); teztaskconfig sourcevertexconfig = sourcevertex.getconfig(); connectjobvertices( inconn, inputindex, sourcevertex, sourcevertexconfig, targetvertex, targetvertexconfig, isbroadcast); } addlocalinfofromchanneltoconfig(input, targetvertexconfig, inputindex, isbroadcast); return 1; }","repo":"ljzzju\/incubator-flink","label":[1,0,0,0]}
{"id":10626,"original_code":"private void connectJobVertices(Channel channel, int inputNumber,\n\t\t\t\t\t\t\tfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\n\t\t\t\t\t\t\tfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\n\t\t\tthrows CompilerException {\n\t\t\/\/ -------------- configure the source task's ship strategy strategies in task config --------------\n\t\tfinal int outputIndex = sourceConfig.getNumOutputs();\n\t\tsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\n\t\tif (outputIndex == 0) {\n\t\t\tsourceConfig.setOutputSerializer(channel.getSerializer());\n\t\t}\n\t\tif (channel.getShipStrategyComparator() != null) {\n\t\t\tsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n\t\t}\n\t\tif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\n\t\t\tfinal DataDistribution dataDistribution = channel.getDataDistribution();\n\t\t\tif(dataDistribution != null) {\n\t\t\t\tsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\t\t\t\t\/\/ TODO: inject code and configuration for automatic histogram generation\n\t\t\t}\n\t\t}\n\t\t\/\/ ---------------- configure the receiver -------------------\n\t\tif (isBroadcast) {\n\t\t\ttargetConfig.addBroadcastInputToGroup(inputNumber);\n\t\t} else {\n\t\t\ttargetConfig.addInputToGroup(inputNumber);\n\t\t}\n\t\t\/\/----------------- connect source and target with edge ------------------------------\n\t\tFlinkEdge edge;\n\t\tShipStrategyType shipStrategy = channel.getShipStrategy();\n\t\tTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\n\t\tif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\n\t\t\tedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\t\t\t\/\/ For forward edges, create as many tasks in upstream operator as in source operator\n\t\t\ttargetVertex.setParallelism(sourceVertex.getParallelism());\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.BROADCAST) {\n\t\t\tedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\n\t\t\tedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse {\n\t\t\tthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n\t\t}\n\t\t\/\/ Tez-specific bookkeeping\n\t\t\/\/ TODO: This probably will not work for vertices with multiple outputs\n\t\tsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\n\t\ttargetVertex.addInput(sourceVertex, inputNumber);\n\t\tedges.add(edge);\n\t}","code_wo_comment":"private void connectJobVertices(Channel channel, int inputNumber,\n\t\t\t\t\t\t\tfinal FlinkVertex sourceVertex, final TezTaskConfig sourceConfig,\n\t\t\t\t\t\t\tfinal FlinkVertex targetVertex, final TezTaskConfig targetConfig, boolean isBroadcast)\n\t\t\tthrows CompilerException {\n\t\n\t\tfinal int outputIndex = sourceConfig.getNumOutputs();\n\t\tsourceConfig.addOutputShipStrategy(channel.getShipStrategy());\n\t\tif (outputIndex == 0) {\n\t\t\tsourceConfig.setOutputSerializer(channel.getSerializer());\n\t\t}\n\t\tif (channel.getShipStrategyComparator() != null) {\n\t\t\tsourceConfig.setOutputComparator(channel.getShipStrategyComparator(), outputIndex);\n\t\t}\n\t\tif (channel.getShipStrategy() == ShipStrategyType.PARTITION_RANGE) {\n\t\t\tfinal DataDistribution dataDistribution = channel.getDataDistribution();\n\t\t\tif(dataDistribution != null) {\n\t\t\t\tsourceConfig.setOutputDataDistribution(dataDistribution, outputIndex);\n\t\t\t} else {\n\t\t\t\tthrow new RuntimeException(\"Range partitioning requires data distribution\");\n\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t\tif (isBroadcast) {\n\t\t\ttargetConfig.addBroadcastInputToGroup(inputNumber);\n\t\t} else {\n\t\t\ttargetConfig.addInputToGroup(inputNumber);\n\t\t}\n\t\n\t\tFlinkEdge edge;\n\t\tShipStrategyType shipStrategy = channel.getShipStrategy();\n\t\tTypeSerializer<?> serializer = channel.getSerializer().getSerializer();\n\t\tif ((shipStrategy == ShipStrategyType.FORWARD) || (shipStrategy == ShipStrategyType.NONE)) {\n\t\t\tedge = new FlinkForwardEdge(sourceVertex, targetVertex, serializer);\n\t\t\n\t\t\ttargetVertex.setParallelism(sourceVertex.getParallelism());\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.BROADCAST) {\n\t\t\tedge = new FlinkBroadcastEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse if (shipStrategy == ShipStrategyType.PARTITION_HASH) {\n\t\t\tedge = new FlinkPartitionEdge(sourceVertex, targetVertex, serializer);\n\t\t}\n\t\telse {\n\t\t\tthrow new CompilerException(\"Ship strategy between nodes \" + sourceVertex.getVertex().getName() + \" and \" + targetVertex.getVertex().getName() + \" currently not supported\");\n\t\t}\n\t\n\t\n\t\tsourceVertex.addNumberOfSubTasksInOutput(targetVertex.getParallelism(), outputIndex);\n\t\ttargetVertex.addInput(sourceVertex, inputNumber);\n\t\tedges.add(edge);\n\t}","cleancode":"private void connectjobvertices(channel channel, int inputnumber, final flinkvertex sourcevertex, final teztaskconfig sourceconfig, final flinkvertex targetvertex, final teztaskconfig targetconfig, boolean isbroadcast) throws compilerexception { final int outputindex = sourceconfig.getnumoutputs(); sourceconfig.addoutputshipstrategy(channel.getshipstrategy()); if (outputindex == 0) { sourceconfig.setoutputserializer(channel.getserializer()); } if (channel.getshipstrategycomparator() != null) { sourceconfig.setoutputcomparator(channel.getshipstrategycomparator(), outputindex); } if (channel.getshipstrategy() == shipstrategytype.partition_range) { final datadistribution datadistribution = channel.getdatadistribution(); if(datadistribution != null) { sourceconfig.setoutputdatadistribution(datadistribution, outputindex); } else { throw new runtimeexception(\"range partitioning requires data distribution\"); } } if (isbroadcast) { targetconfig.addbroadcastinputtogroup(inputnumber); } else { targetconfig.addinputtogroup(inputnumber); } flinkedge edge; shipstrategytype shipstrategy = channel.getshipstrategy(); typeserializer<?> serializer = channel.getserializer().getserializer(); if ((shipstrategy == shipstrategytype.forward) || (shipstrategy == shipstrategytype.none)) { edge = new flinkforwardedge(sourcevertex, targetvertex, serializer); targetvertex.setparallelism(sourcevertex.getparallelism()); } else if (shipstrategy == shipstrategytype.broadcast) { edge = new flinkbroadcastedge(sourcevertex, targetvertex, serializer); } else if (shipstrategy == shipstrategytype.partition_hash) { edge = new flinkpartitionedge(sourcevertex, targetvertex, serializer); } else { throw new compilerexception(\"ship strategy between nodes \" + sourcevertex.getvertex().getname() + \" and \" + targetvertex.getvertex().getname() + \" currently not supported\"); } sourcevertex.addnumberofsubtasksinoutput(targetvertex.getparallelism(), outputindex); targetvertex.addinput(sourcevertex, inputnumber); edges.add(edge); }","repo":"ljzzju\/incubator-flink","label":[1,1,0,0]}
{"id":10732,"original_code":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\n    public static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\n        Char chr = c.getChr();\n        if (inPacket.getUnreadAmount() == 0) {\n            \/\/ Coming back from the cash shop\n\/\/            chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getFieldID()));\n            c.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\n            c.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\n            return;\n    }\n        byte fieldKey = inPacket.decodeByte();\n        int targetField = inPacket.decodeInt();\n        if (targetField == 106020100 || targetField == 106020400) {\n            \/\/ same issue as below, its in mushroom kingdom so maybe the maps are just outdated or w\/e\n            targetField = 106020403;\n        } else if (targetField == 106020402) {\n            \/\/ warping from portal in 106020403 is unable to find defined portal (not a scripted portal)\n            targetField = 106020000;\n        }\n        int x = inPacket.decodeShort();\n        int y = inPacket.decodeShort();\n        String portalName = inPacket.decodeString();\n        if (portalName != null && !\"\".equals(portalName)) {\n            Field field = chr.getField();\n            Portal portal = field.getPortalByName(portalName);\n            if (portal.getScript() != null && !portal.getScript().equals(\"\")) {\n                chr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n            } else {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\n                if (toField == null) {\n                    return;\n                }\n                Portal toPortal = toField.getPortalByName(portal.getTargetPortalName());\n                if (toPortal == null) {\n                    toPortal = toField.getPortalByName(\"sp\");\n                }\n                chr.warp(toField, toPortal);\n            }\n        } else if (chr.getHP() <= 0) {\n            if (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\n                InGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\n                chr.heal(chr.getMaxHP());\n                chr.healMP(chr.getMaxMP());\n                return;\n            }\n            \/\/ Character is dead, respawn request\n            inPacket.decodeByte(); \/\/ always 0\n            byte tarfield = inPacket.decodeByte(); \/\/ ?\n            byte reviveType = inPacket.decodeByte();\n            int returnMap = chr.getField().getReturnMap() == 999999999\n                    ? chr.getPreviousFieldID()\n                    : chr.getField().getReturnMap();\n            switch (reviveType) {\n                \/\/ so far only got 0?\n            }\n            if (!chr.hasBuffProtector()) {\n                chr.getTemporaryStatManager().removeAllStats();\n            }\n            int deathcount = chr.getDeathCount();\n            if (deathcount != 0) {\n                if (deathcount > 0) {\n                    deathcount--;\n                    chr.setDeathCount(deathcount);\n                    chr.write(UserLocal.deathCountInfo(deathcount));\n                }\n                chr.setNearestReturnPortal(); \/\/ attempt to respawn them where they died.. maybe portal 0 is better tho?\n                chr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\n                chr.healHPMP();\n                return;\n            } else if (chr.getInstance() != null) {\n                chr.getInstance().removeChar(chr);\n            } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n                if (toField != null && chr.getTransferField() > 0) {\n                    chr.warp(toField);\n                }\n                chr.setTransferField(0);\n                return;\n            } else {\n                chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getField().getForcedReturn()));\n            }\n            chr.healHPMP();\n            chr.setBuffProtector(false);\n        } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n            Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n            if (toField != null && chr.getTransferField() > 0) {\n                chr.warp(toField);\n            }\n            chr.setTransferField(0);\n        }\n    }","code_wo_comment":"@Handler(op = InHeader.USER_TRANSFER_FIELD_REQUEST)\n    public static void handleUserTransferFieldRequest(Client c, InPacket inPacket) {\n        Char chr = c.getChr();\n        if (inPacket.getUnreadAmount() == 0) {\n           \n            c.getChannelInstance().addClientInTransfer(c.getChannel(), chr.getId(), c);\n            c.write(ClientSocket.migrateCommand(true, (short) c.getChannelInstance().getPort()));\n            return;\n    }\n        byte fieldKey = inPacket.decodeByte();\n        int targetField = inPacket.decodeInt();\n        if (targetField == 106020100 || targetField == 106020400) {\n           \n            targetField = 106020403;\n        } else if (targetField == 106020402) {\n           \n            targetField = 106020000;\n        }\n        int x = inPacket.decodeShort();\n        int y = inPacket.decodeShort();\n        String portalName = inPacket.decodeString();\n        if (portalName != null && !\"\".equals(portalName)) {\n            Field field = chr.getField();\n            Portal portal = field.getPortalByName(portalName);\n            if (portal.getScript() != null && !portal.getScript().equals(\"\")) {\n                chr.getScriptManager().startScript(portal.getId(), portal.getScript(), ScriptType.Portal);\n            } else {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(portal.getTargetMapId());\n                if (toField == null) {\n                    return;\n                }\n                Portal toPortal = toField.getPortalByName(portal.getTargetPortalName());\n                if (toPortal == null) {\n                    toPortal = toField.getPortalByName(\"sp\");\n                }\n                chr.warp(toField, toPortal);\n            }\n        } else if (chr.getHP() <= 0) {\n            if (InGameEventManager.getInstance().charInEventMap(chr.getId())) {\n                InGameEventManager.getInstance().getActiveEvent().onMigrateDeath(chr);\n                chr.heal(chr.getMaxHP());\n                chr.healMP(chr.getMaxMP());\n                return;\n            }\n           \n            inPacket.decodeByte();\n            byte tarfield = inPacket.decodeByte();\n            byte reviveType = inPacket.decodeByte();\n            int returnMap = chr.getField().getReturnMap() == 999999999\n                    ? chr.getPreviousFieldID()\n                    : chr.getField().getReturnMap();\n            switch (reviveType) {\n               \n            }\n            if (!chr.hasBuffProtector()) {\n                chr.getTemporaryStatManager().removeAllStats();\n            }\n            int deathcount = chr.getDeathCount();\n            if (deathcount != 0) {\n                if (deathcount > 0) {\n                    deathcount--;\n                    chr.setDeathCount(deathcount);\n                    chr.write(UserLocal.deathCountInfo(deathcount));\n                }\n                chr.setNearestReturnPortal();\n                chr.warp(chr.getFieldID(), chr.getPreviousPortalID(), false);\n                chr.healHPMP();\n                return;\n            } else if (chr.getInstance() != null) {\n                chr.getInstance().removeChar(chr);\n            } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n                Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n                if (toField != null && chr.getTransferField() > 0) {\n                    chr.warp(toField);\n                }\n                chr.setTransferField(0);\n                return;\n            } else {\n                chr.warp(chr.getOrCreateFieldByCurrentInstanceType(chr.getField().getForcedReturn()));\n            }\n            chr.healHPMP();\n            chr.setBuffProtector(false);\n        } else if (chr.getTransferField() == targetField && chr.getTransferFieldReq() == chr.getField().getId()) {\n            Field toField = chr.getOrCreateFieldByCurrentInstanceType(chr.getTransferField());\n            if (toField != null && chr.getTransferField() > 0) {\n                chr.warp(toField);\n            }\n            chr.setTransferField(0);\n        }\n    }","cleancode":"@handler(op = inheader.user_transfer_field_request) public static void handleusertransferfieldrequest(client c, inpacket inpacket) { char chr = c.getchr(); if (inpacket.getunreadamount() == 0) { c.getchannelinstance().addclientintransfer(c.getchannel(), chr.getid(), c); c.write(clientsocket.migratecommand(true, (short) c.getchannelinstance().getport())); return; } byte fieldkey = inpacket.decodebyte(); int targetfield = inpacket.decodeint(); if (targetfield == 106020100 || targetfield == 106020400) { targetfield = 106020403; } else if (targetfield == 106020402) { targetfield = 106020000; } int x = inpacket.decodeshort(); int y = inpacket.decodeshort(); string portalname = inpacket.decodestring(); if (portalname != null && !\"\".equals(portalname)) { field field = chr.getfield(); portal portal = field.getportalbyname(portalname); if (portal.getscript() != null && !portal.getscript().equals(\"\")) { chr.getscriptmanager().startscript(portal.getid(), portal.getscript(), scripttype.portal); } else { field tofield = chr.getorcreatefieldbycurrentinstancetype(portal.gettargetmapid()); if (tofield == null) { return; } portal toportal = tofield.getportalbyname(portal.gettargetportalname()); if (toportal == null) { toportal = tofield.getportalbyname(\"sp\"); } chr.warp(tofield, toportal); } } else if (chr.gethp() <= 0) { if (ingameeventmanager.getinstance().charineventmap(chr.getid())) { ingameeventmanager.getinstance().getactiveevent().onmigratedeath(chr); chr.heal(chr.getmaxhp()); chr.healmp(chr.getmaxmp()); return; } inpacket.decodebyte(); byte tarfield = inpacket.decodebyte(); byte revivetype = inpacket.decodebyte(); int returnmap = chr.getfield().getreturnmap() == 999999999 ? chr.getpreviousfieldid() : chr.getfield().getreturnmap(); switch (revivetype) { } if (!chr.hasbuffprotector()) { chr.gettemporarystatmanager().removeallstats(); } int deathcount = chr.getdeathcount(); if (deathcount != 0) { if (deathcount > 0) { deathcount--; chr.setdeathcount(deathcount); chr.write(userlocal.deathcountinfo(deathcount)); } chr.setnearestreturnportal(); chr.warp(chr.getfieldid(), chr.getpreviousportalid(), false); chr.healhpmp(); return; } else if (chr.getinstance() != null) { chr.getinstance().removechar(chr); } else if (chr.gettransferfield() == targetfield && chr.gettransferfieldreq() == chr.getfield().getid()) { field tofield = chr.getorcreatefieldbycurrentinstancetype(chr.gettransferfield()); if (tofield != null && chr.gettransferfield() > 0) { chr.warp(tofield); } chr.settransferfield(0); return; } else { chr.warp(chr.getorcreatefieldbycurrentinstancetype(chr.getfield().getforcedreturn())); } chr.healhpmp(); chr.setbuffprotector(false); } else if (chr.gettransferfield() == targetfield && chr.gettransferfieldreq() == chr.getfield().getid()) { field tofield = chr.getorcreatefieldbycurrentinstancetype(chr.gettransferfield()); if (tofield != null && chr.gettransferfield() > 0) { chr.warp(tofield); } chr.settransferfield(0); } }","repo":"lynsone\/swordie","label":[1,0,1,0]}
{"id":18957,"original_code":"private <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\n      Connection connection,\n      String logMessageName, T obj) throws FatalErrorHalt, AbortRound {\n    byte[] data = null;\n    data = agent.serialize(obj);\n    logJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\n    byte[] lengthBytes = serializeInteger(data.length);\n    try {\n      connection.getOutputStream().write(lengthBytes);\n      connection.getOutputStream().write(data);\n    } catch (SocketException se) {\n      \/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n      \/\/ handleError(GOSSIP_IO_ERROR, se);\n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    } catch (IOException e) {\n      \/\/ FIXME: check that handleError is aborting on GOSSIP_IO_ERROR\n      \/\/ handleError(GOSSIP_IO_ERROR, e);\n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    }\n  }","code_wo_comment":"private <T extends Serializable> void sendObject(CommunicationPatternAgent agent,\n      Connection connection,\n      String logMessageName, T obj) throws FatalErrorHalt, AbortRound {\n    byte[] data = null;\n    data = agent.serialize(obj);\n    logJson(LogFlag.serialization, \"mica-serialize-bytes-\" + logMessageName, data.length);\n    byte[] lengthBytes = serializeInteger(data.length);\n    try {\n      connection.getOutputStream().write(lengthBytes);\n      connection.getOutputStream().write(data);\n    } catch (SocketException se) {\n     \n     \n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    } catch (IOException e) {\n     \n     \n      handleError(GOSSIP_IO_ERROR, new AbortRound());\n    }\n  }","cleancode":"private <t extends serializable> void sendobject(communicationpatternagent agent, connection connection, string logmessagename, t obj) throws fatalerrorhalt, abortround { byte[] data = null; data = agent.serialize(obj); logjson(logflag.serialization, \"mica-serialize-bytes-\" + logmessagename, data.length); byte[] lengthbytes = serializeinteger(data.length); try { connection.getoutputstream().write(lengthbytes); connection.getoutputstream().write(data); } catch (socketexception se) { handleerror(gossip_io_error, new abortround()); } catch (ioexception e) { handleerror(gossip_io_error, new abortround()); } }","repo":"mica-gossip\/MiCA","label":[0,0,1,0]}
{"id":2602,"original_code":"@Test\n  public void testUnionType() throws Exception {\n    String sql =\"SELECT typeof(a) AS t, modeof(a) AS m, drilltypeof(a) AS dt\\n\" +\n                \"FROM cp.`jsoninput\/union\/c.json`\";\n    try {\n      testBuilder()\n        .optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n        .sqlQuery(sql)\n        .ordered()\n        .baselineColumns(\"t\",       \"m\",        \"dt\")\n        .baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n        .baselineValues( \"BIGINT\",  \"NULLABLE\", \"UNION\")\n        .baselineValues( \"FLOAT8\",  \"NULLABLE\", \"UNION\")\n        \/\/ The following should probably provide the type of the list,\n        \/\/ and report cardinality as ARRAY.\n        .baselineValues( \"LIST\",    \"NULLABLE\", \"UNION\")\n        .baselineValues( \"NULL\",    \"NULLABLE\", \"UNION\")\n        .go();\n    }\n    finally {\n      client.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n    }\n  }","code_wo_comment":"@Test\n  public void testUnionType() throws Exception {\n    String sql =\"SELECT typeof(a) AS t, modeof(a) AS m, drilltypeof(a) AS dt\\n\" +\n                \"FROM cp.`jsoninput\/union\/c.json`\";\n    try {\n      testBuilder()\n        .optionSettingQueriesForTestQuery(\"alter session set `exec.enable_union_type` = true\")\n        .sqlQuery(sql)\n        .ordered()\n        .baselineColumns(\"t\",       \"m\",        \"dt\")\n        .baselineValues( \"VARCHAR\", \"NULLABLE\", \"UNION\")\n        .baselineValues( \"BIGINT\",  \"NULLABLE\", \"UNION\")\n        .baselineValues( \"FLOAT8\",  \"NULLABLE\", \"UNION\")\n       \n       \n        .baselineValues( \"LIST\",    \"NULLABLE\", \"UNION\")\n        .baselineValues( \"NULL\",    \"NULLABLE\", \"UNION\")\n        .go();\n    }\n    finally {\n      client.resetSession(ExecConstants.ENABLE_UNION_TYPE_KEY);\n    }\n  }","cleancode":"@test public void testuniontype() throws exception { string sql =\"select typeof(a) as t, modeof(a) as m, drilltypeof(a) as dt\\n\" + \"from cp.`jsoninput\/union\/c.json`\"; try { testbuilder() .optionsettingqueriesfortestquery(\"alter session set `exec.enable_union_type` = true\") .sqlquery(sql) .ordered() .baselinecolumns(\"t\", \"m\", \"dt\") .baselinevalues( \"varchar\", \"nullable\", \"union\") .baselinevalues( \"bigint\", \"nullable\", \"union\") .baselinevalues( \"float8\", \"nullable\", \"union\") .baselinevalues( \"list\", \"nullable\", \"union\") .baselinevalues( \"null\", \"nullable\", \"union\") .go(); } finally { client.resetsession(execconstants.enable_union_type_key); } }","repo":"julien-faye\/drill","label":[1,0,0,0]}
{"id":10862,"original_code":"@Test\n    public void test20046() throws Throwable {\n        if (debug)\n            System.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\n        org.jsoup.helper.HttpConnection.Response response0 = null;\n        org.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\n        org.jsoup.Connection.Request request2 = null;\n        response1.req = request2;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\n        response1.charset = \"hi!\";\n        int int8 = response1.numRedirects;\n        response1.contentType = \"hi!\";\n        java.nio.ByteBuffer byteBuffer11 = response1.byteData;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\n        response1.numRedirects = (short) 10;\n        response1.contentType = \"\";\n        boolean boolean19 = response1.hasCookie(\"hi!\");\n        java.lang.String str20 = response1.statusMessage();\n        int int21 = response1.statusCode();\n        \/\/ The following exception was thrown during execution in test generation\n        try {\n            org.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n\/\/ flaky:             org.junit.Assert.fail(\"Expected exception of type java.io.IOException; message: Too many redirects occurred trying to load URL null\");\n        } catch (java.io.IOException e) {\n        \/\/ Expected exception.\n        }\n        org.junit.Assert.assertNull(strEntry5);\n        org.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\n        org.junit.Assert.assertNull(byteBuffer11);\n        org.junit.Assert.assertNull(strEntry13);\n        org.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\n        org.junit.Assert.assertNull(str20);\n        org.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n    }","code_wo_comment":"@Test\n    public void test20046() throws Throwable {\n        if (debug)\n            System.out.format(\"%n%s%n\", \"RegressionTest40.test20046\");\n        org.jsoup.helper.HttpConnection.Response response0 = null;\n        org.jsoup.helper.HttpConnection.Response response1 = new org.jsoup.helper.HttpConnection.Response(response0);\n        org.jsoup.Connection.Request request2 = null;\n        response1.req = request2;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry5 = response1.scanHeaders(\"hi!\");\n        response1.charset = \"hi!\";\n        int int8 = response1.numRedirects;\n        response1.contentType = \"hi!\";\n        java.nio.ByteBuffer byteBuffer11 = response1.byteData;\n        java.util.Map.Entry<java.lang.String, java.lang.String> strEntry13 = response1.scanHeaders(\"\");\n        response1.numRedirects = (short) 10;\n        response1.contentType = \"\";\n        boolean boolean19 = response1.hasCookie(\"hi!\");\n        java.lang.String str20 = response1.statusMessage();\n        int int21 = response1.statusCode();\n       \n        try {\n            org.jsoup.helper.HttpConnection.Response response22 = new org.jsoup.helper.HttpConnection.Response(response1);\n        } catch (java.io.IOException e) {\n       \n        }\n        org.junit.Assert.assertNull(strEntry5);\n        org.junit.Assert.assertTrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0);\n        org.junit.Assert.assertNull(byteBuffer11);\n        org.junit.Assert.assertNull(strEntry13);\n        org.junit.Assert.assertTrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false);\n        org.junit.Assert.assertNull(str20);\n        org.junit.Assert.assertTrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0);\n    }","cleancode":"@test public void test20046() throws throwable { if (debug) system.out.format(\"%n%s%n\", \"regressiontest40.test20046\"); org.jsoup.helper.httpconnection.response response0 = null; org.jsoup.helper.httpconnection.response response1 = new org.jsoup.helper.httpconnection.response(response0); org.jsoup.connection.request request2 = null; response1.req = request2; java.util.map.entry<java.lang.string, java.lang.string> strentry5 = response1.scanheaders(\"hi!\"); response1.charset = \"hi!\"; int int8 = response1.numredirects; response1.contenttype = \"hi!\"; java.nio.bytebuffer bytebuffer11 = response1.bytedata; java.util.map.entry<java.lang.string, java.lang.string> strentry13 = response1.scanheaders(\"\"); response1.numredirects = (short) 10; response1.contenttype = \"\"; boolean boolean19 = response1.hascookie(\"hi!\"); java.lang.string str20 = response1.statusmessage(); int int21 = response1.statuscode(); try { org.jsoup.helper.httpconnection.response response22 = new org.jsoup.helper.httpconnection.response(response1); } catch (java.io.ioexception e) { } org.junit.assert.assertnull(strentry5); org.junit.assert.asserttrue(\"'\" + int8 + \"' != '\" + 0 + \"'\", int8 == 0); org.junit.assert.assertnull(bytebuffer11); org.junit.assert.assertnull(strentry13); org.junit.assert.asserttrue(\"'\" + boolean19 + \"' != '\" + false + \"'\", boolean19 == false); org.junit.assert.assertnull(str20); org.junit.assert.asserttrue(\"'\" + int21 + \"' != '\" + 0 + \"'\", int21 == 0); }","repo":"leusonmario\/2022PhDThesis","label":[0,0,1,0]}
{"id":10871,"original_code":"private void checkNullable() {\n      if (ConfigurationAnnotations.getNullableType(element).isPresent()) {\n        report.addWarning(\"@Nullable on @Produces methods does not do anything\");\n      }\n    }","code_wo_comment":"private void checkNullable() {\n      if (ConfigurationAnnotations.getNullableType(element).isPresent()) {\n        report.addWarning(\"@Nullable on @Produces methods does not do anything\");\n      }\n    }","cleancode":"private void checknullable() { if (configurationannotations.getnullabletype(element).ispresent()) { report.addwarning(\"@nullable on @produces methods does not do anything\"); } }","repo":"lynnfield\/dagger","label":[0,1,0,0]}
{"id":19094,"original_code":"private IMRIValueListener createValueListener() {\n\t\treturn new IMRIValueListener() {\n\t\t\t@Override\n\t\t\tpublic void valueChanged(MRIValueEvent event) {\n\t\t\t\tif (event.getValue() instanceof CompositeData) {\n\t\t\t\t\t\/\/ FIXME: change to a better test of containment?\n\t\t\t\t\tdispose();\n\t\t\t\t\tm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","code_wo_comment":"private IMRIValueListener createValueListener() {\n\t\treturn new IMRIValueListener() {\n\t\t\t@Override\n\t\t\tpublic void valueChanged(MRIValueEvent event) {\n\t\t\t\tif (event.getValue() instanceof CompositeData) {\n\t\t\t\t\n\t\t\t\t\tdispose();\n\t\t\t\t\tm_repository.movePossibleChildSubscriptions(UnavailableChildSubscriptions.this);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}","cleancode":"private imrivaluelistener createvaluelistener() { return new imrivaluelistener() { @override public void valuechanged(mrivalueevent event) { if (event.getvalue() instanceof compositedata) { dispose(); m_repository.movepossiblechildsubscriptions(unavailablechildsubscriptions.this); } } }; }","repo":"meghasfdc\/jmc","label":[1,0,0,0]}
{"id":19169,"original_code":"private boolean ruleMatches(String text, String pattern) {\n        int patternPos = 0;\n        int textPos = 0;\n        int patternEnd = pattern.length();\n        int textEnd = text.length();\n        boolean containsEndChar = pattern.endsWith(\"$\");\n        if (containsEndChar) {\n            patternEnd -= 1;\n        }\n        while ((patternPos < patternEnd) && (textPos < textEnd)) {\n            \/\/ Find next wildcard in the pattern.\n            int wildcardPos = pattern.indexOf('*', patternPos);\n            if (wildcardPos == -1) {\n                wildcardPos = patternEnd;\n            }\n            \/\/ If we're at a wildcard in the pattern, find the place in the text\n            \/\/ where the character(s) after the wildcard match up with what's in\n            \/\/ the text.\n            if (wildcardPos == patternPos) {\n                patternPos += 1;\n                if (patternPos >= patternEnd) {\n                    \/\/ Pattern ends with '*', we're all good.\n                    return true;\n                }\n                \/\/ TODO - don't worry about having two '*' in a row?\n                \/\/ Find the end of the pattern piece we need to match.\n                int patternPieceEnd = pattern.indexOf('*', patternPos);\n                if (patternPieceEnd == -1) {\n                    patternPieceEnd = patternEnd;\n                }\n                boolean matched = false;\n                int patternPieceLen = patternPieceEnd - patternPos;\n                while ((textPos + patternPieceLen <= textEnd) && !matched) {\n                    \/\/ See if patternPieceLen chars from text at textPos match\n                    \/\/ chars from pattern at patternPos\n                    matched = true;\n                    for (int i = 0; i < patternPieceLen && matched; i++) {\n                        if (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\n                            matched = false;\n                        }\n                    }\n                    \/\/ If we matched, we're all set, otherwise we have to\n                    \/\/ advance textPos\n                    if (!matched) {\n                        textPos += 1;\n                    }\n                }\n                \/\/ If we matched, we're all set, otherwise we failed\n                if (!matched) {\n                    return false;\n                }\n            } else {\n                \/\/ See if the pattern from patternPos to wildcardPos matches the\n                \/\/ text starting at textPos\n                while ((patternPos < wildcardPos) && (textPos < textEnd)) {\n                    if (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \/\/ If we didn't reach the end of the pattern, make sure we're not at a\n        \/\/ wildcard, that's a 0 or more match, so then we're still OK.\n        while ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\n            patternPos += 1;\n        }\n        \/\/ We're at the end, so we have a match if the pattern was completely\n        \/\/ consumed, and either we consumed all the text or we didn't have to\n        \/\/ match it all (no '$' at end of the pattern)\n        return (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n    }","code_wo_comment":"private boolean ruleMatches(String text, String pattern) {\n        int patternPos = 0;\n        int textPos = 0;\n        int patternEnd = pattern.length();\n        int textEnd = text.length();\n        boolean containsEndChar = pattern.endsWith(\"$\");\n        if (containsEndChar) {\n            patternEnd -= 1;\n        }\n        while ((patternPos < patternEnd) && (textPos < textEnd)) {\n           \n            int wildcardPos = pattern.indexOf('*', patternPos);\n            if (wildcardPos == -1) {\n                wildcardPos = patternEnd;\n            }\n           \n           \n           \n            if (wildcardPos == patternPos) {\n                patternPos += 1;\n                if (patternPos >= patternEnd) {\n                   \n                    return true;\n                }\n               \n               \n                int patternPieceEnd = pattern.indexOf('*', patternPos);\n                if (patternPieceEnd == -1) {\n                    patternPieceEnd = patternEnd;\n                }\n                boolean matched = false;\n                int patternPieceLen = patternPieceEnd - patternPos;\n                while ((textPos + patternPieceLen <= textEnd) && !matched) {\n                   \n                   \n                    matched = true;\n                    for (int i = 0; i < patternPieceLen && matched; i++) {\n                        if (text.charAt(textPos + i) != pattern.charAt(patternPos + i)) {\n                            matched = false;\n                        }\n                    }\n                   \n                   \n                    if (!matched) {\n                        textPos += 1;\n                    }\n                }\n               \n                if (!matched) {\n                    return false;\n                }\n            } else {\n               \n               \n                while ((patternPos < wildcardPos) && (textPos < textEnd)) {\n                    if (text.charAt(textPos++) != pattern.charAt(patternPos++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n       \n       \n        while ((patternPos < patternEnd) && (pattern.charAt(patternPos) == '*')) {\n            patternPos += 1;\n        }\n       \n       \n       \n        return (patternPos == patternEnd) && ((textPos == textEnd) || !containsEndChar);\n    }","cleancode":"private boolean rulematches(string text, string pattern) { int patternpos = 0; int textpos = 0; int patternend = pattern.length(); int textend = text.length(); boolean containsendchar = pattern.endswith(\"$\"); if (containsendchar) { patternend -= 1; } while ((patternpos < patternend) && (textpos < textend)) { int wildcardpos = pattern.indexof('*', patternpos); if (wildcardpos == -1) { wildcardpos = patternend; } if (wildcardpos == patternpos) { patternpos += 1; if (patternpos >= patternend) { return true; } int patternpieceend = pattern.indexof('*', patternpos); if (patternpieceend == -1) { patternpieceend = patternend; } boolean matched = false; int patternpiecelen = patternpieceend - patternpos; while ((textpos + patternpiecelen <= textend) && !matched) { matched = true; for (int i = 0; i < patternpiecelen && matched; i++) { if (text.charat(textpos + i) != pattern.charat(patternpos + i)) { matched = false; } } if (!matched) { textpos += 1; } } if (!matched) { return false; } } else { while ((patternpos < wildcardpos) && (textpos < textend)) { if (text.charat(textpos++) != pattern.charat(patternpos++)) { return false; } } } } while ((patternpos < patternend) && (pattern.charat(patternpos) == '*')) { patternpos += 1; } return (patternpos == patternend) && ((textpos == textend) || !containsendchar); }","repo":"kovyrin\/crawler-commons","label":[1,0,0,0]}
{"id":11110,"original_code":"private void validateImportPackage(IProgressMonitor monitor) {\n        IHeader header = getHeader(Constants.IMPORT_PACKAGE);\n        if (header == null)\n            return;\n        BundleDescription desc = fModel.getBundleDescription();\n        if (desc == null) {\n            ManifestElement[] elements = header.getElements();\n            for (int i = 0; i < elements.length; i++) {\n                validateSpecificationVersionAttribute(header, elements[i]);\n                validateImportPackageVersion(header, elements[i]);\n            }\n            return;\n        }\n        boolean hasUnresolved = false;\n        VersionConstraint[] constraints = desc.getContainingState().getStateHelper().getUnsatisfiedConstraints(desc);\n        for (int i = 0; i < constraints.length; i++) {\n            if (constraints[i] instanceof ImportPackageSpecification) {\n                hasUnresolved = true;\n                break;\n            }\n        }\n        HashMap<String, ExportPackageDescription> exported = getAvailableExportedPackages(desc.getContainingState());\n        ImportPackageSpecification[] imports = desc.getImportPackages();\n        if (desc.hasDynamicImports()) {\n            List<ImportPackageSpecification> staticImportsList = new ArrayList();\n            for (int i = 0; i < imports.length; ++i) {\n                if (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\n                    staticImportsList.add(imports[i]);\n            }\n            imports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n        }\n        ManifestElement[] elements = header.getElements();\n        int index = 0;\n        for (int i = 0; i < elements.length; i++) {\n            checkCanceled(monitor);\n            validateSpecificationVersionAttribute(header, elements[i]);\n            validateResolutionDirective(header, elements[i]);\n            \/\/ TODO we should only validate versions that we have a match\n            validateImportPackageVersion(header, elements[i]);\n            if (!hasUnresolved)\n                continue;\n            int length = elements[i].getValueComponents().length;\n            for (int j = 0; j < length; j++) {\n                ImportPackageSpecification importSpec = imports[index++];\n                String name = importSpec.getName();\n                if (\/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n                name.equals(\"java\") || name.startsWith(\"java.\")) {\n                    IHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n                    if (jreHeader == null || !\"true\".equals(\/\/$NON-NLS-1$\n                    jreHeader.getValue())) {\n                        report(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\n                        continue;\n                    }\n                }\n                if (importSpec.isResolved() || !isCheckUnresolvedImports())\n                    continue;\n                boolean optional = isOptional(elements[i]);\n                int severity = getRequireBundleSeverity(elements[i], optional);\n                ExportPackageDescription export = exported.get(name);\n                if (export != null) {\n                    if (export.getSupplier().isResolved()) {\n                        Version version = export.getVersion();\n                        org.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\n                        if (range != null && !range.isIncluded(version)) {\n                            report(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n                        }\n                    } else {\n                        report(NLS.bind(PDECoreMessages.BundleErrorReporter_unresolvedExporter, new String[] { export.getSupplier().getSymbolicName(), name }), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_OTHER);\n                    }\n                } else {\n                    IMarker marker = report(NLS.bind(PDECoreMessages.BundleErrorReporter_PackageNotExported, name), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.M_IMPORT_PKG_NOT_AVAILABLE, PDEMarkerFactory.CAT_FATAL);\n                    try {\n                        if (marker != null) {\n                            \/\/$NON-NLS-1$\n                            marker.setAttribute(\/\/$NON-NLS-1$\n                            \"packageName\", \/\/$NON-NLS-1$\n                            name);\n                            if (optional)\n                                \/\/$NON-NLS-1$\n                                marker.setAttribute(\/\/$NON-NLS-1$\n                                \"optional\", \/\/$NON-NLS-1$\n                                true);\n                        }\n                    } catch (CoreException e) {\n                    }\n                }\n            }\n        }\n    }","code_wo_comment":"private void validateImportPackage(IProgressMonitor monitor) {\n        IHeader header = getHeader(Constants.IMPORT_PACKAGE);\n        if (header == null)\n            return;\n        BundleDescription desc = fModel.getBundleDescription();\n        if (desc == null) {\n            ManifestElement[] elements = header.getElements();\n            for (int i = 0; i < elements.length; i++) {\n                validateSpecificationVersionAttribute(header, elements[i]);\n                validateImportPackageVersion(header, elements[i]);\n            }\n            return;\n        }\n        boolean hasUnresolved = false;\n        VersionConstraint[] constraints = desc.getContainingState().getStateHelper().getUnsatisfiedConstraints(desc);\n        for (int i = 0; i < constraints.length; i++) {\n            if (constraints[i] instanceof ImportPackageSpecification) {\n                hasUnresolved = true;\n                break;\n            }\n        }\n        HashMap<String, ExportPackageDescription> exported = getAvailableExportedPackages(desc.getContainingState());\n        ImportPackageSpecification[] imports = desc.getImportPackages();\n        if (desc.hasDynamicImports()) {\n            List<ImportPackageSpecification> staticImportsList = new ArrayList();\n            for (int i = 0; i < imports.length; ++i) {\n                if (!imports[i].getDirective(Constants.RESOLUTION_DIRECTIVE).equals(ImportPackageSpecification.RESOLUTION_DYNAMIC))\n                    staticImportsList.add(imports[i]);\n            }\n            imports = staticImportsList.toArray(new ImportPackageSpecification[staticImportsList.size()]);\n        }\n        ManifestElement[] elements = header.getElements();\n        int index = 0;\n        for (int i = 0; i < elements.length; i++) {\n            checkCanceled(monitor);\n            validateSpecificationVersionAttribute(header, elements[i]);\n            validateResolutionDirective(header, elements[i]);\n           \n            validateImportPackageVersion(header, elements[i]);\n            if (!hasUnresolved)\n                continue;\n            int length = elements[i].getValueComponents().length;\n            for (int j = 0; j < length; j++) {\n                ImportPackageSpecification importSpec = imports[index++];\n                String name = importSpec.getName();\n                if \n                name.equals(\"java\") || name.startsWith(\"java.\")) {\n                    IHeader jreHeader = getHeader(ICoreConstants.ECLIPSE_JREBUNDLE);\n                    if (jreHeader == null || !\"true\".equals\n                    jreHeader.getValue())) {\n                        report(PDECoreMessages.BundleErrorReporter_importNoJRE, getPackageLine(header, elements[i]), CompilerFlags.ERROR, PDEMarkerFactory.M_JAVA_PACKAGE__PORTED, PDEMarkerFactory.CAT_FATAL);\n                        continue;\n                    }\n                }\n                if (importSpec.isResolved() || !isCheckUnresolvedImports())\n                    continue;\n                boolean optional = isOptional(elements[i]);\n                int severity = getRequireBundleSeverity(elements[i], optional);\n                ExportPackageDescription export = exported.get(name);\n                if (export != null) {\n                    if (export.getSupplier().isResolved()) {\n                        Version version = export.getVersion();\n                        org.eclipse.osgi.service.resolver.VersionRange range = importSpec.getVersionRange();\n                        if (range != null && !range.isIncluded(version)) {\n                            report(NLS.bind(PDECoreMessages.BundleErrorReporter_unsatisfiedConstraint, importSpec.toString()), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_FATAL);\n                        }\n                    } else {\n                        report(NLS.bind(PDECoreMessages.BundleErrorReporter_unresolvedExporter, new String[] { export.getSupplier().getSymbolicName(), name }), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.CAT_OTHER);\n                    }\n                } else {\n                    IMarker marker = report(NLS.bind(PDECoreMessages.BundleErrorReporter_PackageNotExported, name), getPackageLine(header, elements[i]), severity, PDEMarkerFactory.M_IMPORT_PKG_NOT_AVAILABLE, PDEMarkerFactory.CAT_FATAL);\n                    try {\n                        if (marker != null) {\n                           \n                            marker.setAttribute\n                            \"packageName\",\n                            name);\n                            if (optional)\n                               \n                                marker.setAttribute\n                                \"optional\",\n                                true);\n                        }\n                    } catch (CoreException e) {\n                    }\n                }\n            }\n        }\n    }","cleancode":"private void validateimportpackage(iprogressmonitor monitor) { iheader header = getheader(constants.import_package); if (header == null) return; bundledescription desc = fmodel.getbundledescription(); if (desc == null) { manifestelement[] elements = header.getelements(); for (int i = 0; i < elements.length; i++) { validatespecificationversionattribute(header, elements[i]); validateimportpackageversion(header, elements[i]); } return; } boolean hasunresolved = false; versionconstraint[] constraints = desc.getcontainingstate().getstatehelper().getunsatisfiedconstraints(desc); for (int i = 0; i < constraints.length; i++) { if (constraints[i] instanceof importpackagespecification) { hasunresolved = true; break; } } hashmap<string, exportpackagedescription> exported = getavailableexportedpackages(desc.getcontainingstate()); importpackagespecification[] imports = desc.getimportpackages(); if (desc.hasdynamicimports()) { list<importpackagespecification> staticimportslist = new arraylist(); for (int i = 0; i < imports.length; ++i) { if (!imports[i].getdirective(constants.resolution_directive).equals(importpackagespecification.resolution_dynamic)) staticimportslist.add(imports[i]); } imports = staticimportslist.toarray(new importpackagespecification[staticimportslist.size()]); } manifestelement[] elements = header.getelements(); int index = 0; for (int i = 0; i < elements.length; i++) { checkcanceled(monitor); validatespecificationversionattribute(header, elements[i]); validateresolutiondirective(header, elements[i]); validateimportpackageversion(header, elements[i]); if (!hasunresolved) continue; int length = elements[i].getvaluecomponents().length; for (int j = 0; j < length; j++) { importpackagespecification importspec = imports[index++]; string name = importspec.getname(); if name.equals(\"java\") || name.startswith(\"java.\")) { iheader jreheader = getheader(icoreconstants.eclipse_jrebundle); if (jreheader == null || !\"true\".equals jreheader.getvalue())) { report(pdecoremessages.bundleerrorreporter_importnojre, getpackageline(header, elements[i]), compilerflags.error, pdemarkerfactory.m_java_package__ported, pdemarkerfactory.cat_fatal); continue; } } if (importspec.isresolved() || !ischeckunresolvedimports()) continue; boolean optional = isoptional(elements[i]); int severity = getrequirebundleseverity(elements[i], optional); exportpackagedescription export = exported.get(name); if (export != null) { if (export.getsupplier().isresolved()) { version version = export.getversion(); org.eclipse.osgi.service.resolver.versionrange range = importspec.getversionrange(); if (range != null && !range.isincluded(version)) { report(nls.bind(pdecoremessages.bundleerrorreporter_unsatisfiedconstraint, importspec.tostring()), getpackageline(header, elements[i]), severity, pdemarkerfactory.cat_fatal); } } else { report(nls.bind(pdecoremessages.bundleerrorreporter_unresolvedexporter, new string[] { export.getsupplier().getsymbolicname(), name }), getpackageline(header, elements[i]), severity, pdemarkerfactory.cat_other); } } else { imarker marker = report(nls.bind(pdecoremessages.bundleerrorreporter_packagenotexported, name), getpackageline(header, elements[i]), severity, pdemarkerfactory.m_import_pkg_not_available, pdemarkerfactory.cat_fatal); try { if (marker != null) { marker.setattribute \"packagename\", name); if (optional) marker.setattribute \"optional\", true); } } catch (coreexception e) { } } } } }","repo":"masud-technope\/BLIZZARD-Replication-Package-ESEC-FSE2018","label":[1,0,0,0]}
{"id":3341,"original_code":"@Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch(item.getItemId()) {\n            case R.id.clean_all:\n                db.open();\n                db.drop();\n                db.close();\n                break;\n            case R.id.manage_backup:\n                db.Backup();\n                break;\n            case R.id.manage_funds:\n                startActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\n                break;\n                                                \/*\n                                                    TODO: check for possibility to chain\/join\/combine xml menus\n                                                    TODO: manage recurring funds (ie set monthly incomes\/payments)\n                                                *\/\n            default:\n                Log.e (TAG, \"MENU = WTF?\");\n        }\n        return super.onOptionsItemSelected(item);\n    }","code_wo_comment":"@Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch(item.getItemId()) {\n            case R.id.clean_all:\n                db.open();\n                db.drop();\n                db.close();\n                break;\n            case R.id.manage_backup:\n                db.Backup();\n                break;\n            case R.id.manage_funds:\n                startActivityForResult(new Intent(BilansView.this, BilansStatusSetting.class), 1);\n                break;\n                                               \n            default:\n                Log.e (TAG, \"MENU = WTF?\");\n        }\n        return super.onOptionsItemSelected(item);\n    }","cleancode":"@override public boolean onoptionsitemselected(menuitem item) { switch(item.getitemid()) { case r.id.clean_all: db.open(); db.drop(); db.close(); break; case r.id.manage_backup: db.backup(); break; case r.id.manage_funds: startactivityforresult(new intent(bilansview.this, bilansstatussetting.class), 1); break; default: log.e (tag, \"menu = wtf?\"); } return super.onoptionsitemselected(item); }","repo":"kkrolczyk\/Schowek","label":[0,1,0,0]}
{"id":3342,"original_code":"private void updateSingleAccount(double amount, String account_name) {\n        \/\/ ok nasty hack here. Currently account have no idea which direction money flows.\n        \/\/ so for now - hardcoded for backwards compatiblility\n        if (account_name.equals(\"bankomat\")){\n            status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); \/\/ TODO: remove hardcoded account names...crashes if names dont match\n        }\n        else {\n            status_disp.reduce_wealth(account_name, (float) amount);\n            Log.e(TAG, account_name + \" \" + amount);\n        }\n    }","code_wo_comment":"private void updateSingleAccount(double amount, String account_name) {\n       \n       \n        if (account_name.equals(\"bankomat\")){\n            status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount);\n        }\n        else {\n            status_disp.reduce_wealth(account_name, (float) amount);\n            Log.e(TAG, account_name + \" \" + amount);\n        }\n    }","cleancode":"private void updatesingleaccount(double amount, string account_name) { if (account_name.equals(\"bankomat\")){ status_disp.transfer_resources(\"karta konto 1\", \"gotowka\", (float) amount); } else { status_disp.reduce_wealth(account_name, (float) amount); log.e(tag, account_name + \" \" + amount); } }","repo":"kkrolczyk\/Schowek","label":[1,0,1,0]}
{"id":19798,"original_code":"protected void onDragonDeath(EnderDragon dragon) {\n        log(\"The dragon died.\");\n        if (_stageNumber != 11) {\n            log(\"But we're not in stage 11, so it doesn't count.\");\n            return;\n        }\n        if (DragonFight.CONFIG.FIGHT_OWNER == null) {\n            log(\"But nobody owns the fight, so it doesn't count.\");\n            return;\n        }\n        \/\/ Bukkit.getOfflinePlayer() NEVER returns null, even for non-existent.\n        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\n        getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\n                                                      ChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\n        Player player = offlinePlayer.getPlayer();\n        if (player == null) {\n            \/\/ Fight owner is offline. Record an unclaimed prize.\n            log(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\n            getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\n            DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n        } else {\n            \/\/ Select a single drop from the `df-dragon-drops` loot set.\n            \/\/ TODO: actually, multiple drops should be supported, once\n            \/\/ BeastMaster supports deferred item drops.\n            log(\"Generating dragon prizes for \" + player.getName());\n            List<ItemStack> prizes = generatePrizes();\n            if (!givePrizes(player, prizes)) {\n                \/\/ The item(s) did not fit, so player must claim with command.\n                DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n                String slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\n                               ChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\n                                   ChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\n                                   ChatColor.DARK_PURPLE + \" to claim your prize.\");\n            }\n        }\n        \/\/ Clear the fight owner once prizes have been given or unclaimed prizes\n        \/\/ recorded, to prevent extra prizes if spurious dragons spawn.\n        DragonFight.CONFIG.FIGHT_OWNER = null;\n        DragonFight.CONFIG.save();\n    }","code_wo_comment":"protected void onDragonDeath(EnderDragon dragon) {\n        log(\"The dragon died.\");\n        if (_stageNumber != 11) {\n            log(\"But we're not in stage 11, so it doesn't count.\");\n            return;\n        }\n        if (DragonFight.CONFIG.FIGHT_OWNER == null) {\n            log(\"But nobody owns the fight, so it doesn't count.\");\n            return;\n        }\n       \n        OfflinePlayer offlinePlayer = Bukkit.getOfflinePlayer(DragonFight.CONFIG.FIGHT_OWNER);\n        getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.LIGHT_PURPLE + offlinePlayer.getName() +\n                                                      ChatColor.DARK_PURPLE + \" was awarded the prize for defeating the dragon.\"));\n        Player player = offlinePlayer.getPlayer();\n        if (player == null) {\n           \n            log(\"An unclaimed prize was added to offline fight owner \" + offlinePlayer.getName() + \".\");\n            getNearbyPlayers().forEach(p -> p.sendMessage(ChatColor.DARK_PURPLE + \"They can claim it when they log in.\"));\n            DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n        } else {\n           \n           \n           \n            log(\"Generating dragon prizes for \" + player.getName());\n            List<ItemStack> prizes = generatePrizes();\n            if (!givePrizes(player, prizes)) {\n               \n                DragonFight.CONFIG.incUnclaimedPrizes(offlinePlayer.getUniqueId(), 1);\n                String slots = ChatColor.LIGHT_PURPLE + Integer.toString(prizes.size()) +\n                               ChatColor.DARK_PURPLE + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"You need at least \" + slots + \" empty.\");\n                player.sendMessage(ChatColor.DARK_PURPLE + \"Run \" +\n                                   ChatColor.LIGHT_PURPLE + \"\/dragon prize\" +\n                                   ChatColor.DARK_PURPLE + \" to claim your prize.\");\n            }\n        }\n       \n       \n        DragonFight.CONFIG.FIGHT_OWNER = null;\n        DragonFight.CONFIG.save();\n    }","cleancode":"protected void ondragondeath(enderdragon dragon) { log(\"the dragon died.\"); if (_stagenumber != 11) { log(\"but we're not in stage 11, so it doesn't count.\"); return; } if (dragonfight.config.fight_owner == null) { log(\"but nobody owns the fight, so it doesn't count.\"); return; } offlineplayer offlineplayer = bukkit.getofflineplayer(dragonfight.config.fight_owner); getnearbyplayers().foreach(p -> p.sendmessage(chatcolor.light_purple + offlineplayer.getname() + chatcolor.dark_purple + \" was awarded the prize for defeating the dragon.\")); player player = offlineplayer.getplayer(); if (player == null) { log(\"an unclaimed prize was added to offline fight owner \" + offlineplayer.getname() + \".\"); getnearbyplayers().foreach(p -> p.sendmessage(chatcolor.dark_purple + \"they can claim it when they log in.\")); dragonfight.config.incunclaimedprizes(offlineplayer.getuniqueid(), 1); } else { log(\"generating dragon prizes for \" + player.getname()); list<itemstack> prizes = generateprizes(); if (!giveprizes(player, prizes)) { dragonfight.config.incunclaimedprizes(offlineplayer.getuniqueid(), 1); string slots = chatcolor.light_purple + integer.tostring(prizes.size()) + chatcolor.dark_purple + \" inventory slot\" + (prizes.size() > 1 ? \"s\" : \"\"); player.sendmessage(chatcolor.dark_purple + \"you need at least \" + slots + \" empty.\"); player.sendmessage(chatcolor.dark_purple + \"run \" + chatcolor.light_purple + \"\/dragon prize\" + chatcolor.dark_purple + \" to claim your prize.\"); } } dragonfight.config.fight_owner = null; dragonfight.config.save(); }","repo":"kadenscott\/DragonFight","label":[1,0,0,0]}
{"id":11718,"original_code":"@Override\n    protected void processAuthenticationResponse(HttpServletRequest request,\n                                                 HttpServletResponse response, AuthenticationContext context)\n            throws AuthenticationFailedException {\n        try {\n            Map<String, String> authenticatorProperties = context.getAuthenticatorProperties();\n            String clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\n            String clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\n            String tokenEndPoint = getTokenEndpoint(authenticatorProperties);\n            if (tokenEndPoint == null) {\n                tokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n            }\n            String callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\n            log.debug(\"callBackUrl : \" + callBackUrl);\n            if (callBackUrl == null) {\n                callBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\n                callBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n            }\n            @SuppressWarnings({\"unchecked\"})\n            Map<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\n            if (paramValueMap != null\n                && paramValueMap.containsKey(\"redirect_uri\")) {\n                callBackUrl = paramValueMap.get(\"redirect_uri\");\n            }\n            OAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\n            String code = authzResponse.getCode();\n            OAuthClientRequest accessRequest;\n            try {\n                accessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n                        .setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n                        .setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n            } catch (OAuthSystemException e) {\n                throw new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n            }\n            \/\/ create OAuth client that uses custom http client under the hood\n            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\n            OAuthClientResponse oAuthResponse;\n            try {\n                oAuthResponse = oAuthClient.accessToken(accessRequest);\n            } catch (OAuthSystemException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Exception while requesting access token\", e);\n                }\n                throw new AuthenticationFailedException(\"Exception while requesting access token\", e);\n            }\n            \/\/ TODO : return access token and id token to framework\n            String accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\n            String idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\n            if (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\n                context.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\n                if (idToken != null) {\n                    context.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\n                    String base64Body = idToken.split(\"\\\\.\")[1];\n                    byte[] decoded = Base64.decodeBase64(base64Body.getBytes());\n                    String json = new String(decoded);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Id token json string : \" + json);\n                    }\n                    Map<String, Object> jsonObject = JSONUtils.parseJSON(json);\n                    if (jsonObject != null) {\n                        Map<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\n                        String authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\n                        AuthenticatedUser authenticatedUserObj = AuthenticatedUser\n                                .createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\n                        authenticatedUserObj.setUserAttributes(claims);\n                        context.setSubject(authenticatedUserObj);\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Decoded json object is null\");\n                        }\n                        throw new AuthenticationFailedException(\"Decoded json object is null\");\n                    }\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Authentication Failed\");\n                    }\n                    throw new AuthenticationFailedException(\"Authentication Failed\");\n                }\n            } else {\n                throw new AuthenticationFailedException(\"Authentication Failed\");\n            }\n        } catch (OAuthProblemException e) {\n            throw new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n        } catch (JSONException e) {\n            throw new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n        }\n    }","code_wo_comment":"@Override\n    protected void processAuthenticationResponse(HttpServletRequest request,\n                                                 HttpServletResponse response, AuthenticationContext context)\n            throws AuthenticationFailedException {\n        try {\n            Map<String, String> authenticatorProperties = context.getAuthenticatorProperties();\n            String clientId = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_ID);\n            String clientSecret = authenticatorProperties.get(OIDCAuthenticatorConstants.CLIENT_SECRET);\n            String tokenEndPoint = getTokenEndpoint(authenticatorProperties);\n            if (tokenEndPoint == null) {\n                tokenEndPoint = authenticatorProperties.get(OIDCAuthenticatorConstants.OAUTH2_TOKEN_URL);\n            }\n            String callBackUrl = authenticatorProperties.get(GoogleOAuth2AuthenticationConstant.CALLBACK_URL);\n            log.debug(\"callBackUrl : \" + callBackUrl);\n            if (callBackUrl == null) {\n                callBackUrl = CarbonUIUtil.getAdminConsoleURL(request);\n                callBackUrl = callBackUrl.replace(\"commonauth\/carbon\/\", \"commonauth\");\n            }\n            @SuppressWarnings({\"unchecked\"})\n            Map<String, String> paramValueMap = (Map<String, String>) context.getProperty(\"oidc:param.map\");\n            if (paramValueMap != null\n                && paramValueMap.containsKey(\"redirect_uri\")) {\n                callBackUrl = paramValueMap.get(\"redirect_uri\");\n            }\n            OAuthAuthzResponse authzResponse = OAuthAuthzResponse.oauthCodeAuthzResponse(request);\n            String code = authzResponse.getCode();\n            OAuthClientRequest accessRequest;\n            try {\n                accessRequest = OAuthClientRequest.tokenLocation(tokenEndPoint)\n                        .setGrantType(GrantType.AUTHORIZATION_CODE).setClientId(clientId).setClientSecret(clientSecret)\n                        .setRedirectURI(callBackUrl).setCode(code).buildBodyMessage();\n            } catch (OAuthSystemException e) {\n                throw new AuthenticationFailedException(\"Exception while building request for request access token\", e);\n            }\n           \n            OAuthClient oAuthClient = new OAuthClient(new URLConnectionClient());\n            OAuthClientResponse oAuthResponse;\n            try {\n                oAuthResponse = oAuthClient.accessToken(accessRequest);\n            } catch (OAuthSystemException e) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Exception while requesting access token\", e);\n                }\n                throw new AuthenticationFailedException(\"Exception while requesting access token\", e);\n            }\n           \n            String accessToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ACCESS_TOKEN);\n            String idToken = oAuthResponse.getParam(OIDCAuthenticatorConstants.ID_TOKEN);\n            if (accessToken != null && (idToken != null || !requiredIDToken(authenticatorProperties))) {\n                context.setProperty(OIDCAuthenticatorConstants.ACCESS_TOKEN, accessToken);\n                if (idToken != null) {\n                    context.setProperty(OIDCAuthenticatorConstants.ID_TOKEN, idToken);\n                    String base64Body = idToken.split(\"\\\\.\")[1];\n                    byte[] decoded = Base64.decodeBase64(base64Body.getBytes());\n                    String json = new String(decoded);\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Id token json string : \" + json);\n                    }\n                    Map<String, Object> jsonObject = JSONUtils.parseJSON(json);\n                    if (jsonObject != null) {\n                        Map<ClaimMapping, String> claims = getSubjectAttributes(oAuthResponse);\n                        String authenticatedUser = (String) jsonObject.get(OIDCAuthenticatorConstants.Claim.EMAIL);\n                        AuthenticatedUser authenticatedUserObj = AuthenticatedUser\n                                .createFederateAuthenticatedUserFromSubjectIdentifier(authenticatedUser);\n                        authenticatedUserObj.setUserAttributes(claims);\n                        context.setSubject(authenticatedUserObj);\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Decoded json object is null\");\n                        }\n                        throw new AuthenticationFailedException(\"Decoded json object is null\");\n                    }\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Authentication Failed\");\n                    }\n                    throw new AuthenticationFailedException(\"Authentication Failed\");\n                }\n            } else {\n                throw new AuthenticationFailedException(\"Authentication Failed\");\n            }\n        } catch (OAuthProblemException e) {\n            throw new AuthenticationFailedException(\"Error occurred while acquiring access token\", e);\n        } catch (JSONException e) {\n            throw new AuthenticationFailedException(\"Error occurred while parsing json object\", e);\n        }\n    }","cleancode":"@override protected void processauthenticationresponse(httpservletrequest request, httpservletresponse response, authenticationcontext context) throws authenticationfailedexception { try { map<string, string> authenticatorproperties = context.getauthenticatorproperties(); string clientid = authenticatorproperties.get(oidcauthenticatorconstants.client_id); string clientsecret = authenticatorproperties.get(oidcauthenticatorconstants.client_secret); string tokenendpoint = gettokenendpoint(authenticatorproperties); if (tokenendpoint == null) { tokenendpoint = authenticatorproperties.get(oidcauthenticatorconstants.oauth2_token_url); } string callbackurl = authenticatorproperties.get(googleoauth2authenticationconstant.callback_url); log.debug(\"callbackurl : \" + callbackurl); if (callbackurl == null) { callbackurl = carbonuiutil.getadminconsoleurl(request); callbackurl = callbackurl.replace(\"commonauth\/carbon\/\", \"commonauth\"); } @suppresswarnings({\"unchecked\"}) map<string, string> paramvaluemap = (map<string, string>) context.getproperty(\"oidc:param.map\"); if (paramvaluemap != null && paramvaluemap.containskey(\"redirect_uri\")) { callbackurl = paramvaluemap.get(\"redirect_uri\"); } oauthauthzresponse authzresponse = oauthauthzresponse.oauthcodeauthzresponse(request); string code = authzresponse.getcode(); oauthclientrequest accessrequest; try { accessrequest = oauthclientrequest.tokenlocation(tokenendpoint) .setgranttype(granttype.authorization_code).setclientid(clientid).setclientsecret(clientsecret) .setredirecturi(callbackurl).setcode(code).buildbodymessage(); } catch (oauthsystemexception e) { throw new authenticationfailedexception(\"exception while building request for request access token\", e); } oauthclient oauthclient = new oauthclient(new urlconnectionclient()); oauthclientresponse oauthresponse; try { oauthresponse = oauthclient.accesstoken(accessrequest); } catch (oauthsystemexception e) { if (log.isdebugenabled()) { log.debug(\"exception while requesting access token\", e); } throw new authenticationfailedexception(\"exception while requesting access token\", e); } string accesstoken = oauthresponse.getparam(oidcauthenticatorconstants.access_token); string idtoken = oauthresponse.getparam(oidcauthenticatorconstants.id_token); if (accesstoken != null && (idtoken != null || !requiredidtoken(authenticatorproperties))) { context.setproperty(oidcauthenticatorconstants.access_token, accesstoken); if (idtoken != null) { context.setproperty(oidcauthenticatorconstants.id_token, idtoken); string base64body = idtoken.split(\"\\\\.\")[1]; byte[] decoded = base64.decodebase64(base64body.getbytes()); string json = new string(decoded); if (log.isdebugenabled()) { log.debug(\"id token json string : \" + json); } map<string, object> jsonobject = jsonutils.parsejson(json); if (jsonobject != null) { map<claimmapping, string> claims = getsubjectattributes(oauthresponse); string authenticateduser = (string) jsonobject.get(oidcauthenticatorconstants.claim.email); authenticateduser authenticateduserobj = authenticateduser .createfederateauthenticateduserfromsubjectidentifier(authenticateduser); authenticateduserobj.setuserattributes(claims); context.setsubject(authenticateduserobj); } else { if (log.isdebugenabled()) { log.debug(\"decoded json object is null\"); } throw new authenticationfailedexception(\"decoded json object is null\"); } } else { if (log.isdebugenabled()) { log.debug(\"authentication failed\"); } throw new authenticationfailedexception(\"authentication failed\"); } } else { throw new authenticationfailedexception(\"authentication failed\"); } } catch (oauthproblemexception e) { throw new authenticationfailedexception(\"error occurred while acquiring access token\", e); } catch (jsonexception e) { throw new authenticationfailedexception(\"error occurred while parsing json object\", e); } }","repo":"manjulaRathnayaka\/carbon-identity","label":[0,1,0,0]}
{"id":11781,"original_code":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\n            throws MetadataValidationException, MetadataException {\n        System.out.println(\"Related QueryContents\");\n        this.displayStructureHeader(index, xv);\n        Metadata m = getMetadata();\n        boolean object_refs = m.isObjectRefsOnly();\n        if (m.getWrapper() == null) {\n            return;\n        }\n        xv.getMetadata().addMetadata(m);\n        if (object_refs) {\n            \/\/ no idea what to do here\n        } else {\n            String ref_id = this.getReferenceId();\n            h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n                    + ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n                    + ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n                    + \")\");\n            \/\/ AMS 04\/24\/2009 - FIXME - Refactor this - 'else-if' and 'else' are pretty similar\n            for (OMElement a_ele : m.getAssociations()) {\n                String src_id = m.getAssocSource(a_ele);\n                String a_type = m.getAssocType(a_ele);\n                String a_id = m.getId(a_ele);\n                String tgt_id = m.getAssocTarget(a_ele);\n                if (src_id == null) {\n                } else if (src_id != null && !src_id.equals(this.getReferenceId())) {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaced by\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"has appended\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transformed to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\n                        a_type = \"is snapshot of\";\n                    } else {\n                        a_type = a_type + \" by\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(src_id, cntl)\n                            + \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n                            + \"]\");\n                } else {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaces\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"appended to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transform of\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(tgt_id, cntl)\n                            + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n                            + \"]\");\n                }\n            }\n        }\n    }","code_wo_comment":"public void displayStructure(QueryControl q_cntl, int index, HttpUtils h, XView xv, String cntl)\n            throws MetadataValidationException, MetadataException {\n        System.out.println(\"Related QueryContents\");\n        this.displayStructureHeader(index, xv);\n        Metadata m = getMetadata();\n        boolean object_refs = m.isObjectRefsOnly();\n        if (m.getWrapper() == null) {\n            return;\n        }\n        xv.getMetadata().addMetadata(m);\n        if (object_refs) {\n           \n        } else {\n            String ref_id = this.getReferenceId();\n            h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \"\n                    + ((m.isRetrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\")\n                    + ((m.isRetrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\")\n                    + \")\");\n           \n            for (OMElement a_ele : m.getAssociations()) {\n                String src_id = m.getAssocSource(a_ele);\n                String a_type = m.getAssocType(a_ele);\n                String a_id = m.getId(a_ele);\n                String tgt_id = m.getAssocTarget(a_ele);\n                if (src_id == null) {\n                } else if (src_id != null && !src_id.equals(this.getReferenceId())) {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaced by\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"has appended\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transformed to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_issnapshotof.equals(a_type)) {\n                        a_type = \"is snapshot of\";\n                    } else {\n                        a_type = a_type + \" by\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(src_id, cntl)\n                            + \" (\" + xv.build_xml_link(src_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(src_id) : \"\")\n                            + \"]\");\n                } else {\n                    if (MetadataSupport.xdsB_ihe_assoc_type_rplc.equals(a_type)) {\n                        a_type = \"replaces\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_apnd.equals(a_type)) {\n                        a_type = \"appended to\";\n                    } else if (MetadataSupport.xdsB_ihe_assoc_type_xfrm.equals(a_type)) {\n                        a_type = \"transform of\";\n                    }\n                    h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \"\n                            + xv.build_details_link(tgt_id, cntl)\n                            + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \"\n                            + ((m.isRetrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\")\n                            + ((m.isRetrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\")\n                            + \") \"\n                            + \" [\" + ((q_cntl.hasEndpoint()) ? xv.build_related_link(tgt_id) : \"\")\n                            + \"]\");\n                }\n            }\n        }\n    }","cleancode":"public void displaystructure(querycontrol q_cntl, int index, httputils h, xview xv, string cntl) throws metadatavalidationexception, metadataexception { system.out.println(\"related querycontents\"); this.displaystructureheader(index, xv); metadata m = getmetadata(); boolean object_refs = m.isobjectrefsonly(); if (m.getwrapper() == null) { return; } xv.getmetadata().addmetadata(m); if (object_refs) { } else { string ref_id = this.getreferenceid(); h.indent1(xv.build_details_link(ref_id, cntl) + \" (\" + xv.build_xml_link(ref_id, cntl) + \" \" + ((m.isretrievable_a(ref_id)) ? xv.build_ret_a_link(ref_id) + \" \" : \"\") + ((m.isretrievable_b(ref_id)) ? xv.build_ret_b_link(ref_id) + \" \" : \"\") + \")\"); for (omelement a_ele : m.getassociations()) { string src_id = m.getassocsource(a_ele); string a_type = m.getassoctype(a_ele); string a_id = m.getid(a_ele); string tgt_id = m.getassoctarget(a_ele); if (src_id == null) { } else if (src_id != null && !src_id.equals(this.getreferenceid())) { if (metadatasupport.xdsb_ihe_assoc_type_rplc.equals(a_type)) { a_type = \"replaced by\"; } else if (metadatasupport.xdsb_ihe_assoc_type_apnd.equals(a_type)) { a_type = \"has appended\"; } else if (metadatasupport.xdsb_ihe_assoc_type_xfrm.equals(a_type)) { a_type = \"transformed to\"; } else if (metadatasupport.xdsb_ihe_assoc_type_issnapshotof.equals(a_type)) { a_type = \"is snapshot of\"; } else { a_type = a_type + \" by\"; } h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \" + xv.build_details_link(src_id, cntl) + \" (\" + xv.build_xml_link(src_id, cntl) + \" \" + ((m.isretrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\") + ((m.isretrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\") + \") \" + \" [\" + ((q_cntl.hasendpoint()) ? xv.build_related_link(src_id) : \"\") + \"]\"); } else { if (metadatasupport.xdsb_ihe_assoc_type_rplc.equals(a_type)) { a_type = \"replaces\"; } else if (metadatasupport.xdsb_ihe_assoc_type_apnd.equals(a_type)) { a_type = \"appended to\"; } else if (metadatasupport.xdsb_ihe_assoc_type_xfrm.equals(a_type)) { a_type = \"transform of\"; } h.indent2(xv.build_assoc_link(a_id, a_type, cntl) + \" \" + xv.build_details_link(tgt_id, cntl) + \" (\" + xv.build_xml_link(tgt_id, cntl) + \" \" + ((m.isretrievable_a(tgt_id)) ? xv.build_ret_a_link(tgt_id) + \" \" : \"\") + ((m.isretrievable_b(tgt_id)) ? xv.build_ret_b_link(tgt_id) + \" \" : \"\") + \") \" + \" [\" + ((q_cntl.hasendpoint()) ? xv.build_related_link(tgt_id) : \"\") + \"]\"); } } } }","repo":"kef\/hieos","label":[1,1,0,0]}
{"id":3600,"original_code":"public RemoteEventData[] readAhead(int maxEvents) \n        throws IOException, ClassNotFoundException \n    {\n        boolean IOExceptionCaught = false;\n        stateCheck();\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        \/\/ Check if empty\n\tif (isEmpty()) \n\t    throw new NoSuchElementException();    \n        long readCount = rcount;\n        long readPosition = rpos;\n        long logNum = getLogNum(readCount); \n        File log = getLogFile(logNum);\n        RemoteEvent evt = null;\n        ArrayList rData = new ArrayList();\n        int i = 0;\n        LogInputStream in = null;\n        boolean done = false;\n        printControlData(persistenceLogger, \"Before read::readAhead\");\n        if (persistenceLogger.isLoggable(Level.FINEST)) {\n            persistenceLogger.log(Level.FINEST, \n                \"EventLog::readAhead() maxEvents = {0}\", \n                new Object[] {Integer.valueOf(maxEvents)});\n        } \n        while ((readCount < wcount) && \n               (rData.size() < maxEvents) &&\n               !done) \n        {\n            if (logNum != getLogNum(readCount)) {\n                logNum = getLogNum(readCount);\n                log = getLogFile(logNum);\n                readPosition = 0;\n            }\n            try {\n                \/\/ get the input stream\n                in = streamPool.getLogInputStream(log, readPosition);\n                \/\/ read the event\n                evt = eventReader.read(in); \n                \/\/ update readCount and readPosition\n                readCount++;\n                readPosition = in.getOffset(); \/\/ offset to next unread event\n                \/\/Generate new entry\n                rData.add(new RemoteEventData(\n                   evt, \n                   new RemoteEventDataCursor(readCount, readPosition)));\n            } catch (IOException ie) {\n                \/\/ We'll get interrupted when asked to shutdown.\n                \/\/ In this case, we can skip the call to nextReadAheadLog.\n                if (ie instanceof InterruptedIOException) {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() interrupted \");\n                    } \n                    \/\/ Stop processing events\n                    done = true;\n                } else {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() received IOException \" \n                            + \"... skipping to next read log\"); \n                    }\n                    readCount = nextReadAheadLog(readCount);\n                    \/\/ TODO - rcount = readCount;\n                    \/\/ TODO - if bump rcount you need to bump wcount too\n                    \/\/ TODO - if bump counts then you need to persist them\n                    readPosition = 0;\n                    IOExceptionCaught = true; \n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() new readCount is {0}\", \n                            Long.valueOf(readCount)); \n                    }                    \n                }\n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", ie);\n                }\n            } catch (ClassNotFoundException cnfe) {\n                \/\/ Note that the read offset is still valid since the\n                \/\/ MarshalledObject extraction should always succeed.\n                \/\/ It's just that the RemoteEvent within it could not\n                \/\/ be reconstituted. Therefore, just skip to the next\n                \/\/ MarshalledObject in the stream.\n                readCount++;\n                readPosition = in.getOffset();\n                \/\/Generate new entry\n                rData.add(new RemoteEventData(\n                   null, \n                   new RemoteEventDataCursor(readCount, readPosition)));                \n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", cnfe);\n                }            \n            } finally {\n                \/\/ If an IOException occurs then the eventReader is in \n                \/\/ a bad state. Therefore, we get rid of our existing\n                \/\/ reference and create a fresh one. The underlying\n                \/\/ stream is also removed from from the pool, forcing\n                \/\/ a fresh copy to be returned on the next \"get\" request.\n                if (IOExceptionCaught) {\n                    \/\/TODO (FCS) add close to interface\n                    \/\/eventReader.close();\n                    eventReader = new EventReader();\n                    if (in != null) {\n                        streamPool.removeLogStream(in);\n                        in = null;\n                    }\n                } else { \n                    if (in != null)\n                        streamPool.releaseLogStream(in);\n                    \/* Shouldn't have to release since we have exclusive\n                     * access, but the next getLogInputStream assumes things\n                     * are on the freelist.\n                     *\/\n                }\n            }\n        }\n        printControlData(persistenceLogger, \"After Event::readAhead\");\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        return (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n    }","code_wo_comment":"public RemoteEventData[] readAhead(int maxEvents) \n        throws IOException, ClassNotFoundException \n    {\n        boolean IOExceptionCaught = false;\n        stateCheck();\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n       \n\tif (isEmpty()) \n\t    throw new NoSuchElementException();    \n        long readCount = rcount;\n        long readPosition = rpos;\n        long logNum = getLogNum(readCount); \n        File log = getLogFile(logNum);\n        RemoteEvent evt = null;\n        ArrayList rData = new ArrayList();\n        int i = 0;\n        LogInputStream in = null;\n        boolean done = false;\n        printControlData(persistenceLogger, \"Before read::readAhead\");\n        if (persistenceLogger.isLoggable(Level.FINEST)) {\n            persistenceLogger.log(Level.FINEST, \n                \"EventLog::readAhead() maxEvents = {0}\", \n                new Object[] {Integer.valueOf(maxEvents)});\n        } \n        while ((readCount < wcount) && \n               (rData.size() < maxEvents) &&\n               !done) \n        {\n            if (logNum != getLogNum(readCount)) {\n                logNum = getLogNum(readCount);\n                log = getLogFile(logNum);\n                readPosition = 0;\n            }\n            try {\n               \n                in = streamPool.getLogInputStream(log, readPosition);\n               \n                evt = eventReader.read(in); \n               \n                readCount++;\n                readPosition = in.getOffset();\n               \n                rData.add(new RemoteEventData(\n                   evt, \n                   new RemoteEventDataCursor(readCount, readPosition)));\n            } catch (IOException ie) {\n               \n               \n                if (ie instanceof InterruptedIOException) {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() interrupted \");\n                    } \n                   \n                    done = true;\n                } else {\n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() received IOException \" \n                            + \"... skipping to next read log\"); \n                    }\n                    readCount = nextReadAheadLog(readCount);\n                   \n                   \n                   \n                    readPosition = 0;\n                    IOExceptionCaught = true; \n                    if (persistenceLogger.isLoggable(Level.FINEST)) {\n                        persistenceLogger.log(Level.FINEST, \n                            \"EventLog::readAhead() new readCount is {0}\", \n                            Long.valueOf(readCount)); \n                    }                    \n                }\n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", ie);\n                }\n            } catch (ClassNotFoundException cnfe) {\n               \n               \n               \n               \n               \n                readCount++;\n                readPosition = in.getOffset();\n               \n                rData.add(new RemoteEventData(\n                   null, \n                   new RemoteEventDataCursor(readCount, readPosition)));                \n                if (persistenceLogger.isLoggable(Levels.HANDLED)) {\n                        persistenceLogger.log(Levels.HANDLED, \n                            \"Exception: \", cnfe);\n                }            \n            } finally {\n               \n               \n               \n               \n               \n                if (IOExceptionCaught) {\n                   \n                   \n                    eventReader = new EventReader();\n                    if (in != null) {\n                        streamPool.removeLogStream(in);\n                        in = null;\n                    }\n                } else { \n                    if (in != null)\n                        streamPool.releaseLogStream(in);\n                   \n                }\n            }\n        }\n        printControlData(persistenceLogger, \"After Event::readAhead\");\n\tif (debugState) {\n\t    assertInvariants();\n\t}\n        return (RemoteEventData[]) rData.toArray(new RemoteEventData[0]);\n    }","cleancode":"public remoteeventdata[] readahead(int maxevents) throws ioexception, classnotfoundexception { boolean ioexceptioncaught = false; statecheck(); if (debugstate) { assertinvariants(); } if (isempty()) throw new nosuchelementexception(); long readcount = rcount; long readposition = rpos; long lognum = getlognum(readcount); file log = getlogfile(lognum); remoteevent evt = null; arraylist rdata = new arraylist(); int i = 0; loginputstream in = null; boolean done = false; printcontroldata(persistencelogger, \"before read::readahead\"); if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() maxevents = {0}\", new object[] {integer.valueof(maxevents)}); } while ((readcount < wcount) && (rdata.size() < maxevents) && !done) { if (lognum != getlognum(readcount)) { lognum = getlognum(readcount); log = getlogfile(lognum); readposition = 0; } try { in = streampool.getloginputstream(log, readposition); evt = eventreader.read(in); readcount++; readposition = in.getoffset(); rdata.add(new remoteeventdata( evt, new remoteeventdatacursor(readcount, readposition))); } catch (ioexception ie) { if (ie instanceof interruptedioexception) { if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() interrupted \"); } done = true; } else { if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() received ioexception \" + \"... skipping to next read log\"); } readcount = nextreadaheadlog(readcount); readposition = 0; ioexceptioncaught = true; if (persistencelogger.isloggable(level.finest)) { persistencelogger.log(level.finest, \"eventlog::readahead() new readcount is {0}\", long.valueof(readcount)); } } if (persistencelogger.isloggable(levels.handled)) { persistencelogger.log(levels.handled, \"exception: \", ie); } } catch (classnotfoundexception cnfe) { readcount++; readposition = in.getoffset(); rdata.add(new remoteeventdata( null, new remoteeventdatacursor(readcount, readposition))); if (persistencelogger.isloggable(levels.handled)) { persistencelogger.log(levels.handled, \"exception: \", cnfe); } } finally { if (ioexceptioncaught) { eventreader = new eventreader(); if (in != null) { streampool.removelogstream(in); in = null; } } else { if (in != null) streampool.releaselogstream(in); } } } printcontroldata(persistencelogger, \"after event::readahead\"); if (debugstate) { assertinvariants(); } return (remoteeventdata[]) rdata.toarray(new remoteeventdata[0]); }","repo":"mkleczek\/river","label":[0,1,0,0]}
{"id":11842,"original_code":"public LoginContext authenticate(String user, char[] password, String realm) {\n\t\t\/\/ consider modules: Krb5LoginModule, LdapLoginModule, NTLoginModule,\n\t\t\/\/ JndiLoginModule\n\t\t\/\/ ...sun...\n\t\tPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\n\t\tLoginContext lc;\n\t\ttry {\n\t\t\tlc = new LoginContext(realm, cbh); \/\/ referenced in jaas.conf\n\t\t} catch (LoginException e) {\n\t\t\tLOG.error(\"Exception during new LoginContext()\", e);\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\t\/\/ call callback to retrieve credentials, and checks that\n\t\t\t\/\/ Authentication fails\n\t\t\tlc.login();\n\t\t} catch (LoginException e) {\n\t\t\t\/\/ FIXME. LoginException may happen either because authentication\n\t\t\t\/\/ failed, or for many other reasons.\n\t\t\t\/\/ We should ignore the first, and LOG the latter.\n\t\t\tLOG.error(\"Exception while loggin-in\", e);\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tArrays.fill(password, '\\u0000');\n\t\t}\n\t\treturn lc;\n\t}","code_wo_comment":"public LoginContext authenticate(String user, char[] password, String realm) {\n\t\n\t\n\t\n\t\tPassiveCallbackHandler cbh = new PassiveCallbackHandler(user, password);\n\t\tLoginContext lc;\n\t\ttry {\n\t\t\tlc = new LoginContext(realm, cbh);\n\t\t} catch (LoginException e) {\n\t\t\tLOG.error(\"Exception during new LoginContext()\", e);\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\n\t\t\n\t\t\tlc.login();\n\t\t} catch (LoginException e) {\n\t\t\n\t\t\n\t\t\n\t\t\tLOG.error(\"Exception while loggin-in\", e);\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tArrays.fill(password, '\\u0000');\n\t\t}\n\t\treturn lc;\n\t}","cleancode":"public logincontext authenticate(string user, char[] password, string realm) { passivecallbackhandler cbh = new passivecallbackhandler(user, password); logincontext lc; try { lc = new logincontext(realm, cbh); } catch (loginexception e) { log.error(\"exception during new logincontext()\", e); return null; } try { lc.login(); } catch (loginexception e) { log.error(\"exception while loggin-in\", e); return null; } finally { arrays.fill(password, '\\u0000'); } return lc; }","repo":"luca-vercelli\/java-web-template","label":[0,0,1,0]}
{"id":11878,"original_code":"@Override\n\tpublic void runWithEvent(IAction action, Event event) {\n\t\tupdateEnablement(action);\n\t\tif (action.isEnabled()) {\n\t\t\tISelection currentSelection = getSelection();\n\t\t\tSet<EPlanElement> selected = PlanEditorUtil.emfFromSelection(currentSelection);\n\t\t\tfinal MoveToOrbitOperation op = new MoveToOrbitOperation(selected);\n\t\t\tString errorMsg = op.analyzeMistakenSelection();\n\t\t\tif (errorMsg != null) {\n\t\t\t\tLogUtil.warn(errorMsg);\n\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Nothing to Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\"No orbit-related plan elements selected.\",\n\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg, new ExecutionException(selected.toString())));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString orbitId = promptForValue();\n\t\t\t\tif (orbitId != null) {\n\t\t\t\t\top.setOrbitId(orbitId);\n\t\t\t\t\tIUndoContext undoContext = getUndoContext();\n\t\t\t\t\tCommonUtils.execute(op, undoContext);\n\t\t\t\t\tString errorMsg2 = op.analyzeMissingOrbitDestination();\n\t\t\t\t\tif (errorMsg2 != null) {\n\t\t\t\t\t\tLogUtil.warn(errorMsg2);\n\t\t\t\t\t\t\/\/TODO:  Use the new WidgetUtils.showErrorToUser method.\n\t\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\t\t\"Move To \" + OrbitEventUtil.ORBIT_NAME +  \" may not have done what you expected.\",\n\t\t\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t\tIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\n\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}","code_wo_comment":"@Override\n\tpublic void runWithEvent(IAction action, Event event) {\n\t\tupdateEnablement(action);\n\t\tif (action.isEnabled()) {\n\t\t\tISelection currentSelection = getSelection();\n\t\t\tSet<EPlanElement> selected = PlanEditorUtil.emfFromSelection(currentSelection);\n\t\t\tfinal MoveToOrbitOperation op = new MoveToOrbitOperation(selected);\n\t\t\tString errorMsg = op.analyzeMistakenSelection();\n\t\t\tif (errorMsg != null) {\n\t\t\t\tLogUtil.warn(errorMsg);\n\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Nothing to Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\"No orbit-related plan elements selected.\",\n\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg, new ExecutionException(selected.toString())));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tString orbitId = promptForValue();\n\t\t\t\tif (orbitId != null) {\n\t\t\t\t\top.setOrbitId(orbitId);\n\t\t\t\t\tIUndoContext undoContext = getUndoContext();\n\t\t\t\t\tCommonUtils.execute(op, undoContext);\n\t\t\t\t\tString errorMsg2 = op.analyzeMissingOrbitDestination();\n\t\t\t\t\tif (errorMsg2 != null) {\n\t\t\t\t\t\tLogUtil.warn(errorMsg2);\n\t\t\t\t\t\n\t\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"Move To \" + OrbitEventUtil.ORBIT_NAME,\n\t\t\t\t\t\t\t\t\"Move To \" + OrbitEventUtil.ORBIT_NAME +  \" may not have done what you expected.\",\n\t\t\t\t\t\t\t\tnew ExceptionStatus(EditorPlugin.ID, errorMsg2, new ExecutionException(selected.toString())));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t\tIStatus error = new ExceptionStatus(EditorPlugin.ID, e.getMessage(), e);\n\t\t\t\t\tErrorDialog.openError(WidgetUtils.getShell(), \"An error occurred\", \"That didn't work.\", error);\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"@override public void runwithevent(iaction action, event event) { updateenablement(action); if (action.isenabled()) { iselection currentselection = getselection(); set<eplanelement> selected = planeditorutil.emffromselection(currentselection); final movetoorbitoperation op = new movetoorbitoperation(selected); string errormsg = op.analyzemistakenselection(); if (errormsg != null) { logutil.warn(errormsg); errordialog.openerror(widgetutils.getshell(), \"nothing to move to \" + orbiteventutil.orbit_name, \"no orbit-related plan elements selected.\", new exceptionstatus(editorplugin.id, errormsg, new executionexception(selected.tostring()))); return; } try { string orbitid = promptforvalue(); if (orbitid != null) { op.setorbitid(orbitid); iundocontext undocontext = getundocontext(); commonutils.execute(op, undocontext); string errormsg2 = op.analyzemissingorbitdestination(); if (errormsg2 != null) { logutil.warn(errormsg2); errordialog.openerror(widgetutils.getshell(), \"move to \" + orbiteventutil.orbit_name, \"move to \" + orbiteventutil.orbit_name + \" may not have done what you expected.\", new exceptionstatus(editorplugin.id, errormsg2, new executionexception(selected.tostring()))); return; } } } catch (exception e) { istatus error = new exceptionstatus(editorplugin.id, e.getmessage(), e); errordialog.openerror(widgetutils.getshell(), \"an error occurred\", \"that didn't work.\", error); } } }","repo":"mikiec84\/OpenSPIFe","label":[1,0,0,0]}
{"id":20922,"original_code":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n\t{\n\t\t\/\/ TODO: Check & refactor this\n\t\t\/\/ Get Tree\n\t\tint AD_Tree_ID = 0;\n\t\tMClient client = MClient.get(ctx);\n\t\tI_AD_ClientInfo ci = client.getInfo();\n\t\tif (TREETYPE_Activity.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Activity_ID();\n\t\telse if (TREETYPE_BoM.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"BoM Trees not supported\");\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\n\t\telse if (TREETYPE_Campaign.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\n\t\telse if (TREETYPE_ElementValue.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\n\t\telse if (TREETYPE_Menu.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Menu_ID();\n\t\telse if (TREETYPE_Organization.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Org_ID();\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Product_ID();\n\t\telse if (TREETYPE_ProductCategory.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"Product Category Trees not supported\");\n\t\telse if (TREETYPE_Project.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Project_ID();\n\t\telse if (TREETYPE_SalesRegion.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\n\t\tif (AD_Tree_ID == 0)\n\t\t\tthrow new IllegalArgumentException(\"No Tree found\");\n\t\tMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\n\t\tif (tree.get_ID() != AD_Tree_ID)\n\t\t\tthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\t\t\/\/ Insert Tree in correct tree\n\t\tboolean saved = false;\n\t\tif (TREETYPE_Menu.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t{\n\t\t\tMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMTree_Node node = new MTree_Node(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\treturn saved;\n\t}","code_wo_comment":"public static boolean addNode(Properties ctx, String treeType, int Record_ID, String trxName)\n\t{\n\t\n\t\n\t\tint AD_Tree_ID = 0;\n\t\tMClient client = MClient.get(ctx);\n\t\tI_AD_ClientInfo ci = client.getInfo();\n\t\tif (TREETYPE_Activity.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Activity_ID();\n\t\telse if (TREETYPE_BoM.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"BoM Trees not supported\");\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_BPartner_ID();\n\t\telse if (TREETYPE_Campaign.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Campaign_ID();\n\t\telse if (TREETYPE_ElementValue.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"ElementValue cannot use this API\");\n\t\telse if (TREETYPE_Menu.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Menu_ID();\n\t\telse if (TREETYPE_Organization.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Org_ID();\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Product_ID();\n\t\telse if (TREETYPE_ProductCategory.equals(treeType))\n\t\t\tthrow new IllegalArgumentException(\"Product Category Trees not supported\");\n\t\telse if (TREETYPE_Project.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_Project_ID();\n\t\telse if (TREETYPE_SalesRegion.equals(treeType))\n\t\t\tAD_Tree_ID = ci.getAD_Tree_SalesRegion_ID();\n\t\tif (AD_Tree_ID == 0)\n\t\t\tthrow new IllegalArgumentException(\"No Tree found\");\n\t\tMTree_Base tree = MTree_Base.get(ctx, AD_Tree_ID, trxName);\n\t\tif (tree.get_ID() != AD_Tree_ID)\n\t\t\tthrow new IllegalArgumentException(\"Tree found AD_Tree_ID=\" + AD_Tree_ID);\n\t\n\t\tboolean saved = false;\n\t\tif (TREETYPE_Menu.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeMM node = new MTree_NodeMM(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_BPartner.equals(treeType))\n\t\t{\n\t\t\tMTree_NodeBP node = new MTree_NodeBP(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse if (TREETYPE_Product.equals(treeType))\n\t\t{\n\t\t\tMTree_NodePR node = new MTree_NodePR(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tMTree_Node node = new MTree_Node(tree, Record_ID);\n\t\t\tsaved = node.save();\n\t\t}\n\t\treturn saved;\n\t}","cleancode":"public static boolean addnode(properties ctx, string treetype, int record_id, string trxname) { int ad_tree_id = 0; mclient client = mclient.get(ctx); i_ad_clientinfo ci = client.getinfo(); if (treetype_activity.equals(treetype)) ad_tree_id = ci.getad_tree_activity_id(); else if (treetype_bom.equals(treetype)) throw new illegalargumentexception(\"bom trees not supported\"); else if (treetype_bpartner.equals(treetype)) ad_tree_id = ci.getad_tree_bpartner_id(); else if (treetype_campaign.equals(treetype)) ad_tree_id = ci.getad_tree_campaign_id(); else if (treetype_elementvalue.equals(treetype)) throw new illegalargumentexception(\"elementvalue cannot use this api\"); else if (treetype_menu.equals(treetype)) ad_tree_id = ci.getad_tree_menu_id(); else if (treetype_organization.equals(treetype)) ad_tree_id = ci.getad_tree_org_id(); else if (treetype_product.equals(treetype)) ad_tree_id = ci.getad_tree_product_id(); else if (treetype_productcategory.equals(treetype)) throw new illegalargumentexception(\"product category trees not supported\"); else if (treetype_project.equals(treetype)) ad_tree_id = ci.getad_tree_project_id(); else if (treetype_salesregion.equals(treetype)) ad_tree_id = ci.getad_tree_salesregion_id(); if (ad_tree_id == 0) throw new illegalargumentexception(\"no tree found\"); mtree_base tree = mtree_base.get(ctx, ad_tree_id, trxname); if (tree.get_id() != ad_tree_id) throw new illegalargumentexception(\"tree found ad_tree_id=\" + ad_tree_id); boolean saved = false; if (treetype_menu.equals(treetype)) { mtree_nodemm node = new mtree_nodemm(tree, record_id); saved = node.save(); } else if (treetype_bpartner.equals(treetype)) { mtree_nodebp node = new mtree_nodebp(tree, record_id); saved = node.save(); } else if (treetype_product.equals(treetype)) { mtree_nodepr node = new mtree_nodepr(tree, record_id); saved = node.save(); } else { mtree_node node = new mtree_node(tree, record_id); saved = node.save(); } return saved; }","repo":"metas-fresh\/fresh","label":[1,0,0,0]}
{"id":12731,"original_code":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\n        Set<Operator> seenByDFS = new HashSet<Operator>();\n        Map<LogicalPlan, PigOutLogicalChunks> mapping =\n                new HashMap<>();\n        while ( !visitQueue.isEmpty() ) {\n            Operator s = visitQueue.poll();\n            LogicalRelationalOperator lro = (LogicalRelationalOperator) s;\n            log.debug(\"Visit: \" + lro);\n            \/\/ for each s, we may need to create a new \"chunk\"\n\t\t\t\/\/ each partition is created by DFS from a source\n            if (!seenByDFS.add(s)) continue;\n            \/\/ Create a new logical plan for the new chunk\n            LogicalPlan newPlan = new LogicalPlan();\n            newPlan.add(s);\n            subPlans.put(s, newPlan);\n            List<Operator> preds = this.plan.getPredecessors(s);\n            if (preds != null)\n                planPreds.put(newPlan, new LinkedList<>(preds));\n            log.debug(lro.getAlias() + \" is the root of new chunk\");\n            discoverPartition(s, seenByDFS, newPlan);\n            String nameNode = this.siteAssignment.get(s);\n            String hostname = nameNode.split(\":\")[0];\n            String portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\n            int port = new Integer(portNum);\n            PigOutCluster clusterInfo = getPigOutCluster(hostname, port);\n            long dataIn = computeDataInSize(newPlan);\n            long dataOut = computeDataOutSize(newPlan);\n            addStores(newPlan);\n            addLoads(newPlan);\n            Iterator<Operator> it = newPlan.getOperators();\n            while (it.hasNext()) {\n                Operator op = it.next();\n                op.setPlan(newPlan);\n            }\n            PigOutLogicalChunks chunk;\n            chunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\n            chunk.setAlias(lro.getAlias());\n            mapping.put( newPlan, chunk );\n        }\n        for (LogicalPlan lp : mapping.keySet()) {\n            List<Operator> succs = planSuccs.get(lp);\n            List<Operator> preds = planPreds.get(lp);\n            PigOutLogicalChunks chunk = mapping.get(lp);\n            if (succs != null) {\n                for (Operator succ : succs) {\n                    LogicalPlan succLP = (LogicalPlan) succ.getPlan();\n                    PigOutLogicalChunks succChunk = mapping.get(succLP);\n                    succChunk.addPredecessors(chunk);\n                    log.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n                }\n            }\n            if (preds != null) {\n                for (Operator pred : preds) {\n                    LogicalPlan predLP = (LogicalPlan) pred.getPlan();\n                    PigOutLogicalChunks predChunk = mapping.get(predLP);\n                    chunk.addPredecessors(predChunk);\n                    log.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n                }\n            }\n        }\n        List<PigOutLogicalChunks> list_chunks = new LinkedList<>();\n        for (PigOutLogicalChunks chunk : mapping.values()) {\n            list_chunks.add( chunk );\n        }\n        return list_chunks;\n    }","code_wo_comment":"public List<PigOutLogicalChunks> createLogicalChunks() throws FrontendException {\n        Set<Operator> seenByDFS = new HashSet<Operator>();\n        Map<LogicalPlan, PigOutLogicalChunks> mapping =\n                new HashMap<>();\n        while ( !visitQueue.isEmpty() ) {\n            Operator s = visitQueue.poll();\n            LogicalRelationalOperator lro = (LogicalRelationalOperator) s;\n            log.debug(\"Visit: \" + lro);\n           \n\t\t\n            if (!seenByDFS.add(s)) continue;\n           \n            LogicalPlan newPlan = new LogicalPlan();\n            newPlan.add(s);\n            subPlans.put(s, newPlan);\n            List<Operator> preds = this.plan.getPredecessors(s);\n            if (preds != null)\n                planPreds.put(newPlan, new LinkedList<>(preds));\n            log.debug(lro.getAlias() + \" is the root of new chunk\");\n            discoverPartition(s, seenByDFS, newPlan);\n            String nameNode = this.siteAssignment.get(s);\n            String hostname = nameNode.split(\":\")[0];\n            String portNum = this.context.getProperties().getProperty(hostname + \".job.tracker\").split(\":\")[1];\n            int port = new Integer(portNum);\n            PigOutCluster clusterInfo = getPigOutCluster(hostname, port);\n            long dataIn = computeDataInSize(newPlan);\n            long dataOut = computeDataOutSize(newPlan);\n            addStores(newPlan);\n            addLoads(newPlan);\n            Iterator<Operator> it = newPlan.getOperators();\n            while (it.hasNext()) {\n                Operator op = it.next();\n                op.setPlan(newPlan);\n            }\n            PigOutLogicalChunks chunk;\n            chunk = new PigOutLogicalChunks(newPlan, context, clusterInfo, dataIn, dataOut);\n            chunk.setAlias(lro.getAlias());\n            mapping.put( newPlan, chunk );\n        }\n        for (LogicalPlan lp : mapping.keySet()) {\n            List<Operator> succs = planSuccs.get(lp);\n            List<Operator> preds = planPreds.get(lp);\n            PigOutLogicalChunks chunk = mapping.get(lp);\n            if (succs != null) {\n                for (Operator succ : succs) {\n                    LogicalPlan succLP = (LogicalPlan) succ.getPlan();\n                    PigOutLogicalChunks succChunk = mapping.get(succLP);\n                    succChunk.addPredecessors(chunk);\n                    log.debug(succChunk.getAlias() + \" depends on \" + chunk.getAlias());\n                }\n            }\n            if (preds != null) {\n                for (Operator pred : preds) {\n                    LogicalPlan predLP = (LogicalPlan) pred.getPlan();\n                    PigOutLogicalChunks predChunk = mapping.get(predLP);\n                    chunk.addPredecessors(predChunk);\n                    log.debug(chunk.getAlias() + \" depends on \" + predChunk.getAlias());\n                }\n            }\n        }\n        List<PigOutLogicalChunks> list_chunks = new LinkedList<>();\n        for (PigOutLogicalChunks chunk : mapping.values()) {\n            list_chunks.add( chunk );\n        }\n        return list_chunks;\n    }","cleancode":"public list<pigoutlogicalchunks> createlogicalchunks() throws frontendexception { set<operator> seenbydfs = new hashset<operator>(); map<logicalplan, pigoutlogicalchunks> mapping = new hashmap<>(); while ( !visitqueue.isempty() ) { operator s = visitqueue.poll(); logicalrelationaloperator lro = (logicalrelationaloperator) s; log.debug(\"visit: \" + lro); if (!seenbydfs.add(s)) continue; logicalplan newplan = new logicalplan(); newplan.add(s); subplans.put(s, newplan); list<operator> preds = this.plan.getpredecessors(s); if (preds != null) planpreds.put(newplan, new linkedlist<>(preds)); log.debug(lro.getalias() + \" is the root of new chunk\"); discoverpartition(s, seenbydfs, newplan); string namenode = this.siteassignment.get(s); string hostname = namenode.split(\":\")[0]; string portnum = this.context.getproperties().getproperty(hostname + \".job.tracker\").split(\":\")[1]; int port = new integer(portnum); pigoutcluster clusterinfo = getpigoutcluster(hostname, port); long datain = computedatainsize(newplan); long dataout = computedataoutsize(newplan); addstores(newplan); addloads(newplan); iterator<operator> it = newplan.getoperators(); while (it.hasnext()) { operator op = it.next(); op.setplan(newplan); } pigoutlogicalchunks chunk; chunk = new pigoutlogicalchunks(newplan, context, clusterinfo, datain, dataout); chunk.setalias(lro.getalias()); mapping.put( newplan, chunk ); } for (logicalplan lp : mapping.keyset()) { list<operator> succs = plansuccs.get(lp); list<operator> preds = planpreds.get(lp); pigoutlogicalchunks chunk = mapping.get(lp); if (succs != null) { for (operator succ : succs) { logicalplan succlp = (logicalplan) succ.getplan(); pigoutlogicalchunks succchunk = mapping.get(succlp); succchunk.addpredecessors(chunk); log.debug(succchunk.getalias() + \" depends on \" + chunk.getalias()); } } if (preds != null) { for (operator pred : preds) { logicalplan predlp = (logicalplan) pred.getplan(); pigoutlogicalchunks predchunk = mapping.get(predlp); chunk.addpredecessors(predchunk); log.debug(chunk.getalias() + \" depends on \" + predchunk.getalias()); } } } list<pigoutlogicalchunks> list_chunks = new linkedlist<>(); for (pigoutlogicalchunks chunk : mapping.values()) { list_chunks.add( chunk ); } return list_chunks; }","repo":"kyunghoj\/pigout","label":[1,0,0,0]}
{"id":21065,"original_code":"@Bean\n    public ListFactoryBean userDnList() {\n        ListFactoryBean bean = new ListFactoryBean();\n        bean.setTargetListClass(ArrayList.class);\n        \/\/ TODO Add values to this list to allow more distinguished name patterns.\n        \/\/      If preferable, ldap.dn can be removed when there is more than one value to avoid confusion.\n        List<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n                \"cn={0},OU=WCT users,DC=webcurator,DC=org\") \/\/,\n                \/\/ TODO CONFIGURATION\n                \/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\",\n                \/\/\"cn={0},OU=WCT users,DC=webcurator,DC=org\"\n        );\n        bean.setSourceList(sourceList);\n        return bean;\n    }","code_wo_comment":"@Bean\n    public ListFactoryBean userDnList() {\n        ListFactoryBean bean = new ListFactoryBean();\n        bean.setTargetListClass(ArrayList.class);\n       \n       \n        List<String> sourceList = new ArrayList<String>(Arrays.asList(\"${ldap.dn}\",\n                \"cn={0},OU=WCT users,DC=webcurator,DC=org\")\n               \n               \n               \n        );\n        bean.setSourceList(sourceList);\n        return bean;\n    }","cleancode":"@bean public listfactorybean userdnlist() { listfactorybean bean = new listfactorybean(); bean.settargetlistclass(arraylist.class); list<string> sourcelist = new arraylist<string>(arrays.aslist(\"${ldap.dn}\", \"cn={0},ou=wct users,dc=webcurator,dc=org\") ); bean.setsourcelist(sourcelist); return bean; }","repo":"mbreemhaar\/webcurator","label":[1,1,0,0]}
{"id":21104,"original_code":"private static String safeUri(String uri) {\n        \/\/ todo: make this way more safe\n        return uri.replace(\" \", \"%20\");\n    }","code_wo_comment":"private static String safeUri(String uri) {\n       \n        return uri.replace(\" \", \"%20\");\n    }","cleancode":"private static string safeuri(string uri) { return uri.replace(\" \", \"%20\"); }","repo":"mikiec84\/blueprints","label":[1,0,0,0]}
{"id":13004,"original_code":"public static void main(String[] args) {\n        printoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n    }","code_wo_comment":"public static void main(String[] args) {\n        printoutModelFile(\"\/Users\/aidancbrady\/Documents\/Mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\");\n    }","cleancode":"public static void main(string[] args) { printoutmodelfile(\"\/users\/aidancbrady\/documents\/mekanism\/src\/main\/resources\/assets\/mekanism\/models\/block\/digital_miner.json\"); }","repo":"marcus8448\/Mekanism","label":[1,0,0,0]}
{"id":13116,"original_code":"private String compoundProduce( JavaFileManager.Location location, Set<ITypeManifold> sps, String fqn, DiagnosticListener<JavaFileObject> errorHandler )\n  {\n    ITypeManifold found = null;\n    String result = \"\";\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == Primary ||\n          sp.getContributorKind() == Partial )\n      {\n        if( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n        {\n          \/\/## todo: use location to select more specifically (in Java 9+ with the location's module)\n          List<IFile> files = sp.findFilesForType( fqn );\n          JavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\n          errorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n            \"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n            \"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n            \"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n            \"If the former, consider renaming one or more of the resource files.\\n\" +\n            \"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n        }\n        else\n        {\n          found = sp;\n          result = sp.contribute( location, fqn, false, result, errorHandler );\n        }\n      }\n    }\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == ContributorKind.Supplemental )\n      {\n        result = sp.contribute( location, fqn, false, result, errorHandler );\n      }\n    }\n    return result;\n  }","code_wo_comment":"private String compoundProduce( JavaFileManager.Location location, Set<ITypeManifold> sps, String fqn, DiagnosticListener<JavaFileObject> errorHandler )\n  {\n    ITypeManifold found = null;\n    String result = \"\";\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == Primary ||\n          sp.getContributorKind() == Partial )\n      {\n        if( found != null && (found.getContributorKind() == Primary || sp.getContributorKind() == Primary) )\n        {\n         \n          List<IFile> files = sp.findFilesForType( fqn );\n          JavaFileObject file = new SourceJavaFileObject( files.get( 0 ).toURI() );\n          errorHandler.report( new JavacDiagnostic( file, Diagnostic.Kind.ERROR, 0, 1, 1,\n            \"The type, \" + fqn + \", has conflicting type manifolds:\\n\" +\n            \"'\" + found.getClass().getName() + \"' and '\" + sp.getClass().getName() + \"'.\\n\" +\n            \"Either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" +\n            \"If the former, consider renaming one or more of the resource files.\\n\" +\n            \"If the latter, you must remove one or more of the type manifold libraries.\" ) );\n        }\n        else\n        {\n          found = sp;\n          result = sp.contribute( location, fqn, false, result, errorHandler );\n        }\n      }\n    }\n    for( ITypeManifold sp: sps )\n    {\n      if( sp.getContributorKind() == ContributorKind.Supplemental )\n      {\n        result = sp.contribute( location, fqn, false, result, errorHandler );\n      }\n    }\n    return result;\n  }","cleancode":"private string compoundproduce( javafilemanager.location location, set<itypemanifold> sps, string fqn, diagnosticlistener<javafileobject> errorhandler ) { itypemanifold found = null; string result = \"\"; for( itypemanifold sp: sps ) { if( sp.getcontributorkind() == primary || sp.getcontributorkind() == partial ) { if( found != null && (found.getcontributorkind() == primary || sp.getcontributorkind() == primary) ) { list<ifile> files = sp.findfilesfortype( fqn ); javafileobject file = new sourcejavafileobject( files.get( 0 ).touri() ); errorhandler.report( new javacdiagnostic( file, diagnostic.kind.error, 0, 1, 1, \"the type, \" + fqn + \", has conflicting type manifolds:\\n\" + \"'\" + found.getclass().getname() + \"' and '\" + sp.getclass().getname() + \"'.\\n\" + \"either two or more resource files have the same base name or the project depends on two or more type manifolds that target the same resource type.\\n\" + \"if the former, consider renaming one or more of the resource files.\\n\" + \"if the latter, you must remove one or more of the type manifold libraries.\" ) ); } else { found = sp; result = sp.contribute( location, fqn, false, result, errorhandler ); } } } for( itypemanifold sp: sps ) { if( sp.getcontributorkind() == contributorkind.supplemental ) { result = sp.contribute( location, fqn, false, result, errorhandler ); } } return result; }","repo":"manifold-systems\/manifold","label":[1,0,0,0]}
{"id":13241,"original_code":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\n        if (mDrawingPie != null) {\n            if (degree >= mDrawingPie.toAngle \/ 2) {\n                if (!mDrawingPie.hasCached) {\n                    \/\/ fix anim duration too short\n                    PieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\n                    if (preWrapper != null && !preWrapper.hasCached) {\n                        preWrapper.hasCached = true;\n                        mCachedDrawWrappers.add(preWrapper);\n                    }\n                    mCachedDrawWrappers.add(mDrawingPie);\n                    mDrawingPie.hasCached = true;\n                }\n            }\n        }\n        mDrawingPie = infoWrapper;\n        animAngle = degree;\n        callInvalidate();\n    }","code_wo_comment":"public void setCurPie(PieInfoWrapperr infoWrapper, float degree) {\n        if (mDrawingPie != null) {\n            if (degree >= mDrawingPie.toAngle \/ 2) {\n                if (!mDrawingPie.hasCached) {\n                   \n                    PieInfoWrapperr preWrapper = mDrawingPie.preWrapper;\n                    if (preWrapper != null && !preWrapper.hasCached) {\n                        preWrapper.hasCached = true;\n                        mCachedDrawWrappers.add(preWrapper);\n                    }\n                    mCachedDrawWrappers.add(mDrawingPie);\n                    mDrawingPie.hasCached = true;\n                }\n            }\n        }\n        mDrawingPie = infoWrapper;\n        animAngle = degree;\n        callInvalidate();\n    }","cleancode":"public void setcurpie(pieinfowrapperr infowrapper, float degree) { if (mdrawingpie != null) { if (degree >= mdrawingpie.toangle \/ 2) { if (!mdrawingpie.hascached) { pieinfowrapperr prewrapper = mdrawingpie.prewrapper; if (prewrapper != null && !prewrapper.hascached) { prewrapper.hascached = true; mcacheddrawwrappers.add(prewrapper); } mcacheddrawwrappers.add(mdrawingpie); mdrawingpie.hascached = true; } } } mdrawingpie = infowrapper; animangle = degree; callinvalidate(); }","repo":"linyingfa\/AnimatedPieView-master","label":[1,0,0,0]}
{"id":21553,"original_code":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\n\t\t\tthrows IllegalArgumentException {\n\t\t\/\/ TODO Auto-generated method stub\n\t\t\/\/Read data from hdfs\n\t\tList<String> results = readAllData(filePath,true); \/\/Only read limited line data(if the data length over max length)\n\t\tList<LineChart> lineCharts = new ArrayList<LineChart>();\n\t\tfor(String  selectedCol : columnNames)\n\t\t{\n\t\t\tLineChart lineChart =  singleLineGen(results, dataType, columns, selectedCol);\n\t\t\tif(lineChart == null)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tlineCharts.add(lineChart);\n\t\t}\n\t\treturn lineCharts;\n\t}","code_wo_comment":"public List<LineChart> LineChartGen(String filePath, String dataType, List<String> columns, List<String> columnNames)\n\t\t\tthrows IllegalArgumentException {\n\t\n\t\n\t\tList<String> results = readAllData(filePath,true);\n\t\tList<LineChart> lineCharts = new ArrayList<LineChart>();\n\t\tfor(String  selectedCol : columnNames)\n\t\t{\n\t\t\tLineChart lineChart =  singleLineGen(results, dataType, columns, selectedCol);\n\t\t\tif(lineChart == null)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tlineCharts.add(lineChart);\n\t\t}\n\t\treturn lineCharts;\n\t}","cleancode":"public list<linechart> linechartgen(string filepath, string datatype, list<string> columns, list<string> columnnames) throws illegalargumentexception { list<string> results = readalldata(filepath,true); list<linechart> linecharts = new arraylist<linechart>(); for(string selectedcol : columnnames) { linechart linechart = singlelinegen(results, datatype, columns, selectedcol); if(linechart == null) continue; else linecharts.add(linechart); } return linecharts; }","repo":"milkboylyf\/EasyML","label":[0,1,0,0]}
{"id":13513,"original_code":"@Override\n    public Value evaluate(BlockContext ctx) {\n        ctx.beforeExpression(this);\n        FunctionBlock funcBlock = null;\n        BlockContext callContext = ctx;\n        if (object != null) {\n            \/\/ method call on an object\n            if (VariableReference.isSelfReference(object.getName())) {\n                \/\/ self object reference?\n                funcBlock = callContext.retrieveLocalFunction(functionName);\n                throw new RockstarRuntimeException(\"self reference\");\n            } else if (VariableReference.isParentReference(object.getName())) {\n                \/\/ parent object reference\n                \/\/ find the caller object context\n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n                \/\/ get the parent object, if exists\n                RockObject parentObj = callerObj.getSuperObject();\n                if (parentObj != null) {\n                    \/\/ find the context that contains the function starting the parent\n                    callContext = parentObj.getContextForFunction(functionName);\n                    \/\/ the call context must be the same object as the caller object\n                    if ((callContext != null)\n                            && (callContext instanceof RockObject)\n                            && (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n                        \/\/ get the method from that context\n                        funcBlock = callContext.retrieveLocalFunction(functionName);\n                    }\n                } else {\n                    throw new RockstarRuntimeException(\"parent reference in non-inherited class\");\n                }\n            } else {\n                \/\/ object reference\n                ctx.beforeExpression(object);\n                Value objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\n                if (objValue == null) {\n                    throw new RockstarRuntimeException(\"Object not found: \" + object);\n                }\n                if (objValue.isObject()) {\n                    \/\/ get the object itself\n                    RockObject objContext = objValue.getObject();\n                    \/\/ find the context that contains the function\n                    callContext = objContext.getContextForFunction(functionName);\n                    if (callContext == null) {\n                        throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                    }\n                    \/\/ get the method from the object\n                    funcBlock = callContext.retrieveLocalFunction(functionName);\n                } else {\n                    throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                }\n            }\n        } else {\n            \/\/ simple method call syntax\n            if (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n                \/\/ unqualified \"parent\" function: must be a parent constructor reference\n                \/\/ find the caller object context\n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n                \/\/ get the parent object, if exists\n                RockObject parentObj = callerObj.getSuperObject();\n                \/\/ TODO check if it is called in a constructor\n                if (parentObj != null) {\n                    \/\/ context is the parent object\n                    callContext = parentObj;\n                    \/\/ get the constructor from the parent context\n                    funcBlock = parentObj.getConstructor();\n                } else {\n                    throw new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n                }\n            } else {\n                \/\/ pure function call or unqualified call in an object context?\n                BlockContext funcCtx = ctx.getContextForFunction(functionName);\n                if (funcCtx == null) {\n                    \/\/ function not found, or function exists only in subcontexts\n                    throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n                }\n                \/\/ we found the function, now we need to find the overrides, if it is on an object\n                if (funcCtx instanceof RockObject) {\n                    \/\/ search the function from the top of the object levels\n                    funcCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n                } else {\n                    \/\/ find the containing context by name\n                    funcCtx = ctx.getContextForFunction(functionName);\n                }\n                \/\/ retrieve the function code\n                funcBlock = funcCtx.retrieveLocalFunction(functionName);\n            }\n        }\n        Value retValue;\n        if (funcBlock != null) {\n            List<Expression> params = getParameters();\n            List<Value> values = new ArrayList<>(params.size());\n            params.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n            \/\/ call the functon\n            retValue = funcBlock.call(callContext, values);\n        } else {\n            if (object == null) {\n                throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n            }\n            throw new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n        }\n        \/\/ return the return value\n        return ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n    }","code_wo_comment":"@Override\n    public Value evaluate(BlockContext ctx) {\n        ctx.beforeExpression(this);\n        FunctionBlock funcBlock = null;\n        BlockContext callContext = ctx;\n        if (object != null) {\n           \n            if (VariableReference.isSelfReference(object.getName())) {\n               \n                funcBlock = callContext.retrieveLocalFunction(functionName);\n                throw new RockstarRuntimeException(\"self reference\");\n            } else if (VariableReference.isParentReference(object.getName())) {\n               \n               \n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent reference in a non-object context\"));\n               \n                RockObject parentObj = callerObj.getSuperObject();\n                if (parentObj != null) {\n                   \n                    callContext = parentObj.getContextForFunction(functionName);\n                   \n                    if ((callContext != null)\n                            && (callContext instanceof RockObject)\n                            && (((RockObject) callContext).getObjId() == callerObj.getObjId())) {\n                       \n                        funcBlock = callContext.retrieveLocalFunction(functionName);\n                    }\n                } else {\n                    throw new RockstarRuntimeException(\"parent reference in non-inherited class\");\n                }\n            } else {\n               \n                ctx.beforeExpression(object);\n                Value objValue = ctx.afterExpression(object, ctx.getVariableValue(object));\n                if (objValue == null) {\n                    throw new RockstarRuntimeException(\"Object not found: \" + object);\n                }\n                if (objValue.isObject()) {\n                   \n                    RockObject objContext = objValue.getObject();\n                   \n                    callContext = objContext.getContextForFunction(functionName);\n                    if (callContext == null) {\n                        throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                    }\n                   \n                    funcBlock = callContext.retrieveLocalFunction(functionName);\n                } else {\n                    throw new RockstarRuntimeException(\"Invalid method call \" + functionName + \" on a \" + objValue.getType().name() + \" type variable \" + object);\n                }\n            }\n        } else {\n           \n            if (VariableReference.isParentReference(functionName) && ctx.getThisObjectCtx().isPresent()) {\n               \n               \n                RockObject callerObj = ctx.getThisObjectCtx()\n                        .orElseThrow(() -> new RockstarRuntimeException(\"parent constructor call in a non-object context\"));\n               \n                RockObject parentObj = callerObj.getSuperObject();\n               \n                if (parentObj != null) {\n                   \n                    callContext = parentObj;\n                   \n                    funcBlock = parentObj.getConstructor();\n                } else {\n                    throw new RockstarRuntimeException(\"parent constructor reference in non-inherited class\");\n                }\n            } else {\n               \n                BlockContext funcCtx = ctx.getContextForFunction(functionName);\n                if (funcCtx == null) {\n                   \n                    throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n                }\n               \n                if (funcCtx instanceof RockObject) {\n                   \n                    funcCtx = ((RockObject) funcCtx).getTopObject().getContextForFunction(functionName);\n                } else {\n                   \n                    funcCtx = ctx.getContextForFunction(functionName);\n                }\n               \n                funcBlock = funcCtx.retrieveLocalFunction(functionName);\n            }\n        }\n        Value retValue;\n        if (funcBlock != null) {\n            List<Expression> params = getParameters();\n            List<Value> values = new ArrayList<>(params.size());\n            params.forEach((expr) -> values.add(expr.evaluate(ctx).asParameter()));\n           \n            retValue = funcBlock.call(callContext, values);\n        } else {\n            if (object == null) {\n                throw new RockstarRuntimeException(\"Undefined function: \" + functionName);\n            }\n            throw new RockstarRuntimeException(\"Undefined method: \" + functionName + \" on class \" + object.getName());\n        }\n       \n        return ctx.afterExpression(this, retValue == null ? Value.NULL : retValue);\n    }","cleancode":"@override public value evaluate(blockcontext ctx) { ctx.beforeexpression(this); functionblock funcblock = null; blockcontext callcontext = ctx; if (object != null) { if (variablereference.isselfreference(object.getname())) { funcblock = callcontext.retrievelocalfunction(functionname); throw new rockstarruntimeexception(\"self reference\"); } else if (variablereference.isparentreference(object.getname())) { rockobject callerobj = ctx.getthisobjectctx() .orelsethrow(() -> new rockstarruntimeexception(\"parent reference in a non-object context\")); rockobject parentobj = callerobj.getsuperobject(); if (parentobj != null) { callcontext = parentobj.getcontextforfunction(functionname); if ((callcontext != null) && (callcontext instanceof rockobject) && (((rockobject) callcontext).getobjid() == callerobj.getobjid())) { funcblock = callcontext.retrievelocalfunction(functionname); } } else { throw new rockstarruntimeexception(\"parent reference in non-inherited class\"); } } else { ctx.beforeexpression(object); value objvalue = ctx.afterexpression(object, ctx.getvariablevalue(object)); if (objvalue == null) { throw new rockstarruntimeexception(\"object not found: \" + object); } if (objvalue.isobject()) { rockobject objcontext = objvalue.getobject(); callcontext = objcontext.getcontextforfunction(functionname); if (callcontext == null) { throw new rockstarruntimeexception(\"invalid method call \" + functionname + \" on a \" + objvalue.gettype().name() + \" type variable \" + object); } funcblock = callcontext.retrievelocalfunction(functionname); } else { throw new rockstarruntimeexception(\"invalid method call \" + functionname + \" on a \" + objvalue.gettype().name() + \" type variable \" + object); } } } else { if (variablereference.isparentreference(functionname) && ctx.getthisobjectctx().ispresent()) { rockobject callerobj = ctx.getthisobjectctx() .orelsethrow(() -> new rockstarruntimeexception(\"parent constructor call in a non-object context\")); rockobject parentobj = callerobj.getsuperobject(); if (parentobj != null) { callcontext = parentobj; funcblock = parentobj.getconstructor(); } else { throw new rockstarruntimeexception(\"parent constructor reference in non-inherited class\"); } } else { blockcontext funcctx = ctx.getcontextforfunction(functionname); if (funcctx == null) { throw new rockstarruntimeexception(\"undefined function: \" + functionname); } if (funcctx instanceof rockobject) { funcctx = ((rockobject) funcctx).gettopobject().getcontextforfunction(functionname); } else { funcctx = ctx.getcontextforfunction(functionname); } funcblock = funcctx.retrievelocalfunction(functionname); } } value retvalue; if (funcblock != null) { list<expression> params = getparameters(); list<value> values = new arraylist<>(params.size()); params.foreach((expr) -> values.add(expr.evaluate(ctx).asparameter())); retvalue = funcblock.call(callcontext, values); } else { if (object == null) { throw new rockstarruntimeexception(\"undefined function: \" + functionname); } throw new rockstarruntimeexception(\"undefined method: \" + functionname + \" on class \" + object.getname()); } return ctx.afterexpression(this, retvalue == null ? value.null : retvalue); }","repo":"mikesep\/rocky","label":[1,1,0,0]}
{"id":21954,"original_code":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\n    InputSource input = null;\n    final String systemId = source.getSystemId();\n    try {\n      \/\/ Try to get InputSource from SAXSource input\n      if (source instanceof SAXSource) {\n        final SAXSource sax = (SAXSource) source;\n        input = sax.getInputSource();\n        \/\/ Pass the SAX parser to the compiler\n        try {\n          XMLReader reader = sax.getXMLReader();\n          \/*\n           * Fix for bug 24695 According to JAXP 1.2 specification if a\n           * SAXSource is created using a SAX InputSource the Transformer or\n           * TransformerFactory creates a reader via the XMLReaderFactory if\n           * setXMLReader is not used\n           *\/\n          if (reader == null) {\n            try {\n              reader = XMLReaderFactory.createXMLReader();\n            } catch (final Exception e) {\n              try {\n                \/\/ Incase there is an exception thrown\n                \/\/ resort to JAXP\n                final SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setNamespaceAware(true);\n                if (xsltc.isSecureProcessing()) {\n                  try {\n                    parserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                  } catch (final SAXException se) {\n                  }\n                }\n                reader = parserFactory.newSAXParser().getXMLReader();\n              } catch (final ParserConfigurationException pce) {\n                throw new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n              }\n            }\n          }\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\n          xsltc.setXMLReader(reader);\n        } catch (final SAXNotRecognizedException snre) {\n          throw new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n        } catch (final SAXNotSupportedException snse) {\n          throw new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n        } catch (final SAXException se) {\n          throw new TransformerConfigurationException(\"SAXException \", se);\n        }\n      }\n      \/\/ handle DOMSource\n      else if (source instanceof DOMSource) {\n        final DOMSource domsrc = (DOMSource) source;\n        final Document dom = (Document) domsrc.getNode();\n        final DOM2SAX dom2sax = new DOM2SAX(dom);\n        xsltc.setXMLReader(dom2sax);\n        \/\/ Try to get SAX InputSource from DOM Source.\n        input = SAXSource.sourceToInputSource(source);\n        if (input == null) {\n          input = new InputSource(domsrc.getSystemId());\n        }\n      }\n      \/\/ Try to get InputStream or Reader from StreamSource\n      else if (source instanceof StreamSource) {\n        final StreamSource stream = (StreamSource) source;\n        final InputStream istream = stream.getInputStream();\n        final Reader reader = stream.getReader();\n        xsltc.setXMLReader(null); \/\/ Clear old XML reader\n        \/\/ Create InputSource from Reader or InputStream in Source\n        if (istream != null) {\n          input = new InputSource(istream);\n        } else if (reader != null) {\n          input = new InputSource(reader);\n        } else {\n          input = new InputSource(systemId);\n        }\n      } else {\n        final ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\n        throw new TransformerConfigurationException(err.toString());\n      }\n      input.setSystemId(systemId);\n    } catch (final NullPointerException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\n      throw new TransformerConfigurationException(err.toString());\n    } catch (final SecurityException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\n      throw new TransformerConfigurationException(err.toString());\n    }\n    return input;\n  }","code_wo_comment":"public static InputSource getInputSource(XSLTC xsltc, Source source) throws TransformerConfigurationException {\n    InputSource input = null;\n    final String systemId = source.getSystemId();\n    try {\n     \n      if (source instanceof SAXSource) {\n        final SAXSource sax = (SAXSource) source;\n        input = sax.getInputSource();\n       \n        try {\n          XMLReader reader = sax.getXMLReader();\n         \n          if (reader == null) {\n            try {\n              reader = XMLReaderFactory.createXMLReader();\n            } catch (final Exception e) {\n              try {\n               \n               \n                final SAXParserFactory parserFactory = SAXParserFactory.newInstance();\n                parserFactory.setNamespaceAware(true);\n                if (xsltc.isSecureProcessing()) {\n                  try {\n                    parserFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                  } catch (final SAXException se) {\n                  }\n                }\n                reader = parserFactory.newSAXParser().getXMLReader();\n              } catch (final ParserConfigurationException pce) {\n                throw new TransformerConfigurationException(\"ParserConfigurationException\", pce);\n              }\n            }\n          }\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true);\n          reader.setFeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false);\n          xsltc.setXMLReader(reader);\n        } catch (final SAXNotRecognizedException snre) {\n          throw new TransformerConfigurationException(\"SAXNotRecognizedException \", snre);\n        } catch (final SAXNotSupportedException snse) {\n          throw new TransformerConfigurationException(\"SAXNotSupportedException \", snse);\n        } catch (final SAXException se) {\n          throw new TransformerConfigurationException(\"SAXException \", se);\n        }\n      }\n     \n      else if (source instanceof DOMSource) {\n        final DOMSource domsrc = (DOMSource) source;\n        final Document dom = (Document) domsrc.getNode();\n        final DOM2SAX dom2sax = new DOM2SAX(dom);\n        xsltc.setXMLReader(dom2sax);\n       \n        input = SAXSource.sourceToInputSource(source);\n        if (input == null) {\n          input = new InputSource(domsrc.getSystemId());\n        }\n      }\n     \n      else if (source instanceof StreamSource) {\n        final StreamSource stream = (StreamSource) source;\n        final InputStream istream = stream.getInputStream();\n        final Reader reader = stream.getReader();\n        xsltc.setXMLReader(null);\n       \n        if (istream != null) {\n          input = new InputSource(istream);\n        } else if (reader != null) {\n          input = new InputSource(reader);\n        } else {\n          input = new InputSource(systemId);\n        }\n      } else {\n        final ErrorMsg err = new ErrorMsg(Messages.get().jaxpUnknownSourceErr());\n        throw new TransformerConfigurationException(err.toString());\n      }\n      input.setSystemId(systemId);\n    } catch (final NullPointerException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().jaxpNoSourceErr(\"TransformerFactory.newTemplates()\"));\n      throw new TransformerConfigurationException(err.toString());\n    } catch (final SecurityException e) {\n      final ErrorMsg err = new ErrorMsg(Messages.get().fileAccessErr(systemId), -1);\n      throw new TransformerConfigurationException(err.toString());\n    }\n    return input;\n  }","cleancode":"public static inputsource getinputsource(xsltc xsltc, source source) throws transformerconfigurationexception { inputsource input = null; final string systemid = source.getsystemid(); try { if (source instanceof saxsource) { final saxsource sax = (saxsource) source; input = sax.getinputsource(); try { xmlreader reader = sax.getxmlreader(); if (reader == null) { try { reader = xmlreaderfactory.createxmlreader(); } catch (final exception e) { try { final saxparserfactory parserfactory = saxparserfactory.newinstance(); parserfactory.setnamespaceaware(true); if (xsltc.issecureprocessing()) { try { parserfactory.setfeature(xmlconstants.feature_secure_processing, true); } catch (final saxexception se) { } } reader = parserfactory.newsaxparser().getxmlreader(); } catch (final parserconfigurationexception pce) { throw new transformerconfigurationexception(\"parserconfigurationexception\", pce); } } } reader.setfeature(\"http:\/\/xml.org\/sax\/features\/namespaces\", true); reader.setfeature(\"http:\/\/xml.org\/sax\/features\/namespace-prefixes\", false); xsltc.setxmlreader(reader); } catch (final saxnotrecognizedexception snre) { throw new transformerconfigurationexception(\"saxnotrecognizedexception \", snre); } catch (final saxnotsupportedexception snse) { throw new transformerconfigurationexception(\"saxnotsupportedexception \", snse); } catch (final saxexception se) { throw new transformerconfigurationexception(\"saxexception \", se); } } else if (source instanceof domsource) { final domsource domsrc = (domsource) source; final document dom = (document) domsrc.getnode(); final dom2sax dom2sax = new dom2sax(dom); xsltc.setxmlreader(dom2sax); input = saxsource.sourcetoinputsource(source); if (input == null) { input = new inputsource(domsrc.getsystemid()); } } else if (source instanceof streamsource) { final streamsource stream = (streamsource) source; final inputstream istream = stream.getinputstream(); final reader reader = stream.getreader(); xsltc.setxmlreader(null); if (istream != null) { input = new inputsource(istream); } else if (reader != null) { input = new inputsource(reader); } else { input = new inputsource(systemid); } } else { final errormsg err = new errormsg(messages.get().jaxpunknownsourceerr()); throw new transformerconfigurationexception(err.tostring()); } input.setsystemid(systemid); } catch (final nullpointerexception e) { final errormsg err = new errormsg(messages.get().jaxpnosourceerr(\"transformerfactory.newtemplates()\")); throw new transformerconfigurationexception(err.tostring()); } catch (final securityexception e) { final errormsg err = new errormsg(messages.get().fileaccesserr(systemid), -1); throw new transformerconfigurationexception(err.tostring()); } return input; }","repo":"lyca\/lyca-xslt","label":[0,0,1,0]}
{"id":30244,"original_code":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\n        switch (code) {\n            case UP:\n                move(new Point(-1, 0),\"\");\n                break;\n            case RIGHT:\n                move(new Point(0, 1),\"\");\n                break;\n            case DOWN:\n                move(new Point(1, 0),\"\");\n                break;\n            case LEFT:\n                move(new Point(0, -1),\"\");\n                break;\n            default:\n                \/\/ TODO: implement something funny.\n        }\n        if (isDebugActive()) {\n            System.out.println(code);\n        }\n    }","code_wo_comment":"public void handleKey(KeyCode code) throws IOException, ClassNotFoundException {\n        switch (code) {\n            case UP:\n                move(new Point(-1, 0),\"\");\n                break;\n            case RIGHT:\n                move(new Point(0, 1),\"\");\n                break;\n            case DOWN:\n                move(new Point(1, 0),\"\");\n                break;\n            case LEFT:\n                move(new Point(0, -1),\"\");\n                break;\n            default:\n               \n        }\n        if (isDebugActive()) {\n            System.out.println(code);\n        }\n    }","cleancode":"public void handlekey(keycode code) throws ioexception, classnotfoundexception { switch (code) { case up: move(new point(-1, 0),\"\"); break; case right: move(new point(0, 1),\"\"); break; case down: move(new point(1, 0),\"\"); break; case left: move(new point(0, -1),\"\"); break; default: } if (isdebugactive()) { system.out.println(code); } }","repo":"krisiney\/SOKOBANFX-DMS-2020","label":[0,1,0,0]}
{"id":22278,"original_code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"net onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n            if (subscriber != null && !subscriber.isUnsubscribed()) {\n                subscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n            }\n        }","code_wo_comment":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"net onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n            if (subscriber != null && !subscriber.isUnsubscribed()) {\n                subscriber.onNext(o)","cleancode":"@override public void onnext(t o) { if (debug) log.i(tag, \"net onnext o:\" + o); observablewrapper.setdata(o); logthread(\"\"); if (debug) log.e(tag, \" check subscriber :\" + subscriber + \" isunsubscribed:\" + subscriber.isunsubscribed()); if (subscriber != null && !subscriber.isunsubscribed()) { subscriber.onnext(o)","repo":"ming1991\/mingop","label":[0,0,1,0]}
{"id":22279,"original_code":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"cache onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (netLatch.getCount() > 0) {\n                if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n                if (subscriber != null && !subscriber.isUnsubscribed()) {\n                    subscriber.onNext(o);\/\/ FIXME: issue A:\u5916\u9762\u5982\u679cObservableOn \u5176\u4ed6\u7ebf\u7a0b,\u5c06\u4f1a\u662f\u5f02\u6b65\u64cd\u4f5c,\u5982\u679c\u5728\u5b9e\u9645\u7684onNext\u8c03\u7528\u4e4b\u524d,\u53d1\u751f\u4e86onComplete\u6216\u8005onError,\u5c06\u4f1aunsubscribe,\u5bfc\u81f4onNext\u6ca1\u6709\u88ab\u8c03\u7528\n                }\n            } else {\n                if (debug) Log.e(TAG, \"net result had been load,so cache is not need to load\");\n            }\n        }","code_wo_comment":"@Override\n        public void onNext(T o) {\n            if (debug) Log.i(TAG, \"cache onNext o:\" + o);\n            observableWrapper.setData(o);\n            logThread(\"\");\n            if (netLatch.getCount() > 0) {\n                if (debug) Log.e(TAG, \" check subscriber :\" + subscriber + \" isUnsubscribed:\" + subscriber.isUnsubscribed());\n                if (subscriber != null && !subscriber.isUnsubscribed()) {\n                    subscriber.onNext(o)\"net result had been load,so cache is not need to load\");\n            }\n        }","cleancode":"@override public void onnext(t o) { if (debug) log.i(tag, \"cache onnext o:\" + o); observablewrapper.setdata(o); logthread(\"\"); if (netlatch.getcount() > 0) { if (debug) log.e(tag, \" check subscriber :\" + subscriber + \" isunsubscribed:\" + subscriber.isunsubscribed()); if (subscriber != null && !subscriber.isunsubscribed()) { subscriber.onnext(o)\"net result had been load,so cache is not need to load\"); } }","repo":"ming1991\/mingop","label":[0,0,1,0]}
{"id":14123,"original_code":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","code_wo_comment":"public abstract Iterable<Tuple2<K, V>> doCall(final T t) throws Exception;","cleancode":"public abstract iterable<tuple2<k, v>> docall(final t t) throws exception;","repo":"lordjoe\/SparkAccumulators","label":[0,1,0,0]}
{"id":22556,"original_code":"private boolean updateAddressFilter(String filter)\n\t{\n\t\tString[] pieces = filter.split(\"\/\");\n\t\tif(pieces.length != 2)\n\t\t{\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tInetAddress new_filter_address;\n\t\tInetAddress new_filter_mask;\n\t\tboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\n\t\ttry {\n\t\t\tnew_filter_address = InetAddress.getByName(pieces[0]);\n\t\t\t\/\/ compute the subnet mask address\n\t\t\tbyte[] byte_mask = new byte[4];\n\t\t\tint slash = Integer.parseInt(pieces[1]);\n\t\t\t\/\/ compute the mask address \n\t\t\t\/\/ there is probably a way easier way to do this\n\t\t\tfor (int j=0; slash-- > 0; j++) {\n\t\t\t\tif (j<8)  byte_mask[0] += Math.pow(2,j);\n\t\t\t\tif (j<16) byte_mask[1] += Math.pow(2,j-8);\n\t\t\t\tif (j<24) byte_mask[2] += Math.pow(2,j-16);\n\t\t\t\tif (j<32) byte_mask[3] += Math.pow(2,j-24);\n\t\t\t}\n\t\t\tnew_filter_mask = InetAddress.getByAddress(byte_mask);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tip_filter_enabled = new_filter_enabled;\n\t\tfilter_address = new_filter_address;\n\t\tfilter_mask = new_filter_mask;\n\t\tfireExpressionChangedEvent();\n\t\t\/\/TODO: make data listen to this so that we don't need this call\n\t\tdata.setFilterPredicate(this);\n\t\tSystem.out.println(\"Updating filter succeeded!\");\n\t\tsearchTextField.setBackground(Color.WHITE);\n\t\treturn true;\n\t}","code_wo_comment":"private boolean updateAddressFilter(String filter)\n\t{\n\t\tString[] pieces = filter.split(\"\/\");\n\t\tif(pieces.length != 2)\n\t\t{\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tInetAddress new_filter_address;\n\t\tInetAddress new_filter_mask;\n\t\tboolean new_filter_enabled = !(pieces[1].equals(\"0\"));\n\t\ttry {\n\t\t\tnew_filter_address = InetAddress.getByName(pieces[0]);\n\t\t\n\t\t\tbyte[] byte_mask = new byte[4];\n\t\t\tint slash = Integer.parseInt(pieces[1]);\n\t\t\n\t\t\n\t\t\tfor (int j=0; slash-- > 0; j++) {\n\t\t\t\tif (j<8)  byte_mask[0] += Math.pow(2,j);\n\t\t\t\tif (j<16) byte_mask[1] += Math.pow(2,j-8);\n\t\t\t\tif (j<24) byte_mask[2] += Math.pow(2,j-16);\n\t\t\t\tif (j<32) byte_mask[3] += Math.pow(2,j-24);\n\t\t\t}\n\t\t\tnew_filter_mask = InetAddress.getByAddress(byte_mask);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tsearchTextField.setBackground(Color.RED);\n\t\t\treturn false;\n\t\t}\n\t\tip_filter_enabled = new_filter_enabled;\n\t\tfilter_address = new_filter_address;\n\t\tfilter_mask = new_filter_mask;\n\t\tfireExpressionChangedEvent();\n\t\n\t\tdata.setFilterPredicate(this);\n\t\tSystem.out.println(\"Updating filter succeeded!\");\n\t\tsearchTextField.setBackground(Color.WHITE);\n\t\treturn true;\n\t}","cleancode":"private boolean updateaddressfilter(string filter) { string[] pieces = filter.split(\"\/\"); if(pieces.length != 2) { searchtextfield.setbackground(color.red); return false; } inetaddress new_filter_address; inetaddress new_filter_mask; boolean new_filter_enabled = !(pieces[1].equals(\"0\")); try { new_filter_address = inetaddress.getbyname(pieces[0]); byte[] byte_mask = new byte[4]; int slash = integer.parseint(pieces[1]); for (int j=0; slash-- > 0; j++) { if (j<8) byte_mask[0] += math.pow(2,j); if (j<16) byte_mask[1] += math.pow(2,j-8); if (j<24) byte_mask[2] += math.pow(2,j-16); if (j<32) byte_mask[3] += math.pow(2,j-24); } new_filter_mask = inetaddress.getbyaddress(byte_mask); } catch (exception e) { searchtextfield.setbackground(color.red); return false; } ip_filter_enabled = new_filter_enabled; filter_address = new_filter_address; filter_mask = new_filter_mask; fireexpressionchangedevent(); data.setfilterpredicate(this); system.out.println(\"updating filter succeeded!\"); searchtextfield.setbackground(color.white); return true; }","repo":"kylekyle\/netgrok","label":[1,0,0,0]}
{"id":22557,"original_code":"private void updateRanges()\n\t{\n\t\t\/\/ get the minimum degree rank\n\t\tmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\n\t\tmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\n\t\tmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\n\t\tmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\n\t\tfireExpressionChangedEvent();\n\t\t\/\/TODO: make data listen to this so that we don't need this call\n\t\tdata.setFilterPredicate(this);\n\t}","code_wo_comment":"private void updateRanges()\n\t{\n\t\n\t\tmin_degree_rank = (float)(degreeRangeSlider.getLowValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmax_degree_rank = (float)(degreeRangeSlider.getHighValue() - degreeRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(degreeRangeSlider.getMaximum() - degreeRangeSlider.getMinimum());\n\t\tmin_bandwidth_rank = (float)(bandwidthRangeSlider.getLowValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmax_bandwidth_rank = (float)(bandwidthRangeSlider.getHighValue() - bandwidthRangeSlider.getMinimum()) \/ \n\t\t\t\t(float)(bandwidthRangeSlider.getMaximum() - bandwidthRangeSlider.getMinimum());\n\t\tmin_degree_enabled = degreeRangeSlider.getLowValue() != degreeRangeSlider.getMinimum();\n\t\tmax_degree_enabled = degreeRangeSlider.getHighValue() != degreeRangeSlider.getMaximum();\n\t\tmin_bandwidth_enabled = bandwidthRangeSlider.getLowValue() != bandwidthRangeSlider.getMinimum();\n\t\tmax_bandwidth_enabled = bandwidthRangeSlider.getHighValue() != bandwidthRangeSlider.getMaximum();\n\t\tfireExpressionChangedEvent();\n\t\n\t\tdata.setFilterPredicate(this);\n\t}","cleancode":"private void updateranges() { min_degree_rank = (float)(degreerangeslider.getlowvalue() - degreerangeslider.getminimum()) \/ (float)(degreerangeslider.getmaximum() - degreerangeslider.getminimum()); max_degree_rank = (float)(degreerangeslider.gethighvalue() - degreerangeslider.getminimum()) \/ (float)(degreerangeslider.getmaximum() - degreerangeslider.getminimum()); min_bandwidth_rank = (float)(bandwidthrangeslider.getlowvalue() - bandwidthrangeslider.getminimum()) \/ (float)(bandwidthrangeslider.getmaximum() - bandwidthrangeslider.getminimum()); max_bandwidth_rank = (float)(bandwidthrangeslider.gethighvalue() - bandwidthrangeslider.getminimum()) \/ (float)(bandwidthrangeslider.getmaximum() - bandwidthrangeslider.getminimum()); min_degree_enabled = degreerangeslider.getlowvalue() != degreerangeslider.getminimum(); max_degree_enabled = degreerangeslider.gethighvalue() != degreerangeslider.getmaximum(); min_bandwidth_enabled = bandwidthrangeslider.getlowvalue() != bandwidthrangeslider.getminimum(); max_bandwidth_enabled = bandwidthrangeslider.gethighvalue() != bandwidthrangeslider.getmaximum(); fireexpressionchangedevent(); data.setfilterpredicate(this); }","repo":"kylekyle\/netgrok","label":[1,0,0,0]}
{"id":30751,"original_code":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\n        for (ConstantInfo constant : constantPool) {\n            if (constant instanceof ConstantInfo.Class) {\n                ConstantInfo.Class info = (ConstantInfo.Class)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Fieldref) {\n                ConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.Methodref) {\n                ConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.InterfaceMethodref) {\n                ConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.String) {\n                ConstantInfo.String info = (ConstantInfo.String)constant;\n                info.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Integer\n                    || constant instanceof ConstantInfo.Float\n                    || constant instanceof ConstantInfo.Long\n                    || constant instanceof ConstantInfo.Double) {\n                \/\/ not needed\n            } else if (constant instanceof ConstantInfo.NameAndType) {\n                ConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n                info.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Utf8) {\n                \/\/ not needed\n            } else if (constant instanceof ConstantInfo.MethodHandle\n                    || constant instanceof ConstantInfo.MethodType\n                    || constant instanceof ConstantInfo.InvokeDynamic) {\n                \/\/ not used yet\n            } else if (constant != null) { \/\/ Long\/Double may leave create a blank space\n                throw new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n            }\n        }\n    }","code_wo_comment":"private void resolveConstantPoolReferences(ConstantInfo[] constantPool) {\n        for (ConstantInfo constant : constantPool) {\n            if (constant instanceof ConstantInfo.Class) {\n                ConstantInfo.Class info = (ConstantInfo.Class)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Fieldref) {\n                ConstantInfo.Fieldref info = (ConstantInfo.Fieldref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.Methodref) {\n                ConstantInfo.Methodref info = (ConstantInfo.Methodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.InterfaceMethodref) {\n                ConstantInfo.InterfaceMethodref info = (ConstantInfo.InterfaceMethodref)constant;\n                info.setClassInfo((ConstantInfo.Class)constantPool[info.getClassIndex() - 1]);\n                info.setNameAndType((ConstantInfo.NameAndType)constantPool[info.getNameAndTypeIndex() - 1]);\n            } else if (constant instanceof ConstantInfo.String) {\n                ConstantInfo.String info = (ConstantInfo.String)constant;\n                info.setString(((ConstantInfo.Utf8)constantPool[info.getStringIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Integer\n                    || constant instanceof ConstantInfo.Float\n                    || constant instanceof ConstantInfo.Long\n                    || constant instanceof ConstantInfo.Double) {\n               \n            } else if (constant instanceof ConstantInfo.NameAndType) {\n                ConstantInfo.NameAndType info = (ConstantInfo.NameAndType)constant;\n                info.setName(((ConstantInfo.Utf8)constantPool[info.getNameIndex() - 1]).getString());\n                info.setDescriptor(((ConstantInfo.Utf8)constantPool[info.getDescriptorIndex() - 1]).getString());\n            } else if (constant instanceof ConstantInfo.Utf8) {\n               \n            } else if (constant instanceof ConstantInfo.MethodHandle\n                    || constant instanceof ConstantInfo.MethodType\n                    || constant instanceof ConstantInfo.InvokeDynamic) {\n               \n            } else if (constant != null) {\n                throw new UnsupportedOperationException(\"Unhandled ConstantType: \" + constant);\n            }\n        }\n    }","cleancode":"private void resolveconstantpoolreferences(constantinfo[] constantpool) { for (constantinfo constant : constantpool) { if (constant instanceof constantinfo.class) { constantinfo.class info = (constantinfo.class)constant; info.setname(((constantinfo.utf8)constantpool[info.getnameindex() - 1]).getstring()); } else if (constant instanceof constantinfo.fieldref) { constantinfo.fieldref info = (constantinfo.fieldref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.methodref) { constantinfo.methodref info = (constantinfo.methodref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.interfacemethodref) { constantinfo.interfacemethodref info = (constantinfo.interfacemethodref)constant; info.setclassinfo((constantinfo.class)constantpool[info.getclassindex() - 1]); info.setnameandtype((constantinfo.nameandtype)constantpool[info.getnameandtypeindex() - 1]); } else if (constant instanceof constantinfo.string) { constantinfo.string info = (constantinfo.string)constant; info.setstring(((constantinfo.utf8)constantpool[info.getstringindex() - 1]).getstring()); } else if (constant instanceof constantinfo.integer || constant instanceof constantinfo.float || constant instanceof constantinfo.long || constant instanceof constantinfo.double) { } else if (constant instanceof constantinfo.nameandtype) { constantinfo.nameandtype info = (constantinfo.nameandtype)constant; info.setname(((constantinfo.utf8)constantpool[info.getnameindex() - 1]).getstring()); info.setdescriptor(((constantinfo.utf8)constantpool[info.getdescriptorindex() - 1]).getstring()); } else if (constant instanceof constantinfo.utf8) { } else if (constant instanceof constantinfo.methodhandle || constant instanceof constantinfo.methodtype || constant instanceof constantinfo.invokedynamic) { } else if (constant != null) { throw new unsupportedoperationexception(\"unhandled constanttype: \" + constant); } } }","repo":"k0kubun\/jjvm","label":[1,0,0,0]}
{"id":22840,"original_code":"public static void send(final InternalDistributedMember recipient, final int processorId,\n        final DM dm, Set keys) throws ForceReattemptException {\n      Assert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\n      final int numSeries = 1;\n      final int seriesNum = 0;\n      \/\/ chunkEntries returns false if didn't finish\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n      }\n      try {\n        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\n          new ObjectIntProcedure() {\n            int msgNum = 0;\n            boolean last = false;\n            \/**\n              * @param a byte[] chunk\n              * @param b positive if last chunk\n              * @return true to continue to next chunk\n              *\/\n            public boolean executeWith(Object a, int b) {\n\/\/              if (this.last)\n\/\/                throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());\n              HeapDataOutputStream chunk = (HeapDataOutputStream)a;\n              this.last = b > 0;\n              try {\n                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\n                return okay;\n              }\n              catch (CancelException e) {\n                return false;\n              }\n            }\n          });\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n        }\n      }\n      catch (IOException io) {\n        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n      }\n      \/\/ TODO [bruce] pass a reference to the cache or region down here so we can do this test\n      \/\/Assert.assertTrue(!cache is closed, \"chunking interrupted but cache is still open\");\n    }","code_wo_comment":"public static void send(final InternalDistributedMember recipient, final int processorId,\n        final DM dm, Set keys) throws ForceReattemptException {\n      Assert.assertTrue(recipient != null, \"FetchKeysReplyMessage NULL reply message\");\n      final int numSeries = 1;\n      final int seriesNum = 0;\n     \n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Starting pr keys chunking for {} kets to member {}\", keys.size(), recipient);\n      }\n      try {\n        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,\n          new ObjectIntProcedure() {\n            int msgNum = 0;\n            boolean last = false;\n           \n            public boolean executeWith(Object a, int b) {\n              HeapDataOutputStream chunk = (HeapDataOutputStream)a;\n              this.last = b > 0;\n              try {\n                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);\n                return okay;\n              }\n              catch (CancelException e) {\n                return false;\n              }\n            }\n          });\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"{} pr keys chunking\", (finished?\"Finished\" : \"DID NOT complete\"));\n        }\n      }\n      catch (IOException io) {\n        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);\n      }\n     \n     \n    }","cleancode":"public static void send(final internaldistributedmember recipient, final int processorid, final dm dm, set keys) throws forcereattemptexception { assert.asserttrue(recipient != null, \"fetchkeysreplymessage null reply message\"); final int numseries = 1; final int seriesnum = 0; if (logger.isdebugenabled()) { logger.debug(\"starting pr keys chunking for {} kets to member {}\", keys.size(), recipient); } try { boolean finished = chunkset(recipient, keys, initialimageoperation.chunk_size_in_bytes, false, new objectintprocedure() { int msgnum = 0; boolean last = false; public boolean executewith(object a, int b) { heapdataoutputstream chunk = (heapdataoutputstream)a; this.last = b > 0; try { boolean okay = sendchunk(recipient, processorid, dm, chunk, seriesnum, msgnum++, numseries, this.last); return okay; } catch (cancelexception e) { return false; } } }); if (logger.isdebugenabled()) { logger.debug(\"{} pr keys chunking\", (finished?\"finished\" : \"did not complete\")); } } catch (ioexception io) { throw new forcereattemptexception(localizedstrings.fetchkeysmessage_unable_to_send_response_to_fetch_keys_request.tolocalizedstring(), io); } }","repo":"karensmolermiller\/incubator-geode","label":[0,1,0,0]}
{"id":14744,"original_code":"@Override\n\t    void processOFMessage(ControllerChannelHandler h, OFMessage m)\n\t\t    throws IOException {\n\t\tswitch (m.getType()) {\n\t\t    case HELLO:\n\t\t\tprocessOFHello(h, (OFHello) m);\n\t\t\tbreak;    \n\t\t    case ECHO_REPLY:\n\t\t\tbreak;\n\t\t    case ECHO_REQUEST:\n\t\t\tprocessOFEchoRequest(h, (OFEchoRequest) m);\n\t\t\tbreak;\n\t\t    case FEATURES_REQUEST:\n\t\t\tprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\n\t\t\tbreak;\n\t\t    case BARRIER_REQUEST:\n\t\t\t\/\/TODO: actually implement barrier contract\n\t\t\tOFBarrierReply breply = new OFBarrierReply();\n\t\t\tbreply.setXid(m.getXid());\n\t\t\th.channel.write(Collections.singletonList(breply));\n\t\t\tbreak;\n\t\t    case SET_CONFIG:\n\t\t    case ERROR:\n\t\t    case PACKET_OUT:\n\t\t    case PORT_MOD:\n\t\t    case QUEUE_GET_CONFIG_REQUEST:\n\t\t    case STATS_REQUEST:    \n\t\t    case FLOW_MOD:\n\t\t    case GET_CONFIG_REQUEST:\n\t\t\th.sw.handleIO(m);\n\t\t\tbreak;\n\t\t    case VENDOR:\n\t\t\tunhandledMessageReceived(h, m);\n\t\t\tbreak;\n\t\t    case FEATURES_REPLY:\n\t\t    case FLOW_REMOVED:\n\t\t    case PACKET_IN:\n\t\t    case PORT_STATUS:\n\t\t    case BARRIER_REPLY:\n\t\t    case GET_CONFIG_REPLY:\n\t\t    case STATS_REPLY:\n\t\t    case QUEUE_GET_CONFIG_REPLY:\n\t\t\tillegalMessageReceived(h, m);\n\t\t\tbreak;\n\t\t}\n\t    }","code_wo_comment":"@Override\n\t    void processOFMessage(ControllerChannelHandler h, OFMessage m)\n\t\t    throws IOException {\n\t\tswitch (m.getType()) {\n\t\t    case HELLO:\n\t\t\tprocessOFHello(h, (OFHello) m);\n\t\t\tbreak;    \n\t\t    case ECHO_REPLY:\n\t\t\tbreak;\n\t\t    case ECHO_REQUEST:\n\t\t\tprocessOFEchoRequest(h, (OFEchoRequest) m);\n\t\t\tbreak;\n\t\t    case FEATURES_REQUEST:\n\t\t\tprocessOFFeaturesRequest(h, (OFFeaturesRequest) m);\n\t\t\tbreak;\n\t\t    case BARRIER_REQUEST:\n\t\t\n\t\t\tOFBarrierReply breply = new OFBarrierReply();\n\t\t\tbreply.setXid(m.getXid());\n\t\t\th.channel.write(Collections.singletonList(breply));\n\t\t\tbreak;\n\t\t    case SET_CONFIG:\n\t\t    case ERROR:\n\t\t    case PACKET_OUT:\n\t\t    case PORT_MOD:\n\t\t    case QUEUE_GET_CONFIG_REQUEST:\n\t\t    case STATS_REQUEST:    \n\t\t    case FLOW_MOD:\n\t\t    case GET_CONFIG_REQUEST:\n\t\t\th.sw.handleIO(m);\n\t\t\tbreak;\n\t\t    case VENDOR:\n\t\t\tunhandledMessageReceived(h, m);\n\t\t\tbreak;\n\t\t    case FEATURES_REPLY:\n\t\t    case FLOW_REMOVED:\n\t\t    case PACKET_IN:\n\t\t    case PORT_STATUS:\n\t\t    case BARRIER_REPLY:\n\t\t    case GET_CONFIG_REPLY:\n\t\t    case STATS_REPLY:\n\t\t    case QUEUE_GET_CONFIG_REPLY:\n\t\t\tillegalMessageReceived(h, m);\n\t\t\tbreak;\n\t\t}\n\t    }","cleancode":"@override void processofmessage(controllerchannelhandler h, ofmessage m) throws ioexception { switch (m.gettype()) { case hello: processofhello(h, (ofhello) m); break; case echo_reply: break; case echo_request: processofechorequest(h, (ofechorequest) m); break; case features_request: processoffeaturesrequest(h, (offeaturesrequest) m); break; case barrier_request: ofbarrierreply breply = new ofbarrierreply(); breply.setxid(m.getxid()); h.channel.write(collections.singletonlist(breply)); break; case set_config: case error: case packet_out: case port_mod: case queue_get_config_request: case stats_request: case flow_mod: case get_config_request: h.sw.handleio(m); break; case vendor: unhandledmessagereceived(h, m); break; case features_reply: case flow_removed: case packet_in: case port_status: case barrier_reply: case get_config_reply: case stats_reply: case queue_get_config_reply: illegalmessagereceived(h, m); break; } }","repo":"mgerola\/OpenVirteX","label":[0,1,0,0]}
{"id":14763,"original_code":"private void concultar() {\n        String sql = \"select * from tbusuarios where iduser=?\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            rs = pst.executeQuery();\n            if (rs.next()) {\n                txtUsuNome.setText(rs.getString(2));\n                txtUsuFone.setText(rs.getString(3));\n                txtUsuLogin.setText(rs.getString(4));\n                txtUsuSenha.setText(rs.getString(5));\n                \/\/a linha abaixo se refere ao combobox \n                cboUsuPerfil.setSelectedItem(rs.getString(6));\n            } else {\n                JOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n                \/\/as linhas abaixo \"limpam os campos\"\n                txtUsuNome.setText(null);\n                txtUsuFone.setText(null);\n                txtUsuLogin.setText(null);\n                txtUsuSenha.setText(null);\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","code_wo_comment":"private void concultar() {\n        String sql = \"select * from tbusuarios where iduser=?\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            rs = pst.executeQuery();\n            if (rs.next()) {\n                txtUsuNome.setText(rs.getString(2));\n                txtUsuFone.setText(rs.getString(3));\n                txtUsuLogin.setText(rs.getString(4));\n                txtUsuSenha.setText(rs.getString(5));\n               \n                cboUsuPerfil.setSelectedItem(rs.getString(6));\n            } else {\n                JOptionPane.showMessageDialog(null, \"Usu\u00e1rio n\u00e3o cadastrado\");\n               \n                txtUsuNome.setText(null);\n                txtUsuFone.setText(null);\n                txtUsuLogin.setText(null);\n                txtUsuSenha.setText(null);\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","cleancode":"private void concultar() { string sql = \"select * from tbusuarios where iduser=?\"; try { pst = conexao.preparestatement(sql); pst.setstring(1, txtusuid.gettext()); rs = pst.executequery(); if (rs.next()) { txtusunome.settext(rs.getstring(2)); txtusufone.settext(rs.getstring(3)); txtusulogin.settext(rs.getstring(4)); txtususenha.settext(rs.getstring(5)); cbousuperfil.setselecteditem(rs.getstring(6)); } else { joptionpane.showmessagedialog(null, \"usu\u00e1rio n\u00e3o cadastrado\"); txtusunome.settext(null); txtusufone.settext(null); txtusulogin.settext(null); txtususenha.settext(null); } } catch (exception e) { joptionpane.showmessagedialog(null, e); } }","repo":"marceloamorimcg\/Dr.InfoSystem","label":[0,0,0,0]}
{"id":14764,"original_code":"private void adicionar() {\n        String sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            pst.setString(2, txtUsuNome.getText());\n            pst.setString(3, txtUsuFone.getText());\n            pst.setString(4, txtUsuLogin.getText());\n            pst.setString(5, txtUsuSenha.getText());\n            pst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n            \/\/validi\u00e7\u00e3o dos campos obrigatorios\n            if ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\n                JOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n            } else {\n                \/\/a estrutura abaixo \u00e9 usada para confirmar a inser\u00e7\u00e3o dos dados na tabela\n                \/\/a linha abaixo atualiza a tabela usuario com os dados do formulario\n                int adicionado = pst.executeUpdate();\n                \/\/ testando a logica \n                \/\/System.out.println(adicionado);\n                if (adicionado > 0) {\n                    JOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\n                    txtUsuNome.setText(null);\n                    txtUsuFone.setText(null);\n                    txtUsuLogin.setText(null);\n                    txtUsuSenha.setText(null);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","code_wo_comment":"private void adicionar() {\n        String sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\";\n        try {\n            pst = conexao.prepareStatement(sql);\n            pst.setString(1, txtUsuId.getText());\n            pst.setString(2, txtUsuNome.getText());\n            pst.setString(3, txtUsuFone.getText());\n            pst.setString(4, txtUsuLogin.getText());\n            pst.setString(5, txtUsuSenha.getText());\n            pst.setString(6, cboUsuPerfil.getSelectedItem().toString());\n                      if ((txtUsuId.getText().isEmpty()) || (txtUsuNome.getText().isEmpty()) || (txtUsuLogin.getText().isEmpty()) || (txtUsuSenha.getText().isEmpty())) {\n                JOptionPane.showMessageDialog(null, \"Preencha todos os campos Obrigatorio\");\n            } else {\n                            \n                int adicionado = pst.executeUpdate();\n               \n               \n                if (adicionado > 0) {\n                    JOptionPane.showMessageDialog(null, \"Usuario adicionado com sucesso\");\n                    txtUsuNome.setText(null);\n                    txtUsuFone.setText(null);\n                    txtUsuLogin.setText(null);\n                    txtUsuSenha.setText(null);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(null, e);\n        }\n    }","cleancode":"private void adicionar() { string sql = \"insert into tbusuarios(iduser, usuario, fone,login,senha,perfil) values(?,?,?,?,?,?)\"; try { pst = conexao.preparestatement(sql); pst.setstring(1, txtusuid.gettext()); pst.setstring(2, txtusunome.gettext()); pst.setstring(3, txtusufone.gettext()); pst.setstring(4, txtusulogin.gettext()); pst.setstring(5, txtususenha.gettext()); pst.setstring(6, cbousuperfil.getselecteditem().tostring()); if ((txtusuid.gettext().isempty()) || (txtusunome.gettext().isempty()) || (txtusulogin.gettext().isempty()) || (txtususenha.gettext().isempty())) { joptionpane.showmessagedialog(null, \"preencha todos os campos obrigatorio\"); } else { int adicionado = pst.executeupdate(); if (adicionado > 0) { joptionpane.showmessagedialog(null, \"usuario adicionado com sucesso\"); txtusunome.settext(null); txtusufone.settext(null); txtusulogin.settext(null); txtususenha.settext(null); } } } catch (exception e) { joptionpane.showmessagedialog(null, e); } }","repo":"marceloamorimcg\/Dr.InfoSystem","label":[0,0,0,0]}
{"id":14786,"original_code":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n        \/\/ Use a predefined list of known Tokenizers\n        \/\/ TODO: publish more tokenizers... (when they are ready\/good enough\/abstract enough)\n        if (\"CSVTokenizer\".equals( tokenizerType )) {\n            return new CSVTokenizerImpl();\n        }\n        \/\/ Use the name of a class and instantiate this tokenizer\n        try {\n            \/\/ use classloader  and search for named class in class path...\n            ClassLoader classLoader = this.getClass().getClassLoader();\n            Class<?> loadedClass = classLoader.loadClass( tokenizerType );\n            \/\/ TODO: check if superclass is registered as a DataTokenizer....\n            \/\/ and check if it implements DataTokenizer\n            Class<?>[] interfaces = loadedClass.getInterfaces();\n            if (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n                \/\/ create the class using the unparametereized the constructor. \n                return (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n            }\n        }\n        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n                        | NoSuchMethodException | SecurityException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalArgumentException();\n    }","code_wo_comment":"public DataTokenizer buildTokenizerInstance( String tokenizerType ) {\n       \n       \n        if (\"CSVTokenizer\".equals( tokenizerType )) {\n            return new CSVTokenizerImpl();\n        }\n       \n        try {\n           \n            ClassLoader classLoader = this.getClass().getClassLoader();\n            Class<?> loadedClass = classLoader.loadClass( tokenizerType );\n           \n           \n            Class<?>[] interfaces = loadedClass.getInterfaces();\n            if (Arrays.asList( interfaces ).contains( DataTokenizer.class )) {\n               \n                return (DataTokenizer) loadedClass.getDeclaredConstructor().newInstance();\n            }\n        }\n        catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException\n                        | NoSuchMethodException | SecurityException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalArgumentException();\n    }","cleancode":"public datatokenizer buildtokenizerinstance( string tokenizertype ) { if (\"csvtokenizer\".equals( tokenizertype )) { return new csvtokenizerimpl(); } try { classloader classloader = this.getclass().getclassloader(); class<?> loadedclass = classloader.loadclass( tokenizertype ); class<?>[] interfaces = loadedclass.getinterfaces(); if (arrays.aslist( interfaces ).contains( datatokenizer.class )) { return (datatokenizer) loadedclass.getdeclaredconstructor().newinstance(); } } catch (classnotfoundexception | instantiationexception | illegalaccessexception | illegalargumentexception | invocationtargetexception | nosuchmethodexception | securityexception e) { e.printstacktrace(); } throw new illegalargumentexception(); }","repo":"mindscan-de\/BrightFlux","label":[0,1,0,0]}
{"id":23051,"original_code":"@Override\n\tprotected void updateConnectButtonState() {\n\t\t\/\/ TODO: Update this logic to also handle the user logged in by email.\n\t\tboolean connected = getPlusClient().isConnected();\n\t\tmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\n\t\tmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n\t}","code_wo_comment":"@Override\n\tprotected void updateConnectButtonState() {\n\t\n\t\tboolean connected = getPlusClient().isConnected();\n\t\tmSignOutButtons.setVisibility(connected ? View.VISIBLE : View.GONE);\n\t\tmPlusSignInButton.setVisibility(connected ? View.GONE : View.VISIBLE);\n\t}","cleancode":"@override protected void updateconnectbuttonstate() { boolean connected = getplusclient().isconnected(); msignoutbuttons.setvisibility(connected ? view.visible : view.gone); mplussigninbutton.setvisibility(connected ? view.gone : view.visible); }","repo":"llanox\/EasyVote","label":[0,1,0,0]}
{"id":23285,"original_code":"@Test\n\tpublic void fetchTest(){ \n\/\/\t\tFileConfigProvider fcp = new FileConfigProvider(\"overrides.json\");\n\/\/\t\tfor(Config config : fcp.getAll(\"prod\", \"ssa\")){\n\/\/\t\t\tSystem.out.println(config);\n\/\/\t\t}\n\/\/\t\tRestConfigProvider rcc = new RestConfigProvider(\"http:\/\/localhost:8080\/configuration\");\n\/\/\t\trcc.getAll(\"prod\", \"ssa\");\n\/\/\t\t\n\t}","code_wo_comment":"@Test\n\tpublic void fetchTest(){ \n\t}","cleancode":"@test public void fetchtest(){ }","repo":"krisglover\/cia","label":[0,0,0,1]}
{"id":31543,"original_code":"private String waitForAnswer(String expected) {\n        \/\/ todo add the possibility to specify more options to be specified\n        \/\/ todo use regexp matching instead of the beginning of a string\n        String line = null;\n        if (expected != null) {\n            try {\n                while ((line = mplayerOutErr.readLine()) != null) {\n                    if (MusicZones.getIsDebugOn()) {\n                        logger.log(Level.INFO, \"Reading line: {0}\", line);\n                    }\n                    if (line.startsWith(expected)) {\n                        return line;\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(ex);\n            }\n        }\n        return line;\n    }","code_wo_comment":"private String waitForAnswer(String expected) {\n       \n       \n        String line = null;\n        if (expected != null) {\n            try {\n                while ((line = mplayerOutErr.readLine()) != null) {\n                    if (MusicZones.getIsDebugOn()) {\n                        logger.log(Level.INFO, \"Reading line: {0}\", line);\n                    }\n                    if (line.startsWith(expected)) {\n                        return line;\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(ex);\n            }\n        }\n        return line;\n    }","cleancode":"private string waitforanswer(string expected) { string line = null; if (expected != null) { try { while ((line = mplayerouterr.readline()) != null) { if (musiczones.getisdebugon()) { logger.log(level.info, \"reading line: {0}\", line); } if (line.startswith(expected)) { return line; } } } catch (ioexception ex) { system.err.println(ex); } } return line; }","repo":"jzerbe\/musiczones","label":[0,1,0,0]}
{"id":31583,"original_code":"private void logGameStart(CFMap map) {\n        log.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n        \/\/TODO: FIX ANNOTATION STUFF\n        \/\/log.println(\"[Red Team Controller: \" + quote(game.getController(Team.RED).getIdString()) + \"]\");\n        \/\/log.println(\"[Blue Team Controller: \" + quote(game.getController(Team.BLUE).getIdString()) + \"]\");\n        log.println();\n        log.println(\"> Game started.\");\n    }","code_wo_comment":"private void logGameStart(CFMap map) {\n        log.println(\"=== CodeFray Version 1 [Capture the Flag] Official Game Log ===\\n\");\n       \n       \n       \n        log.println();\n        log.println(\"> Game started.\");\n    }","cleancode":"private void loggamestart(cfmap map) { log.println(\"=== codefray version 1 [capture the flag] official game log ===\\n\"); log.println(); log.println(\"> game started.\"); }","repo":"lg198\/CodeFray","label":[0,1,0,0]}
{"id":31644,"original_code":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n        \/\/ If the filtered question is the same than asked\n        if(normalizedQuestion.equals(questionAsked))\n            return 100;\n        \/\/ If it is an ordered subset\n        \/\/ TODO I'M NOT SURE IF THIS IS WORKING\n        else if(isSubset(questionAsked))\n            return 65;\n        else if(containsWords(questionAsked)>0)\n            return 30;\n        \/\/ Otherwise\n        else\n            return 0;\n    }","code_wo_comment":"public int getPriorityLevel(LinkedList<String> questionAsked) {\n       \n        if(normalizedQuestion.equals(questionAsked))\n            return 100;\n       \n       \n        else if(isSubset(questionAsked))\n            return 65;\n        else if(containsWords(questionAsked)>0)\n            return 30;\n       \n        else\n            return 0;\n    }","cleancode":"public int getprioritylevel(linkedlist<string> questionasked) { if(normalizedquestion.equals(questionasked)) return 100; else if(issubset(questionasked)) return 65; else if(containswords(questionasked)>0) return 30; else return 0; }","repo":"melvidoni\/chatbot","label":[1,0,0,0]}
{"id":31645,"original_code":"private int containsWords(LinkedList<String> questionAsked) {\n        \/\/ Create a counter\n        int containedWords = 0;\n        \/\/ For each word asked\n        for(String wordAsked : questionAsked) {\n            \/\/ If found, we add one, otherwise, we add zero\n            containedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n        }\n        \/\/ Return the value\n        return containedWords;\n    }","code_wo_comment":"private int containsWords(LinkedList<String> questionAsked) {\n       \n        int containedWords = 0;\n       \n        for(String wordAsked : questionAsked) {\n           \n            containedWords += normalizedQuestion.contains(wordAsked) ? 1 : 0;\n        }\n       \n        return containedWords;\n    }","cleancode":"private int containswords(linkedlist<string> questionasked) { int containedwords = 0; for(string wordasked : questionasked) { containedwords += normalizedquestion.contains(wordasked) ? 1 : 0; } return containedwords; }","repo":"melvidoni\/chatbot","label":[1,0,0,0]}
{"id":31742,"original_code":"@Inject(\n            method = \"updateTexture()V\",\n            at = @At(\n                    value = \"HEAD\",\n                    target = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n            ),\n            cancellable = true)\n    private void updateAetherTexture(CallbackInfo ci) {\n        if (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\n            for (int i = 0; i < 128; ++i) {\n                for (int j = 0; j < 128; ++j) {\n                    int k = j + i * 128;\n                    int l = this.state.colors[k] & 255;\n                    if (l >> 2 == 0) { \/\/ MapColor.CLEAR\n                        \/\/ Who knows what this does? Nothing, it seems. But just in case I'll let it stick around.\n                        \/\/ Comment your code please!\n                        this.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n                    } else {\n                        this.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n                    }\n                }\n            }\n            this.texture.upload();\n            ci.cancel();\n        }\n    }","code_wo_comment":"@Inject(\n            method = \"updateTexture()V\",\n            at = @At(\n                    value = \"HEAD\",\n                    target = \"net\/minecraft\/client\/render\/MapRenderer$MapTexture.updateTexture()V\"\n            ),\n            cancellable = true)\n    private void updateAetherTexture(CallbackInfo ci) {\n        if (this.state.dimension == AetherDimension.AETHER_WORLD_KEY){\n            for (int i = 0; i < 128; ++i) {\n                for (int j = 0; j < 128; ++j) {\n                    int k = j + i * 128;\n                    int l = this.state.colors[k] & 255;\n                    if (l >> 2 == 0) {\n                       \n                       \n                        this.texture.getImage().setColor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24);\n                    } else {\n                        this.texture.getImage().setColor(j, i, AetherMapColorUtil.getColor(MapColor.COLORS[l >> 2], l & 3));\n                    }\n                }\n            }\n            this.texture.upload();\n            ci.cancel();\n        }\n    }","cleancode":"@inject( method = \"updatetexture()v\", at = @at( value = \"head\", target = \"net\/minecraft\/client\/render\/maprenderer$maptexture.updatetexture()v\" ), cancellable = true) private void updateaethertexture(callbackinfo ci) { if (this.state.dimension == aetherdimension.aether_world_key){ for (int i = 0; i < 128; ++i) { for (int j = 0; j < 128; ++j) { int k = j + i * 128; int l = this.state.colors[k] & 255; if (l >> 2 == 0) { this.texture.getimage().setcolor(j, i, (k + k \/ 128 & 1) * 8 + 16 << 24); } else { this.texture.getimage().setcolor(j, i, aethermapcolorutil.getcolor(mapcolor.colors[l >> 2], l & 3)); } } } this.texture.upload(); ci.cancel(); } }","repo":"kalucky0\/The-Aether","label":[1,0,0,0]}
{"id":31763,"original_code":"@Test\n\tpublic void test_EchoUser_restTemplate() {\n\t    String firstName = \"Chuck\";\n\t    String lastName = \"Norris\";\n\t\tString result = restTemplate.getForObject(\n\t\t\t\t\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName, \n\t\t\t\tString.class);\n\t\tString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\n\t\tassertThat(result, containsString(expected));\n\t\tlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n\t}","code_wo_comment":"@Test\n\tpublic void test_EchoUser_restTemplate() {\n\t    String firstName = \"Chuck\";\n\t    String lastName = \"Norris\";\n\t\tString result = restTemplate.getForObject(\n\t\t\t\t\"http:\/\/localhost:8888\/\"+firstName+\"\/\"+lastName, \n\t\t\t\tString.class);\n\t\tString expected = \"{\\\"firstName\\\":\\\"\"+firstName+\"\\\",\\\"lastName\\\":\\\"\"+lastName+\"\\\"}\";\n\t\tassertThat(result, containsString(expected));\n\t\tlog.info(\"*** Successfully echoed a User (\"+firstName+\" \"+lastName+\") through REST ***\");\n\t}","cleancode":"@test public void test_echouser_resttemplate() { string firstname = \"chuck\"; string lastname = \"norris\"; string result = resttemplate.getforobject( \"http:\/\/localhost:8888\/\"+firstname+\"\/\"+lastname, string.class); string expected = \"{\\\"firstname\\\":\\\"\"+firstname+\"\\\",\\\"lastname\\\":\\\"\"+lastname+\"\\\"}\"; assertthat(result, containsstring(expected)); log.info(\"*** successfully echoed a user (\"+firstname+\" \"+lastname+\") through rest ***\"); }","repo":"mickknutson\/spring-cloud-config","label":[0,0,1,0]}
{"id":15506,"original_code":"public boolean validateBinaryExpr(BinaryExpr node) {\n        ExprNode expr1 = node.getExpr1();\n        ExprNode expr2 = node.getExpr2();\n        Type t1 = expr1.getType();\n        Type t2 = expr2.getType();\n        String op = node.getOperation();\n        switch (op) {\n            case \"==\":\n            case \"!=\":\n                if (Types.isNumber(t1)) {\n                    return this.requireNumber(expr2,t2);\n                } else {\n                    return true;\n                    \/\/TODO pass anything.may be Object needed?\n                }\n            case \"+\":\n            case \"-\":\n            case \"*\":\n            case \"\/\":\n            case \"%\":\n            case \">=\":\n            case \"<=\":\n            case \">\":\n            case \"<\":\n            case \"&\":\n            case \"|\":\n            case \"^\":\n            case BinaryExpr.OP_SHIFT_LEFT:\n            case BinaryExpr.OP_SHIFT_RIGHT:\n            case BinaryExpr.OP_UNSIGNED_SHIFT_RIGHT:\n                return this.requireNumber(expr1, t1) && this.requireNumber(expr2, t2);\n            case \"&&\":\n            case \"||\":\n                return requireBoolean(expr1, t1) && requireBoolean(expr2, t2);\n            default:\n                diagnosisReporter.report(Diagnosis.Kind.ERROR, \"unsupported operation:\" + op, node.offset);\n                return false;\n        }\n    }","code_wo_comment":"public boolean validateBinaryExpr(BinaryExpr node) {\n        ExprNode expr1 = node.getExpr1();\n        ExprNode expr2 = node.getExpr2();\n        Type t1 = expr1.getType();\n        Type t2 = expr2.getType();\n        String op = node.getOperation();\n        switch (op) {\n            case \"==\":\n            case \"!=\":\n                if (Types.isNumber(t1)) {\n                    return this.requireNumber(expr2,t2);\n                } else {\n                    return true;\n                   \n                }\n            case \"+\":\n            case \"-\":\n            case \"*\":\n            case \"\/\":\n            case \"%\":\n            case \">=\":\n            case \"<=\":\n            case \">\":\n            case \"<\":\n            case \"&\":\n            case \"|\":\n            case \"^\":\n            case BinaryExpr.OP_SHIFT_LEFT:\n            case BinaryExpr.OP_SHIFT_RIGHT:\n            case BinaryExpr.OP_UNSIGNED_SHIFT_RIGHT:\n                return this.requireNumber(expr1, t1) && this.requireNumber(expr2, t2);\n            case \"&&\":\n            case \"||\":\n                return requireBoolean(expr1, t1) && requireBoolean(expr2, t2);\n            default:\n                diagnosisReporter.report(Diagnosis.Kind.ERROR, \"unsupported operation:\" + op, node.offset);\n                return false;\n        }\n    }","cleancode":"public boolean validatebinaryexpr(binaryexpr node) { exprnode expr1 = node.getexpr1(); exprnode expr2 = node.getexpr2(); type t1 = expr1.gettype(); type t2 = expr2.gettype(); string op = node.getoperation(); switch (op) { case \"==\": case \"!=\": if (types.isnumber(t1)) { return this.requirenumber(expr2,t2); } else { return true; } case \"+\": case \"-\": case \"*\": case \"\/\": case \"%\": case \">=\": case \"<=\": case \">\": case \"<\": case \"&\": case \"|\": case \"^\": case binaryexpr.op_shift_left: case binaryexpr.op_shift_right: case binaryexpr.op_unsigned_shift_right: return this.requirenumber(expr1, t1) && this.requirenumber(expr2, t2); case \"&&\": case \"||\": return requireboolean(expr1, t1) && requireboolean(expr2, t2); default: diagnosisreporter.report(diagnosis.kind.error, \"unsupported operation:\" + op, node.offset); return false; } }","repo":"lbqh\/kalang","label":[0,1,0,0]}
{"id":15600,"original_code":"public void projectTo(final ComplexProjective1 cp)\n        throws IllegalArgumentException {\n        \/* Check if the point lies on the sphere. *\/\n        if (Math.abs(normSquared() - 1.0) > EPSILON) {\n            throw new IllegalArgumentException(\"Norm must be 1.0. \" +\n                                               \"Norm is \" + norm() + \". \");\n        }\n        \/* Check if the point lies above or below the xy-plane. *\/\n        if (z > 0.0) {\n            \/* We might be close to the north pole. This would be bad,\n             * numerically. So perform a 180 degree rotation around the\n             * x-axis, project that point, and swap the entries of the\n             * result.\n             *\/\n            \/* Dummy variables *\/\n            final double dummyRe;\n            final double dummyIm;\n            \/* Rotate by 180 degree around the x-axis. *\/\n            y = -y;\n            z = -z;\n            \/* Project that point. Now, z < -EPSILON. *\/\n            belowXYProjectTo(cp);\n            \/* Rotate back. *\/\n            y = -y;\n            z = -z;\n            \/* Swap the entries of the result.\n             *\n             * TODO: Maybe Complex2 should have a final method that swaps the\n             * entries. This might speed up dereferencing the fields of cp,\n             * because dereferencing fiels of other objects might be slower\n             * than dereferencing fields of the same object. But actually, I\n             * don't know if that is true or if it matters. *\/\n            dummyRe = cp.aRe;\n            dummyIm = cp.aIm;\n            cp.aRe = cp.bRe;\n            cp.aIm = cp.bIm;\n            cp.bRe = dummyRe;\n            cp.bIm = dummyIm;\n        } else {\n            \/* Point lies below xy-plane so we use *\/\n            belowXYProjectTo(cp);\n        }\n    }","code_wo_comment":"public void projectTo(final ComplexProjective1 cp)\n        throws IllegalArgumentException {\n       \n        if (Math.abs(normSquared() - 1.0) > EPSILON) {\n            throw new IllegalArgumentException(\"Norm must be 1.0. \" +\n                                               \"Norm is \" + norm() + \". \");\n        }\n       \n        if (z > 0.0) {\n           \n           \n            final double dummyRe;\n            final double dummyIm;\n           \n            y = -y;\n            z = -z;\n           \n            belowXYProjectTo(cp);\n           \n            y = -y;\n            z = -z;\n           \n            dummyRe = cp.aRe;\n            dummyIm = cp.aIm;\n            cp.aRe = cp.bRe;\n            cp.aIm = cp.bIm;\n            cp.bRe = dummyRe;\n            cp.bIm = dummyIm;\n        } else {\n           \n            belowXYProjectTo(cp);\n        }\n    }","cleancode":"public void projectto(final complexprojective1 cp) throws illegalargumentexception { if (math.abs(normsquared() - 1.0) > epsilon) { throw new illegalargumentexception(\"norm must be 1.0. \" + \"norm is \" + norm() + \". \"); } if (z > 0.0) { final double dummyre; final double dummyim; y = -y; z = -z; belowxyprojectto(cp); y = -y; z = -z; dummyre = cp.are; dummyim = cp.aim; cp.are = cp.bre; cp.aim = cp.bim; cp.bre = dummyre; cp.bim = dummyim; } else { belowxyprojectto(cp); } }","repo":"jupsal\/schmies-jTEM","label":[1,0,0,0]}
{"id":32041,"original_code":"@Test\n    public void dontPullAttachmentAlreadyPulled() {\n        try {\n            \/\/ create a rev with an attachment, then update it keeping attachment\n            \/\/ TODO we need to somehow check the attachment wasn't re-downloaded\n            createRevisionAndBigTextAttachment();\n            pull();\n            DocumentRevision docRev1 = datastore.getDocument(id, rev);\n            Attachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\n            updateRevisionAndKeepAttachment();\n            updateRevisionAndKeepAttachment();\n            pull();\n            DocumentRevision docRev2 = datastore.getDocument(id, rev);\n            Attachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\n            Assert.assertNotNull(a2);\n        } catch (Exception e) {\n            Assert.fail(\"Create\/pull error \" + e);\n        }\n    }","code_wo_comment":"@Test\n    public void dontPullAttachmentAlreadyPulled() {\n        try {\n           \n           \n            createRevisionAndBigTextAttachment();\n            pull();\n            DocumentRevision docRev1 = datastore.getDocument(id, rev);\n            Attachment a1 = datastore.getAttachment(docRev1, bigTextAttachmentName);\n            updateRevisionAndKeepAttachment();\n            updateRevisionAndKeepAttachment();\n            pull();\n            DocumentRevision docRev2 = datastore.getDocument(id, rev);\n            Attachment a2 = datastore.getAttachment(docRev2, bigTextAttachmentName);\n            Assert.assertNotNull(a2);\n        } catch (Exception e) {\n            Assert.fail(\"Create\/pull error \" + e);\n        }\n    }","cleancode":"@test public void dontpullattachmentalreadypulled() { try { createrevisionandbigtextattachment(); pull(); documentrevision docrev1 = datastore.getdocument(id, rev); attachment a1 = datastore.getattachment(docrev1, bigtextattachmentname); updaterevisionandkeepattachment(); updaterevisionandkeepattachment(); pull(); documentrevision docrev2 = datastore.getdocument(id, rev); attachment a2 = datastore.getattachment(docrev2, bigtextattachmentname); assert.assertnotnull(a2); } catch (exception e) { assert.fail(\"create\/pull error \" + e); } }","repo":"kiwiwearables\/sync-android","label":[1,0,0,0]}
{"id":7632,"original_code":"@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Bundle extras;\n        Log.d(TAG, \"Widget configuration activity created\");\n        setResult(RESULT_CANCELED);\n        extras = getIntent().getExtras();\n        if (extras != null) {\n            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n        }\n        if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\n            finish();\n            return;\n        }\n        resultValue = new Intent();\n        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\n        setResult(RESULT_OK, resultValue);\n        if(SessionManager.hasSessionInStore(this)) {\n            \/\/ Finish activity earlier\n            Log.d(TAG, \"Session already taken, leaving configuration activity\");\n            finish();\n        }\n    }","code_wo_comment":"@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Bundle extras;\n        Log.d(TAG, \"Widget configuration activity created\");\n        setResult(RESULT_CANCELED);\n        extras = getIntent().getExtras();\n        if (extras != null) {\n            mAppWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n        }\n        if (mAppWidgetId == AppWidgetManager.INVALID_APPWIDGET_ID) {\n            finish();\n            return;\n        }\n        resultValue = new Intent();\n        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);\n        setResult(RESULT_OK, resultValue);\n        if(SessionManager.hasSessionInStore(this)) {\n           \n            Log.d(TAG, \"Session already taken, leaving configuration activity\");\n            finish();\n        }\n    }","cleancode":"@override protected void oncreate(bundle savedinstancestate) { super.oncreate(savedinstancestate); bundle extras; log.d(tag, \"widget configuration activity created\"); setresult(result_canceled); extras = getintent().getextras(); if (extras != null) { mappwidgetid = extras.getint(appwidgetmanager.extra_appwidget_id, appwidgetmanager.invalid_appwidget_id); } if (mappwidgetid == appwidgetmanager.invalid_appwidget_id) { finish(); return; } resultvalue = new intent(); resultvalue.putextra(appwidgetmanager.extra_appwidget_id, mappwidgetid); setresult(result_ok, resultvalue); if(sessionmanager.hassessioninstore(this)) { log.d(tag, \"session already taken, leaving configuration activity\"); finish(); } }","repo":"memleakpl\/flat","label":[0,0,1,0]}
{"id":24024,"original_code":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\n\t\tif (object == null) {\n\t\t\tbuffer.append(\"NULL\");\n\t\t} else if (object instanceof String) {\n\t\t\tbuffer.append('\\'');\n\t\t\t\/\/ lets escape quotes\n\t\t\tString literal = (String) object;\n\t\t\tif (literal.length() > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n\t\t\t}\n\t\t\tint curPos = 0;\n\t\t\tint endPos = 0;\n\t\t\twhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\n\t\t\t\tbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\n\t\t\t\tcurPos = endPos + 1;\n\t\t\t}\n\t\t\tif (curPos < literal.length())\n\t\t\t\tbuffer.append(literal.substring(curPos));\n\t\t\tbuffer.append('\\'');\n\t\t}\n\t\t\/\/ handle byte pretty formatting\n\t\telse if (object instanceof Byte) {\n\t\t\tIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n\t\t} else if (object instanceof Number) {\n\t\t\t\/\/ process numeric value (do something smart in the future)\n\t\t\tbuffer.append(object);\n\t\t} else if (object instanceof java.sql.Date) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.sql.Time) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.util.Date) {\n\t\t\tlong time = ((java.util.Date) object).getTime();\n\t\t\tbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n\t\t} else if (object instanceof java.util.Calendar) {\n\t\t\tlong time = ((java.util.Calendar) object).getTimeInMillis();\n\t\t\tbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n\t\t} else if (object instanceof Character) {\n\t\t\tbuffer.append(((Character) object).charValue());\n\t\t} else if (object instanceof Boolean) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof Enum<?>) {\n\t\t\t\/\/ buffer.append(object.getClass().getName()).append(\".\");\n\t\t\tbuffer.append(((Enum<?>) object).name()).append(\"=\");\n\t\t\tif (object instanceof ExtendedEnumeration) {\n\t\t\t\tObject value = ((ExtendedEnumeration) object).getDatabaseValue();\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t\tbuffer.append(value);\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(((Enum<?>) object).ordinal());\n\t\t\t\t\/\/ FIXME -- this isn't quite right\n\t\t\t}\n\t\t} else if (object instanceof SQLParameterBinding) {\n\t\t\tsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n\t\t} else if (object.getClass().isArray()) {\n\t\t\tbuffer.append(\"< \");\n\t\t\tint len = Array.getLength(object);\n\t\t\tboolean trimming = false;\n\t\t\tif (len > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tlen = TRIM_VALUES_THRESHOLD;\n\t\t\t\ttrimming = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tbuffer.append(\",\");\n\t\t\t\t}\n\t\t\t\tsqlLiteralForObject(buffer, Array.get(object, i));\n\t\t\t}\n\t\t\tif (trimming) {\n\t\t\t\tbuffer.append(\"...\");\n\t\t\t}\n\t\t\tbuffer.append('>');\n\t\t} else {\n\t\t\tbuffer.append(object.getClass().getName()).append(\"@\").append(System.identityHashCode(object));\n\t\t}\n\t}","code_wo_comment":"void sqlLiteralForObject(StringBuilder buffer, Object object) {\n\t\tif (object == null) {\n\t\t\tbuffer.append(\"NULL\");\n\t\t} else if (object instanceof String) {\n\t\t\tbuffer.append('\\'');\n\t\t\n\t\t\tString literal = (String) object;\n\t\t\tif (literal.length() > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tliteral = literal.substring(0, TRIM_VALUES_THRESHOLD) + \"...\";\n\t\t\t}\n\t\t\tint curPos = 0;\n\t\t\tint endPos = 0;\n\t\t\twhile ((endPos = literal.indexOf('\\'', curPos)) >= 0) {\n\t\t\t\tbuffer.append(literal.substring(curPos, endPos + 1)).append('\\'');\n\t\t\t\tcurPos = endPos + 1;\n\t\t\t}\n\t\t\tif (curPos < literal.length())\n\t\t\t\tbuffer.append(literal.substring(curPos));\n\t\t\tbuffer.append('\\'');\n\t\t}\n\t\n\t\telse if (object instanceof Byte) {\n\t\t\tIDUtil.appendFormattedByte(buffer, ((Byte) object).byteValue());\n\t\t} else if (object instanceof Number) {\n\t\t\n\t\t\tbuffer.append(object);\n\t\t} else if (object instanceof java.sql.Date) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.sql.Time) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof java.util.Date) {\n\t\t\tlong time = ((java.util.Date) object).getTime();\n\t\t\tbuffer.append('\\'').append(new java.sql.Timestamp(time)).append('\\'');\n\t\t} else if (object instanceof java.util.Calendar) {\n\t\t\tlong time = ((java.util.Calendar) object).getTimeInMillis();\n\t\t\tbuffer.append(object.getClass().getName()).append('(').append(new java.sql.Timestamp(time)).append(')');\n\t\t} else if (object instanceof Character) {\n\t\t\tbuffer.append(((Character) object).charValue());\n\t\t} else if (object instanceof Boolean) {\n\t\t\tbuffer.append('\\'').append(object).append('\\'');\n\t\t} else if (object instanceof Enum<?>) {\n\t\t\n\t\t\tbuffer.append(((Enum<?>) object).name()).append(\"=\");\n\t\t\tif (object instanceof ExtendedEnumeration) {\n\t\t\t\tObject value = ((ExtendedEnumeration) object).getDatabaseValue();\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t\tbuffer.append(value);\n\t\t\t\tif (value instanceof String)\n\t\t\t\t\tbuffer.append(\"'\");\n\t\t\t} else {\n\t\t\t\tbuffer.append(((Enum<?>) object).ordinal());\n\t\t\t\n\t\t\t}\n\t\t} else if (object instanceof SQLParameterBinding) {\n\t\t\tsqlLiteralForObject(buffer, ((SQLParameterBinding) object).getValue());\n\t\t} else if (object.getClass().isArray()) {\n\t\t\tbuffer.append(\"< \");\n\t\t\tint len = Array.getLength(object);\n\t\t\tboolean trimming = false;\n\t\t\tif (len > TRIM_VALUES_THRESHOLD) {\n\t\t\t\tlen = TRIM_VALUES_THRESHOLD;\n\t\t\t\ttrimming = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tbuffer.append(\",\");\n\t\t\t\t}\n\t\t\t\tsqlLiteralForObject(buffer, Array.get(object, i));\n\t\t\t}\n\t\t\tif (trimming) {\n\t\t\t\tbuffer.append(\"...\");\n\t\t\t}\n\t\t\tbuffer.append('>');\n\t\t} else {\n\t\t\tbuffer.append(object.getClass().getName()).append(\"@\").append(System.identityHashCode(object));\n\t\t}\n\t}","cleancode":"void sqlliteralforobject(stringbuilder buffer, object object) { if (object == null) { buffer.append(\"null\"); } else if (object instanceof string) { buffer.append('\\''); string literal = (string) object; if (literal.length() > trim_values_threshold) { literal = literal.substring(0, trim_values_threshold) + \"...\"; } int curpos = 0; int endpos = 0; while ((endpos = literal.indexof('\\'', curpos)) >= 0) { buffer.append(literal.substring(curpos, endpos + 1)).append('\\''); curpos = endpos + 1; } if (curpos < literal.length()) buffer.append(literal.substring(curpos)); buffer.append('\\''); } else if (object instanceof byte) { idutil.appendformattedbyte(buffer, ((byte) object).bytevalue()); } else if (object instanceof number) { buffer.append(object); } else if (object instanceof java.sql.date) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof java.sql.time) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof java.util.date) { long time = ((java.util.date) object).gettime(); buffer.append('\\'').append(new java.sql.timestamp(time)).append('\\''); } else if (object instanceof java.util.calendar) { long time = ((java.util.calendar) object).gettimeinmillis(); buffer.append(object.getclass().getname()).append('(').append(new java.sql.timestamp(time)).append(')'); } else if (object instanceof character) { buffer.append(((character) object).charvalue()); } else if (object instanceof boolean) { buffer.append('\\'').append(object).append('\\''); } else if (object instanceof enum<?>) { buffer.append(((enum<?>) object).name()).append(\"=\"); if (object instanceof extendedenumeration) { object value = ((extendedenumeration) object).getdatabasevalue(); if (value instanceof string) buffer.append(\"'\"); buffer.append(value); if (value instanceof string) buffer.append(\"'\"); } else { buffer.append(((enum<?>) object).ordinal()); } } else if (object instanceof sqlparameterbinding) { sqlliteralforobject(buffer, ((sqlparameterbinding) object).getvalue()); } else if (object.getclass().isarray()) { buffer.append(\"< \"); int len = array.getlength(object); boolean trimming = false; if (len > trim_values_threshold) { len = trim_values_threshold; trimming = true; } for (int i = 0; i < len; i++) { if (i > 0) { buffer.append(\",\"); } sqlliteralforobject(buffer, array.get(object, i)); } if (trimming) { buffer.append(\"...\"); } buffer.append('>'); } else { buffer.append(object.getclass().getname()).append(\"@\").append(system.identityhashcode(object)); } }","repo":"laakhbeenor\/cayenne","label":[0,0,1,0]}
{"id":15851,"original_code":"protected double valueFor(Object o)\n        {\n        if (o instanceof java.lang.Number)  \/\/ compiler complains unless I include the full classname!!! Huh?\n            return ((Number)o).doubleValue();\n        else if (o instanceof Valuable)\n            return ((Valuable)o).doubleValue();\n        else if (o instanceof Boolean)\n            return ((Boolean)o).booleanValue() ? 1 : 0;\n        else return Double.NaN;  \/\/ unknown\n        }","code_wo_comment":"protected double valueFor(Object o)\n        {\n        if (o instanceof java.lang.Number) \n            return ((Number)o).doubleValue();\n        else if (o instanceof Valuable)\n            return ((Valuable)o).doubleValue();\n        else if (o instanceof Boolean)\n            return ((Boolean)o).booleanValue() ? 1 : 0;\n        else return Double.NaN; \n        }","cleancode":"protected double valuefor(object o) { if (o instanceof java.lang.number) return ((number)o).doublevalue(); else if (o instanceof valuable) return ((valuable)o).doublevalue(); else if (o instanceof boolean) return ((boolean)o).booleanvalue() ? 1 : 0; else return double.nan; }","repo":"minhhn2910\/g-mason","label":[1,0,0,0]}
{"id":24088,"original_code":"private Grid<Cuenta> createGrid() {\n\t\tgrid = new Grid<>();\n\t\tgrid.setWidthFull();\n\t\tgrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\n\t\tgrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\n        grid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\n        grid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\n        return grid;\n\t}","code_wo_comment":"private Grid<Cuenta> createGrid() {\n\t\tgrid = new Grid<>();\n\t\tgrid.setWidthFull();\n\t\tgrid.addThemeVariants(GridVariant.LUMO_NO_BORDER,GridVariant.LUMO_ROW_STRIPES);\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"dd\/MM\/yyyy\");\n\t\tgrid.addColumn(c -> c.getIban()).setHeader(\"Iban\").setFlexGrow(1);\n        grid.addColumn(c -> c.getSaldo()).setHeader(\"Saldo\").setFlexGrow(1);\n        grid.addColumn(c -> dateFormat.format(c.getFechaCreacion())).setHeader(\"Fecha Creacion\").setWidth(\"250px\").setFlexGrow(0);\n        return grid;\n\t}","cleancode":"private grid<cuenta> creategrid() { grid = new grid<>(); grid.setwidthfull(); grid.addthemevariants(gridvariant.lumo_no_border,gridvariant.lumo_row_stripes); simpledateformat dateformat = new simpledateformat(\"dd\/mm\/yyyy\"); grid.addcolumn(c -> c.getiban()).setheader(\"iban\").setflexgrow(1); grid.addcolumn(c -> c.getsaldo()).setheader(\"saldo\").setflexgrow(1); grid.addcolumn(c -> dateformat.format(c.getfechacreacion())).setheader(\"fecha creacion\").setwidth(\"250px\").setflexgrow(0); return grid; }","repo":"juansgonzalez\/ingenia-bank","label":[0,0,0,0]}
{"id":7744,"original_code":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n            \"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n            \"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n            \"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n            \"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n            \"RecyclerView is the same as what we expecting from the JSON.\")\n    @Test\n    public void hitList_isCorrect() {\n        \/\/ TODO write me\n    }","code_wo_comment":"@Ignore(\"This test was not writted due to lack of time. This is what should have been done:\\n\" +\n            \"Since this feature involves network calls, to properly unit test this it, is necessary\\n\" +\n            \"to mock the Network module and provide a fake JSON response. This way the test doesn't\\n\" +\n            \"rely on an internet connection, a web service and the JSON response is always the same.\\n\" +\n            \"Once we have that it is possible tu use assertj-android to check if the data inside the\\n\" +\n            \"RecyclerView is the same as what we expecting from the JSON.\")\n    @Test\n    public void hitList_isCorrect() {\n       \n    }","cleancode":"@ignore(\"this test was not writted due to lack of time. this is what should have been done:\\n\" + \"since this feature involves network calls, to properly unit test this it, is necessary\\n\" + \"to mock the network module and provide a fake json response. this way the test doesn't\\n\" + \"rely on an internet connection, a web service and the json response is always the same.\\n\" + \"once we have that it is possible tu use assertj-android to check if the data inside the\\n\" + \"recyclerview is the same as what we expecting from the json.\") @test public void hitlist_iscorrect() { }","repo":"leinardi\/Dagger2MVP","label":[0,1,0,0]}
{"id":24143,"original_code":"@Override\n        public boolean equals(Object obj) {\n            \/\/ TODO: come up with a better implementation of this later\n            return false;\n        }","code_wo_comment":"@Override\n        public boolean equals(Object obj) {\n           \n            return false;\n        }","cleancode":"@override public boolean equals(object obj) { return false; }","repo":"kaubster\/se-577-group-projects","label":[1,0,0,0]}
{"id":7766,"original_code":"@Test\n\tpublic void testPaginate() throws Exception {\n\t\t\/\/fail(\"Test not implemented yet.\");\n\t\t\/\/TODO: do later\n\t}","code_wo_comment":"@Test\n\tpublic void testPaginate() throws Exception {\n\t\n\t\n\t}","cleancode":"@test public void testpaginate() throws exception { }","repo":"mkalus\/segrada","label":[0,0,0,1]}
{"id":7935,"original_code":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\t\t\/\/ WARNING\n\t\t\/\/ INCOMPLETE see processSubtypeConstraints\n\t\tTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\n\t\tFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\n\t\tView view = RRef.view();\n\t\tTypeReference SprimeRef = box(Sref);\n\t\tJava7 java = view.language(Java7.class);\n\t\tif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\t\t  \/\/ the constraint S >> R', provided R is not void\t\n\t\t\tTypeReference RprimeRef = substitutedReference(RRef);\n\t\t\tconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n\t\t}\n\t\t\/\/ additional constraints Bi[T1=B(T1) ... Tn=B(Tn)] >> Ti where Bi is the declared bound of Ti\n\t\tfor(TypeParameter param: typeParameters()) {\n\t\t\tTypeReference Bi = param.upperBoundReference();\n\t\t\tTypeReference BiAfterSubstitution = substitutedReference(Bi);\n\t\t\tType Ti = (Type) param.selectionDeclaration();\n\t\t\tType BTi = assignments().type(param);\n\t\t\tif(BTi == null) {\n\t\t\t\tBTi = Ti;\n\t\t\t}\n\t\t\tconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\n\t\t\tconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n\t\t}\n\t\tfor(GGConstraint constraint: _origin.generatedGG()) {\n\t\t\tconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tfor(EQConstraint constraint: _origin.generatedEQ()) {\n\t\t\tconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\t\t\/\/ JLS: Any equality constraints are resolved ...\n\t\tseconds.processEqualityConstraints();\n\t\t\/\/ JLS: ..., and then, for each remaining constraint of the form Ti <: Uk, the argument\n\t\t\/\/      Ti is inferred to be glb(U1,...,Uk)\n\t\tseconds.processSubtypeConstraints();\n\t\t\/\/Any remaining type variable T that has not yet been inferred is then inferred\n\t\t\/\/ to have type Object . If a previously inferred type variable P uses T , then P is\n\t\t\/\/ inferred to be P [T =Object ].\n\t\tfor(TypeParameter param: seconds.unresolvedParameters()) {\n\t\t\tseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n\t\t}\n  \t\/\/FIXME Perform substitution\n\t\tfor(TypeParameter param: unresolvedParameters()) {\n\t\t\tadd(seconds.assignments().assignment(param));\n\t\t}\n\t}","code_wo_comment":"private void processUnresolved(TypeReference Sref) throws LookupException {\n\t\n\t\n\t\tTypeReference RRef = (TypeReference) invokedGenericMethod().returnTypeReference();\n\t\tFirstPhaseConstraintSet constraints = new FirstPhaseConstraintSet(invocation(), invokedGenericMethod());\n\t\tView view = RRef.view();\n\t\tTypeReference SprimeRef = box(Sref);\n\t\tJava7 java = view.language(Java7.class);\n\t\tif(! RRef.getElement().sameAs(java.voidType(RRef.view().namespace()))) {\n\t\t \n\t\t\tTypeReference RprimeRef = substitutedReference(RRef);\n\t\t\tconstraints.add(new GGConstraint(SprimeRef, RprimeRef.getElement()));\n\t\t}\n\t\n\t\tfor(TypeParameter param: typeParameters()) {\n\t\t\tTypeReference Bi = param.upperBoundReference();\n\t\t\tTypeReference BiAfterSubstitution = substitutedReference(Bi);\n\t\t\tType Ti = (Type) param.selectionDeclaration();\n\t\t\tType BTi = assignments().type(param);\n\t\t\tif(BTi == null) {\n\t\t\t\tBTi = Ti;\n\t\t\t}\n\t\t\tconstraints.add(new GGConstraint(BiAfterSubstitution, Ti));\n\t\t\tconstraints.add(new SSConstraint(java.reference(BTi), BiAfterSubstitution.getElement()));\n\t\t}\n\t\tfor(GGConstraint constraint: _origin.generatedGG()) {\n\t\t\tconstraints.add(new GGConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tfor(EQConstraint constraint: _origin.generatedEQ()) {\n\t\t\tconstraints.add(new EQConstraint(substitutedReference(constraint.ARef()), constraint.F()));\n\t\t}\n\t\tSecondPhaseConstraintSet seconds = constraints.secondPhase();\n\t\n\t\tseconds.processEqualityConstraints();\n\t\n\t\n\t\tseconds.processSubtypeConstraints();\n\t\n\t\n\t\n\t\tfor(TypeParameter param: seconds.unresolvedParameters()) {\n\t\t\tseconds.add(new ActualTypeAssignment(param, java.getDefaultSuperClass(view.namespace())));\n\t\t}\n  \n\t\tfor(TypeParameter param: unresolvedParameters()) {\n\t\t\tadd(seconds.assignments().assignment(param));\n\t\t}\n\t}","cleancode":"private void processunresolved(typereference sref) throws lookupexception { typereference rref = (typereference) invokedgenericmethod().returntypereference(); firstphaseconstraintset constraints = new firstphaseconstraintset(invocation(), invokedgenericmethod()); view view = rref.view(); typereference sprimeref = box(sref); java7 java = view.language(java7.class); if(! rref.getelement().sameas(java.voidtype(rref.view().namespace()))) { typereference rprimeref = substitutedreference(rref); constraints.add(new ggconstraint(sprimeref, rprimeref.getelement())); } for(typeparameter param: typeparameters()) { typereference bi = param.upperboundreference(); typereference biaftersubstitution = substitutedreference(bi); type ti = (type) param.selectiondeclaration(); type bti = assignments().type(param); if(bti == null) { bti = ti; } constraints.add(new ggconstraint(biaftersubstitution, ti)); constraints.add(new ssconstraint(java.reference(bti), biaftersubstitution.getelement())); } for(ggconstraint constraint: _origin.generatedgg()) { constraints.add(new ggconstraint(substitutedreference(constraint.aref()), constraint.f())); } for(eqconstraint constraint: _origin.generatedeq()) { constraints.add(new eqconstraint(substitutedreference(constraint.aref()), constraint.f())); } secondphaseconstraintset seconds = constraints.secondphase(); seconds.processequalityconstraints(); seconds.processsubtypeconstraints(); for(typeparameter param: seconds.unresolvedparameters()) { seconds.add(new actualtypeassignment(param, java.getdefaultsuperclass(view.namespace()))); } for(typeparameter param: unresolvedparameters()) { add(seconds.assignments().assignment(param)); } }","repo":"markovandooren\/jnome","label":[0,1,0,0]}
